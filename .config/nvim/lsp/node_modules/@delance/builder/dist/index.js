import { createRequire } from "node:module";
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// transform/webcrack/index.ts
import { getQuickJS, shouldInterruptAfterDeadline } from "quickjs-emscripten";

// /home/mochaa/ghq/git.sr.ht/~self/delance-builder/node_modules/webcrack/src/deobfuscate/index.ts
import debug3 from "debug";

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/ast-utils/ast.ts
import * as t from "@babel/types";
function getPropName(node) {
  if (t.isIdentifier(node)) {
    return node.name;
  }
  if (t.isStringLiteral(node)) {
    return node.value;
  }
  if (t.isNumericLiteral(node)) {
    return node.value.toString();
  }
}
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/ast-utils/generator.ts
import babelGenerate from "@babel/generator";
var defaultOptions = { jsescOption: { minimal: true } };
function generate(ast, options = defaultOptions) {
  return babelGenerate(ast, options).code;
}
function codePreview(node) {
  const code = generate(node, {
    minified: true,
    shouldPrintComment: () => false,
    ...defaultOptions
  });
  if (code.length > 100) {
    return code.slice(0, 70) + " \u2026 " + code.slice(-30);
  }
  return code;
}
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/ast-utils/inline.ts
import traverse2 from "@babel/traverse";
import * as t13 from "@babel/types";

// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/anyExpression.ts
import * as t2 from "@babel/types";

// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/Matcher.ts
class Matcher {
  match(value, keys = []) {
    return this.matchValue(value, keys);
  }
  matchValue(value, keys) {
    throw new Error(`${this.constructor.name}#matchValue is not implemented`);
  }
}

// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/anyExpression.ts
class AnyExpressionMatcher extends Matcher {
  matchValue(value) {
    return t2.isNode(value) && t2.isExpression(value);
  }
}
function anyExpression() {
  return new AnyExpressionMatcher;
}
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/utils/distributeAcrossSlices.ts
function* distributeAcrossSlices(slices, available) {
  if (slices.length === 0) {
    yield [];
  } else if (slices.length === 1) {
    const spacer = slices[0];
    if (spacer.min <= available && available <= spacer.max) {
      yield [available];
    }
  } else {
    const last = slices[slices.length - 1];
    for (let allocateToLast = last.min;allocateToLast <= last.max && allocateToLast <= available; allocateToLast++) {
      const allButLast = slices.slice(0, -1);
      for (const allButLastAllocations of distributeAcrossSlices(allButLast, available - allocateToLast)) {
        yield [...allButLastAllocations, allocateToLast];
      }
    }
  }
}

// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/anything.ts
class AnythingMatcher extends Matcher {
  matchValue(value) {
    return true;
  }
}
function anything() {
  return new AnythingMatcher;
}

// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/slice.ts
class SliceMatcher extends Matcher {
  min;
  max;
  matcher;
  constructor(min, max, matcher) {
    super();
    this.min = min;
    this.max = max;
    this.matcher = matcher;
  }
  matchValue(value, keys) {
    return this.matcher.matchValue(value, keys);
  }
}
function zeroOrMore(matcher = anything()) {
  return new SliceMatcher(0, Infinity, matcher);
}
function oneOrMore(matcher = anything()) {
  return new SliceMatcher(1, Infinity, matcher);
}
function slice(optionsOrLength, matcherOrUndefined) {
  let min;
  let max;
  let matcher;
  if (typeof optionsOrLength === "number") {
    min = optionsOrLength;
    max = optionsOrLength;
    matcher = matcherOrUndefined ?? anything();
  } else if (typeof optionsOrLength === "object" && typeof matcherOrUndefined === "undefined") {
    min = optionsOrLength.min ?? 0;
    max = optionsOrLength.max ?? Infinity;
    matcher = optionsOrLength.matcher ?? anything();
  } else {
    throw new Error("Invalid arguments");
  }
  return new SliceMatcher(min, max, matcher);
}

// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/anyList.ts
class AnyListMatcher extends Matcher {
  matchers;
  sliceMatchers = [];
  constructor(matchers) {
    super();
    this.matchers = matchers;
    for (const matcher of matchers) {
      if (matcher instanceof SliceMatcher) {
        this.sliceMatchers.push(matcher);
      }
    }
  }
  matchValue(array, keys) {
    if (!Array.isArray(array)) {
      return false;
    }
    if (this.matchers.length === 0 && array.length === 0) {
      return true;
    }
    const spacerAllocations = distributeAcrossSlices(this.sliceMatchers, array.length - this.matchers.length + this.sliceMatchers.length);
    for (const allocations of spacerAllocations) {
      const valuesToMatch = array.slice();
      let matchedAll = true;
      let key = 0;
      for (const matcher of this.matchers) {
        if (matcher instanceof SliceMatcher) {
          let sliceValueCount = allocations.shift() || 0;
          while (sliceValueCount > 0) {
            const valueToMatch = valuesToMatch.shift();
            if (!matcher.matchValue(valueToMatch, [...keys, key])) {
              matchedAll = false;
              break;
            }
            sliceValueCount--;
            key++;
          }
        } else if (!matcher.matchValue(valuesToMatch.shift(), [...keys, key])) {
          matchedAll = false;
          break;
        } else {
          key++;
        }
      }
      if (matchedAll) {
        if (valuesToMatch.length > 0) {
          throw new Error(`expected to consume all elements to match but ${valuesToMatch.length} remain!`);
        }
        return true;
      }
    }
    return false;
  }
}
function anyList(...elements) {
  return new AnyListMatcher(elements);
}
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/anyNode.ts
import * as t3 from "@babel/types";
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/anyStatement.ts
import * as t4 from "@babel/types";
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/anyString.ts
class StringMatcher extends Matcher {
  matchValue(value) {
    return typeof value === "string" || value instanceof String;
  }
}
function anyString() {
  return new StringMatcher;
}
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/arrayOf.ts
class ArrayOfMatcher extends Matcher {
  elementMatcher;
  constructor(elementMatcher) {
    super();
    this.elementMatcher = elementMatcher;
  }
  matchValue(value, keys) {
    if (!Array.isArray(value)) {
      return false;
    }
    for (const [i, element] of value.entries()) {
      if (!this.elementMatcher.matchValue(element, [...keys, i])) {
        return false;
      }
    }
    return true;
  }
}
function arrayOf(elementMatcher) {
  return new ArrayOfMatcher(elementMatcher);
}
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/capture.ts
class CapturedMatcher extends Matcher {
  matcher;
  _current;
  _currentKeys;
  constructor(matcher = anything()) {
    super();
    this.matcher = matcher;
  }
  get current() {
    return this._current;
  }
  get currentKeys() {
    return this._currentKeys;
  }
  matchValue(value, keys) {
    if (this.matcher.matchValue(value, keys)) {
      this.capture(value, keys);
      return true;
    } else {
      return false;
    }
  }
  capture(value, keys) {
    this._current = value;
    this._currentKeys = keys;
  }
}
function capture(matcher) {
  return new CapturedMatcher(matcher);
}
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/containerOf.ts
import * as t5 from "@babel/types";
class ContainerOfMatcher extends CapturedMatcher {
  containedMatcher;
  constructor(containedMatcher) {
    super();
    this.containedMatcher = containedMatcher;
  }
  matchValue(value, keys) {
    if (!t5.isNode(value)) {
      return false;
    }
    if (this.containedMatcher.matchValue(value, keys)) {
      this.capture(value, keys);
      return true;
    }
    for (const key in value) {
      const valueAtKey = value[key];
      if (Array.isArray(valueAtKey)) {
        for (const [i, element] of valueAtKey.entries()) {
          if (this.matchValue(element, [...keys, key, i])) {
            return true;
          }
        }
      } else if (this.matchValue(valueAtKey, [...keys, key])) {
        return true;
      }
    }
    return false;
  }
}
function containerOf(containedMatcher) {
  return new ContainerOfMatcher(containedMatcher);
}
// /home/mochaa/ghq/git.sr.ht/~self/delance-builder/node_modules/@codemod/utils/src/index.ts
import * as Babel from "@babel/core";
import * as t9 from "@babel/types";

// node_modules/.pnpm/@codemod+utils@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+utils&co_nwjtgzgerilv5helbn32zsr2ei/node_modules/@codemod/utils/src/NodeTypes.ts
import * as t6 from "@babel/types";
var { BUILDER_KEYS, NODE_FIELDS } = t6;
// node_modules/.pnpm/@codemod+utils@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+utils&co_nwjtgzgerilv5helbn32zsr2ei/node_modules/@codemod/utils/src/builders.ts
import traverse from "@babel/traverse";
import * as t7 from "@babel/types";

// /home/mochaa/ghq/git.sr.ht/~self/delance-builder/node_modules/@codemod/parser/src/index.ts
import {
  parse as babelParse
} from "@babel/parser";

// node_modules/.pnpm/@codemod+parser@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+parser&_ox3mjiaipayjwtjxtrryvsdtqu/node_modules/@codemod/parser/src/options.ts
var DefaultParserPlugins = new Set([
  "asyncGenerators",
  "bigInt",
  "classPrivateMethods",
  "classPrivateProperties",
  "classProperties",
  "doExpressions",
  "dynamicImport",
  "exportDefaultFrom",
  "exportNamespaceFrom",
  "functionBind",
  "functionSent",
  "importAssertions",
  "importMeta",
  "jsx",
  "logicalAssignment",
  "nullishCoalescingOperator",
  "numericSeparator",
  "objectRestSpread",
  "optionalCatchBinding",
  "optionalChaining",
  "partialApplication",
  "throwExpressions",
  "topLevelAwait",
  ["decorators", { decoratorsBeforeExport: true }],
  "decorators-legacy",
  ["pipelineOperator", { proposal: "minimal" }],
  ["recordAndTuple", { syntaxType: "hash" }]
]);
// node_modules/.pnpm/@codemod+utils@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+utils&co_nwjtgzgerilv5helbn32zsr2ei/node_modules/@codemod/utils/src/nodesEquivalent.ts
import * as t8 from "@babel/types";
function nodesEquivalent(a, b) {
  if (a === b) {
    return true;
  }
  if (a.type !== b.type) {
    return false;
  }
  const fields = NODE_FIELDS[a.type];
  const aProps = a;
  const bProps = b;
  for (const [k, field] of Object.entries(fields)) {
    const key = k;
    if (field.optional && aProps[key] == null && bProps[key] == null) {
      continue;
    }
    const aVal = aProps[key];
    const bVal = bProps[key];
    if (aVal === bVal) {
      continue;
    }
    if (aVal == null || bVal == null) {
      return false;
    }
    if (Array.isArray(aVal) && Array.isArray(bVal)) {
      if (aVal.length !== bVal.length) {
        return false;
      }
      for (let i = 0;i < aVal.length; i++) {
        if (!nodesEquivalent(aVal[i], bVal[i])) {
          return false;
        }
      }
      continue;
    }
    if (t8.isNode(aVal) && t8.isNode(bVal)) {
      if (!nodesEquivalent(aVal, bVal)) {
        return false;
      }
      continue;
    }
    return false;
  }
  return true;
}
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/fromCapture.ts
class FromCaptureMatcher extends Matcher {
  capturedMatcher;
  constructor(capturedMatcher) {
    super();
    this.capturedMatcher = capturedMatcher;
  }
  matchValue(value) {
    if (t9.isNode(this.capturedMatcher.current) && t9.isNode(value)) {
      return nodesEquivalent(this.capturedMatcher.current, value);
    }
    return this.capturedMatcher.current === value;
  }
}
function fromCapture(capturedMatcher) {
  return new FromCaptureMatcher(capturedMatcher);
}
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/function.ts
import * as t10 from "@babel/types";

// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/tupleOf.ts
class TupleOfMatcher extends Matcher {
  matchers;
  constructor(...matchers) {
    super();
    this.matchers = matchers;
  }
  matchValue(value, keys) {
    if (!Array.isArray(value)) {
      return false;
    }
    if (value.length !== this.matchers.length) {
      return false;
    }
    for (let i = 0;i < this.matchers.length; i++) {
      const matcher = this.matchers[i];
      const element = value[i];
      if (!matcher.matchValue(element, [...keys, i])) {
        return false;
      }
    }
    return true;
  }
}
function tupleOf(...matchers) {
  return new TupleOfMatcher(...matchers);
}
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/generated.ts
import * as t11 from "@babel/types";
class ArrayExpressionMatcher extends Matcher {
  elements;
  constructor(elements) {
    super();
    this.elements = elements;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isArrayExpression(node)) {
      return false;
    }
    if (typeof this.elements === "undefined") {
    } else if (Array.isArray(this.elements)) {
      if (!tupleOf(...this.elements).matchValue(node.elements, [
        ...keys,
        "elements"
      ])) {
        return false;
      }
    } else if (!this.elements.matchValue(node.elements, [...keys, "elements"])) {
      return false;
    }
    return true;
  }
}
function arrayExpression(elements) {
  return new ArrayExpressionMatcher(elements);
}

class ArrayPatternMatcher extends Matcher {
  elements;
  constructor(elements) {
    super();
    this.elements = elements;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isArrayPattern(node)) {
      return false;
    }
    if (typeof this.elements === "undefined") {
    } else if (Array.isArray(this.elements)) {
      if (!tupleOf(...this.elements).matchValue(node.elements, [
        ...keys,
        "elements"
      ])) {
        return false;
      }
    } else if (!this.elements.matchValue(node.elements, [...keys, "elements"])) {
      return false;
    }
    return true;
  }
}
function arrayPattern(elements) {
  return new ArrayPatternMatcher(elements);
}
class ArrowFunctionExpressionMatcher extends Matcher {
  params;
  body;
  async;
  constructor(params, body, async) {
    super();
    this.params = params;
    this.body = body;
    this.async = async;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isArrowFunctionExpression(node)) {
      return false;
    }
    if (typeof this.params === "undefined") {
    } else if (Array.isArray(this.params)) {
      if (!tupleOf(...this.params).matchValue(node.params, [
        ...keys,
        "params"
      ])) {
        return false;
      }
    } else if (!this.params.matchValue(node.params, [...keys, "params"])) {
      return false;
    }
    if (typeof this.body === "undefined") {
    } else if (!this.body.matchValue(node.body, [...keys, "body"])) {
      return false;
    }
    if (typeof this.async === "undefined") {
    } else if (typeof this.async === "boolean") {
      if (this.async !== node.async) {
        return false;
      }
    } else if (!this.async.matchValue(node.async, [...keys, "async"])) {
      return false;
    }
    return true;
  }
}
function arrowFunctionExpression(params, body, async) {
  return new ArrowFunctionExpressionMatcher(params, body, async);
}

class AssignmentExpressionMatcher extends Matcher {
  operator;
  left;
  right;
  constructor(operator, left, right) {
    super();
    this.operator = operator;
    this.left = left;
    this.right = right;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isAssignmentExpression(node)) {
      return false;
    }
    if (typeof this.operator === "undefined") {
    } else if (typeof this.operator === "string") {
      if (this.operator !== node.operator) {
        return false;
      }
    } else if (!this.operator.matchValue(node.operator, [...keys, "operator"])) {
      return false;
    }
    if (typeof this.left === "undefined") {
    } else if (!this.left.matchValue(node.left, [...keys, "left"])) {
      return false;
    }
    if (typeof this.right === "undefined") {
    } else if (!this.right.matchValue(node.right, [...keys, "right"])) {
      return false;
    }
    return true;
  }
}
function assignmentExpression(operator, left, right) {
  return new AssignmentExpressionMatcher(operator, left, right);
}
class BinaryExpressionMatcher extends Matcher {
  operator;
  left;
  right;
  constructor(operator, left, right) {
    super();
    this.operator = operator;
    this.left = left;
    this.right = right;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isBinaryExpression(node)) {
      return false;
    }
    if (typeof this.operator === "undefined") {
    } else if (typeof this.operator === "string") {
      if (this.operator !== node.operator) {
        return false;
      }
    } else if (!this.operator.matchValue(node.operator, [...keys, "operator"])) {
      return false;
    }
    if (typeof this.left === "undefined") {
    } else if (!this.left.matchValue(node.left, [...keys, "left"])) {
      return false;
    }
    if (typeof this.right === "undefined") {
    } else if (!this.right.matchValue(node.right, [...keys, "right"])) {
      return false;
    }
    return true;
  }
}
function binaryExpression(operator, left, right) {
  return new BinaryExpressionMatcher(operator, left, right);
}
class BlockStatementMatcher extends Matcher {
  body;
  directives;
  constructor(body, directives) {
    super();
    this.body = body;
    this.directives = directives;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isBlockStatement(node)) {
      return false;
    }
    if (typeof this.body === "undefined") {
    } else if (Array.isArray(this.body)) {
      if (!tupleOf(...this.body).matchValue(node.body, [...keys, "body"])) {
        return false;
      }
    } else if (!this.body.matchValue(node.body, [...keys, "body"])) {
      return false;
    }
    if (typeof this.directives === "undefined") {
    } else if (Array.isArray(this.directives)) {
      if (!tupleOf(...this.directives).matchValue(node.directives, [
        ...keys,
        "directives"
      ])) {
        return false;
      }
    } else if (!this.directives.matchValue(node.directives, [...keys, "directives"])) {
      return false;
    }
    return true;
  }
}
function blockStatement(body, directives) {
  return new BlockStatementMatcher(body, directives);
}

class BooleanLiteralMatcher extends Matcher {
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isBooleanLiteral(node)) {
      return false;
    }
    if (typeof this.value === "undefined") {
    } else if (typeof this.value === "boolean") {
      if (this.value !== node.value) {
        return false;
      }
    } else if (!this.value.matchValue(node.value, [...keys, "value"])) {
      return false;
    }
    return true;
  }
}
function booleanLiteral(value) {
  return new BooleanLiteralMatcher(value);
}
class BreakStatementMatcher extends Matcher {
  label;
  constructor(label) {
    super();
    this.label = label;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isBreakStatement(node)) {
      return false;
    }
    if (typeof this.label === "undefined") {
    } else if (this.label === null) {
      if (node.label !== null) {
        return false;
      }
    } else if (!this.label.matchValue(node.label, [...keys, "label"])) {
      return false;
    }
    return true;
  }
}
function breakStatement(label) {
  return new BreakStatementMatcher(label);
}

class CallExpressionMatcher extends Matcher {
  callee;
  _arguments;
  constructor(callee, _arguments) {
    super();
    this.callee = callee;
    this._arguments = _arguments;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isCallExpression(node)) {
      return false;
    }
    if (typeof this.callee === "undefined") {
    } else if (!this.callee.matchValue(node.callee, [...keys, "callee"])) {
      return false;
    }
    if (typeof this._arguments === "undefined") {
    } else if (Array.isArray(this._arguments)) {
      if (!tupleOf(...this._arguments).matchValue(node.arguments, [
        ...keys,
        "arguments"
      ])) {
        return false;
      }
    } else if (!this._arguments.matchValue(node.arguments, [...keys, "arguments"])) {
      return false;
    }
    return true;
  }
}
function callExpression(callee, _arguments) {
  return new CallExpressionMatcher(callee, _arguments);
}
class ClassMethodMatcher extends Matcher {
  kind;
  key;
  params;
  body;
  computed;
  _static;
  generator;
  async;
  constructor(kind, key, params, body, computed, _static, generator, async) {
    super();
    this.kind = kind;
    this.key = key;
    this.params = params;
    this.body = body;
    this.computed = computed;
    this._static = _static;
    this.generator = generator;
    this.async = async;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isClassMethod(node)) {
      return false;
    }
    if (typeof this.kind === "undefined") {
    } else if (typeof this.kind === "string") {
      if (this.kind !== node.kind) {
        return false;
      }
    } else if (!this.kind.matchValue(node.kind, [...keys, "kind"])) {
      return false;
    }
    if (typeof this.key === "undefined") {
    } else if (!this.key.matchValue(node.key, [...keys, "key"])) {
      return false;
    }
    if (typeof this.params === "undefined") {
    } else if (Array.isArray(this.params)) {
      if (!tupleOf(...this.params).matchValue(node.params, [
        ...keys,
        "params"
      ])) {
        return false;
      }
    } else if (!this.params.matchValue(node.params, [...keys, "params"])) {
      return false;
    }
    if (typeof this.body === "undefined") {
    } else if (!this.body.matchValue(node.body, [...keys, "body"])) {
      return false;
    }
    if (typeof this.computed === "undefined") {
    } else if (typeof this.computed === "boolean") {
      if (this.computed !== node.computed) {
        return false;
      }
    } else if (!this.computed.matchValue(node.computed, [...keys, "computed"])) {
      return false;
    }
    if (typeof this._static === "undefined") {
    } else if (typeof this._static === "boolean") {
      if (this._static !== node.static) {
        return false;
      }
    } else if (!this._static.matchValue(node.static, [...keys, "static"])) {
      return false;
    }
    if (typeof this.generator === "undefined") {
    } else if (typeof this.generator === "boolean") {
      if (this.generator !== node.generator) {
        return false;
      }
    } else if (!this.generator.matchValue(node.generator, [...keys, "generator"])) {
      return false;
    }
    if (typeof this.async === "undefined") {
    } else if (typeof this.async === "boolean") {
      if (this.async !== node.async) {
        return false;
      }
    } else if (!this.async.matchValue(node.async, [...keys, "async"])) {
      return false;
    }
    return true;
  }
}
function classMethod(kind, key, params, body, computed, _static, generator, async) {
  return new ClassMethodMatcher(kind, key, params, body, computed, _static, generator, async);
}
class ClassPropertyMatcher extends Matcher {
  key;
  value;
  typeAnnotation;
  decorators;
  computed;
  _static;
  constructor(key, value, typeAnnotation, decorators, computed, _static) {
    super();
    this.key = key;
    this.value = value;
    this.typeAnnotation = typeAnnotation;
    this.decorators = decorators;
    this.computed = computed;
    this._static = _static;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isClassProperty(node)) {
      return false;
    }
    if (typeof this.key === "undefined") {
    } else if (!this.key.matchValue(node.key, [...keys, "key"])) {
      return false;
    }
    if (typeof this.value === "undefined") {
    } else if (this.value === null) {
      if (node.value !== null) {
        return false;
      }
    } else if (!this.value.matchValue(node.value, [...keys, "value"])) {
      return false;
    }
    if (typeof this.typeAnnotation === "undefined") {
    } else if (this.typeAnnotation === null) {
      if (node.typeAnnotation !== null) {
        return false;
      }
    } else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
      ...keys,
      "typeAnnotation"
    ])) {
      return false;
    }
    if (typeof this.decorators === "undefined") {
    } else if (this.decorators === null) {
      if (node.decorators !== null) {
        return false;
      }
    } else if (Array.isArray(this.decorators)) {
      if (!tupleOf(...this.decorators).matchValue(node.decorators, [
        ...keys,
        "decorators"
      ])) {
        return false;
      }
    } else if (!this.decorators.matchValue(node.decorators, [...keys, "decorators"])) {
      return false;
    }
    if (typeof this.computed === "undefined") {
    } else if (typeof this.computed === "boolean") {
      if (this.computed !== node.computed) {
        return false;
      }
    } else if (!this.computed.matchValue(node.computed, [...keys, "computed"])) {
      return false;
    }
    if (typeof this._static === "undefined") {
    } else if (typeof this._static === "boolean") {
      if (this._static !== node.static) {
        return false;
      }
    } else if (!this._static.matchValue(node.static, [...keys, "static"])) {
      return false;
    }
    return true;
  }
}
function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
  return new ClassPropertyMatcher(key, value, typeAnnotation, decorators, computed, _static);
}

class ConditionalExpressionMatcher extends Matcher {
  test;
  consequent;
  alternate;
  constructor(test, consequent, alternate) {
    super();
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isConditionalExpression(node)) {
      return false;
    }
    if (typeof this.test === "undefined") {
    } else if (!this.test.matchValue(node.test, [...keys, "test"])) {
      return false;
    }
    if (typeof this.consequent === "undefined") {
    } else if (!this.consequent.matchValue(node.consequent, [...keys, "consequent"])) {
      return false;
    }
    if (typeof this.alternate === "undefined") {
    } else if (!this.alternate.matchValue(node.alternate, [...keys, "alternate"])) {
      return false;
    }
    return true;
  }
}
function conditionalExpression(test, consequent, alternate) {
  return new ConditionalExpressionMatcher(test, consequent, alternate);
}

class ContinueStatementMatcher extends Matcher {
  label;
  constructor(label) {
    super();
    this.label = label;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isContinueStatement(node)) {
      return false;
    }
    if (typeof this.label === "undefined") {
    } else if (this.label === null) {
      if (node.label !== null) {
        return false;
      }
    } else if (!this.label.matchValue(node.label, [...keys, "label"])) {
      return false;
    }
    return true;
  }
}
function continueStatement(label) {
  return new ContinueStatementMatcher(label);
}
class ExpressionStatementMatcher extends Matcher {
  expression;
  constructor(expression) {
    super();
    this.expression = expression;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isExpressionStatement(node)) {
      return false;
    }
    if (typeof this.expression === "undefined") {
    } else if (!this.expression.matchValue(node.expression, [...keys, "expression"])) {
      return false;
    }
    return true;
  }
}
function expressionStatement(expression) {
  return new ExpressionStatementMatcher(expression);
}
class ForInStatementMatcher extends Matcher {
  left;
  right;
  body;
  constructor(left, right, body) {
    super();
    this.left = left;
    this.right = right;
    this.body = body;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isForInStatement(node)) {
      return false;
    }
    if (typeof this.left === "undefined") {
    } else if (!this.left.matchValue(node.left, [...keys, "left"])) {
      return false;
    }
    if (typeof this.right === "undefined") {
    } else if (!this.right.matchValue(node.right, [...keys, "right"])) {
      return false;
    }
    if (typeof this.body === "undefined") {
    } else if (!this.body.matchValue(node.body, [...keys, "body"])) {
      return false;
    }
    return true;
  }
}
function forInStatement(left, right, body) {
  return new ForInStatementMatcher(left, right, body);
}
class ForStatementMatcher extends Matcher {
  init;
  test;
  update;
  body;
  constructor(init, test, update, body) {
    super();
    this.init = init;
    this.test = test;
    this.update = update;
    this.body = body;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isForStatement(node)) {
      return false;
    }
    if (typeof this.init === "undefined") {
    } else if (this.init === null) {
      if (node.init !== null) {
        return false;
      }
    } else if (!this.init.matchValue(node.init, [...keys, "init"])) {
      return false;
    }
    if (typeof this.test === "undefined") {
    } else if (this.test === null) {
      if (node.test !== null) {
        return false;
      }
    } else if (!this.test.matchValue(node.test, [...keys, "test"])) {
      return false;
    }
    if (typeof this.update === "undefined") {
    } else if (this.update === null) {
      if (node.update !== null) {
        return false;
      }
    } else if (!this.update.matchValue(node.update, [...keys, "update"])) {
      return false;
    }
    if (typeof this.body === "undefined") {
    } else if (!this.body.matchValue(node.body, [...keys, "body"])) {
      return false;
    }
    return true;
  }
}
function forStatement(init, test, update, body) {
  return new ForStatementMatcher(init, test, update, body);
}

class FunctionDeclarationMatcher extends Matcher {
  id;
  params;
  body;
  generator;
  async;
  constructor(id, params, body, generator, async) {
    super();
    this.id = id;
    this.params = params;
    this.body = body;
    this.generator = generator;
    this.async = async;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isFunctionDeclaration(node)) {
      return false;
    }
    if (typeof this.id === "undefined") {
    } else if (this.id === null) {
      if (node.id !== null) {
        return false;
      }
    } else if (!this.id.matchValue(node.id, [...keys, "id"])) {
      return false;
    }
    if (typeof this.params === "undefined") {
    } else if (Array.isArray(this.params)) {
      if (!tupleOf(...this.params).matchValue(node.params, [
        ...keys,
        "params"
      ])) {
        return false;
      }
    } else if (!this.params.matchValue(node.params, [...keys, "params"])) {
      return false;
    }
    if (typeof this.body === "undefined") {
    } else if (!this.body.matchValue(node.body, [...keys, "body"])) {
      return false;
    }
    if (typeof this.generator === "undefined") {
    } else if (typeof this.generator === "boolean") {
      if (this.generator !== node.generator) {
        return false;
      }
    } else if (!this.generator.matchValue(node.generator, [...keys, "generator"])) {
      return false;
    }
    if (typeof this.async === "undefined") {
    } else if (typeof this.async === "boolean") {
      if (this.async !== node.async) {
        return false;
      }
    } else if (!this.async.matchValue(node.async, [...keys, "async"])) {
      return false;
    }
    return true;
  }
}
function functionDeclaration(id, params, body, generator, async) {
  return new FunctionDeclarationMatcher(id, params, body, generator, async);
}

class FunctionExpressionMatcher extends Matcher {
  id;
  params;
  body;
  generator;
  async;
  constructor(id, params, body, generator, async) {
    super();
    this.id = id;
    this.params = params;
    this.body = body;
    this.generator = generator;
    this.async = async;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isFunctionExpression(node)) {
      return false;
    }
    if (typeof this.id === "undefined") {
    } else if (this.id === null) {
      if (node.id !== null) {
        return false;
      }
    } else if (!this.id.matchValue(node.id, [...keys, "id"])) {
      return false;
    }
    if (typeof this.params === "undefined") {
    } else if (Array.isArray(this.params)) {
      if (!tupleOf(...this.params).matchValue(node.params, [
        ...keys,
        "params"
      ])) {
        return false;
      }
    } else if (!this.params.matchValue(node.params, [...keys, "params"])) {
      return false;
    }
    if (typeof this.body === "undefined") {
    } else if (!this.body.matchValue(node.body, [...keys, "body"])) {
      return false;
    }
    if (typeof this.generator === "undefined") {
    } else if (typeof this.generator === "boolean") {
      if (this.generator !== node.generator) {
        return false;
      }
    } else if (!this.generator.matchValue(node.generator, [...keys, "generator"])) {
      return false;
    }
    if (typeof this.async === "undefined") {
    } else if (typeof this.async === "boolean") {
      if (this.async !== node.async) {
        return false;
      }
    } else if (!this.async.matchValue(node.async, [...keys, "async"])) {
      return false;
    }
    return true;
  }
}
function functionExpression(id, params, body, generator, async) {
  return new FunctionExpressionMatcher(id, params, body, generator, async);
}
class IdentifierMatcher extends Matcher {
  name;
  constructor(name) {
    super();
    this.name = name;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isIdentifier(node)) {
      return false;
    }
    if (typeof this.name === "undefined") {
    } else if (typeof this.name === "string") {
      if (this.name !== node.name) {
        return false;
      }
    } else if (!this.name.matchValue(node.name, [...keys, "name"])) {
      return false;
    }
    return true;
  }
}
function identifier(name) {
  return new IdentifierMatcher(name);
}

class IfStatementMatcher extends Matcher {
  test;
  consequent;
  alternate;
  constructor(test, consequent, alternate) {
    super();
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isIfStatement(node)) {
      return false;
    }
    if (typeof this.test === "undefined") {
    } else if (!this.test.matchValue(node.test, [...keys, "test"])) {
      return false;
    }
    if (typeof this.consequent === "undefined") {
    } else if (!this.consequent.matchValue(node.consequent, [...keys, "consequent"])) {
      return false;
    }
    if (typeof this.alternate === "undefined") {
    } else if (this.alternate === null) {
      if (node.alternate !== null) {
        return false;
      }
    } else if (!this.alternate.matchValue(node.alternate, [...keys, "alternate"])) {
      return false;
    }
    return true;
  }
}
function ifStatement(test, consequent, alternate) {
  return new IfStatementMatcher(test, consequent, alternate);
}
class LogicalExpressionMatcher extends Matcher {
  operator;
  left;
  right;
  constructor(operator, left, right) {
    super();
    this.operator = operator;
    this.left = left;
    this.right = right;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isLogicalExpression(node)) {
      return false;
    }
    if (typeof this.operator === "undefined") {
    } else if (typeof this.operator === "string") {
      if (this.operator !== node.operator) {
        return false;
      }
    } else if (!this.operator.matchValue(node.operator, [...keys, "operator"])) {
      return false;
    }
    if (typeof this.left === "undefined") {
    } else if (!this.left.matchValue(node.left, [...keys, "left"])) {
      return false;
    }
    if (typeof this.right === "undefined") {
    } else if (!this.right.matchValue(node.right, [...keys, "right"])) {
      return false;
    }
    return true;
  }
}
function logicalExpression(operator, left, right) {
  return new LogicalExpressionMatcher(operator, left, right);
}

class MemberExpressionMatcher extends Matcher {
  object;
  property;
  computed;
  optional;
  constructor(object, property, computed, optional) {
    super();
    this.object = object;
    this.property = property;
    this.computed = computed;
    this.optional = optional;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isMemberExpression(node)) {
      return false;
    }
    if (typeof this.object === "undefined") {
    } else if (!this.object.matchValue(node.object, [...keys, "object"])) {
      return false;
    }
    if (typeof this.property === "undefined") {
    } else if (!this.property.matchValue(node.property, [...keys, "property"])) {
      return false;
    }
    if (typeof this.computed === "undefined") {
    } else if (typeof this.computed === "boolean") {
      if (this.computed !== node.computed) {
        return false;
      }
    } else if (!this.computed.matchValue(node.computed, [...keys, "computed"])) {
      return false;
    }
    if (typeof this.optional === "undefined") {
    } else if (typeof this.optional === "boolean") {
      if (this.optional !== node.optional) {
        return false;
      }
    } else if (this.optional === null) {
      if (node.optional !== null) {
        return false;
      }
    } else if (!this.optional.matchValue(node.optional, [...keys, "optional"])) {
      return false;
    }
    return true;
  }
}
function memberExpression(object, property, computed, optional) {
  return new MemberExpressionMatcher(object, property, computed, optional);
}
class NullLiteralMatcher extends Matcher {
  constructor() {
    super();
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isNullLiteral(node)) {
      return false;
    }
    return true;
  }
}
function nullLiteral() {
  return new NullLiteralMatcher;
}
class NumericLiteralMatcher extends Matcher {
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isNumericLiteral(node)) {
      return false;
    }
    if (typeof this.value === "undefined") {
    } else if (typeof this.value === "number") {
      if (this.value !== node.value) {
        return false;
      }
    } else if (!this.value.matchValue(node.value, [...keys, "value"])) {
      return false;
    }
    return true;
  }
}
function numericLiteral(value) {
  return new NumericLiteralMatcher(value);
}

class ObjectExpressionMatcher extends Matcher {
  properties;
  constructor(properties) {
    super();
    this.properties = properties;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isObjectExpression(node)) {
      return false;
    }
    if (typeof this.properties === "undefined") {
    } else if (Array.isArray(this.properties)) {
      if (!tupleOf(...this.properties).matchValue(node.properties, [
        ...keys,
        "properties"
      ])) {
        return false;
      }
    } else if (!this.properties.matchValue(node.properties, [...keys, "properties"])) {
      return false;
    }
    return true;
  }
}
function objectExpression(properties) {
  return new ObjectExpressionMatcher(properties);
}

class ObjectMethodMatcher extends Matcher {
  kind;
  key;
  params;
  body;
  computed;
  generator;
  async;
  constructor(kind, key, params, body, computed, generator, async) {
    super();
    this.kind = kind;
    this.key = key;
    this.params = params;
    this.body = body;
    this.computed = computed;
    this.generator = generator;
    this.async = async;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isObjectMethod(node)) {
      return false;
    }
    if (typeof this.kind === "undefined") {
    } else if (typeof this.kind === "string") {
      if (this.kind !== node.kind) {
        return false;
      }
    } else if (!this.kind.matchValue(node.kind, [...keys, "kind"])) {
      return false;
    }
    if (typeof this.key === "undefined") {
    } else if (!this.key.matchValue(node.key, [...keys, "key"])) {
      return false;
    }
    if (typeof this.params === "undefined") {
    } else if (Array.isArray(this.params)) {
      if (!tupleOf(...this.params).matchValue(node.params, [
        ...keys,
        "params"
      ])) {
        return false;
      }
    } else if (!this.params.matchValue(node.params, [...keys, "params"])) {
      return false;
    }
    if (typeof this.body === "undefined") {
    } else if (!this.body.matchValue(node.body, [...keys, "body"])) {
      return false;
    }
    if (typeof this.computed === "undefined") {
    } else if (typeof this.computed === "boolean") {
      if (this.computed !== node.computed) {
        return false;
      }
    } else if (!this.computed.matchValue(node.computed, [...keys, "computed"])) {
      return false;
    }
    if (typeof this.generator === "undefined") {
    } else if (typeof this.generator === "boolean") {
      if (this.generator !== node.generator) {
        return false;
      }
    } else if (!this.generator.matchValue(node.generator, [...keys, "generator"])) {
      return false;
    }
    if (typeof this.async === "undefined") {
    } else if (typeof this.async === "boolean") {
      if (this.async !== node.async) {
        return false;
      }
    } else if (!this.async.matchValue(node.async, [...keys, "async"])) {
      return false;
    }
    return true;
  }
}
function objectMethod(kind, key, params, body, computed, generator, async) {
  return new ObjectMethodMatcher(kind, key, params, body, computed, generator, async);
}

class ObjectPatternMatcher extends Matcher {
  properties;
  constructor(properties) {
    super();
    this.properties = properties;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isObjectPattern(node)) {
      return false;
    }
    if (typeof this.properties === "undefined") {
    } else if (Array.isArray(this.properties)) {
      if (!tupleOf(...this.properties).matchValue(node.properties, [
        ...keys,
        "properties"
      ])) {
        return false;
      }
    } else if (!this.properties.matchValue(node.properties, [...keys, "properties"])) {
      return false;
    }
    return true;
  }
}
function objectPattern(properties) {
  return new ObjectPatternMatcher(properties);
}

class ObjectPropertyMatcher extends Matcher {
  key;
  value;
  computed;
  shorthand;
  decorators;
  constructor(key, value, computed, shorthand, decorators) {
    super();
    this.key = key;
    this.value = value;
    this.computed = computed;
    this.shorthand = shorthand;
    this.decorators = decorators;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isObjectProperty(node)) {
      return false;
    }
    if (typeof this.key === "undefined") {
    } else if (!this.key.matchValue(node.key, [...keys, "key"])) {
      return false;
    }
    if (typeof this.value === "undefined") {
    } else if (!this.value.matchValue(node.value, [...keys, "value"])) {
      return false;
    }
    if (typeof this.computed === "undefined") {
    } else if (typeof this.computed === "boolean") {
      if (this.computed !== node.computed) {
        return false;
      }
    } else if (!this.computed.matchValue(node.computed, [...keys, "computed"])) {
      return false;
    }
    if (typeof this.shorthand === "undefined") {
    } else if (typeof this.shorthand === "boolean") {
      if (this.shorthand !== node.shorthand) {
        return false;
      }
    } else if (!this.shorthand.matchValue(node.shorthand, [...keys, "shorthand"])) {
      return false;
    }
    if (typeof this.decorators === "undefined") {
    } else if (this.decorators === null) {
      if (node.decorators !== null) {
        return false;
      }
    } else if (Array.isArray(this.decorators)) {
      if (!tupleOf(...this.decorators).matchValue(node.decorators, [
        ...keys,
        "decorators"
      ])) {
        return false;
      }
    } else if (!this.decorators.matchValue(node.decorators, [...keys, "decorators"])) {
      return false;
    }
    return true;
  }
}
function objectProperty(key, value, computed, shorthand, decorators) {
  return new ObjectPropertyMatcher(key, value, computed, shorthand, decorators);
}
class OptionalMemberExpressionMatcher extends Matcher {
  object;
  property;
  computed;
  optional;
  constructor(object, property, computed, optional) {
    super();
    this.object = object;
    this.property = property;
    this.computed = computed;
    this.optional = optional;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isOptionalMemberExpression(node)) {
      return false;
    }
    if (typeof this.object === "undefined") {
    } else if (!this.object.matchValue(node.object, [...keys, "object"])) {
      return false;
    }
    if (typeof this.property === "undefined") {
    } else if (!this.property.matchValue(node.property, [...keys, "property"])) {
      return false;
    }
    if (typeof this.computed === "undefined") {
    } else if (typeof this.computed === "boolean") {
      if (this.computed !== node.computed) {
        return false;
      }
    } else if (!this.computed.matchValue(node.computed, [...keys, "computed"])) {
      return false;
    }
    if (typeof this.optional === "undefined") {
    } else if (typeof this.optional === "boolean") {
      if (this.optional !== node.optional) {
        return false;
      }
    } else if (!this.optional.matchValue(node.optional, [...keys, "optional"])) {
      return false;
    }
    return true;
  }
}
function optionalMemberExpression(object, property, computed, optional) {
  return new OptionalMemberExpressionMatcher(object, property, computed, optional);
}
class RestElementMatcher extends Matcher {
  argument;
  constructor(argument) {
    super();
    this.argument = argument;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isRestElement(node)) {
      return false;
    }
    if (typeof this.argument === "undefined") {
    } else if (!this.argument.matchValue(node.argument, [...keys, "argument"])) {
      return false;
    }
    return true;
  }
}
function restElement(argument) {
  return new RestElementMatcher(argument);
}

class ReturnStatementMatcher extends Matcher {
  argument;
  constructor(argument) {
    super();
    this.argument = argument;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isReturnStatement(node)) {
      return false;
    }
    if (typeof this.argument === "undefined") {
    } else if (this.argument === null) {
      if (node.argument !== null) {
        return false;
      }
    } else if (!this.argument.matchValue(node.argument, [...keys, "argument"])) {
      return false;
    }
    return true;
  }
}
function returnStatement(argument) {
  return new ReturnStatementMatcher(argument);
}

class SequenceExpressionMatcher extends Matcher {
  expressions;
  constructor(expressions) {
    super();
    this.expressions = expressions;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isSequenceExpression(node)) {
      return false;
    }
    if (typeof this.expressions === "undefined") {
    } else if (Array.isArray(this.expressions)) {
      if (!tupleOf(...this.expressions).matchValue(node.expressions, [
        ...keys,
        "expressions"
      ])) {
        return false;
      }
    } else if (!this.expressions.matchValue(node.expressions, [...keys, "expressions"])) {
      return false;
    }
    return true;
  }
}
function sequenceExpression(expressions) {
  return new SequenceExpressionMatcher(expressions);
}

class SpreadElementMatcher extends Matcher {
  argument;
  constructor(argument) {
    super();
    this.argument = argument;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isSpreadElement(node)) {
      return false;
    }
    if (typeof this.argument === "undefined") {
    } else if (!this.argument.matchValue(node.argument, [...keys, "argument"])) {
      return false;
    }
    return true;
  }
}
function spreadElement(argument) {
  return new SpreadElementMatcher(argument);
}
class StringLiteralMatcher extends Matcher {
  value;
  constructor(value) {
    super();
    this.value = value;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isStringLiteral(node)) {
      return false;
    }
    if (typeof this.value === "undefined") {
    } else if (typeof this.value === "string") {
      if (this.value !== node.value) {
        return false;
      }
    } else if (!this.value.matchValue(node.value, [...keys, "value"])) {
      return false;
    }
    return true;
  }
}
function stringLiteral(value) {
  return new StringLiteralMatcher(value);
}
class SwitchCaseMatcher extends Matcher {
  test;
  consequent;
  constructor(test, consequent) {
    super();
    this.test = test;
    this.consequent = consequent;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isSwitchCase(node)) {
      return false;
    }
    if (typeof this.test === "undefined") {
    } else if (this.test === null) {
      if (node.test !== null) {
        return false;
      }
    } else if (!this.test.matchValue(node.test, [...keys, "test"])) {
      return false;
    }
    if (typeof this.consequent === "undefined") {
    } else if (Array.isArray(this.consequent)) {
      if (!tupleOf(...this.consequent).matchValue(node.consequent, [
        ...keys,
        "consequent"
      ])) {
        return false;
      }
    } else if (!this.consequent.matchValue(node.consequent, [...keys, "consequent"])) {
      return false;
    }
    return true;
  }
}
function switchCase(test, consequent) {
  return new SwitchCaseMatcher(test, consequent);
}

class SwitchStatementMatcher extends Matcher {
  discriminant;
  cases;
  constructor(discriminant, cases) {
    super();
    this.discriminant = discriminant;
    this.cases = cases;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isSwitchStatement(node)) {
      return false;
    }
    if (typeof this.discriminant === "undefined") {
    } else if (!this.discriminant.matchValue(node.discriminant, [
      ...keys,
      "discriminant"
    ])) {
      return false;
    }
    if (typeof this.cases === "undefined") {
    } else if (Array.isArray(this.cases)) {
      if (!tupleOf(...this.cases).matchValue(node.cases, [
        ...keys,
        "cases"
      ])) {
        return false;
      }
    } else if (!this.cases.matchValue(node.cases, [...keys, "cases"])) {
      return false;
    }
    return true;
  }
}
function switchStatement(discriminant, cases) {
  return new SwitchStatementMatcher(discriminant, cases);
}
class TemplateLiteralMatcher extends Matcher {
  quasis;
  expressions;
  constructor(quasis, expressions) {
    super();
    this.quasis = quasis;
    this.expressions = expressions;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isTemplateLiteral(node)) {
      return false;
    }
    if (typeof this.quasis === "undefined") {
    } else if (Array.isArray(this.quasis)) {
      if (!tupleOf(...this.quasis).matchValue(node.quasis, [
        ...keys,
        "quasis"
      ])) {
        return false;
      }
    } else if (!this.quasis.matchValue(node.quasis, [...keys, "quasis"])) {
      return false;
    }
    if (typeof this.expressions === "undefined") {
    } else if (Array.isArray(this.expressions)) {
      if (!tupleOf(...this.expressions).matchValue(node.expressions, [
        ...keys,
        "expressions"
      ])) {
        return false;
      }
    } else if (!this.expressions.matchValue(node.expressions, [...keys, "expressions"])) {
      return false;
    }
    return true;
  }
}
function templateLiteral(quasis, expressions) {
  return new TemplateLiteralMatcher(quasis, expressions);
}

class ThisExpressionMatcher extends Matcher {
  constructor() {
    super();
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isThisExpression(node)) {
      return false;
    }
    return true;
  }
}
function thisExpression() {
  return new ThisExpressionMatcher;
}
class TryStatementMatcher extends Matcher {
  block;
  handler;
  finalizer;
  constructor(block, handler, finalizer) {
    super();
    this.block = block;
    this.handler = handler;
    this.finalizer = finalizer;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isTryStatement(node)) {
      return false;
    }
    if (typeof this.block === "undefined") {
    } else if (!this.block.matchValue(node.block, [...keys, "block"])) {
      return false;
    }
    if (typeof this.handler === "undefined") {
    } else if (this.handler === null) {
      if (node.handler !== null) {
        return false;
      }
    } else if (!this.handler.matchValue(node.handler, [...keys, "handler"])) {
      return false;
    }
    if (typeof this.finalizer === "undefined") {
    } else if (this.finalizer === null) {
      if (node.finalizer !== null) {
        return false;
      }
    } else if (!this.finalizer.matchValue(node.finalizer, [...keys, "finalizer"])) {
      return false;
    }
    return true;
  }
}
function tryStatement(block, handler, finalizer) {
  return new TryStatementMatcher(block, handler, finalizer);
}
class UnaryExpressionMatcher extends Matcher {
  operator;
  argument;
  prefix;
  constructor(operator, argument, prefix) {
    super();
    this.operator = operator;
    this.argument = argument;
    this.prefix = prefix;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isUnaryExpression(node)) {
      return false;
    }
    if (typeof this.operator === "undefined") {
    } else if (typeof this.operator === "string") {
      if (this.operator !== node.operator) {
        return false;
      }
    } else if (!this.operator.matchValue(node.operator, [...keys, "operator"])) {
      return false;
    }
    if (typeof this.argument === "undefined") {
    } else if (!this.argument.matchValue(node.argument, [...keys, "argument"])) {
      return false;
    }
    if (typeof this.prefix === "undefined") {
    } else if (typeof this.prefix === "boolean") {
      if (this.prefix !== node.prefix) {
        return false;
      }
    } else if (!this.prefix.matchValue(node.prefix, [...keys, "prefix"])) {
      return false;
    }
    return true;
  }
}
function unaryExpression(operator, argument, prefix) {
  return new UnaryExpressionMatcher(operator, argument, prefix);
}
class UpdateExpressionMatcher extends Matcher {
  operator;
  argument;
  prefix;
  constructor(operator, argument, prefix) {
    super();
    this.operator = operator;
    this.argument = argument;
    this.prefix = prefix;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isUpdateExpression(node)) {
      return false;
    }
    if (typeof this.operator === "undefined") {
    } else if (typeof this.operator === "string") {
      if (this.operator !== node.operator) {
        return false;
      }
    } else if (!this.operator.matchValue(node.operator, [...keys, "operator"])) {
      return false;
    }
    if (typeof this.argument === "undefined") {
    } else if (!this.argument.matchValue(node.argument, [...keys, "argument"])) {
      return false;
    }
    if (typeof this.prefix === "undefined") {
    } else if (typeof this.prefix === "boolean") {
      if (this.prefix !== node.prefix) {
        return false;
      }
    } else if (!this.prefix.matchValue(node.prefix, [...keys, "prefix"])) {
      return false;
    }
    return true;
  }
}
function updateExpression(operator, argument, prefix) {
  return new UpdateExpressionMatcher(operator, argument, prefix);
}
class VariableDeclarationMatcher extends Matcher {
  kind;
  declarations;
  constructor(kind, declarations) {
    super();
    this.kind = kind;
    this.declarations = declarations;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isVariableDeclaration(node)) {
      return false;
    }
    if (typeof this.kind === "undefined") {
    } else if (typeof this.kind === "string") {
      if (this.kind !== node.kind) {
        return false;
      }
    } else if (!this.kind.matchValue(node.kind, [...keys, "kind"])) {
      return false;
    }
    if (typeof this.declarations === "undefined") {
    } else if (Array.isArray(this.declarations)) {
      if (!tupleOf(...this.declarations).matchValue(node.declarations, [
        ...keys,
        "declarations"
      ])) {
        return false;
      }
    } else if (!this.declarations.matchValue(node.declarations, [
      ...keys,
      "declarations"
    ])) {
      return false;
    }
    return true;
  }
}
function variableDeclaration(kind, declarations) {
  return new VariableDeclarationMatcher(kind, declarations);
}

class VariableDeclaratorMatcher extends Matcher {
  id;
  init;
  constructor(id, init) {
    super();
    this.id = id;
    this.init = init;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isVariableDeclarator(node)) {
      return false;
    }
    if (typeof this.id === "undefined") {
    } else if (!this.id.matchValue(node.id, [...keys, "id"])) {
      return false;
    }
    if (typeof this.init === "undefined") {
    } else if (this.init === null) {
      if (node.init !== null) {
        return false;
      }
    } else if (!this.init.matchValue(node.init, [...keys, "init"])) {
      return false;
    }
    return true;
  }
}
function variableDeclarator(id, init) {
  return new VariableDeclaratorMatcher(id, init);
}
class WhileStatementMatcher extends Matcher {
  test;
  body;
  constructor(test, body) {
    super();
    this.test = test;
    this.body = body;
  }
  matchValue(node, keys) {
    if (!t11.isNode(node) || !t11.isWhileStatement(node)) {
      return false;
    }
    if (typeof this.test === "undefined") {
    } else if (!this.test.matchValue(node.test, [...keys, "test"])) {
      return false;
    }
    if (typeof this.body === "undefined") {
    } else if (!this.body.matchValue(node.body, [...keys, "body"])) {
      return false;
    }
    return true;
  }
}
function whileStatement(test, body) {
  return new WhileStatementMatcher(test, body);
}
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/or.ts
class OrMatcher extends Matcher {
  matchersOrValues;
  constructor(...matchersOrValues) {
    super();
    this.matchersOrValues = matchersOrValues;
  }
  matchValue(value, keys) {
    for (const matcherOrValue of this.matchersOrValues) {
      if (matcherOrValue instanceof Matcher) {
        if (matcherOrValue.matchValue(value, keys)) {
          return true;
        }
      } else if (matcherOrValue === value) {
        return true;
      }
    }
    return false;
  }
}
function or(...matchersOrValues) {
  return new OrMatcher(...matchersOrValues);
}
// node_modules/.pnpm/@codemod+matchers@https+++gitpkg.vercel.app+api+pkg.tgz+url=codemod-js+codemod+packages+match_y3mhqth3x437cu4u7tvyd2tjkm/node_modules/@codemod/matchers/src/matchers/predicate.ts
class PredicateMatcher extends Matcher {
  predicate;
  constructor(predicate) {
    super();
    this.predicate = predicate;
  }
  matchValue(value) {
    return this.predicate(value);
  }
}
function predicate(predicate2) {
  return new PredicateMatcher(predicate2);
}
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/ast-utils/matcher.ts
import * as t12 from "@babel/types";
var safeLiteral = predicate((node) => t12.isLiteral(node) && (!t12.isTemplateLiteral(node) || node.expressions.length === 0));
function infiniteLoop(body) {
  return or(forStatement(undefined, null, undefined, body), forStatement(undefined, truthyMatcher, undefined, body), whileStatement(truthyMatcher, body));
}
function constKey(name) {
  return or(identifier(name), stringLiteral(name));
}
function constObjectProperty(value) {
  return or(objectProperty(identifier(), value, false), objectProperty(or(stringLiteral(), numericLiteral()), value));
}
function matchIife(body) {
  return callExpression(functionExpression(null, [], body ? blockStatement(body) : undefined), []);
}
var iife = matchIife();
var emptyIife = matchIife([]);
function constMemberExpression(object, property) {
  if (typeof object === "string")
    object = identifier(object);
  return or(memberExpression(object, identifier(property), false), memberExpression(object, stringLiteral(property), true));
}
var undefinedMatcher = or(identifier("undefined"), unaryExpression("void", numericLiteral(0)));
var trueMatcher = or(booleanLiteral(true), unaryExpression("!", numericLiteral(0)), unaryExpression("!", unaryExpression("!", numericLiteral(1))), unaryExpression("!", unaryExpression("!", arrayExpression([]))));
var falseMatcher = or(booleanLiteral(false), unaryExpression("!", arrayExpression([])));
var truthyMatcher = or(trueMatcher, arrayExpression([]));
function findParent(path, matcher) {
  return path.findParent((path2) => matcher.match(path2.node));
}
function createFunctionMatcher(params, body) {
  const captures = Array.from({ length: params }, () => capture(anyString()));
  return functionExpression(undefined, captures.map(identifier), blockStatement(body(...captures.map((c) => identifier(fromCapture(c))))));
}
function isReadonlyObject(binding, memberAccess) {
  if (!binding.constant && binding.constantViolations[0] !== binding.path)
    return false;
  function isPatternAssignment(member) {
    return member.parentPath?.isArrayPattern() || member.parentPath?.isAssignmentPattern() || member.parentPath?.parentPath?.isObjectPattern() || member.parentPath?.isAssignmentPattern();
  }
  return binding.referencePaths.every((path) => memberAccess.match(path.parent) && !path.parentPath?.parentPath?.isAssignmentExpression({
    left: path.parent
  }) && !path.parentPath?.parentPath?.isUpdateExpression({
    argument: path.parent
  }) && !path.parentPath?.parentPath?.isUnaryExpression({
    argument: path.parent,
    operator: "delete"
  }) && !isPatternAssignment(path.parentPath));
}
function isTemporaryVariable(binding, references, kind = "var") {
  return binding !== undefined && binding.references === references && binding.constantViolations.length === 1 && (kind === "var" ? binding.path.isVariableDeclarator() && binding.path.node.init === null : binding.path.listKey === "params" && binding.path.isIdentifier());
}

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/ast-utils/inline.ts
function inlineVariable(binding, value = anyExpression(), unsafeAssignments = false) {
  const varDeclarator = binding.path.node;
  const varMatcher = variableDeclarator(identifier(binding.identifier.name), value);
  const assignmentMatcher = assignmentExpression("=", identifier(binding.identifier.name), value);
  if (binding.constant && varMatcher.match(varDeclarator)) {
    binding.referencePaths.forEach((ref) => {
      ref.replaceWith(varDeclarator.init);
    });
    binding.path.remove();
  } else if (unsafeAssignments && binding.constantViolations.length >= 1) {
    let getNearestAssignment = function(location) {
      return assignments.findLast((assignment) => assignment.start < location);
    };
    const assignments = binding.constantViolations.map((path) => path.node).filter((node) => assignmentMatcher.match(node));
    if (!assignments.length)
      return;
    for (const ref of binding.referencePaths) {
      const assignment = getNearestAssignment(ref.node.start);
      if (assignment)
        ref.replaceWith(assignment.right);
    }
    for (const path of binding.constantViolations) {
      if (path.parentPath?.isExpressionStatement()) {
        path.remove();
      } else if (path.isAssignmentExpression()) {
        path.replaceWith(path.node.right);
      }
    }
    binding.path.remove();
  }
}
function inlineArrayElements(array, references) {
  for (const reference of references) {
    const memberPath = reference.parentPath;
    const property = memberPath.node.property;
    const index = property.value;
    const replacement = array.elements[index];
    memberPath.replaceWith(t13.cloneNode(replacement));
  }
}
function inlineObjectProperties(binding, property = objectProperty()) {
  const varDeclarator = binding.path.node;
  const objectProperties = capture(arrayOf(property));
  const varMatcher = variableDeclarator(identifier(binding.identifier.name), objectExpression(objectProperties));
  if (!varMatcher.match(varDeclarator))
    return;
  const propertyMap = new Map(objectProperties.current.map((p) => [getPropName(p.key), p.value]));
  if (!binding.referencePaths.every((ref) => {
    const member = ref.parent;
    const propName = getPropName(member.property);
    return propertyMap.has(propName);
  }))
    return;
  binding.referencePaths.forEach((ref) => {
    const memberPath = ref.parentPath;
    const propName = getPropName(memberPath.node.property);
    const value = propertyMap.get(propName);
    memberPath.replaceWith(value);
  });
  binding.path.remove();
}
function inlineFunction(fn, caller) {
  if (t13.isRestElement(fn.params[1])) {
    caller.replaceWith(t13.callExpression(caller.node.arguments[0], caller.node.arguments.slice(1)));
    return;
  }
  const returnedValue = fn.body.body[0].argument;
  const clone = t13.cloneNode(returnedValue, true);
  traverse2(clone, {
    Identifier(path) {
      const paramIndex = fn.params.findIndex((p) => p.name === path.node.name);
      if (paramIndex !== -1) {
        path.replaceWith(caller.node.arguments[paramIndex]);
        path.skip();
      }
    },
    noScope: true
  });
  caller.replaceWith(clone);
}
function inlineFunctionAliases(binding) {
  const state = { changes: 0 };
  const refs = [...binding.referencePaths];
  for (const ref of refs) {
    const fn = findParent(ref, functionDeclaration());
    const fnName = capture(anyString());
    const returnedCall = capture(callExpression(identifier(binding.identifier.name), anyList(slice({ min: 2 }))));
    const matcher = functionDeclaration(identifier(fnName), anyList(slice({ min: 2 })), blockStatement([returnStatement(returnedCall)]));
    if (fn && matcher.match(fn.node)) {
      const paramUsedInDecodeCall = fn.node.params.some((param) => {
        const binding2 = fn.scope.getBinding(param.name);
        return binding2?.referencePaths.some((ref2) => ref2.findParent((p) => p.node === returnedCall.current));
      });
      if (!paramUsedInDecodeCall)
        continue;
      const fnBinding = fn.scope.parent.getBinding(fnName.current);
      if (!fnBinding)
        continue;
      const fnRefs = fnBinding.referencePaths;
      refs.push(...fnRefs);
      const callRefs = fnRefs.filter((ref2) => t13.isCallExpression(ref2.parent) && t13.isIdentifier(ref2.parent.callee, { name: fnName.current })).map((ref2) => ref2.parentPath);
      for (const callRef of callRefs) {
        inlineFunction(fn.node, callRef);
        state.changes++;
      }
      fn.remove();
      state.changes++;
    }
  }
  binding.scope.crawl();
  return state;
}
function inlineVariableAliases(binding, targetName = binding.identifier.name) {
  const state = { changes: 0 };
  const refs = [...binding.referencePaths];
  const varName = capture(anyString());
  const matcher = or(variableDeclarator(identifier(varName), identifier(binding.identifier.name)), assignmentExpression("=", identifier(varName), identifier(binding.identifier.name)));
  for (const ref of refs) {
    if (matcher.match(ref.parent)) {
      const varScope = ref.scope;
      const varBinding = varScope.getBinding(varName.current);
      if (!varBinding)
        continue;
      if (ref.isIdentifier({ name: varBinding.identifier.name }))
        continue;
      state.changes += inlineVariableAliases(varBinding, targetName).changes;
      if (ref.parentPath?.isAssignmentExpression()) {
        varBinding.path.remove();
        if (t13.isExpressionStatement(ref.parentPath.parent)) {
          ref.parentPath.remove();
        } else {
          ref.parentPath.replaceWith(t13.identifier(targetName));
        }
      } else if (ref.parentPath?.isVariableDeclarator()) {
        ref.parentPath.remove();
      }
      state.changes++;
    } else {
      ref.replaceWith(t13.identifier(targetName));
      state.changes++;
    }
  }
  return state;
}
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/ast-utils/rename.ts
import traverse3 from "@babel/traverse";
import * as t14 from "@babel/types";
function renameFast(binding, newName) {
  binding.referencePaths.forEach((ref) => {
    if (ref.isExportDefaultDeclaration())
      return;
    if (!ref.isIdentifier()) {
      throw new Error(`Unexpected reference (${ref.type}): ${codePreview(ref.node)}`);
    }
    if (ref.scope.hasBinding(newName))
      ref.scope.rename(newName);
    ref.node.name = newName;
  });
  const patternMatcher = assignmentExpression("=", or(arrayPattern(), objectPattern()));
  binding.constantViolations.forEach((ref) => {
    if (ref.scope.hasBinding(newName))
      ref.scope.rename(newName);
    if (ref.isAssignmentExpression() && t14.isIdentifier(ref.node.left)) {
      ref.node.left.name = newName;
    } else if (ref.isUpdateExpression() && t14.isIdentifier(ref.node.argument)) {
      ref.node.argument.name = newName;
    } else if (ref.isUnaryExpression({ operator: "delete" }) && t14.isIdentifier(ref.node.argument)) {
      ref.node.argument.name = newName;
    } else if (ref.isVariableDeclarator() && t14.isIdentifier(ref.node.id)) {
      ref.node.id.name = newName;
    } else if (ref.isVariableDeclarator() && t14.isArrayPattern(ref.node.id)) {
      const ids = ref.getBindingIdentifiers();
      for (const id in ids) {
        if (id === binding.identifier.name) {
          ids[id].name = newName;
        }
      }
    } else if (ref.isFor() || patternMatcher.match(ref.node)) {
      traverse3(ref.node, {
        Identifier(path) {
          if (path.scope !== ref.scope)
            return path.skip();
          if (path.node.name === binding.identifier.name) {
            path.node.name = newName;
          }
        },
        noScope: true
      });
    } else if (ref.isFunctionDeclaration() && t14.isIdentifier(ref.node.id)) {
      ref.node.id.name = newName;
    } else {
      throw new Error(`Unexpected constant violation (${ref.type}): ${codePreview(ref.node)}`);
    }
  });
  binding.scope.removeOwnBinding(binding.identifier.name);
  binding.scope.bindings[newName] = binding;
  binding.identifier.name = newName;
}
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/ast-utils/transform.ts
import traverse4, { visitors } from "@babel/traverse";
import debug from "debug";
var logger = debug("webcrack:transforms");
async function applyTransformAsync(ast, transform, options) {
  logger(`${transform.name}: started`);
  const state = { changes: 0 };
  await transform.run?.(ast, state, options);
  if (transform.visitor)
    traverse4(ast, transform.visitor(options), undefined, state);
  logger(`${transform.name}: finished with ${state.changes} changes`);
  return state;
}
function applyTransform(ast, transform, options) {
  logger(`${transform.name}: started`);
  const state = { changes: 0 };
  transform.run?.(ast, state, options);
  if (transform.visitor) {
    const visitor = transform.visitor(options);
    visitor.noScope = !transform.scope;
    traverse4(ast, visitor, undefined, state);
  }
  logger(`${transform.name}: finished with ${state.changes} changes`);
  return state;
}
function applyTransforms(ast, transforms, options = {}) {
  options.log ??= true;
  const name = options.name ?? transforms.map((t15) => t15.name).join(", ");
  if (options.log)
    logger(`${name}: started`);
  const state = { changes: 0 };
  for (const transform of transforms) {
    transform.run?.(ast, state);
  }
  const traverseOptions = transforms.flatMap((t15) => t15.visitor?.() ?? []);
  if (traverseOptions.length > 0) {
    const visitor = visitors.merge(traverseOptions);
    visitor.noScope = options.noScope || transforms.every((t15) => !t15.scope);
    traverse4(ast, visitor, undefined, state);
  }
  if (options.log)
    logger(`${name}: finished with ${state.changes} changes`);
  return state;
}
function mergeTransforms(options) {
  return {
    name: options.name,
    tags: options.tags,
    scope: options.transforms.some((t15) => t15.scope),
    visitor() {
      return visitors.merge(options.transforms.flatMap((t15) => t15.visitor?.() ?? []));
    }
  };
}
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/merge-strings.ts
var merge_strings_default = {
  name: "merge-strings",
  tags: ["safe"],
  visitor() {
    const left = capture(stringLiteral());
    const right = capture(stringLiteral());
    const matcher2 = binaryExpression("+", or(left, binaryExpression("+", anything(), left)), right);
    return {
      BinaryExpression: {
        exit(path) {
          if (!matcher2.match(path.node))
            return;
          left.current.value += right.current.value;
          right.current.value = "";
          path.replaceWith(path.node.left);
          path.skip();
          this.changes++;
        }
      }
    };
  }
};

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/deobfuscate/array-rotator.ts
function findArrayRotator(stringArray) {
  const arrayIdentifier = capture(identifier());
  const pushShift = callExpression(constMemberExpression(arrayIdentifier, "push"), [
    callExpression(constMemberExpression(fromCapture(arrayIdentifier), "shift"))
  ]);
  const callMatcher = callExpression(functionExpression(null, anything(), blockStatement(anyList(zeroOrMore(), infiniteLoop(predicate((node) => {
    return containerOf(callExpression(identifier("parseInt"))).match(node) && blockStatement([
      tryStatement(containerOf(pushShift), containerOf(pushShift))
    ]).match(node);
  }))))));
  const matcher2 = expressionStatement(or(callMatcher, unaryExpression("!", callMatcher)));
  for (const ref of stringArray.references) {
    const rotator = findParent(ref, matcher2);
    if (rotator) {
      return rotator;
    }
  }
}

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/deobfuscate/control-flow-object.ts
import * as t15 from "@babel/types";
var control_flow_object_default = {
  name: "control-flow-object",
  tags: ["safe"],
  scope: true,
  visitor() {
    const varId = capture(identifier());
    const propertyName = predicate((name) => /^[a-z]{5}$/i.test(name));
    const propertyKey = constKey(propertyName);
    const propertyValue = or(stringLiteral(), createFunctionMatcher(2, (left, right) => [
      returnStatement(or(binaryExpression(undefined, left, right), logicalExpression(undefined, left, right), binaryExpression(undefined, right, left), logicalExpression(undefined, right, left)))
    ]), predicate((node) => {
      return t15.isFunctionExpression(node) && createFunctionMatcher(node.params.length, (...params) => [
        returnStatement(callExpression(params[0], params.slice(1)))
      ]).match(node);
    }), (() => {
      const fnName = capture(identifier());
      const restName = capture(identifier());
      return functionExpression(undefined, [fnName, restElement(restName)], blockStatement([
        returnStatement(callExpression(fromCapture(fnName), [
          spreadElement(fromCapture(restName))
        ]))
      ]));
    })());
    const objectProperties = capture(arrayOf(objectProperty(propertyKey, propertyValue)));
    const aliasId = capture(identifier());
    const aliasVar = variableDeclaration(anything(), [
      variableDeclarator(aliasId, fromCapture(varId))
    ]);
    const assignedKey = capture(propertyName);
    const assignedValue = capture(propertyValue);
    const assignment = expressionStatement(assignmentExpression("=", constMemberExpression(fromCapture(varId), assignedKey), assignedValue));
    const looseAssignment = expressionStatement(assignmentExpression("=", constMemberExpression(fromCapture(varId), assignedKey)));
    const memberAccess = constMemberExpression(or(fromCapture(varId), fromCapture(aliasId)), propertyName);
    const varMatcher = variableDeclarator(varId, objectExpression(objectProperties));
    const inlineMatcher = constMemberExpression(objectExpression(objectProperties), propertyName);
    function isConstantBinding(binding) {
      return binding.constant || binding.constantViolations[0] === binding.path;
    }
    function transform2(path) {
      let changes = 0;
      if (varMatcher.match(path.node)) {
        const binding = path.scope.getBinding(varId.current.name);
        if (!binding)
          return changes;
        if (!isConstantBinding(binding))
          return changes;
        if (!transformObjectKeys(binding))
          return changes;
        if (!isReadonlyObject(binding, memberAccess))
          return changes;
        const props = new Map(objectProperties.current.map((p) => [
          getPropName(p.key),
          p.value
        ]));
        if (!props.size)
          return changes;
        const oldRefs = [...binding.referencePaths];
        [...binding.referencePaths].reverse().forEach((ref) => {
          const memberPath = ref.parentPath;
          const propName = getPropName(memberPath.node.property);
          const value = props.get(propName);
          if (!value) {
            ref.addComment("leading", "webcrack:control_flow_missing_prop");
            return;
          }
          if (t15.isStringLiteral(value)) {
            memberPath.replaceWith(value);
          } else {
            inlineFunction(value, memberPath.parentPath);
          }
          changes++;
        });
        oldRefs.forEach((ref) => {
          const varDeclarator = findParent(ref, variableDeclarator());
          if (varDeclarator)
            changes += transform2(varDeclarator);
        });
        path.remove();
        changes++;
      }
      return changes;
    }
    function transformObjectKeys(objBinding) {
      const container = objBinding.path.parentPath.container;
      const startIndex = objBinding.path.parentPath.key + 1;
      const properties = [];
      for (let i = startIndex;i < container.length; i++) {
        const statement = container[i];
        if (looseAssignment.match(statement)) {
          applyTransform(statement, merge_strings_default);
        }
        if (assignment.match(statement)) {
          properties.push(t15.objectProperty(t15.identifier(assignedKey.current), assignedValue.current));
        } else {
          break;
        }
      }
      const aliasAssignment = container[startIndex + properties.length];
      if (!aliasVar.match(aliasAssignment))
        return true;
      if (objBinding.references !== properties.length + 1)
        return false;
      const aliasBinding = objBinding.scope.getBinding(aliasId.current.name);
      if (!isReadonlyObject(aliasBinding, memberAccess))
        return false;
      objectProperties.current.push(...properties);
      container.splice(startIndex, properties.length);
      objBinding.referencePaths = aliasBinding.referencePaths;
      objBinding.references = aliasBinding.references;
      objBinding.identifier.name = aliasBinding.identifier.name;
      aliasBinding.path.remove();
      return true;
    }
    return {
      VariableDeclarator: {
        exit(path) {
          this.changes += transform2(path);
        }
      },
      MemberExpression: {
        exit(path) {
          if (!inlineMatcher.match(path.node))
            return;
          const propName = getPropName(path.node.property);
          const value = objectProperties.current.find((prop) => getPropName(prop.key) === propName)?.value;
          if (!value)
            return;
          if (t15.isStringLiteral(value)) {
            path.replaceWith(value);
          } else if (path.parentPath.isCallExpression()) {
            inlineFunction(value, path.parentPath);
          } else {
            path.replaceWith(value);
          }
          this.changes++;
        }
      }
    };
  }
};

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/deobfuscate/control-flow-switch.ts
import * as t16 from "@babel/types";
var control_flow_switch_default = {
  name: "control-flow-switch",
  tags: ["safe"],
  visitor() {
    const sequenceName = capture(identifier());
    const sequenceString = capture(predicate((s) => /^\d+(\|\d+)*$/.test(s)));
    const iterator = capture(identifier());
    const cases = capture(arrayOf(switchCase(stringLiteral(predicate((s) => /^\d+$/.test(s))), anyList(zeroOrMore(), or(continueStatement(), returnStatement())))));
    const matcher2 = blockStatement(anyList(variableDeclaration(undefined, [
      variableDeclarator(sequenceName, callExpression(constMemberExpression(stringLiteral(sequenceString), "split"), [stringLiteral("|")]))
    ]), variableDeclaration(undefined, [variableDeclarator(iterator)]), infiniteLoop(blockStatement([
      switchStatement(memberExpression(fromCapture(sequenceName), updateExpression("++", fromCapture(iterator)), true), cases),
      breakStatement()
    ])), zeroOrMore()));
    return {
      BlockStatement: {
        exit(path) {
          if (!matcher2.match(path.node))
            return;
          const caseStatements = new Map(cases.current.map((c) => [
            c.test.value,
            t16.isContinueStatement(c.consequent.at(-1)) ? c.consequent.slice(0, -1) : c.consequent
          ]));
          const sequence = sequenceString.current.split("|");
          const newStatements = sequence.flatMap((s) => caseStatements.get(s));
          path.node.body.splice(0, 3, ...newStatements);
          this.changes += newStatements.length + 3;
        }
      }
    };
  }
};

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/deobfuscate/dead-code.ts
import * as t17 from "@babel/types";
var dead_code_default = {
  name: "dead-code",
  tags: ["unsafe"],
  scope: true,
  visitor() {
    const stringComparison = binaryExpression(or("===", "==", "!==", "!="), stringLiteral(), stringLiteral());
    const testMatcher = or(stringComparison, unaryExpression("!", stringComparison));
    return {
      "IfStatement|ConditionalExpression": {
        exit(_path) {
          const path = _path;
          if (!testMatcher.match(path.node.test))
            return;
          if (path.get("test").evaluateTruthy()) {
            replace(path, path.get("consequent"));
          } else if (path.node.alternate) {
            replace(path, path.get("alternate"));
          } else {
            path.remove();
          }
          this.changes++;
        }
      }
    };
  }
};
function replace(path, replacement) {
  if (t17.isBlockStatement(replacement.node)) {
    const childBindings = replacement.scope.bindings;
    for (const name in childBindings) {
      const binding = childBindings[name];
      if (path.scope.hasOwnBinding(name)) {
        renameFast(binding, path.scope.generateUid(name));
      }
      binding.scope = path.scope;
      path.scope.bindings[binding.identifier.name] = binding;
    }
    path.replaceWithMultiple(replacement.node.body);
  } else {
    path.replaceWith(replacement);
  }
}

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/deobfuscate/decoder.ts
import { expression } from "@babel/template";
class Decoder {
  name;
  path;
  constructor(name, path) {
    this.name = name;
    this.path = path;
  }
  collectCalls() {
    const calls = [];
    const literalArgument = or(binaryExpression(anything(), predicate((node) => literalArgument.match(node)), predicate((node) => literalArgument.match(node))), unaryExpression("-", predicate((node) => literalArgument.match(node))), numericLiteral(), stringLiteral());
    const literalCall = callExpression(identifier(this.name), arrayOf(literalArgument));
    const expressionCall = callExpression(identifier(this.name), arrayOf(anyExpression()));
    const conditional = capture(conditionalExpression());
    const conditionalCall = callExpression(identifier(this.name), [
      conditional
    ]);
    const buildExtractedConditional = expression`TEST ? CALLEE(CONSEQUENT) : CALLEE(ALTERNATE)`;
    const binding = this.path.scope.getBinding(this.name);
    for (const ref of binding.referencePaths) {
      if (conditionalCall.match(ref.parent)) {
        const [replacement] = ref.parentPath.replaceWith(buildExtractedConditional({
          TEST: conditional.current.test,
          CALLEE: ref.parent.callee,
          CONSEQUENT: conditional.current.consequent,
          ALTERNATE: conditional.current.alternate
        }));
        replacement.scope.crawl();
      } else if (literalCall.match(ref.parent)) {
        calls.push(ref.parentPath);
      } else if (expressionCall.match(ref.parent)) {
        ref.parentPath.traverse({
          ReferencedIdentifier(path) {
            const varBinding = path.scope.getBinding(path.node.name);
            if (!varBinding)
              return;
            inlineVariable(varBinding, literalArgument, true);
          }
        });
        if (literalCall.match(ref.parent)) {
          calls.push(ref.parentPath);
        }
      } else if (ref.parentPath?.isExpressionStatement()) {
        ref.parentPath.remove();
      }
    }
    return calls;
  }
}
function findDecoders(stringArray) {
  const decoders = [];
  const functionName = capture(anyString());
  const arrayIdentifier = capture(identifier());
  const matcher2 = functionDeclaration(identifier(functionName), anything(), blockStatement(anyList(variableDeclaration(undefined, [
    variableDeclarator(arrayIdentifier, callExpression(identifier(stringArray.name)))
  ]), zeroOrMore(), containerOf(memberExpression(fromCapture(arrayIdentifier), undefined, true)), zeroOrMore())));
  for (const ref of stringArray.references) {
    const decoderFn = findParent(ref, matcher2);
    if (decoderFn) {
      const oldName = functionName.current;
      const newName = `__DECODE_${decoders.length}__`;
      const binding = decoderFn.scope.getBinding(oldName);
      renameFast(binding, newName);
      decoders.push(new Decoder(newName, decoderFn));
    }
  }
  return decoders;
}

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/deobfuscate/inline-decoded-strings.ts
import * as t18 from "@babel/types";
var inline_decoded_strings_default = {
  name: "inline-decoded-strings",
  tags: ["unsafe"],
  scope: true,
  async run(ast2, state, options) {
    if (!options)
      return;
    const calls = options.vm.decoders.flatMap((decoder) => decoder.collectCalls());
    const decodedValues = await options.vm.decode(calls);
    for (let i = 0;i < calls.length; i++) {
      const call = calls[i];
      const value = decodedValues[i];
      call.replaceWith(t18.valueToNode(value));
      if (typeof value !== "string")
        call.addComment("leading", "webcrack:decode_error");
    }
    state.changes += calls.length;
  }
};

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/deobfuscate/inline-decoder-wrappers.ts
var inline_decoder_wrappers_default = {
  name: "inline-decoder-wrappers",
  tags: ["unsafe"],
  scope: true,
  run(ast2, state, decoder) {
    if (!decoder?.node.id)
      return;
    const decoderName = decoder.node.id.name;
    const decoderBinding = decoder.parentPath.scope.getBinding(decoderName);
    if (decoderBinding) {
      state.changes += inlineVariableAliases(decoderBinding).changes;
      state.changes += inlineFunctionAliases(decoderBinding).changes;
    }
  }
};

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/deobfuscate/inline-object-props.ts
var inline_object_props_default = {
  name: "inline-object-props",
  tags: ["safe"],
  scope: true,
  visitor() {
    const varId = capture(identifier());
    const propertyName = capture(predicate((name) => /^[\w]+$/i.test(name)));
    const propertyKey = constKey(propertyName);
    const objectProperties = capture(arrayOf(objectProperty(propertyKey, or(stringLiteral(), numericLiteral()))));
    const memberAccess = constMemberExpression(fromCapture(varId), propertyName);
    const varMatcher = variableDeclarator(varId, objectExpression(objectProperties));
    const literalMemberAccess = constMemberExpression(objectExpression(objectProperties), propertyName);
    return {
      MemberExpression(path) {
        if (!literalMemberAccess.match(path.node))
          return;
        const property = objectProperties.current.find((p) => getPropName(p.key) === propertyName.current);
        if (!property)
          return;
        path.replaceWith(property.value);
        this.changes++;
      },
      VariableDeclarator(path) {
        if (!varMatcher.match(path.node))
          return;
        if (objectProperties.current.length === 0)
          return;
        const binding = path.scope.getBinding(varId.current.name);
        if (!binding || !isReadonlyObject(binding, memberAccess))
          return;
        inlineObjectProperties(binding, objectProperty(propertyKey, or(stringLiteral(), numericLiteral())));
        this.changes++;
      }
    };
  }
};

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/deobfuscate/string-array.ts
import traverse5 from "@babel/traverse";
function findStringArray(ast2) {
  let result;
  const functionName = capture(anyString());
  const arrayIdentifier = capture(identifier());
  const arrayExpression2 = capture(arrayExpression(arrayOf(or(stringLiteral(), undefinedMatcher))));
  const functionAssignment = assignmentExpression("=", identifier(fromCapture(functionName)), functionExpression(undefined, [], blockStatement([returnStatement(fromCapture(arrayIdentifier))])));
  const variableDeclaration2 = variableDeclaration(undefined, [
    variableDeclarator(arrayIdentifier, arrayExpression2)
  ]);
  const matcher2 = functionDeclaration(identifier(functionName), [], or(blockStatement([
    variableDeclaration2,
    returnStatement(callExpression(functionAssignment))
  ]), blockStatement([
    variableDeclaration2,
    expressionStatement(functionAssignment),
    returnStatement(callExpression(identifier(functionName)))
  ])));
  traverse5(ast2, {
    FunctionDeclaration(path) {
      if (matcher2.match(path.node)) {
        const length = arrayExpression2.current.elements.length;
        const name = functionName.current;
        const binding = path.scope.getBinding(name);
        renameFast(binding, "__STRING_ARRAY__");
        result = {
          path,
          references: binding.referencePaths,
          name: "__STRING_ARRAY__",
          length
        };
        path.stop();
      }
    },
    VariableDeclaration(path) {
      if (!variableDeclaration2.match(path.node))
        return;
      const length = arrayExpression2.current.elements.length;
      const binding = path.scope.getBinding(arrayIdentifier.current.name);
      const memberAccess = memberExpression(fromCapture(arrayIdentifier), numericLiteral(predicate((value) => value < length)));
      if (!binding.referenced || !isReadonlyObject(binding, memberAccess))
        return;
      inlineArrayElements(arrayExpression2.current, binding.referencePaths);
      path.remove();
    }
  });
  return result;
}

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/deobfuscate/vm.ts
import debug2 from "debug";
class VMDecoder {
  decoders;
  setupCode;
  sandbox;
  constructor(sandbox, stringArray, decoders, rotator) {
    this.sandbox = sandbox;
    this.decoders = decoders;
    const generateOptions = {
      compact: true,
      shouldPrintComment: () => false
    };
    const stringArrayCode = generate(stringArray.path.node, generateOptions);
    const rotatorCode = rotator ? generate(rotator.node, generateOptions) : "";
    const decoderCode = decoders.map((decoder) => generate(decoder.path.node, generateOptions)).join(";\n");
    this.setupCode = [stringArrayCode, rotatorCode, decoderCode].join(";\n");
  }
  async decode(calls) {
    const code = `(() => {
      ${this.setupCode}
      return [${calls.join(",")}]
    })()`;
    try {
      const result = await this.sandbox(code);
      return result;
    } catch (error) {
      debug2("webcrack:deobfuscate")("vm code:", code);
      if (error instanceof Error && (error.message.includes("undefined symbol") || error.message.includes("Segmentation fault"))) {
        throw new Error("isolated-vm version mismatch. Check https://webcrack.netlify.app/docs/guide/common-errors.html#isolated-vm", { cause: error });
      }
      throw error;
    }
  }
}

// /home/mochaa/ghq/git.sr.ht/~self/delance-builder/node_modules/webcrack/src/deobfuscate/index.ts
var deobfuscate_default = {
  name: "deobfuscate",
  tags: ["unsafe"],
  scope: true,
  async run(ast2, state, sandbox) {
    if (!sandbox)
      return;
    const logger2 = debug3("webcrack:deobfuscate");
    const stringArray = findStringArray(ast2);
    logger2(stringArray ? `String Array: ${stringArray.length} strings` : "String Array: no");
    if (!stringArray)
      return;
    const rotator = findArrayRotator(stringArray);
    logger2(`String Array Rotate: ${rotator ? "yes" : "no"}`);
    const decoders = findDecoders(stringArray);
    logger2(`String Array Encodings: ${decoders.length}`);
    state.changes += applyTransform(ast2, inline_object_props_default).changes;
    for (const decoder of decoders) {
      state.changes += applyTransform(ast2, inline_decoder_wrappers_default, decoder.path).changes;
    }
    const vm = new VMDecoder(sandbox, stringArray, decoders, rotator);
    state.changes += (await applyTransformAsync(ast2, inline_decoded_strings_default, { vm })).changes;
    if (decoders.length > 0) {
      stringArray.path.remove();
      rotator?.remove();
      decoders.forEach((decoder) => decoder.path.remove());
      state.changes += 2 + decoders.length;
    }
    state.changes += applyTransforms(ast2, [merge_strings_default, dead_code_default, control_flow_object_default, control_flow_switch_default], { noScope: true }).changes;
  }
};

// /home/mochaa/ghq/git.sr.ht/~self/delance-builder/node_modules/webcrack/src/deobfuscate/var-functions.ts
import * as t19 from "@babel/types";
var var_functions_default = {
  name: "var-functions",
  tags: ["unsafe"],
  visitor() {
    const name = capture(identifier());
    const fn = capture(functionExpression(null));
    const matcher2 = variableDeclaration("var", [
      variableDeclarator(name, fn)
    ]);
    return {
      VariableDeclaration: {
        exit(path) {
          if (matcher2.match(path.node) && path.key !== "init") {
            path.replaceWith(t19.functionDeclaration(name.current, fn.current.params, fn.current.body, fn.current.generator, fn.current.async));
          }
        }
      }
    };
  }
};

// /home/mochaa/ghq/git.sr.ht/~self/delance-builder/node_modules/webcrack/src/deobfuscate/merge-object-assignments.ts
import * as t20 from "@babel/types";
var merge_object_assignments_default = {
  name: "merge-object-assignments",
  tags: ["safe"],
  scope: true,
  visitor: () => {
    const id = capture(identifier());
    const object = capture(objectExpression([]));
    const varMatcher = variableDeclaration(undefined, [
      variableDeclarator(id, object)
    ]);
    const key = capture(anyExpression());
    const computed = capture(anything());
    const value = capture(anyExpression());
    const assignmentMatcher = expressionStatement(assignmentExpression("=", memberExpression(fromCapture(id), key, computed), value));
    return {
      Program(path) {
        path.scope.crawl();
      },
      VariableDeclaration: {
        exit(path) {
          if (!path.inList || !varMatcher.match(path.node))
            return;
          const binding = path.scope.getBinding(id.current.name);
          const container = path.container;
          const siblingIndex = path.key + 1;
          while (siblingIndex < container.length) {
            const sibling = path.getSibling(siblingIndex);
            if (!assignmentMatcher.match(sibling.node) || hasCircularReference(value.current, binding))
              return;
            const isComputed = computed.current && key.current.type !== "NumericLiteral" && key.current.type !== "StringLiteral";
            object.current.properties.push(t20.objectProperty(key.current, value.current, isComputed));
            sibling.remove();
            binding.dereference();
            binding.referencePaths.shift();
            if (binding.references === 1 && inlineableObject.match(object.current)) {
              binding.referencePaths[0].replaceWith(object.current);
              path.remove();
              this.changes++;
            }
          }
        }
      }
    };
  }
};
function hasCircularReference(node, binding) {
  return binding.referencePaths.some((path) => path.find((p) => p.node === node)) || containerOf(callExpression()).match(node);
}
var inlineableObject = predicate((node) => or(safeLiteral, arrayExpression(arrayOf(inlineableObject)), objectExpression(arrayOf(constObjectProperty(inlineableObject)))).match(node));

// /home/mochaa/ghq/git.sr.ht/~self/delance-builder/node_modules/webcrack/src/deobfuscate/self-defending.ts
var self_defending_default = {
  name: "self-defending",
  tags: ["safe"],
  scope: true,
  visitor() {
    const callController = capture(anyString());
    const firstCall = capture(identifier());
    const rfn = capture(identifier());
    const context = capture(identifier());
    const res = capture(identifier());
    const fn = capture(identifier());
    const matcher2 = variableDeclarator(identifier(callController), matchIife([
      variableDeclaration(undefined, [
        variableDeclarator(firstCall, trueMatcher)
      ]),
      returnStatement(functionExpression(null, [context, fn], blockStatement([
        variableDeclaration(undefined, [
          variableDeclarator(rfn, conditionalExpression(fromCapture(firstCall), functionExpression(null, [], blockStatement([
            ifStatement(fromCapture(fn), blockStatement([
              variableDeclaration(undefined, [
                variableDeclarator(res, callExpression(constMemberExpression(fromCapture(fn), "apply"), [
                  fromCapture(context),
                  identifier("arguments")
                ]))
              ]),
              expressionStatement(assignmentExpression("=", fromCapture(fn), nullLiteral())),
              returnStatement(fromCapture(res))
            ]))
          ])), functionExpression(null, [], blockStatement([]))))
        ]),
        expressionStatement(assignmentExpression("=", fromCapture(firstCall), falseMatcher)),
        returnStatement(fromCapture(rfn))
      ])))
    ]));
    return {
      VariableDeclarator(path) {
        if (!matcher2.match(path.node))
          return;
        const binding = path.scope.getBinding(callController.current);
        if (!binding)
          return;
        binding.referencePaths.filter((ref) => ref.parent.type === "CallExpression").forEach((ref) => {
          if (ref.parentPath?.parent.type === "CallExpression") {
            ref.parentPath.parentPath?.remove();
          } else {
            removeSelfDefendingRefs(ref);
          }
          findParent(ref, emptyIife)?.remove();
          this.changes++;
        });
        path.remove();
        this.changes++;
      }
    };
  }
};
function removeSelfDefendingRefs(path) {
  const varName = capture(anyString());
  const varMatcher = variableDeclarator(identifier(varName), callExpression(identifier(path.node.name)));
  const callMatcher = expressionStatement(callExpression(identifier(fromCapture(varName)), []));
  const varDecl = findParent(path, varMatcher);
  if (varDecl) {
    const binding = varDecl.scope.getBinding(varName.current);
    binding?.referencePaths.forEach((ref) => {
      if (callMatcher.match(ref.parentPath?.parent))
        ref.parentPath?.parentPath?.remove();
    });
    varDecl.remove();
  }
}

// /home/mochaa/ghq/git.sr.ht/~self/delance-builder/node_modules/webcrack/src/unminify/transforms/index.ts
var exports_transforms = {};
__export(exports_transforms, {
  yoda: () => yoda_default,
  voidToUndefined: () => void_to_undefined_default,
  unminifyBooleans: () => unminify_booleans_default,
  unaryExpressions: () => unary_expressions_default,
  typeofUndefined: () => typeof_undefined_default,
  ternaryToIf: () => ternary_to_if_default,
  splitVariableDeclarations: () => split_variable_declarations_default,
  splitForLoopVars: () => split_for_loop_vars_default,
  sequence: () => sequence_default,
  removeDoubleNot: () => remove_double_not_default,
  rawLiterals: () => raw_literals_default,
  numberExpressions: () => number_expressions_default,
  mergeStrings: () => merge_strings_default,
  mergeElseIf: () => merge_else_if_default,
  logicalToIf: () => logical_to_if_default,
  jsonParse: () => json_parse_default,
  invertBooleanLogic: () => invert_boolean_logic_default,
  infinity: () => infinity_default,
  forToWhile: () => for_to_while_default,
  computedProperties: () => computed_properties_default,
  blockStatements: () => block_statements_default
});

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/block-statements.ts
import * as t21 from "@babel/types";
var block_statements_default = {
  name: "block-statements",
  tags: ["safe"],
  visitor: () => ({
    IfStatement: {
      exit(path) {
        if (!t21.isBlockStatement(path.node.consequent) && !t21.isEmptyStatement(path.node.consequent)) {
          path.node.consequent = t21.blockStatement([path.node.consequent]);
          this.changes++;
        }
        if (path.node.alternate && !t21.isBlockStatement(path.node.alternate)) {
          path.node.alternate = t21.blockStatement([path.node.alternate]);
          this.changes++;
        }
      }
    },
    Loop: {
      exit(path) {
        if (!t21.isBlockStatement(path.node.body) && !t21.isEmptyStatement(path.node.body)) {
          path.node.body = t21.blockStatement([path.node.body]);
          this.changes++;
        }
      }
    },
    ArrowFunctionExpression: {
      exit(path) {
        if (t21.isSequenceExpression(path.node.body)) {
          path.node.body = t21.blockStatement([
            t21.returnStatement(path.node.body)
          ]);
          this.changes++;
        }
      }
    }
  })
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/computed-properties.ts
import { isIdentifierName } from "@babel/helper-validator-identifier";
import * as t22 from "@babel/types";
var computed_properties_default = {
  name: "computed-properties",
  tags: ["safe"],
  visitor() {
    const stringMatcher = capture(stringLiteral(predicate((value) => isIdentifierName(value))));
    const propertyMatcher = or(memberExpression(anything(), stringMatcher, true), optionalMemberExpression(anything(), stringMatcher, true));
    const keyMatcher = or(objectProperty(stringMatcher), classProperty(stringMatcher), objectMethod(undefined, stringMatcher), classMethod(undefined, stringMatcher));
    return {
      "MemberExpression|OptionalMemberExpression": {
        exit(path) {
          if (!propertyMatcher.match(path.node))
            return;
          path.node.computed = false;
          path.node.property = t22.identifier(stringMatcher.current.value);
          this.changes++;
        }
      },
      "ObjectProperty|ClassProperty|ObjectMethod|ClassMethod": {
        exit(path) {
          if (!keyMatcher.match(path.node))
            return;
          if (path.type === "ClassMethod" && stringMatcher.current.value === "constructor" || path.type === "ObjectProperty" && stringMatcher.current.value === "__proto__")
            return;
          path.node.computed = false;
          path.node.key = t22.identifier(stringMatcher.current.value);
          this.changes++;
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/for-to-while.ts
import * as t23 from "@babel/types";
var for_to_while_default = {
  name: "for-to-while",
  tags: ["safe"],
  visitor() {
    return {
      ForStatement: {
        exit(path) {
          const { test, body, init, update } = path.node;
          if (init || update)
            return;
          path.replaceWith(t23.whileStatement(test ?? t23.booleanLiteral(true), body));
          this.changes++;
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/infinity.ts
import * as t24 from "@babel/types";
var infinity_default = {
  name: "infinity",
  tags: ["safe"],
  scope: true,
  visitor: () => {
    const infinityMatcher = binaryExpression("/", numericLiteral(1), numericLiteral(0));
    const negativeInfinityMatcher = binaryExpression("/", unaryExpression("-", numericLiteral(1)), numericLiteral(0));
    return {
      BinaryExpression: {
        exit(path) {
          if (path.scope.hasBinding("Infinity", { noGlobals: true }))
            return;
          if (infinityMatcher.match(path.node)) {
            path.replaceWith(t24.identifier("Infinity"));
            this.changes++;
          } else if (negativeInfinityMatcher.match(path.node)) {
            path.replaceWith(t24.unaryExpression("-", t24.identifier("Infinity")));
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/invert-boolean-logic.ts
import * as t25 from "@babel/types";
var INVERTED_BINARY_OPERATORS = {
  "==": "!=",
  "===": "!==",
  "!=": "==",
  "!==": "==="
};
var INVERTED_LOGICAL_OPERATORS = {
  "||": "&&",
  "&&": "||"
};
var invert_boolean_logic_default = {
  name: "invert-boolean-logic",
  tags: ["safe"],
  visitor: () => {
    const logicalExpression2 = logicalExpression(or(...Object.values(INVERTED_LOGICAL_OPERATORS)));
    const logicalMatcher = unaryExpression("!", logicalExpression2);
    const binaryExpression2 = capture(binaryExpression(or(...Object.values(INVERTED_BINARY_OPERATORS))));
    const binaryMatcher = unaryExpression("!", binaryExpression2);
    return {
      UnaryExpression: {
        exit(path) {
          const { argument } = path.node;
          if (binaryMatcher.match(path.node)) {
            binaryExpression2.current.operator = INVERTED_BINARY_OPERATORS[binaryExpression2.current.operator];
            path.replaceWith(binaryExpression2.current);
            this.changes++;
          } else if (logicalMatcher.match(path.node)) {
            let current = argument;
            while (logicalExpression2.match(current)) {
              current.operator = INVERTED_LOGICAL_OPERATORS[current.operator];
              current.right = t25.unaryExpression("!", current.right);
              if (!logicalExpression2.match(current.left)) {
                current.left = t25.unaryExpression("!", current.left);
              }
              current = current.left;
            }
            path.replaceWith(argument);
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/json-parse.ts
import { parseExpression } from "@babel/parser";
var json_parse_default = {
  name: "json-parse",
  tags: ["safe"],
  scope: true,
  visitor: () => {
    const string = capture(anyString());
    const matcher2 = callExpression(constMemberExpression("JSON", "parse"), [
      stringLiteral(string)
    ]);
    return {
      CallExpression: {
        exit(path) {
          if (matcher2.match(path.node) && !path.scope.hasBinding("JSON", { noGlobals: true })) {
            try {
              JSON.parse(string.current);
              const parsed = parseExpression(string.current);
              path.replaceWith(parsed);
              this.changes++;
            } catch {
            }
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/logical-to-if.ts
import { statement } from "@babel/template";
import * as t26 from "@babel/types";
var logical_to_if_default = {
  name: "logical-to-if",
  tags: ["safe"],
  visitor: () => {
    const buildIf = statement`if (TEST) { BODY; }`;
    const buildIfNot = statement`if (!TEST) { BODY; }`;
    return {
      ExpressionStatement: {
        exit(path) {
          const expression2 = path.node.expression;
          if (!t26.isLogicalExpression(expression2))
            return;
          if (expression2.operator === "&&") {
            path.replaceWith(buildIf({
              TEST: expression2.left,
              BODY: expression2.right
            }));
            this.changes++;
          } else if (expression2.operator === "||") {
            path.replaceWith(buildIfNot({
              TEST: expression2.left,
              BODY: expression2.right
            }));
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/merge-else-if.ts
var merge_else_if_default = {
  name: "merge-else-if",
  tags: ["safe"],
  visitor() {
    const nestedIf = capture(ifStatement());
    const matcher2 = ifStatement(anything(), anything(), blockStatement([nestedIf]));
    return {
      IfStatement: {
        exit(path) {
          if (matcher2.match(path.node)) {
            path.node.alternate = nestedIf.current;
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/number-expressions.ts
import * as t27 from "@babel/types";
var number_expressions_default = {
  name: "number-expressions",
  tags: ["safe"],
  visitor: () => ({
    "BinaryExpression|UnaryExpression": {
      exit(path) {
        if (!matcher2.match(path.node))
          return;
        const evaluated = path.evaluate();
        if (t27.isBinaryExpression(path.node, { operator: "/" }) && !Number.isInteger(evaluated.value)) {
          return;
        }
        path.replaceWith(t27.valueToNode(evaluated.value));
        path.skip();
        this.changes++;
      }
    }
  })
};
var matcher2 = or(unaryExpression("-", or(stringLiteral(), numericLiteral())), binaryExpression(or("+", "-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"), or(stringLiteral(), numericLiteral(), unaryExpression("-", numericLiteral())), or(stringLiteral(), numericLiteral(), unaryExpression("-", numericLiteral()))));
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/raw-literals.ts
var raw_literals_default = {
  name: "raw-literals",
  tags: ["safe"],
  visitor: () => ({
    StringLiteral(path) {
      if (path.node.extra) {
        path.node.extra = undefined;
        this.changes++;
      }
    },
    NumericLiteral(path) {
      if (path.node.extra) {
        path.node.extra = undefined;
        this.changes++;
      }
    }
  })
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/remove-double-not.ts
import * as t28 from "@babel/types";
var remove_double_not_default = {
  name: "remove-double-not",
  tags: ["safe"],
  visitor() {
    const expression2 = capture(anyExpression());
    const doubleNot = unaryExpression("!", unaryExpression("!", expression2));
    const tripleNot = unaryExpression("!", doubleNot);
    const arrayCall = callExpression(constMemberExpression(arrayExpression(), or("filter", "find", "findLast", "findIndex", "findLastIndex", "some", "every")), [arrowFunctionExpression(anything(), doubleNot)]);
    return {
      Conditional: {
        exit(path) {
          if (doubleNot.match(path.node.test)) {
            path.get("test").replaceWith(expression2.current);
            this.changes++;
          }
        }
      },
      UnaryExpression: {
        exit(path) {
          if (tripleNot.match(path.node)) {
            path.replaceWith(t28.unaryExpression("!", expression2.current));
            this.changes++;
          }
        }
      },
      CallExpression: {
        exit(path) {
          if (arrayCall.match(path.node)) {
            path.get("arguments.0.body").replaceWith(expression2.current);
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/sequence.ts
import * as t29 from "@babel/types";
var sequence_default = {
  name: "sequence",
  tags: ["safe"],
  visitor() {
    const assignmentVariable = or(identifier(), memberExpression(identifier(), or(identifier(), safeLiteral)));
    const assignedSequence = capture(sequenceExpression());
    const assignmentMatcher = assignmentExpression(or("=", "+=", "-=", "*=", "/=", "%=", "**=", "<<=", ">>=", ">>>=", "|=", "^=", "&="), assignmentVariable, assignedSequence);
    return {
      AssignmentExpression: {
        exit(path) {
          if (!assignmentMatcher.match(path.node))
            return;
          const { expressions } = assignedSequence.current;
          path.node.right = expressions.pop();
          const newNodes = path.parentPath.isExpressionStatement() ? expressions.map(t29.expressionStatement) : expressions;
          path.insertBefore(newNodes);
          this.changes++;
        }
      },
      ExpressionStatement: {
        exit(path) {
          if (!t29.isSequenceExpression(path.node.expression))
            return;
          const statements = path.node.expression.expressions.map(t29.expressionStatement);
          path.replaceWithMultiple(statements);
          this.changes++;
        }
      },
      ReturnStatement: {
        exit(path) {
          if (!t29.isSequenceExpression(path.node.argument))
            return;
          const { expressions } = path.node.argument;
          path.node.argument = expressions.pop();
          const statements = expressions.map(t29.expressionStatement);
          path.insertBefore(statements);
          this.changes++;
        }
      },
      IfStatement: {
        exit(path) {
          if (!t29.isSequenceExpression(path.node.test))
            return;
          const { expressions } = path.node.test;
          path.node.test = expressions.pop();
          const statements = expressions.map(t29.expressionStatement);
          path.insertBefore(statements);
          this.changes++;
        }
      },
      SwitchStatement: {
        exit(path) {
          if (!t29.isSequenceExpression(path.node.discriminant))
            return;
          const { expressions } = path.node.discriminant;
          path.node.discriminant = expressions.pop();
          const statements = expressions.map(t29.expressionStatement);
          path.insertBefore(statements);
          this.changes++;
        }
      },
      ThrowStatement: {
        exit(path) {
          if (!t29.isSequenceExpression(path.node.argument))
            return;
          const { expressions } = path.node.argument;
          path.node.argument = expressions.pop();
          const statements = expressions.map(t29.expressionStatement);
          path.insertBefore(statements);
          this.changes++;
        }
      },
      ForInStatement: {
        exit(path) {
          if (!t29.isSequenceExpression(path.node.right))
            return;
          const { expressions } = path.node.right;
          path.node.right = expressions.pop();
          const statements = expressions.map(t29.expressionStatement);
          path.insertBefore(statements);
          this.changes++;
        }
      },
      ForOfStatement: {
        exit(path) {
          if (!t29.isSequenceExpression(path.node.right))
            return;
          const { expressions } = path.node.right;
          path.node.right = expressions.pop();
          const statements = expressions.map(t29.expressionStatement);
          path.insertBefore(statements);
          this.changes++;
        }
      },
      ForStatement: {
        exit(path) {
          if (t29.isSequenceExpression(path.node.init)) {
            const statements = path.node.init.expressions.map(t29.expressionStatement);
            path.node.init = null;
            path.insertBefore(statements);
            this.changes++;
          }
          if (t29.isSequenceExpression(path.node.update) && path.node.body.type === "EmptyStatement") {
            const { expressions } = path.node.update;
            path.node.update = expressions.pop();
            const statements = expressions.map(t29.expressionStatement);
            path.node.body = t29.blockStatement(statements);
            this.changes++;
          }
        }
      },
      VariableDeclaration: {
        exit(path) {
          const sequence = capture(sequenceExpression());
          const matcher3 = variableDeclaration(undefined, [
            variableDeclarator(undefined, sequence)
          ]);
          if (!matcher3.match(path.node))
            return;
          const { expressions } = sequence.current;
          path.node.declarations[0].init = expressions.pop();
          const statements = expressions.map(t29.expressionStatement);
          path.getStatementParent()?.insertBefore(statements);
          this.changes++;
        }
      },
      SequenceExpression: {
        exit(path) {
          const { expressions } = path.node;
          if (expressions.every((node) => safeLiteral.match(node))) {
            path.replaceWith(expressions.at(-1));
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/split-for-loop-vars.ts
import * as t30 from "@babel/types";
var matcher3 = forStatement(variableDeclaration("var", arrayOf(variableDeclarator(identifier()))));
var split_for_loop_vars_default = {
  name: "split-for-loop-vars",
  tags: ["safe"],
  scope: true,
  visitor: () => ({
    ForStatement: {
      exit(path) {
        if (!matcher3.match(path.node))
          return;
        const { init, test, update } = path.node;
        const { declarations } = init;
        for (let i = 0;i < declarations.length; i++) {
          const declarator = declarations[i];
          const binding = path.scope.getBinding(declarator.id.name);
          if (!binding)
            break;
          const isUsedInTestOrUpdate = binding.constantViolations.some((reference) => reference.find((p) => p.node === test || p.node === update)) || binding.referencePaths.some((reference) => reference.find((p) => p.node === test || p.node === update));
          if (isUsedInTestOrUpdate)
            break;
          path.insertBefore(t30.variableDeclaration("var", [declarator]));
          declarations.shift();
          i--;
          this.changes++;
        }
        if (declarations.length === 0)
          path.get("init").remove();
      }
    }
  })
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/split-variable-declarations.ts
import * as t31 from "@babel/types";
var split_variable_declarations_default = {
  name: "split-variable-declarations",
  tags: ["safe"],
  visitor: () => ({
    VariableDeclaration: {
      exit(path) {
        if (path.node.declarations.length > 1) {
          if (path.key === "init" && path.parentPath.isForStatement()) {
            if (!path.parentPath.node.test && !path.parentPath.node.update && path.node.kind === "var") {
              path.parentPath.insertBefore(path.node.declarations.map((declaration) => t31.variableDeclaration(path.node.kind, [declaration])));
              path.remove();
              this.changes++;
            }
          } else {
            if (path.parentPath.isExportNamedDeclaration()) {
              path.parentPath.replaceWithMultiple(path.node.declarations.map((declaration) => t31.exportNamedDeclaration(t31.variableDeclaration(path.node.kind, [declaration]))));
            } else {
              path.replaceWithMultiple(path.node.declarations.map((declaration) => t31.variableDeclaration(path.node.kind, [declaration])));
            }
            this.changes++;
          }
        }
      }
    }
  })
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/ternary-to-if.ts
import { statement as statement2 } from "@babel/template";
var ternary_to_if_default = {
  name: "ternary-to-if",
  tags: ["safe"],
  visitor() {
    const test = capture(anyExpression());
    const consequent = capture(anyExpression());
    const alternate = capture(anyExpression());
    const conditional = conditionalExpression(test, consequent, alternate);
    const buildIf = statement2`if (TEST) { CONSEQUENT; } else { ALTERNATE; }`;
    const buildIfReturn = statement2`if (TEST) { return CONSEQUENT; } else { return ALTERNATE; }`;
    return {
      ExpressionStatement: {
        exit(path) {
          if (conditional.match(path.node.expression)) {
            path.replaceWith(buildIf({
              TEST: test.current,
              CONSEQUENT: consequent.current,
              ALTERNATE: alternate.current
            }));
            this.changes++;
          }
        }
      },
      ReturnStatement: {
        exit(path) {
          if (conditional.match(path.node.argument)) {
            path.replaceWith(buildIfReturn({
              TEST: test.current,
              CONSEQUENT: consequent.current,
              ALTERNATE: alternate.current
            }));
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/typeof-undefined.ts
import * as t32 from "@babel/types";
var OPERATOR_MAP = {
  ">": "===",
  "<": "!=="
};
var typeof_undefined_default = {
  name: "typeof-undefined",
  tags: ["safe"],
  visitor() {
    const operator = capture(or(">", "<"));
    const argument = capture(anyExpression());
    const matcher4 = binaryExpression(operator, unaryExpression("typeof", argument), stringLiteral("u"));
    return {
      BinaryExpression: {
        exit(path) {
          if (!matcher4.match(path.node))
            return;
          path.replaceWith(t32.binaryExpression(OPERATOR_MAP[operator.current], t32.unaryExpression("typeof", argument.current), t32.stringLiteral("undefined")));
          this.changes++;
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/unary-expressions.ts
import * as t33 from "@babel/types";
var unary_expressions_default = {
  name: "unary-expressions",
  tags: ["safe"],
  visitor() {
    const argument = capture(anyExpression());
    const matcher4 = expressionStatement(unaryExpression(or("void", "!", "typeof"), argument));
    const returnVoid = returnStatement(unaryExpression("void", argument));
    return {
      ExpressionStatement: {
        exit(path) {
          if (!matcher4.match(path.node))
            return;
          path.replaceWith(argument.current);
          this.changes++;
        }
      },
      ReturnStatement: {
        exit(path) {
          if (!returnVoid.match(path.node))
            return;
          path.replaceWith(argument.current);
          path.insertAfter(t33.returnStatement());
          this.changes++;
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/unminify-booleans.ts
import * as t34 from "@babel/types";
var unminify_booleans_default = {
  name: "unminify-booleans",
  tags: ["safe"],
  visitor: () => ({
    UnaryExpression(path) {
      if (trueMatcher2.match(path.node)) {
        path.replaceWith(t34.booleanLiteral(true));
        this.changes++;
      } else if (falseMatcher2.match(path.node)) {
        path.replaceWith(t34.booleanLiteral(false));
        this.changes++;
      }
    }
  })
};
var trueMatcher2 = or(unaryExpression("!", numericLiteral(0)), unaryExpression("!", unaryExpression("!", numericLiteral(1))), unaryExpression("!", unaryExpression("!", arrayExpression([]))));
var falseMatcher2 = or(unaryExpression("!", numericLiteral(1)), unaryExpression("!", arrayExpression([])));
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/void-to-undefined.ts
import * as t35 from "@babel/types";
var void_to_undefined_default = {
  name: "void-to-undefined",
  tags: ["safe"],
  scope: true,
  visitor: () => {
    const matcher4 = unaryExpression("void", numericLiteral(0));
    return {
      UnaryExpression: {
        exit(path) {
          if (matcher4.match(path.node) && !path.scope.hasBinding("undefined", { noGlobals: true })) {
            path.replaceWith(t35.identifier("undefined"));
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/unminify/transforms/yoda.ts
import * as t36 from "@babel/types";
var FLIPPED_OPERATORS = {
  "==": "==",
  "===": "===",
  "!=": "!=",
  "!==": "!==",
  ">": "<",
  "<": ">",
  ">=": "<=",
  "<=": ">=",
  "*": "*",
  "^": "^",
  "&": "&",
  "|": "|"
};
var yoda_default = {
  name: "yoda",
  tags: ["safe"],
  visitor: () => {
    const pureValue = or(stringLiteral(), numericLiteral(), unaryExpression("-", or(numericLiteral(), identifier("Infinity"))), booleanLiteral(), nullLiteral(), identifier("undefined"), identifier("NaN"), identifier("Infinity"));
    const matcher4 = binaryExpression(or(...Object.values(FLIPPED_OPERATORS)), pureValue, predicate((node) => !pureValue.match(node)));
    return {
      BinaryExpression: {
        exit(path) {
          if (matcher4.match(path.node)) {
            path.replaceWith(t36.binaryExpression(FLIPPED_OPERATORS[path.node.operator], path.node.right, path.node.left));
            this.changes++;
          }
        }
      }
    };
  }
};
// /home/mochaa/ghq/git.sr.ht/~self/delance-builder/node_modules/webcrack/src/unminify/index.ts
var unminify_default = mergeTransforms({
  name: "unminify",
  tags: ["safe"],
  transforms: Object.values(exports_transforms)
});

// transform/webcrack/index.ts
async function transform2(ast2) {
  applyTransforms(ast2, [block_statements_default, sequence_default, split_variable_declarations_default, var_functions_default], {
    name: "prepare"
  });
  const quickjs = await getQuickJS();
  await applyTransformAsync(ast2, deobfuscate_default, async (code) => quickjs.evalCode(code, {
    shouldInterrupt: shouldInterruptAfterDeadline(Date.now() + 2000),
    memoryLimitBytes: 2 * 1024 * 1024
  }));
  applyTransform(ast2, unminify_default);
  applyTransform(ast2, merge_object_assignments_default);
  applyTransform(ast2, self_defending_default);
  return ast2;
}

// transform/esmodule/module-helper.ts
import * as t37 from "@babel/types";

// utils/matchers/chunk.ts
var mod = capture(identifier());
var exp = capture(identifier());
var req = capture(identifier());
var functionExpr = (args) => or(functionExpression(null, args, blockStatement(), false, false), arrowFunctionExpression(args, blockStatement(), false));
function chunk(id) {
  return objectProperty(numericLiteral(id), or(functionExpr([]), functionExpr([mod]), functionExpr([mod, exp]), functionExpr([mod, exp, req])));
}
var chunks = objectExpression(anyList(oneOrMore(chunk())));
var chunk_default = chunk();

// utils/matchers/createBinding.ts
import tmpl from "@babel/template";
var __createBinding = tmpl.expression.ast`
(this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	if (k2 === undefined) k2 = k;
	var desc = Object.getOwnPropertyDescriptor(m, k);
	if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		desc = { enumerable: true, get: function() { return m[k]; } };
	}
	Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
	if (k2 === undefined) k2 = k;
	o[k2] = m[k];
}))
`;
var obj = capture(identifier());
var mod2 = capture(identifier());
var k = capture(identifier());
var k2 = capture(identifier());
var desc = capture(identifier());
var descMiddle = capture(identifier());
var descObj = objectExpression([
  objectProperty(identifier("enumerable"), booleanLiteral(true)),
  objectProperty(identifier("get"), functionExpression(null, [], blockStatement([
    returnStatement(memberExpression(fromCapture(mod2), fromCapture(k), true))
  ])))
]);
var cond = conditionalExpression(binaryExpression("in", stringLiteral("get"), fromCapture(desc)), unaryExpression("!", memberExpression(fromCapture(mod2), identifier("__esModule"), false)), logicalExpression("||", memberExpression(fromCapture(desc), identifier("writable"), false), memberExpression(fromCapture(desc), identifier("configurable"), false)));
var createBinding_default = variableDeclaration("var", [
  variableDeclarator(identifier(), logicalExpression("||", logicalExpression("&&", thisExpression(), memberExpression(thisExpression(), identifier("__createBinding"))), conditionalExpression(memberExpression(identifier("Object"), identifier("create")), functionExpression(null, [obj, mod2, k, k2], or(blockStatement([
    ifStatement(binaryExpression("===", k2, identifier("undefined")), containerOf(expressionStatement(assignmentExpression("=", fromCapture(k2), fromCapture(k)))), null),
    variableDeclaration("var", [
      variableDeclarator(desc, callExpression(memberExpression(identifier("Object"), identifier("getOwnPropertyDescriptor"), false), [
        fromCapture(mod2),
        fromCapture(k)
      ]))
    ]),
    ifStatement(logicalExpression("||", unaryExpression("!", fromCapture(desc), true), or(cond, unaryExpression("!", unaryExpression("!", cond, true), true))), or(blockStatement([
      expressionStatement(assignmentExpression("=", fromCapture(desc), descObj))
    ]), blockStatement([
      variableDeclaration("const", [
        variableDeclarator(descMiddle, descObj)
      ]),
      expressionStatement(assignmentExpression("=", fromCapture(desc), fromCapture(descMiddle)))
    ])), null),
    expressionStatement(callExpression(memberExpression(identifier("Object"), identifier("defineProperty"), false), [
      fromCapture(obj),
      fromCapture(k2),
      fromCapture(desc)
    ]))
  ]), blockStatement([
    ifStatement(binaryExpression("===", k2, identifier("undefined")), containerOf(expressionStatement(assignmentExpression("=", fromCapture(k2), fromCapture(k)))), null),
    expressionStatement(callExpression(memberExpression(identifier("Object"), identifier("defineProperty"), false), [
      fromCapture(obj),
      fromCapture(k2),
      descObj
    ]))
  ]))), functionExpression(null, [obj, mod2, k, k2], blockStatement([
    ifStatement(binaryExpression("===", k2, identifier("undefined")), containerOf(expressionStatement(assignmentExpression("=", fromCapture(k2), fromCapture(k)))), null),
    expressionStatement(assignmentExpression("=", memberExpression(fromCapture(obj), fromCapture(k2), true), memberExpression(fromCapture(mod2), fromCapture(k), true)))
  ])))))
]);

// utils/matchers/setModuleDefault.ts
import tmpl2 from "@babel/template";
var __setModuleDefault = tmpl2.expression.ast`
(this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
	Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
	o["default"] = v;
})
`;
var leftParamObj = capture(identifier());
var leftParamVal = capture(identifier());
var leftObjIdentifier = capture(identifier());
var leftObj = objectExpression([
  objectProperty(identifier("enumerable"), booleanLiteral(true)),
  objectProperty(identifier("value"), leftParamVal)
]);
var rightParamObj = capture(identifier());
var rightParamVal = capture(identifier());
var setModuleDefault_default = variableDeclaration("var", [
  variableDeclarator(identifier(), logicalExpression("||", logicalExpression("&&", thisExpression(), memberExpression(thisExpression(), identifier("__setModuleDefault"))), conditionalExpression(memberExpression(identifier("Object"), identifier("create")), functionExpression(null, [
    leftParamObj,
    leftParamVal
  ], or(blockStatement([
    variableDeclaration("const", [variableDeclarator(leftObjIdentifier, leftObj)]),
    expressionStatement(callExpression(memberExpression(identifier("Object"), identifier("defineProperty")), [
      leftParamObj,
      stringLiteral("default"),
      leftObjIdentifier
    ]))
  ]), blockStatement([
    expressionStatement(callExpression(memberExpression(identifier("Object"), identifier("defineProperty")), [
      leftParamObj,
      stringLiteral("default"),
      leftObj
    ]))
  ])), false, false), functionExpression(null, [
    rightParamObj,
    rightParamVal
  ], blockStatement([
    expressionStatement(assignmentExpression("=", memberExpression(rightParamObj, identifier("default")), rightParamVal))
  ])))))
]);

// utils/matchers/importStar.ts
import tmpl3 from "@babel/template";
var __importStar = tmpl3.expression.ast`
(this && this.__importStar) || function (mod) {
	if (mod && mod.__esModule) return mod;
	var result = {};
	if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	__setModuleDefault(result, mod);
	return result;
}
`;
var mod3 = capture(identifier());
var k3 = capture(identifier());
var result = capture(identifier());
var importStar_default = variableDeclaration("var", [
  variableDeclarator(identifier(), logicalExpression("||", logicalExpression("&&", thisExpression(), memberExpression(thisExpression(), identifier("__importStar"), false)), functionExpression(null, [mod3], or(blockStatement([
    ifStatement(logicalExpression("&&", fromCapture(mod3), memberExpression(fromCapture(mod3), identifier("__esModule"))), containerOf(returnStatement(fromCapture(mod3))), null),
    variableDeclaration("var", [
      variableDeclarator(result, objectExpression([]))
    ]),
    ifStatement(binaryExpression("!=", fromCapture(mod3), nullLiteral()), containerOf(forInStatement(variableDeclaration("var", [
      variableDeclarator(k3, null)
    ]), fromCapture(mod3), containerOf(ifStatement(logicalExpression("&&", binaryExpression("!==", fromCapture(k3), stringLiteral("default")), callExpression(memberExpression(memberExpression(memberExpression(identifier("Object"), identifier("prototype"), false), identifier("hasOwnProperty"), false), identifier("call"), false), [
      fromCapture(mod3),
      fromCapture(k3)
    ])), containerOf(callExpression(identifier(), [
      fromCapture(result),
      fromCapture(mod3),
      fromCapture(k3)
    ])))))), null),
    expressionStatement(callExpression(identifier(), [
      fromCapture(result),
      fromCapture(mod3)
    ])),
    returnStatement(fromCapture(result))
  ])))))
]);

// utils/matchers/importDefault.ts
import tmpl4 from "@babel/template";
var __importDefault = tmpl4.expression.ast`
(this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
}
`;
var mod4 = capture(identifier());
var isEsm = logicalExpression("&&", fromCapture(mod4), memberExpression(fromCapture(mod4), identifier("__esModule"), false));
var importDefault_default = variableDeclaration("var", [
  variableDeclarator(identifier(), logicalExpression("||", logicalExpression("&&", thisExpression(), memberExpression(thisExpression(), identifier("__importDefault"))), functionExpression(null, [mod4], blockStatement([
    or(returnStatement(conditionalExpression(isEsm, fromCapture(mod4), objectExpression([
      objectProperty(stringLiteral("default"), fromCapture(mod4), false)
    ]))), ifStatement(isEsm, containerOf(returnStatement(fromCapture(mod4))), containerOf(returnStatement(objectExpression([
      objectProperty(identifier("default"), fromCapture(mod4), false)
    ])))))
  ]))))
]);

// utils/matchers/exportStar.ts
import tmpl5 from "@babel/template";
var __exportStar = tmpl5.expression.ast`
(this && this.__exportStar) || function(m, exports) {
	for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
}
`;
var mod5 = capture(identifier());
var exp2 = capture(identifier());
var p = capture(identifier());
var exportStar_default = variableDeclaration("var", [
  variableDeclarator(identifier(), logicalExpression("||", logicalExpression("&&", thisExpression(), memberExpression(thisExpression(), identifier("__exportStar"), false)), functionExpression(null, [mod5, exp2], blockStatement([
    forInStatement(variableDeclaration("var", [
      variableDeclarator(p)
    ]), fromCapture(mod5), containerOf(ifStatement(logicalExpression("&&", binaryExpression("!==", fromCapture(p), stringLiteral("default")), unaryExpression("!", callExpression(memberExpression(memberExpression(memberExpression(identifier("Object"), identifier("prototype"), false), identifier("hasOwnProperty"), false), identifier("call"), false), [
      fromCapture(exp2),
      fromCapture(p)
    ]), true)), containerOf(expressionStatement(callExpression(identifier(), [
      fromCapture(exp2),
      fromCapture(mod5),
      fromCapture(p)
    ]))))))
  ]))))
]);

// transform/esmodule/module-helper.ts
var preExport = assignmentExpression("=", memberExpression(identifier("exports"), identifier(), false), identifier("undefined"));
var undefinedExpr = expressionStatement(identifier("undefined"));
var module_helper_default = {
  name: "module-helper",
  tags: ["safe"],
  scope: true,
  visitor() {
    let level = 0;
    return {
      ObjectExpression: {
        enter($) {
          if (!chunks.match($.node)) {
            return;
          }
          level++;
          const unders = "_".repeat(level - 1);
          const $chunks = $.get("properties");
          for (const $chunk of $chunks) {
            $chunk.assertObjectProperty();
            const $function = $chunk.get("value");
            $function.assertFunction();
            const $p = $function.get("params");
            $p.forEach(($parameter, i) => {
              $parameter.assertIdentifier();
              switch (i) {
                case 0: {
                  $function.scope.rename($parameter.node.name, unders + "module");
                  break;
                }
                case 1: {
                  $function.scope.rename($parameter.node.name, unders + "exports");
                  break;
                }
                case 2: {
                  $function.scope.rename($parameter.node.name, unders + "require");
                  break;
                }
                default: {
                  throw new Error("Unexpected param");
                }
              }
            });
            $function.traverse({
              VariableDeclaration: {
                exit(p2) {
                  const $decl = p2.get("declarations.0");
                  $decl.assertVariableDeclarator();
                  const $id = $decl.get("id");
                  if (!$id.isIdentifier()) {
                    return;
                  }
                  if (importStar_default.match(t37.cloneNode(p2.node))) {
                    $id.scope.rename($id.node.name, "__importStar");
                    $decl.get("init").replaceWith(__importStar);
                  } else if (setModuleDefault_default.match(t37.cloneNode(p2.node))) {
                    $id.scope.rename($id.node.name, "__setModuleDefault");
                    $decl.get("init").replaceWith(__setModuleDefault);
                  } else if (importDefault_default.match(t37.cloneNode(p2.node))) {
                    $id.scope.rename($id.node.name, "__importDefault");
                    $decl.get("init").replaceWith(__importDefault);
                  } else if (createBinding_default.match(t37.cloneNode(p2.node))) {
                    $id.scope.rename($id.node.name, "__createBinding");
                    $decl.get("init").replaceWith(__createBinding);
                  } else if (exportStar_default.match(t37.cloneNode(p2.node))) {
                    $id.scope.rename($id.node.name, "__exportStar");
                    $decl.get("init").replaceWith(__exportStar);
                  } else {
                    return;
                  }
                  this.changes++;
                }
              }
            }, this);
          }
        },
        exit($) {
          if (chunks.match($.node)) {
            level--;
          }
        }
      }
    };
  }
};

// transform/esmodule/indirect-call.ts
import * as t38 from "@babel/types";
var indirect_call_default = {
  name: "indirect-call",
  tags: ["unsafe"],
  visitor: () => ({
    CallExpression: {
      exit($) {
        const { callee, arguments: _arguments } = $.node;
        if (!t38.isSequenceExpression(callee)) {
          return;
        }
        const exprs = [...callee.expressions];
        const _function = exprs.pop();
        if (!t38.isMemberExpression(_function)) {
          return;
        }
        if (exprs.every((expr) => t38.isPureish(expr))) {
          $.replaceWith(t38.callExpression(_function, _arguments));
          this.changes++;
        }
      }
    }
  })
};

// utils/ast.ts
import { parse as babelParse2 } from "@babel/parser";
import babelGenerate2 from "@babel/generator";
import debug4 from "debug";
import traverse6, { visitors as visitors2 } from "@babel/traverse";
var logger2 = debug4("delance:transforms");
function parse2(code) {
  return babelParse2(code, {
    sourceType: "script",
    allowReturnOutsideFunction: true
  });
}
function generate2(ast2) {
  return babelGenerate2(ast2, { jsescOption: { minimal: true, quotes: "single" } }).code;
}
function applyTransform2(ast2, transform3, options, noScopeOverride) {
  logger2(`${transform3.name}: started`);
  const state = { changes: 0 };
  transform3.run?.(ast2, state, options);
  if (transform3.visitor) {
    const visitor = transform3.visitor(options);
    visitor.noScope = noScopeOverride ?? !transform3.scope;
    traverse6(ast2, visitor, undefined, state);
  }
  logger2(`${transform3.name}: finished with ${state.changes} changes`);
  return state;
}

// transform/esmodule/index.ts
function transform3(ast2) {
  applyTransform2(ast2, module_helper_default);
  applyTransform2(ast2, indirect_call_default);
  return ast2;
}

// transform/syntactic/template-literal.ts
import * as t39 from "@babel/types";
function escape(string) {
  return string.replaceAll("\\", "\\\\").replaceAll("`", "\\`").replaceAll("$", "\\$").replaceAll("\t", "\\t").replaceAll("\r", "\\r").replaceAll("\0", "\\0");
}
var template_literal_default = {
  name: "template-literal",
  tags: ["safe"],
  visitor() {
    const concatExpr = binaryExpression("+", or(stringLiteral(), templateLiteral()), anyExpression());
    return {
      BinaryExpression: {
        exit($) {
          if (!concatExpr.match($.node)) {
            return;
          }
          const $left = $.get("left");
          const $right = $.get("right");
          if ($left.isTemplateLiteral()) {
            if ($right.isTemplateLiteral()) {
              const last = $left.node.quasis.pop();
              if (!last) {
                throw new Error("Unexpected empty template literal");
              }
              $left.node.quasis.push(t39.templateElement({
                raw: last.value.raw + $right.node.quasis[0].value.raw
              }, false), ...$right.node.quasis.slice(1));
              $.replaceWith(t39.templateLiteral([
                ...$left.node.quasis
              ], [
                ...$left.node.expressions,
                ...$right.node.expressions
              ]));
            } else if ($right.isStringLiteral()) {
              const last = $left.node.quasis.pop();
              if (!last) {
                throw new Error("Unexpected empty template literal");
              }
              $left.node.quasis.push(t39.templateElement({
                raw: escape(last.value.raw + $right.node.value)
              }, true));
              $.replaceWith($left.node);
            } else {
              $.replaceWith(t39.templateLiteral([
                ...$left.node.quasis.map((element) => {
                  element.tail = false;
                  return element;
                }),
                t39.templateElement({ raw: "" }, true)
              ], [
                ...$left.node.expressions,
                $right.node
              ]));
            }
          } else if ($left.isStringLiteral()) {
            if ($right.isStringLiteral()) {
              $left.node.value += $right.node.value;
              $.replaceWith($left);
            } else {
              if ($right.isCallExpression() && $right.get("callee").isFunctionExpression()) {
                return;
              }
              $.replaceWith(t39.templateLiteral([
                t39.templateElement({ raw: escape($left.node.value) }, false),
                t39.templateElement({ raw: "" }, true)
              ], [
                $right.node
              ]));
            }
          }
          this.changes++;
        }
      }
    };
  }
};

// transform/syntactic/index.ts
function transform4(ast2) {
  applyTransform2(ast2, template_literal_default);
  return ast2;
}

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/transpile/transforms/index.ts
var exports_transforms2 = {};
__export(exports_transforms2, {
  templateLiterals: () => template_literals_default,
  optionalChaining: () => optional_chaining_default,
  nullishCoalescingAssignment: () => nullish_coalescing_assignment_default,
  nullishCoalescing: () => nullish_coalescing_default,
  logicalAssignments: () => logical_assignments_default,
  defaultParameters: () => default_parameters_default
});

// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/transpile/transforms/default-parameters.ts
import * as t40 from "@babel/types";
var default_parameters_default = {
  name: "default-parameters",
  tags: ["safe"],
  scope: true,
  visitor() {
    const defaultExpression = capture(anyExpression());
    const index = capture(numericLiteral());
    const varName = capture(identifier());
    const varId = capture(or(identifier(), arrayPattern(), objectPattern()));
    const argumentCheckAnd = logicalExpression("&&", binaryExpression(">", constMemberExpression("arguments", "length"), index), binaryExpression("!==", memberExpression(identifier("arguments"), fromCapture(index), true), identifier("undefined")));
    const argumentCheckOr = logicalExpression("||", binaryExpression("<=", constMemberExpression("arguments", "length"), index), binaryExpression("===", memberExpression(identifier("arguments"), fromCapture(index), true), identifier("undefined")));
    const defaultParam = variableDeclaration(undefined, [
      variableDeclarator(varId, conditionalExpression(argumentCheckAnd, memberExpression(identifier("arguments"), fromCapture(index), true), defaultExpression))
    ]);
    const defaultFalseParam = variableDeclaration(undefined, [
      variableDeclarator(varId, logicalExpression("&&", argumentCheckAnd, memberExpression(identifier("arguments"), fromCapture(index), true)))
    ]);
    const defaultTrueParam = variableDeclaration(undefined, [
      variableDeclarator(varId, logicalExpression("||", argumentCheckOr, memberExpression(identifier("arguments"), fromCapture(index), true)))
    ]);
    const defaultParamLoose = ifStatement(binaryExpression("===", varName, identifier("undefined")), blockStatement([
      expressionStatement(assignmentExpression("=", fromCapture(varName), defaultExpression))
    ]));
    const normalParam = variableDeclaration(undefined, [
      variableDeclarator(varId, conditionalExpression(binaryExpression(">", constMemberExpression("arguments", "length"), index), memberExpression(identifier("arguments"), fromCapture(index), true), identifier("undefined")))
    ]);
    return {
      VariableDeclaration: {
        exit(path) {
          const fn = path.parentPath.parent;
          if (!t40.isFunction(fn) || path.key !== 0)
            return;
          const newParam = defaultParam.match(path.node) ? t40.assignmentPattern(varId.current, defaultExpression.current) : defaultFalseParam.match(path.node) ? t40.assignmentPattern(varId.current, t40.booleanLiteral(false)) : defaultTrueParam.match(path.node) ? t40.assignmentPattern(varId.current, t40.booleanLiteral(true)) : normalParam.match(path.node) ? varId.current : null;
          if (!newParam)
            return;
          for (let i = fn.params.length;i < index.current.value; i++) {
            fn.params[i] = t40.identifier(path.scope.generateUid("param"));
          }
          fn.params[index.current.value] = newParam;
          path.remove();
          this.changes++;
        }
      },
      IfStatement: {
        exit(path) {
          const fn = path.parentPath.parent;
          if (!t40.isFunction(fn) || path.key !== 0)
            return;
          if (!defaultParamLoose.match(path.node))
            return;
          const binding = path.scope.getOwnBinding(varName.current.name);
          if (!binding)
            return;
          const isFunctionParam = binding.path.listKey === "params" && binding.path.parent === fn;
          if (!isFunctionParam)
            return;
          binding.path.replaceWith(t40.assignmentPattern(varName.current, defaultExpression.current));
          path.remove();
          this.changes++;
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/transpile/transforms/logical-assignments.ts
import * as t41 from "@babel/types";
var logical_assignments_default = {
  name: "logical-assignments",
  tags: ["safe"],
  scope: true,
  visitor() {
    const operator = capture(or("||", "&&"));
    const left = capture(or(identifier(), memberExpression()));
    const right = capture(anyExpression());
    const idMatcher = logicalExpression(operator, left, assignmentExpression("=", fromCapture(left), right));
    const object = capture(anyExpression());
    const property = capture(anyExpression());
    const tmpVar = capture(identifier());
    const member = capture(memberExpression(fromCapture(tmpVar), fromCapture(property)));
    const memberMatcher = logicalExpression(operator, memberExpression(assignmentExpression("=", tmpVar, object), property), assignmentExpression("=", member, right));
    const computedMemberMatcher = logicalExpression(operator, memberExpression(object, assignmentExpression("=", tmpVar, property), true), assignmentExpression("=", memberExpression(fromCapture(object), fromCapture(tmpVar), true), right));
    const tmpVar2 = capture(identifier());
    const multiComputedMemberMatcher = logicalExpression(operator, memberExpression(assignmentExpression("=", tmpVar, object), assignmentExpression("=", tmpVar2, property), true), assignmentExpression("=", memberExpression(fromCapture(tmpVar), fromCapture(tmpVar2), true), right));
    return {
      LogicalExpression: {
        exit(path) {
          if (idMatcher.match(path.node)) {
            path.replaceWith(t41.assignmentExpression(operator.current + "=", left.current, right.current));
            this.changes++;
          } else if (memberMatcher.match(path.node)) {
            const binding = path.scope.getBinding(tmpVar.current.name);
            if (!isTemporaryVariable(binding, 1))
              return;
            binding.path.remove();
            member.current.object = object.current;
            path.replaceWith(t41.assignmentExpression(operator.current + "=", member.current, right.current));
            this.changes++;
          } else if (computedMemberMatcher.match(path.node)) {
            const binding = path.scope.getBinding(tmpVar.current.name);
            if (!isTemporaryVariable(binding, 1))
              return;
            binding.path.remove();
            path.replaceWith(t41.assignmentExpression(operator.current + "=", t41.memberExpression(object.current, property.current, true), right.current));
            this.changes++;
          } else if (multiComputedMemberMatcher.match(path.node)) {
            const binding = path.scope.getBinding(tmpVar.current.name);
            const binding2 = path.scope.getBinding(tmpVar2.current.name);
            if (!isTemporaryVariable(binding, 1) || !isTemporaryVariable(binding2, 1))
              return;
            binding.path.remove();
            binding2.path.remove();
            path.replaceWith(t41.assignmentExpression(operator.current + "=", t41.memberExpression(object.current, property.current, true), right.current));
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/transpile/transforms/nullish-coalescing.ts
import * as t42 from "@babel/types";
var nullish_coalescing_default = {
  name: "nullish-coalescing",
  tags: ["safe"],
  scope: true,
  visitor() {
    const tmpVar = capture(identifier());
    const left = capture(anyExpression());
    const right = capture(anyExpression());
    const idMatcher = conditionalExpression(logicalExpression("&&", binaryExpression("!==", assignmentExpression("=", tmpVar, left), nullLiteral()), binaryExpression("!==", fromCapture(tmpVar), identifier("undefined"))), fromCapture(tmpVar), right);
    const idLooseMatcher = conditionalExpression(binaryExpression("!=", assignmentExpression("=", tmpVar, left), nullLiteral()), fromCapture(tmpVar), right);
    const simpleIdMatcher = conditionalExpression(or(logicalExpression("&&", binaryExpression("!==", left, nullLiteral()), binaryExpression("!==", fromCapture(left), identifier("undefined"))), binaryExpression("!=", left, nullLiteral())), fromCapture(left), right);
    const iifeMatcher = callExpression(arrowFunctionExpression([fromCapture(tmpVar)], anyExpression(), false), []);
    return {
      ConditionalExpression: {
        exit(path) {
          if (idMatcher.match(path.node)) {
            const binding = path.scope.getBinding(tmpVar.current.name);
            if (iifeMatcher.match(path.parentPath.parent) && isTemporaryVariable(binding, 2, "param")) {
              path.parentPath.parentPath.replaceWith(t42.logicalExpression("??", left.current, right.current));
              this.changes++;
            } else if (isTemporaryVariable(binding, 2, "var")) {
              binding.path.remove();
              path.replaceWith(t42.logicalExpression("??", left.current, right.current));
              this.changes++;
            }
          } else if (idLooseMatcher.match(path.node)) {
            const binding = path.scope.getBinding(tmpVar.current.name);
            if (!isTemporaryVariable(binding, 1))
              return;
            binding.path.remove();
            path.replaceWith(t42.logicalExpression("??", left.current, right.current));
            this.changes++;
          } else if (simpleIdMatcher.match(path.node)) {
            path.replaceWith(t42.logicalExpression("??", left.current, right.current));
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/transpile/transforms/nullish-coalescing-assignment.ts
import * as t43 from "@babel/types";
var nullish_coalescing_assignment_default = {
  name: "nullish-coalescing-assignment",
  tags: ["safe"],
  scope: true,
  visitor() {
    const tmpVar = capture(identifier());
    const leftId = capture(identifier());
    const property = capture(identifier());
    const right = capture(anyExpression());
    const computed = capture(anything());
    const memberMatcher = logicalExpression("??", memberExpression(assignmentExpression("=", tmpVar, leftId), property, computed), assignmentExpression("=", memberExpression(fromCapture(tmpVar), fromCapture(property), computed), right));
    const left = capture(or(identifier(), memberExpression()));
    const simpleMatcher = logicalExpression("??", left, assignmentExpression("=", fromCapture(left), right));
    return {
      LogicalExpression: {
        exit(path) {
          if (memberMatcher.match(path.node)) {
            const binding = path.scope.getBinding(tmpVar.current.name);
            if (!isTemporaryVariable(binding, 1))
              return;
            binding.path.remove();
            path.replaceWith(t43.assignmentExpression("??=", t43.memberExpression(leftId.current, property.current, computed.current), right.current));
            this.changes++;
          } else if (simpleMatcher.match(path.node)) {
            path.replaceWith(t43.assignmentExpression("??=", left.current, right.current));
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/transpile/transforms/optional-chaining.ts
import * as t44 from "@babel/types";
var optional_chaining_default = {
  name: "optional-chaining",
  tags: ["safe"],
  scope: true,
  visitor() {
    const object = capture(anyExpression());
    const member = capture(memberExpression(fromCapture(object)));
    const simpleMatcher = conditionalExpression(logicalExpression("||", binaryExpression("===", object, nullLiteral()), binaryExpression("===", fromCapture(object), identifier("undefined"))), identifier("undefined"), member);
    const tmpVar = capture(identifier());
    const tmpMember = capture(memberExpression(fromCapture(tmpVar)));
    const tmpMatcher = conditionalExpression(logicalExpression("||", binaryExpression("===", assignmentExpression("=", tmpVar, object), nullLiteral()), binaryExpression("===", fromCapture(tmpVar), identifier("undefined"))), identifier("undefined"), tmpMember);
    return {
      ConditionalExpression: {
        exit(path) {
          if (simpleMatcher.match(path.node)) {
            member.current.optional = true;
            path.replaceWith(t44.optionalMemberExpression(object.current, member.current.property, member.current.computed, true));
            this.changes++;
          } else if (tmpMatcher.match(path.node)) {
            const binding = path.scope.getBinding(tmpVar.current.name);
            if (!isTemporaryVariable(binding, 2))
              return;
            binding.path.remove();
            tmpMember.current.optional = true;
            path.replaceWith(t44.optionalMemberExpression(object.current, tmpMember.current.property, tmpMember.current.computed, true));
            this.changes++;
          }
        }
      }
    };
  }
};
// node_modules/.pnpm/webcrack@https+++gitpkg.vercel.app+api+pkg.tgz+url=j4k0xb+webcrack+packages+webcrack&commit=f_c5bbn3al5xpen7fhtzx3y6fad4/node_modules/webcrack/src/transpile/transforms/template-literals.ts
import * as t45 from "@babel/types";
function escape2(str) {
  return str.replaceAll("\\", "\\\\").replaceAll("`", "\\`").replaceAll("$", "\\$").replaceAll("\0", "\\0").replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\r", "\\r").replaceAll("\t", "\\t").replaceAll("\v", "\\v");
}
function push(template, value) {
  if (value.type === "StringLiteral") {
    const lastQuasi = template.quasis.at(-1);
    lastQuasi.value.raw += escape2(value.value);
  } else if (value.type === "TemplateLiteral") {
    const lastQuasi = template.quasis.at(-1);
    const firstQuasi = value.quasis[0];
    lastQuasi.value.raw += firstQuasi.value.raw;
    template.expressions.push(...value.expressions);
    template.quasis.push(...value.quasis.slice(1));
  } else {
    template.expressions.push(value);
    template.quasis.push(t45.templateElement({ raw: "" }));
  }
}
function unshift(template, value) {
  if (value.type === "StringLiteral") {
    const firstQuasi = template.quasis[0];
    firstQuasi.value.raw = escape2(value.value) + firstQuasi.value.raw;
  } else {
    template.expressions.unshift(value);
    template.quasis.unshift(t45.templateElement({ raw: "" }));
  }
}
var template_literals_default = {
  name: "template-literals",
  tags: ["unsafe"],
  visitor() {
    const string = capture(or(stringLiteral(), templateLiteral()));
    const concatMatcher = callExpression(constMemberExpression(string, "concat"), arrayOf(anyExpression()));
    return {
      BinaryExpression: {
        exit(path) {
          if (path.node.operator !== "+")
            return;
          if (t45.isTemplateLiteral(path.node.left)) {
            push(path.node.left, path.node.right);
            path.replaceWith(path.node.left);
            this.changes++;
          } else if (t45.isTemplateLiteral(path.node.right) && t45.isExpression(path.node.left)) {
            unshift(path.node.right, path.node.left);
            path.replaceWith(path.node.right);
            this.changes++;
          }
        }
      },
      CallExpression: {
        exit(path) {
          if (concatMatcher.match(path.node)) {
            const template = t45.templateLiteral([t45.templateElement({ raw: "" })], []);
            push(template, string.current);
            for (const arg of path.node.arguments) {
              push(template, arg);
            }
            path.replaceWith(template);
            this.changes++;
          }
        }
      }
    };
  }
};
// /home/mochaa/ghq/git.sr.ht/~self/delance-builder/node_modules/webcrack/src/transpile/index.ts
var transpile_default = mergeTransforms({
  name: "transpile",
  tags: ["safe"],
  transforms: Object.values(exports_transforms2)
});

// transform/delance/stringaes.ts
import traverse7 from "@babel/traverse";
import * as t46 from "@babel/types";

// utils/crypto.ts
import crypto from "node:crypto";
import { Buffer } from "node:buffer";
var _salt = "SEE  LICENSE.txt";
var _lic = [
  ",oidutS lausiV tfosorciM htiw ylno erawtfos eht fo seipoc fo rebmun yna esu dna llatsni yam uoY",
  "stcudorp tfosorciM rosseccus dna ,revreS noitadnuoF maeT ,spOveD eruzA ,edoC oidutS lausiV ,caM rof oidutS lausiV",
  ".snoitacilppa ruoy tset dna poleved ot )\u201DsecivreS dna stcudorP oidutS lausiV\u201C eht ,ylevitcelloc( secivres dna",
  ".sthgir rehto lla sevreser tfosorciM .erawtfos eht esu ot sthgir emos uoy sevig ylno tnemeerga sihT .dlos ton ,desnecil si erawtfos ehT",
  ":ton yam uoY",
  ";syaw niatrec ni ti esu ot uoy wolla ylno taht erawtfos eht ni snoitatimil lacinhcet yna dnuora krow",
  ",erawtfos eht rof edoc ecruos eht evired ot tpmetta esiwrehto ro ,erawtfos eht elbmessasid ro elipmoced ,reenigne esrever",
  ";erawtfos eht ni dedulcni eb yam taht stnenopmoc ecruos nepo niatrec fo esu gninrevog smret gnisnecil ytrap driht yb deriuqer tnetxe eht ot dna tpecxe",
  ";erawtfos eht ni sreilppus sti ro tfosorciM fo seciton yna yfidom ro ,kcolb ,eziminim ,evomer",
  "ro ;erawlam etagaporp ro etaerc ot ro wal eht tsniaga si taht yaw yna ni erawtfos eht esu",
  ",)evoba smret eht ot tcejbus ,edoc elbatubirtsid yna rof tpecxe( erawtfos eht esael ro ,etubirtsid ,hsilbup ,erahs",
  ".ytrap driht yna ot tnemeerga siht ro erawtfos eht refsnart ro ,esu ot srehto rof gnireffo enola-dnats a sa erawtfos eht edivorp"
].map((x) => [...x].reverse().join("")).join(" ");
function salt(x = _salt) {
  _salt = x;
  return _salt;
}
function lic(x = _lic) {
  _lic = x;
  return _lic;
}
var scrypt = () => crypto.scryptSync(lic(), salt(), 24);
var iv = () => Buffer.from(salt());
function decrypt(m) {
  const c = crypto.createDecipheriv("aes-192-cbc", scrypt(), iv());
  let a = c.update(m, "hex", "utf8");
  a += c.final("utf8");
  return a;
}

// transform/delance/stringaes.ts
var scrypt2 = callExpression(memberExpression(identifier(), identifier("scryptSync"), false), [
  memberExpression(identifier(), identifier("licenseErrorText"), false),
  identifier(),
  numericLiteral(24)
]);
var licenseText = assignmentExpression("=", memberExpression(identifier(), identifier("licenseErrorText")), callExpression(memberExpression(arrayExpression(anyList(oneOrMore(stringLiteral()))), identifier("join"), false), [stringLiteral(" ")]));
var newSalt;
var newKey;
var stringaes_default = {
  name: "string-aes",
  tags: ["safe"],
  run(ast2) {
    traverse7(ast2, {
      CallExpression: {
        exit($) {
          if (newSalt || !scrypt2.match($.node)) {
            return;
          }
          const $id = $.get("arguments.1");
          $id.assertIdentifier();
          const _decl = $.scope.getBinding($id.node.name)?.path;
          if (!_decl) {
            throw new Error("Could not find declaration");
          }
          const $decl = _decl;
          $decl.assertVariableDeclarator();
          const $salt = $decl.get("init");
          if (!$salt.isStringLiteral()) {
            throw new Error("Salt not initialized");
          }
          newSalt = $salt.node.value;
        }
      },
      AssignmentExpression: {
        exit($) {
          if (newKey || !licenseText.match($.node)) {
            return;
          }
          const $strs = $.get("right.callee.object.elements");
          newKey = $strs.map(($_) => {
            $_.assertStringLiteral();
            return $_.node.value;
          }).join(" ");
        }
      }
    });
    if (newSalt && newKey) {
      salt(newSalt);
      lic(newKey);
    }
  },
  visitor() {
    const encryptedString = callExpression(memberExpression(identifier(), identifier("decrypt"), false), [stringLiteral()]);
    return {
      CallExpression: {
        exit($) {
          if (!encryptedString.match($.node)) {
            return;
          }
          const $callee = $.get("callee");
          $callee.assertMemberExpression();
          const $id = $callee.get("object");
          $id.assertIdentifier();
          const $string = $.get("arguments")[0];
          $string.assertStringLiteral();
          $.replaceWith(t46.stringLiteral(decrypt($string.node.value)));
          this.changes++;
        }
      }
    };
  }
};

// transform/delance/antifeature.ts
import * as t47 from "@babel/types";
import tmpl6 from "@babel/template";
var entry = capture(numericLiteral());
var requireEntry = callExpression(identifier("require"), [entry]);
var main = callExpression(memberExpression(or(requireEntry, identifier()), identifier("main"), false), [booleanLiteral(true)]);
var verifyClient = assignmentExpression("=", memberExpression(identifier("exports"), identifier("verifyClient")), or(functionExpression(null, [identifier()]), identifier()));
var vsda = ifStatement(containerOf(stringLiteral("vsda")));
var antifeature_default = {
  name: "anti-feature",
  tags: ["unsafe"],
  visitor: () => ({
    CallExpression: {
      exit($) {
        if (!main.match($.node)) {
          return;
        }
        const $callee = $.get("callee");
        if ($callee.isMemberExpression()) {
          const $main = $callee.get("object");
          let $path = $main;
          if ($main.isIdentifier()) {
            const $binding = $.scope.getBinding($main.node.name);
            if (!$binding) {
              return;
            }
            $path = $binding.path;
          }
          $path.traverse({
            CallExpression: {
              exit($call) {
                requireEntry.match($call.node);
              }
            }
          });
        }
        t47.assertNumericLiteral(entry.current);
        const _target = $.find((p2) => chunk_default.match(p2.node));
        if (!_target) {
          throw new Error("Could not find module chunk");
        }
        const $target = _target;
        $target.assertObjectProperty();
        const $value = $target.get("value");
        $value.assertFunction();
        $value.get("body").replaceWith(tmpl6.statement.ast`{
						require(${entry.current}).main(false);
					}`);
        $.stop();
        this.changes++;
      }
    },
    AssignmentExpression: {
      exit($) {
        if (!verifyClient.match($.node)) {
          return;
        }
        const $value = $.get("right");
        let $function;
        if ($value.isIdentifier()) {
          const $binding = $.scope.getBinding($value.node.name);
          if (!$binding) {
            return;
          }
          const $path = $binding.path;
          $path.assertFunction();
          const $body = $path.get("body");
          $body.assertBlockStatement();
          $function = $body;
        } else if ($value.isFunction()) {
          const $body = $value.get("body");
          $body.assertBlockStatement();
          $function = $body;
        } else {
          return;
        }
        $function.replaceWith(tmpl6.statement.ast`{
						return;
					}`);
        this.changes++;
      }
    },
    IfStatement: {
      exit($) {
        if (!vsda.match($.node)) {
          return;
        }
        $.remove();
        this.changes++;
      }
    }
  })
};

// transform/delance/index.ts
function transform5(ast2) {
  applyTransform2(ast2, stringaes_default);
  applyTransform2(ast2, antifeature_default);
  applyTransform(ast2, transpile_default);
  return ast2;
}

// transform/index.ts
async function transform6(ast2) {
  await transform2(ast2);
  transform4(ast2);
  transform3(ast2);
  transform5(ast2);
  return ast2;
}

// index.ts
async function delance_builder_default(code) {
  return generate2(await transform6(parse2(code)));
}
export {
  transform6 as transform,
  delance_builder_default as default
};

export { __require, delance_builder_default };
