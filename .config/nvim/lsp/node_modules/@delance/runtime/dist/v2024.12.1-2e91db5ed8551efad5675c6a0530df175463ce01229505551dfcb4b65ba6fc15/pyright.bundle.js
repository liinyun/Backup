"use strict";

exports.id = 344;
exports.ids = [344];
exports.modules = {
  1811: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.nullCallback = undefined;
    exports.analyzeProgram = function (e, n, a, r, s, p) {
      let d = false;
      r = r ?? exports.nullCallback;
      try {
        i.throwIfCancellationRequested(p);
        const t = new l.Duration();
        d = e.analyze(n, p);
        const s = e.getFilesToAnalyzeCount();
        const o = n !== undefined;
        const c = e.getDiagnostics(a, o);
        const u = c.length;
        const m = t.getDurationInSeconds();
        if (u > 0 || !d) {
          r({
            diagnostics: c,
            filesInProgram: e.getFileCount(),
            requiringAnalysisCount: s,
            checkingOnlyOpenFiles: e.isCheckingOnlyOpenFiles(),
            fatalErrorOccurred: false,
            configParseErrorOccurred: false,
            elapsedTime: m,
            reason: 'analysis'
          });
        }
      } catch (e) {
        if (i.OperationCanceledException.is(e)) {
          return false;
        }
        const t = o.getErrorString(e);
        s.error(`Error performing analysis: ${t}`);
        r({
          diagnostics: [],
          filesInProgram: 0,
          requiringAnalysisCount: {
            files: 0,
            cells: 0
          },
          checkingOnlyOpenFiles: true,
          fatalErrorOccurred: true,
          configParseErrorOccurred: false,
          elapsedTime: 0,
          error: o.getSerializableError(e),
          reason: 'analysis'
        });
      }
      return d;
    };
    const i = require(91426);
    const o = __importStar(require(48281));
    const l = require(71582);
    exports.nullCallback = () => {};
  },
  12673: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.isAnnotationEvaluationPostponed = function (e) {
      if (e.isStubFile) {
        return true;
      }
      if (e.futureImports.has('annotations')) {
        return true;
      }
      if (a.PythonVersion.isGreaterOrEqualTo(e.executionEnvironment.pythonVersion, a.pythonVersion3_14)) {
        return true;
      }
      return false;
    };
    const a = require(63808);
  },
  26687: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.cleanNodeAnalysisInfo = function (e) {
      const t = s(e);
      if (t == null ? undefined : t.scope) {
        t.scope = undefined;
      }
      if (t == null ? undefined : t.declaration) {
        t.declaration = undefined;
      }
      if (t == null ? undefined : t.flowNode) {
        t.flowNode = undefined;
      }
      if (t == null ? undefined : t.afterFlowNode) {
        t.afterFlowNode = undefined;
      }
      if (t == null ? undefined : t.fileInfo) {
        t.fileInfo = undefined;
      }
      if (t == null ? undefined : t.codeFlowExpressions) {
        t.codeFlowExpressions = undefined;
      }
      if (t == null ? undefined : t.codeFlowComplexity) {
        t.codeFlowComplexity = undefined;
      }
      if (t == null ? undefined : t.dunderAllInfo) {
        t.dunderAllInfo = undefined;
      }
      if (t == null ? undefined : t.typeParamSymbol) {
        t.typeParamSymbol = undefined;
      }
    };
    exports.getImportInfo = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.importInfo;
      }
    };
    exports.setImportInfo = function (e, t) {
      i(e).importInfo = t;
    };
    exports.getScope = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.scope;
      }
    };
    exports.setScope = function (e, t) {
      i(e).scope = t;
    };
    exports.getDeclaration = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.declaration;
      }
    };
    exports.setDeclaration = function (e, t) {
      i(e).declaration = t;
    };
    exports.getFlowNode = r;
    exports.setFlowNode = function (e, t) {
      i(e).flowNode = t;
    };
    exports.getAfterFlowNode = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.afterFlowNode;
      }
    };
    exports.setAfterFlowNode = function (e, t) {
      i(e).afterFlowNode = t;
    };
    exports.getFileInfo = function (e) {
      while (e.nodeType !== 36) {
        e = e.parent;
      }
      return s(e).fileInfo;
    };
    exports.setFileInfo = function (e, t) {
      i(e).fileInfo = t;
    };
    exports.getCodeFlowExpressions = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.codeFlowExpressions;
      }
    };
    exports.setCodeFlowExpressions = function (e, t) {
      i(e).codeFlowExpressions = t;
    };
    exports.getCodeFlowComplexity = function (e) {
      var t;
      const n = s(e);
      if ((t = n == null ? undefined : n.codeFlowComplexity) !== null && t !== undefined) {
        return t;
      } else {
        return 0;
      }
    };
    exports.setCodeFlowComplexity = function (e, t) {
      i(e).codeFlowComplexity = t;
    };
    exports.getDunderAllInfo = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.dunderAllInfo;
      }
    };
    exports.setDunderAllInfo = function (e, t) {
      i(e).dunderAllInfo = t;
    };
    exports.isCodeUnreachable = function (e) {
      let t = e;
      while (t) {
        const e = r(t);
        if (e) {
          return !!(e.flags & a.FlowFlags.Unreachable);
        }
        t = t.parent;
      }
      return false;
    };
    const a = require(50299);
    function r(e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.flowNode;
      }
    }
    function s(e) {
      return e.a;
    }
    function i(e) {
      let t = e.a;
      if (!t) {
        e.a = t = {};
      }
      return t;
    }
  },
  82695: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.BackgroundAnalysisProgram = exports.InvalidatedReason = undefined;
    require(23070);
    const a = require(1811);
    const r = require(79253);
    var s;
    (function (e) {
      e[e.Reanalyzed = 0] = 'Reanalyzed';
      e[e.SourceWatcherChanged = 1] = 'SourceWatcherChanged';
      e[e.LibraryWatcherChanged = 2] = 'LibraryWatcherChanged';
      e[e.LibraryWatcherContentOnlyChanged = 3] = 'LibraryWatcherContentOnlyChanged';
    })(s || (exports.InvalidatedReason = s = {}));
    exports.BackgroundAnalysisProgram = class {
      constructor(e, t, n, a, s, i, o) {
        var l;
        this.serviceId = e;
        this._serviceProvider = t;
        this._configOptions = n;
        this._importResolver = a;
        this._backgroundAnalysis = s;
        this._maxAnalysisTime = i;
        this._disableChecker = o;
        this._disposed = false;
        this._program = new r.Program(this.importResolver, this.configOptions, this._serviceProvider, undefined, this._disableChecker, e);
        if ((l = this._backgroundAnalysis) !== null && l !== undefined) {
          l.setProgramView(this._program);
        }
      }
      get configOptions() {
        return this._configOptions;
      }
      get importResolver() {
        return this._importResolver;
      }
      get program() {
        return this._program;
      }
      get host() {
        return this._importResolver.host;
      }
      get backgroundAnalysis() {
        return this._backgroundAnalysis;
      }
      hasSourceFile(e) {
        return !!this._program.getSourceFile(e);
      }
      setConfigOptions(e) {
        var t;
        this._configOptions = e;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.setConfigOptions(e);
        }
        this._program.setConfigOptions(e);
      }
      setImportResolver(e) {
        var t;
        this._importResolver = e;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.setImportResolver(e);
        }
        this._program.setImportResolver(e);
        this.configOptions.getExecutionEnvironments().forEach(e => this._ensurePartialStubPackages(e));
      }
      setTrackedFiles(e) {
        var t;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.setTrackedFiles(e);
        }
        const n = this._program.setTrackedFiles(e);
        this._reportDiagnosticsForRemovedFiles(n);
      }
      setAllowedThirdPartyImports(e) {
        var t;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.setAllowedThirdPartyImports(e);
        }
        this._program.setAllowedThirdPartyImports(e);
      }
      setFileOpened(e, t, n, a) {
        var r;
        if ((r = this._backgroundAnalysis) !== null && r !== undefined) {
          r.setFileOpened(e, t, n, a);
        }
        this._program.setFileOpened(e, t, n, a);
      }
      getChainedUri(e) {
        return this._program.getChainedUri(e);
      }
      updateChainedUri(e, t) {
        var n;
        if ((n = this._backgroundAnalysis) !== null && n !== undefined) {
          n.updateChainedUri(e, t);
        }
        this._program.updateChainedUri(e, t);
      }
      updateOpenFileContents(e, t, n, a) {
        var r;
        if ((r = this._backgroundAnalysis) !== null && r !== undefined) {
          r.setFileOpened(e, t, n, a);
        }
        this._program.setFileOpened(e, t, n, a);
        this.markFilesDirty([e], true);
      }
      setFileClosed(e, t) {
        var n;
        if ((n = this._backgroundAnalysis) !== null && n !== undefined) {
          n.setFileClosed(e, t);
        }
        const a = this._program.setFileClosed(e, t);
        this._reportDiagnosticsForRemovedFiles(a);
      }
      addInterimFile(e) {
        var t;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.addInterimFile(e);
        }
        this._program.addInterimFile(e);
      }
      markAllFilesDirty(e) {
        var t;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.markAllFilesDirty(e);
        }
        this._program.markAllFilesDirty(e);
      }
      markFilesDirty(e, t) {
        var n;
        if ((n = this._backgroundAnalysis) !== null && n !== undefined) {
          n.markFilesDirty(e, t);
        }
        this._program.markFilesDirty(e, t);
      }
      setCompletionCallback(e) {
        var t;
        this._onAnalysisCompletion = e;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.setCompletionCallback(e);
        }
      }
      startAnalysis(e) {
        if (this._backgroundAnalysis) {
          this._backgroundAnalysis.startAnalysis(e);
          return false;
        } else {
          return a.analyzeProgram(this._program, this._maxAnalysisTime, this._configOptions, this._onAnalysisCompletion, this._serviceProvider.console(), e);
        }
      }
      async analyzeFile(e, t) {
        if (this._backgroundAnalysis) {
          return this._backgroundAnalysis.analyzeFile(e, t);
        } else {
          return this._program.analyzeFile(e, t);
        }
      }
      libraryUpdated() {
        return false;
      }
      async getDiagnosticsForRange(e, t, n) {
        if (this._backgroundAnalysis) {
          return this._backgroundAnalysis.getDiagnosticsForRange(e, t, n);
        } else {
          return this._program.getDiagnosticsForRange(e, t);
        }
      }
      async writeTypeStub(e, t, n, r) {
        if (this._backgroundAnalysis) {
          return this._backgroundAnalysis.writeTypeStub(e, t, n, r);
        } else {
          a.analyzeProgram(this._program, undefined, this._configOptions, this._onAnalysisCompletion, this._serviceProvider.console(), r);
          return this._program.writeTypeStub(e, t, n, r);
        }
      }
      invalidateAndForceReanalysis(e) {
        var t;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.invalidateAndForceReanalysis(e);
        }
        this._importResolver.invalidateCache();
        this._program.markAllFilesDirty(true);
      }
      restart() {
        var e;
        if ((e = this._backgroundAnalysis) !== null && e !== undefined) {
          e.restart();
        }
      }
      dispose() {
        var e;
        var t;
        if (!this._disposed) {
          this._disposed = true;
          this._program.dispose();
          if ((e = this._backgroundAnalysis) !== null && e !== undefined) {
            e.shutdown();
          }
          if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
            t.dispose();
          }
        }
      }
      enterEditMode() {
        this._preEditAnalysis = this._backgroundAnalysis;
        this._backgroundAnalysis = undefined;
        this._program.enterEditMode();
      }
      exitEditMode() {
        this._backgroundAnalysis = this._preEditAnalysis;
        this._preEditAnalysis = undefined;
        return this._program.exitEditMode();
      }
      _ensurePartialStubPackages(e) {
        var t;
        var n;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.ensurePartialStubPackages((n = e.root) === null || n === undefined ? undefined : n.toString());
        }
        return this._importResolver.ensurePartialStubPackages(e);
      }
      _reportDiagnosticsForRemovedFiles(e) {
        if (e.length !== 0 && !this._backgroundAnalysis && this._onAnalysisCompletion) {
          this._onAnalysisCompletion({
            diagnostics: e,
            filesInProgram: this._program.getFileCount(),
            requiringAnalysisCount: this._program.getFilesToAnalyzeCount(),
            checkingOnlyOpenFiles: this._program.isCheckingOnlyOpenFiles(),
            fatalErrorOccurred: false,
            configParseErrorOccurred: false,
            elapsedTime: 0,
            reason: 'tracking'
          });
        }
      }
    };
  },
  15157: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DummyScopeGenerator = exports.ReturnFinder = exports.YieldFinder = exports.Binder = undefined;
    const i = require(58147);
    const o = require(48281);
    const l = require(65880);
    const p = require(54010);
    const d = require(56814);
    const c = require(88754);
    const u = require(27113);
    const m = require(67703);
    const y = __importStar(require(26687));
    const g = require(50299);
    const h = require(28445);
    const f = __importStar(require(41557));
    const T = require(88744);
    const v = require(35197);
    const b = __importStar(require(28676));
    const _ = require(58253);
    const C = require(12097);
    class I extends T.ParseTreeWalker {
      constructor(e, t = false) {
        super();
        this._moduleSymbolOnly = t;
        this._deferredBindingTasks = [];
        this._currentExceptTargets = [];
        this._finallyTargets = [];
        this._typingImportAliases = [];
        this._sysImportAliases = [];
        this._dataclassesImportAliases = [];
        this._typingSymbolAliases = new Map();
        this._dataclassesSymbolAliases = new Map();
        this._dunderAllStringNodes = [];
        this._usesUnsupportedDunderAllForm = false;
        this._isInExceptSuite = false;
        this._isInAnnotatedAnnotation = false;
        this._potentialHiddenSymbols = new Map();
        this._potentialPrivateSymbols = new Map();
        this._codeFlowComplexity = 0;
        this._fileInfo = e;
      }
      bindModule(e) {
        var t;
        const n = this._fileInfo.builtinsScope === undefined;
        this._addTypingImportAliasesFromBuiltinsScope();
        this._createNewScope(n ? 5 : 4, this._fileInfo.builtinsScope, undefined, () => {
          y.setScope(e, this._currentScope);
          y.setFlowNode(e, this._currentFlowNode);
          this._addImplicitSymbolToCurrentScope('__name__', e, 'str');
          this._addImplicitSymbolToCurrentScope('__loader__', e, 'Any');
          this._addImplicitSymbolToCurrentScope('__package__', e, 'str | None');
          this._addImplicitSymbolToCurrentScope('__spec__', e, 'Any');
          this._addImplicitSymbolToCurrentScope('__path__', e, 'Iterable[str]');
          this._addImplicitSymbolToCurrentScope('__file__', e, 'str');
          this._addImplicitSymbolToCurrentScope('__cached__', e, 'str');
          this._addImplicitSymbolToCurrentScope('__dict__', e, 'Dict[str, Any]');
          this._addImplicitSymbolToCurrentScope('__annotations__', e, 'Dict[str, Any]');
          this._addImplicitSymbolToCurrentScope('__builtins__', e, 'Any');
          this._addImplicitSymbolToCurrentScope('__doc__', e, 'str | None');
          this._currentFlowNode = this._createStartFlowNode();
          this._walkStatementsAndReportUnreachable(e.d.statements);
          y.setAfterFlowNode(e, this._currentFlowNode);
          y.setCodeFlowExpressions(e, this._currentScopeCodeFlowExpressions);
          y.setCodeFlowComplexity(e, this._codeFlowComplexity);
        });
        this._bindDeferred();
        this._potentialHiddenSymbols.forEach((e, t) => {
          var n;
          if (!((n = this._dunderAllNames) === null || n === undefined ? undefined : n.some(e => e === t))) {
            if (this._fileInfo.isStubFile) {
              e.setIsExternallyHidden();
            } else {
              e.setPrivatePyTypedImport();
            }
          }
        });
        this._potentialPrivateSymbols.forEach((e, t) => {
          var n;
          if (!((n = this._dunderAllNames) === null || n === undefined ? undefined : n.some(e => e === t))) {
            e.setIsPrivateMember();
          }
        });
        if (this._dunderAllNames) {
          y.setDunderAllInfo(e, {
            names: this._dunderAllNames,
            stringNodes: this._dunderAllStringNodes,
            usesUnsupportedDunderAllForm: this._usesUnsupportedDunderAllForm
          });
        } else {
          y.setDunderAllInfo(e, undefined);
        }
        const a = y.getScope(e);
        if (a && this._dunderAllNames) {
          for (const e of this._dunderAllNames) {
            if ((t = a.symbolTable.get(e)) !== null && t !== undefined) {
              t.setIsInDunderAll();
            }
          }
        }
      }
      visitModule(e) {
        o.fail('We should never get here');
        return false;
      }
      visitSuite(e) {
        this._walkStatementsAndReportUnreachable(e.d.statements);
        return false;
      }
      visitModuleName(e) {
        const t = y.getImportInfo(e);
        o.assert(t !== undefined);
        if (t.isNativeLib) {
          return true;
        }
        if (!t.isImportFound) {
          this._addDiagnostic(l.DiagnosticRule.reportMissingImports, m.LocMessage.importResolveFailure().format({
            importName: t.importName,
            venv: this._fileInfo.executionEnvironment.name
          }), e);
          return true;
        }
        if (!t.isStubFile && t.importType === 1 && !t.pyTypedInfo) {
          const n = this._addDiagnostic(l.DiagnosticRule.reportMissingTypeStubs, m.LocMessage.stubFileMissing().format({
            importName: t.importName
          }), e);
          if (n) {
            const e = {
              action: 'pyright.createtypestub',
              moduleName: t.importName
            };
            n.addAction(e);
          }
        }
        return true;
      }
      visitClass(e) {
        this.walkMultiple(e.d.decorators);
        const t = {
          type: 6,
          node: e,
          uri: this._fileInfo.fileUri,
          range: d.convertTextRangeToRange(e.d.name, this._fileInfo.lines),
          moduleName: this._fileInfo.moduleName,
          isInExceptSuite: this._isInExceptSuite
        };
        const n = this._bindNameToScope(this._currentScope, e.d.name);
        let a;
        if (n) {
          n.addDeclaration(t);
        }
        y.setDeclaration(e, t);
        if (e.d.typeParams) {
          this.walk(e.d.typeParams);
          a = y.getScope(e.d.typeParams);
        }
        this.walkMultiple(e.d.arguments);
        this._createNewScope(3, a ?? this._getNonClassParentScope(), undefined, () => {
          y.setScope(e, this._currentScope);
          this._addImplicitSymbolToCurrentScope('__doc__', e, 'str | None');
          this._addImplicitSymbolToCurrentScope('__module__', e, 'str');
          this._addImplicitSymbolToCurrentScope('__qualname__', e, 'str');
          this._dunderSlotsEntries = undefined;
          if (!this._moduleSymbolOnly) {
            this.walk(e.d.suite);
          }
          if (this._dunderSlotsEntries) {
            this._addSlotsToCurrentScope(this._dunderSlotsEntries);
          }
          this._dunderSlotsEntries = undefined;
        });
        this._createAssignmentTargetFlowNodes(e.d.name, false, false);
        return false;
      }
      visitFunction(e) {
        this._createVariableAnnotationFlowNode();
        y.setFlowNode(e, this._currentFlowNode);
        const t = this._bindNameToScope(this._currentScope, e.d.name);
        const n = f.getEnclosingClass(e, true);
        const a = {
          type: 5,
          node: e,
          isMethod: !!n,
          isGenerator: false,
          uri: this._fileInfo.fileUri,
          range: d.convertTextRangeToRange(e.d.name, this._fileInfo.lines),
          moduleName: this._fileInfo.moduleName,
          isInExceptSuite: this._isInExceptSuite
        };
        let r;
        if (t) {
          t.addDeclaration(a);
        }
        y.setDeclaration(e, a);
        e.d.params.forEach(e => {
          if (e.d.defaultValue) {
            this.walk(e.d.defaultValue);
          }
        });
        if (e.d.typeParams) {
          this.walk(e.d.typeParams);
          r = y.getScope(e.d.typeParams);
        }
        this.walkMultiple(e.d.decorators);
        e.d.params.forEach(e => {
          if (e.d.annotation) {
            this.walk(e.d.annotation);
          }
          if (e.d.annotationComment) {
            this.walk(e.d.annotationComment);
          }
        });
        if (e.d.returnAnnotation) {
          this.walk(e.d.returnAnnotation);
        }
        if (e.d.funcAnnotationComment) {
          this.walk(e.d.funcAnnotationComment);
        }
        this._createNewScope(2, r ?? this._getNonClassParentScope(), undefined, () => {
          y.setScope(e, this._currentScope);
          if (f.getEnclosingClass(e)) {
            this._addImplicitSymbolToCurrentScope('__class__', e, 'type[self]');
          }
          this._deferBinding(() => {
            this._currentFlowNode = this._createStartFlowNode();
            this._codeFlowComplexity = 0;
            e.d.params.forEach(e => {
              if (e.d.name) {
                const t = this._bindNameToScope(this._currentScope, e.d.name);
                if (t) {
                  const n = {
                    type: 2,
                    node: e,
                    uri: this._fileInfo.fileUri,
                    range: d.convertTextRangeToRange(e, this._fileInfo.lines),
                    moduleName: this._fileInfo.moduleName,
                    isInExceptSuite: this._isInExceptSuite
                  };
                  t.addDeclaration(n);
                  y.setDeclaration(e.d.name, n);
                }
                this._createFlowAssignment(e.d.name);
              }
            });
            this._targetFunctionDeclaration = a;
            this._currentReturnTarget = this._createBranchLabel();
            this.walk(e.d.suite);
            this._targetFunctionDeclaration = undefined;
            y.setAfterFlowNode(e.d.suite, this._currentFlowNode);
            this._addAntecedent(this._currentReturnTarget, this._currentFlowNode);
            const t = this._finishFlowLabel(this._currentReturnTarget);
            y.setAfterFlowNode(e, t);
            y.setCodeFlowExpressions(e, this._currentScopeCodeFlowExpressions);
            y.setCodeFlowComplexity(e, this._codeFlowComplexity);
          });
        });
        this._createAssignmentTargetFlowNodes(e.d.name, false, false);
        return false;
      }
      visitLambda(e) {
        this._createVariableAnnotationFlowNode();
        y.setFlowNode(e, this._currentFlowNode);
        e.d.params.forEach(e => {
          if (e.d.defaultValue) {
            this.walk(e.d.defaultValue);
          }
        });
        this._createNewScope(2, this._getNonClassParentScope(), undefined, () => {
          y.setScope(e, this._currentScope);
          this._deferBinding(() => {
            this._currentFlowNode = this._createStartFlowNode();
            e.d.params.forEach(e => {
              if (e.d.name) {
                const t = this._bindNameToScope(this._currentScope, e.d.name);
                if (t) {
                  const n = {
                    type: 2,
                    node: e,
                    uri: this._fileInfo.fileUri,
                    range: d.convertTextRangeToRange(e, this._fileInfo.lines),
                    moduleName: this._fileInfo.moduleName,
                    isInExceptSuite: this._isInExceptSuite
                  };
                  t.addDeclaration(n);
                  y.setDeclaration(e.d.name, n);
                }
                this._createFlowAssignment(e.d.name);
                this.walk(e.d.name);
                y.setFlowNode(e, this._currentFlowNode);
              }
            });
            this.walk(e.d.expr);
            y.setCodeFlowExpressions(e, this._currentScopeCodeFlowExpressions);
          });
        });
        return false;
      }
      visitCall(e) {
        var t;
        var n;
        this._disableTrueFalseTargets(() => {
          this.walk(e.d.leftExpr);
          f.getArgsByRuntimeOrder(e).forEach(e => {
            if (this._currentFlowNode) {
              y.setFlowNode(e, this._currentFlowNode);
            }
            this.walk(e);
          });
        });
        if (!f.isNodeContainedWithinNodeType(e, 16) && !this._isInAnnotatedAnnotation) {
          this._createCallFlowNode(e);
        }
        if (this._currentScope.type === 4 && e.d.leftExpr.nodeType === 35 && e.d.leftExpr.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.leftExpr.d.value === '__all__') {
          let a = true;
          if (e.d.leftExpr.d.member.d.value === 'extend' && e.d.args.length === 1) {
            const t = e.d.args[0].d.valueExpr;
            if (t.nodeType === 34) {
              if (t.d.items.every(e => {
                var t;
                var n;
                return e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49 && ((t = this._dunderAllNames) === null || t === undefined || t.push(e.d.strings[0].d.value), (n = this._dunderAllStringNodes) === null || n === undefined || n.push(e.d.strings[0]), true);
              })) {
                a = false;
              }
            } else {
              if (t.nodeType === 35 && t.d.leftExpr.nodeType === 38 && t.d.member.d.value === '__all__') {
                const e = this._getDunderAllNamesFromImport(t.d.leftExpr.d.value);
                if (e && e.length > 0) {
                  e.forEach(e => {
                    var t;
                    if ((t = this._dunderAllNames) !== null && t !== undefined) {
                      t.push(e);
                    }
                  });
                }
                a = false;
              }
            }
          } else {
            if (e.d.leftExpr.d.member.d.value === 'remove' && e.d.args.length === 1) {
              const t = e.d.args[0].d.valueExpr;
              if (t.nodeType === 48 && t.d.strings.length === 1 && t.d.strings[0].nodeType === 49 && this._dunderAllNames) {
                this._dunderAllNames = this._dunderAllNames.filter(e => e !== t.d.strings[0].d.value);
                this._dunderAllStringNodes = this._dunderAllStringNodes.filter(e => e.d.value !== t.d.strings[0].d.value);
                a = false;
              }
            } else {
              if (e.d.leftExpr.d.member.d.value === 'append' && e.d.args.length === 1) {
                const r = e.d.args[0].d.valueExpr;
                if (r.nodeType === 48 && r.d.strings.length === 1 && r.d.strings[0].nodeType === 49) {
                  if ((t = this._dunderAllNames) !== null && t !== undefined) {
                    t.push(r.d.strings[0].d.value);
                  }
                  if ((n = this._dunderAllStringNodes) !== null && n !== undefined) {
                    n.push(r.d.strings[0]);
                  }
                  a = false;
                }
              }
            }
          }
          if (a) {
            this._usesUnsupportedDunderAllForm = true;
            this._addDiagnostic(l.DiagnosticRule.reportUnsupportedDunderAll, m.LocMessage.unsupportedDunderAllOperation(), e);
          }
        }
        return false;
      }
      visitTypeParameterList(e) {
        const t = new v.Scope(0, this._getNonClassParentScope(), this._currentScope);
        e.d.params.forEach(e => {
          if (e.d.boundExpr) {
            this.walk(e.d.boundExpr);
          }
        });
        const n = new Set();
        e.d.params.forEach(a => {
          const r = a.d.name;
          const s = t.addSymbol(r.d.value, 0);
          const i = {
            type: 3,
            node: a,
            uri: this._fileInfo.fileUri,
            range: d.convertTextRangeToRange(e, this._fileInfo.lines),
            moduleName: this._fileInfo.moduleName,
            isInExceptSuite: this._isInExceptSuite
          };
          s.addDeclaration(i);
          y.setDeclaration(r, i);
          if (n.has(r.d.value)) {
            this._addSyntaxError(m.LocMessage.typeParameterExistingTypeParameter().format({
              name: r.d.value
            }), r);
          } else {
            n.add(r.d.value);
          }
        });
        e.d.params.forEach(e => {
          if (e.d.defaultExpr) {
            this.walk(e.d.defaultExpr);
          }
        });
        y.setScope(e, t);
        return false;
      }
      visitTypeAlias(e) {
        let t;
        this._bindNameToScope(this._currentScope, e.d.name);
        this.walk(e.d.name);
        if (e.d.typeParams) {
          this.walk(e.d.typeParams);
          t = y.getScope(e.d.typeParams);
        }
        const n = {
          type: 4,
          node: e,
          uri: this._fileInfo.fileUri,
          range: d.convertTextRangeToRange(e.d.name, this._fileInfo.lines),
          moduleName: this._fileInfo.moduleName,
          isInExceptSuite: this._isInExceptSuite,
          docString: this._getVariableDocString(e.d.expr)
        };
        const a = this._bindNameToScope(this._currentScope, e.d.name);
        if (a) {
          a.addDeclaration(n);
        }
        y.setDeclaration(e, n);
        this._createAssignmentTargetFlowNodes(e.d.name, true, false);
        const r = this._currentScope;
        this._currentScope = t ?? this._currentScope;
        this.walk(e.d.expr);
        this._currentScope = r;
        return false;
      }
      visitAssignment(e) {
        if (this._handleTypingStubAssignmentOrAnnotation(e)) {
          return false;
        }
        this._bindPossibleTupleNamedTarget(e.d.leftExpr);
        if (e.d.annotationComment) {
          this.walk(e.d.annotationComment);
          this._addTypeDeclarationForVariable(e.d.leftExpr, e.d.annotationComment);
        }
        if (e.d.chainedAnnotationComment) {
          this._addDiagnostic(l.DiagnosticRule.reportInvalidTypeForm, m.LocMessage.annotationNotSupported(), e.d.chainedAnnotationComment);
        }
        if (e.d.leftExpr.nodeType === 27) {
          const t = e.d.leftExpr;
          if (t.d.items.length === 1 && !t.d.trailingComma && t.d.items[0].d.valueExpr.nodeType === 48 && g.isCodeFlowSupportedForReference(t.d.leftExpr)) {
            const e = g.createKeyForReference(t.d.leftExpr);
            this._currentScopeCodeFlowExpressions.add(e);
          }
        }
        this.walk(e.d.rightExpr);
        let t = true;
        if (f.getEnclosingFunction(e) || e.d.rightExpr.nodeType === 9 && this._fileInfo.isTypingStubFile || f.isWithinLoop(e)) {
          t = false;
        }
        this._addInferredTypeAssignmentForVariable(e.d.leftExpr, e.d.rightExpr, t);
        this._createAssignmentTargetFlowNodes(e.d.leftExpr, true, false);
        if (this._currentScope.type === 4 && (e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === '__all__' || e.d.leftExpr.nodeType === 54 && e.d.leftExpr.d.valueExpr.nodeType === 38 && e.d.leftExpr.d.valueExpr.d.value === '__all__')) {
          const t = e.d.rightExpr;
          this._dunderAllNames = [];
          let n = false;
          if (t.nodeType === 34) {
            t.d.items.forEach(e => {
              if (e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49) {
                this._dunderAllNames.push(e.d.strings[0].d.value);
                this._dunderAllStringNodes.push(e.d.strings[0]);
              } else {
                n = true;
              }
            });
          } else {
            if (t.nodeType === 52) {
              t.d.items.forEach(e => {
                if (e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49) {
                  this._dunderAllNames.push(e.d.strings[0].d.value);
                  this._dunderAllStringNodes.push(e.d.strings[0]);
                } else {
                  n = true;
                }
              });
            } else {
              n = true;
            }
          }
          if (n) {
            this._usesUnsupportedDunderAllForm = true;
            this._addDiagnostic(l.DiagnosticRule.reportUnsupportedDunderAll, m.LocMessage.unsupportedDunderAllOperation(), e);
          }
        }
        if (this._currentScope.type === 3 && (e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === '__slots__' || e.d.leftExpr.nodeType === 54 && e.d.leftExpr.d.valueExpr.nodeType === 38 && e.d.leftExpr.d.valueExpr.d.value === '__slots__')) {
          const t = e.d.rightExpr;
          this._dunderSlotsEntries = [];
          let n = true;
          if (t.nodeType === 48) {
            this._dunderSlotsEntries.push(t);
          } else {
            if (t.nodeType === 34) {
              t.d.items.forEach(e => {
                if (e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49) {
                  this._dunderSlotsEntries.push(e);
                } else {
                  n = false;
                }
              });
            } else {
              if (t.nodeType === 52) {
                t.d.items.forEach(e => {
                  if (e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49) {
                    this._dunderSlotsEntries.push(e);
                  } else {
                    n = false;
                  }
                });
              } else {
                n = false;
              }
            }
          }
          if (!n) {
            this._dunderSlotsEntries = undefined;
          }
        }
        return false;
      }
      visitAssignmentExpression(e) {
        this._disableTrueFalseTargets(() => {
          this.walk(e.d.rightExpr);
        });
        const t = f.getEvaluationNodeForAssignmentExpression(e);
        if (t) {
          const n = y.getScope(t);
          let a = this._currentScope;
          while (a && a !== n) {
            if (a.lookUpSymbol(e.d.name.d.value)) {
              this._addSyntaxError(m.LocMessage.assignmentExprComprehension().format({
                name: e.d.name.d.value
              }), e.d.name);
              break;
            }
            a = a.parent;
          }
          this._bindNameToScope(n, e.d.name);
          this._addInferredTypeAssignmentForVariable(e.d.name, e.d.rightExpr);
          this._createAssignmentTargetFlowNodes(e.d.name, true, false);
        } else {
          this._addSyntaxError(m.LocMessage.assignmentExprContext(), e);
          this.walk(e.d.name);
        }
        return false;
      }
      visitAugmentedAssignment(e) {
        this.walk(e.d.leftExpr);
        this.walk(e.d.rightExpr);
        this._bindPossibleTupleNamedTarget(e.d.destExpr);
        this._createAssignmentTargetFlowNodes(e.d.destExpr, false, false);
        if (e.d.operator === 1 && this._currentScope.type === 4 && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === '__all__') {
          const t = e.d.rightExpr;
          let n = true;
          if (t.nodeType === 34) {
            t.d.items.forEach(e => {
              var t;
              if (e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49) {
                if ((t = this._dunderAllNames) !== null && t !== undefined) {
                  t.push(e.d.strings[0].d.value);
                }
                this._dunderAllStringNodes.push(e.d.strings[0]);
              }
            });
            n = false;
          } else {
            if (t.nodeType === 35 && t.d.leftExpr.nodeType === 38 && t.d.member.d.value === '__all__') {
              const e = this._getDunderAllNamesFromImport(t.d.leftExpr.d.value);
              if (e) {
                e.forEach(e => {
                  var t;
                  if ((t = this._dunderAllNames) !== null && t !== undefined) {
                    t.push(e);
                  }
                });
                n = false;
              }
            }
          }
          if (n) {
            this._usesUnsupportedDunderAllForm = true;
            this._addDiagnostic(l.DiagnosticRule.reportUnsupportedDunderAll, m.LocMessage.unsupportedDunderAllOperation(), e);
          }
        }
        return false;
      }
      visitDel(e) {
        e.d.targets.forEach(e => {
          this._bindPossibleTupleNamedTarget(e);
          this.walk(e);
          this._createAssignmentTargetFlowNodes(e, false, true);
        });
        return false;
      }
      visitTypeAnnotation(e) {
        var t;
        if (this._handleTypingStubAssignmentOrAnnotation(e)) {
          return false;
        }
        const n = ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 3 && f.getEnclosingClass(e, true) !== undefined;
        if (!n) {
          this.walk(e.d.annotation);
        }
        this._createVariableAnnotationFlowNode();
        this._bindPossibleTupleNamedTarget(e.d.valueExpr);
        this._addTypeDeclarationForVariable(e.d.valueExpr, e.d.annotation);
        if (n) {
          this.walk(e.d.annotation);
        }
        const a = [];
        if (this._isNarrowingExpression(e.d.valueExpr, a)) {
          a.forEach(e => {
            const t = g.createKeyForReference(e);
            this._currentScopeCodeFlowExpressions.add(t);
          });
        }
        this.walk(e.d.valueExpr);
        return false;
      }
      visitFor(e) {
        this._bindPossibleTupleNamedTarget(e.d.targetExpr);
        this._addInferredTypeAssignmentForVariable(e.d.targetExpr, e);
        this.walk(e.d.iterableExpr);
        const t = this._createLoopLabel();
        const n = this._createBranchLabel();
        const a = this._createBranchLabel();
        this._addAntecedent(t, this._currentFlowNode);
        this._currentFlowNode = t;
        this._addAntecedent(n, this._currentFlowNode);
        const r = this._trackCodeFlowExpressions(() => {
          this._createAssignmentTargetFlowNodes(e.d.targetExpr, true, false);
        });
        this._bindLoopStatement(t, a, () => {
          this.walk(e.d.forSuite);
          this._addAntecedent(t, this._currentFlowNode);
          r.forEach(e => {
            var t;
            if ((t = this._currentScopeCodeFlowExpressions) !== null && t !== undefined) {
              t.add(e);
            }
          });
        });
        this._currentFlowNode = this._finishFlowLabel(n);
        if (e.d.elseSuite) {
          this.walk(e.d.elseSuite);
        }
        this._addAntecedent(a, this._currentFlowNode);
        this._currentFlowNode = this._finishFlowLabel(a);
        if (e.d.asyncToken && !this._fileInfo.ipythonMode) {
          const t = f.getEnclosingFunction(e);
          if (!t || !t.d.isAsync) {
            this._addSyntaxError(m.LocMessage.asyncNotInAsyncFunction(), e.d.asyncToken);
          }
        }
        return false;
      }
      visitContinue(e) {
        if (this._currentContinueTarget) {
          this._addAntecedent(this._currentContinueTarget, this._currentFlowNode);
        }
        this._currentFlowNode = I._unreachableFlowNode;
        return false;
      }
      visitBreak(e) {
        if (this._currentBreakTarget) {
          this._addAntecedent(this._currentBreakTarget, this._currentFlowNode);
        }
        this._currentFlowNode = I._unreachableFlowNode;
        return false;
      }
      visitReturn(e) {
        if (this._targetFunctionDeclaration) {
          if (!this._targetFunctionDeclaration.returnStatements) {
            this._targetFunctionDeclaration.returnStatements = [];
          }
          this._targetFunctionDeclaration.returnStatements.push(e);
        }
        if (e.d.expr) {
          this.walk(e.d.expr);
        }
        y.setFlowNode(e, this._currentFlowNode);
        if (this._currentReturnTarget) {
          this._addAntecedent(this._currentReturnTarget, this._currentFlowNode);
        }
        this._finallyTargets.forEach(e => {
          this._addAntecedent(e, this._currentFlowNode);
        });
        this._currentFlowNode = I._unreachableFlowNode;
        return false;
      }
      visitYield(e) {
        if (this._isInComprehension(e, true)) {
          this._addSyntaxError(m.LocMessage.yieldWithinComprehension(), e);
        }
        this._bindYield(e);
        return false;
      }
      visitYieldFrom(e) {
        if (this._isInComprehension(e, true)) {
          this._addSyntaxError(m.LocMessage.yieldWithinComprehension(), e);
        }
        this._bindYield(e);
        return false;
      }
      visitMemberAccess(e) {
        this.walk(e.d.leftExpr);
        y.setFlowNode(e, this._currentFlowNode);
        return false;
      }
      visitName(e) {
        y.setFlowNode(e, this._currentFlowNode);
        return false;
      }
      visitIndex(e) {
        y.setFlowNode(e, this._currentFlowNode);
        this.walk(e.d.leftExpr);
        const t = this._isInAnnotatedAnnotation;
        if (this._isTypingAnnotation(e.d.leftExpr, 'Annotated')) {
          this._isInAnnotatedAnnotation = true;
        }
        e.d.items.forEach(e => {
          this.walk(e);
        });
        this._isInAnnotatedAnnotation = t;
        return false;
      }
      visitIf(e) {
        const t = this._currentFlowNode;
        const n = this._createBranchLabel();
        const a = this._createBranchLabel();
        const r = this._createBranchLabel(t);
        r.affectedExpressions = this._trackCodeFlowExpressions(() => {
          const t = b.evaluateStaticBoolLikeExpression(e.d.testExpr, this._fileInfo.executionEnvironment, this._fileInfo.definedConstants, this._typingImportAliases, this._sysImportAliases);
          this._bindConditional(e.d.testExpr, n, a);
          this._currentFlowNode = t === false ? I._unreachableFlowNode : this._finishFlowLabel(n);
          this.walk(e.d.ifSuite);
          this._addAntecedent(r, this._currentFlowNode);
          this._currentFlowNode = t === true ? I._unreachableFlowNode : this._finishFlowLabel(a);
          if (e.d.elseSuite) {
            this.walk(e.d.elseSuite);
          } else {
            this._bindNeverCondition(e.d.testExpr, r, false);
          }
          this._addAntecedent(r, this._currentFlowNode);
          this._currentFlowNode = this._finishFlowLabel(r);
        });
        return false;
      }
      visitWhile(e) {
        const t = this._createBranchLabel();
        const n = this._createBranchLabel();
        const a = this._createBranchLabel();
        const r = b.evaluateStaticBoolLikeExpression(e.d.testExpr, this._fileInfo.executionEnvironment, this._fileInfo.definedConstants, this._typingImportAliases, this._sysImportAliases);
        const s = this._createLoopLabel();
        this._addAntecedent(s, this._currentFlowNode);
        this._currentFlowNode = s;
        this._bindConditional(e.d.testExpr, t, n);
        this._currentFlowNode = r === false ? I._unreachableFlowNode : this._finishFlowLabel(t);
        this._bindLoopStatement(s, a, () => {
          this.walk(e.d.whileSuite);
        });
        this._addAntecedent(s, this._currentFlowNode);
        this._currentFlowNode = r === true ? I._unreachableFlowNode : this._finishFlowLabel(n);
        if (e.d.elseSuite) {
          this.walk(e.d.elseSuite);
        }
        this._addAntecedent(a, this._currentFlowNode);
        this._currentFlowNode = this._finishFlowLabel(a);
        return false;
      }
      visitAssert(e) {
        const t = this._createBranchLabel();
        const n = this._createBranchLabel();
        this._bindConditional(e.d.testExpr, t, n);
        if (e.d.exceptionExpr) {
          this._currentFlowNode = this._finishFlowLabel(n);
          this.walk(e.d.exceptionExpr);
        }
        this._currentFlowNode = this._finishFlowLabel(t);
        return false;
      }
      visitExcept(e) {
        if (e.d.typeExpr) {
          this.walk(e.d.typeExpr);
        }
        if (e.d.name) {
          this.walk(e.d.name);
          const t = this._bindNameToScope(this._currentScope, e.d.name);
          this._createAssignmentTargetFlowNodes(e.d.name, true, false);
          if (t) {
            const n = {
              type: 1,
              node: e.d.name,
              isConstant: C.isConstantName(e.d.name.d.value),
              inferredTypeSource: e,
              uri: this._fileInfo.fileUri,
              range: d.convertTextRangeToRange(e.d.name, this._fileInfo.lines),
              moduleName: this._fileInfo.moduleName,
              isInExceptSuite: this._isInExceptSuite,
              isExplicitBinding: this._currentScope.getBindingType(e.d.name.d.value) !== undefined
            };
            t.addDeclaration(n);
          }
        }
        const t = this._isInExceptSuite;
        this._isInExceptSuite = true;
        this.walk(e.d.exceptSuite);
        this._isInExceptSuite = t;
        if (e.d.name) {
          this._createFlowAssignment(e.d.name, true);
        }
        return false;
      }
      visitRaise(e) {
        if (this._currentFlowNode) {
          this._addExceptTargets(this._currentFlowNode);
        }
        if (this._targetFunctionDeclaration) {
          if (!this._targetFunctionDeclaration.raiseStatements) {
            this._targetFunctionDeclaration.raiseStatements = [];
          }
          this._targetFunctionDeclaration.raiseStatements.push(e);
        }
        if (e.d.expr) {
          this.walk(e.d.expr);
        }
        if (e.d.fromExpr) {
          this.walk(e.d.fromExpr);
        }
        this._finallyTargets.forEach(e => {
          this._addAntecedent(e, this._currentFlowNode);
        });
        this._currentFlowNode = I._unreachableFlowNode;
        return false;
      }
      visitTry(e) {
        const t = this._currentFlowNode;
        const n = e.d.exceptClauses.map(() => this._createBranchLabel());
        const a = this._createBranchLabel(t);
        let r = false;
        const s = this._createBranchLabel(t);
        const i = {
          flags: g.FlowFlags.PreFinallyGate,
          id: this._getUniqueFlowNodeId(),
          antecedent: s
        };
        a.affectedExpressions = this._trackCodeFlowExpressions(() => {
          if (e.d.finallySuite) {
            this._addAntecedent(a, i);
          }
          if (!e.d.exceptClauses.some(e => !e.d.typeExpr)) {
            n.push(s);
          }
          n.forEach(e => {
            this._addAntecedent(e, this._currentFlowNode);
          });
          if (e.d.finallySuite) {
            this._finallyTargets.push(s);
          }
          this._useExceptTargets(n, () => {
            this.walk(e.d.trySuite);
          });
          if (e.d.elseSuite) {
            this.walk(e.d.elseSuite);
          }
          this._addAntecedent(a, this._currentFlowNode);
          if (!this._isCodeUnreachable()) {
            r = true;
          }
          e.d.exceptClauses.forEach((e, t) => {
            this._currentFlowNode = this._finishFlowLabel(n[t]);
            this.walk(e);
            this._addAntecedent(a, this._currentFlowNode);
            if (!this._isCodeUnreachable()) {
              r = true;
            }
          });
          if (e.d.finallySuite) {
            this._finallyTargets.pop();
          }
          this._currentFlowNode = this._finishFlowLabel(a);
        });
        if (e.d.finallySuite) {
          this.walk(e.d.finallySuite);
          const t = {
            flags: g.FlowFlags.PostFinally,
            id: this._getUniqueFlowNodeId(),
            finallyNode: e.d.finallySuite,
            antecedent: this._currentFlowNode,
            preFinallyGate: i
          };
          this._currentFlowNode = r ? t : I._unreachableFlowNode;
        }
        return false;
      }
      visitAwait(e) {
        var t;
        var n;
        var a;
        var r;
        var s;
        var i;
        var o;
        const l = f.getExecutionScopeNode(e);
        if ((l == null ? undefined : l.nodeType) !== 31 || !l.d.isAsync) {
          if (this._fileInfo.ipythonMode && (l == null ? undefined : l.nodeType) === 36) {
            return true;
          }
          if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 11 || ((a = (n = e.parent) === null || n === undefined ? undefined : n.parent) === null || a === undefined ? undefined : a.nodeType) === 34 || ((s = (r = e.parent) === null || r === undefined ? undefined : r.parent) === null || s === undefined ? undefined : s.nodeType) === 45 || ((o = (i = e.parent) === null || i === undefined ? undefined : i.parent) === null || o === undefined ? undefined : o.nodeType) === 18) {
            this._addSyntaxError(m.LocMessage.awaitNotInAsync(), e.d.awaitToken);
          }
        }
        return true;
      }
      visitGlobal(e) {
        const t = this._currentScope.getGlobalScope().scope;
        e.d.targets.forEach(e => {
          const n = e.d.value;
          if (this._currentScope.getBindingType(n) === 0) {
            this._addSyntaxError(m.LocMessage.nonLocalRedefinition().format({
              name: n
            }), e);
          }
          const a = this._currentScope.lookUpSymbolRecursive(n);
          if (a && a.scope === this._currentScope) {
            this._addSyntaxError(m.LocMessage.globalReassignment().format({
              name: n
            }), e);
          }
          this._bindNameToScope(t, e);
          if (this._currentScope !== t) {
            this._currentScope.setBindingType(n, 1);
          }
        });
        return true;
      }
      visitNonlocal(e) {
        const t = this._currentScope.getGlobalScope().scope;
        if (this._currentScope === t) {
          this._addSyntaxError(m.LocMessage.nonLocalInModule(), e);
        } else {
          e.d.targets.forEach(e => {
            const n = e.d.value;
            if (this._currentScope.getBindingType(n) === 1) {
              this._addSyntaxError(m.LocMessage.globalRedefinition().format({
                name: n
              }), e);
            }
            const a = this._currentScope.lookUpSymbolRecursive(n);
            if (a && a.scope === this._currentScope) {
              this._addSyntaxError(m.LocMessage.nonLocalReassignment().format({
                name: n
              }), e);
            } else {
              if (!a || a.scope === t) {
                this._addSyntaxError(m.LocMessage.nonLocalNoBinding().format({
                  name: n
                }), e);
              }
            }
            if (a) {
              this._currentScope.setBindingType(n, 0);
            }
          });
        }
        return true;
      }
      visitImportAs(e) {
        var t;
        var n;
        var a;
        var r;
        var s;
        var i;
        if (e.d.module.d.nameParts.length > 0) {
          const l = e.d.module.d.nameParts[0].d.value;
          let p;
          let d;
          if (e.d.alias) {
            p = e.d.alias.d.value;
            d = e.d.alias;
          } else {
            p = l;
            d = e.d.module.d.nameParts[0];
          }
          const c = this._bindNameToScope(this._currentScope, d);
          if (!!c && (this._currentScope.type === 4 || this._currentScope.type === 5) && (!e.d.alias || e.d.module.d.nameParts.length !== 1 || e.d.module.d.nameParts[0].d.value !== e.d.alias.d.value)) {
            if (this._fileInfo.isStubFile || this._fileInfo.isInPyTypedPackage) {
              this._potentialHiddenSymbols.set(p, c);
            }
          }
          const u = y.getImportInfo(e.d.module);
          o.assert(u !== undefined);
          if (c) {
            this._createAliasDeclarationForMultipartImportName(e, e.d.alias, u, c);
          }
          this._createFlowAssignment(e.d.alias ? e.d.alias : e.d.module.d.nameParts[0]);
          if (e.d.module.d.nameParts.length === 1) {
            if (l === 'typing' || l === 'typing_extensions') {
              this._typingImportAliases.push((n = (t = e.d.alias) === null || t === undefined ? undefined : t.d.value) !== null && n !== undefined ? n : l);
            } else {
              if (l === 'sys') {
                this._sysImportAliases.push((r = (a = e.d.alias) === null || a === undefined ? undefined : a.d.value) !== null && r !== undefined ? r : l);
              } else {
                if (l === 'dataclasses') {
                  this._dataclassesImportAliases.push((i = (s = e.d.alias) === null || s === undefined ? undefined : s.d.value) !== null && i !== undefined ? i : l);
                }
              }
            }
          }
        }
        return true;
      }
      visitImportFrom(e) {
        var t;
        const n = ['Final', 'ClassVar', 'Annotated'];
        const a = ['InitVar'];
        const r = y.getImportInfo(e.d.module);
        y.setFlowNode(e, this._currentFlowNode);
        let s = u.Uri.empty();
        if (r && r.isImportFound && !r.isNativeLib) {
          s = r.resolvedUris[r.resolvedUris.length - 1];
        }
        const i = p.stripFileExtension(this._fileInfo.fileUri.fileName);
        const o = i === '__init__' && e.d.module.d.leadingDots === 1 && e.d.module.d.nameParts.length === 1;
        let l = false;
        let h = false;
        if (e.d.module.d.nameParts.length === 1) {
          const t = e.d.module.d.nameParts[0].d.value;
          if (t === 'typing' || t === 'typing_extensions') {
            l = true;
          }
          if (t === 'dataclasses') {
            h = true;
          }
        }
        if (e.d.isWildcardImport) {
          if (f.getEnclosingClass(e) || f.getEnclosingFunction(e)) {
            this._addSyntaxError(m.LocMessage.wildcardInFunction(), e);
          }
          if (r) {
            const i = [];
            if ((t = this._currentScopeCodeFlowExpressions) !== null && t !== undefined) {
              t.add(g.wildcardImportReferenceKey);
            }
            const p = this._fileInfo.importLookup(s);
            if (p) {
              const t = this._getWildcardImportNames(p);
              if (o) {
                if (!t.some(t => t === e.d.module.d.nameParts[0].d.value)) {
                  this._addImplicitFromImport(e, r);
                }
              }
              t.forEach(t => {
                const n = this._bindNameValueToScope(this._currentScope, t);
                if (n) {
                  if (p.symbolTable.get(t)) {
                    const a = {
                      type: 8,
                      node: e,
                      uri: s,
                      loadSymbolsFromPath: true,
                      range: c.getEmptyRange(),
                      usesLocalName: false,
                      symbolName: t,
                      moduleName: this._fileInfo.moduleName,
                      isInExceptSuite: this._isInExceptSuite
                    };
                    n.addDeclaration(a);
                    i.push(t);
                  } else {
                    if (r && r.filteredImplicitImports) {
                      const a = r.filteredImplicitImports.get(t);
                      if (a) {
                        const r = {
                          type: 8,
                          node: e,
                          uri: a.uri,
                          loadSymbolsFromPath: true,
                          range: c.getEmptyRange(),
                          usesLocalName: false,
                          moduleName: this._fileInfo.moduleName,
                          isInExceptSuite: this._isInExceptSuite
                        };
                        const o = {
                          type: 8,
                          node: e,
                          uri: s,
                          loadSymbolsFromPath: true,
                          usesLocalName: false,
                          symbolName: t,
                          submoduleFallback: r,
                          range: c.getEmptyRange(),
                          moduleName: this._fileInfo.moduleName,
                          isInExceptSuite: this._isInExceptSuite
                        };
                        n.addDeclaration(o);
                        i.push(t);
                      }
                    }
                  }
                  if (l) {
                    n.setTypingSymbolAlias(t);
                  }
                }
              });
            }
            this._createFlowWildcardImport(e, i);
            if (l) {
              n.forEach(e => {
                this._typingSymbolAliases.set(e, e);
              });
            }
            if (h) {
              a.forEach(e => {
                this._dataclassesSymbolAliases.set(e, e);
              });
            }
          }
        } else {
          if (o) {
            this._addImplicitFromImport(e, r);
          }
          e.d.imports.forEach(t => {
            const o = t.d.name.d.value;
            const p = t.d.alias || t.d.name;
            y.setFlowNode(t, this._currentFlowNode);
            const u = this._bindNameToScope(this._currentScope, p);
            if (u) {
              let m;
              let y;
              if (e.d.module.d.nameParts.length > 0) {
                if ((this._currentScope.type === 4 || this._currentScope.type === 5) && (!t.d.alias || t.d.alias.d.value !== t.d.name.d.value)) {
                  if (this._fileInfo.isStubFile || this._fileInfo.isInPyTypedPackage) {
                    this._potentialHiddenSymbols.set(p.d.value, u);
                  }
                }
              }
              if (r && r.filteredImplicitImports) {
                m = r.filteredImplicitImports.get(o);
              }
              let g = true;
              if (m) {
                y = {
                  type: 8,
                  node: t,
                  uri: m.uri,
                  loadSymbolsFromPath: true,
                  range: c.getEmptyRange(),
                  usesLocalName: false,
                  moduleName: this._formatModuleName(e.d.module),
                  isInExceptSuite: this._isInExceptSuite
                };
                if (i === '__init__' && (e.d.module.d.leadingDots === 1 && e.d.module.d.nameParts.length === 0 || s.equals(this._fileInfo.fileUri))) {
                  g = false;
                }
              }
              const f = {
                type: 8,
                node: t,
                uri: s,
                loadSymbolsFromPath: g,
                usesLocalName: !!t.d.alias,
                symbolName: o,
                submoduleFallback: y,
                range: d.convertTextRangeToRange(p, this._fileInfo.lines),
                moduleName: this._formatModuleName(e.d.module),
                isInExceptSuite: this._isInExceptSuite,
                isNativeLib: r == null ? undefined : r.isNativeLib
              };
              u.addDeclaration(f);
              this._createFlowAssignment(t.d.alias || t.d.name);
              if (l && n.some(e => e === t.d.name.d.value)) {
                this._typingSymbolAliases.set(p.d.value, t.d.name.d.value);
                if (l) {
                  u.setTypingSymbolAlias(p.d.value);
                }
              }
              if (h && a.some(e => e === t.d.name.d.value)) {
                this._dataclassesSymbolAliases.set(p.d.value, t.d.name.d.value);
              }
            }
          });
        }
        return true;
      }
      visitWith(e) {
        e.d.withItems.forEach(e => {
          this.walk(e.d.expr);
          if (e.d.target) {
            this._bindPossibleTupleNamedTarget(e.d.target);
            this._addInferredTypeAssignmentForVariable(e.d.target, e);
            this._createAssignmentTargetFlowNodes(e.d.target, true, false);
          }
        });
        const t = this._createContextManagerLabel(e.d.withItems.map(e => e.d.expr), !!e.d.isAsync, false);
        this._addAntecedent(t, this._currentFlowNode);
        const n = this._createContextManagerLabel(e.d.withItems.map(e => e.d.expr), !!e.d.isAsync, true);
        this._currentExceptTargets.forEach(e => {
          this._addAntecedent(e, n);
        });
        const a = this._currentFlowNode;
        const r = this._createBranchLabel(a);
        this._addAntecedent(r, t);
        r.affectedExpressions = this._trackCodeFlowExpressions(() => {
          this._useExceptTargets([t, n], () => {
            this.walk(e.d.suite);
          });
          this._addAntecedent(r, this._currentFlowNode);
          this._currentFlowNode = r;
          if (!this._isCodeUnreachable()) {
            this._addExceptTargets(this._currentFlowNode);
          }
          if (e.d.asyncToken && !this._fileInfo.ipythonMode) {
            const t = f.getEnclosingFunction(e);
            if (!t || !t.d.isAsync) {
              this._addSyntaxError(m.LocMessage.asyncNotInAsyncFunction(), e.d.asyncToken);
            }
          }
        });
        return false;
      }
      visitTernary(e) {
        const t = this._currentFlowNode;
        const n = this._createBranchLabel();
        const a = this._createBranchLabel();
        const r = this._createBranchLabel(t);
        r.affectedExpressions = this._trackCodeFlowExpressions(() => {
          this._bindConditional(e.d.testExpr, n, a);
          this._currentFlowNode = this._finishFlowLabel(n);
          this.walk(e.d.ifExpr);
          this._addAntecedent(r, this._currentFlowNode);
          this._currentFlowNode = this._finishFlowLabel(a);
          this.walk(e.d.elseExpr);
          this._addAntecedent(r, this._currentFlowNode);
          this._currentFlowNode = this._finishFlowLabel(r);
        });
        return false;
      }
      visitUnaryOperation(e) {
        if (e.d.operator === 38 && this._currentFalseTarget && this._currentTrueTarget) {
          this._bindConditional(e.d.expr, this._currentFalseTarget, this._currentTrueTarget);
        } else {
          this._disableTrueFalseTargets(() => {
            this.walk(e.d.expr);
          });
        }
        return false;
      }
      visitBinaryOperation(e) {
        if (e.d.operator === 36 || e.d.operator === 37) {
          let t;
          let n = this._currentTrueTarget;
          let a = this._currentFalseTarget;
          if (!n || !a) {
            t = this._createBranchLabel();
            n = a = t;
          }
          const r = this._createBranchLabel();
          if (e.d.operator === 36) {
            this._bindConditional(e.d.leftExpr, r, a);
          } else {
            this._bindConditional(e.d.leftExpr, n, r);
          }
          this._currentFlowNode = this._finishFlowLabel(r);
          this._bindConditional(e.d.rightExpr, n, a);
          if (t) {
            this._currentFlowNode = this._finishFlowLabel(t);
          }
        } else {
          this._disableTrueFalseTargets(() => {
            this.walk(e.d.leftExpr);
            this.walk(e.d.rightExpr);
          });
        }
        return false;
      }
      visitComprehension(e) {
        const t = f.getEnclosingFunction(e);
        if (e.d.forIfNodes.length > 0 && e.d.forIfNodes[0].nodeType === 12) {
          this.walk(e.d.forIfNodes[0].d.iterableExpr);
        }
        this._createNewScope(1, this._getNonClassParentScope(), undefined, () => {
          var n;
          var a;
          var r;
          y.setScope(e, this._currentScope);
          const s = this._createBranchLabel();
          for (let s = 0; s < e.d.forIfNodes.length; s++) {
            const i = e.d.forIfNodes[s];
            const o = new Map();
            if (i.nodeType === 12) {
              this._bindPossibleTupleNamedTarget(i.d.targetExpr, o);
              this._addInferredTypeAssignmentForVariable(i.d.targetExpr, i);
              if (i.d.asyncToken && !this._fileInfo.ipythonMode) {
                if ((!t || !t.d.isAsync) && (((n = e.parent) === null || n === undefined ? undefined : n.nodeType) === 34 || ((a = e.parent) === null || a === undefined ? undefined : a.nodeType) === 45 || ((r = e.parent) === null || r === undefined ? undefined : r.nodeType) === 18)) {
                  this._addSyntaxError(m.LocMessage.asyncNotInAsyncFunction(), i.d.asyncToken);
                }
              }
            }
          }
          for (let t = 0; t < e.d.forIfNodes.length; t++) {
            const n = e.d.forIfNodes[t];
            if (n.nodeType === 12) {
              if (t !== 0) {
                this.walk(n.d.iterableExpr);
              }
              this._createAssignmentTargetFlowNodes(n.d.targetExpr, true, false);
            } else {
              const e = this._createBranchLabel();
              this._bindConditional(n.d.testExpr, e, s);
              this._currentFlowNode = this._finishFlowLabel(e);
            }
          }
          this.walk(e.d.expr);
          this._addAntecedent(s, this._currentFlowNode);
          this._currentFlowNode = this._finishFlowLabel(s);
        });
        return false;
      }
      visitMatch(e) {
        this.walk(e.d.expr);
        const t = [];
        let n = this._isNarrowingExpression(e.d.expr, t);
        if (e.d.expr.nodeType === 52) {
          e.d.expr.d.items.forEach(e => {
            if (this._isNarrowingExpression(e, t)) {
              n = true;
            }
          });
        }
        if (n) {
          t.forEach(e => {
            const t = g.createKeyForReference(e);
            this._currentScopeCodeFlowExpressions.add(t);
          });
        }
        const a = this._createBranchLabel();
        let r = false;
        e.d.cases.forEach(t => {
          const n = this._createBranchLabel();
          const s = this._createBranchLabel();
          const i = this._createBranchLabel();
          this._addAntecedent(s, this._currentFlowNode);
          if (t.d.isIrrefutable) {
            if (!t.d.guardExpr) {
              r = true;
            }
          } else {
            this._addAntecedent(n, this._currentFlowNode);
          }
          this._currentFlowNode = this._finishFlowLabel(s);
          this._currentMatchSubjExpr = e.d.expr;
          this.walk(t.d.pattern);
          if (this._currentMatchSubjExpr) {
            this._createFlowNarrowForPattern(e.d.expr, t);
            this._currentMatchSubjExpr = undefined;
          }
          if (t.d.guardExpr) {
            this._bindConditional(t.d.guardExpr, i, n);
          } else {
            this._addAntecedent(i, this._currentFlowNode);
          }
          this._currentFlowNode = this._finishFlowLabel(i);
          this.walk(t.d.suite);
          this._addAntecedent(a, this._currentFlowNode);
          this._currentFlowNode = this._finishFlowLabel(n);
        });
        if (n) {
          this._createFlowNarrowForPattern(e.d.expr, e);
        }
        if (!r) {
          this._createFlowExhaustedMatch(e);
        }
        this._addAntecedent(a, this._currentFlowNode);
        this._currentFlowNode = this._finishFlowLabel(a);
        return false;
      }
      visitPatternAs(e) {
        const t = this._createBranchLabel();
        e.d.orPatterns.forEach(e => {
          this.walk(e);
          this._addAntecedent(t, this._currentFlowNode);
        });
        this._currentFlowNode = this._finishFlowLabel(t);
        if (e.d.target) {
          this.walk(e.d.target);
          const t = this._bindNameToScope(this._currentScope, e.d.target);
          this._createAssignmentTargetFlowNodes(e.d.target, false, false);
          if (t) {
            const n = {
              type: 1,
              node: e.d.target,
              isConstant: C.isConstantName(e.d.target.d.value),
              inferredTypeSource: e,
              uri: this._fileInfo.fileUri,
              range: d.convertTextRangeToRange(e.d.target, this._fileInfo.lines),
              moduleName: this._fileInfo.moduleName,
              isInExceptSuite: this._isInExceptSuite,
              isExplicitBinding: this._currentScope.getBindingType(e.d.target.d.value) !== undefined
            };
            t.addDeclaration(n);
          }
        }
        return false;
      }
      visitPatternCapture(e) {
        if (!e.d.isWildcard) {
          this._addPatternCaptureTarget(e.d.target);
        }
        return true;
      }
      visitPatternMappingExpandEntry(e) {
        if (e.d.target.d.value !== '_') {
          this._addPatternCaptureTarget(e.d.target);
        }
        return true;
      }
      _addTypingImportAliasesFromBuiltinsScope() {
        if (!this._fileInfo.builtinsScope) {
          return;
        }
        this._fileInfo.builtinsScope.symbolTable.forEach((e, t) => {
          const n = e.getTypingSymbolAlias();
          if (n && !e.isExternallyHidden()) {
            this._typingSymbolAliases.set(t, n);
          }
        });
      }
      _formatModuleName(e) {
        return '.'.repeat(e.d.leadingDots) + e.d.nameParts.map(e => e.d.value).join('.');
      }
      _getNonClassParentScope() {
        let e = this._currentScope;
        while (e.type === 3) {
          e = e.parent;
        }
        return e;
      }
      _addSlotsToCurrentScope(e) {
        o.assert(this._currentScope.type === 3);
        let t = false;
        for (const n of e) {
          const e = n.d.strings[0].d.value;
          if (e === '__dict__') {
            t = true;
            continue;
          }
          let a = this._currentScope.lookUpSymbol(e);
          if (!a) {
            a = this._currentScope.addSymbol(e, 5);
            const t = this._fileInfo.diagnosticRuleSet.reportPrivateUsage !== 'none';
            if (C.isPrivateOrProtectedName(e) && t) {
              a.setIsPrivateMember();
            }
          }
          const r = {
            type: 1,
            node: n,
            isConstant: C.isConstantName(e),
            isDefinedBySlots: true,
            uri: this._fileInfo.fileUri,
            range: d.convertTextRangeToRange(n, this._fileInfo.lines),
            moduleName: this._fileInfo.moduleName,
            isInExceptSuite: this._isInExceptSuite,
            isExplicitBinding: this._currentScope.getBindingType(e) !== undefined
          };
          a.addDeclaration(r);
        }
        if (!t) {
          this._currentScope.setSlotsNames(e.map(e => e.d.strings[0].d.value));
        }
      }
      _isInComprehension(e, t = false) {
        let n;
        let a;
        let r = e;
        while (r) {
          if (r.nodeType === 11) {
            if (t && r.d.forIfNodes.length > 0) {
              const e = r.d.forIfNodes[0];
              if (n === e && e.nodeType === 12 && a === e.d.iterableExpr) {
                return false;
              }
            }
            return true;
          }
          a = n;
          n = r;
          r = r.parent;
        }
        return false;
      }
      _addPatternCaptureTarget(e) {
        const t = this._bindNameToScope(this._currentScope, e);
        this._createAssignmentTargetFlowNodes(e, false, false);
        if (this._currentMatchSubjExpr && (f.isMatchingExpression(e, this._currentMatchSubjExpr) || f.isPartialMatchingExpression(e, this._currentMatchSubjExpr))) {
          this._currentMatchSubjExpr = undefined;
        }
        if (t) {
          const n = {
            type: 1,
            node: e,
            isConstant: C.isConstantName(e.d.value),
            inferredTypeSource: e.parent,
            uri: this._fileInfo.fileUri,
            range: d.convertTextRangeToRange(e, this._fileInfo.lines),
            moduleName: this._fileInfo.moduleName,
            isInExceptSuite: this._isInExceptSuite,
            isExplicitBinding: this._currentScope.getBindingType(e.d.value) !== undefined
          };
          t.addDeclaration(n);
        }
      }
      _useExceptTargets(e, t) {
        const n = this._currentExceptTargets;
        this._currentExceptTargets = e;
        t();
        this._currentExceptTargets = n;
      }
      _getDunderAllNamesFromImport(e) {
        var t;
        var n;
        const a = this._currentScope.lookUpSymbol(e);
        if (!a) {
          return;
        }
        const r = a.getDeclarations().find(e => e.type === 8);
        const s = (r == null ? undefined : r.uri) && !r.uri.isEmpty() && r.loadSymbolsFromPath ? r.uri : ((t = r == null ? undefined : r.submoduleFallback) === null || t === undefined ? undefined : t.uri) && !r.submoduleFallback.uri.isEmpty() && r.submoduleFallback.loadSymbolsFromPath ? r.submoduleFallback.uri : undefined;
        if (!s) {
          return;
        }
        let i = this._fileInfo.importLookup(s);
        if (i == null ? undefined : i.dunderAllNames) {
          return i.dunderAllNames;
        } else {
          if (((n = r == null ? undefined : r.submoduleFallback) === null || n === undefined ? undefined : n.uri) && !r.submoduleFallback.uri.isEmpty()) {
            i = this._fileInfo.importLookup(r.submoduleFallback.uri);
            return i == null ? undefined : i.dunderAllNames;
          } else {
            return undefined;
          }
        }
      }
      _addImplicitFromImport(e, t) {
        const n = e.d.module.d.nameParts[0].d.value;
        const a = this._bindNameValueToScope(this._currentScope, n);
        if (a) {
          this._createAliasDeclarationForMultipartImportName(e, undefined, t, a);
        }
        this._createFlowAssignment(e.d.module.d.nameParts[0]);
      }
      _createAliasDeclarationForMultipartImportName(e, t, n, a) {
        var r;
        const s = e.d.module.d.nameParts[0].d.value;
        y.setFlowNode(e, this._currentFlowNode);
        const i = a.getDeclarations().find(e => e.type === 8 && e.firstNamePart === s);
        let o;
        let l;
        l = n && n.isImportFound && !n.isNativeLib && n.resolvedUris.length > 0 ? n.resolvedUris[n.resolvedUris.length - 1] : h.UnresolvedModuleMarker;
        const p = n && n.isImportFound && !n.isNativeLib && n.resolvedUris.length > 0;
        o = i || (p ? {
          type: 8,
          node: e,
          uri: l,
          loadSymbolsFromPath: false,
          range: c.getEmptyRange(),
          usesLocalName: !!t,
          moduleName: t ? this._formatModuleName(e.d.module) : '.'.repeat(e.d.module.d.leadingDots) + s,
          firstNamePart: s,
          isInExceptSuite: this._isInExceptSuite
        } : {
          type: 8,
          node: e,
          uri: l,
          loadSymbolsFromPath: true,
          range: c.getEmptyRange(),
          usesLocalName: !!t,
          moduleName: (r = n == null ? undefined : n.importName) !== null && r !== undefined ? r : '',
          firstNamePart: t ? this._formatModuleName(e.d.module) : '.'.repeat(e.d.module.d.leadingDots) + s,
          isUnresolved: true,
          isInExceptSuite: this._isInExceptSuite
        });
        const d = y.getImportInfo(e.d.module.d.nameParts[0]);
        if (d && d.resolvedUris.length) {
          o.uri = d.resolvedUris[0];
          o.loadSymbolsFromPath = true;
          this._addImplicitImportsToLoaderActions(d, o);
        }
        if (t || e.d.module.d.nameParts.length === 1) {
          o.uri = l;
          o.loadSymbolsFromPath = true;
          o.isUnresolved = false;
          if (n) {
            this._addImplicitImportsToLoaderActions(n, o);
          }
        } else {
          let t = o;
          for (let a = 1; a < e.d.module.d.nameParts.length; a++) {
            const r = e.d.module.d.nameParts[a].d.value;
            let s = t.implicitImports ? t.implicitImports.get(r) : undefined;
            if (!s) {
              s = {
                uri: n && a < n.resolvedUris.length ? n.resolvedUris[a] : h.UnresolvedModuleMarker,
                loadSymbolsFromPath: false,
                implicitImports: new Map(),
                isUnresolved: !p
              };
              if (!t.implicitImports) {
                t.implicitImports = new Map();
              }
              t.implicitImports.set(r, s);
            }
            if (a === e.d.module.d.nameParts.length - 1) {
              if (n && a < n.resolvedUris.length) {
                s.uri = n.resolvedUris[a];
                s.loadSymbolsFromPath = true;
                this._addImplicitImportsToLoaderActions(n, s);
              }
            } else {
              const t = y.getImportInfo(e.d.module.d.nameParts[a]);
              if (t && t.resolvedUris.length) {
                s.uri = t.resolvedUris[a];
                s.loadSymbolsFromPath = true;
                this._addImplicitImportsToLoaderActions(t, s);
              }
            }
            t = s;
          }
        }
        if (!i) {
          a.addDeclaration(o);
        }
      }
      _getWildcardImportNames(e) {
        const t = [];
        if (e.dunderAllNames) {
          if (!e.usesUnsupportedDunderAllForm) {
            return e.dunderAllNames;
          }
          i.appendArray(t, e.dunderAllNames);
        }
        e.symbolTable.forEach((e, n) => {
          if (!e.isExternallyHidden() && !n.startsWith('_')) {
            t.push(n);
          }
        });
        return t;
      }
      _walkStatementsAndReportUnreachable(e) {
        let t = false;
        for (const n of e) {
          y.setFlowNode(n, this._currentFlowNode);
          if (!t) {
            t = this._isCodeUnreachable();
          }
          if (t) {
            if (this._targetFunctionDeclaration && !this._targetFunctionDeclaration.isGenerator) {
              if (new k().checkContainsYield(n)) {
                this._targetFunctionDeclaration.isGenerator = true;
              }
            }
            if (!this._moduleSymbolOnly) {
              new S(this._currentScope).walk(n);
            }
          } else {
            this.walk(n);
          }
        }
        return false;
      }
      _createStartFlowNode() {
        return {
          flags: g.FlowFlags.Start,
          id: this._getUniqueFlowNodeId()
        };
      }
      _createBranchLabel(e) {
        return {
          flags: g.FlowFlags.BranchLabel,
          id: this._getUniqueFlowNodeId(),
          antecedents: [],
          preBranchAntecedent: e,
          affectedExpressions: undefined
        };
      }
      _createFlowNarrowForPattern(e, t) {
        const n = {
          flags: g.FlowFlags.NarrowForPattern,
          id: this._getUniqueFlowNodeId(),
          subjectExpression: e,
          statement: t,
          antecedent: this._currentFlowNode
        };
        this._currentFlowNode = n;
      }
      _createContextManagerLabel(e, t, n) {
        return {
          flags: g.FlowFlags.PostContextManager | g.FlowFlags.BranchLabel,
          id: this._getUniqueFlowNodeId(),
          antecedents: [],
          expressions: e,
          affectedExpressions: undefined,
          isAsync: t,
          blockIfSwallowsExceptions: n
        };
      }
      _createLoopLabel() {
        return {
          flags: g.FlowFlags.LoopLabel,
          id: this._getUniqueFlowNodeId(),
          antecedents: [],
          affectedExpressions: undefined
        };
      }
      _finishFlowLabel(e) {
        if (e.antecedents.length === 0) {
          return I._unreachableFlowNode;
        } else {
          if (e.antecedents.length === 1 && e.flags === g.FlowFlags.BranchLabel) {
            return e.antecedents[0];
          } else {
            this._codeFlowComplexity += e.antecedents.length - 1;
            return e;
          }
        }
      }
      _bindNeverCondition(e, t, n) {
        const a = [];
        if (e.nodeType === 55 && e.d.operator === 38) {
          this._bindNeverCondition(e.d.expr, t, !n);
        } else {
          if (e.nodeType !== 7 || e.d.operator !== 36 && e.d.operator !== 37) {
            if (this._isNarrowingExpression(e, a, {
              filterForNeverNarrowing: true
            })) {
              if (a.filter(e => e.nodeType === 38).length > 0) {
                this._currentFlowNode = this._createFlowConditional(n ? g.FlowFlags.TrueNeverCondition : g.FlowFlags.FalseNeverCondition, this._currentFlowNode, e);
              }
            }
            this._addAntecedent(t, this._currentFlowNode);
          } else {
            let a = e.d.operator === 36;
            if (n) {
              a = !a;
            }
            if (a) {
              const a = this._currentFlowNode;
              this._bindNeverCondition(e.d.leftExpr, t, n);
              this._currentFlowNode = a;
              this._bindNeverCondition(e.d.rightExpr, t, n);
            } else {
              const a = this._currentFlowNode;
              const r = this._createBranchLabel();
              this._bindNeverCondition(e.d.leftExpr, r, n);
              if (a !== this._currentFlowNode) {
                this._currentFlowNode = this._finishFlowLabel(r);
                const s = this._currentFlowNode;
                this._bindNeverCondition(e.d.rightExpr, t, n);
                if (s === this._currentFlowNode) {
                  this._currentFlowNode = a;
                }
              }
            }
          }
        }
      }
      _bindConditional(e, t, n) {
        this._setTrueFalseTargets(t, n, () => {
          this.walk(e);
        });
        if (!this._isLogicalExpression(e)) {
          this._addAntecedent(t, this._createFlowConditional(g.FlowFlags.TrueCondition, this._currentFlowNode, e));
          this._addAntecedent(n, this._createFlowConditional(g.FlowFlags.FalseCondition, this._currentFlowNode, e));
        }
      }
      _disableTrueFalseTargets(e) {
        this._setTrueFalseTargets(undefined, undefined, e);
      }
      _setTrueFalseTargets(e, t, n) {
        const a = this._currentTrueTarget;
        const r = this._currentFalseTarget;
        this._currentTrueTarget = e;
        this._currentFalseTarget = t;
        n();
        this._currentTrueTarget = a;
        this._currentFalseTarget = r;
      }
      _createFlowConditional(e, t, n) {
        if (t.flags & g.FlowFlags.Unreachable) {
          return t;
        }
        const a = b.evaluateStaticBoolLikeExpression(n, this._fileInfo.executionEnvironment, this._fileInfo.definedConstants, this._typingImportAliases, this._sysImportAliases);
        if (a === true && e & g.FlowFlags.FalseCondition || a === false && e & g.FlowFlags.TrueCondition) {
          return I._unreachableFlowNode;
        }
        const r = [];
        if (!this._isNarrowingExpression(n, r, {
          filterForNeverNarrowing: !!(e & (g.FlowFlags.TrueNeverCondition | g.FlowFlags.FalseNeverCondition))
        })) {
          return t;
        }
        r.forEach(e => {
          const t = g.createKeyForReference(e);
          this._currentScopeCodeFlowExpressions.add(t);
        });
        const s = r.filter(e => e.nodeType === 38);
        const i = {
          flags: e,
          id: this._getUniqueFlowNodeId(),
          reference: s.length > 0 ? s[0] : undefined,
          expression: n,
          antecedent: t
        };
        this._addExceptTargets(i);
        return i;
      }
      _isLogicalExpression(e) {
        switch (e.nodeType) {
          case 55:
            return e.d.operator === 38;
          case 7:
            return e.d.operator === 36 || e.d.operator === 37;
        }
        return false;
      }
      _isNarrowingExpression(e, t, n = {}) {
        switch (e.nodeType) {
          case 38:
          case 35:
          case 27:
            if (n.filterForNeverNarrowing) {
              if (e.nodeType !== 38) {
                return false;
              }
              if (!n.isComplexExpression) {
                return false;
              }
            }
            return !!g.isCodeFlowSupportedForReference(e) && (t.push(e), n.filterForNeverNarrowing || (e.nodeType === 35 && n.allowDiscriminatedNarrowing && g.isCodeFlowSupportedForReference(e.d.leftExpr) && t.push(e.d.leftExpr), e.nodeType !== 27 || e.d.items.length !== 1 || e.d.trailingComma || e.d.items[0].d.argCategory !== 0 || g.isCodeFlowSupportedForReference(e.d.leftExpr) && t.push(e.d.leftExpr)), true);
          case 4:
            t.push(e.d.name);
            this._isNarrowingExpression(e.d.rightExpr, t, {
              ...n,
              isComplexExpression: true
            });
            return true;
          case 7:
            {
              const a = e.d.operator === 39 || e.d.operator === 40;
              const r = e.d.operator === 12 || e.d.operator === 28;
              if (a || r) {
                if (e.d.rightExpr.nodeType === 14 && e.d.rightExpr.d.constType === 26) {
                  return this._isNarrowingExpression(e.d.leftExpr, t, {
                    ...n,
                    isComplexExpression: true,
                    allowDiscriminatedNarrowing: true
                  });
                }
                if (a && e.d.leftExpr.nodeType === 9 && e.d.leftExpr.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.leftExpr.d.value === 'type' && e.d.leftExpr.d.args.length === 1 && e.d.leftExpr.d.args[0].d.argCategory === 0) {
                  return this._isNarrowingExpression(e.d.leftExpr.d.args[0].d.valueExpr, t, {
                    ...n,
                    isComplexExpression: true
                  });
                }
                return this._isNarrowingExpression(e.d.leftExpr, t, {
                  ...n,
                  isComplexExpression: true,
                  allowDiscriminatedNarrowing: true
                });
              }
              if (e.d.rightExpr.nodeType === 40 && e.d.rightExpr.d.isInteger && (e.d.operator === 20 || e.d.operator === 21 || e.d.operator === 15 || e.d.operator === 16)) {
                return this._isNarrowingExpression(e.d.leftExpr, t, {
                  ...n,
                  isComplexExpression: true
                });
              }
              if ((e.d.operator === 41 || e.d.operator === 42) && e.d.leftExpr.nodeType === 48 && this._isNarrowingExpression(e.d.rightExpr, t, {
                ...n,
                isComplexExpression: true
              })) {
                return true;
              }
              if (e.d.operator === 41 || e.d.operator === 42) {
                const a = this._isNarrowingExpression(e.d.leftExpr, t, {
                  ...n,
                  isComplexExpression: true
                });
                const r = this._isNarrowingExpression(e.d.rightExpr, t, {
                  ...n,
                  isComplexExpression: true
                });
                return a || r;
              }
              return false;
            }
          case 55:
            return e.d.operator === 38 && this._isNarrowingExpression(e.d.expr, t, {
              ...n,
              isComplexExpression: false
            });
          case 5:
            return this._isNarrowingExpression(e.d.rightExpr, t, {
              ...n,
              isComplexExpression: true
            });
          case 9:
            if (e.d.leftExpr.nodeType === 38 && (e.d.leftExpr.d.value === 'isinstance' || e.d.leftExpr.d.value === 'issubclass') && e.d.args.length === 2) {
              return this._isNarrowingExpression(e.d.args[0].d.valueExpr, t, {
                ...n,
                isComplexExpression: true
              });
            }
            if (e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'callable' && e.d.args.length === 1) {
              return this._isNarrowingExpression(e.d.args[0].d.valueExpr, t, {
                ...n,
                isComplexExpression: true
              });
            }
            if (e.d.args.length >= 1) {
              return !n.filterForNeverNarrowing && this._isNarrowingExpression(e.d.args[0].d.valueExpr, t, {
                ...n,
                isComplexExpression: true
              });
            }
        }
        return false;
      }
      _createAssignmentTargetFlowNodes(e, t, n) {
        switch (e.nodeType) {
          case 38:
          case 35:
          case 27:
            this._createFlowAssignment(e, n);
            if (t) {
              this.walk(e);
            }
            break;
          case 52:
            e.d.items.forEach(e => {
              this._createAssignmentTargetFlowNodes(e, t, n);
            });
            break;
          case 54:
            this._createAssignmentTargetFlowNodes(e.d.valueExpr, false, n);
            if (t) {
              this.walk(e);
            }
            break;
          case 56:
            this._createAssignmentTargetFlowNodes(e.d.expr, false, n);
            if (t) {
              this.walk(e);
            }
            break;
          case 34:
            e.d.items.forEach(e => {
              this._createAssignmentTargetFlowNodes(e, t, n);
            });
            break;
          default:
            if (t) {
              this.walk(e);
            }
        }
      }
      _createCallFlowNode(e) {
        if (!this._isCodeUnreachable()) {
          this._addExceptTargets(this._currentFlowNode);
          const t = {
            flags: g.FlowFlags.Call,
            id: this._getUniqueFlowNodeId(),
            node: e,
            antecedent: this._currentFlowNode
          };
          this._currentFlowNode = t;
        }
      }
      _createVariableAnnotationFlowNode() {
        if (!this._isCodeUnreachable()) {
          const e = {
            flags: g.FlowFlags.VariableAnnotation,
            id: this._getUniqueFlowNodeId(),
            antecedent: this._currentFlowNode
          };
          this._currentFlowNode = e;
        }
      }
      _createFlowAssignment(e, t = false) {
        let n = _.indeterminateSymbolId;
        if (e.nodeType === 38) {
          const t = this._currentScope.lookUpSymbolRecursive(e.d.value);
          o.assert(t !== undefined);
          n = t.symbol.id;
        }
        const a = this._currentFlowNode;
        if (!this._isCodeUnreachable() && g.isCodeFlowSupportedForReference(e)) {
          const a = {
            flags: g.FlowFlags.Assignment,
            id: this._getUniqueFlowNodeId(),
            node: e,
            antecedent: this._currentFlowNode,
            targetSymbolId: n
          };
          const r = g.createKeyForReference(e);
          this._currentScopeCodeFlowExpressions.add(r);
          if (t) {
            a.flags |= g.FlowFlags.Unbind;
          }
          if (e.nodeType === 35) {
            this._addExceptTargets(a);
          }
          this._currentFlowNode = a;
        }
        if (!t || y.getFlowNode(e) === undefined) {
          y.setFlowNode(e, t ? a : this._currentFlowNode);
        }
      }
      _createFlowWildcardImport(e, t) {
        if (!this._isCodeUnreachable()) {
          const n = {
            flags: g.FlowFlags.WildcardImport,
            id: this._getUniqueFlowNodeId(),
            node: e,
            names: t,
            antecedent: this._currentFlowNode
          };
          this._addExceptTargets(n);
          this._currentFlowNode = n;
        }
        y.setFlowNode(e, this._currentFlowNode);
      }
      _createFlowExhaustedMatch(e) {
        if (!this._isCodeUnreachable()) {
          const t = {
            flags: g.FlowFlags.ExhaustedMatch,
            id: this._getUniqueFlowNodeId(),
            node: e,
            antecedent: this._currentFlowNode,
            subjectExpression: e.d.expr
          };
          this._currentFlowNode = t;
        }
        y.setAfterFlowNode(e, this._currentFlowNode);
      }
      _isCodeUnreachable() {
        return !!(this._currentFlowNode.flags & g.FlowFlags.Unreachable);
      }
      _addExceptTargets(e) {
        if (this._currentExceptTargets) {
          this._currentExceptTargets.forEach(t => {
            this._addAntecedent(t, e);
          });
        }
      }
      _trackCodeFlowExpressions(e) {
        const t = this._currentScopeCodeFlowExpressions;
        this._currentScopeCodeFlowExpressions = new Set();
        e();
        const n = this._currentScopeCodeFlowExpressions;
        if (t) {
          this._currentScopeCodeFlowExpressions.forEach(e => {
            t.add(e);
          });
        }
        this._currentScopeCodeFlowExpressions = t;
        return n;
      }
      _bindLoopStatement(e, t, n) {
        const a = this._currentContinueTarget;
        const r = this._currentBreakTarget;
        this._currentContinueTarget = e;
        this._currentBreakTarget = t;
        e.affectedExpressions = this._trackCodeFlowExpressions(n);
        this._currentContinueTarget = a;
        this._currentBreakTarget = r;
      }
      _addAntecedent(e, t) {
        if (!(this._currentFlowNode.flags & g.FlowFlags.Unreachable) && !e.antecedents.some(e => e.id === t.id)) {
          e.antecedents.push(t);
        }
      }
      _bindNameToScope(e, t, n) {
        return this._bindNameValueToScope(e, t.d.value, n);
      }
      _bindNameValueToScope(e, t, n) {
        const a = this._currentScope.getBindingType(t);
        if (a === undefined) {
          let a = e.lookUpSymbol(t);
          if (!a) {
            a = e.addSymbol(t, 5);
            if (this._currentScope.type === 4 || this._currentScope.type === 5) {
              if (C.isPrivateOrProtectedName(t)) {
                if (C.isPrivateName(t)) {
                  if (e.type === 3) {
                    a.setIsExternallyHidden();
                  } else {
                    this._potentialPrivateSymbols.set(t, a);
                  }
                } else {
                  if (this._fileInfo.isStubFile || this._fileInfo.isInPyTypedPackage) {
                    if (this._currentScope.type === 5) {
                      a.setIsExternallyHidden();
                    } else {
                      this._potentialPrivateSymbols.set(t, a);
                    }
                  } else {
                    a.setIsPrivateMember();
                  }
                }
              }
            }
            if (n) {
              n.set(t, a);
            }
          }
          return a;
        }
        {
          const e = (a === 0 ? this._currentScope.parent : this._currentScope.getGlobalScope().scope).lookUpSymbolRecursive(t);
          if (e) {
            return e.symbol;
          }
        }
      }
      _bindPossibleTupleNamedTarget(e, t) {
        switch (e.nodeType) {
          case 38:
            this._bindNameToScope(this._currentScope, e, t);
            break;
          case 52:
          case 34:
            e.d.items.forEach(e => {
              this._bindPossibleTupleNamedTarget(e, t);
            });
            break;
          case 54:
            this._bindPossibleTupleNamedTarget(e.d.valueExpr, t);
            break;
          case 56:
            this._bindPossibleTupleNamedTarget(e.d.expr, t);
        }
      }
      _addImplicitSymbolToCurrentScope(e, t, n) {
        const a = this._addSymbolToCurrentScope(e, false);
        if (a) {
          a.addDeclaration({
            type: 0,
            node: t,
            intrinsicType: n,
            uri: this._fileInfo.fileUri,
            range: c.getEmptyRange(),
            moduleName: this._fileInfo.moduleName,
            isInExceptSuite: this._isInExceptSuite
          });
          a.setIsIgnoredForProtocolMatch();
        }
      }
      _addSymbolToCurrentScope(e, t) {
        let n = this._currentScope.lookUpSymbol(e);
        if (!n) {
          let a = 0;
          if (t) {
            a |= 1;
          }
          if (this._currentScope.type === 3) {
            a |= 4;
          }
          if (this._fileInfo.isStubFile && C.isPrivateOrProtectedName(e)) {
            a |= 2;
          }
          n = this._currentScope.addSymbol(e, a);
        }
        return n;
      }
      _createNewScope(e, t, n, a) {
        const r = this._currentScope;
        const s = new v.Scope(e, t, n);
        this._currentScope = s;
        const i = e === 5 || e === 4 || e === 2;
        const o = this._currentScopeCodeFlowExpressions;
        if (i) {
          this._currentScopeCodeFlowExpressions = new Set();
        }
        a();
        this._currentScopeCodeFlowExpressions = o;
        this._currentScope = r;
        return s;
      }
      _addInferredTypeAssignmentForVariable(e, t, n = false) {
        switch (e.nodeType) {
          case 38:
            {
              const a = e;
              const r = this._currentScope.lookUpSymbolRecursive(a.d.value);
              if (r && r.symbol) {
                const s = {
                  type: 1,
                  node: e,
                  isConstant: C.isConstantName(e.d.value),
                  inferredTypeSource: t,
                  isInferenceAllowedInPyTyped: this._isInferenceAllowedInPyTyped(a.d.value),
                  typeAliasName: n ? e : undefined,
                  uri: this._fileInfo.fileUri,
                  range: d.convertTextRangeToRange(a, this._fileInfo.lines),
                  moduleName: this._fileInfo.moduleName,
                  isInExceptSuite: this._isInExceptSuite,
                  docString: this._getVariableDocString(e),
                  isExplicitBinding: this._currentScope.getBindingType(a.d.value) !== undefined
                };
                r.symbol.addDeclaration(s);
              }
              break;
            }
          case 35:
            {
              const n = this._getMemberAccessInfo(e);
              if (n) {
                const a = e.d.member;
                let r = n.classScope.lookUpSymbol(a.d.value);
                if (!r) {
                  r = n.classScope.addSymbol(a.d.value, 1);
                  const e = this._fileInfo.diagnosticRuleSet.reportPrivateUsage !== 'none';
                  if (C.isPrivateOrProtectedName(a.d.value) && e) {
                    r.setIsPrivateMember();
                  }
                }
                if (n.isInstanceMember) {
                  if (!r.isClassMember() || !r.getDeclarations().some(e => e.type === 5 && e.isMethod)) {
                    r.setIsInstanceMember();
                  }
                } else {
                  r.setIsClassMember();
                }
                const s = {
                  type: 1,
                  node: e.d.member,
                  isConstant: C.isConstantName(a.d.value),
                  inferredTypeSource: t,
                  isDefinedByMemberAccess: true,
                  uri: this._fileInfo.fileUri,
                  range: d.convertTextRangeToRange(e.d.member, this._fileInfo.lines),
                  moduleName: this._fileInfo.moduleName,
                  isInExceptSuite: this._isInExceptSuite,
                  docString: this._getVariableDocString(e)
                };
                r.addDeclaration(s);
              }
              break;
            }
          case 52:
            e.d.items.forEach(e => {
              this._addInferredTypeAssignmentForVariable(e, t);
            });
            break;
          case 54:
            this._addInferredTypeAssignmentForVariable(e.d.valueExpr, t);
            break;
          case 56:
            this._addInferredTypeAssignmentForVariable(e.d.expr, t);
            break;
          case 34:
            e.d.items.forEach(e => {
              this._addInferredTypeAssignmentForVariable(e, t);
            });
        }
      }
      _isInferenceAllowedInPyTyped(e) {
        return ['__match_args__', '__slots__', '__all__'].some(t => t === e);
      }
      _addTypeDeclarationForVariable(e, t) {
        var n;
        var a;
        var r;
        let s = false;
        switch (e.nodeType) {
          case 38:
            {
              const i = e;
              const o = this._currentScope.lookUpSymbolRecursive(i.d.value);
              if (o && o.symbol) {
                const s = this._isAnnotationFinal(t);
                let l = t;
                if (s.isFinal) {
                  if (!s.finalTypeNode) {
                    l = undefined;
                  }
                }
                const p = this._isAnnotationClassVar(t);
                if (p.isClassVar) {
                  if (!p.classVarTypeNode) {
                    l = undefined;
                  }
                }
                let c = false;
                if (s.isFinal) {
                  const t = f.getEnclosingClassOrFunction(e);
                  if (t && t.nodeType === 10) {
                    if (((n = e.parent) === null || n === undefined ? undefined : n.nodeType) === 3 || ((r = (a = e.parent) === null || a === undefined ? undefined : a.parent) === null || r === undefined ? undefined : r.nodeType) === 3) {
                      c = true;
                    }
                  }
                }
                const u = {
                  type: 1,
                  node: e,
                  isConstant: C.isConstantName(i.d.value),
                  isFinal: s.isFinal,
                  typeAliasName: e,
                  uri: this._fileInfo.fileUri,
                  typeAnnotationNode: l,
                  range: d.convertTextRangeToRange(i, this._fileInfo.lines),
                  moduleName: this._fileInfo.moduleName,
                  isInExceptSuite: this._isInExceptSuite,
                  docString: this._getVariableDocString(e),
                  isExplicitBinding: this._currentScope.getBindingType(i.d.value) !== undefined
                };
                o.symbol.addDeclaration(u);
                if (c) {
                  o.symbol.setIsFinalVarInClassBody();
                }
                if (p.isClassVar) {
                  o.symbol.setIsClassVar();
                } else {
                  if (!c) {
                    o.symbol.setIsInstanceMember();
                  }
                }
                if (t.nodeType === 27) {
                  if (this._isDataclassesAnnotation(t.d.leftExpr, 'InitVar')) {
                    o.symbol.setIsInitVar();
                  } else {
                    if (this._isTypingAnnotation(t.d.leftExpr, 'Annotated') && t.d.items.length > 0) {
                      const e = t.d.items[0].d.valueExpr;
                      if (e.nodeType === 27 && this._isDataclassesAnnotation(e.d.leftExpr, 'InitVar')) {
                        o.symbol.setIsInitVar();
                      }
                    }
                  }
                }
              }
              s = true;
              break;
            }
          case 35:
            {
              const n = this._getMemberAccessInfo(e);
              if (n) {
                const a = e.d.member;
                let r = n.classScope.lookUpSymbol(a.d.value);
                if (!r) {
                  r = n.classScope.addSymbol(a.d.value, 1);
                  const e = this._fileInfo.diagnosticRuleSet.reportPrivateUsage !== 'none';
                  if (C.isPrivateOrProtectedName(a.d.value) && e) {
                    r.setIsPrivateMember();
                  }
                }
                if (n.isInstanceMember) {
                  r.setIsInstanceMember();
                } else {
                  r.setIsClassMember();
                }
                const i = this._isAnnotationFinal(t);
                const o = {
                  type: 1,
                  node: e.d.member,
                  isConstant: C.isConstantName(a.d.value),
                  isDefinedByMemberAccess: true,
                  isFinal: i.isFinal,
                  uri: this._fileInfo.fileUri,
                  typeAnnotationNode: i.isFinal && !i.finalTypeNode ? undefined : t,
                  range: d.convertTextRangeToRange(e.d.member, this._fileInfo.lines),
                  moduleName: this._fileInfo.moduleName,
                  isInExceptSuite: this._isInExceptSuite,
                  docString: this._getVariableDocString(e)
                };
                r.addDeclaration(o);
                s = true;
              }
              break;
            }
        }
        if (!s) {
          this._addDiagnostic(l.DiagnosticRule.reportInvalidTypeForm, m.LocMessage.annotationNotSupported(), t);
        }
      }
      _isTypingAnnotation(e, t) {
        return this._isKnownAnnotation(e, t, this._typingImportAliases, this._typingSymbolAliases);
      }
      _isDataclassesAnnotation(e, t) {
        return this._isKnownAnnotation(e, t, this._dataclassesImportAliases, this._dataclassesSymbolAliases);
      }
      _isKnownAnnotation(e, t, n, a) {
        let r = e;
        if (r.nodeType === 48 && r.d.annotation) {
          r = r.d.annotation;
        }
        if (r.nodeType === 38) {
          if (a.get(r.d.value) === t) {
            return true;
          }
        } else {
          if (r.nodeType === 35 && r.d.leftExpr.nodeType === 38 && r.d.member.d.value === t) {
            const e = r.d.leftExpr.d.value;
            return n.some(t => t === e);
          }
        }
        return false;
      }
      _getVariableDocString(e) {
        const t = f.getVariableDocStringNode(e);
        if (!t) {
          return;
        }
        const n = t.d.strings;
        if (n.length === 1) {
          return n[0].d.value;
        } else {
          return n.map(e => e.d.value).join('');
        }
      }
      _isAnnotationFinal(e) {
        let t;
        let n = false;
        if (e) {
          const a = this._isAnnotationClassVar(e);
          if (a == null ? undefined : a.classVarTypeNode) {
            e = a.classVarTypeNode;
          }
          if (this._isTypingAnnotation(e, 'Final')) {
            n = true;
          } else {
            if (e.nodeType === 27 && e.d.items.length > 0 && this._isTypingAnnotation(e.d.leftExpr, 'Annotated')) {
              return this._isAnnotationFinal(e.d.items[0].d.valueExpr);
            }
            if (e.nodeType === 27 && e.d.items.length === 1) {
              if (!!this._isAnnotationFinal(e.d.leftExpr).isFinal && e.d.items[0].d.argCategory === 0 && !e.d.items[0].d.name && !e.d.trailingComma) {
                n = true;
                t = e.d.items[0].d.valueExpr;
              }
            }
          }
        }
        return {
          isFinal: n,
          finalTypeNode: t
        };
      }
      _isAnnotationClassVar(e) {
        let t;
        let n = false;
        while (e) {
          if (e.nodeType === 48 && e.d.annotation) {
            e = e.d.annotation;
          }
          if (e.nodeType !== 27 || !(e.d.items.length > 0) || !this._isTypingAnnotation(e.d.leftExpr, 'Annotated')) {
            if (this._isTypingAnnotation(e, 'ClassVar')) {
              n = true;
              break;
            }
            if (e.nodeType === 27 && e.d.items.length === 1) {
              if (!!this._isAnnotationClassVar(e.d.leftExpr).isClassVar && e.d.items[0].d.argCategory === 0 && !e.d.items[0].d.name && !e.d.trailingComma) {
                n = true;
                t = e.d.items[0].d.valueExpr;
              }
              break;
            }
            break;
          }
          e = e.d.items[0].d.valueExpr;
        }
        return {
          isClassVar: n,
          classVarTypeNode: t
        };
      }
      _getMemberAccessInfo(e) {
        if (e.d.leftExpr.nodeType !== 38) {
          return;
        }
        const t = e.d.leftExpr.d.value;
        const n = f.getEnclosingFunction(e);
        if (!n) {
          return;
        }
        const a = f.getEnclosingClass(n, true);
        if (!a) {
          return;
        }
        let r = false;
        if (n.d.params.length < 1 || !n.d.params[0].d.name) {
          return;
        }
        const s = a.d.name.d.value;
        const i = n.d.params[0].d.name.d.value;
        if (t === s) {
          r = false;
        } else {
          if (t !== i) {
            return;
          }
          if (['__new__', '__init_subclass__', '__class_getitem__'].includes(n.d.name.d.value)) {
            r = false;
          } else {
            r = true;
            for (const e of n.d.decorators) {
              if (e.d.expr.nodeType === 38) {
                const t = e.d.expr.d.value;
                if (t === 'staticmethod') {
                  return;
                }
                if (t === 'classmethod') {
                  r = false;
                  break;
                }
              }
            }
          }
        }
        const l = y.getScope(a);
        o.assert(l !== undefined);
        return {
          classNode: a,
          methodNode: n,
          classScope: l,
          isInstanceMember: r
        };
      }
      _addImplicitImportsToLoaderActions(e, t) {
        e.filteredImplicitImports.forEach(e => {
          const n = t.implicitImports ? t.implicitImports.get(e.name) : undefined;
          if (n) {
            n.uri = e.uri;
            n.loadSymbolsFromPath = true;
          } else {
            if (!t.implicitImports) {
              t.implicitImports = new Map();
            }
            t.implicitImports.set(e.name, {
              uri: e.uri,
              loadSymbolsFromPath: true,
              implicitImports: new Map()
            });
          }
        });
      }
      _handleTypingStubAssignmentOrAnnotation(e) {
        if (!this._fileInfo.isTypingStubFile) {
          return false;
        }
        let t;
        if (e.nodeType === 54) {
          t = e;
        } else {
          if (e.d.leftExpr.nodeType !== 54) {
            return false;
          }
          t = e.d.leftExpr;
        }
        if (t.d.valueExpr.nodeType !== 38) {
          return false;
        }
        const n = t.d.valueExpr;
        const a = new Set(['Tuple', 'Generic', 'Protocol', 'Callable', 'Type', 'ClassVar', 'Final', 'Literal', 'TypedDict', 'Union', 'Optional', 'Annotated', 'TypeAlias', 'Concatenate', 'TypeGuard', 'Unpack', 'Self', 'NoReturn', 'Never', 'LiteralString', 'OrderedDict', 'TypeIs']);
        const r = n.d.value;
        if (!a.has(r)) {
          return false;
        }
        const s = {
          type: 7,
          node: t,
          uri: this._fileInfo.fileUri,
          range: d.convertTextRangeToRange(t, this._fileInfo.lines),
          moduleName: this._fileInfo.moduleName,
          isInExceptSuite: this._isInExceptSuite
        };
        const i = this._bindNameToScope(this._currentScope, t.d.valueExpr);
        if (i) {
          i.addDeclaration(s);
        }
        y.setDeclaration(e, s);
        return true;
      }
      _deferBinding(e) {
        if (!this._moduleSymbolOnly) {
          this._deferredBindingTasks.push({
            scope: this._currentScope,
            codeFlowExpressions: this._currentScopeCodeFlowExpressions,
            callback: e
          });
        }
      }
      _bindDeferred() {
        while (this._deferredBindingTasks.length > 0) {
          const e = this._deferredBindingTasks.shift();
          this._currentScope = e.scope;
          this._currentScopeCodeFlowExpressions = e.codeFlowExpressions;
          e.callback();
        }
      }
      _bindYield(e) {
        const t = f.getEnclosingFunction(e);
        if (t) {
          if (t.d.isAsync && e.nodeType === 61) {
            this._addSyntaxError(m.LocMessage.yieldFromOutsideAsync(), e);
          }
        } else {
          if (!f.getEnclosingLambda(e)) {
            this._addSyntaxError(m.LocMessage.yieldOutsideFunction(), e);
          }
        }
        if (this._targetFunctionDeclaration) {
          if (!this._targetFunctionDeclaration.yieldStatements) {
            this._targetFunctionDeclaration.yieldStatements = [];
          }
          this._targetFunctionDeclaration.yieldStatements.push(e);
          this._targetFunctionDeclaration.isGenerator = true;
        }
        if (e.d.expr) {
          this.walk(e.d.expr);
        }
        y.setFlowNode(e, this._currentFlowNode);
      }
      _getUniqueFlowNodeId() {
        this._codeFlowComplexity += 0.05;
        return g.getUniqueFlowNodeId();
      }
      _addDiagnostic(e, t, n) {
        const a = this._fileInfo.diagnosticRuleSet[e];
        let r;
        switch (a) {
          case 'error':
          case 'warning':
          case 'information':
            r = this._fileInfo.diagnosticSink.addDiagnosticWithTextRange(a, t, n);
            break;
          case 'none':
            break;
          default:
            return o.assertNever(a, `${a} is not expected`);
        }
        if (r) {
          r.setRule(e);
        }
        return r;
      }
      _addSyntaxError(e, t) {
        return this._fileInfo.diagnosticSink.addDiagnosticWithTextRange('error', e, t);
      }
    }
    exports.Binder = I;
    I._unreachableFlowNode = {
      flags: g.FlowFlags.Unreachable,
      id: g.getUniqueFlowNodeId()
    };
    class k extends T.ParseTreeWalker {
      constructor() {
        super(...arguments);
        this._containsYield = false;
      }
      checkContainsYield(e) {
        this.walk(e);
        return this._containsYield;
      }
      visitYield(e) {
        this._containsYield = true;
        return false;
      }
      visitYieldFrom(e) {
        this._containsYield = true;
        return false;
      }
    }
    exports.YieldFinder = k;
    class w extends T.ParseTreeWalker {
      constructor() {
        super(...arguments);
        this._containsReturn = false;
      }
      checkContainsReturn(e) {
        this.walk(e);
        return this._containsReturn;
      }
      visitReturn(e) {
        this._containsReturn = true;
        return false;
      }
    }
    exports.ReturnFinder = w;
    class S extends T.ParseTreeWalker {
      constructor(e) {
        super();
        this._currentScope = e;
      }
      visitClass(e) {
        const t = this._createNewScope(3, () => {
          this.walk(e.d.suite);
        });
        if (!y.getScope(e)) {
          y.setScope(e, t);
        }
        return false;
      }
      visitFunction(e) {
        const t = this._createNewScope(2, () => {
          this.walk(e.d.suite);
        });
        if (!y.getScope(e)) {
          y.setScope(e, t);
        }
        return false;
      }
      _createNewScope(e, t) {
        const n = this._currentScope;
        const a = new v.Scope(e, this._currentScope);
        this._currentScope = a;
        t();
        this._currentScope = n;
        return a;
      }
    }
    exports.DummyScopeGenerator = S;
  },
  32720: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CacheManager = undefined;
    const a = require(48281);
    const r = require(16066);
    class s {
      constructor(e = 0) {
        this._maxWorkers = e;
        this._pausedCount = 0;
        this._cacheOwners = [];
        this._sharedUsagePosition = 0;
        this._lastHeapStats = Date.now();
      }
      registerCacheOwner(e) {
        this._cacheOwners.push(e);
      }
      addWorker(e, t) {
        const n = this._getSharedUsageBuffer();
        if (n) {
          t.postMessage({
            requestType: 'cacheUsageBuffer',
            sharedUsageBuffer: n,
            data: e.toString()
          });
          t.on('exit', () => {
            new Float64Array(n)[e] = 0;
          });
        }
      }
      handleCachedUsageBufferMessage(e) {
        if (e.requestType === 'cacheUsageBuffer') {
          const t = parseInt(e.data || '0');
          const n = e.sharedUsageBuffer;
          if (n && t) {
            this._sharedUsageBuffer = n;
            this._sharedUsagePosition = t;
          }
        }
      }
      unregisterCacheOwner(e) {
        const t = this._cacheOwners.findIndex(t => t === e);
        if (t < 0) {
          a.fail('Specified cache provider not found');
        } else {
          this._cacheOwners.splice(t, 1);
        }
      }
      pauseTracking() {
        const e = this;
        e._pausedCount++;
        return {
          dispose() {
            e._pausedCount--;
          }
        };
      }
      getCacheUsage() {
        if (this._pausedCount > 0) {
          return -1;
        }
        let e = 0;
        this._cacheOwners.forEach(t => {
          e += t.getCacheUsage();
        });
        return e;
      }
      emptyCache(e) {
        if (e) {
          const t = r.getHeapStatistics();
          e.info(`Emptying type cache to avoid heap overflow. Used ${this._convertToMB(t.used_heap_size)} out of ${this._convertToMB(t.heap_size_limit)}.`);
        }
        this._cacheOwners.forEach(e => {
          e.emptyCache();
        });
      }
      getUsedHeapRatio(e) {
        if (this._pausedCount > 0) {
          return -1;
        }
        const t = r.getHeapStatistics();
        let n = this._getTotalHeapUsage(t);
        if (e && Date.now() - this._lastHeapStats > 1000) {
          this._lastHeapStats = Date.now();
          const a = r.getSystemMemoryInfo();
          e.info(`Heap stats: total_memory_size=${this._convertToMB(a.total)}, total_free_size=${this._convertToMB(a.free)}, total_heap_size=${this._convertToMB(t.total_heap_size)}, used_heap_size=${this._convertToMB(t.used_heap_size)}, cross_worker_used_heap_size=${this._convertToMB(n)}, total_physical_size=${this._convertToMB(t.total_physical_size)}, total_available_size=${this._convertToMB(t.total_available_size)}, heap_size_limit=${this._convertToMB(t.heap_size_limit)}`);
        }
        n += n * 0.05;
        return n / t.heap_size_limit;
      }
      _convertToMB(e) {
        return `${Math.round(e / 1048576)}MB`;
      }
      _getSharedUsageBuffer() {
        try {
          if (!this._sharedUsageBuffer && this._maxWorkers > 0) {
            this._sharedUsageBuffer = new SharedArrayBuffer((this._maxWorkers + 1) * 8);
          }
          return this._sharedUsageBuffer;
        } catch {
          return;
        }
      }
      _getTotalHeapUsage(e) {
        const t = this._getSharedUsageBuffer();
        if (t) {
          const n = new Float64Array(t);
          n[this._sharedUsagePosition] = e.used_heap_size;
          return n.reduce((e, t) => e + t, 0);
        }
        return e.used_heap_size;
      }
    }
    exports.CacheManager = s;
    (function (e) {
      e.is = function (e) {
        return e.registerCacheOwner !== undefined && e.unregisterCacheOwner !== undefined && e.pauseTracking !== undefined && e.getCacheUsage !== undefined && e.emptyCache !== undefined && e.getUsedHeapRatio !== undefined;
      };
    })(s || (exports.CacheManager = s = {}));
  },
  56798: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Checker = undefined;
    const i = require(56911);
    const o = require(58147);
    const l = require(48281);
    const p = require(11479);
    const d = require(65880);
    const c = require(63808);
    const u = require(88754);
    const m = require(27113);
    const y = require(65574);
    const g = require(67703);
    const h = require(85114);
    const f = require(23981);
    const T = __importStar(require(26687));
    const v = require(86672);
    const b = require(20516);
    const _ = require(57373);
    const C = require(28445);
    const I = require(83760);
    const k = require(45579);
    const w = require(21451);
    const S = require(75130);
    const A = require(47610);
    const x = require(44321);
    const P = __importStar(require(41557));
    const D = require(88744);
    const N = require(69932);
    const F = require(54500);
    const E = require(95952);
    const M = require(53266);
    const O = require(3113);
    const z = require(28676);
    const U = __importStar(require(12097));
    const V = require(4064);
    const R = require(66308);
    const L = require(90080);
    const B = require(83055);
    const j = require(18891);
    const q = require(21024);
    const G = require(92324);
    class W extends D.ParseTreeWalker {
      constructor(e, t, n, a, r) {
        super();
        this._importResolver = e;
        this._evaluator = t;
        this._sourceMapper = a;
        this._dependentFiles = r;
        this._isUnboundCheckSuppressed = false;
        this._scopedNodes = [];
        this._typeParamLists = [];
        this._moduleNode = n.parseTree;
        this._fileInfo = T.getFileInfo(this._moduleNode);
      }
      check() {
        this._scopedNodes.push(this._moduleNode);
        this._conditionallyReportShadowedModule();
        const e = T.getCodeFlowComplexity(this._moduleNode);
        if (e > L.maxCodeComplexity) {
          this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.codeTooComplexToAnalyze(), {
            start: 0,
            length: 0
          });
        }
        this._walkStatementsAndReportUnreachable(this._moduleNode.d.statements);
        const t = T.getDunderAllInfo(this._moduleNode);
        if (t) {
          this._evaluator.markNamesAccessed(this._moduleNode, t.names);
          this._reportUnusedDunderAllSymbols(t.stringNodes);
        }
        this._validateSymbolTables();
        this._reportDuplicateImports();
      }
      walk(e) {
        if (T.isCodeUnreachable(e)) {
          this._evaluator.suppressDiagnostics(e, () => {
            super.walk(e);
          });
        } else {
          super.walk(e);
        }
      }
      visitSuite(e) {
        this._walkStatementsAndReportUnreachable(e.d.statements);
        return false;
      }
      visitStatementList(e) {
        e.d.statements.forEach(e => {
          if (h.isExpressionNode(e)) {
            this._evaluator.getType(e);
            this._reportUnusedExpression(e);
          }
        });
        return true;
      }
      visitClass(e) {
        const t = this._evaluator.getTypeOfClass(e);
        if (e.d.typeParams) {
          this.walk(e.d.typeParams);
        }
        this.walk(e.d.suite);
        this.walkMultiple(e.d.decorators);
        this.walkMultiple(e.d.arguments);
        if (t) {
          if (q.ClassType.isProtocolClass(t.classType)) {
            e.d.arguments.forEach(e => {
              if (!e.d.name) {
                const n = this._evaluator.getType(e.d.valueExpr);
                if (n && q.isInstantiableClass(n) && !q.ClassType.isBuiltIn(n, 'Protocol') && !q.ClassType.isBuiltIn(n, 'Generic')) {
                  if (!q.ClassType.isProtocolClass(n)) {
                    this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.protocolBaseClass().format({
                      classType: t.classType.shared.name,
                      baseType: n.shared.name
                    }), e.d.valueExpr);
                  }
                }
              }
            });
            this._validateProtocolTypeParamVariance(e, t.classType);
          }
          if (!this._fileInfo.isStubFile) {
            this._validateSlotsClassVarConflict(t.classType);
          }
          this._validateBaseClassOverrides(t.classType);
          this._validateTypedDictOverrides(t.classType);
          this._validateOverloadDecoratorConsistency(t.classType);
          this._validateMultipleInheritanceBaseClasses(t.classType, e.d.name);
          this._validateMultipleInheritanceCompatibility(t.classType, e.d.name);
          this._validateConstructorConsistency(t.classType, e.d.name);
          this._validateFinalMemberOverrides(t.classType);
          this._validateInstanceVariableInitialization(e, t.classType);
          this._validateFinalClassNotAbstract(t.classType, e);
          this._validateDataClassPostInit(t.classType);
          this._validateEnumMembers(t.classType, e);
          if (q.ClassType.isTypedDictClass(t.classType)) {
            this._validateTypedDictClassSuite(e.d.suite);
          }
          if (q.ClassType.isEnumClass(t.classType)) {
            this._validateEnumClassOverride(e, t.classType);
          }
          this._evaluator.validateInitSubclassArgs(e, t.classType);
        }
        this._scopedNodes.push(e);
        return false;
      }
      visitFunction(e) {
        var t;
        var n;
        var a;
        if (e.d.typeParams) {
          this.walk(e.d.typeParams);
        }
        if (!this._fileInfo.diagnosticRuleSet.analyzeUnannotatedFunctions && !this._fileInfo.isStubFile) {
          if (P.isUnannotatedFunction(e)) {
            this._evaluator.addInformation(g.LocMessage.unannotatedFunctionSkipped().format({
              name: e.d.name.d.value
            }), e.d.name);
          }
        }
        const r = this._evaluator.getTypeOfFunction(e);
        const s = P.getEnclosingClass(e, true);
        if (r) {
          let i = false;
          const o = new Set();
          const l = x.getParamListDetails(r.functionType);
          e.d.params.forEach((e, t) => {
            var n;
            if (e.d.name) {
              if (e.d.category === 0 && t >= l.positionOnlyParamCount) {
                o.add(e.d.name.d.value);
              }
              if (e.d.category === 1) {
                const t = (n = e.d.annotation) !== null && n !== undefined ? n : e.d.annotationComment;
                if (t && t.nodeType === 35 && t.d.member.d.value === 'args') {
                  const e = this._evaluator.getType(t.d.leftExpr);
                  if (e && q.isParamSpec(e)) {
                    i = true;
                  }
                }
              } else {
                if (e.d.category === 2) {
                  i = false;
                }
              }
            }
            if (e.d.name && e.d.category === 0 && i) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.namedParamAfterParamSpecArgs().format({
                name: e.d.name.d.value
              }), e.d.name);
            }
            if (e.d.name && e.d.name.d.value !== '_') {
              const t = r.functionType.shared.parameters.findIndex(t => {
                var n;
                return t.name === ((n = e.d.name) === null || n === undefined ? undefined : n.d.value);
              });
              if (t >= 0) {
                const n = r.functionType.shared.parameters[t];
                const a = q.FunctionType.getParamType(r.functionType, t);
                if (this._fileInfo.diagnosticRuleSet.reportUnknownParameterType !== 'none') {
                  if (q.isUnknown(a) || q.isTypeVar(a) && a.shared.isSynthesized && !q.TypeVarType.isSelf(a)) {
                    this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownParameterType, g.LocMessage.paramTypeUnknown().format({
                      paramName: e.d.name.d.value
                    }), e.d.name);
                  } else {
                    if (G.isPartlyUnknown(a)) {
                      const t = new p.DiagnosticAddendum();
                      t.addMessage(g.LocAddendum.paramType().format({
                        paramType: this._evaluator.printType(a, {
                          expandTypeAlias: true
                        })
                      }));
                      this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownParameterType, g.LocMessage.paramTypePartiallyUnknown().format({
                        paramName: e.d.name.d.value
                      }) + t.getString(), e.d.name);
                    }
                  }
                }
                let s = false;
                if (q.FunctionParam.isTypeDeclared(n) || q.isTypeVar(a) && q.TypeVarType.isSelf(a)) {
                  s = true;
                }
                if (!s && this._fileInfo.diagnosticRuleSet.reportMissingParameterType !== 'none') {
                  this._evaluator.addDiagnostic(d.DiagnosticRule.reportMissingParameterType, g.LocMessage.paramAnnotationMissing().format({
                    name: e.d.name.d.value
                  }), e.d.name);
                }
              }
            }
          });
          if (l.hasUnpackedTypedDict) {
            const n = r.functionType.shared.parameters.length - 1;
            const a = q.FunctionType.getParamType(r.functionType, n);
            if (q.isClass(a) && a.shared.typedDictEntries) {
              const r = new Set();
              a.shared.typedDictEntries.knownItems.forEach((e, t) => {
                if (o.has(t)) {
                  r.add(t);
                }
              });
              if (r.size > 0) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.overlappingKeywordArgs().format({
                  names: [...r.values()].join(', ')
                }), (t = e.d.params[n].d.annotation) !== null && t !== undefined ? t : e.d.params[n]);
              }
            }
          }
          const c = r.functionType.shared.parameters.filter((e, t) => {
            const n = q.FunctionType.getParamType(r.functionType, t);
            return !!q.FunctionParam.isTypeDeclared(e) && !!q.isTypeVar(n) && !!q.isParamSpec(n) && e.category !== 0 && !!e.name && !!n.priv.paramSpecAccess;
          });
          if (c.length === 1 && c[0].name) {
            const t = e.d.params.find(e => {
              var t;
              return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === c[0].name;
            });
            const a = (n = t == null ? undefined : t.d.annotation) !== null && n !== undefined ? n : t == null ? undefined : t.d.annotationComment;
            if (a) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecArgsKwargsUsage(), a);
            }
          }
          if (this._fileInfo.isStubFile) {
            if (!e.d.returnAnnotation && !((a = e.d.funcAnnotationComment) === null || a === undefined ? undefined : a.d.returnAnnotation)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownParameterType, g.LocMessage.returnTypeUnknown(), e.d.name);
            }
          }
          if (s) {
            this._validateMethod(e, r.functionType, s);
          }
        }
        e.d.params.forEach((e, t) => {
          if (e.d.defaultValue) {
            this.walk(e.d.defaultValue);
          }
          if (e.d.annotation) {
            this.walk(e.d.annotation);
          }
          if (e.d.annotationComment) {
            this.walk(e.d.annotationComment);
          }
          if (r) {
            const n = e.d.annotation || e.d.annotationComment;
            if (n && t < r.functionType.shared.parameters.length) {
              const e = q.FunctionType.getParamType(r.functionType, t);
              const a = ['__init__', '__new__'];
              if (s && q.isTypeVar(e) && e.priv.scopeType === 0 && e.shared.declaredVariance === 3 && !e.shared.isSynthesized && !a.some(e => e === r.functionType.shared.name)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramTypeCovariant(), n);
              }
            }
          }
        });
        if (e.d.returnAnnotation) {
          this.walk(e.d.returnAnnotation);
        }
        if (e.d.funcAnnotationComment) {
          this.walk(e.d.funcAnnotationComment);
          if (this._fileInfo.diagnosticRuleSet.reportTypeCommentUsage !== 'none' && c.PythonVersion.isGreaterOrEqualTo(this._fileInfo.executionEnvironment.pythonVersion, c.pythonVersion3_5)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportTypeCommentUsage, g.LocMessage.typeCommentDeprecated(), e.d.funcAnnotationComment);
          }
        }
        this.walkMultiple(e.d.decorators);
        e.d.params.forEach(e => {
          if (e.d.name) {
            this.walk(e.d.name);
          }
        });
        const i = T.getCodeFlowComplexity(e);
        const o = i > L.maxCodeComplexity;
        if (o) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.codeTooComplexToAnalyze(), e.d.name);
        } else {
          this.walk(e.d.suite);
        }
        if (r) {
          if (!o) {
            this._validateFunctionReturn(e, r.functionType);
          }
          this._validateDunderSignatures(e, r.functionType, s !== undefined);
          this._validateTypeGuardFunction(e, r.functionType, s !== undefined);
          this._validateFunctionTypeVarUsage(e, r);
          this._validateGeneratorReturnType(e, r.functionType);
          this._reportDeprecatedClassProperty(e, r);
          if (!s && q.FunctionType.isFinal(r.functionType)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalNonMethod().format({
              name: e.d.name.d.value
            }), e.d.name);
          }
        }
        if (this._fileInfo.isStubFile && e.d.name.d.value === '__getattr__') {
          const t = E.getScopeForNode(e);
          if ((t == null ? undefined : t.type) === 4) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompleteStub, g.LocMessage.stubUsesGetAttr(), e.d.name);
          }
        }
        this._scopedNodes.push(e);
        if (r && q.isOverloaded(r.decoratedType) && r.functionType.priv.overloaded) {
          if (q.OverloadedType.getImplementation(r.decoratedType) !== r.functionType) {
            const t = q.OverloadedType.getOverloads(r.decoratedType);
            if (t.length > 1) {
              const n = 100;
              if (t.length < n) {
                this._validateOverloadConsistency(e, t[t.length - 1], t.slice(0, t.length - 1));
              }
            }
          }
          this._validateOverloadAttributeConsistency(e, r.decoratedType);
        }
        return false;
      }
      visitLambda(e) {
        this._evaluator.getType(e);
        this.walkMultiple([...e.d.params, e.d.expr]);
        e.d.params.forEach(e => {
          if (e.d.name) {
            const t = this._evaluator.getType(e.d.name);
            if (t) {
              if (q.isUnknown(t)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownLambdaType, g.LocMessage.paramTypeUnknown().format({
                  paramName: e.d.name.d.value
                }), e.d.name);
              } else {
                if (G.isPartlyUnknown(t)) {
                  this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownLambdaType, g.LocMessage.paramTypePartiallyUnknown().format({
                    paramName: e.d.name.d.value
                  }), e.d.name);
                }
              }
            }
          }
        });
        const t = this._evaluator.getType(e.d.expr);
        if (t) {
          if (q.isUnknown(t)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownLambdaType, g.LocMessage.lambdaReturnTypeUnknown(), e.d.expr);
          } else {
            if (G.isPartlyUnknown(t)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownLambdaType, g.LocMessage.lambdaReturnTypePartiallyUnknown().format({
                returnType: this._evaluator.printType(t, {
                  expandTypeAlias: true
                })
              }), e.d.expr);
            }
          }
        }
        this._scopedNodes.push(e);
        return false;
      }
      visitCall(e) {
        var t;
        this._validateIsInstanceCall(e);
        this._validateIllegalDefaultParamInitializer(e);
        this._validateStandardCollectionInstantiation(e);
        if ((this._fileInfo.diagnosticRuleSet.reportUnusedCallResult !== 'none' || this._fileInfo.diagnosticRuleSet.reportUnusedCoroutine !== 'none') && ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 47) {
          const t = e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'reveal_type';
          const n = this._evaluator.getType(e);
          if (!t && n && this._isTypeValidForUnusedValueTest(n)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnusedCallResult, g.LocMessage.unusedCallResult().format({
              type: this._evaluator.printType(n)
            }), e);
            if (q.isClassInstance(n) && q.ClassType.isBuiltIn(n, 'Coroutine')) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnusedCoroutine, g.LocMessage.unusedCoroutine(), e);
            }
          }
        }
        return true;
      }
      visitAwait(e) {
        var t;
        if (this._fileInfo.diagnosticRuleSet.reportUnusedCallResult !== 'none' && ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 47 && e.d.expr.nodeType === 9) {
          const t = this._evaluator.getType(e);
          if (t && this._isTypeValidForUnusedValueTest(t)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnusedCallResult, g.LocMessage.unusedCallResult().format({
              type: this._evaluator.printType(t)
            }), e);
          }
        }
        return true;
      }
      visitFor(e) {
        this._evaluator.evaluateTypesForStatement(e);
        if (e.d.typeComment) {
          this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.annotationNotSupported(), e.d.typeComment);
        }
        return true;
      }
      visitList(e) {
        this._validateIllegalDefaultParamInitializer(e);
        return true;
      }
      visitSet(e) {
        this._validateIllegalDefaultParamInitializer(e);
        return true;
      }
      visitDictionary(e) {
        this._validateIllegalDefaultParamInitializer(e);
        return true;
      }
      visitComprehension(e) {
        this._scopedNodes.push(e);
        return true;
      }
      visitComprehensionIf(e) {
        this._validateConditionalIsBool(e.d.testExpr);
        this._reportUnnecessaryConditionExpression(e.d.testExpr);
        return true;
      }
      visitIf(e) {
        this._validateConditionalIsBool(e.d.testExpr);
        this._reportUnnecessaryConditionExpression(e.d.testExpr);
        return true;
      }
      visitWhile(e) {
        this._validateConditionalIsBool(e.d.testExpr);
        this._reportUnnecessaryConditionExpression(e.d.testExpr);
        return true;
      }
      visitWith(e) {
        e.d.withItems.forEach(e => {
          this._evaluator.evaluateTypesForStatement(e);
        });
        if (e.d.typeComment) {
          this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.annotationNotSupported(), e.d.typeComment);
        }
        return true;
      }
      visitReturn(e) {
        var t;
        var n;
        var a;
        var r;
        var s;
        var i;
        let o;
        let l;
        const c = P.getEnclosingFunction(e);
        let u = c ? this._evaluator.getDeclaredReturnType(c) : undefined;
        o = e.d.expr ? (t = this._evaluator.getTypeResult(e.d.expr)) !== null && t !== undefined ? t : {
          type: q.UnknownType.create()
        } : {
          type: this._evaluator.getNoneType()
        };
        l = o.type;
        if ((n = l.props) === null || n === undefined ? undefined : n.specialForm) {
          l = l.props.specialForm;
        }
        if ((c == null ? undefined : c.d.isAsync) && e.d.expr) {
          const t = T.getDeclaration(c);
          if ((t == null ? undefined : t.type) === 5 && t.isGenerator) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.returnInAsyncGenerator(), e.d.expr);
          }
        }
        if (this._evaluator.isNodeReachable(e, undefined) && c) {
          if (u) {
            if (q.isNever(u)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.noReturnContainsReturn(), e);
            } else {
              const t = P.getTypeVarScopesForNode(e);
              u = this._evaluator.stripTypeGuard(u);
              let n = G.makeTypeVarsBound(u, t);
              let s = new p.DiagnosticAddendum();
              let i = false;
              if (this._evaluator.assignType(n, l, s)) {
                i = true;
              } else {
                const a = G.getTypeVarArgsRecursive(u);
                if (a && a.some(e => q.TypeVarType.hasConstraints(e))) {
                  const r = new v.ConstraintTracker();
                  for (const t of a) {
                    if (q.TypeVarType.hasConstraints(t)) {
                      const n = this._evaluator.narrowConstrainedTypeVar(e, q.TypeVarType.cloneAsBound(t));
                      if (n) {
                        r.setBounds(t, n);
                      }
                    }
                  }
                  if (!r.isEmpty()) {
                    n = this._evaluator.solveAndApplyConstraints(u, r);
                    n = G.makeTypeVarsBound(n, t);
                    if (this._evaluator.assignType(n, l, s)) {
                      i = true;
                    }
                  }
                }
              }
              if (!i) {
                if (o.expectedTypeDiagAddendum) {
                  s = o.expectedTypeDiagAddendum;
                }
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportReturnType, g.LocMessage.returnTypeMismatch().format({
                  exprType: this._evaluator.printType(l),
                  returnType: this._evaluator.printType(u)
                }) + s.getString(), (a = e.d.expr) !== null && a !== undefined ? a : e, (r = o.expectedTypeDiagAddendum) === null || r === undefined ? undefined : r.getEffectiveTextRange());
              }
            }
          }
          if (q.isUnknown(l)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownVariableType, g.LocMessage.returnTypeUnknown(), (s = e.d.expr) !== null && s !== undefined ? s : e);
          } else {
            if (G.isPartlyUnknown(l)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownVariableType, g.LocMessage.returnTypePartiallyUnknown().format({
                returnType: this._evaluator.printType(l, {
                  expandTypeAlias: true
                })
              }), (i = e.d.expr) !== null && i !== undefined ? i : e);
            }
          }
        }
        return true;
      }
      visitYield(e) {
        var t;
        const n = e.d.expr ? this._evaluator.getTypeResult(e.d.expr) : {
          type: this._evaluator.getNoneType()
        };
        this._validateYieldType(e, (t = n == null ? undefined : n.type) !== null && t !== undefined ? t : q.UnknownType.create(), n == null ? undefined : n.expectedTypeDiagAddendum);
        return true;
      }
      visitYieldFrom(e) {
        var t;
        var n;
        var a;
        var r;
        const s = this._evaluator.getType(e.d.expr) || q.UnknownType.create();
        let i;
        let o;
        if (q.isClassInstance(s) && q.ClassType.isBuiltIn(s, 'Coroutine')) {
          i = q.UnknownType.create();
        } else {
          i = (n = (t = this._evaluator.getTypeOfIterable({
            type: s
          }, false, e)) === null || t === undefined ? undefined : t.type) !== null && n !== undefined ? n : q.UnknownType.create();
          const l = G.getGeneratorTypeArgs(i);
          if (l) {
            i = l.length >= 1 ? l[0] : q.UnknownType.create();
            o = l.length >= 2 ? l[1] : undefined;
          } else {
            i = (r = (a = this._evaluator.getTypeOfIterator({
              type: s
            }, false, e)) === null || a === undefined ? undefined : a.type) !== null && r !== undefined ? r : q.UnknownType.create();
          }
        }
        this._validateYieldType(e, i, undefined, o);
        return true;
      }
      visitRaise(e) {
        if (e.d.expr) {
          this._evaluator.verifyRaiseExceptionType(e.d.expr, false);
        }
        if (e.d.fromExpr) {
          this._evaluator.verifyRaiseExceptionType(e.d.fromExpr, true);
        }
        return true;
      }
      visitExcept(e) {
        if (e.d.typeExpr) {
          this._evaluator.evaluateTypesForStatement(e);
          const t = this._evaluator.getType(e.d.typeExpr);
          if (t) {
            this._validateExceptionType(t, e.d.typeExpr, e.d.isExceptGroup);
          }
        }
        return true;
      }
      visitAssert(e) {
        if (e.d.exceptionExpr) {
          this._evaluator.getType(e.d.exceptionExpr);
        }
        this._validateConditionalIsBool(e.d.testExpr);
        const t = this._evaluator.getType(e.d.testExpr);
        if (t && q.isClassInstance(t) && G.isTupleClass(t) && t.priv.tupleTypeArgs && t.priv.tupleTypeArgs.length > 0) {
          if (!G.isUnboundedTupleClass(t)) {
            this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportAssertAlwaysTrue, g.LocMessage.assertAlwaysTrue(), e.d.testExpr);
          }
        }
        return true;
      }
      visitAssignment(e) {
        this._evaluator.evaluateTypesForStatement(e);
        if (e.d.annotationComment) {
          this._evaluator.getType(e.d.annotationComment);
          if (this._fileInfo.diagnosticRuleSet.reportTypeCommentUsage !== 'none' && c.PythonVersion.isGreaterOrEqualTo(this._fileInfo.executionEnvironment.pythonVersion, c.pythonVersion3_6)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportTypeCommentUsage, g.LocMessage.typeCommentDeprecated(), e.d.annotationComment);
          }
        }
        if (e.d.leftExpr.nodeType === 54) {
          const t = this._evaluator.getTypeOfAnnotation(e.d.leftExpr.d.annotation);
          if (q.isClassInstance(t) && q.ClassType.isBuiltIn(t, 'TypeAlias')) {
            const t = E.getScopeForNode(e);
            if (t && t.type !== 3 && t.type !== 4 && t.type !== 5) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasNotInModuleOrClass(), e.d.leftExpr.d.annotation);
            }
          }
        }
        return true;
      }
      visitAssignmentExpression(e) {
        this._evaluator.getType(e);
        return true;
      }
      visitAugmentedAssignment(e) {
        const t = this._evaluator.getTypeResult(e);
        this._reportDeprecatedUseForOperation(e.d.destExpr, t);
        return true;
      }
      visitIndex(e) {
        this._evaluator.getType(e);
        const t = this._evaluator.getType(e.d.leftExpr);
        if (t) {
          G.doForEachSubtype(t, n => {
            const a = G.getSpecializedTupleType(n);
            if (!q.isClassInstance(n) || !(a == null ? undefined : a.priv.tupleTypeArgs) || G.isUnboundedTupleClass(a)) {
              return;
            }
            const r = a.priv.tupleTypeArgs.length;
            if (e.d.items.length !== 1 || e.d.trailingComma || e.d.items[0].d.argCategory !== 0 || e.d.items[0].d.name) {
              return;
            }
            const s = this._evaluator.getType(e.d.items[0].d.valueExpr);
            if (s && q.isClassInstance(s) && q.ClassType.isBuiltIn(s, 'int') && G.isLiteralType(s) && typeof s.priv.literalValue == 'number') {
              if ((!(s.priv.literalValue < 0) && !(s.priv.literalValue < r) || !(s.priv.literalValue >= 0) && !(s.priv.literalValue + r >= 0)) && !this._evaluator.isTypeSubsumedByOtherType(a, t, false)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.tupleIndexOutOfRange().format({
                  index: s.priv.literalValue,
                  type: this._evaluator.printType(n)
                }), e);
              }
            }
          });
        }
        return true;
      }
      visitBinaryOperation(e) {
        if (e.d.operator === 12 || e.d.operator === 28 || e.d.operator === 39 || e.d.operator === 40) {
          if (!P.isWithinAssertExpression(e)) {
            this._validateComparisonTypes(e);
          }
        } else {
          if ((e.d.operator === 41 || e.d.operator === 42) && !P.isWithinAssertExpression(e)) {
            this._validateContainmentTypes(e);
          }
        }
        const t = this._evaluator.getTypeResult(e);
        this._reportDeprecatedUseForOperation(e.d.leftExpr, t);
        return true;
      }
      visitSlice(e) {
        this._evaluator.getType(e);
        return true;
      }
      visitUnpack(e) {
        this._evaluator.getType(e);
        return true;
      }
      visitTuple(e) {
        this._evaluator.getType(e);
        return true;
      }
      visitUnaryOperation(e) {
        if (e.d.operator === 38) {
          this._validateConditionalIsBool(e.d.expr);
        }
        const t = this._evaluator.getTypeResult(e);
        this._reportDeprecatedUseForOperation(e.d.expr, t);
        return true;
      }
      visitTernary(e) {
        this._evaluator.getType(e);
        this._validateConditionalIsBool(e.d.testExpr);
        this._reportUnnecessaryConditionExpression(e.d.testExpr);
        return true;
      }
      visitStringList(e) {
        const t = [];
        if (c.PythonVersion.isLessThan(this._fileInfo.executionEnvironment.pythonVersion, c.pythonVersion3_12)) {
          let n = e;
          while (n) {
            if (n.nodeType === 30) {
              t.push(n);
            }
            n = n.parent;
          }
        }
        for (const n of e.d.strings) {
          (n.nodeType === 49 ? [n.d.token] : n.d.middleTokens).forEach(e => {
            const n = f.getUnescapedString(e);
            let a = e.start;
            if (e.type === 5) {
              a += e.prefixLength + e.quoteMarkLength;
            }
            n.unescapeErrors.forEach(e => {
              if (e.errorType === 0) {
                this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportInvalidStringEscapeSequence, g.LocMessage.stringUnsupportedEscape(), {
                  start: a + e.offset,
                  length: e.length
                });
              }
            });
            if (t.length > 0) {
              if (e.escapedValue.indexOf('\\') >= 0) {
                this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.formatStringEscape(), {
                  start: a,
                  length: 1
                });
              }
            }
          });
          if (t.length > 0) {
            const e = 7;
            if (t.some(t => (t.d.token.flags & e) == (n.d.token.flags & e))) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.formatStringNestedQuote(), n);
            }
          }
        }
        if (e.d.annotation) {
          this._evaluator.getType(e);
        }
        if (e.d.strings.length > 1 && !e.d.hasParens) {
          this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportImplicitStringConcatenation, g.LocMessage.implicitStringConcat(), e);
        }
        return true;
      }
      visitFormatString(e) {
        e.d.fieldExprs.forEach(e => {
          this._evaluator.getType(e);
        });
        e.d.formatExprs.forEach(e => {
          this._evaluator.getType(e);
        });
        return true;
      }
      visitGlobal(e) {
        this._suppressUnboundCheck(() => {
          e.d.targets.forEach(e => {
            this._evaluator.getType(e);
            this.walk(e);
          });
        });
        return false;
      }
      visitNonlocal(e) {
        this._suppressUnboundCheck(() => {
          e.d.targets.forEach(e => {
            this._evaluator.getType(e);
            this.walk(e);
          });
        });
        return false;
      }
      visitName(e) {
        this._conditionallyReportPrivateUsage(e);
        if (!this._isUnboundCheckSuppressed) {
          this._reportUnboundName(e);
        }
        const t = this._evaluator.getType(e);
        this._reportDeprecatedUseForType(e, t);
        return true;
      }
      visitDel(e) {
        e.d.targets.forEach(e => {
          this._evaluator.verifyDeleteExpression(e);
          this.walk(e);
        });
        return false;
      }
      visitMemberAccess(e) {
        var t;
        const n = this._evaluator.getTypeResult(e.d.member);
        const a = (t = n == null ? undefined : n.type) !== null && t !== undefined ? t : q.UnknownType.create();
        const r = this._evaluator.getType(e.d.leftExpr);
        this._reportDeprecatedUseForType(e.d.member, a, r && q.isModule(r) && r.priv.moduleName === 'typing');
        if (n == null ? undefined : n.memberAccessDeprecationInfo) {
          this._reportDeprecatedUseForMemberAccess(e.d.member, n.memberAccessDeprecationInfo);
        }
        this._conditionallyReportPrivateUsage(e.d.member);
        this.walk(e.d.leftExpr);
        return false;
      }
      visitImportAs(e) {
        this._conditionallyReportShadowedImport(e);
        this._evaluator.evaluateTypesForStatement(e);
        return true;
      }
      visitImportFrom(e) {
        if (e.d.module.d.leadingDots === 0 && e.d.module.d.nameParts.length === 1 && e.d.module.d.nameParts[0].d.value === '__future__') {
          if (!P.isValidLocationForFutureImport(e)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.futureImportLocationNotAllowed(), e);
          }
        }
        this._conditionallyReportShadowedImport(e);
        if (e.d.isWildcardImport) {
          this._evaluator.evaluateTypesForStatement(e);
          const t = T.getImportInfo(e.d.module);
          if (t && t.isImportFound && t.importType !== 2 && !this._fileInfo.isStubFile) {
            this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportWildcardImportFromLibrary, g.LocMessage.wildcardLibraryImport(), e.d.wildcardToken || e);
          }
        } else {
          e.d.imports.forEach(e => {
            this._evaluator.evaluateTypesForStatement(e);
          });
        }
        return true;
      }
      visitImportFromAs(e) {
        var t;
        var n;
        var a;
        if (this._fileInfo.isStubFile) {
          return false;
        }
        const r = (t = this._evaluator.getDeclInfoForNameNode(e.d.name)) === null || t === undefined ? undefined : t.decls;
        if (!r) {
          return false;
        }
        for (const t of r) {
          if (!C.isAliasDeclaration(t) || !t.submoduleFallback || t.node !== e) {
            continue;
          }
          const n = this._evaluator.resolveAliasDeclaration(t, true);
          const a = n == null ? undefined : n.uri;
          if (!a || !O.isStubFile(a)) {
            continue;
          }
          const r = this._getImportResult(e, a);
          if (r) {
            this._addMissingModuleSourceDiagnosticIfNeeded(r, e.d.name);
            break;
          }
        }
        let s = false;
        if (((n = e.parent) === null || n === undefined ? undefined : n.nodeType) === 25 && e.parent.d.module.d.leadingDots === 0 && e.parent.d.module.d.nameParts.length === 1 && e.parent.d.module.d.nameParts[0].d.value === 'typing') {
          s = true;
        }
        const i = this._evaluator.getType((a = e.d.alias) !== null && a !== undefined ? a : e.d.name);
        this._reportDeprecatedUseForType(e.d.name, i, s);
        return false;
      }
      visitModuleName(e) {
        if (this._fileInfo.isStubFile) {
          return false;
        }
        const t = T.getImportInfo(e);
        l.assert(t !== undefined);
        this._addMissingModuleSourceDiagnosticIfNeeded(t, e);
        return false;
      }
      visitTypeParameterList(e) {
        this._typeParamLists.push(e);
        return true;
      }
      visitTypeParameter(e) {
        var t;
        var n;
        var a;
        var r;
        let s = (n = (t = e.parent) === null || t === undefined ? undefined : t.parent) === null || n === undefined ? undefined : n.parent;
        let i = false;
        while (s) {
          const t = P.getTypeVarScopeNode(s);
          if (!t) {
            break;
          }
          if (t.nodeType === 10) {
            const n = (a = this._evaluator.getTypeOfClass(t)) === null || a === undefined ? undefined : a.classType;
            if (n == null ? undefined : n.shared.typeParams.some(t => t.shared.name === e.d.name.d.value)) {
              i = true;
              break;
            }
          } else {
            if (t.nodeType === 31) {
              const n = (r = this._evaluator.getTypeOfFunction(t)) === null || r === undefined ? undefined : r.functionType;
              if (n == null ? undefined : n.shared.typeParams.some(t => t.shared.name === e.d.name.d.value)) {
                i = true;
                break;
              }
            }
          }
          s = t.parent;
        }
        if (i) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarUsedByOuterScope().format({
            name: e.d.name.d.value
          }), e.d.name);
        }
        return false;
      }
      visitTypeAlias(e) {
        const t = E.getScopeForNode(e);
        if (t && t.type !== 3 && t.type !== 4 && t.type !== 5) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasStatementBadScope(), e.d.name);
        }
        return true;
      }
      visitTypeAnnotation(e) {
        this._evaluator.getType(e.d.annotation);
        return true;
      }
      visitMatch(e) {
        this._evaluator.getType(e.d.expr);
        this._validateExhaustiveMatch(e);
        return true;
      }
      visitCase(e) {
        if (e.d.guardExpr) {
          this._validateConditionalIsBool(e.d.guardExpr);
        }
        this._evaluator.evaluateTypesForStatement(e.d.pattern);
        return true;
      }
      visitPatternClass(e) {
        N.validateClassPattern(this._evaluator, e);
        return true;
      }
      visitTry(e) {
        this._reportUnusedExceptStatements(e);
        return true;
      }
      visitError(e) {
        if (e.d.child) {
          this._evaluator.getType(e.d.child);
        }
        return false;
      }
      _getImportResult(e, t) {
        const n = this._importResolver.getConfigOptions().findExecEnvironment(t);
        const a = e.parent.d.module.d.leadingDots === 0 ? this._importResolver.getModuleNameForImport(t, n).moduleName : A.getRelativeModuleName(this._importResolver.fileSystem, this._fileInfo.fileUri, t, this._importResolver.getConfigOptions());
        if (a) {
          return this._importResolver.resolveImport(this._fileInfo.fileUri, n, S.createImportedModuleDescriptor(a));
        }
      }
      _addMissingModuleSourceDiagnosticIfNeeded(e, t) {
        if (!e.isNativeLib && e.isStubFile && e.importType !== 0 && e.nonStubImportResult && !e.nonStubImportResult.isImportFound) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportMissingModuleSource, g.LocMessage.importSourceResolveFailure().format({
            importName: e.importName,
            venv: this._fileInfo.executionEnvironment.name
          }), t);
        }
      }
      _validateConditionalIsBool(e) {
        const t = this._evaluator.getType(e);
        if (!t) {
          return;
        }
        let n = true;
        const a = new p.DiagnosticAddendum();
        this._evaluator.mapSubtypesExpandTypeVars(t, undefined, t => {
          var r;
          if (q.isAnyOrUnknown(t)) {
            return;
          }
          if (q.isClassInstance(t) && q.ClassType.isBuiltIn(t, 'bool')) {
            return;
          }
          const s = (r = this._evaluator.getTypeOfMagicMethodCall(t, '__bool__', [], e, undefined)) === null || r === undefined ? undefined : r.type;
          if (s && !q.isAnyOrUnknown(s)) {
            if (!q.isClassInstance(s) || !q.ClassType.isBuiltIn(s, 'bool')) {
              n = false;
              a.addMessage(g.LocAddendum.conditionalRequiresBool().format({
                operandType: this._evaluator.printType(t),
                boolReturnType: this._evaluator.printType(s)
              }));
            }
          }
        });
        if (!n) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.conditionalOperandInvalid().format({
            type: this._evaluator.printType(t)
          }) + a.getString(), e);
        }
      }
      _reportUnnecessaryConditionExpression(e) {
        if (e.nodeType === 7) {
          if (e.d.operator === 36 || e.d.operator === 37) {
            this._reportUnnecessaryConditionExpression(e.d.leftExpr);
            this._reportUnnecessaryConditionExpression(e.d.rightExpr);
          }
          return;
        }
        if (e.nodeType === 55) {
          if (e.d.operator === 38) {
            this._reportUnnecessaryConditionExpression(e.d.expr);
          }
          return;
        }
        const t = this._evaluator.getTypeOfExpression(e);
        let n = true;
        let a = true;
        G.doForEachSubtype(t.type, e => {
          e = this._evaluator.makeTopLevelTypeVarsConcrete(e);
          if (!q.isFunction(e) && !q.isOverloaded(e)) {
            n = false;
          }
          if (!q.isClassInstance(e) || !q.ClassType.isBuiltIn(e, 'Coroutine')) {
            a = false;
          }
        });
        if (n) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryComparison, g.LocMessage.functionInConditionalExpression(), e);
        }
        if (a) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryComparison, g.LocMessage.coroutineInConditionalExpression(), e);
        }
      }
      _reportUnusedExpression(e) {
        var t;
        var n;
        if (this._fileInfo.diagnosticRuleSet.reportUnusedExpression === 'none') {
          return;
        }
        let a = false;
        if ([55, 7, 40, 14, 38, 52].some(t => t === e.nodeType)) {
          a = true;
        } else {
          if ((e.nodeType === 34 || e.nodeType === 45 || e.nodeType === 18) && !e.d.items.some(e => e.nodeType === 11)) {
            a = true;
          }
        }
        if (a && this._fileInfo.ipythonMode === M.IPythonMode.CellDocs && ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 47 && e.parent.d.statements[e.parent.d.statements.length - 1] === e && ((n = e.parent.parent) === null || n === undefined ? undefined : n.nodeType) === 36 && e.parent.parent.d.statements[e.parent.parent.d.statements.length - 1] === e.parent) {
          a = false;
        }
        if (a) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnusedExpression, g.LocMessage.unusedExpression(), e);
        }
      }
      _validateExhaustiveMatch(e) {
        if (this._fileInfo.diagnosticRuleSet.reportMatchNotExhaustive === 'none') {
          return;
        }
        const t = this._evaluator.evaluateTypeForSubnode(e, () => {
          this._evaluator.evaluateTypesForMatchStatement(e);
        });
        if (t && !q.isNever(t.type)) {
          const n = new p.DiagnosticAddendum();
          n.addMessage(g.LocAddendum.matchIsNotExhaustiveType().format({
            type: this._evaluator.printType(t.type)
          }));
          n.addMessage(g.LocAddendum.matchIsNotExhaustiveHint());
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportMatchNotExhaustive, g.LocMessage.matchIsNotExhaustive() + n.getString(), e.d.expr);
        }
      }
      _suppressUnboundCheck(e) {
        const t = this._isUnboundCheckSuppressed;
        this._isUnboundCheckSuppressed = true;
        try {
          e();
        } finally {
          this._isUnboundCheckSuppressed = t;
        }
      }
      _validateIllegalDefaultParamInitializer(e) {
        if (this._fileInfo.diagnosticRuleSet.reportCallInDefaultInitializer !== 'none' && P.isWithinDefaultParamInitializer(e) && !this._fileInfo.isStubFile) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportCallInDefaultInitializer, g.LocMessage.defaultValueContainsCall(), e);
        }
      }
      _validateStandardCollectionInstantiation(e) {
        const t = this._evaluator.getType(e.d.leftExpr);
        if (t && q.isInstantiableClass(t) && q.ClassType.isBuiltIn(t) && !t.priv.includeSubclasses && t.priv.aliasName) {
          if (['List', 'Set', 'Dict', 'Tuple'].some(e => e === t.priv.aliasName)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.collectionAliasInstantiation().format({
              type: t.priv.aliasName,
              alias: t.shared.name
            }), e.d.leftExpr);
          }
        }
      }
      _validateContainmentTypes(e) {
        const t = this._evaluator.getType(e.d.leftExpr);
        const n = this._evaluator.getType(e.d.rightExpr);
        if (!t || !n) {
          return;
        }
        if (q.isNever(t) || q.isNever(n)) {
          return;
        }
        const a = j.getElementTypeForContainerNarrowing(n);
        if (!a) {
          return;
        }
        const r = j.narrowTypeForContainerElementType(this._evaluator, t, this._evaluator.makeTopLevelTypeVarsConcrete(a));
        if (q.isNever(r)) {
          const n = () => e.d.operator === 41 ? g.LocMessage.containmentAlwaysFalse() : g.LocMessage.containmentAlwaysTrue();
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryContains, n().format({
            leftType: this._evaluator.printType(t, {
              expandTypeAlias: true
            }),
            rightType: this._evaluator.printType(a, {
              expandTypeAlias: true
            })
          }), e);
        }
      }
      _validateComparisonTypes(e) {
        let t = e.d.rightExpr;
        if (t.nodeType === 7 && !t.d.hasParens && P.operatorSupportsChaining(t.d.operator)) {
          t = t.d.leftExpr;
        }
        const n = this._evaluator.getType(e.d.leftExpr);
        const a = this._evaluator.getType(t);
        if (!n || !a) {
          return;
        }
        if (q.isNever(n) || q.isNever(a)) {
          return;
        }
        const r = () => e.d.operator === 12 || e.d.operator === 39 ? g.LocMessage.comparisonAlwaysFalse() : g.LocMessage.comparisonAlwaysTrue();
        if (G.isLiteralTypeOrUnion(a) && G.isLiteralTypeOrUnion(n)) {
          if (z.evaluateStaticBoolExpression(e, this._fileInfo.executionEnvironment, this._fileInfo.definedConstants) === undefined) {
            let t = false;
            G.doForEachSubtype(n, e => {
              if (this._evaluator.assignType(a, e)) {
                t = true;
              }
            });
            G.doForEachSubtype(a, e => {
              if (this._evaluator.assignType(n, e)) {
                t = true;
              }
            });
            if (!t) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryComparison, r().format({
                leftType: this._evaluator.printType(n, {
                  expandTypeAlias: true
                }),
                rightType: this._evaluator.printType(a, {
                  expandTypeAlias: true
                })
              }), e);
            }
          }
        } else {
          let t = false;
          this._evaluator.mapSubtypesExpandTypeVars(n, {}, e => {
            if (!t) {
              this._evaluator.mapSubtypesExpandTypeVars(a, {}, n => {
                if (!t) {
                  if (this._isTypeComparable(e, n)) {
                    t = true;
                  }
                  return n;
                }
              });
              return e;
            }
          });
          if (!t) {
            const t = this._evaluator.printType(n, {
              expandTypeAlias: true
            });
            const s = this._evaluator.printType(a, {
              expandTypeAlias: true
            });
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryComparison, r().format({
              leftType: t,
              rightType: s
            }), e);
          }
        }
      }
      _isTypeComparable(e, t) {
        if (q.isAnyOrUnknown(e) || q.isAnyOrUnknown(t)) {
          return true;
        }
        if (q.isNever(e) || q.isNever(t)) {
          return false;
        }
        if (q.isModule(e) || q.isModule(t)) {
          return q.isTypeSame(e, t, {
            ignoreConditions: true
          });
        }
        if ((q.isFunction(e) || q.isOverloaded(e)) !== (q.isFunction(t) || q.isOverloaded(t))) {
          return false;
        }
        if (q.isInstantiableClass(e) || q.isClassInstance(e) && q.ClassType.isBuiltIn(e, 'type')) {
          if (q.isInstantiableClass(t) || q.isClassInstance(t) && q.ClassType.isBuiltIn(t, 'type')) {
            const n = q.ClassType.specialize(e, undefined);
            const a = q.ClassType.specialize(t, undefined);
            if (this._evaluator.assignType(n, a) || this._evaluator.assignType(a, n)) {
              return true;
            }
          }
          const n = e.shared.effectiveMetaclass;
          return !!n && !!q.isClass(n) && !!G.lookUpClassMember(n, '__eq__', 4);
        }
        if (q.isClassInstance(e)) {
          if (q.isClass(t)) {
            const n = q.ClassType.specialize(e, undefined);
            const a = q.ClassType.specialize(t, undefined);
            if (this._evaluator.assignType(n, a) || this._evaluator.assignType(a, n)) {
              return true;
            }
            if (q.ClassType.isBuiltIn(e) && q.ClassType.isBuiltIn(t) && q.TypeBase.isInstance(t)) {
              return false;
            }
          }
          const n = G.lookUpClassMember(q.ClassType.cloneAsInstantiable(e), '__eq__', 4);
          return !!n && (!q.ClassType.isDataClass(e) || !n.symbol.getSynthesizedType());
        }
        return true;
      }
      _validateGeneratorReturnType(e, t) {
        var n;
        if (!q.FunctionType.isGenerator(t)) {
          return;
        }
        const a = t.shared.declaredReturnType;
        if (!a) {
          return;
        }
        if (q.isNever(a)) {
          return;
        }
        const r = t.shared.declaration;
        if (!r || !r.yieldStatements || r.yieldStatements.length === 0) {
          return;
        }
        let s;
        s = !e.d.isAsync && q.isClassInstance(a) && q.ClassType.isBuiltIn(a, 'AwaitableGenerator') ? this._evaluator.getTypingType(e, 'AwaitableGenerator') : this._evaluator.getTypingType(e, e.d.isAsync ? 'AsyncGenerator' : 'Generator');
        if (!s || !q.isInstantiableClass(s)) {
          return;
        }
        const i = q.ClassType.cloneAsInstance(q.ClassType.specialize(s, [q.AnyType.create(), q.AnyType.create(), q.AnyType.create()]));
        const o = new p.DiagnosticAddendum();
        if (!this._evaluator.assignType(a, i, o)) {
          const t = e.d.isAsync ? g.LocMessage.generatorAsyncReturnType() : g.LocMessage.generatorSyncReturnType();
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeForm, t.format({
            yieldType: this._evaluator.printType(q.AnyType.create())
          }) + o.getString(), (n = e.d.returnAnnotation) !== null && n !== undefined ? n : e.d.name);
        }
      }
      _isTypeValidForUnusedValueTest(e) {
        return !G.isNoneInstance(e) && !q.isNever(e) && !q.isAnyOrUnknown(e);
      }
      _validateFunctionTypeVarUsage(e, t) {
        if (this._fileInfo.diagnosticRuleSet.reportInvalidTypeVarUse === 'none') {
          return;
        }
        const n = t.functionType;
        const a = new Map();
        const r = new Map();
        let s;
        let i;
        let o = true;
        if (q.FunctionType.isInstanceMethod(n) && e.d.name.d.value === '__init__') {
          const t = P.getEnclosingClassOrFunction(e);
          if (t && t.nodeType === 10) {
            const e = this._evaluator.getTypeOfClass(t);
            if (e && q.isClass(e.classType)) {
              i = e.classType;
            }
          }
        }
        const l = new P.NameNodeWalker((t, n, l) => {
          var p;
          var d;
          var c;
          var u;
          var m;
          var y;
          var g;
          const h = this._evaluator.getType(t);
          if (h && q.isTypeVar(h) && !q.TypeVarType.isSelf(h)) {
            if (h.priv.scopeId === P.getScopeIdForNode(e)) {
              let e = q.TypeVarType.hasConstraints(h) || h.shared.isDefaultExplicit || o && n !== undefined || q.isParamSpec(h);
              if (!e && l && n !== undefined) {
                const t = this._evaluator.getType(l);
                const a = (p = t == null ? undefined : t.props) === null || p === undefined ? undefined : p.typeAliasInfo;
                if ((a == null ? undefined : a.shared.typeParams) && n < a.shared.typeParams.length) {
                  e = true;
                }
              }
              const r = a.get(h.shared.name);
              const i = ((d = s == null ? undefined : s.d.defaultValue) === null || d === undefined ? undefined : d.nodeType) === 21;
              if (r) {
                r.nodes.push(t);
                if (s !== undefined) {
                  r.paramTypeUsageCount += 1;
                  if (i) {
                    r.paramTypeWithEllipsisUsageCount += 1;
                    if (!r.paramWithEllipsis) {
                      r.paramWithEllipsis = (u = s == null ? undefined : s.d.name) === null || u === undefined ? undefined : u.d.value;
                    }
                  }
                } else {
                  r.returnTypeUsageCount += 1;
                }
              } else {
                a.set(h.shared.name, {
                  nodes: [t],
                  typeVar: h,
                  paramTypeUsageCount: s !== undefined ? 1 : 0,
                  paramTypeWithEllipsisUsageCount: i ? 1 : 0,
                  returnTypeUsageCount: s === undefined ? 1 : 0,
                  paramWithEllipsis: i ? (c = s == null ? undefined : s.d.name) === null || c === undefined ? undefined : c.d.value : undefined,
                  isExempt: e
                });
              }
            }
            if (i && h.priv.scopeId === i.shared.typeVarScopeId) {
              const e = r.get(h.shared.name);
              const n = ((m = s == null ? undefined : s.d.defaultValue) === null || m === undefined ? undefined : m.nodeType) === 21;
              const a = !!h.shared.isDefaultExplicit;
              if (e) {
                e.nodes.push(t);
                if (s !== undefined) {
                  e.paramTypeUsageCount += 1;
                  if (n) {
                    e.paramTypeWithEllipsisUsageCount += 1;
                    if (!e.paramWithEllipsis) {
                      e.paramWithEllipsis = (g = s == null ? undefined : s.d.name) === null || g === undefined ? undefined : g.d.value;
                    }
                  }
                }
              } else {
                r.set(h.shared.name, {
                  typeVar: h,
                  nodes: [t],
                  paramTypeUsageCount: s !== undefined ? 1 : 0,
                  paramTypeWithEllipsisUsageCount: n ? 1 : 0,
                  returnTypeUsageCount: 0,
                  paramWithEllipsis: n ? (y = s == null ? undefined : s.d.name) === null || y === undefined ? undefined : y.d.value : undefined,
                  isExempt: a
                });
              }
            }
          }
        });
        e.d.params.forEach(e => {
          const t = e.d.annotation || e.d.annotationComment;
          if (t) {
            s = e;
            l.walk(t);
          }
        });
        s = undefined;
        if (e.d.returnAnnotation) {
          o = false;
          l.walk(e.d.returnAnnotation);
        }
        if (e.d.funcAnnotationComment) {
          e.d.funcAnnotationComment.d.paramAnnotations.forEach(e => {
            l.walk(e);
          });
          if (e.d.funcAnnotationComment.d.returnAnnotation) {
            o = false;
            l.walk(e.d.funcAnnotationComment.d.returnAnnotation);
          }
        }
        a.forEach(e => {
          var a;
          if (e.nodes.length === 1 && !e.isExempt) {
            let t;
            t = q.isTypeVarTuple(e.typeVar) ? '"tuple[object, ...]"' : e.typeVar.shared.boundType ? `"${this._evaluator.printType(G.convertToInstance(e.typeVar.shared.boundType))}"` : '"object"';
            const n = new p.DiagnosticAddendum();
            n.addMessage(g.LocAddendum.typeVarUnnecessarySuggestion().format({
              type: t
            }));
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeVarUse, g.LocMessage.typeVarUsedOnlyOnce().format({
              name: e.nodes[0].d.value
            }) + n.getString(), e.nodes[0]);
          }
          let r = e.returnTypeUsageCount > 0;
          if (e.returnTypeUsageCount === 1 && n.shared.declaredReturnType) {
            const t = n.shared.declaredReturnType;
            if (q.isUnion(t) && t.priv.subtypes.some(t => q.isTypeVar(t) && t.shared.name === e.nodes[0].d.value)) {
              r = false;
            }
          }
          const s = q.isOverloaded(t.decoratedType) && !q.FunctionType.isOverloaded(t.functionType);
          if (r && e.paramTypeWithEllipsisUsageCount > 0 && e.paramTypeUsageCount === e.paramTypeWithEllipsisUsageCount && !s) {
            const t = new p.DiagnosticAddendum();
            t.addMessage(g.LocAddendum.typeVarUnsolvableRemedy());
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeVarUse, g.LocMessage.typeVarPossiblyUnsolvable().format({
              name: e.nodes[0].d.value,
              param: (a = e.paramWithEllipsis) !== null && a !== undefined ? a : ''
            }) + t.getString(), e.nodes[0]);
          }
        });
        r.forEach(e => {
          var t;
          if (e.paramTypeWithEllipsisUsageCount > 0 && e.paramTypeUsageCount === e.paramTypeWithEllipsisUsageCount && !e.isExempt) {
            const n = new p.DiagnosticAddendum();
            n.addMessage(g.LocAddendum.typeVarUnsolvableRemedy());
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeVarUse, g.LocMessage.typeVarPossiblyUnsolvable().format({
              name: e.nodes[0].d.value,
              param: (t = e.paramWithEllipsis) !== null && t !== undefined ? t : ''
            }) + n.getString(), e.nodes[0]);
          }
        });
      }
      _validateOverloadAttributeConsistency(e, t) {
        var n;
        var a;
        var r;
        var s;
        var i;
        var o;
        if (this._fileInfo.diagnosticRuleSet.reportInconsistentOverload === 'none') {
          return;
        }
        let l = 0;
        let p = 0;
        const c = q.OverloadedType.getOverloads(t);
        if (c.length === 0) {
          return;
        }
        let u = c.length;
        c.forEach(e => {
          if (q.FunctionType.isStaticMethod(e)) {
            l++;
          }
          if (q.FunctionType.isClassMethod(e)) {
            p++;
          }
        });
        const m = q.OverloadedType.getImplementation(t);
        if (m && q.isFunction(m)) {
          u += 1;
          if (q.FunctionType.isStaticMethod(m)) {
            l++;
          }
          if (q.FunctionType.isClassMethod(m)) {
            p++;
          }
        }
        if (l > 0 && l < u) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadStaticMethodInconsistent().format({
            name: e.d.name.d.value
          }), (r = (a = (n = c[0]) === null || n === undefined ? undefined : n.shared.declaration) === null || a === undefined ? undefined : a.node.d.name) !== null && r !== undefined ? r : e.d.name);
        }
        if (p > 0 && p < u) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadClassMethodInconsistent().format({
            name: e.d.name.d.value
          }), (o = (i = (s = c[0]) === null || s === undefined ? undefined : s.shared.declaration) === null || i === undefined ? undefined : i.node.d.name) !== null && o !== undefined ? o : e.d.name);
        }
      }
      _validateOverloadConsistency(e, t, n) {
        if (this._fileInfo.diagnosticRuleSet.reportOverlappingOverload !== 'none') {
          for (let a = 0; a < n.length; a++) {
            const r = n[a];
            if (this._isOverlappingOverload(t, r, false)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportOverlappingOverload, g.LocMessage.overlappingOverload().format({
                name: e.d.name.d.value,
                obscured: n.length + 1,
                obscuredBy: a + 1
              }), e.d.name);
              break;
            }
          }
          for (let a = 0; a < n.length; a++) {
            const r = n[a];
            if (this._isOverlappingOverload(r, t, true)) {
              const s = q.FunctionType.getEffectiveReturnType(r);
              const i = q.FunctionType.getEffectiveReturnType(t);
              if (s && i && !this._evaluator.assignType(i, s, undefined, undefined, 0)) {
                const t = this._findNodeForOverload(e, r);
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportOverlappingOverload, g.LocMessage.overloadReturnTypeMismatch().format({
                  name: e.d.name.d.value,
                  newIndex: n.length + 1,
                  prevIndex: a + 1
                }), (t || e).d.name);
                break;
              }
            }
          }
        }
      }
      _findNodeForOverload(e, t) {
        var n;
        const a = (n = this._evaluator.getDeclInfoForNameNode(e.d.name)) === null || n === undefined ? undefined : n.decls;
        if (a) {
          for (const e of a) {
            if (e.type === 5) {
              const n = this._evaluator.getTypeOfFunction(e.node);
              if ((n == null ? undefined : n.functionType) === t) {
                return e.node;
              }
            }
          }
        }
      }
      _isOverlappingOverload(e, t, n) {
        var a;
        var r;
        var s;
        if (q.FunctionType.isInstanceMethod(e) && e.shared.name === '__get__') {
          return false;
        }
        let i = 80;
        if (n) {
          i |= 32;
        }
        const o = (a = e.shared.declaration) === null || a === undefined ? undefined : a.node;
        if (o) {
          const t = P.getTypeVarScopesForNode(o);
          e = G.makeTypeVarsBound(e, t);
        }
        const l = (s = (r = t.shared.declaration) === null || r === undefined ? undefined : r.node) === null || s === undefined ? undefined : s.parent;
        if (l) {
          const e = P.getTypeVarScopesForNode(l);
          t = G.makeTypeVarsBound(t, e);
        }
        return this._evaluator.assignType(e, t, undefined, undefined, i);
      }
      _validateOverloadImplementation(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        var o;
        const l = new v.ConstraintTracker();
        let d = t;
        let c = e;
        const u = (r = (a = t.shared.declaration) === null || a === undefined ? undefined : a.node) === null || r === undefined ? undefined : r.parent;
        if (u) {
          const e = P.getTypeVarScopesForNode(u);
          d = G.makeTypeVarsBound(t, e);
        }
        const m = (s = e.shared.declaration) === null || s === undefined ? undefined : s.node;
        if (m) {
          const t = P.getTypeVarScopesForNode(m);
          c = G.makeTypeVarsBound(e, t);
        }
        let y = this._evaluator.assignType(c, d, n, l, 578);
        const h = this._evaluator.solveAndApplyConstraints((i = q.FunctionType.getEffectiveReturnType(c)) !== null && i !== undefined ? i : this._evaluator.getInferredReturnType(c), l);
        const f = this._evaluator.solveAndApplyConstraints((o = q.FunctionType.getEffectiveReturnType(d)) !== null && o !== undefined ? o : this._evaluator.getInferredReturnType(d), l);
        const T = new p.DiagnosticAddendum();
        if (!q.isNever(h) && !this._evaluator.assignType(f, h, T.createAddendum(), l, 0)) {
          T.addMessage(g.LocAddendum.functionReturnTypeMismatch().format({
            sourceType: this._evaluator.printType(h),
            destType: this._evaluator.printType(f)
          }));
          if (n != null) {
            n.addAddendum(T);
          }
          y = false;
        }
        return y;
      }
      _walkStatementsAndReportUnreachable(e) {
        let t;
        let n = false;
        for (const a of e) {
          if (!n) {
            const r = this._evaluator.getNodeReachability(a, t);
            if (r !== B.Reachability.Reachable) {
              const t = a.start;
              const s = e[e.length - 1];
              const i = u.TextRange.getEnd(s);
              this._evaluator.addUnreachableCode(a, r, {
                start: t,
                length: i - t
              });
              n = true;
            }
          }
          if (!n && this._fileInfo.isStubFile) {
            this._validateStubStatement(a);
          }
          this.walk(a);
          t = a;
        }
      }
      _validateStubStatement(e) {
        switch (e.nodeType) {
          case 22:
          case 31:
          case 10:
          case 0:
            break;
          case 57:
          case 29:
          case 53:
          case 58:
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidStubStatement, g.LocMessage.invalidStubStatement(), e);
            break;
          case 47:
            for (const t of e.d.statements) {
              let e = true;
              switch (t.nodeType) {
                case 2:
                case 4:
                case 6:
                case 7:
                case 14:
                case 17:
                case 18:
                case 27:
                case 29:
                case 30:
                case 32:
                case 33:
                case 34:
                case 35:
                case 38:
                case 39:
                case 40:
                case 43:
                case 44:
                case 45:
                case 46:
                case 51:
                case 52:
                case 53:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                  e = false;
                  break;
                case 5:
                  e = t.d.operator === 1 && t.d.leftExpr.nodeType === 38 && t.d.leftExpr.d.value === '__all__';
                  break;
                case 9:
                  e = t.d.leftExpr.nodeType === 35 && t.d.leftExpr.d.leftExpr.nodeType === 38 && t.d.leftExpr.d.leftExpr.d.value === '__all__';
              }
              if (!e) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidStubStatement, g.LocMessage.invalidStubStatement(), t);
              }
            }
        }
      }
      _validateExceptionTypeRecursive(e, t, n, a, r, s) {
        G.doForEachSubtype(e, e => {
          var i;
          if (!q.isAnyOrUnknown(e) && q.isClass(e)) {
            if (q.TypeBase.isInstantiable(e)) {
              i = e;
              if (n && q.isInstantiableClass(n) && !G.derivesFromClassRecursive(i, n, false)) {
                t.addMessage(g.LocMessage.exceptionTypeIncorrect().format({
                  type: this._evaluator.printType(e)
                }));
              }
              if (s && (e => !a || !q.isInstantiableClass(a) || G.derivesFromClassRecursive(e, a, false))(e)) {
                t.addMessage(g.LocMessage.exceptionGroupTypeIncorrect());
              }
              return;
            }
            if (r && e.priv.tupleTypeArgs) {
              e.priv.tupleTypeArgs.forEach(e => {
                this._validateExceptionTypeRecursive(e.type, t, n, a, false, s);
              });
              return;
            }
            t.addMessage(g.LocMessage.exceptionTypeIncorrect().format({
              type: this._evaluator.printType(e)
            }));
          }
        });
      }
      _validateExceptionType(e, t, n) {
        const a = this._evaluator.getBuiltInType(t, 'BaseException');
        const r = this._evaluator.getBuiltInType(t, 'BaseExceptionGroup');
        const s = new p.DiagnosticAddendum();
        this._validateExceptionTypeRecursive(e, s, a, r, true, n);
        if (!s.isEmpty()) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.exceptionTypeNotClass().format({
            type: this._evaluator.printType(e)
          }), t);
        }
      }
      _reportUnusedDunderAllSymbols(e) {
        if (this._fileInfo.diagnosticRuleSet.reportUnsupportedDunderAll === 'none') {
          return;
        }
        const t = T.getScope(this._moduleNode);
        if (t) {
          e.forEach(e => {
            if (!t.symbolTable.has(e.d.value)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnsupportedDunderAll, g.LocMessage.dunderAllSymbolNotPresent().format({
                name: e.d.value
              }), e);
            }
          });
        }
      }
      _validateSymbolTables() {
        var e;
        const t = (e = this._dependentFiles) === null || e === undefined ? undefined : e.map(e => T.getFileInfo(e.parseTree));
        for (const e of this._scopedNodes) {
          const n = T.getScope(e);
          if (n) {
            n.symbolTable.forEach((e, a) => {
              this._conditionallyReportUnusedSymbol(a, e, n.type, t);
              this._reportIncompatibleDeclarations(a, e);
              this._reportMultipleFinalDeclarations(a, e, n.type);
              this._reportFinalInLoop(e);
              this._reportMultipleTypeAliasDeclarations(a, e);
              this._reportInvalidOverload(a, e);
            });
          }
        }
        const n = this._fileInfo.accessedSymbolSet;
        for (const e of this._typeParamLists) {
          const t = T.getScope(e);
          for (const a of e.d.params) {
            const e = t == null ? undefined : t.symbolTable.get(a.d.name.d.value);
            if (!e) {
              return;
            }
            if (!n.has(e.id)) {
              e.getDeclarations().forEach(e => {
                this._conditionallyReportUnusedDeclaration(e, false);
              });
            }
          }
        }
      }
      _reportInvalidOverload(e, t) {
        const n = t.getTypedDeclarations();
        if (n.length === 0) {
          return;
        }
        const a = n[0];
        if (a.type !== 5) {
          return;
        }
        const r = this._evaluator.getEffectiveTypeOfSymbol(t);
        const s = q.isOverloaded(r) ? q.OverloadedType.getOverloads(r) : q.isFunction(r) && q.FunctionType.isOverloaded(r) ? [r] : [];
        if (q.isOverloaded(r)) {
          const e = q.OverloadedType.getOverloads(r);
          if (e.length > 0 && e[0].shared.name === '') {
            return;
          }
        } else {
          if (q.isFunction(r) && r.shared.name === '') {
            return;
          }
        }
        if (s.length === 1) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.singleOverload().format({
            name: e
          }), a.node.d.name);
        }
        if (this._fileInfo.isStubFile || s.length === 0) {
          return;
        }
        let i;
        if (q.isOverloaded(r)) {
          i = q.OverloadedType.getImplementation(r);
        } else {
          if (q.isFunction(r) && !q.FunctionType.isOverloaded(r)) {
            i = r;
          }
        }
        if (i) {
          if (q.isOverloaded(r) && this._fileInfo.diagnosticRuleSet.reportInconsistentOverload !== 'none') {
            q.OverloadedType.getOverloads(r).forEach((t, n) => {
              var r;
              var s;
              var o;
              var l;
              const c = new p.DiagnosticAddendum();
              if (i && q.isFunction(i) && !this._validateOverloadImplementation(t, i, c) && i.shared.declaration) {
                const p = this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadImplementationMismatch().format({
                  name: e,
                  index: n + 1
                }) + c.getString(), i.shared.declaration.node.d.name);
                if (p && t.shared.declaration) {
                  p.addRelatedInfo(g.LocAddendum.overloadSignature(), (s = (r = t.shared.declaration) === null || r === undefined ? undefined : r.uri) !== null && s !== undefined ? s : a.uri, (l = (o = t.shared.declaration) === null || o === undefined ? undefined : o.range) !== null && l !== undefined ? l : a.range);
                }
              }
            });
          }
        } else {
          const e = P.getEnclosingClassOrFunction(a.node);
          if (e && e.nodeType === 10) {
            const t = this._evaluator.getTypeOfClass(e);
            if (t) {
              if (q.ClassType.isProtocolClass(t.classType)) {
                return;
              }
              if (q.ClassType.supportsAbstractMethods(t.classType) && q.isOverloaded(r) && q.OverloadedType.getOverloads(r).every(e => q.FunctionType.isAbstractMethod(e))) {
                return;
              }
            }
          }
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportNoOverloadImplementation, g.LocMessage.overloadWithoutImplementation().format({
            name: a.node.d.name.d.value
          }), a.node.d.name);
        }
      }
      _reportFinalInLoop(e) {
        if (!this._evaluator.isFinalVariable(e)) {
          return;
        }
        const t = e.getDeclarations();
        if (t.length !== 0 && P.isWithinLoop(t[0].node)) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalInLoop(), t[0].node);
        }
      }
      _reportMultipleFinalDeclarations(e, t, n) {
        if (!this._evaluator.isFinalVariable(t)) {
          return;
        }
        const a = t.getDeclarations();
        let r = false;
        let s = false;
        a.forEach(t => {
          var a;
          if (this._evaluator.isFinalVariableDeclaration(t)) {
            if (r) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalRedeclaration().format({
                name: e
              }), t.node);
            }
            r = true;
          }
          let i = false;
          if (t.type === 1) {
            if (t.inferredTypeSource) {
              if (s) {
                let e = false;
                if (n === 3) {
                  const n = P.getEnclosingClassOrFunction(t.node);
                  if ((n == null ? undefined : n.nodeType) === 31) {
                    e = true;
                  }
                }
                if (!e) {
                  i = true;
                }
              }
              s = true;
            }
          } else {
            i = true;
          }
          if (i) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalReassigned().format({
              name: e
            }), (a = I.getNameNodeForDeclaration(t)) !== null && a !== undefined ? a : t.node);
          }
        });
        if (!s && !this._fileInfo.isStubFile) {
          const n = a.find(e => e.type === 1 && e.isFinal);
          if (n) {
            let a = false;
            let r = false;
            if (t.isClassMember() && !t.isClassVar()) {
              const e = P.getEnclosingClass(n.node, true);
              if (e) {
                const t = this._evaluator.getTypeOfClass(e);
                if (t && q.isClass(t.decoratedType)) {
                  if (q.ClassType.isDataClass(t.decoratedType)) {
                    a = true;
                  }
                  if (q.ClassType.isProtocolClass(t.decoratedType)) {
                    r = true;
                  }
                }
              }
            }
            if (!a && !r) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalUnassigned().format({
                name: e
              }), n.node);
            }
          }
        }
      }
      _reportMultipleTypeAliasDeclarations(e, t) {
        const n = t.getDeclarations();
        const a = n.find(e => this._evaluator.isExplicitTypeAliasDeclaration(e));
        if (a && n.length > 1) {
          n.forEach(t => {
            if (t !== a) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, g.LocMessage.typeAliasRedeclared().format({
                name: e
              }), t.node);
            }
          });
        }
      }
      _reportIncompatibleDeclarations(e, t) {
        var n;
        var a;
        var r;
        var s;
        const i = V.getLastTypedDeclarationForSymbol(t);
        if (!i) {
          return;
        }
        if (e === '_') {
          return;
        }
        let o;
        let l = t.getDeclarations().filter(e => e !== i);
        if (i.type === 5) {
          const e = this._evaluator.getTypeOfFunction(i.node);
          l = l.filter(t => {
            if (t.type !== 5) {
              return true;
            }
            const n = this._evaluator.getTypeOfFunction(t.node);
            if (!n) {
              return true;
            }
            const a = e ? this._evaluator.makeTopLevelTypeVarsConcrete(e.decoratedType) : undefined;
            if (a && q.isClassInstance(a) && q.ClassType.isPropertyClass(a) && q.isClassInstance(n.decoratedType) && q.ClassType.isPropertyClass(n.decoratedType)) {
              return n.decoratedType.shared.typeSourceId !== a.shared.typeSourceId;
            } else {
              return !q.FunctionType.isOverloaded(n.functionType);
            }
          });
        }
        if (l.length === 0) {
          return;
        }
        o = i.type === 5 ? i.isMethod ? g.LocAddendum.seeMethodDeclaration() : g.LocAddendum.seeFunctionDeclaration() : i.type === 6 ? g.LocAddendum.seeClassDeclaration() : i.type === 2 ? g.LocAddendum.seeParameterDeclaration() : i.type === 1 ? g.LocAddendum.seeVariableDeclaration() : i.type === 4 ? g.LocAddendum.seeTypeAliasDeclaration() : g.LocAddendum.seeDeclaration();
        const p = e => {
          if (e) {
            let t;
            if (i.type === 5 || i.type === 6) {
              t = i.node.d.name;
            } else {
              if (i.type === 1) {
                if (i.node.nodeType === 38) {
                  t = i.node;
                }
              } else {
                if (i.type === 2 || i.type === 3) {
                  if (i.node.d.name) {
                    t = i.node.d.name;
                  }
                }
              }
            }
            if (t) {
              e.addRelatedInfo(o, i.uri, i.range);
            }
          }
        };
        for (const t of l) {
          if (t.type === 6) {
            let n = false;
            if (i.type === 3) {
              n = true;
            }
            if (!n) {
              p(this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, g.LocMessage.obscuredClassDeclaration().format({
                name: e
              }), t.node.d.name));
            }
          } else {
            if (t.type === 5) {
              const r = (n = this._evaluator.getTypeForDeclaration(i)) === null || n === undefined ? undefined : n.type;
              let s = false;
              if (r && q.isFunction(r)) {
                this._evaluator.getInferredReturnType(r);
              }
              const o = (a = this._evaluator.getTypeForDeclaration(t)) === null || a === undefined ? undefined : a.type;
              const l = P.getEnclosingSuite(i.node) === P.getEnclosingSuite(t.node);
              if (o && q.isFunction(o)) {
                this._evaluator.getInferredReturnType(o);
              }
              if (!l && r && o && q.isTypeSame(r, o)) {
                s = true;
              }
              if (i.type === 3) {
                s = true;
              }
              if (!s) {
                p(this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, t.isMethod ? g.LocMessage.obscuredMethodDeclaration().format({
                  name: e
                }) : g.LocMessage.obscuredFunctionDeclaration().format({
                  name: e
                }), t.node.d.name));
              }
            } else {
              if (t.type === 2) {
                if (t.node.d.name) {
                  let n = false;
                  if (i.type === 3) {
                    n = true;
                  }
                  if (!n) {
                    const n = g.LocMessage.obscuredParameterDeclaration();
                    p(this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, n.format({
                      name: e
                    }), t.node.d.name));
                  }
                }
              } else {
                if (t.type === 1) {
                  const n = (r = this._evaluator.getTypeForDeclaration(i)) === null || r === undefined ? undefined : r.type;
                  if (t.typeAnnotationNode && t.node.nodeType === 38) {
                    let a = false;
                    const r = (s = this._evaluator.getTypeForDeclaration(t)) === null || s === undefined ? undefined : s.type;
                    if (n && r && q.isTypeSame(n, r)) {
                      a = true;
                    }
                    if (i.type === 3) {
                      a = true;
                    }
                    if (!a) {
                      p(this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, g.LocMessage.obscuredVariableDeclaration().format({
                        name: e
                      }), t.node));
                    }
                  }
                } else {
                  if (t.type === 4) {
                    p(this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, g.LocMessage.obscuredTypeAliasDeclaration().format({
                      name: e
                    }), t.node.d.name));
                  }
                }
              }
            }
          }
        }
      }
      _conditionallyReportUnusedSymbol(e, t, n, a) {
        const r = this._fileInfo.accessedSymbolSet;
        if (t.isIgnoredForProtocolMatch() || r.has(t.id)) {
          return;
        }
        if (a && a.some(e => e.accessedSymbolSet.has(t.id))) {
          return;
        }
        if (e === '_') {
          return;
        }
        if (U.isDunderName(e)) {
          return;
        }
        t.getDeclarations().forEach(t => {
          this._conditionallyReportUnusedDeclaration(t, this._isSymbolPrivate(e, n));
        });
      }
      _conditionallyReportUnusedDeclaration(e, t) {
        var n;
        let a;
        let r;
        let s;
        let i;
        switch (e.type) {
          case 8:
            a = this._fileInfo.diagnosticRuleSet.reportUnusedImport;
            i = d.DiagnosticRule.reportUnusedImport;
            if (e.node.nodeType === 24) {
              if (e.node.d.alias) {
                if (e.node.d.alias.d.value !== e.moduleName) {
                  r = e.node.d.alias;
                }
              } else {
                const t = e.node.d.module.d.nameParts;
                if (t.length > 0) {
                  const e = t.map(e => e.d.value).join('.');
                  let n = {
                    start: t[0].start,
                    length: t[0].length
                  };
                  n = u.TextRange.extend(n, t[t.length - 1]);
                  this._fileInfo.diagnosticSink.addUnusedCodeWithTextRange(g.LocMessage.unaccessedSymbol().format({
                    name: e
                  }), n, {
                    action: 'pyright.unusedImport'
                  });
                  this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportUnusedImport, g.LocMessage.unaccessedImport().format({
                    name: e
                  }), n);
                  return;
                }
              }
            } else {
              if (e.node.nodeType === 26) {
                const t = e.node.parent;
                const a = ((n = e.node.d.alias) === null || n === undefined ? undefined : n.d.value) === e.node.d.name.d.value;
                const s = t.d.module.d.nameParts.length === 1 && t.d.module.d.nameParts[0].d.value === '__future__';
                if (!a && !s) {
                  r = e.node.d.alias || e.node.d.name;
                }
              }
            }
            if (r) {
              s = g.LocMessage.unaccessedImport().format({
                name: r.d.value
              });
            }
            break;
          case 4:
          case 1:
          case 2:
            if (!t) {
              return;
            }
            if (this._fileInfo.isStubFile) {
              return;
            }
            a = this._fileInfo.diagnosticRuleSet.reportUnusedVariable;
            if (e.node.nodeType === 38) {
              r = e.node;
              if (r.d.value.startsWith('_')) {
                a = 'none';
              }
            } else {
              if (e.node.nodeType === 41) {
                r = e.node.d.name;
                a = 'none';
              }
            }
            if (r) {
              i = d.DiagnosticRule.reportUnusedVariable;
              s = g.LocMessage.unaccessedVariable().format({
                name: r.d.value
              });
            }
            break;
          case 6:
            if (!t) {
              return;
            }
            if (this._fileInfo.isStubFile) {
              return;
            }
            a = this._fileInfo.diagnosticRuleSet.reportUnusedClass;
            r = e.node.d.name;
            i = d.DiagnosticRule.reportUnusedClass;
            s = g.LocMessage.unaccessedClass().format({
              name: r.d.value
            });
            break;
          case 5:
            if (!t) {
              return;
            }
            if (this._fileInfo.isStubFile) {
              return;
            }
            a = this._fileInfo.diagnosticRuleSet.reportUnusedFunction;
            r = e.node.d.name;
            i = d.DiagnosticRule.reportUnusedFunction;
            s = g.LocMessage.unaccessedFunction().format({
              name: r.d.value
            });
            break;
          case 3:
            a = 'none';
            r = e.node.d.name;
            break;
          case 0:
          case 7:
            return;
          default:
            l.assertNever(e);
        }
        const o = i === d.DiagnosticRule.reportUnusedImport ? {
          action: 'pyright.unusedImport'
        } : undefined;
        if (r) {
          this._fileInfo.diagnosticSink.addUnusedCodeWithTextRange(g.LocMessage.unaccessedSymbol().format({
            name: r.d.value
          }), r, o);
          if (i !== undefined && s && a !== 'none') {
            this._evaluator.addDiagnostic(i, s, r);
          }
        }
      }
      _validateIsInstanceCall(e) {
        if (e.d.leftExpr.nodeType !== 38 || e.d.leftExpr.d.value !== 'isinstance' && e.d.leftExpr.d.value !== 'issubclass' || e.d.args.length !== 2) {
          return;
        }
        const t = e.d.leftExpr.d.value === 'isinstance';
        let n = this._evaluator.getType(e.d.args[0].d.valueExpr);
        if (!n) {
          return;
        }
        n = G.mapSubtypes(n, e => G.transformPossibleRecursiveTypeAlias(e));
        n = this._evaluator.expandPromotionTypes(e, n);
        const a = this._evaluator.getType(e.d.args[1].d.valueExpr);
        if (!a) {
          return;
        }
        let r = true;
        const s = new p.DiagnosticAddendum();
        G.doForEachSubtype(a, e => {
          if (q.isClassInstance(e) && q.ClassType.isTupleClass(e) && e.priv.tupleTypeArgs) {
            if (e.priv.tupleTypeArgs.some(e => !this._isTypeSupportedTypeForIsInstance(e.type, t, s))) {
              r = false;
            }
          } else {
            if (!this._isTypeSupportedTypeForIsInstance(e, t, s)) {
              r = false;
            }
          }
        });
        if (!r) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportArgumentType, t ? g.LocMessage.isInstanceInvalidType().format({
            type: this._evaluator.printType(a)
          }) + s.getString() : g.LocMessage.isSubclassInvalidType().format({
            type: this._evaluator.printType(a)
          }) + s.getString(), e.d.args[1]);
        }
        if (!t) {
          const t = new p.DiagnosticAddendum();
          G.doForEachSubtype(a, e => {
            if (q.isClassInstance(e) && q.ClassType.isTupleClass(e) && e.priv.tupleTypeArgs) {
              e.priv.tupleTypeArgs.forEach(e => {
                this._validateNotDataProtocol(e.type, t);
              });
            } else {
              this._validateNotDataProtocol(e, t);
            }
          });
          if (!t.isEmpty()) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.dataProtocolInSubclassCheck(), e.d.args[1]);
          }
        }
        if (P.isWithinAssertExpression(e)) {
          return;
        }
        const i = j.getIsInstanceClassTypes(this._evaluator, a);
        if (i && (i.forEach(a => {
          if (q.isInstantiableClass(a)) {
            this._validateUnsafeProtocolOverlap(e.d.args[0].d.valueExpr, q.ClassType.cloneAsInstance(a), t ? n : G.convertToInstance(n));
          }
        }), this._fileInfo.diagnosticRuleSet.reportUnnecessaryIsInstance !== 'none')) {
          const a = j.narrowTypeForInstanceOrSubclass(this._evaluator, n, i, t, false, false, e);
          const r = j.narrowTypeForInstanceOrSubclass(this._evaluator, n, i, t, false, true, e);
          const s = q.isNever(a);
          const o = q.isNever(r);
          if (s || o) {
            const a = q.combineTypes(i.map(e => G.convertToInstance(e)));
            const r = s ? t ? g.LocMessage.unnecessaryIsInstanceAlways() : g.LocMessage.unnecessaryIsSubclassAlways() : t ? g.LocMessage.unnecessaryIsInstanceNever() : g.LocMessage.unnecessaryIsSubclassNever();
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryIsInstance, r.format({
              testType: this._evaluator.printType(n),
              classType: this._evaluator.printType(a)
            }), e);
          }
        }
      }
      _validateUnsafeProtocolOverlap(e, t, n) {
        if (q.ClassType.isProtocolClass(t)) {
          let a = false;
          const r = new p.DiagnosticAddendum();
          G.doForEachSubtype(n, e => {
            if (q.isClassInstance(e) && F.isProtocolUnsafeOverlap(this._evaluator, t, e)) {
              a = true;
              r.addMessage(g.LocAddendum.protocolUnsafeOverlap().format({
                name: e.shared.name
              }));
            }
          });
          if (a) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.protocolUnsafeOverlap().format({
              name: t.shared.name
            }) + r.getString(), e);
          }
        }
      }
      _isTypeSupportedTypeForIsInstance(e, t, n) {
        let a = true;
        G.doForEachSubtype(e, e => {
          e = this._evaluator.makeTopLevelTypeVarsConcrete(e);
          if ((e = G.transformPossibleRecursiveTypeAlias(e)).props?.specialForm && q.ClassType.isBuiltIn(e.props.specialForm, 'TypeAliasType')) {
            n.addMessage(g.LocAddendum.typeAliasInstanceCheck());
            a = false;
            return;
          }
          switch (e.category) {
            case 2:
            case 1:
            case 0:
              break;
            case 6:
              if (q.ClassType.isBuiltIn(e, 'TypedDict')) {
                n.addMessage(g.LocAddendum.typedDictNotAllowed());
                a = false;
              } else {
                if (q.ClassType.isBuiltIn(e, 'NamedTuple')) {
                  n.addMessage(g.LocAddendum.namedTupleNotAllowed());
                  a = false;
                } else {
                  if (G.isNoneInstance(e)) {
                    n.addMessage(g.LocAddendum.noneNotAllowed());
                    a = false;
                  } else {
                    if (q.ClassType.isTypedDictClass(e)) {
                      n.addMessage(g.LocAddendum.typedDictClassNotAllowed());
                      a = false;
                    } else {
                      if (e.priv.isTypeArgExplicit && !e.priv.includeSubclasses) {
                        n.addMessage(g.LocAddendum.genericClassNotAllowed());
                        a = false;
                      } else {
                        if (q.ClassType.isIllegalIsinstanceClass(e)) {
                          n.addMessage(g.LocAddendum.isinstanceClassNotSupported().format({
                            type: e.shared.name
                          }));
                          a = false;
                        } else {
                          if (!q.ClassType.isProtocolClass(e) || q.ClassType.isRuntimeCheckable(e) || e.priv.includeSubclasses) {
                            if (q.ClassType.isNewTypeClass(e)) {
                              n.addMessage(g.LocAddendum.newTypeClassNotAllowed());
                              a = false;
                            } else {
                              if (e.props?.specialForm && q.isClassInstance(e.props.specialForm) && q.ClassType.isBuiltIn(e.props.specialForm, 'Annotated')) {
                                n.addMessage(g.LocAddendum.annotatedNotAllowed());
                                a = false;
                              }
                            }
                          } else {
                            n.addMessage(g.LocAddendum.protocolRequiresRuntimeCheckable());
                            a = false;
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;
            case 4:
              if (!q.TypeBase.isInstantiable(e) || !!e.priv.isCallableWithTypeArgs) {
                n.addMessage(g.LocAddendum.genericClassNotAllowed());
                a = false;
              }
              break;
            case 9:
              n.addMessage(g.LocAddendum.typeVarNotAllowed());
              a = false;
          }
        });
        return a;
      }
      _validateNotDataProtocol(e, t) {
        if (q.isInstantiableClass(e) && q.ClassType.isProtocolClass(e) && !F.isMethodOnlyProtocol(e)) {
          t.addMessage(g.LocAddendum.dataProtocolUnsupported().format({
            name: e.shared.name
          }));
        }
      }
      _isSymbolPrivate(e, t) {
        if (t === 2 || t === 1) {
          return true;
        }
        if (U.isPrivateName(e)) {
          return true;
        }
        if (U.isProtectedName(e)) {
          return t !== 3;
        }
        return false;
      }
      _reportDeprecatedClassProperty(e, t) {
        if (q.isClassInstance(t.decoratedType) && q.ClassType.isClassProperty(t.decoratedType)) {
          this._reportDeprecatedDiagnostic(e.d.name, g.LocMessage.classPropertyDeprecated());
        }
      }
      _reportDeprecatedUseForMemberAccess(e, t) {
        let n;
        if (t.accessType === 'property') {
          n = t.accessMethod === 'get' ? g.LocMessage.deprecatedPropertyGetter().format({
            name: e.d.value
          }) : t.accessMethod === 'set' ? g.LocMessage.deprecatedPropertySetter().format({
            name: e.d.value
          }) : g.LocMessage.deprecatedPropertyDeleter().format({
            name: e.d.value
          });
        } else {
          if (t.accessType === 'descriptor') {
            n = t.accessMethod === 'get' ? g.LocMessage.deprecatedDescriptorGetter().format({
              name: e.d.value
            }) : t.accessMethod === 'set' ? g.LocMessage.deprecatedDescriptorSetter().format({
              name: e.d.value
            }) : g.LocMessage.deprecatedDescriptorDeleter().format({
              name: e.d.value
            });
          }
        }
        if (n) {
          this._reportDeprecatedDiagnostic(e, n, t.deprecatedMessage);
        }
      }
      _reportDeprecatedUseForOperation(e, t) {
        const n = t == null ? undefined : t.magicMethodDeprecationInfo;
        if (n) {
          this._reportDeprecatedDiagnostic(e, g.LocMessage.deprecatedMethod().format({
            className: n.className,
            name: n.methodName
          }), n.deprecatedMessage);
        }
      }
      _reportDeprecatedUseForType(e, t, n = false) {
        var a;
        var r;
        var s;
        if (!t) {
          return;
        }
        let i;
        let o;
        function l(e) {
          if (e.shared.declaration && e.shared.declaration.node.nodeType === 31) {
            const t = P.getEnclosingClass(e.shared.declaration.node, true);
            if (t) {
              return g.LocMessage.deprecatedMethod().format({
                name: e.shared.name || '<anonymous>',
                className: t.d.name.d.value
              });
            }
          }
          return g.LocMessage.deprecatedFunction().format({
            name: e.shared.name
          });
        }
        function p(t, n) {
          let a;
          const r = P.getCallForName(e);
          if (r) {
            a = t.getTypeResult(r);
          } else {
            const n = P.getDecoratorForName(e);
            if (n) {
              a = t.getTypeResultForDecorator(n);
            }
          }
          if (a && a.overloadsUsedForCall && a.overloadsUsedForCall.length > 0) {
            a.overloadsUsedForCall.forEach(t => {
              if (t.shared.deprecatedMessage !== undefined) {
                if (e.d.value === t.shared.name) {
                  o = t.shared.deprecatedMessage;
                  i = l(t);
                } else {
                  if (q.isInstantiableClass(n) && ['__init__', '__new__'].includes(t.shared.name)) {
                    o = t.shared.deprecatedMessage;
                    i = g.LocMessage.deprecatedConstructor().format({
                      name: n.shared.name
                    });
                  } else {
                    if (q.isClassInstance(n) && t.shared.name === '__call__') {
                      o = t.shared.deprecatedMessage;
                      i = g.LocMessage.deprecatedFunction().format({
                        name: e.d.value
                      });
                    }
                  }
                }
              }
            });
          }
        }
        G.doForEachSubtype(t, t => {
          if (q.isClass(t)) {
            if (t.priv.includeSubclasses || t.shared.deprecatedMessage === undefined || e.d.value !== t.shared.name) {
              p(this._evaluator, t);
              return;
            } else {
              o = t.shared.deprecatedMessage;
              return void (i = g.LocMessage.deprecatedClass().format({
                name: t.shared.name
              }));
            }
          }
          if (q.isFunction(t)) {
            if (t.shared.deprecatedMessage !== undefined) {
              if (!t.shared.name || t.shared.name === '__call__' || e.d.value === t.shared.name) {
                o = t.shared.deprecatedMessage;
                i = l(t);
              }
            }
          } else {
            if (q.isOverloaded(t)) {
              p(this._evaluator, t);
              const n = q.OverloadedType.getImplementation(t);
              if (n && q.isFunction(n) && n.shared.deprecatedMessage !== undefined) {
                if (!n.shared.name || e.d.value === n.shared.name) {
                  o = n.shared.deprecatedMessage;
                  i = l(n);
                }
              }
            }
          }
        });
        if (i) {
          this._reportDeprecatedDiagnostic(e, i, o);
        }
        if (this._fileInfo.diagnosticRuleSet.deprecateTypingAliases) {
          const i = (a = k.deprecatedAliases.get(e.d.value)) !== null && a !== undefined ? a : k.deprecatedSpecialForms.get(e.d.value);
          if (i && (q.isInstantiableClass(t) && t.shared.fullName === i.fullName || ((s = (r = t.props) === null || r === undefined ? undefined : r.typeAliasInfo) === null || s === undefined ? undefined : s.shared.fullName) === i.fullName) && c.PythonVersion.isGreaterOrEqualTo(this._fileInfo.executionEnvironment.pythonVersion, i.version)) {
            if (!i.typingImportOnly || !!n) {
              this._reportDeprecatedDiagnostic(e, g.LocMessage.deprecatedType().format({
                version: c.PythonVersion.toString(i.version),
                replacement: i.replacementText
              }));
            }
          }
        }
      }
      _reportDeprecatedDiagnostic(e, t, n) {
        const a = new p.DiagnosticAddendum();
        if (n) {
          a.addMessage(n);
        }
        if (this._fileInfo.diagnosticRuleSet.reportDeprecated === 'none') {
          this._evaluator.addDeprecated(t + a.getString(), e);
        } else {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportDeprecated, t + a.getString(), e);
        }
      }
      _reportUnboundName(e) {
        if (this._fileInfo.diagnosticRuleSet.reportUnboundVariable !== 'none' && !T.isCodeUnreachable(e)) {
          const t = this._evaluator.getType(e);
          if (t) {
            if (q.isUnbound(t)) {
              if (this._evaluator.isNodeReachable(e)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnboundVariable, g.LocMessage.symbolIsUnbound().format({
                  name: e.d.value
                }), e);
              }
            } else {
              if (q.isPossiblyUnbound(t)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportPossiblyUnboundVariable, g.LocMessage.symbolIsPossiblyUnbound().format({
                  name: e.d.value
                }), e);
              }
            }
          }
        }
      }
      _conditionallyReportShadowedModule() {
        if (this._fileInfo.diagnosticRuleSet.reportShadowedImports === 'none') {
          return;
        }
        const e = this._fileInfo.moduleName;
        const t = {
          nameParts: e.split('.'),
          leadingDots: 0,
          importedSymbols: new Set()
        };
        if (this._importResolver.getTypeshedStdLibPath(this._fileInfo.executionEnvironment) && this._importResolver.isStdlibModule(t, this._fileInfo.executionEnvironment) && this._sourceMapper.isUserCode(this._fileInfo.fileUri)) {
          const t = this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportShadowedImports, g.LocMessage.stdlibModuleOverridden().format({
            name: e,
            path: this._fileInfo.fileUri.toUserVisibleString()
          }), this._moduleNode);
          if (t) {
            const e = {
              action: 'renameShadowedFile',
              oldUri: this._fileInfo.fileUri,
              newUri: this._sourceMapper.getNextFileName(this._fileInfo.fileUri)
            };
            t.addAction(e);
          }
        }
      }
      _conditionallyReportShadowedImport(e) {
        var t;
        var n;
        if (this._fileInfo.diagnosticRuleSet.reportShadowedImports === 'none') {
          return;
        }
        const a = e.nodeType === 26 ? ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 25 ? (n = e.parent) === null || n === undefined ? undefined : n.d.module : undefined : e.d.module;
        if (a == null ? undefined : a.d.leadingDots) {
          return;
        }
        const r = e.nodeType === 24 ? e.d.module.d.nameParts : e.nodeType === 26 ? [e.d.name] : e.d.module.d.nameParts;
        const s = r.map(e => e.d.value);
        const o = {
          nameParts: s,
          leadingDots: 0,
          importedSymbols: new Set()
        };
        const l = this._importResolver.getTypeshedStdLibPath(this._fileInfo.executionEnvironment);
        if (l && this._importResolver.isStdlibModule(o, this._fileInfo.executionEnvironment)) {
          const t = y.DefinitionProvider.getDefinitionsForNode(this._sourceMapper, this._evaluator, r[r.length - 1], r[r.length - 1].start, i.CancellationToken.None);
          (t ? t.map(e => e.uri) : []).forEach(t => {
            if (!t.startsWith(l) && !O.isStubFile(t) && this._sourceMapper.isUserCode(t)) {
              const n = this._evaluator.addDiagnostic(d.DiagnosticRule.reportShadowedImports, g.LocMessage.stdlibModuleOverridden().format({
                name: s.join('.'),
                path: t.toUserVisibleString()
              }), e);
              if (n) {
                const e = {
                  action: 'renameShadowedFile',
                  oldUri: t,
                  newUri: this._sourceMapper.getNextFileName(t)
                };
                n.addAction(e);
              }
            }
          });
        }
      }
      _conditionallyReportPrivateUsage(e) {
        var t;
        var n;
        var a;
        if (this._fileInfo.diagnosticRuleSet.reportPrivateUsage === 'none') {
          return;
        }
        if (this._fileInfo.isStubFile) {
          return;
        }
        if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 1 && e.parent.d.name === e) {
          return;
        }
        const r = e.d.value;
        const s = U.isPrivateName(r);
        const i = U.isProtectedName(r);
        if (!s && !i) {
          return;
        }
        const o = (a = (n = this._evaluator.getDeclInfoForNameNode(e)) === null || n === undefined ? undefined : n.decls) === null || a === undefined ? undefined : a.filter(e => e.type !== 1 || !e.isExplicitBinding);
        let l;
        let p = o && o.length > 0 ? o[o.length - 1] : undefined;
        if (!p || p.node === e) {
          return;
        }
        if (p.type === 8) {
          if (p.usesLocalName) {
            return;
          }
          const e = this._evaluator.resolveAliasDeclarationWithInfo(p, true);
          if (!e) {
            return;
          }
          p = e.declaration;
          if (!e.isPrivate) {
            return;
          }
        }
        if (!p || p.node === e) {
          return;
        }
        if (p.node) {
          l = P.getEnclosingClass(p.node);
        }
        if (p.node && p.node.parent && p.node.parent === l) {
          l = P.getEnclosingClass(l);
        }
        let c = false;
        if (l && i) {
          const t = this._evaluator.getTypeOfClass(l);
          if (t && q.isInstantiableClass(t.decoratedType)) {
            if (q.ClassType.isDefinedInStub(t.decoratedType)) {
              return;
            }
            c = true;
            const n = P.getEnclosingClass(e);
            if (n) {
              const e = this._evaluator.getTypeOfClass(n);
              if (e && q.isInstantiableClass(e.decoratedType) && G.derivesFromClassRecursive(e.decoratedType, t.decoratedType, true)) {
                return;
              }
            }
          }
        }
        if (l && !P.isNodeContainedWithin(e, l)) {
          if (c) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportPrivateUsage, g.LocMessage.protectedUsedOutsideOfClass().format({
              name: r
            }), e);
          } else {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportPrivateUsage, g.LocMessage.privateUsedOutsideOfClass().format({
              name: r
            }), e);
          }
        }
      }
      _validateEnumClassOverride(e, t) {
        t.shared.baseClasses.forEach((t, n) => {
          if (q.isClass(t) && w.isEnumClassWithMembers(this._evaluator, t)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.enumClassOverride().format({
              name: t.shared.name
            }), e.d.arguments[n]);
          }
        });
      }
      _validateTypedDictClassSuite(e) {
        const t = e => {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictBadVar(), e);
        };
        e.d.statements.forEach(e => {
          if (!T.isCodeUnreachable(e)) {
            if (e.nodeType === 47) {
              for (const n of e.d.statements) {
                if (n.nodeType !== 54 && n.nodeType !== 21 && n.nodeType !== 48 && n.nodeType !== 42) {
                  t(n);
                }
              }
            } else {
              t(e);
            }
          }
        });
      }
      _validateTypeGuardFunction(e, t, n) {
        var a;
        const r = t.shared.declaredReturnType;
        if (!r) {
          return;
        }
        if (!q.isClassInstance(r) || !r.priv.typeArgs || r.priv.typeArgs.length < 1) {
          return;
        }
        const s = q.ClassType.isBuiltIn(r, 'TypeGuard');
        const i = q.ClassType.isBuiltIn(r, 'TypeIs');
        if (!s && !i) {
          return;
        }
        let o = t.shared.parameters.length;
        if (n && (q.FunctionType.isInstanceMethod(t) || q.FunctionType.isConstructorMethod(t) || q.FunctionType.isClassMethod(t))) {
          o--;
        }
        if (o < 1) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeGuardParamCount(), e.d.name);
        }
        if (i) {
          const s = G.getTypeVarScopeIds(t);
          const i = r.priv.typeArgs[0];
          let o = G.makeTypeVarsBound(i, s);
          o = q.TypeBase.cloneWithTypeForm(o, o);
          const l = n && !q.FunctionType.isStaticMethod(t) ? 1 : 0;
          if (l >= t.shared.parameters.length) {
            return;
          }
          const p = G.makeTypeVarsBound(q.FunctionType.getParamType(t, l), s);
          if (!this._evaluator.assignType(p, o)) {
            const t = e.d.returnAnnotation || ((a = e.d.funcAnnotationComment) === null || a === undefined ? undefined : a.d.returnAnnotation);
            if (t) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeIsReturnType().format({
                type: this._evaluator.printType(p),
                returnType: this._evaluator.printType(i)
              }), t);
            }
          }
        }
      }
      _validateDunderSignatures(e, t, n) {
        var a;
        const r = t.shared.name;
        if (n && r === '__init__') {
          const n = e.d.returnAnnotation || ((a = e.d.funcAnnotationComment) === null || a === undefined ? undefined : a.d.returnAnnotation);
          const r = t.shared.declaredReturnType;
          if (n && r) {
            if (!G.isNoneInstance(r) && !q.isNever(r)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.initMustReturnNone(), n);
            }
          } else {
            const n = this._evaluator.getInferredReturnType(t);
            if (!q.isNever(n) && !G.isNoneInstance(n) && !q.isAnyOrUnknown(n)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.initMustReturnNone(), e.d.name);
            }
          }
        }
      }
      _validateFunctionReturn(e, t) {
        var n;
        if (this._fileInfo.isStubFile) {
          return;
        }
        const a = e.d.returnAnnotation || ((n = e.d.funcAnnotationComment) === null || n === undefined ? undefined : n.d.returnAnnotation);
        if (a) {
          const n = !this._evaluator.isAfterNodeReachable(e);
          const r = this._evaluator.isAfterNodeReachable(e.d.suite);
          let s = t.shared.declaredReturnType;
          if (s) {
            this._reportUnknownReturnResult(e, s);
            this._validateReturnTypeIsNotContravariant(s, a);
            const t = P.getTypeVarScopesForNode(e);
            s = G.makeTypeVarsBound(s, t);
          }
          if (q.FunctionType.isGenerator(t)) {
            s = G.getDeclaredGeneratorReturnType(t);
          }
          if (s && !n && r) {
            if (q.isNever(s)) {
              if (!P.isSuiteEmpty(e.d.suite) && !q.FunctionType.isOverloaded(t) && !q.FunctionType.isAsync(t)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportReturnType, g.LocMessage.noReturnReturnsNone(), a);
              }
            } else {
              if (!q.FunctionType.isAbstractMethod(t)) {
                const n = P.isSuiteEmpty(e.d.suite) || q.FunctionType.isOverloaded(t);
                const r = n ? undefined : new p.DiagnosticAddendum();
                if (!this._evaluator.assignType(s, this._evaluator.getNoneType(), r) && !n) {
                  this._evaluator.addDiagnostic(d.DiagnosticRule.reportReturnType, g.LocMessage.returnMissing().format({
                    returnType: this._evaluator.printType(s)
                  }) + (r == null ? undefined : r.getString()), a);
                }
              }
            }
          }
        } else {
          const n = this._evaluator.getInferredReturnType(t);
          this._reportUnknownReturnResult(e, n);
          this._validateReturnTypeIsNotContravariant(n, e.d.name);
        }
      }
      _validateReturnTypeIsNotContravariant(e, t) {
        let n = false;
        G.doForEachSubtype(e, e => {
          if (q.isTypeVar(e) && e.shared.declaredVariance === 4 && e.priv.scopeType === 0) {
            n = true;
          }
        });
        if (n) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.returnTypeContravariant(), t);
        }
      }
      _reportUnknownReturnResult(e, t) {
        if (q.isUnknown(t)) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownParameterType, g.LocMessage.returnTypeUnknown(), e.d.name);
        } else {
          if (G.isPartlyUnknown(t)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownParameterType, g.LocMessage.returnTypePartiallyUnknown().format({
              returnType: this._evaluator.printType(t, {
                expandTypeAlias: true
              })
            }), e.d.name);
          }
        }
      }
      _validateFinalMemberOverrides(e) {
        q.ClassType.getSymbolTable(e).forEach((t, n) => {
          const a = G.lookUpClassMember(e, n, 1);
          if (a && q.isInstantiableClass(a.classType) && !U.isPrivateName(n)) {
            if (this._evaluator.isFinalVariable(a.symbol)) {
              const e = t.getDeclarations()[0];
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalRedeclarationBySubclass().format({
                name: n,
                className: a.classType.shared.name
              }), e.node);
            } else {
              if (q.ClassType.hasNamedTupleEntry(a.classType, n) && !U.isDunderName(n)) {
                const e = t.getDeclarations()[0];
                if (e.type === 1) {
                  this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.namedTupleEntryRedeclared().format({
                    name: n,
                    className: a.classType.shared.name
                  }), e.node);
                }
              }
            }
          }
        });
      }
      _validateEnumMembers(e, t) {
        if (!q.ClassType.isEnumClass(e) || q.ClassType.isBuiltIn(e)) {
          return;
        }
        const n = w.getEnumDeclaredValueType(this._evaluator, e, true);
        let a = b.getBoundNewMethod(this._evaluator, t.d.name, e, undefined, 4);
        if ((a == null ? undefined : a.classType) && q.isClass(a.classType) && q.ClassType.isBuiltIn(a.classType)) {
          a = undefined;
        }
        let r = b.getBoundInitMethod(this._evaluator, t.d.name, q.ClassType.cloneAsInstance(e), undefined, 4);
        if ((r == null ? undefined : r.classType) && q.isClass(r.classType) && q.ClassType.isBuiltIn(r.classType)) {
          r = undefined;
        }
        q.ClassType.getSymbolTable(e).forEach((t, s) => {
          var i;
          const o = w.transformTypeForEnumMember(this._evaluator, e, s, true);
          if (!o || !q.isClassInstance(o) || !q.ClassType.isSameGenericClass(o, q.ClassType.cloneAsInstance(e)) || !(o.priv.literalValue instanceof q.EnumLiteral)) {
            return;
          }
          const l = t.getTypedDeclarations();
          if (l.length > 0) {
            if (l[0].type === 1 && l[0].inferredTypeSource) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.enumMemberTypeAnnotation(), l[0].node);
            }
            return;
          }
          const c = t.getDeclarations();
          if (c.length >= 2 && c[0].type === 1) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.duplicateEnumMember().format({
              name: s
            }), c[1].node);
            return;
          }
          if (c[0].type !== 1) {
            return;
          }
          if (c[0].isFinal) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.enumMemberTypeAnnotation(), c[0].node);
          }
          const u = c[0].node;
          const m = o.priv.literalValue.itemType;
          const y = P.getParentNodeOfType(u, 3);
          const h = (i = y == null ? undefined : y.d.rightExpr) !== null && i !== undefined ? i : u;
          if (a || r) {
            if (!q.isAnyOrUnknown(m)) {
              const e = [{
                argCategory: q.isClassInstance(m) && G.isTupleClass(m) ? 1 : 0,
                typeResult: {
                  type: m
                }
              }];
              if (a) {
                this._evaluator.validateCallArgs(h, e, a, undefined, undefined, undefined);
              }
              if (r) {
                this._evaluator.validateCallArgs(h, e, r, undefined, undefined, undefined);
              }
            }
          } else {
            if (n) {
              const t = new p.DiagnosticAddendum();
              if ((!q.isClassInstance(m) || !q.ClassType.isSameGenericClass(m, e)) && !this._evaluator.assignType(n, m, t)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportAssignmentType, g.LocMessage.typeAssignmentMismatch().format(this._evaluator.printSrcDestTypes(m, n)) + t.getString(), h);
              }
            }
          }
        });
      }
      _validateDataClassPostInit(e) {
        if (!q.ClassType.isDataClass(e)) {
          return;
        }
        const t = G.lookUpClassMember(e, '__post_init__', 66);
        if (!t) {
          return;
        }
        if (q.ClassType.derivesFromAnyOrUnknown(e)) {
          return;
        }
        const n = new Map();
        q.ClassType.getReverseMro(e).forEach(e => {
          if (q.isClass(e) && q.ClassType.isDataClass(e)) {
            q.ClassType.getSymbolTable(e).forEach((e, t) => {
              if (e.isInitVar()) {
                n.set(t, e);
              }
            });
          }
        });
        const a = this._evaluator.getTypeOfMember(t);
        if (!q.isFunction(a) || !q.FunctionType.isInstanceMethod(a) || !a.shared.declaration) {
          return;
        }
        const r = x.getParamListDetails(a);
        if (r.argsIndex !== undefined || r.kwargsIndex !== undefined || r.firstKeywordOnlyIndex !== undefined) {
          return;
        }
        const s = r.params.filter((e, t) => q.FunctionType.getParamDefaultType(a, t) === undefined);
        const i = n.size + 1;
        const o = a.shared.declaration.node;
        if (i < s.length || i > r.params.length) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.dataClassPostInitParamCount().format({
            expected: n.size
          }), o.d.name);
        }
        let l = 1;
        n.forEach((e, t) => {
          var n;
          var s;
          if (l >= r.params.length) {
            return;
          }
          const i = r.params[l].param;
          const c = o.d.params.find(e => {
            var t;
            return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === i.name;
          });
          const u = (n = c == null ? undefined : c.d.annotation) !== null && n !== undefined ? n : c == null ? undefined : c.d.annotationComment;
          if (q.FunctionParam.isTypeDeclared(i) && u) {
            const n = (s = this._evaluator.getDeclaredTypeOfSymbol(e)) === null || s === undefined ? undefined : s.type;
            const i = q.FunctionType.getParamType(a, r.params[l].index);
            const o = new p.DiagnosticAddendum();
            if (n && !this._evaluator.assignType(i, n, o)) {
              const n = this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.dataClassPostInitType().format({
                fieldName: t
              }) + o.getString(), u);
              if (n) {
                const t = e.getTypedDeclarations();
                if (t.length > 0) {
                  n.addRelatedInfo(g.LocAddendum.dataClassFieldLocation(), t[0].uri, t[0].range);
                }
              }
            }
          }
          l++;
        });
      }
      _validateFinalClassNotAbstract(e, t) {
        if (!q.ClassType.isFinal(e)) {
          return;
        }
        if (!q.ClassType.supportsAbstractMethods(e)) {
          return;
        }
        const n = this._evaluator.getAbstractSymbols(e);
        if (n.length === 0) {
          return;
        }
        const a = new p.DiagnosticAddendum();
        n.forEach((e, t) => {
          if (t === 2) {
            a.addMessage(g.LocAddendum.memberIsAbstractMore().format({
              count: n.length - 2
            }));
          } else {
            if (t < 2 && q.isInstantiableClass(e.classType)) {
              const t = e.classType.shared.name;
              a.addMessage(g.LocAddendum.memberIsAbstract().format({
                type: t,
                name: e.symbolName
              }));
            }
          }
        });
        this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalClassIsAbstract().format({
          type: e.shared.name
        }) + a.getString(), t.d.name);
      }
      _validateInstanceVariableInitialization(e, t) {
        if (this._fileInfo.isStubFile) {
          return;
        }
        if (this._fileInfo.diagnosticRuleSet.reportUninitializedInstanceVariable === 'none') {
          return;
        }
        if (q.ClassType.isProtocolClass(t) || q.ClassType.supportsAbstractMethods(t) && !q.ClassType.isFinal(t)) {
          return;
        }
        const n = new Map();
        if (q.ClassType.isFinal(t)) {
          G.getProtocolSymbolsRecursive(t, n, 64);
        }
        const a = [];
        if (q.ClassType.isDataClass(t)) {
          _.addInheritedDataClassEntries(t, a);
        }
        q.ClassType.getSymbolTable(t).forEach((e, a) => {
          n.delete(a);
          if (!e.isInstanceMember()) {
            return;
          }
          const r = e.getDeclarations();
          if (r.find(e => {
            var n;
            var r;
            var s;
            const i = P.getEnclosingClassOrFunction(e.node);
            if (!i) {
              return true;
            }
            if (i.nodeType === 10) {
              if (((n = e.node.parent) === null || n === undefined ? undefined : n.nodeType) === 3) {
                return true;
              }
              if (((r = e.node.parent) === null || r === undefined ? undefined : r.nodeType) === 54 && ((s = e.node.parent.parent) === null || s === undefined ? undefined : s.nodeType) === 3) {
                return true;
              }
              if (q.ClassType.isDataClass(t) || q.ClassType.hasNamedTupleEntry(t, a)) {
                return true;
              }
              if (q.ClassType.isTypedDictClass(t)) {
                return true;
              }
            }
            return i.d.name.d.value === '__init__';
          })) {
            return;
          }
          if (!G.lookUpClassMember(t, a, 1)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUninitializedInstanceVariable, g.LocMessage.uninitializedInstanceVariable().format({
              name: a
            }), r[0].node);
          }
        });
        const r = new p.DiagnosticAddendum();
        n.forEach((e, t) => {
          const n = e.symbol.getDeclarations();
          if (n.length === 0 || !q.isClass(e.classType)) {
            return;
          }
          if (n[0].type !== 1) {
            return;
          }
          const s = a == null ? undefined : a.find(e => e.name === t);
          if (s) {
            if (s.includeInInit) {
              return;
            }
          } else {
            if (n.some(e => e.type === 1 && !!e.inferredTypeSource)) {
              return;
            }
          }
          r.addMessage(g.LocAddendum.uninitializedAbstractVariable().format({
            name: t,
            classType: e.classType.shared.name
          }));
        });
        if (!r.isEmpty()) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUninitializedInstanceVariable, g.LocMessage.uninitializedAbstractVariables().format({
            classType: t.shared.name
          }) + r.getString(), e.d.name);
        }
      }
      _validateProtocolTypeParamVariance(e, t) {
        if (t.shared.typeParams.length === 0) {
          return;
        }
        const n = this._evaluator.getBuiltInType(e, 'object');
        if (!q.isInstantiableClass(n)) {
          return;
        }
        const a = q.ClassType.cloneAsInstance(n);
        const r = q.ClassType.createInstantiable('__varianceDummy', '', '', m.Uri.empty(), 0, 0, undefined, undefined);
        t.shared.typeParams.forEach((n, s) => {
          if (q.isTypeVarTuple(n) || q.isParamSpec(n)) {
            return;
          }
          if (n.shared.isSynthesized) {
            return;
          }
          if (n.shared.declaredVariance === 0) {
            return;
          }
          const i = t.shared.typeParams.map((e, t) => q.isTypeVarTuple(e) ? e : t === s ? a : r);
          const o = t.shared.typeParams.map((e, t) => t === s || q.isTypeVarTuple(e) ? e : r);
          const l = q.ClassType.specialize(t, i);
          const p = q.ClassType.specialize(t, o);
          let c;
          if (this._evaluator.assignClassToSelf(l, p, 3)) {
            c = 3;
          } else {
            c = this._evaluator.assignClassToSelf(p, l, 4) ? 4 : 2;
          }
          if (c !== t.shared.typeParams[s].shared.declaredVariance) {
            let a;
            a = c === 3 ? g.LocMessage.protocolVarianceCovariant().format({
              variable: n.shared.name,
              class: t.shared.name
            }) : c === 4 ? g.LocMessage.protocolVarianceContravariant().format({
              variable: n.shared.name,
              class: t.shared.name
            }) : g.LocMessage.protocolVarianceInvariant().format({
              variable: n.shared.name,
              class: t.shared.name
            });
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeVarUse, a, e.d.name);
          }
        });
      }
      _validateSlotsClassVarConflict(e) {
        if (e.shared.localSlotsNames) {
          if (!q.ClassType.isDataClass(e)) {
            q.ClassType.getSymbolTable(e).forEach((e, t) => {
              const n = e.getDeclarations();
              if (n.some(e => e.type === 1 && e.isDefinedBySlots)) {
                n.forEach(e => {
                  if (e.type === 1 && !e.isDefinedBySlots && !e.isDefinedByMemberAccess) {
                    if (e.node.nodeType === 38 && P.isWriteAccess(e.node)) {
                      this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.slotsClassVarConflict().format({
                        name: t
                      }), e.node);
                    }
                  }
                });
              }
            });
          }
        }
      }
      _validateConstructorConsistency(e, t) {
        if (b.getBoundCallMethod(this._evaluator, t, e)) {
          return;
        }
        const n = b.getBoundNewMethod(this._evaluator, t, e);
        if (!n || n.typeErrors || !n.classType || !q.isClass(n.classType)) {
          return;
        }
        const a = b.getBoundInitMethod(this._evaluator, t, q.ClassType.cloneAsInstance(e));
        if (!a || a.typeErrors || !a.classType || !q.isClass(a.classType)) {
          return;
        }
        if (!q.ClassType.isSameGenericClass(a.classType, e) && !q.ClassType.isSameGenericClass(n.classType, e)) {
          return;
        }
        let r = n.type;
        if (!q.isFunction(r) && !q.isOverloaded(r)) {
          return;
        }
        if (q.isOverloaded(r) && (r = q.OverloadedType.getImplementation(r), !r || !q.isFunction(r))) {
          return;
        }
        let s = a.type;
        if ((q.isFunction(s) || q.isOverloaded(s)) && (!q.isOverloaded(s) || (s = q.OverloadedType.getImplementation(s), s && q.isFunction(s))) && !q.FunctionType.hasDefaultParams(s) && !q.FunctionType.hasDefaultParams(r) && (!this._evaluator.assignType(r, s, undefined, undefined, 64) || !this._evaluator.assignType(s, r, undefined, undefined, 64))) {
          const t = q.ClassType.isSameGenericClass(a.classType, e);
          const i = s.shared.declaration;
          const o = r.shared.declaration;
          if (i && o) {
            const e = t ? i : o;
            const l = e.node.nodeType === 31 ? e.node.d.name : e.node;
            const c = new p.DiagnosticAddendum();
            const u = this._evaluator.printType(s);
            const m = this._evaluator.printType(r);
            c.addMessage(g.LocAddendum.initMethodSignature().format({
              type: u
            }));
            c.addMessage(g.LocAddendum.newMethodSignature().format({
              type: m
            }));
            const y = this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentConstructor, g.LocMessage.constructorParametersMismatch().format({
              classType: this._evaluator.printType(q.ClassType.cloneAsInstance(t ? a.classType : n.classType))
            }) + c.getString(), l);
            if (y) {
              const e = t ? o : i;
              y.addRelatedInfo((t ? g.LocAddendum.newMethodLocation() : g.LocAddendum.initMethodLocation()).format({
                type: this._evaluator.printType(q.ClassType.cloneAsInstance(t ? n.classType : a.classType))
              }), e.uri, e.range);
            }
          }
        }
      }
      _validateMultipleInheritanceBaseClasses(e, t) {
        const n = [];
        for (const t of e.shared.baseClasses) {
          if (!q.isClass(t)) {
            return;
          }
          if (!q.ClassType.isBuiltIn(t, ['Generic', 'Protocol', 'object'])) {
            n.push(t);
          }
        }
        if (n.length < 2) {
          return;
        }
        const a = new p.DiagnosticAddendum();
        for (const t of n) {
          const n = G.buildSolutionFromSpecializedClass(t);
          for (const r of t.shared.mro) {
            if (q.isClass(r) && r.shared.typeParams.length > 0) {
              const s = G.applySolvedTypeVars(r, n);
              const i = e.shared.mro.find(e => q.isClass(e) && q.ClassType.isSameGenericClass(e, s));
              if (i && q.isInstantiableClass(i)) {
                const n = G.getTypeVarScopeIds(e);
                const r = G.makeTypeVarsBound(q.ClassType.cloneAsInstance(i), n);
                const o = G.makeTypeVarsBound(q.ClassType.cloneAsInstance(s), n);
                if (!this._evaluator.assignType(r, o)) {
                  const e = new p.DiagnosticAddendum();
                  const n = G.convertToInstance(t);
                  if (q.isTypeSame(n, o)) {
                    e.addMessage(g.LocAddendum.baseClassIncompatible().format({
                      baseClass: this._evaluator.printType(n),
                      type: this._evaluator.printType(r)
                    }));
                  } else {
                    e.addMessage(g.LocAddendum.baseClassIncompatibleSubclass().format({
                      baseClass: this._evaluator.printType(n),
                      subclass: this._evaluator.printType(o),
                      type: this._evaluator.printType(r)
                    }));
                  }
                  a.addAddendum(e);
                  break;
                }
              }
            }
          }
        }
        if (!a.isEmpty()) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.baseClassIncompatible().format({
            type: e.shared.name
          }) + a.getString(), t);
        }
      }
      _validateMultipleInheritanceCompatibility(e, t) {
        if (this._fileInfo.diagnosticRuleSet.reportIncompatibleMethodOverride === 'none' && this._fileInfo.diagnosticRuleSet.reportIncompatibleVariableOverride === 'none') {
          return;
        }
        const n = [];
        e.shared.baseClasses.forEach(e => {
          if (!!q.isClass(e) && !q.ClassType.isBuiltIn(e, 'Generic') && !q.ClassType.isBuiltIn(e, 'Protocol')) {
            n.push(e);
          }
        });
        if (n.length < 2) {
          return;
        }
        const a = n.map(t => {
          const n = e.shared.mro.find(e => q.isClass(e) && q.ClassType.isSameGenericClass(e, t));
          if (n && q.isClass(n)) {
            return G.getClassFieldsRecursive(n);
          } else {
            return new Map();
          }
        });
        const r = G.getClassFieldsRecursive(e);
        for (let n = 1; n < a.length; n++) {
          const s = a[n];
          for (const [n, a] of s) {
            if (U.isDunderName(n) || U.isPrivateName(n)) {
              continue;
            }
            const s = a.classType;
            if (!q.isClass(s)) {
              continue;
            }
            const i = r.get(n);
            if (i) {
              const r = i.classType;
              if (!q.isClass(r) || q.ClassType.isSameGenericClass(r, s) || q.ClassType.isSameGenericClass(r, e)) {
                continue;
              }
              this._validateMultipleInheritanceOverride(a, i, e, n, t);
            }
          }
        }
      }
      _validateMultipleInheritanceOverride(e, t, n, a, r) {
        var s;
        var i;
        var o;
        var l;
        if (!q.isClass(e.classType) || !q.isClass(t.classType)) {
          return;
        }
        if (a === '_') {
          return;
        }
        let c = this._evaluator.getEffectiveTypeOfSymbol(e.symbol);
        c = G.partiallySpecializeType(c, e.classType, this._evaluator.getTypeClassType());
        const u = t.symbol;
        let m = this._evaluator.getEffectiveTypeOfSymbol(u);
        m = G.partiallySpecializeType(m, t.classType, this._evaluator.getTypeClassType());
        const y = q.ClassType.getSymbolTable(n).get(a);
        const h = y ? this._evaluator.getEffectiveTypeOfSymbol(y) : undefined;
        let f;
        const T = V.getLastTypedDeclarationForSymbol(t.symbol);
        const v = V.getLastTypedDeclarationForSymbol(e.symbol);
        if (q.isFunction(c) || q.isOverloaded(c)) {
          const e = new p.DiagnosticAddendum();
          let t;
          if (q.isFunction(m)) {
            t = m;
          } else {
            if (q.isOverloaded(m)) {
              const e = q.OverloadedType.getImplementation(m);
              if (!e || !q.isFunction(e)) {
                return;
              }
              t = e;
            }
          }
          if (t && !this._evaluator.validateOverrideMethod(c, t, undefined, e, true)) {
            const s = t.shared.declaration;
            if (s && s.type === 5) {
              f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.baseClassMethodTypeIncompatible().format({
                classType: n.shared.name,
                name: a
              }) + e.getString(), r);
            }
          }
        } else {
          if (G.isProperty(c)) {
            if (G.isProperty(m) || q.isAnyOrUnknown(m)) {
              this._validateMultipleInheritancePropertyOverride(e.classType, n, c, m, u, a, r);
            } else {
              if (u.getDeclarations().length > 0) {
                f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.baseClassVariableTypeIncompatible().format({
                  classType: n.shared.name,
                  name: a
                }), r);
              }
            }
          } else {
            if (this._fileInfo.diagnosticRuleSet.reportIncompatibleVariableOverride !== 'none') {
              const p = V.getLastTypedDeclarationForSymbol(e.symbol);
              let u;
              let y;
              let T = (p == null ? undefined : p.type) === 1 && !p.isFinal;
              if (q.ClassType.isDataClassFrozen(e.classType) && e.classType.shared.dataClassEntries) {
                if (e.classType.shared.dataClassEntries.find(e => e.name === a)) {
                  T = false;
                }
              }
              if (e.classType.shared.typedDictEntries) {
                u = (i = (s = e.classType.shared.typedDictEntries.knownItems.get(a)) !== null && s !== undefined ? s : e.classType.shared.typedDictEntries.extraItems) !== null && i !== undefined ? i : R.getEffectiveExtraItemsEntryType(this._evaluator, e.classType);
                if (u == null ? undefined : u.isReadOnly) {
                  T = false;
                }
              }
              if (t.classType.shared.typedDictEntries) {
                y = (l = (o = t.classType.shared.typedDictEntries.knownItems.get(a)) !== null && o !== undefined ? o : t.classType.shared.typedDictEntries.extraItems) !== null && l !== undefined ? l : R.getEffectiveExtraItemsEntryType(this._evaluator, t.classType);
              }
              if (this._evaluator.assignType(c, h ?? m, undefined, undefined, T ? 1 : 0)) {
                if (u && y) {
                  let e;
                  let t = true;
                  if (u.isReadOnly) {
                    e = y.isRequired || !u.isRequired;
                  } else {
                    t = !y.isReadOnly;
                    e = y.isRequired === u.isRequired;
                  }
                  if (e) {
                    if (!t) {
                      f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.typedDictFieldReadOnlyRedefinition().format({
                        name: a
                      }), r);
                    }
                  } else {
                    const e = y.isRequired ? g.LocMessage.typedDictFieldRequiredRedefinition : g.LocMessage.typedDictFieldNotRequiredRedefinition;
                    f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, e().format({
                      name: a
                    }), r);
                  }
                }
              } else {
                f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.baseClassVariableTypeIncompatible().format({
                  classType: n.shared.name,
                  name: a
                }), r);
              }
            }
          }
        }
        if (f && T && v) {
          this._addMultipleInheritanceRelatedInfo(f, e.classType, c, v, t.classType, m, T);
        }
      }
      _addMultipleInheritanceRelatedInfo(e, t, n, a, r, s, i) {
        e.addRelatedInfo(g.LocAddendum.baseClassOverriddenType().format({
          baseClass: this._evaluator.printType(G.convertToInstance(t)),
          type: this._evaluator.printType(n)
        }), a.uri, a.range);
        e.addRelatedInfo(g.LocAddendum.baseClassOverridesType().format({
          baseClass: this._evaluator.printType(G.convertToInstance(r)),
          type: this._evaluator.printType(s)
        }), i.uri, i.range);
      }
      _validateMultipleInheritancePropertyOverride(e, t, n, a, r, s, i) {
        [['fget', e => {
          var t;
          if ((t = e.priv.fgetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }], ['fset', e => {
          var t;
          if ((t = e.priv.fsetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }], ['fdel', e => {
          var t;
          if ((t = e.priv.fdelInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }]].forEach(o => {
          const l = new p.DiagnosticAddendum();
          const [c, u] = o;
          const m = u(n);
          const y = u(a);
          if (m) {
            const o = G.partiallySpecializeType(m, e, this._evaluator.getTypeClassType());
            if (q.isFunction(o)) {
              if (y) {
                const r = G.partiallySpecializeType(y, t, this._evaluator.getTypeClassType());
                if (q.isFunction(r) && !this._evaluator.validateOverrideMethod(o, r, t, l.createAddendum())) {
                  l.addMessage(g.LocAddendum.propertyMethodIncompatible().format({
                    name: c
                  }));
                  const p = r.shared.declaration;
                  if (p && p.type === 5) {
                    const r = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.propertyOverridden().format({
                      name: s,
                      className: e.shared.name
                    }) + l.getString(), i);
                    const c = o.shared.declaration;
                    if (r && c) {
                      this._addMultipleInheritanceRelatedInfo(r, e, n, c, t, a, p);
                    }
                  }
                }
              } else {
                l.addMessage(g.LocAddendum.propertyMethodMissing().format({
                  name: c
                }));
                const p = r.getDeclarations();
                if (p.length > 0) {
                  const r = p[p.length - 1];
                  const c = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.propertyOverridden().format({
                    name: s,
                    className: e.shared.name
                  }) + l.getString(), i);
                  const u = o.shared.declaration;
                  if (c && u) {
                    this._addMultipleInheritanceRelatedInfo(c, e, n, u, t, a, r);
                  }
                }
              }
            }
          }
        });
      }
      _validateOverloadDecoratorConsistency(e) {
        q.ClassType.getSymbolTable(e).forEach((e, t) => {
          const n = V.getLastTypedDeclarationForSymbol(e);
          if (!n || n.type !== 5) {
            return;
          }
          const a = this._evaluator.getEffectiveTypeOfSymbol(e);
          if (!q.isOverloaded(a)) {
            return;
          }
          const r = q.OverloadedType.getOverloads(a);
          const s = q.OverloadedType.getImplementation(a);
          this._validateOverloadFinalConsistency(r, s);
          this._validateOverloadAbstractConsistency(r, s);
        });
      }
      _validateOverloadAbstractConsistency(e, t) {
        if (t && q.isFunction(t)) {
          if (q.FunctionType.isAbstractMethod(t)) {
            return;
          }
          e.forEach(e => {
            var t;
            const n = e.shared.declaration;
            if (q.FunctionType.isAbstractMethod(e) && n) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadAbstractImplMismatch().format({
                name: e.shared.name
              }), (t = I.getNameNodeForDeclaration(n)) !== null && t !== undefined ? t : n.node);
            }
          });
          return;
        }
        if (e.length < 2) {
          return;
        }
        const n = q.FunctionType.isAbstractMethod(e[0]);
        e.slice(1).forEach((e, t) => {
          var a;
          if (q.FunctionType.isAbstractMethod(e) !== n && e.shared.declaration) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadAbstractMismatch().format({
              name: e.shared.name
            }), (a = I.getNameNodeForDeclaration(e.shared.declaration)) !== null && a !== undefined ? a : e.shared.declaration.node);
          }
        });
      }
      _validateOverloadFinalConsistency(e, t) {
        if (t && q.isFunction(t)) {
          if (!q.FunctionType.isFinal(t)) {
            e.forEach(e => {
              var t;
              var n;
              if (q.FunctionType.isFinal(e) && ((t = e.shared.declaration) === null || t === undefined ? undefined : t.node)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadFinalInconsistencyImpl().format({
                  name: e.shared.name
                }), (n = I.getNameNodeForDeclaration(e.shared.declaration)) !== null && n !== undefined ? n : e.shared.declaration.node);
              }
            });
          }
        } else {
          if (e.length > 0 && !q.FunctionType.isFinal(e[0])) {
            e.slice(1).forEach((e, t) => {
              var n;
              var a;
              if (q.FunctionType.isFinal(e) && ((n = e.shared.declaration) === null || n === undefined ? undefined : n.node)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadFinalInconsistencyNoImpl().format({
                  name: e.shared.name,
                  index: t + 2
                }), (a = I.getNameNodeForDeclaration(e.shared.declaration)) !== null && a !== undefined ? a : e.shared.declaration.node);
              }
            });
          }
        }
      }
      _validateTypedDictOverrides(e) {
        if (!q.ClassType.isTypedDictClass(e)) {
          return;
        }
        const t = R.getTypedDictMembersForClass(this._evaluator, e, false);
        for (const n of e.shared.baseClasses) {
          const a = new p.DiagnosticAddendum();
          if (!q.isClass(n) || !q.ClassType.isTypedDictClass(n) || !q.ClassType.isTypedDictEffectivelyClosed(n)) {
            continue;
          }
          const r = R.getTypedDictMembersForClass(this._evaluator, n, false);
          const s = G.buildSolutionFromSpecializedClass(n);
          const i = r.extraItems ? G.applySolvedTypeVars(r.extraItems.valueType, s) : q.UnknownType.create();
          for (const [e, n] of t.knownItems) {
            if (!r.knownItems.get(e)) {
              if (!r.extraItems || q.isNever(r.extraItems.valueType)) {
                a.addMessage(g.LocAddendum.typedDictClosedExtraNotAllowed().format({
                  name: e
                }));
              } else {
                if (this._evaluator.assignType(i, n.valueType, undefined, undefined, r.extraItems.isReadOnly ? 0 : 1)) {
                  if (!r.extraItems.isReadOnly && n.isRequired) {
                    a.addMessage(g.LocAddendum.typedDictClosedFieldNotRequired().format({
                      name: e
                    }));
                  }
                } else {
                  a.addMessage(g.LocAddendum.typedDictClosedExtraTypeMismatch().format({
                    name: e,
                    type: this._evaluator.printType(n.valueType)
                  }));
                }
              }
            }
          }
          if (t.extraItems && r.extraItems) {
            if (!this._evaluator.assignType(i, t.extraItems.valueType, undefined, undefined, r.extraItems.isReadOnly ? 0 : 1)) {
              a.addMessage(g.LocAddendum.typedDictClosedExtraTypeMismatch().format({
                name: 'extra_items',
                type: this._evaluator.printType(t.extraItems.valueType)
              }));
            }
          }
          if (!a.isEmpty() && e.shared.declaration) {
            const t = I.getNameNodeForDeclaration(e.shared.declaration);
            if (t) {
              if (r.extraItems) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.typedDictClosedExtras().format({
                  name: n.shared.name,
                  type: this._evaluator.printType(i)
                }) + a.getString(), t);
              } else {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.typedDictClosedNoExtras().format({
                  name: n.shared.name
                }) + a.getString(), t);
              }
            }
          }
        }
      }
      _validateBaseClassOverrides(e) {
        q.ClassType.getSymbolTable(e).forEach((t, n) => {
          if (U.isPrivateName(n)) {
            return;
          }
          let a = true;
          if (!t.hasTypedDeclarations()) {
            a = false;
          }
          const r = this._evaluator.getEffectiveTypeOfSymbol(t);
          if (q.isAnyOrUnknown(r)) {
            return;
          }
          let s;
          for (const i of e.shared.baseClasses) {
            if (!q.isClass(i)) {
              continue;
            }
            const o = e.shared.mro.find(e => q.isClass(e) && q.ClassType.isSameGenericClass(e, i));
            if (!o) {
              continue;
            }
            l.assert(q.isClass(o));
            const p = G.lookUpClassMember(o, n, 0);
            if (p) {
              s = s ?? p;
              this._validateBaseClassOverride(p, t, a ? r : q.AnyType.create(), e, n);
            }
          }
          if (s) {
            this._validateOverrideDecoratorPresent(t, r, s);
          } else {
            this._validateOverrideDecoratorNotPresent(t, r);
          }
        });
      }
      _validateOverrideDecoratorPresent(e, t, n) {
        if (this._fileInfo.diagnosticRuleSet.reportImplicitOverride === 'none') {
          return;
        }
        let a;
        if (q.isFunction(t)) {
          a = t;
        } else {
          if (q.isOverloaded(t)) {
            const e = q.OverloadedType.getImplementation(t);
            if (e && q.isFunction(e)) {
              a = e;
            }
          } else {
            if (q.isClassInstance(t) && q.ClassType.isPropertyClass(t) && t.priv.fgetInfo) {
              a = t.priv.fgetInfo.methodType;
            }
          }
        }
        if (!(a == null ? undefined : a.shared.declaration) || q.FunctionType.isOverridden(a)) {
          return;
        }
        if (this._isMethodExemptFromLsp(a.shared.name)) {
          return;
        }
        if (!e.getDeclarations().some(e => e === a.shared.declaration)) {
          return;
        }
        if (q.isAnyOrUnknown(n.classType)) {
          return;
        }
        const r = a.shared.declaration.node;
        this._evaluator.addDiagnostic(d.DiagnosticRule.reportImplicitOverride, g.LocMessage.overrideDecoratorMissing().format({
          name: r.d.name.d.value,
          className: this._evaluator.printType(G.convertToInstance(n.classType))
        }), r.d.name);
      }
      _isMethodExemptFromLsp(e) {
        return ['__init__', '__new__', '__init_subclass__', '__post_init__'].some(t => t === e);
      }
      _validateOverrideDecoratorNotPresent(e, t) {
        let n;
        if (q.isFunction(t)) {
          n = t;
        } else {
          if (q.isOverloaded(t)) {
            const e = q.OverloadedType.getImplementation(t);
            if (e && q.isFunction(e)) {
              n = e;
            }
          } else {
            if (q.isClassInstance(t) && q.ClassType.isPropertyClass(t) && t.priv.fgetInfo) {
              n = t.priv.fgetInfo.methodType;
            }
          }
        }
        if (!(n == null ? undefined : n.shared.declaration) || !q.FunctionType.isOverridden(n)) {
          return;
        }
        if (!e.getDeclarations().some(e => e === n.shared.declaration)) {
          return;
        }
        const a = n.shared.declaration.node;
        this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.overriddenMethodNotFound().format({
          name: a.d.name.d.value
        }), a.d.name);
      }
      _validateBaseClassOverride(e, t, n, a, r) {
        var s;
        var i;
        var o;
        var l;
        var c;
        var u;
        var m;
        var y;
        var h;
        var f;
        var T;
        var v;
        if (!q.isInstantiableClass(e.classType)) {
          return;
        }
        if (e.symbol.isIgnoredForOverrideChecks() || t.isIgnoredForOverrideChecks()) {
          return;
        }
        if (!e.symbol.hasTypedDeclarations()) {
          return;
        }
        if (r === '_') {
          return;
        }
        const b = e.classType;
        const _ = q.ClassType.cloneAsInstance(G.selfSpecializeClass(a, {
          useBoundTypeVars: true
        }));
        const C = G.partiallySpecializeType(this._evaluator.getEffectiveTypeOfSymbol(e.symbol), b, this._evaluator.getTypeClassType(), _);
        n = G.partiallySpecializeType(n, a, this._evaluator.getTypeClassType(), _);
        if (a.shared.typeVarScopeId) {
          n = G.makeTypeVarsBound(n, [a.shared.typeVarScopeId]);
        }
        if (q.isFunction(C) || q.isOverloaded(C)) {
          const o = new p.DiagnosticAddendum();
          let l = false;
          if (!U.isPrivateName(r)) {
            if (q.isFunction(C) && q.FunctionType.isFinal(C)) {
              l = true;
            } else {
              if (q.isOverloaded(C)) {
                const e = q.OverloadedType.getOverloads(C);
                const t = q.OverloadedType.getImplementation(C);
                if (e.some(e => q.FunctionType.isFinal(e))) {
                  l = true;
                }
                if (t && q.isFunction(t) && q.FunctionType.isFinal(t)) {
                  l = true;
                }
              }
            }
          }
          if (l) {
            const n = V.getLastTypedDeclarationForSymbol(t);
            if (n && n.type === 5) {
              const t = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.finalMethodOverride().format({
                name: r,
                className: b.shared.name
              }), n.node.d.name);
              const a = V.getLastTypedDeclarationForSymbol(e.symbol);
              if (t && a) {
                t.addRelatedInfo(g.LocAddendum.finalMethod(), a.uri, a.range);
              }
            }
          }
          if (q.isFunction(n) || q.isOverloaded(n)) {
            const i = !U.isDunderName(r);
            if (!this._isMethodExemptFromLsp(r) && !U.isPrivateName(r) && !q.ClassType.isTypedDictClass(a) && !this._evaluator.validateOverrideMethod(C, n, a, o, i)) {
              const n = V.getLastTypedDeclarationForSymbol(t);
              if (n) {
                const t = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.incompatibleMethodOverride().format({
                  name: r,
                  className: b.shared.name
                }) + o.getString(), (s = I.getNameNodeForDeclaration(n)) !== null && s !== undefined ? s : n.node);
                const a = V.getLastTypedDeclarationForSymbol(e.symbol);
                if (t && a) {
                  t.addRelatedInfo(g.LocAddendum.overriddenMethod(), a.uri, a.range);
                }
              }
            }
          } else {
            if (!q.isAnyOrUnknown(n) && !q.ClassType.isBuiltIn(b, '_TypedDict')) {
              const a = t.getDeclarations();
              if (a.length > 0) {
                const t = a[a.length - 1];
                const s = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.methodOverridden().format({
                  name: r,
                  className: b.shared.name,
                  type: this._evaluator.printType(n)
                }), (i = I.getNameNodeForDeclaration(t)) !== null && i !== undefined ? i : t.node);
                const o = V.getLastTypedDeclarationForSymbol(e.symbol);
                if (s && o) {
                  s.addRelatedInfo(g.LocAddendum.overriddenMethod(), o.uri, o.range);
                }
              }
            }
          }
        } else {
          if (G.isProperty(C)) {
            if (G.isProperty(n)) {
              this._validatePropertyOverride(b, a, C, n, t, r);
            } else {
              const e = t.getDeclarations();
              if (e.length > 0 && t.isClassMember()) {
                const t = e[e.length - 1];
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.propertyOverridden().format({
                  name: r,
                  className: b.shared.name
                }), (o = I.getNameNodeForDeclaration(t)) !== null && o !== undefined ? o : t.node);
              }
            }
          } else {
            if (this._fileInfo.diagnosticRuleSet.reportIncompatibleVariableOverride !== 'none') {
              const s = t.getDeclarations();
              if (s.length > 0) {
                const i = s[s.length - 1];
                const o = s[0];
                let _;
                let k;
                let w = (o == null ? undefined : o.type) === 1 && !o.isFinal;
                if (q.ClassType.isDataClassFrozen(b) && b.shared.dataClassEntries) {
                  if (b.shared.dataClassEntries.find(e => e.name === r)) {
                    w = false;
                  }
                }
                if (!t.isIgnoredForProtocolMatch()) {
                  if (b.shared.typedDictEntries) {
                    _ = (c = (l = b.shared.typedDictEntries.knownItems.get(r)) !== null && l !== undefined ? l : b.shared.typedDictEntries.extraItems) !== null && c !== undefined ? c : R.getEffectiveExtraItemsEntryType(this._evaluator, b);
                    if (_ == null ? undefined : _.isReadOnly) {
                      w = false;
                    }
                  }
                  if (a.shared.typedDictEntries) {
                    k = (m = (u = a.shared.typedDictEntries.knownItems.get(r)) !== null && u !== undefined ? u : a.shared.typedDictEntries.extraItems) !== null && m !== undefined ? m : R.getEffectiveExtraItemsEntryType(this._evaluator, a);
                  }
                }
                let S = new p.DiagnosticAddendum();
                if (this._evaluator.assignType(C, n, S, undefined, w ? 1 : 0)) {
                  if (_ && k) {
                    let e = true;
                    e = _.isReadOnly ? k.isRequired || !_.isRequired : k.isRequired === _.isRequired;
                    if (!e) {
                      const e = k.isRequired ? g.LocMessage.typedDictFieldRequiredRedefinition : g.LocMessage.typedDictFieldNotRequiredRedefinition;
                      this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, e().format({
                        name: r
                      }), (h = I.getNameNodeForDeclaration(i)) !== null && h !== undefined ? h : i.node);
                    }
                    if (!_.isReadOnly && k.isReadOnly) {
                      this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictFieldReadOnlyRedefinition().format({
                        name: r
                      }), (f = I.getNameNodeForDeclaration(i)) !== null && f !== undefined ? f : i.node);
                    }
                  }
                } else {
                  if (w) {
                    S = new p.DiagnosticAddendum();
                    S.addMessage(g.LocAddendum.overrideIsInvariant());
                    S.createAddendum().addMessage(g.LocAddendum.overrideInvariantMismatch().format({
                      overrideType: this._evaluator.printType(n),
                      baseType: this._evaluator.printType(C)
                    }));
                  }
                  const t = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.symbolOverridden().format({
                    name: r,
                    className: b.shared.name
                  }) + S.getString(), (y = I.getNameNodeForDeclaration(i)) !== null && y !== undefined ? y : i.node);
                  const a = V.getLastTypedDeclarationForSymbol(e.symbol);
                  if (t && a) {
                    t.addRelatedInfo(g.LocAddendum.overriddenSymbol(), a.uri, a.range);
                  }
                }
                const A = this._evaluator.isFinalVariable(e.symbol);
                const x = s.find(e => this._evaluator.isFinalVariableDeclaration(e));
                if (!A && x) {
                  const e = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.variableFinalOverride().format({
                    name: r,
                    className: b.shared.name
                  }), (T = I.getNameNodeForDeclaration(i)) !== null && T !== undefined ? T : i.node);
                  if (e) {
                    e.addRelatedInfo(g.LocAddendum.overriddenSymbol(), x.uri, x.range);
                  }
                }
                const P = e.symbol.isClassVar();
                let D = t.isClassVar();
                if (P && !D) {
                  if (!t.hasTypedDeclarations()) {
                    D = true;
                  }
                  if (t.getTypedDeclarations().every(e => e.type === 6)) {
                    D = true;
                  }
                }
                const N = q.ClassType.isTypedDictClass(a) && !D;
                if (P !== D && !N) {
                  const n = t.isClassVar() ? g.LocMessage.classVarOverridesInstanceVar() : g.LocMessage.instanceVarOverridesClassVar();
                  const a = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, n.format({
                    name: r,
                    className: b.shared.name
                  }), (v = I.getNameNodeForDeclaration(i)) !== null && v !== undefined ? v : i.node);
                  const s = V.getLastTypedDeclarationForSymbol(e.symbol);
                  if (a && s) {
                    a.addRelatedInfo(g.LocAddendum.overriddenSymbol(), s.uri, s.range);
                  }
                }
              }
            }
          }
        }
      }
      _validatePropertyOverride(e, t, n, a, r, s) {
        [['fget', e => {
          var t;
          if ((t = e.priv.fgetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }], ['fset', e => {
          var t;
          if ((t = e.priv.fsetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }], ['fdel', e => {
          var t;
          if ((t = e.priv.fdelInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }]].forEach(i => {
          var o;
          var l;
          const c = new p.DiagnosticAddendum();
          const [u, m] = i;
          const y = m(n);
          const h = m(a);
          if (y) {
            const n = G.partiallySpecializeType(y, e, this._evaluator.getTypeClassType());
            if (!q.isFunction(n)) {
              return;
            }
            if (!h) {
              c.addMessage(g.LocAddendum.propertyMethodMissing().format({
                name: u
              }));
              const t = r.getDeclarations();
              if (t.length > 0) {
                const a = t[t.length - 1];
                const r = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.propertyOverridden().format({
                  name: s,
                  className: e.shared.name
                }) + c.getString(), (o = I.getNameNodeForDeclaration(a)) !== null && o !== undefined ? o : a.node);
                const i = n.shared.declaration;
                if (r && i) {
                  r.addRelatedInfo(g.LocAddendum.overriddenMethod(), i.uri, i.range);
                }
              }
              return;
            }
            const a = G.partiallySpecializeType(h, t, this._evaluator.getTypeClassType());
            if (!q.isFunction(a)) {
              return;
            }
            if (this._evaluator.validateOverrideMethod(n, a, t, c.createAddendum())) {
              return;
            }
            c.addMessage(g.LocAddendum.propertyMethodIncompatible().format({
              name: u
            }));
            const i = a.shared.declaration;
            if (!i || i.type !== 5) {
              return;
            }
            let p = i.node.d.name;
            const m = t.shared.declaration;
            if (!m || m.node.nodeType !== 10 || !P.isNodeContainedWithin(i.node, m.node.d.suite)) {
              const e = r.getDeclarations();
              if (e.length === 0) {
                return;
              }
              const t = e[e.length - 1];
              p = (l = I.getNameNodeForDeclaration(t)) !== null && l !== undefined ? l : t.node;
            }
            const f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.propertyOverridden().format({
              name: s,
              className: e.shared.name
            }) + c.getString(), p);
            const T = n.shared.declaration;
            if (f && T) {
              f.addRelatedInfo(g.LocAddendum.overriddenMethod(), T.uri, T.range);
            }
          }
        });
      }
      _validateMethod(e, t, n) {
        const a = this._evaluator.getTypeOfClass(n);
        if (!a) {
          return;
        }
        const r = a.classType;
        const s = e.d.name.d.value;
        const i = G.isInstantiableMetaclass(r);
        if (['__init__', '__init_subclass__', '__enter__', '__exit__'].includes(s)) {
          if (!q.FunctionType.isAbstractMethod(t) && !q.FunctionType.isOverloaded(t) && !this._fileInfo.isStubFile) {
            this._validateSuperCallForMethod(e, t, r);
          }
        }
        const o = ['self', '_self', '__self'];
        const l = ['cls', '_cls', '__cls'];
        const p = ['__mcls', 'mcls', 'mcs', 'metacls'];
        if (s === '_generate_next_value_') {
          return;
        }
        if (s === '__new__') {
          if (e.d.params.length !== 0 && e.d.params[0].d.name) {
            const t = e.d.params[0].d.name.d.value;
            if (!l.includes(t) && (!i || !p.includes(t))) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportSelfClsParameterName, g.LocMessage.newClsParam(), e.d.params[0]);
            }
          } else {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportSelfClsParameterName, g.LocMessage.newClsParam(), e.d.name);
          }
          this._validateClsSelfParamType(e, t, r, true);
          return;
        }
        if (q.FunctionType.isStaticMethod(t)) {
          if (e.d.params.length === 0 || !e.d.params[0].d.name) {
            return;
          }
          const t = e.d.params[0].d.name.d.value;
          if (t === 'self' || t === 'cls') {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportSelfClsParameterName, g.LocMessage.staticClsSelfParam(), e.d.params[0].d.name);
          }
          return;
        }
        if (q.FunctionType.isClassMethod(t)) {
          let n = '';
          if (e.d.params.length > 0 && e.d.params[0].d.name) {
            n = e.d.params[0].d.name.d.value;
          }
          if (!l.includes(n) && (!i || !p.includes(n))) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportSelfClsParameterName, g.LocMessage.classMethodClsParam(), e.d.params.length > 0 ? e.d.params[0] : e.d.name);
          }
          this._validateClsSelfParamType(e, t, r, true);
          return;
        }
        const c = e.d.decorators.length > 0;
        if (q.FunctionType.isOverloaded(t) || !c) {
          let t = '';
          let n = true;
          if (e.d.params.length > 0) {
            if (e.d.params[0].d.name) {
              t = e.d.params[0].d.name.d.value;
            }
            if (e.d.params[0].d.category !== 0) {
              n = false;
            }
          }
          if (n && !o.includes(t)) {
            const n = i && l.includes(t);
            const a = U.isPrivateOrProtectedName(t);
            if (!n && !a) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportSelfClsParameterName, g.LocMessage.instanceMethodSelfParam(), e.d.params.length > 0 ? e.d.params[0] : e.d.name);
            }
          }
        }
        this._validateClsSelfParamType(e, t, r, false);
      }
      _validateSuperCallForMethod(e, t, n) {
        if (this._fileInfo.diagnosticRuleSet.reportMissingSuperCall === 'none') {
          return;
        }
        let a = 17;
        if (q.ClassType.isFinal(n)) {
          a |= 4;
        }
        if (!G.lookUpClassMember(n, t.shared.name, a)) {
          return;
        }
        let r = false;
        const s = new P.CallNodeWalker(e => {
          if (e.d.leftExpr.nodeType === 35 && e.d.leftExpr.d.member.d.value === t.shared.name) {
            const t = e.d.leftExpr.d.leftExpr;
            if (t.nodeType === 9 && t.d.leftExpr.nodeType === 38 && t.d.leftExpr.d.value === 'super') {
              r = true;
            } else {
              const e = this._evaluator.getType(t);
              if (e && q.isInstantiableClass(e)) {
                r = true;
              }
            }
          }
        });
        s.walk(e.d.suite);
        if (!r) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportMissingSuperCall, g.LocMessage.missingSuperCall().format({
            methodName: t.shared.name
          }), e.d.name);
        }
      }
      _validateClsSelfParamType(e, t, n, a) {
        var r;
        if (e.d.params.length < 1 || t.shared.parameters.length < 1) {
          return;
        }
        const s = t.shared.parameters[0];
        const i = q.FunctionType.getParamType(t, 0);
        const o = (r = e.d.params[0].d.annotation) !== null && r !== undefined ? r : e.d.params[0].d.annotationComment;
        if (!o || !s.name) {
          return;
        }
        if (t.shared.name === '__init__' && t.shared.methodClass) {
          if (G.getTypeVarArgsRecursive(i).some(e => {
            var n;
            return e.priv.scopeId === ((n = t.shared.methodClass) === null || n === undefined ? undefined : n.shared.typeVarScopeId) && !q.TypeVarType.isSelf(e);
          })) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeVarUse, g.LocMessage.initMethodSelfParamTypeVar(), o);
          }
        }
        if (q.ClassType.isProtocolClass(n)) {
          return;
        }
        const l = this._evaluator.makeTopLevelTypeVarsConcrete(i);
        const p = a ? n : G.convertToInstance(n);
        if ((!q.isInstantiableClass(l) || !q.ClassType.isProtocolClass(l)) && (!q.isClassInstance(l) || !q.ClassType.isProtocolClass(l)) && (s.category !== 1 || !q.isParamSpec(i) || i.priv.paramSpecAccess !== 'args') && !q.FunctionType.isOverloaded(t) && (!q.isClassInstance(i) || !q.ClassType.isBuiltIn(i, 'LiteralString') || !q.ClassType.isBuiltIn(n, 'str')) && !this._evaluator.assignType(i, p) && !q.isNever(i)) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.clsSelfParamTypeMismatch().format({
            name: s.name,
            classType: this._evaluator.printType(p)
          }), o);
        }
      }
      _validateYieldType(e, t, n, a) {
        var r;
        var s;
        var i;
        var o;
        const l = P.getEnclosingFunction(e);
        if (!l || !l.d.returnAnnotation) {
          return;
        }
        const c = this._evaluator.getTypeOfFunction(l);
        if (!c) {
          return;
        }
        let u = q.FunctionType.getEffectiveReturnType(c.functionType);
        if (!u) {
          return;
        }
        const m = P.getTypeVarScopesForNode(e);
        let y;
        u = G.makeTypeVarsBound(u, m);
        y = !l.d.isAsync && q.isClassInstance(u) && q.ClassType.isBuiltIn(u, 'AwaitableGenerator') ? this._evaluator.getTypingType(e, 'AwaitableGenerator') : this._evaluator.getTypingType(e, l.d.isAsync ? 'AsyncGenerator' : 'Generator');
        if (!y || !q.isInstantiableClass(y)) {
          return;
        }
        if (!this._evaluator.isNodeReachable(e, undefined)) {
          return;
        }
        if (q.isNever(u)) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.noReturnContainsYield(), e);
          return;
        }
        const h = [t, a ?? q.UnknownType.create(), q.UnknownType.create()];
        const f = q.ClassType.cloneAsInstance(q.ClassType.specialize(y, h));
        const T = new p.DiagnosticAddendum();
        if (!this._evaluator.assignType(u, f, T)) {
          const a = l.d.isAsync ? g.LocMessage.generatorAsyncReturnType() : g.LocMessage.generatorSyncReturnType();
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportReturnType, a.format({
            yieldType: this._evaluator.printType(t)
          }) + ((r = n == null ? undefined : n.getString()) !== null && r !== undefined ? r : T.getString()), (s = e.d.expr) !== null && s !== undefined ? s : e, (o = (i = n == null ? undefined : n.getEffectiveTextRange()) !== null && i !== undefined ? i : e.d.expr) !== null && o !== undefined ? o : e);
        }
      }
      _reportUnusedExceptStatements(e) {
        let t = false;
        const n = [];
        e.d.exceptClauses.forEach(e => {
          var a;
          var r;
          if (t || e.d.isExceptGroup || !e.d.typeExpr) {
            return;
          }
          const s = this._evaluator.getType(e.d.typeExpr);
          if (!s || q.isAnyOrUnknown(s)) {
            t = true;
            return;
          }
          const i = [];
          if (q.isInstantiableClass(s)) {
            if (s.priv.includeSubclasses) {
              t = true;
            }
            i.push(s);
          } else {
            if (q.isClassInstance(s)) {
              const n = (r = (a = this._evaluator.getTypeOfIterator({
                type: s
              }, false, e.d.typeExpr, false)) === null || a === undefined ? undefined : a.type) !== null && r !== undefined ? r : q.UnknownType.create();
              G.doForEachSubtype(n, e => {
                if (q.isAnyOrUnknown(e)) {
                  t = true;
                }
                if (q.isInstantiableClass(e)) {
                  if (e.priv.includeSubclasses) {
                    t = true;
                  }
                  i.push(e);
                }
              });
            } else {
              t = true;
            }
          }
          if (n.length > 0 && !t) {
            const t = new p.DiagnosticAddendum();
            let a = 0;
            i.forEach(e => {
              const r = n.find(t => G.derivesFromClassRecursive(e, t, true));
              if (r) {
                t.addMessage(g.LocAddendum.unreachableExcept().format({
                  exceptionType: this._evaluator.printType(G.convertToInstance(e)),
                  parentType: this._evaluator.printType(G.convertToInstance(r))
                }));
                a++;
              }
            });
            if (i.length > 0 && i.length === a) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnusedExcept, g.LocMessage.unreachableExcept() + t.getString(), e.d.typeExpr);
              this._evaluator.addUnreachableCode(e, B.Reachability.UnreachableByAnalysis, e.d.exceptSuite);
            }
          }
          o.appendArray(n, i);
        });
      }
      _reportDuplicateImports() {
        const e = A.getTopLevelImports(this._moduleNode);
        const t = new Map();
        e.orderedImports.forEach(e => {
          if (e.node.nodeType === 25) {
            const t = new Map();
            e.node.d.imports.forEach(e => {
              if (!e.d.alias) {
                if (t.get(e.d.name.d.value)) {
                  this._evaluator.addDiagnostic(d.DiagnosticRule.reportDuplicateImport, g.LocMessage.duplicateImport().format({
                    importName: e.d.name.d.value
                  }), e.d.name);
                } else {
                  t.set(e.d.name.d.value, e);
                }
              }
            });
          } else {
            if (e.subnode && !e.subnode.d.alias) {
              if (t.get(e.moduleName)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportDuplicateImport, g.LocMessage.duplicateImport().format({
                  importName: e.moduleName
                }), e.subnode);
              } else {
                t.set(e.moduleName, e.subnode);
              }
            }
          }
        });
      }
    }
    exports.Checker = W;
  },
  1693: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CircularDependency = undefined;
    exports.CircularDependency = class {
      constructor() {
        this._paths = [];
      }
      appendPath(e) {
        this._paths.push(e);
      }
      getPaths() {
        return this._paths;
      }
      normalizeOrder() {
        let e = 0;
        this._paths.forEach((t, n) => {
          if (t < this._paths[e]) {
            e = n;
          }
        });
        if (e !== 0) {
          this._paths = this._paths.slice(e).concat(this._paths.slice(0, e));
        }
      }
      isEqual(e) {
        if (e._paths.length !== this._paths.length) {
          return false;
        }
        for (let t = 0; t < this._paths.length; t++) {
          if (this._paths[t] !== e._paths[t]) {
            return false;
          }
        }
        return true;
      }
    };
  },
  19914: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FlowNodeTypeResult = undefined;
    exports.isIncompleteType = f;
    exports.getCodeFlowEngine = function (e, t) {
      const n = new Set();
      const I = new Map();
      const k = new Map();
      const w = new Map();
      let S = 1;
      let A = 0;
      let x = 0;
      let P = false;
      function D(t, r, s = false) {
        const o = new Set();
        const l = new Set();
        function p(e) {
          if (l.size > 0) {
            return e;
          }
          let n = I.get(t.id);
          if (!n) {
            n = {
              reachability: undefined,
              reachabilityFrom: new Map()
            };
            I.set(t.id, n);
          }
          if (r) {
            n.reachabilityFrom.set(r.id, e);
          } else {
            n.reachability = e;
          }
          return e;
        }
        if (T) {
          z(t, undefined, 'getFlowNodeReachability');
        }
        if (n.has(t.id)) {
          return u.Reachability.UnreachableByAnalysis;
        }
        n.add(t.id);
        try {
          return function t(n, d = 0) {
            var c;
            if (d > 64) {
              return u.Reachability.Reachable;
            }
            d++;
            let g = n;
            while (true) {
              const h = I.get(n.id);
              if (h !== undefined && l.size === 0) {
                if (r) {
                  const e = h.reachabilityFrom.get(r.id);
                  if (e !== undefined) {
                    return e;
                  }
                } else {
                  if (h.reachability !== undefined) {
                    return h.reachability;
                  }
                }
              }
              if (o.has(g.id)) {
                return p(u.Reachability.UnreachableAlways);
              }
              o.add(g.id);
              if (g.flags & i.FlowFlags.Unreachable) {
                return p(u.Reachability.UnreachableAlways);
              }
              if (g === r) {
                return p(u.Reachability.Reachable);
              }
              if (g.flags & (i.FlowFlags.VariableAnnotation | i.FlowFlags.Assignment | i.FlowFlags.WildcardImport | i.FlowFlags.ExhaustedMatch)) {
                g = g.antecedent;
              } else {
                if (g.flags & i.FlowFlags.NarrowForPattern) {
                  const t = g;
                  const n = e.evaluateTypeForSubnode(t.statement, () => {
                    if (t.statement.nodeType === 64) {
                      e.evaluateTypesForCaseStatement(t.statement);
                    } else {
                      e.evaluateTypesForMatchStatement(t.statement);
                    }
                  });
                  if (n && y.isNever(n.type)) {
                    return p(u.Reachability.UnreachableByAnalysis);
                  }
                  g = t.antecedent;
                } else {
                  if (g.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.FalseCondition | i.FlowFlags.TrueNeverCondition | i.FlowFlags.FalseNeverCondition)) {
                    const t = g;
                    if (t.reference) {
                      const n = e.lookUpSymbolRecursive(t.reference, t.reference.d.value, false);
                      if (n && n.symbol.hasTypedDeclarations()) {
                        let n = false;
                        const a = m.getTypeNarrowingCallback(e, t.reference, t.expression, !!(t.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.TrueNeverCondition)));
                        if (a) {
                          const r = e.getTypeOfExpression(t.reference);
                          const s = a(r.type);
                          const i = (c = s == null ? undefined : s.type) !== null && c !== undefined ? c : r.type;
                          if (y.isNever(i) && !r.isIncomplete) {
                            n = true;
                          }
                        }
                        if (n) {
                          return p(u.Reachability.UnreachableByAnalysis);
                        }
                      }
                    }
                    g = t.antecedent;
                  } else {
                    if (g.flags & i.FlowFlags.Call) {
                      const t = g;
                      if (!s && F(e, t)) {
                        return p(u.Reachability.UnreachableByAnalysis);
                      }
                      g = t.antecedent;
                    } else {
                      if (g.flags & (i.FlowFlags.BranchLabel | i.FlowFlags.LoopLabel)) {
                        if (g.flags & i.FlowFlags.PostContextManager) {
                          const t = g;
                          if (!t.expressions.some(n => M(e, n, t.isAsync))) {
                            return p(u.Reachability.UnreachableByAnalysis);
                          }
                        }
                        const n = g;
                        let a = false;
                        for (const e of n.antecedents) {
                          const n = t(e, d);
                          if (n === u.Reachability.Reachable) {
                            return p(n);
                          }
                          if (n === u.Reachability.UnreachableByAnalysis) {
                            a = true;
                          }
                        }
                        return p(a ? u.Reachability.UnreachableByAnalysis : u.Reachability.UnreachableAlways);
                      }
                      if (g.flags & i.FlowFlags.Start) {
                        return p(r ? u.Reachability.UnreachableByAnalysis : u.Reachability.Reachable);
                      }
                      if (!(g.flags & i.FlowFlags.PreFinallyGate)) {
                        if (g.flags & i.FlowFlags.PostFinally) {
                          const e = g;
                          const n = l.has(e.preFinallyGate.id);
                          try {
                            l.add(e.preFinallyGate.id);
                            return p(t(e.antecedent, d));
                          } finally {
                            if (!n) {
                              l.delete(e.preFinallyGate.id);
                            }
                          }
                        }
                        a.fail('Unexpected flow node flags');
                        return p(u.Reachability.Reachable);
                      }
                      {
                        const e = g;
                        if (l.has(e.id)) {
                          return p(u.Reachability.UnreachableByAnalysis);
                        }
                        g = e.antecedent;
                      }
                    }
                  }
                }
              }
            }
          }(t);
        } finally {
          n.delete(t.id);
        }
      }
      function N(e, t) {
        let n = true;
        g.doForEachSubtype(e, e => {
          if (y.isTypeVar(e)) {
            if (!y.isTypeSame(e, t)) {
              n = false;
            }
          } else {
            if (!e.props?.condition || !e.props.condition.some(e => y.TypeVarType.hasConstraints(e.typeVar) && e.typeVar.priv.nameWithScope === t.priv.nameWithScope)) {
              n = false;
            }
          }
        });
        return n;
      }
      function F(e, t) {
        const n = t.node;
        if (s.getFileInfo(n).isStubFile) {
          return false;
        }
        if (v) {
          console.log(`isCallNoReturn@${t.id} Pre depth ${A}`);
        }
        if (k.has(n.id)) {
          const e = k.get(n.id);
          if (v) {
            console.log(`isCallNoReturn@${t.id} Post: ${e ? 'true' : 'false'} (cached)`);
          }
          return e;
        }
        if (A > y.maxTypeRecursionCount) {
          return false;
        }
        if (n.d.leftExpr.nodeType === 33) {
          return false;
        }
        k.set(n.id, false);
        A++;
        try {
          let a = 0;
          let r = 0;
          const s = e.getTypeOfExpression(n.d.leftExpr, 2);
          const i = s.type;
          g.doForEachSubtype(i, t => {
            r++;
            if (y.isInstantiableClass(t)) {
              if (l.getBoundCallMethod(e, n, t)) {
                return;
              }
              const a = l.getBoundNewMethod(e, n, t);
              if (a && (y.isFunction(a.type) || y.isOverloaded(a.type))) {
                t = a.type;
              }
            } else {
              if (y.isClassInstance(t)) {
                const n = e.getBoundMagicMethod(t, '__call__');
                if (n) {
                  t = n;
                }
              }
            }
            const o = n.parent?.nodeType === 6;
            if (y.isFunction(t)) {
              if (E(t, o)) {
                a++;
              }
            } else {
              if (y.isOverloaded(t)) {
                let r = 0;
                let i = 0;
                y.OverloadedType.getOverloads(t).forEach(e => {
                  r++;
                  if (E(e, o)) {
                    i++;
                  }
                });
                if (i > 0) {
                  if (i === r) {
                    a++;
                  } else {
                    const r = e.validateOverloadedArgTypes(n, n.d.args.map(t => e.convertNodeToArg(t)), {
                      type: t,
                      isIncomplete: s.isIncomplete
                    }, undefined, false, undefined);
                    if (r.returnType && y.isNever(r.returnType)) {
                      a++;
                    }
                  }
                }
              }
            }
          });
          const o = r > 0 && a === r;
          k.set(n.id, o);
          if (v) {
            console.log(`isCallNoReturn@${t.id} Post: ${o ? 'true' : 'false'}`);
          }
          return o;
        } finally {
          A--;
        }
      }
      function E(t, n) {
        const a = y.FunctionType.getEffectiveReturnType(t, false);
        if (a) {
          return !!y.isClassInstance(a) && !!y.ClassType.isBuiltIn(a, 'Coroutine') && !!a.priv.typeArgs && !!(a.priv.typeArgs.length >= 3) && !!y.isNever(a.priv.typeArgs[2]) && !!n || y.isNever(a);
        }
        if (!b) {
          return false;
        }
        if (t.shared.declaration && !t.shared.declaration.isGenerator && !y.FunctionType.isAbstractMethod(t) && !y.FunctionType.isStubDefinition(t) && !y.FunctionType.isPyTypedDefinition(t)) {
          const n = t.shared.declaration.node.d.suite.d.statements;
          let a = false;
          for (const t of n) {
            if (t.nodeType !== 47 || t.d.statements.length !== 1) {
              break;
            }
            const n = t.d.statements[0];
            if (n.nodeType !== 48) {
              if (n.nodeType === 43 && n.d.expr) {
                const t = e.getType(n.d.expr);
                if (t && y.isClass(t) && g.derivesFromStdlibClass(t, 'NotImplementedError')) {
                  a = true;
                }
              }
              break;
            }
          }
          if (!a && !function (e, t) {
            if (!t.shared.declaration) {
              return true;
            }
            return e.isAfterNodeReachable(t.shared.declaration.node);
          }(e, t)) {
            return true;
          }
        }
        return false;
      }
      function M(e, t, n) {
        if (w.has(t.id)) {
          return w.get(t.id);
        }
        w.set(t.id, false);
        if (x > y.maxTypeRecursionCount) {
          return false;
        }
        x++;
        let a = false;
        try {
          const r = e.getTypeOfExpression(t).type;
          if (r && y.isClassInstance(r)) {
            const t = n ? '__aexit__' : '__exit__';
            const s = e.getBoundMagicMethod(r, t);
            if (s && y.isFunction(s) && s.shared.declaredReturnType) {
              let e = s.shared.declaredReturnType;
              if (n && y.isClassInstance(e) && y.ClassType.isBuiltIn(e, 'Coroutine') && e.priv.typeArgs && e.priv.typeArgs.length >= 3) {
                e = e.priv.typeArgs[2];
              }
              a = false;
              if (y.isClassInstance(e) && y.ClassType.isBuiltIn(e, 'bool')) {
                if (e.priv.literalValue === undefined || e.priv.literalValue === true) {
                  a = true;
                }
              }
            }
          }
        } finally {
          x--;
        }
        w.set(t.id, a);
        return a;
      }
      function O(t, n) {
        const r = s.getImportInfo(t.node.d.module);
        a.assert(r !== undefined && r.isImportFound);
        a.assert(t.node.d.isWildcardImport);
        const i = e.lookUpSymbolRecursive(t.node, n, false);
        a.assert(i !== undefined);
        const o = i.symbol.getDeclarations().find(e => e.node === t.node);
        return o && e.getInferredTypeOfDeclaration(i.symbol, o) || y.UnknownType.create();
      }
      function z(e, t, n, a = console) {
        let i = '';
        if (t) {
          const e = s.getFileInfo(t);
          const n = r.convertOffsetToPosition(t.start, e.lines);
          i = `${p.printExpression(t)}[${n.line + 1}:${n.character + 1}]`;
        }
        a.log(`${n}@${e.id}: ${i || '(none)'}`);
        a.log(o.formatControlFlowGraph(e));
      }
      return {
        createCodeFlowAnalyzer: function () {
          const n = new Map();
          function r(e) {
            if (!e) {
              return false;
            }
            for (const [t, a] of n.entries()) {
              if (t !== e && a.pendingNodes.size > 0) {
                return true;
              }
            }
            return false;
          }
          return {
            getTypeFromCodeFlow: function (s, o, l) {
              var v;
              var b;
              if (T) {
                z(s, o, 'getTypeFromCodeFlow');
              }
              const I = o !== undefined ? i.createKeyForReference(o) : undefined;
              let k;
              const w = I !== undefined && (l == null ? undefined : l.targetSymbolId) !== undefined ? `${I}.${l == null ? undefined : l.targetSymbolId.toString()}` : '.';
              const A = function (e) {
                let t = n.get(e);
                if (!t) {
                  t = {
                    cache: new Map(),
                    pendingNodes: new Set(),
                    closedFinallyGateNodes: new Set()
                  };
                  n.set(e, t);
                }
                return t;
              }(w);
              function x(e, n, a) {
                if (a) {
                  if (n) {
                    const t = A.cache.get(e.id);
                    if (t) {
                      const e = t;
                      if (e.isIncompleteType && e.type && !y.isTypeSame(e.type, n)) {
                        S++;
                      }
                    }
                  }
                } else {
                  S++;
                }
                const r = a ? {
                  isIncompleteType: true,
                  type: n,
                  incompleteSubtypes: [],
                  generationCount: S
                } : n;
                A.cache.set(e.id, r);
                t.trackEntry(A.cache, e.id);
                return h.create(n, a, S, a ? [] : undefined);
              }
              function N(e, t, n, r, s, i) {
                const o = A.cache.get(e.id);
                if (o === undefined || !f(o)) {
                  a.fail(`setIncompleteSubtype can be called only on a valid incomplete cache entry: prev cache entry?: ${!o} index=${t} isPending=${s} evaluationCount=${i}`);
                }
                const l = o.incompleteSubtypes;
                if (t < l.length) {
                  const e = l[t];
                  if (e.isIncomplete === r && y.isTypeSame(e.type, n)) {
                    if (e.isPending !== s) {
                      l[t] = {
                        type: n,
                        isIncomplete: r,
                        isPending: s,
                        evaluationCount: i
                      };
                    }
                  } else {
                    l[t] = {
                      type: n,
                      isIncomplete: r,
                      isPending: s,
                      evaluationCount: i
                    };
                    S++;
                  }
                } else {
                  a.assert(l.length === t);
                  l.push({
                    type: n,
                    isIncomplete: r,
                    isPending: s,
                    evaluationCount: i
                  });
                  S++;
                }
                let p;
                if (o.incompleteSubtypes.length > 0) {
                  const e = [];
                  o.incompleteSubtypes.forEach(t => {
                    if (t.type) {
                      e.push(t.type);
                    }
                  });
                  p = e.length > 0 ? y.combineTypes(e) : undefined;
                }
                o.type = p;
                o.generationCount = S;
                return E(e);
              }
              function E(e) {
                if (!A.cache.has(e.id)) {
                  return;
                }
                const t = A.cache.get(e.id);
                if (t === undefined) {
                  return h.create(undefined, false);
                } else {
                  if (f(t)) {
                    return h.create(t.type, true, t.generationCount, t.incompleteSubtypes);
                  } else {
                    return h.create(t, false);
                  }
                }
              }
              function U(e) {
                var t;
                if (!e.type) {
                  return;
                }
                if (!e.incompleteSubtypes || e.incompleteSubtypes.length === 0) {
                  return g.cleanIncompleteUnknown(e.type);
                }
                const n = [];
                if ((t = e.incompleteSubtypes) !== null && t !== undefined) {
                  t.forEach(e => {
                    if (e.type && !g.isIncompleteUnknown(e.type)) {
                      n.push(g.cleanIncompleteUnknown(e.type));
                    }
                  });
                }
                return y.combineTypes(n);
              }
              function V(t) {
                let n = t.node;
                const a = t.node.parent;
                if (a) {
                  if (a.nodeType === 31 || a.nodeType === 10) {
                    n = a;
                  }
                }
                return e.evaluateTypeForSubnode(n, () => {
                  e.evaluateTypesForStatement(t.node);
                });
              }
              function R(e, t) {
                A.pendingNodes.add(e.id);
                try {
                  const n = t();
                  A.pendingNodes.delete(e.id);
                  return n;
                } catch (t) {
                  A.pendingNodes.delete(e.id);
                  throw t;
                }
              }
              function L(t) {
                var n;
                var r;
                var s;
                var f;
                var T;
                var v;
                let b = t;
                for (e.checkForCancellation();;) {
                  const t = E(b);
                  if (t) {
                    if (!t.isIncomplete) {
                      return t;
                    }
                    if (t.generationCount === S) {
                      return h.create(U(t), true);
                    }
                  }
                  if (A.pendingNodes.has(b.id)) {
                    return h.create((n = t == null ? undefined : t.type) !== null && n !== undefined ? n : y.UnknownType.create(true), true);
                  }
                  if (b.flags & i.FlowFlags.Unreachable) {
                    return x(b, y.NeverType.createNever(), false);
                  }
                  if (b.flags & i.FlowFlags.VariableAnnotation) {
                    b = b.antecedent;
                  } else {
                    if (b.flags & i.FlowFlags.Call) {
                      const t = b;
                      if (F(e, t)) {
                        return x(b, undefined, false);
                      }
                      b = t.antecedent;
                    } else {
                      if (b.flags & i.FlowFlags.Assignment) {
                        const t = b;
                        const n = t.node;
                        if (o) {
                          if ((l == null ? undefined : l.targetSymbolId) === t.targetSymbolId && p.isMatchingExpression(o, n)) {
                            if (b.flags & i.FlowFlags.Unbind) {
                              if (o.nodeType === 27 || o.nodeType === 35) {
                                return x(b, undefined, false);
                              } else {
                                return x(b, y.UnboundType.create(), false);
                              }
                            }
                            let a = R(b, () => V(t));
                            if (a) {
                              if (g.isTypeAliasPlaceholder(a.type)) {
                                return h.create(a.type, true);
                              }
                              if (o.nodeType === 35 && e.isAsymmetricAccessorAssignment(n)) {
                                a = undefined;
                              }
                            }
                            return x(b, a == null ? undefined : a.type, !!(a == null ? undefined : a.isIncomplete));
                          }
                          if (n.nodeType === 27 && p.isMatchingExpression(o, n.d.leftExpr) && ((r = n.parent) === null || r === undefined ? undefined : r.nodeType) === 3 && n.d.items.length === 1 && !n.d.trailingComma && !n.d.items[0].d.name && n.d.items[0].d.argCategory === 0 && n.d.items[0].d.valueExpr.nodeType === 48 && n.d.items[0].d.valueExpr.d.strings.length === 1 && n.d.items[0].d.valueExpr.d.strings[0].nodeType === 49) {
                            const e = n.d.items[0].d.valueExpr.d.strings[0].d.value;
                            const a = R(t, () => {
                              const n = L(t.antecedent);
                              if (n.type) {
                                n.type = g.mapSubtypes(n.type, t => y.isClass(t) && y.ClassType.isTypedDictClass(t) ? c.narrowForKeyAssignment(t, e) : t);
                              }
                              return n;
                            });
                            return x(b, a == null ? undefined : a.type, !!(a == null ? undefined : a.isIncomplete));
                          }
                          if (p.isPartialMatchingExpression(o, n)) {
                            return h.create((s = l == null ? undefined : l.typeAtStart) === null || s === undefined ? undefined : s.type, !!((f = l == null ? undefined : l.typeAtStart) === null || f === undefined ? undefined : f.isIncomplete));
                          }
                        }
                        b = t.antecedent;
                      } else {
                        if (b.flags & i.FlowFlags.BranchLabel) {
                          const t = b;
                          if (b.flags & i.FlowFlags.PostContextManager) {
                            const t = b;
                            if (t.expressions.some(n => M(e, n, t.isAsync)) === t.blockIfSwallowsExceptions) {
                              return x(b, undefined, false);
                            }
                          }
                          if (o && t.preBranchAntecedent && t.affectedExpressions && (k ||= i.createKeysForReferenceSubexpressions(o), !k.some(e => t.affectedExpressions.has(e)) && D(b, t.preBranchAntecedent) === u.Reachability.Reachable)) {
                            b = t.preBranchAntecedent;
                            continue;
                          }
                          return B(b);
                        }
                        if (b.flags & i.FlowFlags.LoopLabel) {
                          const e = b;
                          if (o && (k ||= i.createKeysForReferenceSubexpressions(o), !k.some(t => e.affectedExpressions.has(t)))) {
                            b = e.antecedents[0];
                            continue;
                          }
                          return j(e, t);
                        }
                        if (b.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.FalseCondition)) {
                          const t = b;
                          if (!(l == null ? undefined : l.skipConditionalNarrowing) && o) {
                            const n = R(b, () => {
                              const n = m.getTypeNarrowingCallback(e, o, t.expression, !!(t.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.TrueNeverCondition)));
                              if (n) {
                                const e = L(t.antecedent);
                                let a = e.type;
                                let r = e.isIncomplete;
                                if (a) {
                                  const e = n(a);
                                  if (e) {
                                    a = e.type;
                                    if (e.isIncomplete) {
                                      r = true;
                                    }
                                  }
                                }
                                return x(b, a, r);
                              }
                            });
                            if (n) {
                              return n;
                            }
                          }
                          b = t.antecedent;
                        } else {
                          if (b.flags & (i.FlowFlags.TrueNeverCondition | i.FlowFlags.FalseNeverCondition)) {
                            const t = b;
                            if (!(l == null ? undefined : l.skipConditionalNarrowing) && t.reference && i.createKeyForReference(t.reference) !== I) {
                              const n = e.lookUpSymbolRecursive(t.reference, t.reference.d.value, false);
                              if (n && n.symbol.hasTypedDeclarations()) {
                                const n = R(b, () => {
                                  const n = m.getTypeNarrowingCallback(e, t.reference, t.expression, !!(t.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.TrueNeverCondition)));
                                  if (n) {
                                    const a = e.getTypeOfExpression(t.reference);
                                    let r = a.type;
                                    let s = !!a.isIncomplete;
                                    const i = n(a.type);
                                    if (i) {
                                      r = i.type;
                                      if (i.isIncomplete) {
                                        s = true;
                                      }
                                    }
                                    if (y.isNever(r)) {
                                      return x(b, undefined, s);
                                    }
                                  }
                                });
                                if (n) {
                                  return n;
                                }
                              }
                            }
                            b = t.antecedent;
                          } else {
                            if (b.flags & i.FlowFlags.ExhaustedMatch) {
                              const t = b;
                              const n = e.evaluateTypeForSubnode(t.node, () => {
                                e.evaluateTypesForMatchStatement(t.node);
                              });
                              if (n) {
                                if (y.isNever(n.type)) {
                                  return x(b, n.type, !!n.isIncomplete);
                                }
                                if (o) {
                                  const a = d.getPatternSubtypeNarrowingCallback(e, o, t.subjectExpression);
                                  if (a) {
                                    const e = a(n.type);
                                    if (e) {
                                      return x(b, e.type, !!n.isIncomplete || !!e.isIncomplete);
                                    }
                                  }
                                }
                              }
                              b = t.antecedent;
                            } else {
                              if (b.flags & i.FlowFlags.NarrowForPattern) {
                                const t = b;
                                if (!o || p.isMatchingExpression(o, t.subjectExpression)) {
                                  const n = e.evaluateTypeForSubnode(t.statement, () => {
                                    if (t.statement.nodeType === 64) {
                                      e.evaluateTypesForCaseStatement(t.statement);
                                    } else {
                                      e.evaluateTypesForMatchStatement(t.statement);
                                    }
                                  });
                                  if (n) {
                                    if (o) {
                                      return x(b, n.type, !!n.isIncomplete);
                                    }
                                    if (y.isNever(n.type)) {
                                      return x(b, undefined, !!n.isIncomplete);
                                    }
                                  }
                                } else {
                                  if (t.statement.nodeType === 64) {
                                    const n = t.statement;
                                    const a = d.getPatternSubtypeNarrowingCallback(e, o, t.subjectExpression);
                                    if (a) {
                                      const t = e.evaluateTypeForSubnode(n, () => {
                                        e.evaluateTypesForCaseStatement(n);
                                      });
                                      if (t) {
                                        const e = a(t.type);
                                        if (e) {
                                          return x(b, e.type, !!t.isIncomplete || !!e.isIncomplete);
                                        }
                                      }
                                    }
                                  }
                                }
                                b = t.antecedent;
                              } else {
                                if (b.flags & i.FlowFlags.PreFinallyGate) {
                                  return q(b);
                                }
                                if (b.flags & i.FlowFlags.PostFinally) {
                                  return G(b);
                                }
                                if (b.flags & i.FlowFlags.Start) {
                                  return x(b, (T = l == null ? undefined : l.typeAtStart) === null || T === undefined ? undefined : T.type, !!((v = l == null ? undefined : l.typeAtStart) === null || v === undefined ? undefined : v.isIncomplete));
                                }
                                if (b.flags & i.FlowFlags.WildcardImport) {
                                  const e = b;
                                  if (o && o.nodeType === 38) {
                                    const t = o.d.value;
                                    if (e.names.some(e => e === t)) {
                                      return R(b, () => {
                                        const n = O(e, t);
                                        return x(b, n, false);
                                      });
                                    }
                                  }
                                  b = e.antecedent;
                                } else {
                                  a.fail('Unexpected flow node flags');
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              function B(e) {
                const t = [];
                let n = false;
                for (const a of e.antecedents) {
                  const r = L(a);
                  if (o === undefined && r.type && !y.isNever(r.type)) {
                    return x(e, y.UnknownType.create(), false);
                  }
                  if (r.isIncomplete) {
                    n = true;
                  }
                  if (r.type) {
                    t.push(r.type);
                  }
                }
                return x(e, t.length > 0 ? y.combineTypes(t) : undefined, n);
              }
              function j(e, t) {
                var n;
                const a = e.antecedents.length;
                if (t === undefined) {
                  t = x(e, o ? undefined : y.UnknownType.create(), true);
                } else {
                  if (t.incompleteSubtypes && t.incompleteSubtypes.length === e.antecedents.length && t.incompleteSubtypes.some(e => e.isPending)) {
                    return h.create(U(t), true);
                  }
                }
                let s = 0;
                while (true) {
                  let i = false;
                  let l = false;
                  let p = o === undefined && ((n = t.incompleteSubtypes) === null || n === undefined ? undefined : n.some(e => e.type !== undefined));
                  let d = false;
                  let c = false;
                  e.antecedents.forEach((n, a) => {
                    var r;
                    var s;
                    if (o === undefined && p) {
                      return;
                    }
                    if (c && a > 0) {
                      return;
                    }
                    if ((t = E(e)).incompleteSubtypes && a < t.incompleteSubtypes.length && t.incompleteSubtypes[a].isPending) {
                      if (a !== 0) {
                        i = true;
                        l = true;
                        return;
                      }
                      c = true;
                    }
                    const u = t.incompleteSubtypes !== undefined && a < t.incompleteSubtypes.length ? t.incompleteSubtypes[a] : undefined;
                    if (u === undefined || !(u == null ? undefined : u.isPending) && (u == null ? undefined : u.isIncomplete)) {
                      const o = u === undefined ? 0 : u.evaluationCount;
                      if (o >= _) {
                        if (!P && C) {
                          console.log('Types failed to converge during code flow analysis');
                        }
                        P = true;
                        return;
                      }
                      t = N(e, a, (r = u == null ? undefined : u.type) !== null && r !== undefined ? r : y.UnknownType.create(true), true, true, o);
                      try {
                        const r = L(n);
                        if (r.isIncomplete) {
                          i = true;
                          if (a === 0) {
                            d = true;
                          }
                        }
                        t = N(e, a, (s = r.type) !== null && s !== undefined ? s : r.isIncomplete ? y.UnknownType.create(true) : y.NeverType.createNever(), r.isIncomplete, c, o + 1);
                      } catch (n) {
                        t = N(e, a, y.UnknownType.create(true), true, c, o + 1);
                        throw n;
                      }
                    }
                    if (o === undefined && (t == null ? undefined : t.type) !== undefined) {
                      p = true;
                    }
                  });
                  if (p) {
                    if (l) {
                      return h.create(y.UnknownType.create(), false);
                    } else {
                      return x(e, y.UnknownType.create(), false);
                    }
                  }
                  let u = t.type;
                  if (i && u) {
                    const e = g.cleanIncompleteUnknown(u);
                    if (e !== u) {
                      u = e;
                    }
                  }
                  if (!i || s >= a) {
                    let t = i;
                    if (!!i && !l && !r(w) && !!u && !g.isIncompleteUnknown(u) && !d) {
                      t = false;
                    }
                    if (l || i) {
                      if (!t) {
                        S++;
                      }
                      return h.create(u, t);
                    } else {
                      if (c) {
                        return h.create(u, true);
                      } else {
                        return x(e, u, false);
                      }
                    }
                  }
                  s++;
                }
              }
              function q(e) {
                if (A.closedFinallyGateNodes.has(e.id)) {
                  return h.create(undefined, false);
                }
                const t = L(e.antecedent);
                (function (e) {
                  A.cache.delete(e.id);
                })(e);
                return h.create(t.type, t.isIncomplete);
              }
              function G(t) {
                const n = A.closedFinallyGateNodes.has(t.preFinallyGate.id);
                try {
                  let n;
                  A.closedFinallyGateNodes.add(t.preFinallyGate.id);
                  e.useSpeculativeMode(t.finallyNode, () => {
                    n = L(t.antecedent);
                  });
                  if (n.isIncomplete) {
                    return n;
                  } else {
                    return x(t, n.type, false);
                  }
                } finally {
                  if (!n) {
                    A.closedFinallyGateNodes.delete(t.preFinallyGate.id);
                  }
                }
              }
              if (s) {
                return L(s);
              } else {
                return h.create((v = l == null ? undefined : l.typeAtStart) === null || v === undefined ? undefined : v.type, !!((b = l == null ? undefined : l.typeAtStart) === null || b === undefined ? undefined : b.isIncomplete));
              }
            }
          };
        },
        getFlowNodeReachability: D,
        narrowConstrainedTypeVar: function (t, n) {
          a.assert(!y.isParamSpec(n));
          a.assert(!y.isTypeVarTuple(n));
          a.assert(!y.TypeVarType.hasBound(n));
          a.assert(y.TypeVarType.hasConstraints(n));
          const r = new Set();
          const s = [];
          for (const e of n.shared.constraints) {
            if (!y.isClassInstance(e)) {
              return;
            }
            s.push(e);
          }
          const o = function t(n, o) {
            let l = n;
            while (true) {
              if (r.has(l.id)) {
                return s;
              }
              if (l.flags & (i.FlowFlags.Unreachable | i.FlowFlags.Start)) {
                return s;
              }
              if (l.flags & (i.FlowFlags.VariableAnnotation | i.FlowFlags.Assignment | i.FlowFlags.WildcardImport | i.FlowFlags.TrueNeverCondition | i.FlowFlags.FalseNeverCondition | i.FlowFlags.ExhaustedMatch | i.FlowFlags.PostFinally | i.FlowFlags.PreFinallyGate | i.FlowFlags.Call)) {
                l = l.antecedent;
              } else {
                if (l.flags & i.FlowFlags.NarrowForPattern) {
                  const n = l;
                  if (n.statement.nodeType === 64 && N(e.getTypeOfExpression(n.subjectExpression).type, o)) {
                    const a = n.statement.d.pattern;
                    if (a.nodeType === 66 && a.d.orPatterns.length === 1 && a.d.orPatterns[0].nodeType === 68) {
                      const r = a.d.orPatterns[0];
                      const s = e.getTypeOfExpression(r.d.className, 2).type;
                      if (y.isInstantiableClass(s)) {
                        return t(n.antecedent, o).filter(e => y.ClassType.isSameGenericClass(e, y.ClassType.cloneAsInstance(s)));
                      }
                    }
                  }
                  l = n.antecedent;
                } else {
                  if (!(l.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.FalseCondition))) {
                    if (l.flags & (i.FlowFlags.BranchLabel | i.FlowFlags.LoopLabel)) {
                      const e = l;
                      const n = [];
                      r.add(l.id);
                      for (const a of e.antecedents) {
                        const e = t(a, o);
                        for (const t of e) {
                          if (!n.some(e => y.isTypeSame(e, t))) {
                            n.push(t);
                          }
                        }
                      }
                      r.delete(l.id);
                      return n;
                    }
                    a.fail('Unexpected flow node flags');
                    return s;
                  }
                  {
                    const n = l;
                    const a = n.expression;
                    const s = !!(l.flags & i.FlowFlags.TrueCondition);
                    if (a.nodeType === 9 && a.d.leftExpr.nodeType === 38 && a.d.leftExpr.d.value === 'isinstance' && a.d.args.length === 2) {
                      const i = a.d.args[0].d.valueExpr;
                      if (N(e.getTypeOfExpression(i).type, o)) {
                        r.add(l.id);
                        const i = t(n.antecedent, o);
                        r.delete(l.id);
                        const p = a.d.args[1].d.valueExpr;
                        const d = e.getTypeOfExpression(p, 634).type;
                        if (y.isInstantiableClass(d)) {
                          return i.filter(e => y.ClassType.isSameGenericClass(e, y.ClassType.cloneAsInstance(d)) ? s : !s);
                        }
                      }
                    }
                    l = n.antecedent;
                  }
                }
              }
            }
          }(t, n);
          if (o.length === 1) {
            return o[0];
          } else {
            return undefined;
          }
        },
        printControlFlowGraph: z
      };
    };
    const a = require(48281);
    const r = require(56814);
    const s = require(26687);
    const i = require(50299);
    const o = require(20175);
    const l = require(20516);
    const p = require(41557);
    const d = require(69932);
    const c = require(66308);
    const u = require(83055);
    const m = require(18891);
    const y = require(21024);
    const g = require(92324);
    var h;
    function f(e) {
      return !!e.isIncompleteType;
    }
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          type: e,
          isIncomplete: t,
          generationCount: n,
          incompleteSubtypes: a
        };
      };
    })(h || (exports.FlowNodeTypeResult = h = {}));
    const T = false;
    const v = false;
    const b = false;
    const _ = 256;
    const C = false;
  },
  50299: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.wildcardImportReferenceKey = exports.FlowFlags = undefined;
    exports.getUniqueFlowNodeId = function () {
      return s++;
    };
    exports.isCodeFlowSupportedForReference = function e(t) {
      if (t.nodeType === 38) {
        return true;
      }
      if (t.nodeType === 35) {
        return e(t.d.leftExpr);
      }
      if (t.nodeType === 27) {
        if (t.d.items.length !== 1 || t.d.trailingComma || t.d.items[0].d.name !== undefined || t.d.items[0].d.argCategory !== 0) {
          return false;
        }
        const n = t.d.items[0].d.valueExpr;
        const a = n.nodeType === 40 && !n.d.isImaginary && n.d.isInteger;
        const r = n.nodeType === 55 && n.d.operator === 33 && n.d.expr.nodeType === 40 && !n.d.expr.d.isImaginary && n.d.expr.d.isInteger;
        const s = n.nodeType === 48 && n.d.strings.length === 1 && n.d.strings[0].nodeType === 49;
        return (!!a || !!r || !!s) && e(t.d.leftExpr);
      }
      return false;
    };
    exports.createKeyForReference = i;
    exports.createKeysForReferenceSubexpressions = function e(t) {
      if (t.nodeType === 38) {
        return [i(t)];
      }
      if (t.nodeType === 35) {
        return [...e(t.d.leftExpr), i(t)];
      }
      if (t.nodeType === 27) {
        return [...e(t.d.leftExpr), i(t)];
      }
      a.fail('createKeyForReference received unexpected expression type');
    };
    const a = require(48281);
    var r;
    (function (e) {
      e[e.Unreachable = 1] = 'Unreachable';
      e[e.Start = 2] = 'Start';
      e[e.BranchLabel = 4] = 'BranchLabel';
      e[e.LoopLabel = 8] = 'LoopLabel';
      e[e.Assignment = 16] = 'Assignment';
      e[e.Unbind = 32] = 'Unbind';
      e[e.WildcardImport = 64] = 'WildcardImport';
      e[e.TrueCondition = 128] = 'TrueCondition';
      e[e.FalseCondition = 512] = 'FalseCondition';
      e[e.Call = 1024] = 'Call';
      e[e.PreFinallyGate = 2048] = 'PreFinallyGate';
      e[e.PostFinally = 4096] = 'PostFinally';
      e[e.VariableAnnotation = 16384] = 'VariableAnnotation';
      e[e.PostContextManager = 32768] = 'PostContextManager';
      e[e.TrueNeverCondition = 65536] = 'TrueNeverCondition';
      e[e.FalseNeverCondition = 131072] = 'FalseNeverCondition';
      e[e.NarrowForPattern = 262144] = 'NarrowForPattern';
      e[e.ExhaustedMatch = 524288] = 'ExhaustedMatch';
    })(r || (exports.FlowFlags = r = {}));
    let s = 1;
    function i(e) {
      let t;
      if (e.nodeType === 38) {
        t = e.d.value;
      } else {
        if (e.nodeType === 35) {
          t = `${i(e.d.leftExpr)}.${e.d.member.d.value}`;
        } else {
          if (e.nodeType === 27) {
            const n = i(e.d.leftExpr);
            a.assert(e.d.items.length === 1);
            const r = e.d.items[0].d.valueExpr;
            if (r.nodeType === 40) {
              t = `${n}[${r.d.value.toString()}]`;
            } else {
              if (r.nodeType === 48) {
                const e = r;
                a.assert(e.d.strings.length === 1 && e.d.strings[0].nodeType === 49);
                t = `${n}["${e.d.strings[0].d.value}"]`;
              } else {
                if (r.nodeType === 55 && r.d.operator === 33 && r.d.expr.nodeType === 40) {
                  t = `${n}[-${r.d.expr.d.value.toString()}]`;
                } else {
                  a.fail('createKeyForReference received unexpected index type');
                }
              }
            }
          } else {
            a.fail('createKeyForReference received unexpected expression type');
          }
        }
      }
      return t;
    }
    exports.wildcardImportReferenceKey = '*';
  },
  20175: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.formatControlFlowGraph = function (e) {
      const t = Object.create(null);
      const n = [];
      const i = [];
      const o = c(e, new Set());
      for (const e of n) {
        e.text = g(e.flowNode, e.circular);
        m(e);
      }
      const l = function (e) {
        const t = f(Array(e), 0);
        for (const e of n) {
          t[e.level] = Math.max(t[e.level], e.text.length);
        }
        return t;
      }(function e(t) {
        let n = 0;
        for (const a of p(t)) {
          n = Math.max(n, e(a));
        }
        return n + 1;
      }(o));
      (function e(t, n) {
        if (t.lane === -1) {
          t.lane = n;
          t.endLane = n;
          const a = p(t);
          for (let r = 0; r < a.length; r++) {
            if (r > 0) {
              n++;
            }
            const s = a[r];
            e(s, n);
            if (s.endLane > t.endLane) {
              n = s.endLane;
            }
          }
          t.endLane = n;
        }
      })(o, 0);
      return function () {
        const e = l.length;
        const t = n.reduce((e, t) => Math.max(e, t.lane), 0) + 1;
        const a = f(Array(t), '');
        const r = l.map(() => Array(t));
        const s = l.map(() => f(Array(t), 0));
        for (const e of n) {
          r[e.level][e.lane] = e;
          const t = p(e);
          for (let n = 0; n < t.length; n++) {
            const a = t[n];
            let r = 8;
            if (a.lane === e.lane) {
              r |= 4;
            }
            if (n > 0) {
              r |= 1;
            }
            if (n < t.length - 1) {
              r |= 2;
            }
            s[e.level][a.lane] |= r;
          }
          if (t.length === 0) {
            s[e.level][e.lane] |= 16;
          }
          const n = d(e);
          for (let t = 0; t < n.length; t++) {
            const a = n[t];
            let r = 4;
            if (t > 0) {
              r |= 1;
            }
            if (t < n.length - 1) {
              r |= 2;
            }
            s[e.level - 1][a.lane] |= r;
          }
        }
        for (let n = 0; n < e; n++) {
          for (let e = 0; e < t; e++) {
            const t = n > 0 ? s[n - 1][e] : 0;
            const a = e > 0 ? s[n][e - 1] : 0;
            let r = s[n][e];
            if (!r) {
              r = 0;
              if (t & 8) {
                r |= 12;
              }
              if (a & 2) {
                r |= 3;
              }
              s[n][e] = r;
            }
          }
        }
        for (let t = 0; t < e; t++) {
          for (let n = 0; n < a.length; n++) {
            const a = s[t][n];
            const o = a & 4 ? '─' : ' ';
            const p = r[t][n];
            if (p) {
              i(n, p.text);
              if (t < e - 1) {
                i(n, ' ');
                i(n, T(o, l[t] - p.text.length));
              }
            } else {
              if (t < e - 1) {
                i(n, T(o, l[t] + 1));
              }
            }
            i(n, h(a));
            i(n, a & 8 && t < e - 1 && !r[t + 1][n] ? '─' : ' ');
          }
        }
        return `${a.join('\n')}\n`;
        function i(e, t) {
          a[e] += t;
        }
      }();
      function p(e) {
        const t = [];
        for (const n of e.edges) {
          if (n.source === e) {
            t.push(n.target);
          }
        }
        return t;
      }
      function d(e) {
        const t = [];
        for (const n of e.edges) {
          if (n.target === e) {
            t.push(n.source);
          }
        }
        return t;
      }
      function c(e, a) {
        const r = e.id;
        let i = t[r];
        if (i && a.has(e)) {
          i = {
            id: -1,
            flowNode: e,
            edges: [],
            text: '',
            lane: -1,
            endLane: -1,
            level: -1,
            circular: true
          };
          n.push(i);
          return i;
        }
        a.add(e);
        if (!i) {
          t[r] = i = {
            id: r,
            flowNode: e,
            edges: [],
            text: '',
            lane: -1,
            endLane: -1,
            level: -1,
            circular: false
          };
          n.push(i);
          const o = function (e) {
            if (e.flags & (s.FlowFlags.LoopLabel | s.FlowFlags.BranchLabel)) {
              return e.antecedents;
            }
            if (e.flags & (s.FlowFlags.Assignment | s.FlowFlags.VariableAnnotation | s.FlowFlags.WildcardImport | s.FlowFlags.TrueCondition | s.FlowFlags.FalseCondition | s.FlowFlags.TrueNeverCondition | s.FlowFlags.FalseNeverCondition | s.FlowFlags.NarrowForPattern | s.FlowFlags.ExhaustedMatch | s.FlowFlags.Call | s.FlowFlags.PreFinallyGate | s.FlowFlags.PostFinally)) {
              return [e.antecedent];
            }
            return [];
          }(e);
          for (const e of o) {
            u(i, e, a);
          }
        }
        a.delete(e);
        return i;
      }
      function u(e, t, n) {
        const a = c(t, n);
        const r = {
          source: e,
          target: a
        };
        i.push(r);
        e.edges.push(r);
        a.edges.push(r);
      }
      function m(e) {
        if (e.level !== -1) {
          return e.level;
        }
        let t = 0;
        for (const n of d(e)) {
          t = Math.max(t, m(n) + 1);
        }
        return e.level = t;
      }
      function y(e) {
        const t = function (e) {
          if (e.flags & s.FlowFlags.Assignment || e.flags & s.FlowFlags.WildcardImport) {
            return e.node;
          } else {
            if (e.flags & (s.FlowFlags.TrueCondition | s.FlowFlags.FalseCondition)) {
              return e.expression;
            } else {
              if (e.flags & s.FlowFlags.NarrowForPattern) {
                return e.statement;
              } else {
                if (e.flags & s.FlowFlags.Call) {
                  return e.node;
                } else {
                  return undefined;
                }
              }
            }
          }
        }(e);
        if (!t) {
          return;
        }
        const n = r.getFileInfo(t);
        const i = a.convertOffsetToPosition(t.start, n.lines);
        return `[${i.line + 1}:${i.character + 1}]`;
      }
      function g(e, t) {
        const n = `${function (e) {
          if (e & s.FlowFlags.Start) {
            return 'Start';
          }
          if (e & s.FlowFlags.BranchLabel) {
            return 'Branch';
          }
          if (e & s.FlowFlags.LoopLabel) {
            return 'Loop';
          }
          if (e & s.FlowFlags.Unbind) {
            return 'Unbind';
          }
          if (e & s.FlowFlags.Assignment) {
            return 'Assign';
          }
          if (e & s.FlowFlags.TrueCondition) {
            return 'True';
          }
          if (e & s.FlowFlags.FalseCondition) {
            return 'False';
          }
          if (e & s.FlowFlags.Call) {
            return 'Call';
          }
          if (e & s.FlowFlags.Unreachable) {
            return 'Unreachable';
          }
          if (e & s.FlowFlags.WildcardImport) {
            return 'Wildcard';
          }
          if (e & s.FlowFlags.PreFinallyGate) {
            return 'PreFinal';
          }
          if (e & s.FlowFlags.PostFinally) {
            return 'PostFinal';
          }
          if (e & s.FlowFlags.VariableAnnotation) {
            return 'Annotate';
          }
          if (e & s.FlowFlags.TrueNeverCondition) {
            return 'TrueNever';
          }
          if (e & s.FlowFlags.FalseNeverCondition) {
            return 'FalseNever';
          }
          if (e & s.FlowFlags.NarrowForPattern) {
            return 'Pattern';
          }
          if (e & s.FlowFlags.ExhaustedMatch) {
            return 'Exhaust';
          }
          throw new Error();
        }(e.flags)}@${e.id}${y(e) || ''}`;
        if (t) {
          return `Circular(${n})`;
        } else {
          return n;
        }
      }
      function h(e) {
        switch (e) {
          case 3:
            return '│';
          case 12:
            return '─';
          case 5:
            return '╯';
          case 9:
            return '╰';
          case 6:
            return '╮';
          case 10:
            return '╭';
          case 7:
            return '┤';
          case 11:
            return '├';
          case 13:
            return '┴';
          case 14:
            return '┬';
          case 15:
            return '╫';
        }
        return ' ';
      }
      function f(e, t) {
        if (e.fill) {
          e.fill(t);
        } else {
          for (let n = 0; n < e.length; n++) {
            e[n] = t;
          }
        }
        return e;
      }
      function T(e, t) {
        if (e.repeat) {
          if (t > 0) {
            return e.repeat(t);
          } else {
            return '';
          }
        }
        let n = '';
        while (n.length < t) {
          n += e;
        }
        return n;
      }
    };
    const a = require(56814);
    const r = require(26687);
    const s = require(50299);
  },
  22415: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getFileLevelDirectives = function (e, t, n, r, s) {
      let o = a.cloneDiagnosticRuleSet(n);
      if (r) {
        c(o);
      }
      for (let n = 0; n < e.count; n++) {
        const a = e.getItemAt(n);
        if (a.comments) {
          for (const e of a.comments) {
            const [n, a] = g(e.value, {
              start: e.start,
              length: e.length
            });
            o = m(n, a, () => i.convertOffsetToPosition(e.start, t).character <= 1, o, s);
          }
        }
      }
      return o;
    };
    const a = require(12522);
    const r = require(48281);
    const s = require(11479);
    const i = require(56814);
    const o = require(67703);
    const l = 'strict';
    const p = 'standard';
    const d = 'basic';
    function c(e) {
      (function (e, t, n) {
        const r = a.getBooleanDiagnosticRules();
        const s = a.getDiagLevelDiagnosticRules();
        for (const a of r) {
          if (!n.find(e => e === a)) {
            if (t[a]) {
              e[a] = true;
            }
          }
        }
        for (const a of s) {
          if (n.find(e => e === a)) {
            continue;
          }
          const r = t[a];
          const s = e[a];
          if (r === 'error' || r === 'warning' && s !== 'error' || r === 'information' && s !== 'error' && s !== 'warning') {
            e[a] = r;
          }
        }
      })(e, a.getStrictDiagnosticRuleSet(), a.getStrictModeNotOverriddenRules());
    }
    function u(e, t) {
      const n = a.getBooleanDiagnosticRules();
      const r = a.getDiagLevelDiagnosticRules();
      for (const a of n) {
        e[a] = t[a];
      }
      for (const n of r) {
        e[n] = t[n];
      }
    }
    function m(e, t, n, r, i) {
      const m = 'pyright:';
      if (e.startsWith(m)) {
        const m = e.substring(8);
        if (m.trim().startsWith('ignore')) {
          return r;
        }
        if (!n()) {
          const e = new s.DiagnosticAddendum();
          e.addMessage(o.LocAddendum.pyrightCommentIgnoreTip());
          const n = {
            message: o.LocMessage.pyrightCommentNotOnOwnLine() + e.getString(),
            range: t
          };
          i.push(n);
        }
        const h = m.split(',');
        if (h.some(e => e.trim() === l)) {
          c(r);
        } else {
          if (h.some(e => e.trim() === p)) {
            (function (e) {
              u(e, a.getStandardDiagnosticRuleSet());
            })(r);
          } else {
            if (h.some(e => e.trim() === d)) {
              (function (e) {
                u(e, a.getBasicDiagnosticRuleSet());
              })(r);
            }
          }
        }
        let f = 0;
        for (const e of h) {
          const [n, a] = g(e, {
            start: t.start + 8 + f,
            length: e.length
          });
          r = y(n, a, r, i);
          f += e.length + 1;
        }
      }
      return r;
    }
    function y(e, t, n, r) {
      const s = e.split('=');
      const [i, c] = g(s[0], {
        start: t.start,
        length: s[0].length
      });
      if (s.length === 1 && i && [l, p, d].some(e => i === e)) {
        return n;
      }
      const u = a.getDiagLevelDiagnosticRules();
      const m = a.getBooleanDiagnosticRules();
      const y = s.length > 0 ? s.slice(1).join('=') : '';
      const [h, f] = g(y, {
        start: t.start + s[0].length + 1,
        length: y.length
      });
      if (u.find(e => e === i)) {
        const e = function (e) {
          switch (e) {
            case 'false':
            case 'none':
              return 'none';
            case 'true':
            case 'error':
              return 'error';
            case 'warning':
              return 'warning';
            case 'information':
              return 'information';
            default:
              return;
          }
        }(h);
        if (e !== undefined) {
          n[i] = e;
        } else {
          const e = {
            message: o.LocMessage.pyrightCommentInvalidDiagnosticSeverityValue(),
            range: h ? f : c
          };
          r.push(e);
        }
      } else {
        if (m.find(e => e === i)) {
          const e = function (e) {
            if (e === 'false') {
              return false;
            }
            if (e === 'true') {
              return true;
            }
            return;
          }(h);
          if (e !== undefined) {
            n[i] = e;
          } else {
            const e = {
              message: o.LocMessage.pyrightCommentInvalidDiagnosticBoolValue(),
              range: h ? f : c
            };
            r.push(e);
          }
        } else {
          if (i) {
            const e = {
              message: h ? o.LocMessage.pyrightCommentUnknownDiagnosticRule().format({
                rule: i
              }) : o.LocMessage.pyrightCommentUnknownDirective().format({
                directive: i
              }),
              range: c
            };
            r.push(e);
          } else {
            const e = {
              message: o.LocMessage.pyrightCommentMissingDirective(),
              range: c
            };
            r.push(e);
          }
        }
      }
      return n;
    }
    function g(e, t) {
      r.assert(e.length === t.length);
      const n = e.trimStart();
      let a = t;
      if (n !== e) {
        const t = e.length - n.length;
        a = {
          start: a.start + t,
          length: a.length - t
        };
      }
      const s = n.trimEnd();
      if (s !== n) {
        a = {
          start: a.start,
          length: a.length - n.length + s.length
        };
      }
      r.assert(s.length === a.length);
      return [s, a];
    }
  },
  70617: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ConstraintSolution = exports.ConstraintSolutionSet = undefined;
    const a = require(48281);
    const r = require(21024);
    class s {
      constructor() {
        this._typeVarMap = new Map();
      }
      isEmpty() {
        return this._typeVarMap.size === 0;
      }
      getType(e) {
        const t = r.TypeVarType.getNameWithScope(e);
        return this._typeVarMap.get(t);
      }
      setType(e, t) {
        const n = r.TypeVarType.getNameWithScope(e);
        return this._typeVarMap.set(n, t);
      }
      hasType(e) {
        const t = r.TypeVarType.getNameWithScope(e);
        return this._typeVarMap.has(t);
      }
      doForEachTypeVar(e) {
        this._typeVarMap.forEach((t, n) => {
          if (t) {
            e(t, n);
          }
        });
      }
    }
    exports.ConstraintSolutionSet = s;
    exports.ConstraintSolution = class {
      constructor(e) {
        this._solutionSets = e && e.length > 0 ? [...e] : [new s()];
      }
      isEmpty() {
        return this._solutionSets.every(e => e.isEmpty());
      }
      setType(e, t) {
        return this._solutionSets.forEach(n => {
          n.setType(e, t);
        });
      }
      getMainSolutionSet() {
        return this.getSolutionSet(0);
      }
      getSolutionSets() {
        return this._solutionSets;
      }
      doForEachSolutionSet(e) {
        this.getSolutionSets().forEach((t, n) => {
          e(t, n);
        });
      }
      getSolutionSet(e) {
        a.assert(e >= 0 && e < this._solutionSets.length);
        return this._solutionSets[e];
      }
    };
  },
  10081: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.assignTypeVar = u;
    exports.solveConstraints = function (e, t, n) {
      const a = [];
      t.doForEachConstraintSet(t => {
        const r = m(e, t, n);
        a.push(r);
      });
      return new s.ConstraintSolution(a);
    };
    exports.applySourceSolutionToConstraints = function (e, t) {
      if (t.isEmpty()) {
        return;
      }
      e.doForEachConstraintSet(e => {
        e.getTypeVars().forEach(n => {
          e.setBounds(n.typeVar, n.lowerBound ? p.applySolvedTypeVars(n.lowerBound, t) : undefined, n.upperBound ? p.applySolvedTypeVars(n.upperBound, t) : undefined, n.retainLiterals);
        });
      });
    };
    exports.solveConstraintSet = m;
    exports.addConstraintsForExpectedType = function (e, t, n, a, r, s = undefined) {
      if (l.isAny(n)) {
        t.shared.typeParams.forEach(e => {
          a.setBounds(e, n, n);
        });
        return true;
      }
      if (l.isTypeVar(n) && l.TypeVarType.isSelf(n) && n.shared.boundType) {
        n = n.shared.boundType;
      }
      if (!l.isClass(n)) {
        return false;
      }
      const o = n.priv.typeArgs;
      if (!o) {
        return e.assignType(t, n, undefined, a, 2048);
      }
      e.inferVarianceForClass(t);
      if (l.ClassType.isSameGenericClass(n, t)) {
        const e = p.buildSolutionFromSpecializedClass(n);
        l.ClassType.getTypeParams(n).forEach(t => {
          let n = e.getMainSolutionSet().getType(t);
          if (n && r) {
            n = p.transformExpectedType(n, r, s);
          }
          if (n) {
            const e = l.TypeVarType.getVariance(t);
            a.setBounds(t, e === 3 ? undefined : n, e === 4 ? undefined : n);
          }
        });
        return true;
      }
      const d = p.getTypeVarScopeId(n);
      const c = l.ClassType.getTypeParams(n).map((e, t) => {
        const n = l.TypeVarType.createInstance(`__dest${t}`, l.isParamSpec(e) ? l.TypeVarKind.ParamSpec : l.TypeVarKind.TypeVar);
        n.shared.isSynthesized = true;
        n.shared.declaredVariance = 2;
        n.priv.scopeId = d;
        return n;
      });
      const m = l.ClassType.specialize(n, c);
      const y = l.ClassType.getTypeParams(t).map((e, t) => {
        const n = l.TypeVarType.createInstance(`__source${t}`, l.isParamSpec(e) ? l.TypeVarKind.ParamSpec : l.TypeVarKind.TypeVar);
        n.shared.isSynthesized = true;
        n.shared.synthesizedIndex = t;
        n.shared.isExemptFromBoundCheck = true;
        return l.TypeVarType.cloneAsUnificationVar(n);
      });
      const g = l.ClassType.specialize(t, y);
      const f = new i.ConstraintTracker();
      if (e.assignType(m, g, undefined, f, 2048)) {
        let t = true;
        c.forEach((n, i) => {
          let d = h(e, f.getMainConstraintSet(), n);
          const c = [];
          if (d && (l.isParamSpec(n) && l.isFunction(d) && (d = p.simplifyFunctionToParamSpec(d)), l.isUnion(d))) {
            let e;
            p.sortTypes(d.priv.subtypes).forEach(t => {
              if (l.isTypeVar(t) && t.shared.isSynthesized && t.shared.synthesizedIndex !== undefined && !e) {
                e = t;
              } else {
                c.push(t);
              }
            });
            if (e) {
              d = e;
            }
          }
          if (d && l.isTypeVar(d) && d.shared.isSynthesized && d.shared.synthesizedIndex !== undefined) {
            const n = l.ClassType.getTypeParams(g)[d.shared.synthesizedIndex];
            if (i < o.length) {
              let d = p.transformPossibleRecursiveTypeAlias(o[i]);
              if (c.length > 0) {
                d = l.combineTypes([d, ...c]);
              }
              if (r) {
                d = p.transformExpectedType(d, r, s);
              }
              if (!d || !u(e, n, d, undefined, a, 256)) {
                t = false;
              }
            }
          }
        });
        return t;
      }
      return false;
    };
    const a = require(11479);
    const r = require(67703);
    const s = require(70617);
    const i = require(86672);
    const o = require(83055);
    const l = require(21024);
    const p = require(92324);
    const d = 64;
    const c = false;
    function u(e, t, n, s, i, u = 0, m = 0) {
      let y;
      if (c) {
        const a = ' '.repeat(m * 2);
        console.log(`${a}`);
        console.log(`${a}assignTypeVar called with`);
        console.log(`${a}destType: ${e.printType(t)}`);
        console.log(`${a}srcType: ${e.printType(n)}`);
        console.log(`${a}flags: ${u}`);
        if (i) {
          T(e, i, a);
        }
      }
      if (l.isUnpacked(t) && l.isUnpacked(n)) {
        t = l.TypeVarType.cloneForPacked(t);
        n = p.makePacked(n);
      }
      if (!t.priv.scopeId) {
        return true;
      }
      if (l.TypeVarType.isBound(t) && !l.TypeVarType.isUnification(t)) {
        return function (e, t, n, a, s) {
          if (l.isAnyOrUnknown(n) || l.isClass(n) && l.ClassType.derivesFromAnyOrUnknown(n)) {
            return true;
          }
          if (l.isParamSpec(t) && l.isFunction(n) && l.FunctionType.isGradualCallableForm(n)) {
            return true;
          }
          const i = !!(s & 1);
          if (l.isNever(n) && !i) {
            return true;
          }
          if (l.isClassInstance(n) && l.ClassType.isBuiltIn(n, 'type') && (!n.priv.typeArgs || n.priv.typeArgs.length < 1 || l.isAnyOrUnknown(n.priv.typeArgs[0])) && l.TypeBase.isInstantiable(t)) {
            return true;
          }
          if ((!t.shared.isSynthesized || !!l.TypeVarType.isSelf(t)) && a != null) {
            a.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(n, t)));
          }
          return false;
        }(e, t, n, s, u);
      }
      if (l.TypeBase.isInstantiable(t) && l.isInstantiableClass(n) && e.isSpecialFormClass(n, u)) {
        return false;
      }
      if (l.isTypeSame(t, n)) {
        return true;
      }
      if (l.isParamSpec(t)) {
        y = function (e, t, n, a, s, i = 0) {
          if (!s) {
            return true;
          }
          let o = true;
          let d = l.isParamSpec(n) ? n : p.convertTypeToParamSpecValue(n);
          if (l.isFunction(d)) {
            d = p.simplifyFunctionToParamSpec(d);
          }
          s.doForEachConstraintSet(n => {
            var s;
            var c;
            if (l.isParamSpec(d)) {
              const e = (s = n.getTypeVar(t)) === null || s === undefined ? undefined : s.lowerBound;
              if (!e) {
                n.setBounds(t, d);
                return;
              }
              {
                const t = p.convertTypeToParamSpecValue(e);
                const n = l.FunctionType.getParamSpecFromArgsKwargs(t);
                if (l.FunctionType.cloneRemoveParamSpecArgsKwargs(t).shared.parameters.length === 0 && n && l.isTypeSame(n, d, {}, i)) {
                  return;
                }
              }
            } else {
              if (l.isFunction(d)) {
                const a = d;
                let r = false;
                const s = (c = n.getTypeVar(t)) === null || c === undefined ? undefined : c.lowerBound;
                if (s) {
                  const t = p.simplifyFunctionToParamSpec(p.convertTypeToParamSpecValue(s));
                  const n = e.assignType(t, a, undefined, undefined, 64, i);
                  const o = e.assignType(a, t, undefined, undefined, 64, i);
                  if (n && o) {
                    if (l.FunctionType.isGradualCallableForm(a)) {
                      return;
                    }
                    r = true;
                  } else {
                    if (o) {
                      r = true;
                    } else {
                      if (n) {
                        return;
                      }
                    }
                  }
                } else {
                  r = true;
                }
                if (r) {
                  n.setBounds(t, a);
                  return;
                }
              } else {
                if (l.isAnyOrUnknown(d)) {
                  return;
                }
              }
            }
            if (a != null) {
              a.addMessage(r.LocAddendum.typeParamSpec().format({
                type: e.printType(d),
                name: t.shared.name
              }));
            }
            o = false;
          });
          return o;
        }(e, t, n, s, i, m);
      } else {
        if (l.isTypeVarTuple(t) && !t.priv.isInUnion) {
          if (t.priv.isUnpacked) {
            const t = e.getTupleClassType();
            if (!l.isUnpacked(n) && t) {
              n = p.convertToInstance(p.specializeTupleClass(t, [{
                type: n,
                isUnbounded: false
              }], true, true));
            }
          } else {
            n = p.makeUnpacked(n);
          }
        }
        if (l.isTypeVarTuple(n) && n.priv.isUnpacked && !n.priv.isInUnion && !l.isTypeVarTuple(t)) {
          n = l.TypeVarType.cloneForUnpacked(n, true);
        }
        y = l.TypeVarType.hasConstraints(t) ? function (e, t, n, a, s, i, o) {
          let d;
          const c = e.makeTopLevelTypeVarsConcrete(n);
          const u = s == null ? undefined : s.getMainConstraintSet().getTypeVar(t);
          const m = u == null ? undefined : u.upperBound;
          const y = u == null ? undefined : u.lowerBound;
          let g = false;
          if (l.isTypeVar(n)) {
            if (e.assignType(t, c, undefined, undefined, 0, o)) {
              d = n;
              if (l.TypeBase.isInstantiable(n)) {
                d = p.convertToInstance(n, false);
              }
            }
          } else {
            let n;
            let a = true;
            d = p.mapSubtypes(c, r => {
              let s;
              let d;
              if (l.isAnyOrUnknown(r)) {
                return r;
              } else {
                t.shared.constraints.forEach((n, a) => {
                  const i = l.TypeBase.isInstantiable(t) ? p.convertToInstantiable(n) : n;
                  if (e.assignType(i, r, undefined, undefined, 0, o)) {
                    if (!s || !!e.assignType(l.TypeBase.isInstantiable(t) ? p.convertToInstantiable(s) : s, i, undefined, undefined, 0, o)) {
                      s = p.addConditionToType(n, p.getTypeCondition(r));
                      d = a;
                    }
                  }
                });
                if (!s && !(i & 2)) {
                  a = false;
                }
                if (d !== undefined && !p.getTypeCondition(r)) {
                  if (n !== undefined && n !== d) {
                    a = false;
                  }
                  n = d;
                }
                return s;
              }
            });
            if (!!l.isNever(d) || !a) {
              d = undefined;
            }
            if (!d && l.isUnion(c)) {
              d = t.shared.constraints.find(n => {
                const a = l.TypeBase.isInstantiable(t) ? p.convertToInstantiable(n) : n;
                return e.assignType(a, c, undefined, undefined, 0, o);
              });
            }
          }
          if (!d) {
            if (a != null) {
              a.addMessage(r.LocAddendum.typeConstrainedTypeVar().format({
                type: e.printType(n),
                name: t.shared.name
              }));
            }
            return false;
          }
          if (p.isLiteralTypeOrUnion(d)) {
            g = true;
          }
          if (y && !l.isAnyOrUnknown(y)) {
            if (!e.assignType(y, d, undefined, undefined, 0, o)) {
              if (!e.assignType(d, y, undefined, undefined, 0, o)) {
                if (a != null) {
                  a.addMessage(r.LocAddendum.typeConstrainedTypeVar().format({
                    type: e.printType(d),
                    name: e.printType(y)
                  }));
                }
                return false;
              }
              if (s != null) {
                s.setBounds(t, d, m);
              }
            }
          } else {
            if (s != null) {
              s.setBounds(t, d, m, g);
            }
          }
          return true;
        }(e, t, n, s, i, u, m) : function (e, t, n, s, i, c, u) {
          const m = !!(c & 1);
          const y = !!(c & 2) && !m;
          const h = i == null ? undefined : i.getMainConstraintSet().getTypeVar(t);
          let T = h == null ? undefined : h.upperBound;
          if (!T && !l.TypeVarType.isSelf(t)) {
            T = t.shared.boundType;
          }
          let v = h == null ? undefined : h.lowerBound;
          let b = v;
          let _ = T;
          const C = s ? new a.DiagnosticAddendum() : undefined;
          let I = n;
          if (!(c & 8192)) {
            if (l.isClass(I) && I.priv.includeSubclasses) {
              I = p.specializeWithDefaultTypeArgs(I);
            }
          }
          if (l.TypeBase.isInstantiable(t)) {
            if (p.isEffectivelyInstantiable(I)) {
              I = p.convertToInstance(I, false);
            } else {
              const a = e.makeTopLevelTypeVarsConcrete(I);
              if (!p.isEffectivelyInstantiable(a)) {
                if (s != null) {
                  s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(n, t)));
                }
                return false;
              }
              I = p.convertToInstance(a);
            }
          } else {
            if (l.isTypeVar(n) && l.TypeBase.isInstantiable(n) && l.isTypeSame(p.convertToInstance(n), t)) {
              if (s != null) {
                s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(I, t)));
              }
              return false;
            }
          }
          if (c & 2048) {
            if (c & 4096 && l.isUnknown(I)) {
              return true;
            }
            if (!h) {
              if (m) {
                b = I;
                _ = I;
              } else {
                if (y) {
                  b = I;
                } else {
                  _ = I;
                }
              }
            }
          } else {
            if (y) {
              if (!T || l.isTypeSame(t, T)) {
                _ = I;
              } else {
                if (!l.isTypeSame(T, I, {}, u)) {
                  if (e.assignType(T, e.makeTopLevelTypeVarsConcrete(I), C, undefined, 0, u)) {
                    _ = I;
                  } else {
                    if (!e.assignType(I, T, C, undefined, 0, u)) {
                      if (s && C) {
                        s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(T, I)));
                        s.addAddendum(C);
                      }
                      return false;
                    }
                  }
                }
              }
              if (v && !e.assignType(_, v, undefined, undefined, 0, u)) {
                if (s && C) {
                  s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(v, _)));
                  s.addAddendum(C);
                }
                return false;
              }
            } else {
              if (!v || l.isTypeSame(t, v)) {
                b = I;
              } else {
                if (l.isTypeSame(v, I, {}, u)) {
                  if (!_ && m && h && !h.retainLiterals) {
                    b = g(e, t, v);
                  }
                } else {
                  if (e.assignType(v, I, C, i, c, u)) {
                    if (p.isPartlyUnknown(v) && !l.isUnknown(I) && e.assignType(I, v, undefined, i, 0, u)) {
                      b = I;
                    } else {
                      b = v;
                      if (i) {
                        b = e.solveAndApplyConstraints(b, i);
                      }
                    }
                  } else {
                    if (l.isTypeVar(v) && !l.isTypeVar(I) && e.assignType(e.makeTopLevelTypeVarsConcrete(v), I, C, i, c, u)) {
                      b = I;
                    } else {
                      if (e.assignType(I, v, undefined, i, 0, u)) {
                        if (!l.isTypeVar(I)) {
                          b = I;
                        }
                      } else {
                        if (l.isTypeVarTuple(t)) {
                          const t = function (e, t, n) {
                            if (!l.isUnpackedClass(t) || !l.isUnpackedClass(n)) {
                              return;
                            }
                            if (!t.priv.tupleTypeArgs || !n.priv.tupleTypeArgs || t.priv.tupleTypeArgs.length !== n.priv.tupleTypeArgs.length) {
                              return;
                            }
                            const a = f(e, t);
                            const r = f(e, n);
                            if (l.isTypeSame(a, r)) {
                              return a;
                            }
                            return;
                          }(e, v, I);
                          if (!t) {
                            if (s != null) {
                              s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(v, I)));
                            }
                            return false;
                          }
                          b = t;
                        } else {
                          const n = e.getObjectType();
                          if (!_ && m && h && !h.retainLiterals) {
                            v = g(e, t, v);
                          }
                          let a = v;
                          if (i) {
                            a = e.solveAndApplyConstraints(v, i);
                          }
                          b = l.isUnion(a) && a.priv.subtypes.length > o.maxSubtypesForInferredType && l.TypeVarType.hasBound(t) && l.isClassInstance(n) ? l.combineTypes([a, n], {
                            maxSubtypeCount: d
                          }) : l.combineTypes([a, I], {
                            maxSubtypeCount: d
                          });
                        }
                      }
                    }
                  }
                }
              }
              if (m && b && !e.assignType(I, b, s == null ? undefined : s.createAddendum(), undefined, 0, u)) {
                if (s && C) {
                  s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(b, I)));
                }
                return false;
              }
              if (T && b && !l.isTypeSame(T, b, {}, u) && !e.assignType(T, b, s == null ? undefined : s.createAddendum(), undefined, 0, u)) {
                if (s && C) {
                  s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(b, T)));
                }
                return false;
              }
            }
          }
          if (!_ && m) {
            _ = b;
          }
          if (t.shared.boundType) {
            const a = b || _;
            if (l.TypeBase.isInstantiable(t) && !p.isEffectivelyInstantiable(n)) {
              return false;
            }
            const o = l.TypeVarType.isSelf(t) ? i : undefined;
            if (!e.assignType(t.shared.boundType, e.makeTopLevelTypeVarsConcrete(a), s == null ? undefined : s.createAddendum(), o, 0, u)) {
              if (!t.shared.isSynthesized && s != null) {
                s.addMessage(r.LocAddendum.typeBound().format({
                  sourceType: e.printType(a),
                  destType: e.printType(t.shared.boundType),
                  name: l.TypeVarType.getReadableName(t)
                }));
              }
              return false;
            }
          }
          if (i != null) {
            i.setBounds(t, b, _, !!(c & 2304));
          }
          return true;
        }(e, t, n, s, i, u, m);
      }
      if (c) {
        const t = ' '.repeat(m * 2);
        console.log(`${t}`);
        if (i) {
          T(e, i, t);
        }
      }
      return y;
    }
    function m(e, t, n) {
      const a = new s.ConstraintSolutionSet();
      t.doForEachTypeVar(r => {
        y(e, t, n, a, r);
      });
      return a;
    }
    function y(e, t, n, a, r) {
      if (a.hasType(r.typeVar)) {
        return a.getType(r.typeVar);
      }
      a.setType(r.typeVar, undefined);
      let i = h(e, t, r.typeVar, n == null ? undefined : n.useLowerBoundOnly);
      if (i) {
        const o = p.getTypeVarArgsRecursive(i);
        if (o.length > 0) {
          const d = new s.ConstraintSolution();
          for (const s of o) {
            if (l.isTypeSame(s, r.typeVar, {
              ignoreTypeFlags: true
            })) {
              continue;
            }
            if (l.TypeVarType.isBound(s)) {
              continue;
            }
            const i = t.getTypeVar(s);
            if (!i) {
              continue;
            }
            const o = y(e, t, n, a, i);
            if (o) {
              d.setType(s, o);
            }
          }
          if (!d.isEmpty()) {
            i = p.applySolvedTypeVars(i, d);
          }
        }
      }
      a.setType(r.typeVar, i);
      return i;
    }
    function g(e, t, n) {
      if (l.isTypeVarTuple(t)) {
        return f(e, n);
      } else {
        return p.stripTypeForm(e.stripLiteralValue(n));
      }
    }
    function h(e, t, n, a) {
      const r = t.getTypeVar(n);
      if (!r) {
        return;
      }
      if (l.isParamSpec(n)) {
        if (!r.lowerBound) {
          return;
        }
        if (l.isFunction(r.lowerBound)) {
          return r.lowerBound;
        }
        if (l.isAnyOrUnknown(r.lowerBound)) {
          return l.ParamSpecType.getUnknown();
        }
      }
      let s;
      let i = r.lowerBound;
      if (i) {
        if (!r.retainLiterals) {
          const t = g(e, n, i);
          if (t !== i) {
            if (!r.upperBound || !!e.assignType(r.upperBound, t)) {
              if (l.TypeVarType.hasConstraints(n)) {
                if (n.shared.constraints.some(e => l.isTypeSame(t, e))) {
                  i = t;
                }
              } else {
                i = t;
              }
            }
          }
        }
        s = i;
      } else {
        if (!a) {
          s = r.upperBound;
        }
      }
      return s;
    }
    function f(e, t) {
      if (!l.isUnpackedClass(t) || !t.priv.tupleTypeArgs) {
        return t;
      }
      let n = false;
      const a = t.priv.tupleTypeArgs.map(t => {
        const a = p.stripTypeForm(e.stripLiteralValue(t.type));
        if (a !== t.type) {
          n = true;
        }
        return {
          isUnbounded: t.isUnbounded,
          isOptional: t.isOptional,
          type: a
        };
      });
      if (n) {
        return p.specializeTupleClass(t, a, true, true);
      } else {
        return t;
      }
    }
    function T(e, t, n) {
      const a = t.getConstraintSets().length;
      if (a === 0) {
        console.log(`${n}  no signatures`);
      } else {
        if (a === 1) {
          v(e, t.getConstraintSets()[0], `${n}  `);
        } else {
          t.doForEachConstraintSet((t, a) => {
            console.log(`${n}  signature ${a}`);
            v(e, t, `${n}    `);
          });
        }
      }
    }
    function v(e, t, n) {
      let a = false;
      t.getTypeVars().forEach(t => {
        const r = `${n}${t.typeVar.shared.name}`;
        const s = t.lowerBound;
        const i = t.upperBound;
        if (s && i && l.isTypeSame(s, i)) {
          console.log(`${r} = ${e.printType(s)}`);
          a = true;
        } else {
          if (s) {
            console.log(`${r} ≤ ${e.printType(s)}`);
            a = true;
          }
          if (i) {
            console.log(`${r} ≥ ${e.printType(i)}`);
            a = true;
          }
        }
      });
      if (!a) {
        console.log(`${n}no constraints`);
      }
    }
  },
  86672: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ConstraintTracker = exports.ConstraintSet = undefined;
    const a = require(48281);
    const r = require(53529);
    const s = require(21024);
    class i {
      constructor() {
        this._typeVarMap = new Map();
      }
      clone() {
        const e = new i();
        this._typeVarMap.forEach(t => {
          e.setBounds(t.typeVar, t.lowerBound, t.upperBound, t.retainLiterals);
        });
        if (this._scopeIds) {
          this._scopeIds.forEach(t => e.addScopeId(t));
        }
        return e;
      }
      isSame(e) {
        if (this._typeVarMap.size !== e._typeVarMap.size) {
          return false;
        }
        function t(e, t) {
          if (e && t) {
            return s.isTypeSame(e, t, {
              honorIsTypeArgExplicit: true,
              honorTypeForm: true
            });
          } else {
            return e === t;
          }
        }
        let n = true;
        this._typeVarMap.forEach((a, r) => {
          const s = e._typeVarMap.get(r);
          if (!s || !t(a.lowerBound, s.lowerBound) || !t(a.upperBound, s.upperBound)) {
            n = false;
          }
        });
        return n;
      }
      isEmpty() {
        return this._typeVarMap.size === 0;
      }
      getScore() {
        let e = 0;
        this._typeVarMap.forEach(t => {
          var n;
          e += 1;
          const a = (n = t.lowerBound) !== null && n !== undefined ? n : t.upperBound;
          if (a) {
            e += 1 - r.getComplexityScoreForType(a);
          }
        });
        return e;
      }
      setBounds(e, t, n, a) {
        const r = s.TypeVarType.getNameWithScope(e);
        this._typeVarMap.set(r, {
          typeVar: e,
          lowerBound: t,
          upperBound: n,
          retainLiterals: a
        });
      }
      doForEachTypeVar(e) {
        this._typeVarMap.forEach(e);
      }
      getTypeVar(e) {
        const t = s.TypeVarType.getNameWithScope(e);
        return this._typeVarMap.get(t);
      }
      getTypeVars() {
        const e = [];
        this._typeVarMap.forEach(t => {
          e.push(t);
        });
        return e;
      }
      addScopeId(e) {
        if (!this._scopeIds) {
          this._scopeIds = new Set();
        }
        this._scopeIds.add(e);
      }
      hasScopeId(e) {
        return !!this._scopeIds && this._scopeIds.has(e);
      }
      getScopeIds() {
        return new Set(this._scopeIds);
      }
      hasUnificationVars() {
        for (const e of this._typeVarMap.values()) {
          if (s.TypeVarType.isUnification(e.typeVar)) {
            return true;
          }
        }
        return false;
      }
    }
    exports.ConstraintSet = i;
    class o {
      constructor() {
        this._constraintSets = [new i()];
      }
      clone() {
        const e = new o();
        e._constraintSets = this._constraintSets.map(e => e.clone());
        return e;
      }
      cloneWithSignature(e) {
        const t = this.clone();
        if (e) {
          const n = this._constraintSets.filter(t => t.hasScopeId(e));
          if (n.length > 0) {
            t._constraintSets = n;
          } else {
            t._constraintSets.forEach(t => {
              t.addScopeId(e);
            });
          }
        }
        return t;
      }
      copyFromClone(e) {
        this._constraintSets = e._constraintSets.map(e => e.clone());
      }
      copyBounds(e) {
        this._constraintSets.forEach(t => {
          t.setBounds(e.typeVar, e.lowerBound, e.upperBound, e.retainLiterals);
        });
      }
      addConstraintSets(e) {
        a.assert(e.length > 0);
        if (e.length < 1024) {
          this._constraintSets = Array.from(e);
        }
      }
      isSame(e) {
        return e._constraintSets.length === this._constraintSets.length && this._constraintSets.every((t, n) => t.isSame(e._constraintSets[n]));
      }
      isEmpty() {
        return this._constraintSets.every(e => e.isEmpty());
      }
      setBounds(e, t, n, a) {
        return this._constraintSets.forEach(r => {
          r.setBounds(e, t, n, a);
        });
      }
      getScore() {
        let e = 0;
        this._constraintSets.forEach(t => {
          e += t.getScore();
        });
        return e / this._constraintSets.length;
      }
      getMainConstraintSet() {
        return this._constraintSets[0];
      }
      getConstraintSets() {
        return this._constraintSets;
      }
      doForEachConstraintSet(e) {
        this.getConstraintSets().forEach((t, n) => {
          e(t, n);
        });
      }
      getConstraintSet(e) {
        a.assert(e >= 0 && e < this._constraintSets.length);
        return this._constraintSets[e];
      }
    }
    exports.ConstraintTracker = o;
  },
  10329: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.hasConstructorTransform = function (e) {
      if (e.shared.fullName === 'functools.partial') {
        return true;
      }
      return false;
    };
    exports.applyConstructorTransform = function (e, t, n, a, r) {
      if (a.shared.fullName === 'functools.partial') {
        return function (e, t, n, a) {
          if (!c.isClassInstance(a.returnType) || a.returnType.shared.fullName !== 'functools.partial') {
            return;
          }
          const r = u.lookUpObjectMember(a.returnType, '__call__', 16);
          if (!r || !c.isTypeSame(u.convertToInstance(r.classType), a.returnType)) {
            return;
          }
          const o = e.getTypeOfMember(r);
          if (!c.isFunction(o) || o.shared.parameters.length < 1) {
            return;
          }
          if (n.length < 1) {
            return;
          }
          const p = e.getTypeOfArg(n[0], undefined);
          let d = p.type;
          const y = e.makeTopLevelTypeVarsConcrete(d);
          if (c.isInstantiableClass(y)) {
            const t = l.createFunctionFromConstructor(e, y, c.isTypeVar(d) ? u.convertToInstance(d) : undefined);
            if (t) {
              d = t;
            }
          }
          e.inferReturnTypeIfNecessary(d);
          if (n.some(e => e.argCategory !== 0)) {
            return;
          }
          if (c.isFunction(d)) {
            const r = m(e, t, n, o, d);
            if (!r) {
              return;
            }
            return {
              returnType: c.ClassType.cloneForPartial(a.returnType, r.returnType),
              isTypeIncomplete: a.isTypeIncomplete,
              argumentErrors: r.argumentErrors
            };
          }
          if (c.isOverloaded(d)) {
            const r = [];
            const l = c.OverloadedType.getOverloads(d);
            let p;
            let u = false;
            l.forEach(t => {
              const a = m(e, undefined, n, o, t);
              if (a) {
                if (a.argumentErrors) {
                  u = true;
                } else {
                  if (c.isFunction(a.returnType)) {
                    r.push(a.returnType);
                  }
                }
              }
            });
            if (r.length === 0) {
              if (u && l.length > 0) {
                e.addDiagnostic(s.DiagnosticRule.reportCallIssue, i.LocMessage.noOverload().format({
                  name: l[0].shared.name
                }), t);
              }
              return;
            }
            p = r.length === 1 ? r[0] : c.OverloadedType.create(r.map(e => c.FunctionType.cloneWithNewFlags(e, e.shared.flags | 256)));
            return {
              returnType: c.ClassType.cloneForPartial(a.returnType, p),
              isTypeIncomplete: a.isTypeIncomplete,
              argumentErrors: false
            };
          }
          return;
        }(e, t, n, r);
      }
      return r;
    };
    const a = require(58147);
    const r = require(11479);
    const s = require(65880);
    const i = require(67703);
    const o = require(86672);
    const l = require(20516);
    const p = require(44321);
    const d = require(66308);
    const c = require(21024);
    const u = require(92324);
    function m(e, t, n, l, m) {
      const y = new Map();
      const g = p.getParamListDetails(m);
      let h = false;
      let f = false;
      const T = new o.ConstraintTracker();
      n.slice(1).forEach((n, a) => {
        var o;
        var l;
        var d;
        var v;
        var b;
        var _;
        var C;
        var I;
        if (n.valueExpression) {
          if (n.name) {
            const a = g.params.find(e => {
              var t;
              return e.param.name === ((t = n.name) === null || t === undefined ? undefined : t.d.value) && e.kind !== p.ParamKind.Positional;
            });
            if (a) {
              const o = a.param.name;
              const l = a.type;
              if (y.has(o)) {
                if (t) {
                  e.addDiagnostic(s.DiagnosticRule.reportCallIssue, i.LocMessage.paramAlreadyAssigned().format({
                    name: n.name.d.value
                  }), n.name);
                }
                h = true;
              } else {
                const a = new r.DiagnosticAddendum();
                const p = e.getTypeOfExpression(n.valueExpression, undefined, u.makeInferenceContext(l));
                if (!e.assignType(l, p.type, a, T)) {
                  if (t) {
                    e.addDiagnostic(s.DiagnosticRule.reportArgumentType, i.LocMessage.argAssignmentParamFunction().format({
                      argType: e.printType(p.type),
                      paramType: e.printType(l),
                      functionName: m.shared.name,
                      paramName: o
                    }), (I = n.valueExpression) !== null && I !== undefined ? I : t);
                  }
                  h = true;
                }
                y.set(o, true);
              }
            } else {
              if (g.kwargsIndex === undefined) {
                if (t) {
                  e.addDiagnostic(s.DiagnosticRule.reportCallIssue, i.LocMessage.paramNameMissing().format({
                    name: n.name.d.value
                  }), n.name);
                }
                h = true;
              } else {
                const a = c.FunctionType.getParamType(m, g.params[g.kwargsIndex].index);
                const o = new r.DiagnosticAddendum();
                const l = e.getTypeOfExpression(n.valueExpression, undefined, u.makeInferenceContext(a));
                if (!e.assignType(a, l.type, o, T)) {
                  if (t) {
                    e.addDiagnostic(s.DiagnosticRule.reportArgumentType, i.LocMessage.argAssignmentParamFunction().format({
                      argType: e.printType(l.type),
                      paramType: e.printType(a),
                      functionName: m.shared.name,
                      paramName: (_ = g.params[g.kwargsIndex].param.name) !== null && _ !== undefined ? _ : ''
                    }), (C = n.valueExpression) !== null && C !== undefined ? C : t);
                  }
                  h = true;
                }
              }
            }
          } else {
            if (a >= g.params.length || g.params[a].kind === p.ParamKind.Keyword) {
              if (g.argsIndex !== undefined) {
                const a = c.FunctionType.getParamType(m, g.params[g.argsIndex].index);
                const p = new r.DiagnosticAddendum();
                const d = e.getTypeOfExpression(n.valueExpression, undefined, u.makeInferenceContext(a));
                if (!e.assignType(a, d.type, p, T)) {
                  if (t) {
                    e.addDiagnostic(s.DiagnosticRule.reportArgumentType, i.LocMessage.argAssignmentParamFunction().format({
                      argType: e.printType(d.type),
                      paramType: e.printType(a),
                      functionName: m.shared.name,
                      paramName: (o = g.params[g.argsIndex].param.name) !== null && o !== undefined ? o : ''
                    }), (l = n.valueExpression) !== null && l !== undefined ? l : t);
                  }
                  h = true;
                }
              } else {
                if (!f) {
                  if (t) {
                    e.addDiagnostic(s.DiagnosticRule.reportCallIssue, g.positionParamCount === 1 ? i.LocMessage.argPositionalExpectedOne() : i.LocMessage.argPositionalExpectedCount().format({
                      expected: g.positionParamCount
                    }), (d = n.valueExpression) !== null && d !== undefined ? d : t);
                  }
                }
                f = true;
                h = true;
              }
            } else {
              const o = c.FunctionType.getParamType(m, a);
              const l = new r.DiagnosticAddendum();
              const p = (v = g.params[a].param.name) !== null && v !== undefined ? v : '';
              const d = e.getTypeOfExpression(n.valueExpression, undefined, u.makeInferenceContext(o));
              if (!e.assignType(o, d.type, l, T)) {
                if (t) {
                  e.addDiagnostic(s.DiagnosticRule.reportArgumentType, i.LocMessage.argAssignmentParamFunction().format({
                    argType: e.printType(d.type),
                    paramType: e.printType(o),
                    functionName: m.shared.name,
                    paramName: p
                  }), (b = n.valueExpression) !== null && b !== undefined ? b : t);
                }
                h = true;
              }
              y.set(p, false);
            }
          }
        }
      });
      const v = e.solveAndApplyConstraints(m, T);
      if (!c.isFunction(v)) {
        return;
      }
      const b = v.shared.parameters.map((t, n) => {
        var a;
        let r = c.FunctionType.getParamType(v, n);
        if (t.category === 2 && c.isClassInstance(r) && c.isUnpackedClass(r) && c.ClassType.isTypedDictClass(r)) {
          const t = d.getTypedDictMembersForClass(e, r);
          const n = new Map((a = r.priv.typedDictNarrowedEntries) !== null && a !== undefined ? a : []);
          t.knownItems.forEach((e, t) => {
            if (y.has(t)) {
              n.set(t, {
                ...e,
                isRequired: false
              });
            }
          });
          r = c.ClassType.cloneAsInstance(c.ClassType.cloneForNarrowedTypedDictEntries(r, n));
        }
        let s = c.FunctionType.getParamDefaultType(v, n);
        if (t.name && y.get(t.name)) {
          s = c.AnyType.create(true);
        }
        return c.FunctionParam.create(t.category, r, t.flags, t.name, s);
      });
      const _ = b.filter(e => e.category !== 2 && (e.category === 1 || !e.name || !y.has(e.name)));
      const C = b.filter(e => e.name && y.get(e.name));
      const I = b.filter(e => e.category === 2);
      const k = [];
      a.appendArray(k, _);
      a.appendArray(k, C);
      a.appendArray(k, I);
      const w = c.FunctionType.createInstance(l.shared.name, l.shared.fullName, l.shared.moduleName, l.shared.flags, v.shared.docString);
      if (l.shared.parameters.length > 0) {
        c.FunctionType.addParam(w, l.shared.parameters[0]);
      }
      k.forEach(e => {
        c.FunctionType.addParam(w, e);
      });
      w.shared.declaredReturnType = v.shared.declaredReturnType ? c.FunctionType.getEffectiveReturnType(v) : v.priv.inferredReturnType;
      w.shared.declaration = l.shared.declaration;
      w.shared.typeVarScopeId = v.shared.typeVarScopeId;
      return {
        returnType: w,
        isTypeIncomplete: false,
        argumentErrors: h
      };
    }
  },
  20516: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getBoundNewMethod = u;
    exports.getBoundInitMethod = m;
    exports.getBoundCallMethod = y;
    exports.validateConstructorArgs = function (e, t, n, a, o, l) {
      var m;
      var y;
      const h = (m = a.props) === null || m === undefined ? undefined : m.typeAliasInfo;
      if ((h == null ? undefined : h.shared.typeParams) && !h.typeArgs) {
        a = c.applySolvedTypeVars(a, new i.ConstraintSolution(), {
          replaceUnsolved: {
            scopeIds: [h.shared.typeVarScopeId],
            tupleClassType: e.getTupleClassType()
          }
        });
      }
      const T = f(e, t, n, a, o, l, true);
      if (T) {
        const r = (y = T.returnType) !== null && y !== undefined ? y : d.UnknownType.create();
        if (T.argumentErrors || v(e, a, r)) {
          f(e, t, n, a, o, l, false);
          return T;
        }
      }
      const b = new r.DiagnosticAddendum();
      const _ = u(e, t, a, b);
      if (_ == null ? undefined : _.typeErrors) {
        e.addDiagnostic(s.DiagnosticRule.reportGeneralTypeIssues, b.getString(), t);
      }
      const C = p.hasConstructorTransform(a);
      const I = e.useSpeculativeMode(C ? t : undefined, () => g(e, t, n, a, o, l, _));
      let k = !C || I.argumentErrors;
      if (C) {
        if (I.argumentErrors) {
          g(e, t, n, a, o, l, _);
          k = true;
        } else {
          if (I.returnType) {
            const r = p.applyConstructorTransform(e, t, n, a, {
              argumentErrors: !!I.argumentErrors,
              returnType: I.returnType,
              isTypeIncomplete: !!I.isTypeIncomplete
            });
            if (r) {
              I.returnType = r.returnType;
              if (r.isTypeIncomplete) {
                I.isTypeIncomplete = true;
              }
              if (r.argumentErrors) {
                I.argumentErrors = true;
              }
              k = true;
            }
          }
        }
      }
      if (!k) {
        n.forEach(t => {
          if (t.valueExpression && !e.isSpeculativeModeInUse(t.valueExpression)) {
            e.getTypeOfExpression(t.valueExpression);
          }
        });
      }
      return I;
    };
    exports.createFunctionFromConstructor = function (e, t, n = undefined, a = 0) {
      const r = function (e, t, n) {
        const a = t.shared.effectiveMetaclass;
        if (!a || !d.isClass(a)) {
          return;
        }
        const r = c.lookUpClassMember(a, '__call__', 536);
        if (!r) {
          return;
        }
        const s = e.getTypeOfMember(r);
        if (!d.isFunction(s) && !d.isOverloaded(s)) {
          return;
        }
        const i = e.bindFunctionToClassOrObject(t, s, r && d.isInstantiableClass(r.classType) ? r.classType : undefined, false, t, undefined, n);
        if (!i) {
          return;
        }
        let o = false;
        c.doForEachSignature(i, n => {
          if (n.shared.declaredReturnType) {
            const a = d.FunctionType.getEffectiveReturnType(n);
            if (a && v(e, t, a)) {
              o = true;
            }
          }
        });
        if (o) {
          return i;
        } else {
          return undefined;
        }
      }(e, t, a);
      if (r) {
        return r;
      }
      let s = function (e, t, n, a) {
        const r = c.lookUpClassMember(t, '__new__', 532);
        if (!r) {
          return;
        }
        const s = e.getTypeOfMember(r);
        const i = s => {
          const i = s.shared.parameters.some((e, n) => {
            if (n === 0 || !e.name) {
              return false;
            }
            const a = d.FunctionType.getParamType(s, n);
            return c.getTypeVarArgsRecursive(a).some(e => e.priv.scopeId === c.getTypeVarScopeId(t));
          });
          const o = e.bindFunctionToClassOrObject(i ? c.selfSpecializeClass(t) : t, s, r && d.isInstantiableClass(r.classType) ? r.classType : undefined, true, n, undefined, a);
          if (!o) {
            return;
          }
          const l = d.FunctionType.clone(o);
          l.shared.typeVarScopeId = s.shared.typeVarScopeId;
          if (!l.shared.docString && t.shared.docString) {
            l.shared.docString = t.shared.docString;
          }
          l.shared.flags &= -6;
          l.priv.constructorTypeVarScopeId = c.getTypeVarScopeId(t);
          return l;
        };
        if (d.isFunction(s)) {
          return i(s);
        }
        if (!d.isOverloaded(s)) {
          return;
        }
        const o = [];
        d.OverloadedType.getOverloads(s).forEach(e => {
          const t = i(e);
          if (t) {
            o.push(t);
          }
        });
        if (o.length === 0) {
          return;
        }
        if (o.length === 1) {
          return o[0];
        }
        return d.OverloadedType.create(o);
      }(e, t, n, a);
      if (s) {
        let n = false;
        c.doForEachSignature(s, a => {
          const r = d.FunctionType.getEffectiveReturnType(a);
          if (r && b(e, t, r)) {
            n = true;
          }
        });
        if (n) {
          return s;
        }
      }
      const i = function (e, t, n, a) {
        const r = c.lookUpClassMember(t, '__init__', 532);
        if (!r) {
          return;
        }
        const s = e.getTypeOfMember(r);
        const i = d.ClassType.cloneAsInstance(t);
        function o(s) {
          var o;
          const p = e.bindFunctionToClassOrObject(i, s, r && d.isInstantiableClass(r.classType) ? r.classType : undefined, undefined, n, undefined, a);
          if (!p) {
            return;
          }
          const u = d.FunctionType.clone(p);
          let m = n;
          if (!m && (m = i, i.shared.typeParams.length > 0 && !i.priv.typeArgs)) {
            const t = new l.ConstraintTracker();
            const n = [];
            u.shared.parameters.forEach((e, t) => {
              const a = d.FunctionType.getParamType(u, t);
              c.addTypeVarsToListIfUnique(n, c.getTypeVarArgsRecursive(a));
            });
            n.forEach(e => {
              t.setBounds(e, e);
            });
            m = e.solveAndApplyConstraints(i, t, {
              replaceUnsolved: {
                scopeIds: c.getTypeVarScopeIds(i),
                tupleClassType: e.getTupleClassType()
              }
            });
          }
          u.shared.declaredReturnType = (o = p.priv.strippedFirstParamType) !== null && o !== undefined ? o : m;
          if (u.priv.specializedTypes) {
            u.priv.specializedTypes.returnType = m;
          }
          if (!u.shared.docString && t.shared.docString) {
            u.shared.docString = t.shared.docString;
          }
          u.shared.flags &= -5;
          u.priv.constructorTypeVarScopeId = c.getTypeVarScopeId(t);
          return u;
        }
        if (d.isFunction(s)) {
          return o(s);
        }
        if (!d.isOverloaded(s)) {
          return;
        }
        const p = [];
        d.OverloadedType.getOverloads(s).forEach(e => {
          const t = o(e);
          if (t) {
            p.push(t);
          }
        });
        if (p.length === 0) {
          return;
        }
        if (p.length === 1) {
          return p[0];
        }
        return d.OverloadedType.create(p);
      }(e, t, n, a);
      if (i && s && _(s)) {
        s = undefined;
      }
      if (s && i) {
        return d.combineTypes([i, s]);
      }
      if (s || i) {
        if (s != null) {
          return s;
        } else {
          return i;
        }
      }
      if (s != null) {
        return s;
      } else {
        return function (e) {
          const t = d.FunctionType.createSynthesizedInstance('__new__', 0);
          t.shared.declaredReturnType = d.ClassType.cloneAsInstance(e);
          if (e.priv.includeSubclasses || d.ClassType.isProtocolClass(e)) {
            d.FunctionType.addDefaultParams(t);
          }
          if (!t.shared.docString && e.shared.docString) {
            t.shared.docString = e.shared.docString;
          }
          return t;
        }(t);
      }
    };
    const a = require(58147);
    const r = require(11479);
    const s = require(65880);
    const i = require(70617);
    const o = require(10081);
    const l = require(86672);
    const p = require(10329);
    const d = require(21024);
    const c = require(92324);
    function u(e, t, n, a = undefined, r = 4) {
      const s = r | 800;
      return e.getTypeOfBoundMember(t, n, '__new__', {
        method: 'get'
      }, a, s);
    }
    function m(e, t, n, a = undefined, r = 4) {
      const s = r | 528;
      return e.getTypeOfBoundMember(t, n, '__init__', {
        method: 'get'
      }, a, s);
    }
    function y(e, t, n) {
      return e.getTypeOfBoundMember(t, n, '__call__', {
        method: 'get'
      }, undefined, 536);
    }
    function g(e, t, n, p, y, g, f) {
      var v;
      var C;
      let I;
      let k = false;
      let w = false;
      let S = false;
      const A = [];
      let x;
      let P;
      if (f) {
        const r = h(e, t, n, p, y, g, f, true);
        if (r.argumentErrors) {
          w = true;
        } else {
          a.appendArray(A, (v = r.overloadsUsedForCall) !== null && v !== undefined ? v : []);
        }
        if (r.isTypeIncomplete) {
          S = true;
        }
        x = r.returnType;
      }
      if (!x || _(f == null ? undefined : f.type)) {
        x = d.ClassType.cloneAsInstance(p);
      } else {
        if (d.isAnyOrUnknown(x)) {
          x = c.applySolvedTypeVars(d.ClassType.cloneAsInstance(p), new i.ConstraintSolution(), {
            replaceUnsolved: {
              scopeIds: c.getTypeVarScopeIds(p),
              tupleClassType: e.getTupleClassType()
            }
          });
        }
      }
      if (w) {
        P = {
          type: c.convertToInstance(p)
        };
      }
      if (!d.isNever(x) && !b(e, p, x) && d.isClassInstance(x)) {
        let a = x;
        if (a.priv.typeArgs && a.priv.typeArgs.some(e => d.isUnknown(e))) {
          a = d.ClassType.cloneAsInstance(p);
        }
        const i = new r.DiagnosticAddendum();
        P = m(e, t, a, i);
        if (P == null ? undefined : P.typeErrors) {
          e.addDiagnostic(s.DiagnosticRule.reportGeneralTypeIssues, i.getString(), t);
        }
        if (P) {
          const r = function (e, t, n, a, r, s, i) {
            let p = false;
            let u = false;
            const m = [];
            const y = new l.ConstraintTracker();
            if (a.priv.typeArgs) {
              o.addConstraintsForExpectedType(e, a, a, y, undefined);
            }
            const g = c.selfSpecializeClass(a);
            const h = e.validateCallArgs(t, n, {
              type: i
            }, y, r, s ? {
              ...s,
              returnTypeOverride: g
            } : undefined);
            let f = a;
            if (h.specializedInitSelfType && d.isClassInstance(h.specializedInitSelfType) && d.ClassType.isSameGenericClass(h.specializedInitSelfType, f)) {
              f = d.ClassType.cloneAsInstantiable(h.specializedInitSelfType);
            }
            const v = T(e, f, undefined, y);
            if (h.isTypeIncomplete) {
              p = true;
            }
            if (h.argumentErrors) {
              u = true;
            } else {
              if (h.overloadsUsedForCall) {
                m.push(...h.overloadsUsedForCall);
              }
            }
            return {
              argumentErrors: u,
              returnType: v,
              isTypeIncomplete: p,
              overloadsUsedForCall: m
            };
          }(e, t, n, a, y, g, P.type);
          if (r.argumentErrors) {
            w = true;
          } else {
            if (r.overloadsUsedForCall) {
              A.push(...r.overloadsUsedForCall);
            }
          }
          if (r.isTypeIncomplete) {
            S = true;
          }
          I = r.returnType;
          k = true;
          y = true;
        }
      }
      if (!k && f) {
        if (!e.isSpeculativeModeInUse(t)) {
          h(e, t, n, p, y, g, f, false);
        }
        k = true;
        I = x;
      }
      if (!f && !P) {
        const r = function (e, t, n, a, r) {
          var s;
          const i = (s = u(e, t, a, undefined, 0)) === null || s === undefined ? undefined : s.type;
          if (!i || !d.isFunction(i) && !d.isOverloaded(i)) {
            return {
              returnType: c.convertToInstance(a)
            };
          }
          return h(e, t, n, a, false, r, {
            type: i
          }, false);
        }(e, t, n, p, g);
        if (r.argumentErrors) {
          w = true;
        } else {
          if (r.overloadsUsedForCall) {
            a.appendArray(A, r.overloadsUsedForCall);
          }
        }
        if (r.isTypeIncomplete) {
          S = true;
        }
        I = (C = r.returnType) !== null && C !== undefined ? C : d.UnknownType.create();
      }
      return {
        argumentErrors: w,
        returnType: I,
        isTypeIncomplete: S,
        overloadsUsedForCall: A
      };
    }
    function h(e, t, n, a, r, s, i, o) {
      let p;
      let u = false;
      let m = false;
      const y = [];
      const g = new l.ConstraintTracker();
      const h = e.useSpeculativeMode(o ? t : undefined, () => e.validateCallArgs(t, n, i, g, r, s));
      if (h.isTypeIncomplete) {
        u = true;
      }
      if (h.argumentErrors) {
        m = true;
        e.validateCallArgs(t, n, i, g, r, s);
      } else {
        p = h.returnType;
        if (y.length === 0 && h.overloadsUsedForCall) {
          y.push(...h.overloadsUsedForCall);
        }
      }
      if (p) {
        if (d.isClassInstance(p) && c.isTupleClass(p) && !p.priv.tupleTypeArgs) {
          if (p.priv.typeArgs && p.priv.typeArgs.length === 1) {
            p = c.specializeTupleClass(p, [{
              type: p.priv.typeArgs[0],
              isUnbounded: true
            }]);
          }
          p = function (e, t) {
            let n = e;
            if (t && d.isClassInstance(t.expectedType) && c.isTupleClass(t.expectedType) && t.expectedType.priv.tupleTypeArgs) {
              n = c.specializeTupleClass(e, t.expectedType.priv.tupleTypeArgs);
            }
            return n;
          }(p, s);
        }
      } else {
        p = T(e, a, s, g);
      }
      return {
        argumentErrors: m,
        returnType: p,
        isTypeIncomplete: u,
        overloadsUsedForCall: y
      };
    }
    function f(e, t, n, a, r, s, i) {
      const o = y(e, t, a);
      if (!o) {
        return;
      }
      const l = e.useSpeculativeMode(i ? t : undefined, () => e.validateCallArgs(t, n, o, undefined, r, s));
      if (!l.argumentErrors) {
        const e = o.type;
        if (d.isFunction(e) && !e.shared.declaredReturnType) {
          return;
        }
        if (l.returnType && d.isUnknown(l.returnType)) {
          return;
        }
      }
      return l;
    }
    function T(e, t, n, a) {
      let r = true;
      if (t.shared.typeParams.length === 0 || t.priv.typeArgs) {
        return e.solveAndApplyConstraints(d.ClassType.cloneAsInstance(t), a, {
          replaceUnsolved: {
            scopeIds: [],
            tupleClassType: e.getTupleClassType()
          }
        });
      }
      if (n) {
        const s = c.mapSubtypes(n.expectedType, n => function (e, t, n, a) {
          const r = e.solveAndApplyConstraints(d.ClassType.cloneAsInstance(t), a, {
            replaceUnsolved: {
              scopeIds: [],
              tupleClassType: e.getTupleClassType()
            }
          });
          if (e.assignType(n, r)) {
            if (d.isAny(n)) {
              return n;
            } else {
              return r;
            }
          }
        }(e, t, n, a));
        if (!d.isNever(s)) {
          return s;
        }
        if (t.priv.typeArgs) {
          r = false;
        }
      }
      const s = e.solveAndApplyConstraints(t, a, {
        replaceUnsolved: r ? {
          scopeIds: c.getTypeVarScopeIds(t),
          tupleClassType: e.getTupleClassType()
        } : undefined
      });
      return d.ClassType.cloneAsInstance(s);
    }
    function v(e, t, n) {
      return !e.assignType(c.convertToInstance(t), n) || !!d.isNever(n) || !!d.findSubtype(n, e => d.isAny(e)) || !!d.ClassType.isEnumClass(t);
    }
    function b(e, t, n) {
      const a = e.makeTopLevelTypeVarsConcrete(n);
      let r = false;
      c.doForEachSubtype(a, e => {
        if (!d.isUnknown(e)) {
          if (d.isClassInstance(e)) {
            const n = [];
            if (!d.ClassType.isDerivedFrom(d.ClassType.cloneAsInstantiable(e), t, n)) {
              r = true;
            }
          } else {
            r = true;
          }
        }
      });
      return r;
    }
    function _(e) {
      var t;
      if (!e || !d.isFunction(e)) {
        return false;
      }
      const n = e.shared.parameters;
      if (n.length !== 2) {
        return false;
      }
      if (n[0].category !== 1 || n[1].category !== 2) {
        return false;
      }
      const a = (t = e.shared.declaredReturnType) !== null && t !== undefined ? t : e.priv.inferredReturnType;
      return !!a && !!d.isTypeVar(a) && !!d.TypeVarType.isSelf(a);
    }
  },
  57373: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.synthesizeDataClassMethods = function (e, t, n, a, r, s, S) {
      var A;
      i.assert(_.ClassType.isDataClass(n) || a);
      const x = C.synthesizeTypeVarForSelfCls(n, true);
      const P = _.FunctionType.createSynthesizedInstance('__new__', 1);
      P.priv.constructorTypeVarScopeId = C.getTypeVarScopeId(n);
      const D = _.FunctionType.createSynthesizedInstance('__init__');
      D.priv.constructorTypeVarScopeId = C.getTypeVarScopeId(n);
      _.FunctionType.addParam(P, _.FunctionParam.create(0, x, _.FunctionParamFlags.TypeDeclared, 'cls'));
      if (!a) {
        _.FunctionType.addDefaultParams(P);
        P.shared.flags |= 32768;
      }
      P.shared.declaredReturnType = C.convertToInstance(x);
      const N = C.synthesizeTypeVarForSelfCls(n, false);
      const F = _.FunctionParam.create(0, N, _.FunctionParamFlags.TypeDeclared, 'self');
      _.FunctionType.addParam(D, F);
      if (a) {
        _.FunctionType.addDefaultParams(D);
        D.shared.flags |= 32768;
      }
      let E;
      D.shared.declaredReturnType = e.getNoneType();
      if (p.PythonVersion.isGreaterOrEqualTo(c.getFileInfo(t).executionEnvironment.pythonVersion, p.pythonVersion3_13)) {
        E = _.FunctionType.createSynthesizedInstance('__replace__');
        _.FunctionType.addParam(E, F);
        _.FunctionType.addKeywordOnlyParamSeparator(E);
        E.shared.declaredReturnType = N;
      }
      const M = [];
      const O = [];
      const z = new Set();
      const U = k(n, O);
      if (!U) {
        _.FunctionType.addDefaultParams(D);
        if (E) {
          _.FunctionType.addDefaultParams(E);
        }
      }
      const V = a ? P : D;
      const R = [];
      let L = false;
      _.ClassType.getSymbolTable(n).forEach((s, i) => {
        var o;
        var p;
        var u;
        var m;
        var y;
        var g;
        var h;
        if (s.isIgnoredForProtocolMatch()) {
          return;
        }
        if (i === '__hash__') {
          return;
        }
        const v = s.getTypedDeclarations().find(e => {
          if (e.type !== 1) {
            return false;
          }
          const t = f.getEnclosingClassOrFunction(e.node);
          return !!t && t.nodeType === 10;
        });
        if (v) {
          let s;
          let i;
          let h;
          let f;
          let b = v.node;
          while (b && b.nodeType !== 3) {
            if (b.nodeType === 54) {
              if (((o = b.parent) === null || o === undefined ? undefined : o.nodeType) === 3) {
                b = b.parent;
              }
              break;
            }
            b = b.parent;
          }
          if (!b) {
            return;
          }
          let k;
          let S;
          let A = false;
          let x = false;
          let P = _.ClassType.isDataClassKeywordOnly(n) || L;
          let D = true;
          if (b.nodeType === 3) {
            if (b.d.leftExpr.nodeType === 54 && b.d.leftExpr.d.valueExpr.nodeType === 38) {
              s = b.d.leftExpr.d.valueExpr;
              i = b.d.leftExpr;
              const t = b;
              f = () => e.getTypeOfAnnotation(t.d.leftExpr.d.annotation, {
                varTypeAnnotation: true,
                allowFinal: true,
                allowClassVar: true
              });
            }
            A = true;
            k = b.d.rightExpr;
            if (b.d.rightExpr.nodeType === 9) {
              const r = e.getTypeOfExpression(b.d.rightExpr.d.leftExpr, 2);
              const s = r.type;
              if (!a && w(s, ((p = n.shared.dataClassBehaviors) === null || p === undefined ? undefined : p.fieldDescriptorNames) || [])) {
                const n = b.d.rightExpr.d.args.find(e => {
                  var t;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'init';
                });
                if (n && n.d.valueExpr) {
                  const e = c.getFileInfo(t);
                  D = (u = T.evaluateStaticBoolExpression(n.d.valueExpr, e.executionEnvironment, e.definedConstants)) !== null && u !== undefined ? u : D;
                } else {
                  D = (m = I(e, b.d.rightExpr, r, 'init')) !== null && m !== undefined ? m : D;
                }
                const a = b.d.rightExpr.d.args.find(e => {
                  var t;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'kw_only';
                });
                if (a && a.d.valueExpr) {
                  const e = c.getFileInfo(t);
                  P = (y = T.evaluateStaticBoolExpression(a.d.valueExpr, e.executionEnvironment, e.definedConstants)) !== null && y !== undefined ? y : P;
                } else {
                  P = (g = I(e, b.d.rightExpr, r, 'kw_only')) !== null && g !== undefined ? g : P;
                }
                const s = b.d.rightExpr.d.args.find(e => {
                  var t;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'default';
                });
                A = !!s;
                if (s == null ? undefined : s.d.valueExpr) {
                  k = s.d.valueExpr;
                }
                const i = b.d.rightExpr.d.args.find(e => {
                  var t;
                  var n;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'default_factory' || ((n = e.d.name) === null || n === undefined ? undefined : n.d.value) === 'factory';
                });
                if (i) {
                  A = true;
                  x = true;
                }
                if (i == null ? undefined : i.d.valueExpr) {
                  k = i.d.valueExpr;
                }
                const o = b.d.rightExpr.d.args.find(e => {
                  var t;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'alias';
                });
                if (o) {
                  const t = e.getTypeOfExpression(o.d.valueExpr).type;
                  if (_.isClassInstance(t) && _.ClassType.isBuiltIn(t, 'str') && C.isLiteralType(t)) {
                    h = t.priv.literalValue;
                  }
                }
                const l = b.d.rightExpr.d.args.find(e => {
                  var t;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'converter';
                });
                if (l && l.d.valueExpr) {
                  S = l;
                }
              }
            }
          } else {
            if (b.nodeType === 54 && b.d.valueExpr.nodeType === 38) {
              s = b.d.valueExpr;
              i = b;
              const t = b;
              f = () => e.getTypeOfAnnotation(t.d.annotation, {
                varTypeAnnotation: true,
                allowFinal: true,
                allowClassVar: true
              });
              if (!a && b.d.valueExpr.d.value === '_') {
                const e = f();
                if (_.isClassInstance(e) && _.ClassType.isBuiltIn(e, 'KW_ONLY')) {
                  L = true;
                  s = undefined;
                  i = undefined;
                  f = undefined;
                }
              }
            }
          }
          if (s && f) {
            const t = s.d.value;
            const a = _.ClassType.getSymbolTable(n).get(t);
            z.add(t);
            if ((a == null ? undefined : a.isClassVar()) && !(a == null ? undefined : a.isFinalVarInClassBody())) {
              const e = O.findIndex(e => e.name === t);
              if (e >= 0) {
                O.splice(e, 1);
              }
              const a = {
                name: t,
                classType: n,
                alias: h,
                isKeywordOnly: false,
                hasDefault: A,
                isDefaultFactory: x,
                defaultExpr: k,
                includeInInit: D,
                nameNode: s,
                typeAnnotationNode: i,
                type: _.UnknownType.create(),
                isClassVar: true,
                converter: S
              };
              M.push(a);
            } else {
              const a = {
                name: t,
                classType: n,
                alias: h,
                isKeywordOnly: P,
                hasDefault: A,
                isDefaultFactory: x,
                defaultExpr: k,
                includeInInit: D,
                nameNode: s,
                typeAnnotationNode: i,
                type: _.UnknownType.create(),
                isClassVar: false,
                converter: S
              };
              R.push({
                entry: a,
                evaluator: f
              });
              let o = M.findIndex(e => e.name === t);
              if (o >= 0) {
                M[o] = a;
              } else {
                M.push(a);
              }
              o = O.findIndex(e => e.name === t);
              if (o >= 0) {
                const n = O[o];
                if (!a.hasDefault && n.hasDefault && n.includeInInit) {
                  a.hasDefault = true;
                  a.defaultExpr = n.defaultExpr;
                  A = true;
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassFieldInheritedDefault().format({
                    fieldName: t
                  }), s);
                }
                O[o] = a;
              } else {
                O.push(a);
                o = O.length - 1;
              }
              if (!P && D && !r && !A) {
                const t = O.findIndex(e => e.hasDefault && e.includeInInit && !e.isKeywordOnly);
                if (t >= 0 && t < o) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassFieldWithDefault(), s);
                }
              }
            }
          }
        } else {
          const t = s.getDeclarations();
          if (t.length === 0) {
            return;
          }
          const a = t[t.length - 1];
          if (a.type !== 1) {
            return;
          }
          const r = a.node.parent;
          if (!r || r.nodeType !== 3) {
            return;
          }
          if (r.d.rightExpr.nodeType === 9) {
            if (w(e.getTypeOfExpression(r.d.rightExpr.d.leftExpr, 2).type, ((h = n.shared.dataClassBehaviors) === null || h === undefined ? undefined : h.fieldDescriptorNames) || [])) {
              e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassFieldWithoutAnnotation(), r.d.rightExpr);
            }
          }
        }
      });
      if (a) {
        n.shared.namedTupleEntries = z;
      } else {
        n.shared.dataClassEntries = M;
      }
      R.forEach(e => {
        e.entry.type = e.evaluator();
      });
      const B = _.ClassType.getSymbolTable(n);
      const j = [];
      if (!r && !s) {
        if (U) {
          O.forEach(a => {
            if (a.includeInInit) {
              let r;
              let s = a.type;
              if (a.classType !== n && C.requiresSpecialization(s)) {
                const e = new m.ConstraintSolution();
                C.addSolutionForSelfType(e, a.classType, n);
                s = C.applySolvedTypeVars(s, e);
              }
              s = function (e, t) {
                if (!_.isClassInstance(t) || C.isMetaclassInstance(t)) {
                  return t;
                }
                const n = e.getBoundMagicMethod(t, '__set__');
                if (!n) {
                  return t;
                }
                if (!_.isFunction(n)) {
                  return t;
                }
                return _.FunctionType.getParamType(n, 1);
              }(e, s);
              if (a.converter) {
                const n = s;
                s = function (e, t, n, a) {
                  var r;
                  const s = function (e, t) {
                    if (_.isFunction(t) || _.isOverloaded(t)) {
                      return t;
                    }
                    if (_.isClassInstance(t)) {
                      return e.getBoundMagicMethod(t, '__call__');
                    }
                    if (_.isInstantiableClass(t)) {
                      let n = g.createFunctionFromConstructor(e, t);
                      if (n && (_.isUnion(n) && (n = n.priv.subtypes[0]), _.isFunction(n) || _.isOverloaded(n))) {
                        return n;
                      }
                    }
                    return;
                  }(e, e.getTypeOfExpression(t.d.valueExpr).type);
                  if (!s) {
                    return n;
                  }
                  const i = _.TypeVarType.createInstance('__converterInput');
                  i.priv.scopeId = f.getScopeIdForNode(t);
                  const p = _.FunctionType.createSynthesizedInstance('');
                  p.shared.typeVarScopeId = i.priv.scopeId;
                  p.shared.declaredReturnType = n;
                  _.FunctionType.addParam(p, _.FunctionParam.create(0, i, _.FunctionParamFlags.TypeDeclared | _.FunctionParamFlags.NameSynthesized, '__input'));
                  _.FunctionType.addPositionOnlyParamSeparator(p);
                  if (_.isFunction(s) || _.isOverloaded(s)) {
                    const c = [];
                    const u = new o.DiagnosticAddendum();
                    C.doForEachSignature(s, t => {
                      const r = new y.ConstraintTracker();
                      if (e.assignType(_.FunctionType.getEffectiveReturnType(t) ?? _.UnknownType.create(), n, undefined, r)) {
                        t = e.solveAndApplyConstraints(t, r);
                      }
                      const s = new y.ConstraintTracker();
                      if (e.assignType(p, t, u, s)) {
                        const t = e.solveAndApplyConstraints(i, s, {
                          replaceUnsolved: {
                            scopeIds: C.getTypeVarScopeIds(i),
                            tupleClassType: e.getTupleClassType()
                          }
                        });
                        c.push(t);
                      }
                    });
                    if (c.length > 0) {
                      return _.combineTypes(c);
                    }
                    if (_.isFunction(s)) {
                      e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassConverterFunction().format({
                        argType: e.printType(s),
                        fieldType: e.printType(n),
                        fieldName: a
                      }) + u.getString(), t, (r = u.getEffectiveTextRange()) !== null && r !== undefined ? r : t);
                    } else {
                      const r = _.OverloadedType.getOverloads(s);
                      e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassConverterOverloads().format({
                        funcName: r.length > 0 && r[0].shared.name ? r[0].shared.name : '<anonymous function>',
                        fieldType: e.printType(n),
                        fieldName: a
                      }) + u.getString(), t);
                    }
                  }
                  return n;
                }(e, a.converter, s, a.name);
                B.set(a.name, function (e, t, n, a, r, s, i, o) {
                  const l = u.getFileInfo(t);
                  const p = e.getBuiltInType(t, 'type');
                  const d = `__converterDescriptor_${s}`;
                  const c = _.ClassType.createInstantiable(d, f.getClassFullName(r, l.moduleName, d), l.moduleName, l.fileUri, 0, f.getTypeSourceId(r), undefined, _.isInstantiableClass(p) ? p : _.UnknownType.create());
                  c.shared.baseClasses.push(e.getBuiltInType(t, 'object'));
                  C.computeMroLinearization(c);
                  const m = _.ClassType.getSymbolTable(c);
                  const y = C.synthesizeTypeVarForSelfCls(c, false);
                  const g = _.FunctionType.createSynthesizedInstance('__set__');
                  _.FunctionType.addParam(g, _.FunctionParam.create(0, y, _.FunctionParamFlags.TypeDeclared, 'self'));
                  _.FunctionType.addParam(g, _.FunctionParam.create(0, _.AnyType.create(), _.FunctionParamFlags.TypeDeclared, 'obj'));
                  _.FunctionType.addParam(g, _.FunctionParam.create(0, o, _.FunctionParamFlags.TypeDeclared, 'value'));
                  g.shared.declaredReturnType = e.getNoneType();
                  const h = v.Symbol.createWithType(4, g);
                  m.set('__set__', h);
                  const T = _.FunctionType.createSynthesizedInstance('__get__');
                  _.FunctionType.addParam(T, _.FunctionParam.create(0, y, _.FunctionParamFlags.TypeDeclared, 'self'));
                  _.FunctionType.addParam(T, _.FunctionParam.create(0, _.AnyType.create(), _.FunctionParamFlags.TypeDeclared, 'obj'));
                  _.FunctionType.addParam(T, _.FunctionParam.create(0, _.AnyType.create(), _.FunctionParamFlags.TypeDeclared, 'objtype'));
                  T.shared.declaredReturnType = i;
                  const b = v.Symbol.createWithType(4, T);
                  m.set('__get__', b);
                  return v.Symbol.createWithType(4, _.ClassType.cloneAsInstance(c), n);
                }(e, t, a.nameNode, a.typeAnnotationNode, a.converter, a.name, n, s));
                if (a.hasDefault) {
                  r = a.type;
                }
              } else {
                if (a.hasDefault) {
                  if (a.isDefaultFactory || !a.defaultExpr) {
                    r = a.type;
                  } else {
                    const n = a.defaultExpr;
                    const i = c.getFileInfo(t).isStubFile ? 1 : 0;
                    const o = f.getTypeVarScopesForNode(a.defaultExpr);
                    const l = C.makeTypeVarsBound(s, o);
                    r = e.useSpeculativeMode(n, () => e.getTypeOfExpression(n, i, C.makeInferenceContext(l)).type);
                    r = C.makeTypeVarsFree(r, o);
                  }
                }
              }
              const i = a.alias || a.name;
              if (!a.alias && a.nameNode && b.isPrivateName(a.nameNode.d.value)) {
                e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassFieldWithPrivateName(), a.nameNode);
              }
              const p = _.FunctionParam.create(0, s, _.FunctionParamFlags.TypeDeclared, i, r, a.defaultExpr);
              if (a.isKeywordOnly) {
                j.push(p);
              } else {
                _.FunctionType.addParam(V, p);
              }
              if (E) {
                const e = _.FunctionParam.create(p.category, p._type, p.flags, p.name, _.AnyType.create(true));
                _.FunctionType.addParam(E, e);
              }
            }
          });
          if (j.length > 0) {
            _.FunctionType.addKeywordOnlyParamSeparator(V);
            j.forEach(e => {
              _.FunctionType.addParam(V, e);
            });
          }
        }
        B.set('__init__', v.Symbol.createWithType(4, D));
        B.set('__new__', v.Symbol.createWithType(4, P));
        if (E) {
          B.set('__replace__', v.Symbol.createWithType(4, E));
        }
      }
      const q = e.getBuiltInType(t, 'str');
      const G = e.getBuiltInType(t, 'tuple');
      if (G && _.isInstantiableClass(G) && q && _.isInstantiableClass(q) && !B.has('__match_args__')) {
        const e = [];
        O.forEach(t => {
          if (t.includeInInit && !t.isKeywordOnly) {
            e.push(t.name);
          }
        });
        const t = e.map(e => ({
          type: _.ClassType.cloneAsInstance(_.ClassType.cloneWithLiteral(q, e)),
          isUnbounded: false
        }));
        const n = _.ClassType.cloneAsInstance(C.specializeTupleClass(G, t));
        B.set('__match_args__', v.Symbol.createWithType(4, n));
      }
      const W = (n, a) => {
        const r = _.FunctionType.createSynthesizedInstance(n);
        _.FunctionType.addParam(r, F);
        _.FunctionType.addParam(r, _.FunctionParam.create(0, a, _.FunctionParamFlags.TypeDeclared, 'other'));
        r.shared.declaredReturnType = e.getBuiltInObject(t, 'bool');
        if (!B.get(n)) {
          B.set(n, v.Symbol.createWithType(4, r));
        }
      };
      if (!_.ClassType.isDataClassSkipGenerateEq(n)) {
        W('__eq__', e.getBuiltInObject(t, 'object'));
      }
      if (_.ClassType.isDataClassGenerateOrder(n)) {
        ['__lt__', '__le__', '__gt__', '__ge__'].forEach(e => {
          W(e, N);
        });
      }
      let K = _.ClassType.isDataClassFrozen(n);
      const $ = !a && !_.ClassType.isDataClassSkipGenerateEq(n) && !_.ClassType.isDataClassFrozen(n);
      if (S) {
        K = false;
      }
      if (_.ClassType.isDataClassGenerateHash(n)) {
        K = true;
      }
      if (K) {
        const n = _.FunctionType.createSynthesizedInstance('__hash__');
        _.FunctionType.addParam(n, F);
        n.shared.declaredReturnType = e.getBuiltInObject(t, 'int');
        B.set('__hash__', v.Symbol.createWithType(4100, n));
      } else {
        if ($ && !S) {
          B.set('__hash__', v.Symbol.createWithType(4100, e.getNoneType()));
        }
      }
      let H = e.getBuiltInType(t, 'dict');
      if (_.isInstantiableClass(H)) {
        H = _.ClassType.cloneAsInstance(_.ClassType.specialize(H, [e.getBuiltInObject(t, 'str'), _.AnyType.create()]));
      }
      if (!a) {
        B.set('__dataclass_fields__', v.Symbol.createWithType(132, H));
      }
      if (_.ClassType.isDataClassGenerateSlots(n) && n.shared.localSlotsNames === undefined) {
        n.shared.localSlotsNames = M.map(e => e.name);
      }
      if (_.ClassType.isDataClassGenerateSlots(n)) {
        let n = (A = e.getTypingType(t, 'Iterable')) !== null && A !== undefined ? A : _.UnknownType.create();
        if (_.isInstantiableClass(n)) {
          n = _.ClassType.cloneAsInstance(_.ClassType.specialize(n, [e.getBuiltInObject(t, 'str')]));
        }
        B.set('__slots__', v.Symbol.createWithType(132, n));
      }
      if (h.updateNamedTupleBaseClass(n, O.map(e => e.type), true)) {
        C.computeMroLinearization(n);
      }
    };
    exports.addInheritedDataClassEntries = k;
    exports.validateDataClassTransformDecorator = function (e, t) {
      const n = {
        skipGenerateInit: false,
        skipGenerateEq: false,
        generateOrder: false,
        generateSlots: false,
        generateHash: false,
        keywordOnly: false,
        frozen: false,
        frozenDefault: false,
        fieldDescriptorNames: []
      };
      const a = c.getFileInfo(t);
      t.d.args.forEach(t => {
        if (t.d.name && t.d.argCategory === 0) {
          switch (t.d.name.d.value) {
            case 'kw_only_default':
              {
                const r = T.evaluateStaticBoolExpression(t.d.valueExpr, a.executionEnvironment, a.definedConstants);
                if (r === undefined) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformExpectedBoolLiteral(), t.d.valueExpr);
                  return;
                }
                n.keywordOnly = r;
                break;
              }
            case 'eq_default':
              {
                const r = T.evaluateStaticBoolExpression(t.d.valueExpr, a.executionEnvironment, a.definedConstants);
                if (r === undefined) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformExpectedBoolLiteral(), t.d.valueExpr);
                  return;
                }
                n.skipGenerateEq = !r;
                break;
              }
            case 'order_default':
              {
                const r = T.evaluateStaticBoolExpression(t.d.valueExpr, a.executionEnvironment, a.definedConstants);
                if (r === undefined) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformExpectedBoolLiteral(), t.d.valueExpr);
                  return;
                }
                n.generateOrder = r;
                break;
              }
            case 'frozen_default':
              {
                const r = T.evaluateStaticBoolExpression(t.d.valueExpr, a.executionEnvironment, a.definedConstants);
                if (r === undefined) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformExpectedBoolLiteral(), t.d.valueExpr);
                  return;
                }
                n.frozen = r;
                n.frozenDefault = r;
                break;
              }
            case 'field_descriptors':
            case 'field_specifiers':
              {
                const a = e.getTypeOfExpression(t.d.valueExpr).type;
                if (!_.isClassInstance(a) || !_.ClassType.isBuiltIn(a, 'tuple') || !a.priv.tupleTypeArgs || a.priv.tupleTypeArgs.some(e => !_.isInstantiableClass(e.type) && !_.isFunction(e.type) && !_.isOverloaded(e.type))) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformFieldSpecifier().format({
                    type: e.printType(a)
                  }), t.d.valueExpr);
                  return;
                }
                a.priv.tupleTypeArgs.forEach(e => {
                  if (_.isInstantiableClass(e.type) || _.isFunction(e.type)) {
                    n.fieldDescriptorNames.push(e.type.shared.fullName);
                  } else {
                    if (_.isOverloaded(e.type)) {
                      const t = _.OverloadedType.getOverloads(e.type);
                      if (t.length > 0) {
                        n.fieldDescriptorNames.push(t[0].shared.fullName);
                      }
                    }
                  }
                });
                break;
              }
            default:
              e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformUnknownArgument().format({
                name: t.d.name.d.value
              }), t.d.valueExpr);
          }
        } else {
          e.addDiagnostic(l.DiagnosticRule.reportCallIssue, d.LocMessage.dataClassTransformPositionalParam(), t);
        }
      });
      return n;
    };
    exports.getDataclassDecoratorBehaviors = function (e) {
      let t;
      if (_.isFunction(e)) {
        t = e;
      } else {
        if (_.isOverloaded(e)) {
          const n = _.OverloadedType.getOverloads(e);
          const a = _.OverloadedType.getImplementation(e);
          t = n.find(e => !!e.shared.decoratorDataClassBehaviors);
          if (!t && a && _.isFunction(a) && a.shared.decoratorDataClassBehaviors) {
            t = a;
          }
          if (!t && n.length > 0) {
            t = n[0];
          }
        }
      }
      if (!t) {
        return;
      }
      if (t.shared.decoratorDataClassBehaviors) {
        return t.shared.decoratorDataClassBehaviors;
      }
      if (t.shared.fullName === 'dataclasses.dataclass') {
        return {
          fieldDescriptorNames: ['dataclasses.field', 'dataclasses.Field']
        };
      }
      return;
    };
    exports.applyDataClassClassBehaviorOverrides = A;
    exports.applyDataClassDecorator = function (e, t, n, a, r) {
      var s;
      A(e, t, n, ((s = r == null ? undefined : r.d.args) !== null && s !== undefined ? s : []).map(t => e.convertNodeToArg(t)), a);
    };
    const i = require(48281);
    const o = require(11479);
    const l = require(65880);
    const p = require(63808);
    const d = require(67703);
    const c = __importStar(require(26687));
    const u = require(26687);
    const m = require(70617);
    const y = require(86672);
    const g = require(20516);
    const h = require(60055);
    const f = require(41557);
    const T = require(28676);
    const v = require(58253);
    const b = require(12097);
    const _ = require(21024);
    const C = require(92324);
    function I(e, t, n, a) {
      const r = n.type;
      let s;
      if (_.isFunction(r)) {
        s = r;
      } else {
        if (_.isOverloaded(r)) {
          s = e.getBestOverloadForArgs(t, {
            type: r,
            isIncomplete: n.isIncomplete
          }, t.d.args.map(t => e.convertNodeToArg(t)));
        } else {
          if (_.isInstantiableClass(r)) {
            const n = g.getBoundInitMethod(e, t, r);
            if (n) {
              if (_.isFunction(n.type)) {
                s = n.type;
              } else {
                if (_.isOverloaded(n.type)) {
                  s = e.getBestOverloadForArgs(t, {
                    type: n.type
                  }, t.d.args.map(t => e.convertNodeToArg(t)));
                }
              }
            }
          }
        }
      }
      if (s) {
        const e = s.shared.parameters.findIndex(e => e.name === a);
        if (e >= 0) {
          const t = s.shared.parameters[e];
          const n = _.FunctionType.getParamType(s, e);
          if (_.FunctionParam.isTypeDeclared(t) && _.isClass(n) && typeof n.priv.literalValue == 'boolean') {
            return n.priv.literalValue;
          }
          const a = _.FunctionType.getParamDefaultType(s, e);
          if (a && _.isClass(a) && typeof a.priv.literalValue == 'boolean') {
            return a.priv.literalValue;
          }
        }
      }
    }
    function k(e, t) {
      let n = true;
      _.ClassType.getReverseMro(e).forEach(e => {
        if (_.isInstantiableClass(e)) {
          const n = C.buildSolutionFromSpecializedClass(e);
          _.ClassType.getDataClassEntries(e).forEach(e => {
            const a = t.findIndex(t => t.name === e.name);
            const r = {
              ...e
            };
            r.type = C.applySolvedTypeVars(r.type, n);
            if (e.isClassVar) {
              if (a >= 0) {
                t.splice(a, 1);
              }
            } else {
              if (a >= 0) {
                t[a] = r;
              } else {
                t.push(r);
              }
            }
          });
        } else {
          n = false;
        }
      });
      return n;
    }
    function w(e, t) {
      let n;
      if (_.isFunction(e)) {
        n = e.shared.fullName;
      } else {
        if (_.isOverloaded(e)) {
          const t = _.OverloadedType.getOverloads(e);
          if (t.length > 0) {
            n = t[0].shared.fullName;
          }
        } else {
          if (_.isInstantiableClass(e)) {
            n = e.shared.fullName;
          }
        }
      }
      return !!n && t.some(e => e === n);
    }
    function S(e, t, n, a, r, s) {
      switch (a) {
        case 'order':
          if (r !== undefined) {
            s.generateOrder = r;
          }
          break;
        case 'kw_only':
          if (r !== undefined) {
            s.keywordOnly = r;
          }
          break;
        case 'frozen':
          {
            let a = false;
            let i = false;
            if (r !== undefined) {
              s.frozen = r;
            }
            n.shared.baseClasses.forEach(e => {
              if (_.isInstantiableClass(e) && _.ClassType.isDataClass(e)) {
                if (_.ClassType.isDataClassFrozen(e)) {
                  i = true;
                } else {
                  if (!e.shared.classDataClassTransform && (!e.shared.declaredMetaclass || !_.isInstantiableClass(e.shared.declaredMetaclass) || !e.shared.declaredMetaclass.shared.classDataClassTransform)) {
                    a = true;
                  }
                }
              }
            });
            if (r) {
              if (a) {
                e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassBaseClassNotFrozen(), t);
              }
            } else {
              if (i) {
                e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassBaseClassFrozen(), t);
              }
            }
            break;
          }
        case 'init':
          if (r !== undefined) {
            s.skipGenerateInit = !r;
          }
          break;
        case 'eq':
          if (r !== undefined) {
            s.skipGenerateEq = !r;
          }
          break;
        case 'slots':
          if (r === true) {
            s.generateSlots = true;
            if (n.shared.localSlotsNames) {
              e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassSlotsOverwrite(), t);
            }
          } else {
            if (r === false) {
              s.generateSlots = false;
            }
          }
          break;
        case 'hash':
        case 'unsafe_hash':
          if (r === true) {
            s.generateHash = true;
          }
      }
    }
    function A(e, t, n, a, r) {
      let s = false;
      const i = {
        ...r
      };
      i.frozen = i.frozenDefault;
      n.shared.dataClassBehaviors = i;
      a.forEach(t => {
        if (t.valueExpression && t.name) {
          (function (e, t, n, a, r, s) {
            const i = c.getFileInfo(t);
            S(e, t, n, a, T.evaluateStaticBoolExpression(r, i.executionEnvironment, i.definedConstants), s);
          })(e, t.name, n, t.name.d.value, t.valueExpression, i);
          if (t.name.d.value === 'frozen') {
            s = true;
          }
        }
      });
      if (!s) {
        S(e, t, n, 'frozen', r.frozenDefault, i);
      }
    }
  },
  28445: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.UnresolvedModuleMarker = undefined;
    exports.isFunctionDeclaration = function (e) {
      return e.type === 5;
    };
    exports.isClassDeclaration = function (e) {
      return e.type === 6;
    };
    exports.isParamDeclaration = function (e) {
      return e.type === 2;
    };
    exports.isTypeParamDeclaration = function (e) {
      return e.type === 3;
    };
    exports.isTypeAliasDeclaration = function (e) {
      return e.type === 4;
    };
    exports.isVariableDeclaration = function (e) {
      return e.type === 1;
    };
    exports.isAliasDeclaration = r;
    exports.isSpecialBuiltInClassDeclaration = function (e) {
      return e.type === 7;
    };
    exports.isIntrinsicDeclaration = function (e) {
      return e.type === 0;
    };
    exports.isUnresolvedAliasDeclaration = function (e) {
      return r(e) && e.uri.equals(exports.UnresolvedModuleMarker);
    };
    const a = require(27113);
    function r(e) {
      return e.type === 8;
    }
    exports.UnresolvedModuleMarker = a.Uri.constant('*** unresolved module ***');
  },
  83760: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.hasTypeForDeclaration = function (e) {
      switch (e.type) {
        case 0:
        case 6:
        case 7:
        case 5:
        case 3:
        case 4:
          return true;
        case 2:
          {
            if (e.node.d.annotation || e.node.d.annotationComment) {
              return true;
            }
            const t = e.node.parent;
            if ((t == null ? undefined : t.nodeType) === 31 && t.d.funcAnnotationComment && !t.d.funcAnnotationComment.d.isEllipsis) {
              const n = t.d.funcAnnotationComment.d.paramAnnotations;
              return !(t.d.params.length > n.length) || e.node !== t.d.params[0];
            }
            return false;
          }
        case 1:
          return !!e.typeAnnotationNode;
        case 8:
          return false;
      }
    };
    exports.areDeclarationsSame = function (e, t, n = false, a = false) {
      if (e.type !== t.type) {
        return false;
      }
      if (!e.uri.equals(t.uri)) {
        return false;
      }
      if ((!a || e.type !== 8) && (e.range.start.line !== t.range.start.line || e.range.start.character !== t.range.start.character)) {
        return false;
      }
      if (e.type === 8 && t.type === 8) {
        if (e.symbolName !== t.symbolName || e.usesLocalName !== t.usesLocalName) {
          return false;
        }
        if (n) {
          return true;
        }
        if (e.node !== t.node) {
          return false;
        }
      }
      return true;
    };
    exports.getNameFromDeclaration = function (e) {
      var t;
      switch (e.type) {
        case 8:
          return e.symbolName;
        case 6:
        case 5:
        case 3:
        case 4:
          return e.node.d.name.d.value;
        case 2:
          if ((t = e.node.d.name) === null || t === undefined) {
            return undefined;
          } else {
            return t.d.value;
          }
        case 1:
          if (e.node.nodeType === 38) {
            return e.node.d.value;
          } else {
            return undefined;
          }
        case 0:
        case 7:
          if (e.node.nodeType === 54 && e.node.d.valueExpr.nodeType === 38) {
            return e.node.d.valueExpr.d.value;
          } else {
            return undefined;
          }
        default:
          a.assertNever(e);
      }
      throw new Error('Shouldn\'t reach here');
    };
    exports.getNameNodeForDeclaration = function (e) {
      var t;
      var n;
      switch (e.type) {
        case 8:
          if (e.node.nodeType === 24) {
            if ((t = e.node.d.alias) !== null && t !== undefined) {
              return t;
            } else {
              return e.node.d.module.d.nameParts[0];
            }
          } else {
            if (e.node.nodeType === 26) {
              if ((n = e.node.d.alias) !== null && n !== undefined) {
                return n;
              } else {
                return e.node.d.name;
              }
            } else {
              return e.node.d.module.d.nameParts[0];
            }
          }
        case 6:
        case 5:
        case 3:
        case 2:
        case 4:
          return e.node.d.name;
        case 1:
          if (e.node.nodeType === 38) {
            return e.node;
          } else {
            return undefined;
          }
        case 0:
        case 7:
          return;
        default:
          a.assertNever(e);
      }
      throw new Error('Shouldn\'t reach here');
    };
    exports.isDefinedInFile = function (e, t) {
      var n;
      if (s.isAliasDeclaration(e)) {
        if ((n = i.getFileInfoFromNode(e.node)) === null || n === undefined) {
          return undefined;
        } else {
          return n.fileUri.equals(t);
        }
      }
      return e.uri.equals(t);
    };
    exports.getDeclarationsWithUsesLocalNameRemoved = function (e) {
      return e.map(e => {
        if (e.type !== 8) {
          return e;
        }
        const t = {
          ...e
        };
        t.usesLocalName = false;
        return t;
      });
    };
    exports.synthesizeAliasDeclaration = function (e) {
      return {
        type: 8,
        node: undefined,
        uri: e,
        loadSymbolsFromPath: false,
        range: r.getEmptyRange(),
        implicitImports: new Map(),
        usesLocalName: false,
        moduleName: '',
        isInExceptSuite: false
      };
    };
    exports.resolveAliasDeclaration = function e(t, n, a) {
      let r = n;
      const s = [];
      let i;
      let o;
      let l = false;
      let p = false;
      while (true) {
        if (r.type !== 8 || !r.symbolName) {
          return {
            declaration: r,
            isPrivate: l,
            privatePyTypedImported: i,
            privatePyTypedImporter: o
          };
        }
        if (!a.resolveLocalNames && r.usesLocalName) {
          return {
            declaration: r,
            isPrivate: l,
            privatePyTypedImported: i,
            privatePyTypedImporter: o
          };
        }
        let d;
        if (!r.uri.isEmpty() && r.loadSymbolsFromPath) {
          d = t(r.uri, {
            skipFileNeededCheck: a.skipFileNeededCheck
          });
        }
        const c = d ? d.symbolTable.get(r.symbolName) : undefined;
        if (!c) {
          if (r.submoduleFallback) {
            if (r.symbolName && !r.uri.isEmpty() && r.submoduleFallback.type === 8 && !r.submoduleFallback.uri.isEmpty()) {
              if (!t(r.submoduleFallback.uri, {
                skipFileNeededCheck: a.skipFileNeededCheck,
                skipParsing: true
              })) {
                return;
              }
            }
            let n = r.submoduleFallback;
            if (r.symbolName) {
              n = {
                ...r.submoduleFallback
              };
              let e = n.moduleName;
              if (e) {
                e = `${e}.`;
              }
              n.moduleName = `${e}${r.symbolName}`;
            }
            return e(t, n, a);
          }
          if (r.isNativeLib) {
            return {
              declaration: undefined,
              isPrivate: l
            };
          } else {
            return undefined;
          }
        }
        if (c.isPrivateMember() && !p) {
          l = true;
        }
        if (c.isExternallyHidden() && !a.allowExternallyHiddenAccess) {
          return;
        }
        let u = c.getTypedDeclarations();
        u = u.filter(e => !e.isInExceptSuite);
        if (u.length === 0) {
          u = c.getDeclarations();
          u = u.filter(e => !e.isInExceptSuite);
        }
        if (u.length === 0) {
          u = c.getDeclarations();
        }
        if (u.length === 0) {
          return;
        }
        const m = r;
        const y = u.filter(e => !s.includes(e));
        r = y.length > 0 ? y[y.length - 1] : u[u.length - 1];
        if (d == null ? undefined : d.isInPyTypedPackage) {
          if (p) {
            if (!c.isPrivatePyTypedImport()) {
              i = i ?? (r == null ? undefined : r.moduleName);
            }
          } else {
            if (c.isPrivatePyTypedImport()) {
              o = m == null ? undefined : m.moduleName;
            }
            p = true;
          }
        }
        if (s.find(e => e === r)) {
          if (r.type === 8 && r.submoduleFallback) {
            return e(t, r.submoduleFallback, a);
          } else {
            return {
              declaration: n,
              isPrivate: l,
              privatePyTypedImported: i,
              privatePyTypedImporter: o
            };
          }
        }
        s.push(r);
      }
    };
    const a = require(48281);
    const r = require(88754);
    const s = require(28445);
    const i = require(41557);
  },
  26163: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getFunctionInfoFromDecorators = function (e, t, n) {
      const a = r.getFileInfo(t);
      let s;
      let i = 0;
      if (n) {
        if (t.d.name.d.value === '__new__') {
          i |= 1;
        }
        if (['__init_subclass__', '__class_getitem__'].some(e => t.d.name.d.value === e)) {
          i |= 2;
        }
      }
      for (const r of t.d.decorators) {
        let t = a.isStubFile ? 4 : 0;
        if (r.d.expr.nodeType !== 9) {
          t |= 2;
        }
        const o = e.getTypeOfExpression(r.d.expr, t).type;
        if (p.isFunction(o)) {
          if (p.FunctionType.isBuiltIn(o, 'abstractmethod')) {
            if (n) {
              i |= 8;
            }
          } else {
            if (p.FunctionType.isBuiltIn(o, 'final')) {
              i |= 8192;
            } else {
              if (p.FunctionType.isBuiltIn(o, 'override')) {
                i |= 262144;
              } else {
                if (p.FunctionType.isBuiltIn(o, 'type_check_only')) {
                  i |= 128;
                } else {
                  if (p.FunctionType.isBuiltIn(o, 'no_type_check')) {
                    i |= 524288;
                  } else {
                    if (p.FunctionType.isBuiltIn(o, 'overload')) {
                      i |= 256;
                    }
                  }
                }
              }
            }
          }
        } else {
          if (p.isClass(o)) {
            if (p.TypeBase.isInstantiable(o)) {
              if (p.ClassType.isBuiltIn(o, 'staticmethod')) {
                if (n) {
                  i |= 4;
                }
              } else {
                if (p.ClassType.isBuiltIn(o, 'classmethod') && n) {
                  i |= 2;
                }
              }
            } else {
              if (p.ClassType.isBuiltIn(o, 'deprecated')) {
                s = o.priv.deprecatedInstanceMessage;
              }
            }
          }
        }
      }
      return {
        flags: i,
        deprecationMessage: s
      };
    };
    exports.applyFunctionDecorator = function (e, t, n, a, i) {
      let c = r.getFileInfo(a).isStubFile ? 4 : 0;
      if (a.d.expr.nodeType !== 9) {
        c |= 2;
      }
      const u = e.getTypeOfExpression(a.d.expr, c).type;
      if ((p.isInstantiableClass(u) && p.ClassType.isSpecialBuiltIn(u, 'overload') || p.isFunction(u) && p.FunctionType.isBuiltIn(u, 'overload')) && p.isFunction(t)) {
        t.shared.flags |= 256;
        n.shared.flags |= 256;
        return t;
      }
      if (a.d.expr.nodeType === 9) {
        const r = e.getTypeOfExpression(a.d.expr.d.leftExpr, c | 2).type;
        if (p.isFunction(r) && (r.shared.name === '__dataclass_transform__' || p.FunctionType.isBuiltIn(r, 'dataclass_transform'))) {
          n.shared.decoratorDataClassBehaviors = s.validateDataClassTransformDecorator(e, a.d.expr);
          return t;
        }
      }
      let m = d(e, a, t);
      if (p.isFunction(u)) {
        if (p.FunctionType.isBuiltIn(u, 'abstractmethod')) {
          return t;
        }
        if (p.FunctionType.isBuiltIn(u, 'type_check_only')) {
          n.shared.flags |= 128;
          return t;
        }
        if (a.d.expr.nodeType === 35) {
          const n = e.getTypeOfExpression(a.d.expr.d.leftExpr, c | 2).type;
          if (l.isProperty(n)) {
            const r = a.d.expr.d.member.d.value;
            if (r === 'setter') {
              if (p.isFunction(t)) {
                o.validatePropertyMethod(e, t, a);
                return o.clonePropertyWithSetter(e, n, t, i);
              } else {
                return t;
              }
            }
            if (r === 'deleter') {
              if (p.isFunction(t)) {
                o.validatePropertyMethod(e, t, a);
                return o.clonePropertyWithDeleter(e, n, t, i);
              } else {
                return t;
              }
            }
          }
        }
      } else {
        if (p.isInstantiableClass(u)) {
          if (p.ClassType.isBuiltIn(u)) {
            switch (u.shared.name) {
              case 'classmethod':
              case 'staticmethod':
                {
                  const e = u.shared.name === 'classmethod' ? 2 : 4;
                  if (p.isFunction(t) && !(t.shared.flags & e)) {
                    const n = p.FunctionType.clone(t);
                    n.shared.flags &= -8;
                    n.shared.flags |= e;
                    return n;
                  }
                  return t;
                }
              case 'decorator':
                return t;
            }
          }
          if (p.ClassType.isPropertyClass(u)) {
            if (p.isFunction(t)) {
              o.validatePropertyMethod(e, t, a);
              return o.createProperty(e, a, u, t);
            }
            if (p.isClassInstance(t)) {
              const n = e.getBoundMagicMethod(t, '__call__');
              if (n && p.isFunction(n)) {
                return o.createProperty(e, a, u, n);
              } else {
                return p.UnknownType.create();
              }
            }
          }
        }
      }
      if (p.isFunction(t) && p.isFunction(m)) {
        m = p.FunctionType.clone(m);
        if (p.FunctionType.isOverloaded(t)) {
          m.shared.flags |= 256;
        }
        if (!m.shared.docString) {
          m.shared.docString = t.shared.docString;
        }
      }
      return m;
    };
    exports.applyClassDecorator = function (e, t, n, a) {
      let i = r.getFileInfo(a).isStubFile ? 4 : 0;
      if (a.d.expr.nodeType !== 9) {
        i |= 2;
      }
      const o = e.getTypeOfExpression(a.d.expr, i).type;
      if (a.d.expr.nodeType === 9) {
        const t = e.getTypeOfExpression(a.d.expr.d.leftExpr, i | 2).type;
        if (p.isFunction(t) && (t.shared.name === '__dataclass_transform__' || p.FunctionType.isBuiltIn(t, 'dataclass_transform'))) {
          n.shared.classDataClassTransform = s.validateDataClassTransformDecorator(e, a.d.expr);
        }
      }
      if (p.isOverloaded(o)) {
        const r = s.getDataclassDecoratorBehaviors(o);
        if (r) {
          s.applyDataClassDecorator(e, a, n, r, undefined);
          return t;
        }
      } else {
        if (p.isFunction(o)) {
          if (p.FunctionType.isBuiltIn(o, 'final')) {
            n.shared.flags |= 256;
            return t;
          }
          if (p.FunctionType.isBuiltIn(o, 'type_check_only')) {
            n.shared.flags |= 1048576;
            return t;
          }
          if (p.FunctionType.isBuiltIn(o, 'runtime_checkable')) {
            n.shared.flags |= 2048;
            return t;
          }
          let r;
          let l;
          if (a.d.expr.nodeType === 9) {
            l = a.d.expr;
            const t = e.getTypeOfExpression(l.d.leftExpr, i | 2).type;
            r = s.getDataclassDecoratorBehaviors(t);
          } else {
            const t = e.getTypeOfExpression(a.d.expr, i).type;
            r = s.getDataclassDecoratorBehaviors(t);
          }
          if (r) {
            s.applyDataClassDecorator(e, a, n, r, l);
            return t;
          }
        } else {
          if (p.isClassInstance(o) && p.ClassType.isBuiltIn(o, 'deprecated')) {
            n.shared.deprecatedMessage = o.priv.deprecatedInstanceMessage;
            return t;
          }
        }
      }
      return d(e, a, t);
    };
    exports.addOverloadsToFunctionType = function (e, t, n) {
      let s;
      let i;
      const o = r.getDeclaration(t);
      if (o) {
        s = o;
      }
      const l = e.lookUpSymbolRecursive(t, t.d.name.d.value, false);
      if (l) {
        const t = l.symbol.getDeclarations();
        const r = t.findIndex(e => e === s);
        if (r > 0) {
          for (let n = 0; n < r; n++) {
            const a = t[n];
            if (a.type === 5) {
              e.getTypeOfFunction(a.node);
            }
          }
          let s = [];
          const o = t[r - 1];
          if (o.type === 5) {
            const t = e.getTypeOfFunction(o.node);
            if (t) {
              if (p.isFunction(t.decoratedType)) {
                if (p.FunctionType.isOverloaded(t.decoratedType)) {
                  s.push(t.decoratedType);
                }
              } else {
                if (p.isOverloaded(t.decoratedType)) {
                  i = p.OverloadedType.getImplementation(t.decoratedType);
                  if (i) {
                    return n;
                  }
                  a.appendArray(s, p.OverloadedType.getOverloads(t.decoratedType));
                }
              }
            }
          }
          if (p.isFunction(n) && p.FunctionType.isOverloaded(n)) {
            s.push(n);
          } else {
            i = n;
          }
          if (s.length === 1 && !i) {
            return s[0];
          }
          if (s.length === 0 && i) {
            return i;
          }
          if (i && p.isFunction(i) && i.shared.docString) {
            const e = i.shared.docString;
            s = s.map(t => p.FunctionType.isOverloaded(t) && !t.shared.docString ? p.FunctionType.cloneWithDocString(t, e) : t);
          }
          if (i && p.isFunction(i) && i.shared.deprecatedMessage !== undefined) {
            const e = i.shared.deprecatedMessage;
            s = s.map(t => p.FunctionType.isOverloaded(t) && t.shared.deprecatedMessage === undefined ? p.FunctionType.cloneWithDeprecatedMessage(t, e) : t);
          }
          return p.OverloadedType.create(s, i);
        }
      }
      return n;
    };
    exports.getDeprecatedMessageFromCall = function (e) {
      if (e.d.args.length > 0 && e.d.args[0].d.argCategory === 0 && e.d.args[0].d.valueExpr.nodeType === 48) {
        const t = e.d.args[0].d.valueExpr.d.strings.map(e => e.d.value).join('');
        return i.convertDocStringToPlainText(t);
      }
      return '';
    };
    const a = require(58147);
    const r = require(26687);
    const s = require(57373);
    const i = require(12670);
    const o = require(89460);
    const l = require(92324);
    const p = require(21024);
    function d(e, t, n) {
      var a;
      var s;
      let i = r.getFileInfo(t).isStubFile ? 4 : 0;
      if (t.d.expr.nodeType !== 9) {
        i |= 2;
      }
      const o = e.getTypeOfExpression(t.d.expr, i);
      if (p.isInstantiableClass(o.type) && p.ClassType.isBuiltIn(o.type, 'classmethod') && l.isProperty(n)) {
        return n;
      }
      const d = [{
        argCategory: 0,
        typeResult: {
          type: n
        }
      }];
      const c = e.validateCallArgs(t.d.expr, d, o, undefined, true, undefined);
      e.setTypeResultForNode(t, {
        type: (a = c.returnType) !== null && a !== undefined ? a : p.UnknownType.create(),
        overloadsUsedForCall: c.overloadsUsedForCall,
        isIncomplete: c.isTypeIncomplete
      });
      const u = (s = c.returnType) !== null && s !== undefined ? s : p.UnknownType.create();
      if (!p.isFunction(u) || u.shared.declaredReturnType || u.shared.parameters.some((e, t) => !e.name || !!p.FunctionParam.isTypeDeclared(e) || e.category === 0 && (t !== 0 || !p.FunctionParam.isTypeInferred(e)))) {
        if (l.isPartlyUnknown(u) && p.isFunction(o.type) && !o.type.shared.parameters.find(e => p.FunctionParam.isTypeDeclared(e)) && o.type.shared.declaredReturnType === undefined) {
          return n;
        } else {
          return u;
        }
      } else {
        return n;
      }
    }
  },
  45579: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.deprecatedSpecialForms = exports.deprecatedAliases = undefined;
    const a = require(63808);
    exports.deprecatedAliases = new Map([['Tuple', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.tuple',
      replacementText: 'tuple'
    }], ['List', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.list',
      replacementText: 'list'
    }], ['Dict', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.dict',
      replacementText: 'dict'
    }], ['Set', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.set',
      replacementText: 'set'
    }], ['FrozenSet', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.frozenset',
      replacementText: 'frozenset'
    }], ['Type', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.type',
      replacementText: 'type'
    }], ['Deque', {
      version: a.pythonVersion3_9,
      fullName: 'collections.deque',
      replacementText: 'collections.deque'
    }], ['DefaultDict', {
      version: a.pythonVersion3_9,
      fullName: 'collections.defaultdict',
      replacementText: 'collections.defaultdict'
    }], ['OrderedDict', {
      version: a.pythonVersion3_9,
      fullName: 'collections.OrderedDict',
      replacementText: 'collections.OrderedDict',
      typingImportOnly: true
    }], ['Counter', {
      version: a.pythonVersion3_9,
      fullName: 'collections.Counter',
      replacementText: 'collections.Counter',
      typingImportOnly: true
    }], ['ChainMap', {
      version: a.pythonVersion3_9,
      fullName: 'collections.ChainMap',
      replacementText: 'collections.ChainMap',
      typingImportOnly: true
    }], ['Awaitable', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Awaitable',
      replacementText: 'collections.abc.Awaitable',
      typingImportOnly: true
    }], ['Coroutine', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Coroutine',
      replacementText: 'collections.abc.Coroutine',
      typingImportOnly: true
    }], ['AsyncIterable', {
      version: a.pythonVersion3_9,
      fullName: 'typing.AsyncIterable',
      replacementText: 'collections.abc.AsyncIterable',
      typingImportOnly: true
    }], ['AsyncIterator', {
      version: a.pythonVersion3_9,
      fullName: 'typing.AsyncIterator',
      replacementText: 'collections.abc.AsyncIterator',
      typingImportOnly: true
    }], ['AsyncGenerator', {
      version: a.pythonVersion3_9,
      fullName: 'typing.AsyncGenerator',
      replacementText: 'collections.abc.AsyncGenerator',
      typingImportOnly: true
    }], ['Iterable', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Iterable',
      replacementText: 'collections.abc.Iterable',
      typingImportOnly: true
    }], ['Iterator', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Iterator',
      replacementText: 'collections.abc.Iterator',
      typingImportOnly: true
    }], ['Generator', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Generator',
      replacementText: 'collections.abc.Generator',
      typingImportOnly: true
    }], ['Reversible', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Reversible',
      replacementText: 'collections.abc.Reversible',
      typingImportOnly: true
    }], ['Container', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Container',
      replacementText: 'collections.abc.Container',
      typingImportOnly: true
    }], ['Collection', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Collection',
      replacementText: 'collections.abc.Collection',
      typingImportOnly: true
    }], ['AbstractSet', {
      version: a.pythonVersion3_9,
      fullName: 'typing.AbstractSet',
      replacementText: 'collections.abc.Set',
      typingImportOnly: true
    }], ['MutableSet', {
      version: a.pythonVersion3_9,
      fullName: 'typing.MutableSet',
      replacementText: 'collections.abc.MutableSet',
      typingImportOnly: true
    }], ['Mapping', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Mapping',
      replacementText: 'collections.abc.Mapping',
      typingImportOnly: true
    }], ['MutableMapping', {
      version: a.pythonVersion3_9,
      fullName: 'typing.MutableMapping',
      replacementText: 'collections.abc.MutableMapping',
      typingImportOnly: true
    }], ['Sequence', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Sequence',
      replacementText: 'collections.abc.Sequence',
      typingImportOnly: true
    }], ['MutableSequence', {
      version: a.pythonVersion3_9,
      fullName: 'typing.MutableSequence',
      replacementText: 'collections.abc.MutableSequence',
      typingImportOnly: true
    }], ['ByteString', {
      version: a.pythonVersion3_9,
      fullName: 'typing.ByteString',
      replacementText: 'collections.abc.ByteString',
      typingImportOnly: true
    }], ['MappingView', {
      version: a.pythonVersion3_9,
      fullName: 'typing.MappingView',
      replacementText: 'collections.abc.MappingView',
      typingImportOnly: true
    }], ['KeysView', {
      version: a.pythonVersion3_9,
      fullName: 'typing.KeysView',
      replacementText: 'collections.abc.KeysView',
      typingImportOnly: true
    }], ['ItemsView', {
      version: a.pythonVersion3_9,
      fullName: 'typing.ItemsView',
      replacementText: 'collections.abc.ItemsView',
      typingImportOnly: true
    }], ['ValuesView', {
      version: a.pythonVersion3_9,
      fullName: 'typing.ValuesView',
      replacementText: 'collections.abc.ValuesView',
      typingImportOnly: true
    }], ['ContextManager', {
      version: a.pythonVersion3_9,
      fullName: 'typing.ContextManager',
      replacementText: 'contextlib.AbstractContextManager'
    }], ['AsyncContextManager', {
      version: a.pythonVersion3_9,
      fullName: 'typing.AsyncContextManager',
      replacementText: 'contextlib.AbstractAsyncContextManager'
    }], ['Pattern', {
      version: a.pythonVersion3_9,
      fullName: 're.Pattern',
      replacementText: 're.Pattern',
      typingImportOnly: true
    }], ['Match', {
      version: a.pythonVersion3_9,
      fullName: 're.Match',
      replacementText: 're.Match',
      typingImportOnly: true
    }]]);
    exports.deprecatedSpecialForms = new Map([['Optional', {
      version: a.pythonVersion3_10,
      fullName: 'typing.Optional',
      replacementText: '| None'
    }], ['Union', {
      version: a.pythonVersion3_10,
      fullName: 'typing.Union',
      replacementText: '|'
    }], ['Callable', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Callable',
      replacementText: 'collections.abc.Callable',
      typingImportOnly: true
    }]]);
  },
  12670: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.convertDocStringToMarkdown = function (e) {
      return new E(e).convert();
    };
    exports.convertDocStringToPlainText = function (e) {
      const t = a.cleanAndSplitDocString(e);
      const n = [];
      for (const e of t) {
        const t = n.length > 0 ? n[n.length - 1] : undefined;
        if (!O(e) || !O(t)) {
          n.push(e);
        }
      }
      return n.join('\n').trimEnd();
    };
    const a = require(81073);
    const r = /\S|$/;
    const s = /\S/;
    const i = /^\s*~~~+$/;
    const o = /^\s*\+\+\++$/;
    const l = /^\s*===+\s+===+$/;
    const p = /^\s*---+\s+---+$/;
    const d = /^(\s*)-\s/;
    const c = /^(\s*)\*\s/;
    const u = /^(\s*)\d+\.\s/;
    const m = /^(\s+\* )(.*)$/;
    const y = /^\s*\.\. /;
    const g = /^\s*\.\.\s+(.*)::\s*(.*)$/;
    const h = / *>>> /;
    const f = /^\s*:(param|arg|type|return|rtype|raise|except|var|ivar|cvar|copyright|license)/;
    const T = /^\.[\s\t]+(@\w)/gm;
    const v = /^(\.\s{3})|^(\.)/;
    const b = [{
      exp: /^\s*=+(\s+=+)+$/,
      replacement: '='
    }, {
      exp: /^\s*-+(\s+-+)+$/,
      replacement: '-'
    }, {
      exp: /^\s*~+(\s+-+)+$/,
      replacement: '~'
    }, {
      exp: /^\s*\++(\s+\++)+$/,
      replacement: '+'
    }];
    const _ = /\s/g;
    const C = /``/g;
    const I = /~/g;
    const k = /\+/g;
    const w = /(?<!\\)([_*~[\]])/g;
    const S = /(\[.*\]\(.*\))/g;
    const A = /^\s*(?<block>`{3}(?!`)|~{3}(?!~))(\w*)/;
    const x = /^\s*(?<block>`{3}(?!`)|~{3}(?!~))/;
    const P = [{
      exp: /</g,
      replacement: '&lt;'
    }, {
      exp: />/g,
      replacement: '&gt;'
    }];
    const D = '  \n';
    const N = /^\s*::$/;
    const F = [{
      exp: /\s+::$/g,
      replacement: ''
    }, {
      exp: /(\S)\s*::$/g,
      replacement: '$1:'
    }, {
      exp: /:[\w_\-+:.]+:`/g,
      replacement: '`'
    }, {
      exp: /`:[\w_\-+:.]+:/g,
      replacement: '`'
    }];
    class E {
      constructor(e) {
        this._builder = '';
        this._skipAppendEmptyLine = true;
        this._insideInlineCode = false;
        this._appendDirectiveBlock = false;
        this._stateStack = [];
        this._lineNum = 0;
        this._blockIndent = 0;
        this._state = this._parseText;
        this._input = e;
        this._lines = a.cleanAndSplitDocString(e);
      }
      convert() {
        for (T.test(this._input) && (this._lines = this._lines.map(e => e.replace(v, ''))); this._currentLineOrUndefined() !== undefined;) {
          const e = this._state;
          const t = this._lineNum;
          this._state();
          if (this._state === e && this._lineNum === t) {
            break;
          }
        }
        if (this._state === this._parseBacktickBlock || this._state === this._parseDocTest || this._state === this._parseLiteralBlock) {
          this._trimOutputAndAppendLine(this._lastBacktickString || '```');
        } else {
          if (this._insideInlineCode) {
            this._trimOutputAndAppendLine('`', true);
          }
        }
        return this._builder.trim();
      }
      _eatLine() {
        this._lineNum++;
      }
      _currentLineOrUndefined() {
        if (this._lineNum < this._lines.length) {
          return this._lines[this._lineNum];
        } else {
          return undefined;
        }
      }
      _currentLine() {
        return this._currentLineOrUndefined() || '';
      }
      _currentIndent() {
        return M(this._currentLine());
      }
      _prevIndent() {
        var e;
        return M((e = this._lineAt(this._lineNum - 1)) !== null && e !== undefined ? e : '');
      }
      _lineAt(e) {
        if (e < this._lines.length) {
          return this._lines[e];
        } else {
          return undefined;
        }
      }
      _nextBlockIndent() {
        return M(this._lines.slice(this._lineNum + 1).find(e => !O(e)) || '');
      }
      _currentLineIsOutsideBlock() {
        return this._currentIndent() < this._blockIndent;
      }
      _currentLineWithinBlock() {
        return this._currentLine().substr(this._blockIndent);
      }
      _pushAndSetState(e) {
        if (this._state === this._parseText) {
          this._insideInlineCode = false;
        }
        this._stateStack.push(this._state);
        this._state = e;
      }
      _popState() {
        this._state = this._stateStack.splice(0, 1)[0];
        if (this._state === this._parseText) {
          this._insideInlineCode = false;
        }
      }
      _parseText() {
        if (O(this._currentLineOrUndefined())) {
          this._state = this._parseEmpty;
          return;
        }
        if (this._beginBacktickBlock()) {
          return;
        }
        if (this._beginLiteralBlock()) {
          return;
        }
        if (this._beginDocTest()) {
          return;
        }
        if (this._beginDirective()) {
          return;
        }
        if (this._beginList()) {
          return;
        }
        if (this._beginFieldList()) {
          return;
        }
        if (this._beginTableBlock()) {
          return;
        }
        const e = this._formatPlainTextIndent(this._currentLine());
        this._appendTextLine(e);
        this._eatLine();
      }
      _formatPlainTextIndent(e) {
        const t = this._lineAt(this._lineNum - 1);
        const n = this._prevIndent();
        const a = this._currentIndent();
        if (!!(a > n) && !O(t) && !this._builder.endsWith(D) && !this._builder.endsWith('\n\n') && !z(t)) {
          this._builder = this._builder.slice(0, -1) + D;
        }
        if (n > a && !O(t) && !this._builder.endsWith(D) && !this._builder.endsWith('\n\n')) {
          this._builder = this._builder.slice(0, -1) + D;
        }
        return e = n === 0 || this._builder.endsWith(D) || this._builder.endsWith('\n\n') ? this._convertIndent(e) : e.trimStart();
      }
      _convertIndent(e) {
        return e = e.replace(/^([ \t]+)(.+)$/g, (e, t, n) => '&nbsp;'.repeat(t.length) + n);
      }
      _escapeHtml(e) {
        P.forEach(t => {
          e = e.replace(t.exp, t.replacement);
        });
        return e;
      }
      _appendTextLine(e) {
        const t = (e = this._preprocessTextLine(e)).split('`');
        for (let e = 0; e < t.length; e++) {
          let n = t[e];
          if (e > 0) {
            this._insideInlineCode = !this._insideInlineCode;
            this._append('`');
          }
          if (this._insideInlineCode) {
            this._append(n);
            continue;
          }
          n = this._escapeHtml(n);
          if (e === 0) {
            if (t.length === 1) {
              for (const e of b) {
                if (e.exp.test(n)) {
                  n = n.replace(_, e.replacement);
                  break;
                }
              }
              if (i.test(n)) {
                this._append(n.replace(I, '-'));
                continue;
              }
              if (o.test(n)) {
                this._append(n.replace(k, '-'));
                continue;
              }
            }
            const e = m.exec(n);
            if (e !== null && e.length === 3) {
              this._append(e[1]);
              n = e[2];
            }
          }
          n.split(S).forEach(e => {
            if (S.test(e)) {
              this._append(e);
            } else {
              this._append(e.replace(w, '\\$1'));
            }
          });
        }
        this._builder += '\n';
      }
      _preprocessTextLine(e) {
        if (N.test(e)) {
          return '';
        } else {
          F.forEach(t => e = e.replace(t.exp, t.replacement));
          return e = e.replace(C, '`');
        }
      }
      _parseEmpty() {
        if (O(this._currentLineOrUndefined())) {
          this._appendLine();
          this._eatLine();
          return;
        }
        this._state = this._parseText;
      }
      _beginMinIndentCodeBlock(e) {
        this._appendLine('```');
        this._pushAndSetState(e);
        this._blockIndent = this._currentIndent();
      }
      _beginBacktickBlock() {
        const e = this._currentLine().match(A);
        return e !== null && (this._blockIndent = this._currentIndent(), this._lastBacktickString = e[1], this._appendLine(e[1] + e[2]), this._pushAndSetState(this._parseBacktickBlock), this._eatLine(), true);
      }
      _parseBacktickBlock() {
        if (x.test(this._currentLine()) && this._currentIndent() === this._blockIndent) {
          const e = this._currentLine().match(x);
          this._lastBacktickString = e ? e[1] : '```';
          this._appendLine(this._lastBacktickString);
          this._appendLine();
          this._popState();
        } else {
          this._appendLine(this._currentLine());
        }
        this._eatLine();
      }
      _beginDocTest() {
        return !!h.test(this._currentLine()) && (this._beginMinIndentCodeBlock(this._parseDocTest), this._appendLine(this._currentLineWithinBlock()), this._eatLine(), true);
      }
      _parseDocTest() {
        if (this._currentLineIsOutsideBlock() || O(this._currentLine())) {
          this._trimOutputAndAppendLine('```');
          this._appendLine();
          this._popState();
          return;
        }
        this._appendLine(this._currentLineWithinBlock());
        this._eatLine();
      }
      _beginLiteralBlock() {
        const e = this._lineAt(this._lineNum - 1);
        if (e === undefined) {
          return false;
        }
        if (!O(e)) {
          return false;
        }
        let t = this._lineNum - 2;
        for (; t >= 0; t--) {
          const e = this._lineAt(t);
          if (!O(e)) {
            if (e.endsWith('::')) {
              break;
            }
            return false;
          }
        }
        return !(t < 0) && (this._currentIndent() === 0 ? (this._appendLine('```'), this._pushAndSetState(this._parseLiteralBlockSingleLine), true) : (this._beginMinIndentCodeBlock(this._parseLiteralBlock), true));
      }
      _parseLiteralBlock() {
        if (O(this._currentLineOrUndefined())) {
          this._appendLine();
          this._eatLine();
          return;
        }
        const e = this._lineAt(this._lineNum - 1);
        if (this._currentLineIsOutsideBlock() && O(e)) {
          this._trimOutputAndAppendLine('```');
          this._appendLine();
          this._popState();
          return;
        }
        this._appendLine(this._currentLine());
        this._eatLine();
      }
      _parseLiteralBlockSingleLine() {
        this._appendLine(this._currentLine());
        this._appendLine('```');
        this._appendLine();
        this._popState();
        this._eatLine();
      }
      _beginDirective() {
        return !!y.test(this._currentLine()) && (this._pushAndSetState(this._parseDirective), this._blockIndent = this._nextBlockIndent(), this._appendDirectiveBlock = false, true);
      }
      _beginFieldList() {
        if (this._insideInlineCode) {
          return false;
        }
        let e = this._currentLine();
        if (e.startsWith('@')) {
          this._appendLine();
          this._appendTextLine(e);
          this._eatLine();
          return true;
        }
        const t = !(e == null ? undefined : e.endsWith(':')) && !(e == null ? undefined : e.endsWith('::')) && !!e.match(/.*?\s*:\s*(.+)/gu);
        const n = f.test(e);
        if (t || n) {
          const t = this._lineAt(this._lineNum - 1);
          if (!this._builder.endsWith(D) && !this._builder.endsWith('\n\n') && !z(t)) {
            this._builder = this._builder.slice(0, -1) + D;
          }
          e = this._convertIndent(e);
          this._appendTextLine(e);
          this._eatLine();
          return true;
        }
        return false;
      }
      _beginTableBlock() {
        if (this._insideInlineCode) {
          return false;
        }
        const e = this._currentLine();
        return !!l.test(e) && (this._tableState = {
          header: e.trimStart(),
          inHeader: true
        }, this._eatLine(), this._pushAndSetState(this._parseTableBlock), true);
      }
      _parseTableBlock() {
        if (O(this._currentLineOrUndefined()) || !this._tableState) {
          this._tableState = undefined;
          this._popState();
          return;
        }
        let e = this._currentLine();
        if (l.test(e)) {
          this._eatLine();
          this._appendLine('\n<br/>\n');
          this._popState();
          this._tableState = undefined;
          return;
        }
        {
          let t = '|';
          const n = this._tableState.header.split(' ');
          const a = [];
          if (this._tableState.inHeader) {
            do {
              let t = 0;
              for (let r = 0; r < n.length; r++) {
                const s = n[r].length + 1;
                const i = e.slice(t, t + s);
                if (a[r] === undefined) {
                  a[r] = `${i} `;
                } else {
                  a[r] = a[r].concat(`<br>${i} `);
                }
                t += s;
              }
              this._eatLine();
              e = this._currentLine();
            } while (!O(this._currentLineOrUndefined()) && !p.test(e) && !l.test(e));
            this._tableState.inHeader = false;
            a.forEach(e => {
              t += `${e}|`;
            });
            this._appendLine(t);
            const r = e.trimStart().replace(/=/g, '-').replace(' ', '|');
            this._appendLine(`|${r}|`);
            this._eatLine();
          } else {
            let a = 0;
            n.forEach(n => {
              const r = n.length + 1;
              const s = e.slice(a, a + r);
              t += `${s}|`;
              a += r;
            });
            this._appendLine(t);
            this._eatLine();
          }
        }
      }
      _beginList() {
        if (this._insideInlineCode) {
          return false;
        }
        let e = this._currentLine();
        const t = d.exec(e);
        if ((t == null ? undefined : t.length) === 2) {
          if (t[1].length >= 4) {
            e = ' '.repeat(t[1].length / 2) + e.trimLeft();
          }
          this._appendTextLine(e);
          this._eatLine();
          if (this._state !== this._parseList) {
            this._pushAndSetState(this._parseList);
          }
          return true;
        }
        const n = c.exec(e);
        if ((n == null ? undefined : n.length) === 2) {
          if (n[1].length === 0) {
            e = e = ` ${e}`;
          } else {
            if (n[1].length >= 4) {
              e = ' '.repeat(n[1].length / 2) + e.trimLeft();
            }
          }
          this._appendTextLine(e);
          this._eatLine();
          if (this._state !== this._parseList) {
            this._pushAndSetState(this._parseList);
          }
          return true;
        }
        const a = u.exec(e);
        return (a == null ? undefined : a.length) === 2 && (this._appendTextLine(e), this._eatLine(), true);
      }
      _parseList() {
        if (O(this._currentLineOrUndefined()) || this._currentLineIsOutsideBlock()) {
          this._popState();
          return;
        }
        if (!this._beginList()) {
          const e = this._currentLine().trimStart();
          this._appendTextLine(e);
          this._eatLine();
        }
      }
      _parseDirective() {
        const e = g.exec(this._currentLine());
        if (e !== null && e.length === 3) {
          const t = e[1];
          const n = e[2];
          if (t === 'class') {
            this._appendDirectiveBlock = true;
            this._appendLine();
            this._appendLine('```');
            this._appendLine(n);
            this._appendLine('```');
            this._appendLine();
          } else {
            if (t === 'code-block') {
              this._appendDirectiveBlock = true;
              this._beginMinIndentCodeBlock(this._parseLiteralBlock);
              this._eatLine();
              return;
            }
          }
        }
        if (this._blockIndent === 0) {
          this._popState();
        } else {
          this._state = this._parseDirectiveBlock;
        }
        this._eatLine();
      }
      _parseDirectiveBlock() {
        if (O(this._currentLineOrUndefined()) || !this._currentLineIsOutsideBlock()) {
          if (this._appendDirectiveBlock) {
            this._appendTextLine(this._currentLine().trimLeft());
          }
          this._eatLine();
        } else {
          this._popState();
        }
      }
      _appendLine(e) {
        if (O(e)) {
          if (!this._skipAppendEmptyLine) {
            this._builder += '\n';
            this._skipAppendEmptyLine = true;
          }
        } else {
          this._builder += e + '\n';
          this._skipAppendEmptyLine = false;
        }
      }
      _append(e) {
        this._builder += e;
        this._skipAppendEmptyLine = false;
      }
      _trimOutputAndAppendLine(e, t = false) {
        this._builder = this._builder.trimRight();
        this._skipAppendEmptyLine = false;
        if (!t) {
          this._appendLine();
        }
        this._appendLine(e);
      }
    }
    function M(e) {
      return e.search(r);
    }
    function O(e) {
      return e === undefined || !s.test(e);
    }
    function z(e) {
      var t;
      var n;
      return e !== undefined && ((n = (t = e.match(/^\s*[#`~=-]{3,}/)) === null || t === undefined ? undefined : t.length) !== null && n !== undefined ? n : 0) > 0;
    }
  },
  81073: (module, exports) => {
    function n(e) {
      const t = e.replace(/\r/g, '').replace(/\t/g, '        ').split('\n');
      let n = Number.MAX_VALUE;
      t.forEach((e, a) => {
        if (t.length <= 1 || a > 0) {
          const t = e.trimLeft();
          if (t) {
            n = Math.min(n, e.length - t.length);
          }
        }
      });
      if (n >= Number.MAX_VALUE) {
        n = 0;
      }
      const a = [];
      for (t.forEach((e, t) => {
        if (t === 0) {
          a.push(e.trim());
        } else {
          a.push(e.substr(n).trimRight());
        }
      }); a.length > 0 && a[0].length === 0;) {
        a.shift();
      }
      while (a.length > 0 && a[a.length - 1].length === 0) {
        a.pop();
      }
      return a;
    }
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.cleanAndSplitDocString = n;
    exports.extractParameterDocumentation = function (e, t) {
      if (!e || !t) {
        return;
      }
      const a = n(e);
      for (const e of a) {
        const n = e.trim();
        let a = n.indexOf(`@param ${t}`);
        if (a >= 0) {
          return n.substr(a + 7);
        }
        a = n.indexOf(`:param ${t}`);
        if (a >= 0) {
          return n.substr(a + 7);
        }
        a = n.indexOf(t + ': ');
        if (a >= 0) {
          return n.substr(a);
        }
        a = n.indexOf(t + ' (');
        if (a >= 0) {
          return n.substr(a);
        }
      }
      return;
    };
  },
  21451: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.isEnumMetaclass = function (e) {
      return e.shared.mro.some(e => c.isClass(e) && c.ClassType.isBuiltIn(e, ['EnumMeta', 'EnumType']));
    };
    exports.isEnumClassWithMembers = function (e, t) {
      if (!c.isClass(t) || !c.ClassType.isEnumClass(t)) {
        return false;
      }
      let n = false;
      c.ClassType.getSymbolTable(t).forEach((a, r) => {
        const s = u(e, t, r);
        if (s && c.isClassInstance(s) && c.ClassType.isSameGenericClass(s, c.ClassType.cloneAsInstance(t))) {
          n = true;
        }
      });
      return n;
    };
    exports.createEnumType = function (e, t, n, a) {
      const r = s.getFileInfo(t);
      const l = y(n);
      if (a.length === 0) {
        return;
      }
      const p = a[0];
      if (p.argCategory !== 0 || !p.valueExpression || p.valueExpression.nodeType !== 48 || p.valueExpression.d.strings.length !== 1 || p.valueExpression.d.strings[0].nodeType !== 49) {
        return;
      }
      const u = p.valueExpression.d.strings.map(e => e.d.value).join('');
      const m = c.ClassType.createInstantiable(u, i.getClassFullName(t, r.moduleName, u), r.moduleName, r.fileUri, 4259840, i.getTypeSourceId(t), undefined, n.shared.effectiveMetaclass);
      m.shared.baseClasses.push(n);
      d.computeMroLinearization(m);
      const g = c.ClassType.getSymbolTable(m);
      g.set('__class__', o.Symbol.createWithType(68, m));
      if (a.length < 2) {
        return;
      }
      const h = a[1];
      if (h.argCategory !== 0 || !h.valueExpression) {
        return;
      }
      const f = e.getBuiltInType(t, 'int');
      if (!f || !c.isInstantiableClass(f)) {
        return;
      }
      const T = c.ClassType.cloneAsInstance(m);
      if (h.valueExpression.nodeType === 48) {
        if (!h.valueExpression.d.strings.every(e => e.nodeType === 49)) {
          return;
        }
        const e = h.valueExpression.d.strings.map(e => e.d.value).join('').trim().split(/[\s,]+/);
        for (const [t, n] of e.entries()) {
          if (!n) {
            return;
          }
          const e = c.ClassType.cloneWithLiteral(c.ClassType.cloneAsInstance(f), t + 1);
          const a = new c.EnumLiteral(m.shared.fullName, m.shared.name, n, e, l);
          const r = o.Symbol.createWithType(4, c.ClassType.cloneWithLiteral(T, a));
          g.set(n, r);
        }
        return m;
      }
      if (h.valueExpression.nodeType === 34 || h.valueExpression.nodeType === 52) {
        h.valueExpression.nodeType;
        const t = h.valueExpression.d.items;
        if (t.length === 0) {
          return;
        }
        let n = false;
        for (const [a, r] of t.entries()) {
          let t;
          let s;
          if (a === 0) {
            n = r.nodeType === 48;
          }
          if (r.nodeType === 48) {
            if (!n) {
              return;
            }
            t = r;
            s = c.ClassType.cloneWithLiteral(c.ClassType.cloneAsInstance(f), a + 1);
          } else {
            if (r.nodeType !== 52) {
              return;
            }
            if (n) {
              return;
            }
            if (r.d.items.length !== 2) {
              return;
            }
            t = r.d.items[0];
            s = e.getTypeOfExpression(r.d.items[1]).type;
          }
          if (t.nodeType !== 48 || t.d.strings.length !== 1 || t.d.strings[0].nodeType !== 49) {
            return;
          }
          const i = t.d.strings[0].d.value;
          const p = new c.EnumLiteral(m.shared.fullName, m.shared.name, i, s, l);
          const d = o.Symbol.createWithType(4, c.ClassType.cloneWithLiteral(T, p));
          g.set(i, d);
        }
      }
      if (h.valueExpression.nodeType === 18) {
        const t = h.valueExpression.d.items;
        if (t.length === 0) {
          return;
        }
        for (const n of t) {
          if (n.nodeType !== 20) {
            return;
          }
          const t = n.d.keyExpr;
          const a = e.getTypeOfExpression(n.d.valueExpr).type;
          if (t.nodeType !== 48 || t.d.strings.length !== 1 || t.d.strings[0].nodeType !== 49) {
            return;
          }
          const r = t.d.strings[0].d.value;
          const s = new c.EnumLiteral(m.shared.fullName, m.shared.name, r, a, l);
          const i = o.Symbol.createWithType(4, c.ClassType.cloneWithLiteral(T, s));
          g.set(r, i);
        }
      }
      return m;
    };
    exports.transformTypeForEnumMember = u;
    exports.isDeclInEnumClass = function (e, t) {
      const n = i.getEnclosingClass(t.node, true);
      if (!n) {
        return false;
      }
      const a = e.getTypeOfClass(n);
      if (!a) {
        return false;
      }
      return c.ClassType.isEnumClass(a.classType);
    };
    exports.getEnumDeclaredValueType = m;
    exports.getTypeOfEnumMember = function (e, t, n, r, s) {
      if (!c.ClassType.isEnumClass(n)) {
        return;
      }
      const i = u(e, n, r);
      if (i) {
        return {
          type: i,
          isIncomplete: s
        };
      }
      if (c.TypeBase.isInstantiable(n)) {
        return;
      }
      const o = n.priv.literalValue;
      if (r === 'name' || r === '_name_') {
        const i = d.lookUpClassMember(n, r);
        if (i && c.isClass(i.classType) && !c.ClassType.isBuiltIn(i.classType, 'Enum')) {
          return;
        }
        const l = e.getBuiltInType(t, 'str');
        if (!c.isInstantiableClass(l)) {
          return;
        }
        const u = e => c.ClassType.cloneAsInstance(c.ClassType.cloneWithLiteral(l, e.itemName));
        if (o) {
          a.assert(o instanceof c.EnumLiteral);
          return {
            type: u(o),
            isIncomplete: s
          };
        }
        const m = p.enumerateLiteralsForType(e, n);
        if (m && m.length > 0) {
          return {
            type: c.combineTypes(m.map(e => {
              const t = e.priv.literalValue;
              a.assert(t instanceof c.EnumLiteral);
              return u(t);
            })),
            isIncomplete: s
          };
        }
      }
      const l = m(e, n);
      if (r === 'value' || r === '_value_') {
        const t = d.lookUpClassMember(n, r);
        if (t && c.isClass(t.classType) && !c.ClassType.isBuiltIn(t.classType)) {
          return;
        }
        const i = n.shared.effectiveMetaclass;
        if (i && c.isClass(i) && !c.ClassType.isBuiltIn(i)) {
          return {
            type: l ?? c.AnyType.create(),
            isIncomplete: s
          };
        }
        const u = d.lookUpClassMember(n, '__new__', 4);
        const m = d.lookUpClassMember(n, '__init__', 4);
        if (u && c.isClass(u.classType) && !c.ClassType.isBuiltIn(u.classType)) {
          return {
            type: l ?? c.AnyType.create(),
            isIncomplete: s
          };
        }
        if (m && c.isClass(m.classType) && !c.ClassType.isBuiltIn(m.classType)) {
          return {
            type: l ?? c.AnyType.create(),
            isIncomplete: s
          };
        }
        if (o) {
          a.assert(o instanceof c.EnumLiteral);
          if (c.isAny(o.itemType)) {
            if (l) {
              return {
                type: l,
                isIncomplete: s
              };
            } else {
              return undefined;
            }
          } else {
            return {
              type: o.itemType,
              isIncomplete: s
            };
          }
        }
        const y = p.enumerateLiteralsForType(e, n);
        if (y && y.length > 0) {
          return {
            type: c.combineTypes(y.map(e => {
              const t = e.priv.literalValue;
              a.assert(t instanceof c.EnumLiteral);
              return t.itemType;
            })),
            isIncomplete: s
          };
        }
      }
      return;
    };
    exports.getEnumAutoValueType = function (e, t) {
      const n = i.getEnclosingClass(t);
      if (n) {
        const a = e.getTypeOfClass(n);
        if (a) {
          const n = e.getTypeOfBoundMember(t, c.ClassType.cloneAsInstance(a.classType), '_generate_next_value_');
          if (n && !n.typeErrors && c.isFunction(n.type) && n.classType && c.isClass(n.classType) && !c.ClassType.isBuiltIn(n.classType, 'Enum') && n.type.shared.declaredReturnType) {
            return n.type.shared.declaredReturnType;
          }
        }
      }
      return e.getBuiltInObject(t, 'int');
    };
    const a = require(48281);
    const r = require(63808);
    const s = require(26687);
    const i = require(41557);
    const o = require(58253);
    const l = require(12097);
    const p = require(18891);
    const d = require(92324);
    const c = require(21024);
    function u(e, t, n, a = false, i = 0) {
      var o;
      var p;
      var m;
      var g;
      var h;
      var f;
      var T;
      var v;
      if (i > c.maxTypeRecursionCount) {
        return;
      }
      i++;
      if (!c.ClassType.isEnumClass(t)) {
        return;
      }
      const b = d.lookUpClassMember(t, n);
      if (!b || !c.isClass(b.classType) || !c.ClassType.isEnumClass(b.classType)) {
        return;
      }
      const _ = b.symbol.getDeclarations();
      if (_.length < 1) {
        return;
      }
      const C = _[0];
      let I;
      let k;
      let w;
      let S = false;
      let A = false;
      if (C.node.nodeType === 38) {
        w = C.node;
      } else {
        if (C.node.nodeType !== 31 && C.node.nodeType !== 10) {
          return;
        }
        w = C.node.d.name;
      }
      if (((o = w.parent) === null || o === undefined ? undefined : o.nodeType) === 3 && w.parent.d.leftExpr === w) {
        S = true;
        I = w.parent.d.rightExpr;
      } else {
        if (((p = w.parent) === null || p === undefined ? undefined : p.nodeType) === 52 && ((m = w.parent.parent) === null || m === undefined ? undefined : m.nodeType) === 3) {
          S = true;
          A = true;
          I = w.parent.parent.d.rightExpr;
        } else {
          if (((g = w.parent) === null || g === undefined ? undefined : g.nodeType) === 54 && w.parent.d.valueExpr === w) {
            if (a) {
              S = true;
            }
            k = w.parent.d.annotation;
          }
        }
      }
      if (l.isSingleDunderName(n)) {
        return;
      }
      if (n === 'name' || n === 'value') {
        return;
      }
      const x = k ? e.getTypeOfAnnotation(k) : undefined;
      let P;
      if (I) {
        const t = s.getFileInfo(I).isStubFile ? 1 : undefined;
        P = e.getTypeOfExpression(I, t).type;
      }
      if ((I == null ? undefined : I.nodeType) === 38 && I.d.value !== n) {
        const n = u(e, t, I.d.value, false, i);
        if (n && c.isClassInstance(n) && c.ClassType.isSameGenericClass(n, c.ClassType.cloneAsInstance(b.classType)) && n.priv.literalValue !== undefined) {
          return n;
        }
      }
      if (C.node.nodeType === 31) {
        const t = e.getTypeOfFunction(C.node);
        if (t) {
          P = t.decoratedType;
        }
      } else {
        if (C.node.nodeType === 10) {
          const t = e.getTypeOfClass(C.node);
          if (t && (P = t.decoratedType, c.isInstantiableClass(P))) {
            const e = s.getFileInfo(C.node);
            S = r.PythonVersion.isLessThan(e.executionEnvironment.pythonVersion, r.pythonVersion3_13);
          }
        }
      }
      let D = (h = x ?? P) !== null && h !== undefined ? h : c.UnknownType.create();
      if (A) {
        D = (T = (f = e.getTypeOfIterator({
          type: D
        }, false, w, false)) === null || f === undefined ? undefined : f.type) !== null && T !== undefined ? T : c.UnknownType.create();
      }
      if (c.isClassInstance(D) && c.ClassType.getSymbolTable(D).get('__get__')) {
        return;
      }
      if (l.isPrivateName(n)) {
        return;
      }
      if (!c.findSubtype(D, e => !c.isFunction(e) && !c.isOverloaded(e))) {
        return;
      }
      if (!P && ((v = w.parent) === null || v === undefined ? undefined : v.nodeType) === 3 && w.parent.d.leftExpr === w) {
        P = e.getTypeOfExpression(w.parent.d.rightExpr, undefined, d.makeInferenceContext(x)).type;
      }
      if (P && c.isClassInstance(P) && c.ClassType.isBuiltIn(P)) {
        if (P.shared.fullName === 'enum.nonmember') {
          const t = P.priv.typeArgs && P.priv.typeArgs.length > 0 ? P.priv.typeArgs[0] : c.UnknownType.create();
          if (x && e.assignType(x, t)) {
            return x;
          } else {
            return t;
          }
        }
        if (P.shared.fullName === 'enum.member') {
          D = P.priv.typeArgs && P.priv.typeArgs.length > 0 ? P.priv.typeArgs[0] : c.UnknownType.create();
          S = true;
        }
      }
      if (!S) {
        return;
      }
      const N = new c.EnumLiteral(b.classType.shared.fullName, b.classType.shared.name, n, D, y(t));
      return c.ClassType.cloneAsInstance(c.ClassType.cloneWithLiteral(b.classType, N));
    }
    function m(e, t, n = false) {
      let a;
      const r = d.lookUpClassMember(t, '_value_', n ? 64 : 0);
      if (r && r.classType && c.isClass(r.classType) && !c.ClassType.isBuiltIn(r.classType, 'Enum')) {
        a = e.getTypeOfMember(r);
      }
      return a;
    }
    function y(e) {
      return e.shared.mro.some(e => c.isClass(e) && c.ClassType.isBuiltIn(e, 'ReprEnum'));
    }
  },
  39245: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.applyFunctionTransform = function (e, t, n, l, p) {
      if (i.isFunction(l) && l.shared.fullName === 'functools.total_ordering') {
        return function (e, t, n, l) {
          var p;
          if (n.length !== 1) {
            return l;
          }
          const d = (p = n[0].typeResult) === null || p === undefined ? undefined : p.type;
          if (!d || !i.isInstantiableClass(d) || d.priv.includeSubclasses) {
            return l;
          }
          const c = ['__lt__', '__le__', '__gt__', '__ge__'];
          const u = i.ClassType.cloneAsInstance(d);
          let m;
          const y = c.filter(e => {
            const t = o.lookUpObjectMember(u, e, 16);
            if (t && !m) {
              m = t;
            }
            return !t;
          });
          if (!m) {
            e.addDiagnostic(a.DiagnosticRule.reportGeneralTypeIssues, r.LocMessage.totalOrderingMissingMethod(), t);
            return l;
          }
          let g;
          const h = e.getTypeOfMember(m);
          if (i.isFunction(h) && h.shared.parameters.length >= 2 && i.FunctionParam.isTypeDeclared(h.shared.parameters[1])) {
            g = i.FunctionType.getParamType(h, 1);
          }
          if (!g) {
            const n = e.getBuiltInObject(t, 'object');
            if (!n || !i.isClassInstance(n)) {
              return l;
            }
            g = n;
          }
          const f = e.getBuiltInObject(t, 'bool');
          if (!f || !i.isClassInstance(f)) {
            return l;
          }
          const T = i.FunctionParam.create(0, o.synthesizeTypeVarForSelfCls(d, false), i.FunctionParamFlags.TypeDeclared, 'self');
          const v = i.FunctionParam.create(0, g, i.FunctionParamFlags.TypeDeclared, '__value');
          y.forEach(e => {
            const t = i.FunctionType.createSynthesizedInstance(e);
            i.FunctionType.addParam(t, T);
            i.FunctionType.addParam(t, v);
            t.shared.declaredReturnType = f;
            i.ClassType.getSymbolTable(d).set(e, s.Symbol.createWithType(4, t));
          });
          return l;
        }(e, t, n, p);
      }
      return p;
    };
    const a = require(65880);
    const r = require(67703);
    const s = require(58253);
    const i = require(21024);
    const o = require(92324);
  },
  75130: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ImportResolver = exports.supportedFileExtensions = undefined;
    exports.createImportedModuleDescriptor = I;
    exports.formatImportName = A;
    exports.getParentImportResolutionRoot = x;
    exports.getModuleNameFromPath = P;
    const i = require(58147);
    const o = require(12522);
    const l = require(4883);
    const p = require(54010);
    const d = require(63808);
    const c = require(71745);
    const u = __importStar(require(89740));
    const m = require(89740);
    const y = require(27113);
    const g = require(5884);
    const h = require(49969);
    const f = require(47610);
    const T = require(27670);
    const v = require(92031);
    const b = __importStar(require(16259));
    const _ = __importStar(require(12097));
    const C = require(12097);
    function I(e) {
      if (e.length === 0) {
        return {
          leadingDots: 0,
          nameParts: [],
          importedSymbols: new Set()
        };
      }
      let t = 0;
      let n = 0;
      for (; t < e.length && e[t] === '.'; t++) {
        n++;
      }
      return {
        leadingDots: n,
        nameParts: e.slice(t).split('.'),
        importedSymbols: new Set()
      };
    }
    const k = ['.pyd', '.so', '.dylib'];
    const w = ['.py', '.pyi'];
    exports.supportedFileExtensions = [...w, ...k];
    class S {
      constructor(e, t, n) {
        this.serviceProvider = e;
        this._configOptions = t;
        this.host = n;
        this._cachedImportResults = new Map();
        this._cachedModuleNameResults = new Map();
        this._cachedEntriesForPath = new Map();
        this._cachedFilesForPath = new Map();
        this._cachedDirExistenceForRoot = new Map();
        this.cachedParentImportResults = new T.ParentDirectoryCache(() => this.getPythonSearchPaths([]));
      }
      get fileSystem() {
        return this.serviceProvider.fs();
      }
      get tmp() {
        return this.serviceProvider.tmp();
      }
      get partialStubs() {
        return this.serviceProvider.tryGet(c.ServiceKeys.partialStubs);
      }
      static isSupportedImportSourceFile(e) {
        const t = e.lastExtension.toLowerCase();
        return w.some(e => t === e);
      }
      static isSupportedImportFile(e) {
        const n = e.lastExtension.toLowerCase();
        return exports.supportedFileExtensions.some(e => n === e);
      }
      invalidateCache() {
        var e;
        this._cachedImportResults = new Map();
        this._cachedModuleNameResults = new Map();
        this.cachedParentImportResults.reset();
        this._stdlibModules = undefined;
        this._invalidateFileSystemCache();
        if ((e = this.partialStubs) !== null && e !== undefined) {
          e.clearPartialStubs();
        }
      }
      resolveImport(e, t, n) {
        return this.resolveImportInternal(e, t, n);
      }
      getCompletionSuggestions(e, t, n) {
        const a = this._getCompletionSuggestionsStrict(e, t, n);
        if (n.leadingDots > 0) {
          return a;
        }
        const r = x(e, t.root);
        let s = e.getDirectory();
        while (this._shouldWalkUp(s, r, t) && s) {
          this._getCompletionSuggestionsAbsolute(e, t, s, n, a, false);
          s = this._tryWalkUp(s);
        }
        return a;
      }
      getConfigOptions() {
        return this._configOptions;
      }
      setConfigOptions(e) {
        this._configOptions = e;
        this.invalidateCache();
      }
      getSourceFilesFromStub(e, t, n) {
        const a = [];
        this._cachedImportResults.forEach(t => {
          t.forEach(t => {
            if (t.isStubFile && t.isImportFound && t.nonStubImportResult && t.resolvedUris[t.resolvedUris.length - 1].equals(e) && t.nonStubImportResult.isImportFound) {
              const e = t.nonStubImportResult.resolvedUris[t.nonStubImportResult.resolvedUris.length - 1];
              if (e.hasExtension('.py') || e.hasExtension('.pyi')) {
                a.push(e);
              }
            }
          });
        });
        if (a.length === 0) {
          const t = e.replaceExtension('.py');
          if (this.dirExistsCached(t)) {
            a.push(t);
          }
        }
        if (a.length === 0) {
          const n = this.getImportRoots(t);
          const r = [];
          for (const t of n) {
            if (e.isChild(t)) {
              const n = Array.from(t.getRelativePathComponents(e));
              if (n.length >= 1) {
                if (n[0].endsWith(l.stubsSuffix)) {
                  n[0] = n[0].slice(0, n[0].length - l.stubsSuffix.length);
                }
                r.push(n.join('/'));
              }
            }
          }
          for (const e of r) {
            for (const t of n) {
              let n = t.resolvePaths(e).replaceExtension('.py');
              if (this.fileExistsCached(n)) {
                a.push(n);
              } else {
                const e = n.stripExtension();
                if (e.pathEndsWith('__init__')) {
                  n = e.getDirectory().packageUri;
                  if (this.fileExistsCached(n)) {
                    a.push(n);
                  }
                } else {
                  n = e.initPyUri;
                  if (this.fileExistsCached(n)) {
                    a.push(n);
                  }
                }
              }
            }
          }
        }
        return a;
      }
      getModuleNameForImport(e, t, n = false, a = false) {
        var r;
        const s = i.getOrAdd(this._cachedModuleNameResults, (r = t.root) === null || r === undefined ? undefined : r.key, () => new Map());
        const o = `${n}.${a}.${e.key}`;
        return i.getOrAdd(s, o, () => this._getModuleNameForImport(e, t, n, a));
      }
      getTypeshedStdLibPath(e) {
        return this._getStdlibTypeshedPath(this._configOptions.typeshedPath, e.pythonVersion, e.pythonPlatform, []);
      }
      getTypeshedThirdPartyPath(e) {
        return this._getThirdPartyTypeshedPath(this._configOptions.typeshedPath, []);
      }
      isStdlibModule(e, t) {
        if (!this._stdlibModules) {
          this._stdlibModules = this._buildStdlibCache(this.getTypeshedStdLibPath(t), t);
        }
        return this._stdlibModules.has(e.nameParts.join('.'));
      }
      getImportRoots(e, t = false) {
        const n = [];
        const a = [];
        const r = this._getStdlibTypeshedPath(this._configOptions.typeshedPath, e.pythonVersion, e.pythonPlatform, n);
        if (r) {
          a.push(r);
        }
        if (e.root) {
          a.push(e.root);
        }
        i.appendArray(a, e.extraPaths);
        if (this._configOptions.stubPath) {
          a.push(this._configOptions.stubPath);
        }
        if (t) {
          const e = this._getThirdPartyTypeshedPath(this._configOptions.typeshedPath, n);
          if (e) {
            a.push(e.resolvePaths('...'));
          }
        } else {
          const e = this._getThirdPartyTypeshedPackageRoots(n);
          i.appendArray(a, e);
        }
        const s = this.getTypeshedPathEx(e, n);
        if (s) {
          a.push(s);
        }
        const o = this.getPythonSearchPaths(n);
        if (o.length > 0) {
          i.appendArray(a, o);
        }
        return a;
      }
      ensurePartialStubPackages(e) {
        var t;
        if (!this.partialStubs) {
          return false;
        }
        if (this.partialStubs.isPartialStubPackagesScanned(e)) {
          return false;
        }
        const n = this.partialStubs;
        const a = [];
        const r = [];
        const s = this.getTypeshedPathEx(e, a);
        i(this._configOptions.stubPath);
        i((t = e.root) !== null && t !== undefined ? t : this._configOptions.projectRoot);
        e.extraPaths.forEach(e => i(e));
        i(s);
        this.getPythonSearchPaths(a).forEach(e => i(e));
        this.partialStubs.processPartialStubPackages(r, this.getImportRoots(e), s);
        this._invalidateFileSystemCache();
        return true;
        function i(e) {
          if (e && !n.isPathScanned(e)) {
            r.push(e);
          }
        }
      }
      getPythonSearchPaths(e) {
        if (!this._cachedPythonSearchPaths) {
          const e = [];
          const t = (b.findPythonSearchPaths(this.fileSystem, this._configOptions, this.host, e) || []).map(e => this.fileSystem.realCasePath(e));
          this._cachedPythonSearchPaths = {
            paths: Array.from(new Set(t)),
            failureInfo: e
          };
        }
        e.push(...this._cachedPythonSearchPaths.failureInfo);
        return this._cachedPythonSearchPaths.paths;
      }
      getTypeshedStdlibExcludeList(e, t, n) {
        const a = this._getStdlibTypeshedPath(e, t, n, []);
        const r = [];
        if (a) {
          if (!this._cachedTypeshedStdLibModuleVersionInfo) {
            this._cachedTypeshedStdLibModuleVersionInfo = this._readTypeshedStdLibVersions(e, []);
          }
          this._cachedTypeshedStdLibModuleVersionInfo.forEach((e, s) => {
            let i = false;
            if (e.max !== undefined && d.PythonVersion.isGreaterThan(t, e.max)) {
              i = true;
            }
            if (n !== undefined) {
              const t = n.toLowerCase();
              if (e.supportedPlatforms && e.supportedPlatforms.every(e => e.toLowerCase() !== t)) {
                i = true;
              }
              if (e.unsupportedPlatforms && e.unsupportedPlatforms.some(e => e.toLowerCase() === t)) {
                i = true;
              }
            }
            if (i) {
              const e = a.combinePaths(...s.split('.'));
              r.push(e);
              const t = e.replaceExtension('.pyi');
              r.push(t);
            }
          });
          return r;
        } else {
          return r;
        }
      }
      getTypeshedPathEx(e, t) {}
      readdirEntriesCached(e) {
        const t = this._cachedEntriesForPath.get(e.key);
        if (t) {
          return t;
        }
        let n;
        try {
          n = this.fileSystem.readdirEntriesSync(e);
        } catch {
          n = [];
        }
        this._cachedEntriesForPath.set(e.key, n);
        return n;
      }
      resolveImportInternal(e, t, n) {
        const a = A(n);
        const r = this._resolveImportStrict(a, e, t, n, []);
        if (r.isImportFound || n.leadingDots > 0) {
          return r;
        }
        const s = e.getDirectory();
        const i = this.cachedParentImportResults.getImportResult(s, a, r);
        if (i) {
          return this.filterImplicitImports(i, n.importedSymbols);
        }
        const o = x(e, t.root);
        if (!this.cachedParentImportResults.checkValidPath(this.fileSystem, e, o)) {
          return r;
        }
        const l = [`Attempting to resolve using local imports: ${a}`];
        const p = {
          importPath: undefined
        };
        let d = s;
        while (this._shouldWalkUp(d, o, t) && d) {
          const r = this.resolveAbsoluteImport(e, d, t, n, a, l, undefined, undefined, false, true);
          this.cachedParentImportResults.checked(d, a, p);
          if (r.isImportFound) {
            p.importPath = d;
            this.cachedParentImportResults.add({
              importResult: r,
              path: d,
              importName: a
            });
            return this.filterImplicitImports(r, n.importedSymbols);
          }
          d = this._tryWalkUp(d);
        }
        if (d) {
          this.cachedParentImportResults.checked(d, a, p);
        }
        if (this._configOptions.verboseOutput) {
          const e = this.serviceProvider.console();
          l.forEach(t => e.log(t));
        }
        return r;
      }
      fileExistsCached(e) {
        const t = e.getDirectory();
        if (t.equals(e)) {
          return false;
        }
        const n = e.fileName;
        const a = this.readdirEntriesCached(t).find(e => e.name === n);
        if (a == null ? undefined : a.isFile()) {
          return true;
        }
        if (a == null ? undefined : a.isSymbolicLink()) {
          const t = g.tryRealpath(this.fileSystem, e);
          if (t && this.fileSystem.existsSync(t) && g.isFile(this.fileSystem, t)) {
            return true;
          }
        }
        return false;
      }
      dirExistsCached(e) {
        var t;
        var n;
        const a = e.getDirectory();
        if (a.equals(e)) {
          let a = this._cachedDirExistenceForRoot.get(e.key);
          if (a === undefined) {
            a = (n = (t = g.tryStat(this.fileSystem, e)) === null || t === undefined ? undefined : t.isDirectory()) !== null && n !== undefined && n;
            this._cachedDirExistenceForRoot.set(e.key, a);
          }
          return a;
        }
        const r = e.fileName;
        const s = this.readdirEntriesCached(a).find(e => e.name === r);
        if (s == null ? undefined : s.isDirectory()) {
          return true;
        }
        if (s == null ? undefined : s.isSymbolicLink()) {
          const t = g.tryRealpath(this.fileSystem, e);
          if (t && this.fileSystem.existsSync(t) && g.isDirectory(this.fileSystem, t)) {
            return true;
          }
        }
        return false;
      }
      addResultsToCache(e, t, n, a, r, s) {
        var o;
        const l = r && r.leadingDots > 0 ? e : undefined;
        i.getOrAdd(this._cachedImportResults, (o = t.root) === null || o === undefined ? undefined : o.key, () => new Map()).set(this._getImportCacheKey(l, n, s), a);
        return this.filterImplicitImports(a, r == null ? undefined : r.importedSymbols);
      }
      resolveAbsoluteImport(e, t, n, a, r, s, i = false, o = false, l = false, p = true, d = false) {
        if (p && l) {
          const e = this._resolveAbsoluteImport(t, n, a, r, s, i, false, true, true, true);
          if (e.packageDirectory && (!e.isNamespacePackage || e.isImportFound)) {
            return e;
          }
        }
        return this._resolveAbsoluteImport(t, n, a, r, s, i, o, false, p, d);
      }
      resolveImportEx(e, t, n, a, r = [], s = true) {}
      resolveNativeImportEx(e, t, n = []) {}
      getNativeModuleName(e) {
        if (N(e.lastExtension.toLowerCase())) {
          return p.stripFileExtension(e.fileName, true);
        }
      }
      filterImplicitImports(e, t) {
        if (t === undefined) {
          const t = Object.assign({}, e);
          t.filteredImplicitImports = new Map();
          return t;
        }
        if (t.size === 0) {
          return e;
        }
        if (e.implicitImports.size === 0) {
          return e;
        }
        const n = new Map();
        e.implicitImports.forEach(e => {
          if (t.has(e.name)) {
            n.set(e.name, e);
          }
        });
        if (n.size === e.implicitImports.size) {
          return e;
        }
        const a = Object.assign({}, e);
        a.filteredImplicitImports = n;
        return a;
      }
      _resolveImportStrict(e, t, n, a, r) {
        const s = o.matchFileSpecs(this._configOptions, t);
        const i = {
          importName: e,
          isRelative: false,
          isImportFound: false,
          isPartlyResolved: false,
          isNamespacePackage: false,
          isInitFilePresent: false,
          isStubPackage: false,
          importFailureInfo: r,
          resolvedUris: [],
          importType: 2,
          isStubFile: false,
          isNativeLib: false,
          implicitImports: new Map(),
          filteredImplicitImports: new Map(),
          nonStubImportResult: undefined
        };
        this.ensurePartialStubPackages(n);
        if (a.leadingDots > 0) {
          const i = this._lookUpResultsInCache(t, n, e, a, s);
          if (i) {
            return i;
          }
          const o = this._resolveRelativeImport(t, n, a, e, r);
          if (o) {
            o.isRelative = true;
            return this.addResultsToCache(t, n, e, o, a, s);
          }
        } else {
          const r = this._lookUpResultsInCache(t, n, e, a, s);
          if (r) {
            if (!r.isImportFound || !r.isNamespacePackage || !!this._isNamespacePackageResolved(a, r.implicitImports)) {
              return r;
            }
          }
          const o = this._resolveBestAbsoluteImport(t, n, a, true);
          if (o) {
            if (o.isStubFile) {
              o.nonStubImportResult = this._resolveBestAbsoluteImport(t, n, a, false) || i;
            }
            return this.addResultsToCache(t, n, e, o, a, s);
          }
        }
        return this.addResultsToCache(t, n, e, i, undefined, s);
      }
      _getCompletionSuggestionsStrict(e, t, n) {
        const a = [];
        const r = new Map();
        if (n.leadingDots > 0) {
          this._getCompletionSuggestionsRelative(e, t, n, r);
        } else {
          if (n.nameParts.length > 0) {
            this._getCompletionSuggestionsTypeshedPath(e, t, n, true, r);
          }
          if (t.root) {
            this._getCompletionSuggestionsAbsolute(e, t, t.root, n, r);
          }
          for (const a of t.extraPaths) {
            this._getCompletionSuggestionsAbsolute(e, t, a, n, r);
          }
          if (this._configOptions.stubPath) {
            this._getCompletionSuggestionsAbsolute(e, t, this._configOptions.stubPath, n, r);
          }
          this._getCompletionSuggestionsTypeshedPath(e, t, n, false, r);
          const s = this.getPythonSearchPaths(a);
          for (const a of s) {
            this._getCompletionSuggestionsAbsolute(e, t, a, n, r);
          }
        }
        return r;
      }
      _getModuleNameForImport(e, t, n, a) {
        let r;
        let s = 0;
        let i = false;
        let o = false;
        let l = false;
        const p = [];
        let d;
        const c = this._getStdlibTypeshedPath(this._configOptions.typeshedPath, t.pythonVersion, t.pythonPlatform, p);
        if (c && (r = P(c, e), r)) {
          const e = {
            leadingDots: 0,
            nameParts: r.split('.'),
            importedSymbols: undefined
          };
          if (this._isStdlibTypeshedStubValidForVersion(e, this._configOptions.typeshedPath, t.pythonVersion, t.pythonPlatform, [])) {
            return {
              moduleName: r,
              importType: s,
              isTypeshedFile: true,
              isLocalTypingsFile: i,
              isThirdPartyPyTypedPresent: o
            };
          }
        }
        if (t.root) {
          const n = D(t.root, e);
          if (n) {
            if (n.containsInvalidCharacters) {
              d = n.moduleName;
            } else {
              r = n.moduleName;
            }
          }
          s = 2;
        }
        for (const n of t.extraPaths) {
          const t = D(n, e);
          if (t) {
            if (t.containsInvalidCharacters) {
              d = t.moduleName;
            } else {
              const e = t.moduleName;
              if (!r || e && e.length < r.length) {
                r = e;
                s = 2;
              }
            }
          }
        }
        if (this._configOptions.stubPath) {
          const t = D(this._configOptions.stubPath, e);
          if (t) {
            if (t.containsInvalidCharacters) {
              d = t.moduleName;
            } else {
              const e = t.moduleName;
              if (!r || e && e.length < r.length) {
                r = e;
                s = 2;
                i = true;
              }
            }
          }
        }
        const u = this._getThirdPartyTypeshedPath(this._configOptions.typeshedPath, p);
        if (u) {
          const t = P(u, e, true);
          if (!r || t && t.length < r.length) {
            r = t;
            s = 1;
            l = true;
          }
        }
        const m = this.getTypeshedPathEx(t, p);
        if (m) {
          const t = P(m, e);
          if (!r || t && t.length < r.length) {
            r = t;
            s = 1;
            l = true;
          }
        }
        const y = this.getPythonSearchPaths(p);
        for (const t of y) {
          const n = D(t, e);
          if (n) {
            if (n.containsInvalidCharacters) {
              d = n.moduleName;
            } else {
              const e = n.moduleName;
              if (!r || e && e.length < r.length) {
                r = e;
                s = 1;
                l = false;
              }
            }
          }
        }
        if (a && s === 1) {
          const n = x(e, t.root);
          let a = e.getDirectory();
          while (this._shouldWalkUp(a, n, t)) {
            const e = this._getPyTypedInfo(a);
            if (e) {
              if (!e.isPartiallyTyped) {
                o = true;
              }
              break;
            }
            a = this._tryWalkUp(a);
          }
        }
        if (r) {
          return {
            moduleName: r,
            importType: s,
            isTypeshedFile: l,
            isLocalTypingsFile: i,
            isThirdPartyPyTypedPresent: o
          };
        } else {
          if (n && d) {
            return {
              moduleName: d,
              isTypeshedFile: l,
              importType: s,
              isLocalTypingsFile: i,
              isThirdPartyPyTypedPresent: o
            };
          } else {
            return {
              moduleName: '',
              isTypeshedFile: l,
              importType: 2,
              isLocalTypingsFile: i,
              isThirdPartyPyTypedPresent: o
            };
          }
        }
      }
      _invalidateFileSystemCache() {
        this._cachedEntriesForPath.clear();
        this._cachedFilesForPath.clear();
        this._cachedDirExistenceForRoot.clear();
      }
      _resolveAbsoluteImport(e, t, n, a, r, s, i, o, p, d) {
        if (o) {
          r.push(`Attempting to resolve stub package using root path '${e}'`);
        } else {
          r.push(`Attempting to resolve using root path '${e}'`);
        }
        const c = [];
        let u;
        let m;
        let g;
        let h = e;
        let f = false;
        let T = false;
        let v = false;
        let b = false;
        let _ = false;
        let C = new Map();
        if (n.nameParts.length === 0) {
          const e = h.initPyUri;
          const t = h.initPyiUri;
          if (p && this.fileExistsCached(t)) {
            r.push(`Resolved import with file '${t}'`);
            c.push(t);
            b = true;
          } else {
            if (this.fileExistsCached(e)) {
              r.push(`Resolved import with file '${e}'`);
              c.push(e);
            } else {
              r.push(`Partially resolved import with directory '${h}'`);
              c.push(y.Uri.empty());
              f = true;
            }
          }
          C = this._findImplicitImports(a, h, [e, t]);
        } else {
          for (let e = 0; e < n.nameParts.length; e++) {
            const s = e === 0;
            const g = e === n.nameParts.length - 1;
            h = h.combinePaths(n.nameParts[e]);
            if (o && s) {
              h = h.addPath(l.stubsSuffix);
              v = true;
            }
            const I = this.dirExistsCached(h);
            if (I) {
              if (s) {
                u = h;
              }
              const e = h.initPyUri;
              const t = h.initPyiUri;
              T = false;
              if (p && this.fileExistsCached(t)) {
                r.push(`Resolved import with file '${t}'`);
                c.push(t);
                if (g) {
                  b = true;
                }
                T = true;
              } else {
                if (this.fileExistsCached(e)) {
                  r.push(`Resolved import with file '${e}'`);
                  c.push(e);
                  T = true;
                }
              }
              if (!m && d) {
                m = this._getPyTypedInfo(h);
              }
              if (T) {
                if (!g) {
                  continue;
                }
                C = this._findImplicitImports(n.nameParts.join('.'), h, [e, t]);
                break;
              }
            }
            const k = h.packageUri;
            const w = h.packageStubUri;
            const S = h.getDirectory();
            if (p && this.fileExistsCached(w)) {
              r.push(`Resolved import with file '${w}'`);
              c.push(w);
              if (g) {
                b = true;
              }
            } else {
              if (this.fileExistsCached(k)) {
                r.push(`Resolved import with file '${k}'`);
                c.push(k);
              } else {
                if (i && this._findAndResolveNativeModule(S, h, t, a, n, r, c)) {
                  _ = true;
                  r.push(`Did not find file '${w}' or '${k}'`);
                } else {
                  if (I) {
                    if (!g) {
                      c.push(y.Uri.empty());
                      f = true;
                      m = undefined;
                      continue;
                    }
                    r.push(`Partially resolved import with directory '${h}'`);
                    c.push(y.Uri.empty());
                    if (g) {
                      C = this._findImplicitImports(a, h, [k, w]);
                      f = true;
                    }
                  }
                }
              }
            }
            if (!m && d) {
              m = this._getPyTypedInfo(S);
            }
            break;
          }
        }
        const I = c.length > 0 && c.length < n.nameParts.length;
        g = s ? c.length > 0 : c.length >= n.nameParts.length;
        return {
          importName: a,
          isRelative: false,
          isNamespacePackage: f,
          isInitFilePresent: T,
          isStubPackage: v,
          isImportFound: g,
          isPartlyResolved: I,
          importFailureInfo: r,
          importType: 2,
          resolvedUris: c,
          searchPath: e,
          isStubFile: b,
          isNativeLib: _,
          implicitImports: C,
          pyTypedInfo: m,
          filteredImplicitImports: C,
          packageDirectory: u
        };
      }
      _getImportCacheKey(e, t, n) {
        var a;
        return `${(a = e == null ? undefined : e.key) !== null && a !== undefined ? a : ''}-${t}-${n}`;
      }
      _lookUpResultsInCache(e, t, n, a, r) {
        var s;
        var i;
        const o = this._cachedImportResults.get((i = (s = t.root) === null || s === undefined ? undefined : s.key) !== null && i !== undefined ? i : '');
        if (!o) {
          return;
        }
        const l = a.leadingDots > 0 ? e : undefined;
        const p = o.get(this._getImportCacheKey(l, n, r));
        if (p) {
          return this.filterImplicitImports(p, a.importedSymbols);
        } else {
          return undefined;
        }
      }
      _isNamespacePackageResolved(e, t) {
        if (e.importedSymbols) {
          if (!Array.from(e.importedSymbols.keys()).some(e => t.has(e))) {
            return false;
          }
        } else {
          if (t.size === 0) {
            return false;
          }
        }
        return true;
      }
      _resolveBestAbsoluteImport(e, t, n, a) {
        const r = A(n);
        const s = [];
        if (a && this._configOptions.stubPath) {
          s.push(`Looking in stubPath '${this._configOptions.stubPath}'`);
          const i = this.resolveAbsoluteImport(e, this._configOptions.stubPath, t, n, r, s, undefined, false, true, a, false);
          if (i.isImportFound) {
            i.importType = 2;
            i.isLocalTypingsFile = true;
            if (!i.isNamespacePackage || !i.resolvedUris[i.resolvedUris.length - 1].isEmpty()) {
              return i;
            }
            if (this._isNamespacePackageResolved(n, i.implicitImports)) {
              return i;
            }
          }
        }
        let i;
        let o;
        if (t.root) {
          s.push(`Looking in root directory of execution environment '${t.root}'`);
          o = this.resolveAbsoluteImport(e, t.root, t, n, r, s, undefined, true, true, a, false);
          i = o;
        }
        for (const l of t.extraPaths) {
          s.push(`Looking in extraPath '${l}'`);
          o = this.resolveAbsoluteImport(e, l, t, n, r, s, undefined, true, true, a, false);
          i = this._pickBestImport(i, o, n);
        }
        if (a && n.nameParts.length > 0) {
          s.push('Looking for typeshed stdlib path');
          const e = this._findTypeshedPath(t, n, r, true, s);
          if (e) {
            e.isStdlibTypeshedFile = true;
            return e;
          }
        }
        const l = this.getPythonSearchPaths(s);
        if (l.length > 0) {
          for (const o of l) {
            s.push(`Looking in python search path '${o}'`);
            const l = this.resolveAbsoluteImport(e, o, t, n, r, s, false, true, true, a, true);
            if (l) {
              l.importType = 1;
              i = this._pickBestImport(i, l, n);
            }
          }
        } else {
          s.push('No python interpreter search path');
        }
        if (t.root !== this._getTypeshedRoot(this._configOptions.typeshedPath, s) && (i == null ? undefined : i.pyTypedInfo) && !i.isPartlyResolved) {
          return i;
        }
        const p = this.resolveImportEx(e, t, n, r, s, a);
        if (p) {
          return p;
        }
        if (a && n.nameParts.length > 0) {
          s.push('Looking for typeshed third-party path');
          const e = this._findTypeshedPath(t, n, r, false, s);
          if (e) {
            e.isThirdPartyTypeshedFile = true;
            i = this._pickBestImport(i, e, n);
          }
        }
        return i;
      }
      _pickBestImport(e, t, n) {
        if (!e) {
          return t;
        }
        if (!t) {
          return e;
        }
        if (t.isImportFound) {
          const a = e.resolvedUris.findIndex(e => !e.isEmpty());
          const r = t.resolvedUris.findIndex(e => !e.isEmpty());
          if (a !== r) {
            if (a < 0) {
              return t;
            } else {
              if (r < 0 || a < r) {
                return e;
              } else {
                return t;
              }
            }
          }
          if (!e.isImportFound) {
            return t;
          }
          if (e.isNamespacePackage && t.isNamespacePackage && n.importedSymbols && !this._isNamespacePackageResolved(n, e.implicitImports)) {
            if (this._isNamespacePackageResolved(n, t.implicitImports)) {
              return t;
            }
            if (e.isInitFilePresent && !t.isInitFilePresent) {
              return e;
            }
            if (!e.isInitFilePresent && t.isInitFilePresent) {
              return t;
            }
          }
          if (e.importType === 2 && t.importType === 1) {
            return e;
          }
          if (e.pyTypedInfo && !t.pyTypedInfo) {
            return e;
          }
          if (!e.pyTypedInfo && t.pyTypedInfo && e.importType === t.importType) {
            return t;
          }
          if (e.isStubFile && !t.isStubFile) {
            return e;
          }
          if (!e.isStubFile && t.isStubFile) {
            return t;
          }
          if (e.resolvedUris.length > t.resolvedUris.length) {
            return t;
          }
        } else {
          if (t.isPartlyResolved) {
            const n = e.resolvedUris.findIndex(e => !e.isEmpty());
            const a = t.resolvedUris.findIndex(e => !e.isEmpty());
            if (n !== a) {
              if (n < 0) {
                return t;
              } else {
                if (a < 0 || n < a) {
                  return e;
                } else {
                  return t;
                }
              }
            }
          }
        }
        return e;
      }
      _findTypeshedPath(e, t, n, a, r) {
        let s;
        r.push(`Looking for typeshed ${a ? b.stdLibFolderName : b.thirdPartyFolderName} path`);
        if (a) {
          const n = this._getStdlibTypeshedPath(this._configOptions.typeshedPath, e.pythonVersion, e.pythonPlatform, r, t);
          if (n) {
            s = [n];
          }
        } else {
          s = this._getThirdPartyTypeshedPackagePaths(t, r);
        }
        if (s) {
          for (const i of s) {
            if (this.dirExistsCached(i)) {
              const s = this.resolveAbsoluteImport(undefined, i, e, t, n, r);
              if (s.isImportFound) {
                let e = a ? 0 : 1;
                if (n === 'typing_extensions') {
                  e = 1;
                }
                s.importType = e;
                return s;
              }
            }
          }
        }
        r.push('Typeshed path not found');
      }
      _buildStdlibCache(e, t) {
        const n = new Set();
        if (e) {
          const a = (e, r) => {
            this.readdirEntriesCached(e).forEach(s => {
              if (s.isDirectory()) {
                const t = e.combinePaths(s.name);
                a(t, r ? `${r}.${s.name}` : s.name);
              } else {
                if (s.name.includes('.py')) {
                  const a = p.stripFileExtension(s.name);
                  if (!a.startsWith('_')) {
                    if (this._isStdlibTypeshedStubValidForVersion(I(a), e, t.pythonVersion, t.pythonPlatform, [])) {
                      n.add(r ? `${r}.${a}` : a);
                    }
                  }
                }
              }
            });
          };
          a(e, undefined);
        }
        return n;
      }
      _buildTypeshedThirdPartyPackageMap(e) {
        this._cachedTypeshedThirdPartyPackagePaths = new Map();
        if (e) {
          this.readdirEntriesCached(e).forEach(t => {
            if (t.isDirectory()) {
              const n = e.combinePaths(t.name);
              this.readdirEntriesCached(n).forEach(e => {
                if (e.name !== '@python2') {
                  if (e.isDirectory()) {
                    const t = this._cachedTypeshedThirdPartyPackagePaths.get(e.name);
                    if (t) {
                      t.push(n);
                    } else {
                      this._cachedTypeshedThirdPartyPackagePaths.set(e.name, [n]);
                    }
                  } else {
                    if (e.isFile() && e.name.endsWith('.pyi')) {
                      const t = p.stripFileExtension(e.name);
                      const a = this._cachedTypeshedThirdPartyPackagePaths.get(t);
                      if (a) {
                        a.push(n);
                      } else {
                        this._cachedTypeshedThirdPartyPackagePaths.set(t, [n]);
                      }
                    }
                  }
                }
              });
            }
          });
        }
        const t = Array.from(this._cachedTypeshedThirdPartyPackagePaths.values()).flatMap(e => e);
        this._cachedTypeshedThirdPartyPackageRoots = Array.from(new Set(t)).sort();
      }
      _getCompletionSuggestionsTypeshedPath(e, t, n, a, r) {
        const s = [];
        let i;
        if (a) {
          const e = this._getStdlibTypeshedPath(this._configOptions.typeshedPath, t.pythonVersion, t.pythonPlatform, s, n);
          if (e) {
            i = [e];
          }
        } else {
          i = this._getThirdPartyTypeshedPackagePaths(n, s, false);
          const e = this.getTypeshedPathEx(t, s);
          if (e) {
            i = i ?? [];
            i.push(e);
          }
        }
        if (i) {
          i.forEach(a => {
            if (this.dirExistsCached(a)) {
              this._getCompletionSuggestionsAbsolute(e, t, a, n, r);
            }
          });
        }
      }
      _getStdlibTypeshedPath(e, t, n, a, r) {
        const s = this._getTypeshedSubdirectory(true, e, a);
        if (!s || !r || this._isStdlibTypeshedStubValidForVersion(r, e, t, n, a)) {
          return s;
        }
      }
      _getThirdPartyTypeshedPath(e, t) {
        return this._getTypeshedSubdirectory(false, e, t);
      }
      _isStdlibTypeshedStubValidForVersion(e, t, n, a, r) {
        if (!this._cachedTypeshedStdLibModuleVersionInfo) {
          this._cachedTypeshedStdLibModuleVersionInfo = this._readTypeshedStdLibVersions(t, r);
        }
        for (let t = 1; t <= e.nameParts.length; t++) {
          const r = e.nameParts.slice(0, t);
          const s = this._cachedTypeshedStdLibModuleVersionInfo.get(r.join('.'));
          if (s) {
            if (d.PythonVersion.isLessThan(n, s.min)) {
              return false;
            }
            if (s.max !== undefined && d.PythonVersion.isGreaterThan(n, s.max)) {
              return false;
            }
            if (a !== undefined) {
              const e = a.toLowerCase();
              if (s.supportedPlatforms && s.supportedPlatforms.every(t => t.toLowerCase() !== e)) {
                return false;
              }
              if (s.unsupportedPlatforms && s.unsupportedPlatforms.some(t => t.toLowerCase() === e)) {
                return false;
              }
            }
          }
        }
        return true;
      }
      _readTypeshedStdLibVersions(e, t) {
        const n = new Map();
        const a = this._getTypeshedSubdirectory(true, e, t);
        if (a) {
          const e = a.combinePaths('VERSIONS');
          try {
            const a = this.fileSystem.statSync(e);
            if (a.size > 0 && a.size < 262144) {
              this.fileSystem.readFileSync(e, 'utf8').split(/\r?\n/).forEach(e => {
                const t = e.split('#')[0].split(';').map(e => e.trim());
                const a = t[0].split(':');
                if (a.length !== 2) {
                  return;
                }
                const r = a[1].split('-');
                if (r.length > 2) {
                  return;
                }
                const s = a[0].trim();
                if (!s) {
                  return;
                }
                let i = r[0].trim();
                if (i.endsWith('+')) {
                  i = i.substr(0, i.length - 1);
                }
                let o;
                let l;
                let p;
                let c = d.PythonVersion.fromString(i);
                if (!c) {
                  c = d.pythonVersion3_0;
                }
                if (r.length > 1) {
                  o = d.PythonVersion.fromString(r[1].trim());
                }
                const u = 'platforms=';
                let m = t.slice(1).find(e => e.startsWith(u));
                if (m) {
                  m = m.trim().substring(10);
                  const e = m.split(',');
                  for (let t of e) {
                    t = t.trim();
                    let e = false;
                    if (t.startsWith('!')) {
                      e = true;
                      t = t.substring(1);
                    }
                    if (e) {
                      p = p ?? [];
                      p.push(t);
                    } else {
                      l = l ?? [];
                      l.push(t);
                    }
                  }
                }
                n.set(s, {
                  min: c,
                  max: o,
                  supportedPlatforms: l,
                  unsupportedPlatforms: p
                });
              });
            } else {
              t.push('Typeshed stdlib VERSIONS file is unexpectedly large');
            }
          } catch (e) {
            t.push(`Could not read typeshed stdlib VERSIONS file: '${JSON.stringify(e)}'`);
          }
        }
        return n;
      }
      _getThirdPartyTypeshedPackagePaths(e, t, n = true) {
        const a = this._getThirdPartyTypeshedPath(this._configOptions.typeshedPath, t);
        if (!this._cachedTypeshedThirdPartyPackagePaths) {
          this._buildTypeshedThirdPartyPackageMap(a);
        }
        const r = e.nameParts.length > 0 ? e.nameParts[0] : '';
        if (n) {
          return this._cachedTypeshedThirdPartyPackagePaths.get(r);
        } else {
          if (r) {
            return i.flatten(i.getMapValues(this._cachedTypeshedThirdPartyPackagePaths, e => e.startsWith(r)));
          } else {
            return [];
          }
        }
      }
      _getThirdPartyTypeshedPackageRoots(e) {
        const t = this._getThirdPartyTypeshedPath(this._configOptions.typeshedPath, e);
        if (!this._cachedTypeshedThirdPartyPackagePaths) {
          this._buildTypeshedThirdPartyPackageMap(t);
        }
        return this._cachedTypeshedThirdPartyPackageRoots;
      }
      _getTypeshedRoot(e, t) {
        var n;
        if (this._cachedTypeshedRoot === undefined) {
          let t;
          if (e && this.dirExistsCached(e)) {
            t = e;
          }
          if (!t) {
            t = (n = b.getTypeShedFallbackPath(this.fileSystem)) !== null && n !== undefined ? n : y.Uri.empty();
          }
          this._cachedTypeshedRoot = t;
        }
        if (this._cachedTypeshedRoot.isEmpty()) {
          return undefined;
        } else {
          return this._cachedTypeshedRoot;
        }
      }
      _getTypeshedSubdirectory(e, t, n) {
        if (e) {
          if (this._cachedTypeshedStdLibPath !== undefined) {
            return this._cachedTypeshedStdLibPath;
          }
        } else {
          if (this._cachedTypeshedThirdPartyPath !== undefined) {
            return this._cachedTypeshedThirdPartyPath;
          }
        }
        let a = this._getTypeshedRoot(t, n);
        if (a !== undefined && (a = b.getTypeshedSubdirectory(a, e), this.dirExistsCached(a))) {
          if (e) {
            this._cachedTypeshedStdLibPath = a;
          } else {
            this._cachedTypeshedThirdPartyPath = a;
          }
          return a;
        }
      }
      _resolveRelativeImport(e, t, n, a, r) {
        r.push('Attempting to resolve relative import');
        const s = f.getDirectoryLeadingDotsPointsTo(e.getDirectory(), n.leadingDots);
        if (!s) {
          r.push(`Invalid relative path '${a}'`);
          return;
        }
        const i = this.resolveAbsoluteImport(e, s, t, n, a, r, false, true);
        if (i && i.isStubFile) {
          i.nonStubImportResult = this.resolveAbsoluteImport(e, s, t, n, a, r, false, true, false, false) || {
            importName: a,
            isRelative: true,
            isImportFound: false,
            isPartlyResolved: false,
            isNamespacePackage: false,
            isStubPackage: false,
            importFailureInfo: r,
            resolvedUris: [],
            importType: 2,
            isStubFile: false,
            isNativeLib: false,
            implicitImports: [],
            filteredImplicitImports: [],
            nonStubImportResult: undefined
          };
        }
        return i;
      }
      _getCompletionSuggestionsRelative(e, t, n, a) {
        const r = f.getDirectoryLeadingDotsPointsTo(e.getDirectory(), n.leadingDots);
        if (r) {
          this._getCompletionSuggestionsAbsolute(e, t, r, n, a);
        }
      }
      _getFilesInDirectory(e) {
        const t = this._cachedFilesForPath.get(e.key);
        if (t) {
          return t;
        }
        let n = [];
        try {
          const t = this.readdirEntriesCached(e);
          const a = t.filter(e => e.isFile());
          t.forEach(t => {
            var n;
            if (t.isSymbolicLink() && ((n = g.tryStat(this.fileSystem, e.combinePaths(t.name))) === null || n === undefined ? undefined : n.isFile())) {
              a.push(t);
            }
          });
          n = a.map(t => e.combinePaths(t.name));
        } catch {
          n = [];
        }
        this._cachedFilesForPath.set(e.key, n);
        return n;
      }
      _getCompletionSuggestionsAbsolute(e, t, n, a, r, s = true) {
        let i = n;
        const o = a.nameParts.map(e => e);
        if (a.hasTrailingDot) {
          o.push('');
        }
        const l = a.leadingDots;
        const p = o.slice(0, -1);
        if (o.length === 0) {
          this._addFilteredSuggestionsAbsolute(e, t, i, '', r, l, p, s);
        } else {
          for (let n = 0; n < o.length && (n === o.length - 1 && this._addFilteredSuggestionsAbsolute(e, t, i, o[n], r, l, p, s), i = i.combinePaths(o[n]), this.dirExistsCached(i)); n++);
        }
      }
      _addFilteredSuggestionsAbsolute(e, t, n, a, r, s, i, o) {
        const l = g.getFileSystemEntriesFromDirEntries(this.readdirEntriesCached(n), this.fileSystem, n);
        l.files.forEach(n => {
          const l = n.stripAllExtensions().fileName;
          if (S.isSupportedImportFile(n)) {
            if (l === '__init__') {
              return;
            }
            if (a && !u.isPatternInSymbol(a, l)) {
              return;
            }
            if (!this._isUniqueValidSuggestion(l, r) || !this._isResolvableSuggestion(l, s, i, e, t, o)) {
              return;
            }
            r.set(l, n);
          }
        });
        l.directories.forEach(n => {
          const l = n.fileName;
          if (a && !l.startsWith(a)) {
            return;
          }
          if (!this._isUniqueValidSuggestion(l, r) || !this._isResolvableSuggestion(l, s, i, e, t, o)) {
            return;
          }
          const p = n.initPyiUri;
          if (this.fileExistsCached(p)) {
            r.set(l, p);
            return;
          }
          const d = n.initPyUri;
          if (this.fileExistsCached(d)) {
            r.set(l, d);
          } else {
            r.set(l, y.Uri.empty());
          }
        });
      }
      _isResolvableSuggestion(e, t, n, a, r, s) {
        const i = {
          leadingDots: t,
          nameParts: [...n, e],
          importedSymbols: new Set()
        };
        let o;
        if (s) {
          const e = A(i);
          const t = [];
          o = this._resolveImportStrict(e, a, r, i, t);
        } else {
          o = this.resolveImportInternal(a, r, i);
        }
        return !!o && !!o.isImportFound && (!_.isPrivateOrProtectedName(e) || o.pyTypedInfo === undefined);
      }
      _isUniqueValidSuggestion(e, t) {
        return !t.has(e) && !/[.-]/.test(e) && (!C.isDunderName(e) || e === '__future__');
      }
      _findImplicitImports(e, t, n) {
        const a = new Map();
        const r = g.getFileSystemEntriesFromDirEntries(this.readdirEntriesCached(t), this.fileSystem, t);
        for (const t of r.files) {
          const r = t.lastExtension;
          let s;
          let i = false;
          if (r === '.py' || r === '.pyi') {
            s = p.stripFileExtension(t.fileName);
          } else {
            if (!N(r) || this.fileExistsCached(t.packageUri) || this.fileExistsCached(t.packageStubUri)) {
              continue;
            }
            s = t.stripAllExtensions().fileName;
            i = true;
          }
          if (!n.find(e => e.equals(t))) {
            const n = {
              isStubFile: t.hasExtension('.pyi'),
              isNativeLib: i,
              name: s,
              uri: t
            };
            const r = a.get(n.name);
            if (!r || !r.isStubFile) {
              if (i) {
                const a = t;
                const r = this.resolveNativeImportEx(a, `${e}.${s}`, []);
                if (r) {
                  n.uri = r;
                  n.isNativeLib = false;
                }
              }
              a.set(n.name, n);
            }
          }
        }
        for (const e of r.directories) {
          const t = e.initPyUri;
          const r = e.initPyiUri;
          let s;
          let i = false;
          if (this.fileExistsCached(r)) {
            i = true;
            s = r;
          } else {
            if (this.fileExistsCached(t)) {
              s = t;
            }
          }
          if (s && !n.find(e => e.equals(s))) {
            const t = {
              isStubFile: i,
              isNativeLib: false,
              name: e.fileName,
              uri: s,
              pyTypedInfo: this._getPyTypedInfo(e)
            };
            a.set(t.name, t);
          }
        }
        return a;
      }
      _getPyTypedInfo(e) {
        if (this.fileExistsCached(e.pytypedUri)) {
          return v.getPyTypedInfoForPyTypedFile(this.fileSystem, e.pytypedUri);
        }
      }
      _findAndResolveNativeModule(e, t, n, a, r, s, i) {
        let o = false;
        if (!n.skipNativeLibraries && this.dirExistsCached(e)) {
          const l = this._getFilesInDirectory(e);
          const p = t.fileName;
          const d = l.find(e => this._isNativeModuleFileName(p, e));
          if (d) {
            o = this._resolveNativeModuleWithStub(d, n, a, r, s, i);
            if (o) {
              s.push(`Resolved with native lib '${d.toUserVisibleString()}'`);
            }
          }
        }
        return o;
      }
      _resolveNativeModuleWithStub(e, t, n, a, r, s) {
        let i = n;
        if (a.leadingDots > 0) {
          const n = this.getModuleNameForImport(e, t);
          i = n.moduleName.length > 0 ? n.moduleName : i;
        }
        const o = this.resolveNativeImportEx(e, i, r);
        if (o) {
          r.push(`Resolved native import ${n} with stub '${o}'`);
          s.push(o);
          return false;
        } else {
          r.push(`Resolved import with file '${e}'`);
          s.push(e);
          return true;
        }
      }
      _isNativeModuleFileName(e, t) {
        const n = t.lastExtension.toLowerCase();
        const a = p.stripFileExtension(t.fileName, true);
        return N(n) && m.equateStringsCaseInsensitive(e, a);
      }
      _tryWalkUp(e) {
        if (!e || e.isEmpty() || e.isRoot()) {
          return;
        }
        const t = e.resolvePaths('..');
        if (t.equals(e)) {
          return undefined;
        } else {
          return t;
        }
      }
      _shouldWalkUp(e, t, n) {
        return e && !e.isEmpty() && (e.isChild(t) || e.equals(t) && F(n.root));
      }
    }
    function A(e) {
      return '.'.repeat(e.leadingDots) + e.nameParts.join('.');
    }
    function x(e, t) {
      if (F(t)) {
        return e.getDirectory();
      } else {
        return t;
      }
    }
    function P(e, t, n = false) {
      const a = D(e, t, n);
      if (a && !a.containsInvalidCharacters) {
        return a.moduleName;
      }
    }
    function D(e, t, n = false) {
      let a = t.stripExtension();
      if (N(t.lastExtension)) {
        a = a.stripExtension();
      }
      if (!a.startsWith(e)) {
        return;
      }
      if (a.pathEndsWith('__init__')) {
        a = a.getDirectory();
      }
      const r = Array.from(e.getRelativePathComponents(a));
      if (n) {
        if (r.length === 0) {
          return;
        }
        r.shift();
      }
      if (r.length === 0) {
        return;
      }
      if (r[0].endsWith(l.stubsSuffix)) {
        r[0] = r[0].substr(0, r[0].length - l.stubsSuffix.length);
      }
      const s = r.some(e => !h.Tokenizer.isPythonIdentifier(e));
      return {
        moduleName: r.join('.'),
        containsInvalidCharacters: s
      };
    }
    function N(e) {
      return k.some(t => t === e);
    }
    function F(e) {
      return !e || e.isEmpty() || y.Uri.isDefaultWorkspace(e);
    }
    exports.ImportResolver = S;
  },
  47610: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getImportGroup = h;
    exports.compareImportStatements = function (e, t) {
      const n = h(e);
      const a = h(t);
      if (n < a) {
        return -1;
      }
      if (n > a) {
        return 1;
      }
      if (e.moduleName < t.moduleName) {
        return -1;
      } else {
        return 1;
      }
    };
    exports.getTopLevelImports = function (e, t = false) {
      const n = {
        orderedImports: [],
        mapByFilePath: new Map()
      };
      let a = false;
      let r = false;
      e.d.statements.forEach(e => {
        if (e.nodeType === 47) {
          e.d.statements.forEach(e => {
            if (e.nodeType === 23) {
              r = true;
              (function (e, t, n) {
                e.d.list.forEach(a => {
                  const r = m.getImportInfo(a.d.module);
                  let s;
                  if (r && r.isImportFound) {
                    s = r.resolvedUris[r.resolvedUris.length - 1];
                  }
                  const i = {
                    node: e,
                    subnode: a,
                    importResult: r,
                    resolvedPath: s,
                    moduleName: C(a.d.module),
                    followsNonImportStatement: n
                  };
                  t.orderedImports.push(i);
                  if (s && !s.isEmpty()) {
                    if (!t.mapByFilePath.has(s.key)) {
                      t.mapByFilePath.set(s.key, i);
                    }
                  }
                });
              })(e, n, a);
              a = false;
            } else {
              if (e.nodeType === 25) {
                r = true;
                (function (e, t, n, a) {
                  var r;
                  const s = m.getImportInfo(e.d.module);
                  let i;
                  if (s && s.isImportFound) {
                    i = s.resolvedUris[s.resolvedUris.length - 1];
                  }
                  if (a && s) {
                    t.implicitImports = (r = t.implicitImports) !== null && r !== undefined ? r : new Map();
                    for (const n of s.implicitImports.values()) {
                      const a = e.d.imports.find(e => e.d.name.d.value === n.name);
                      if (a) {
                        t.implicitImports.set(n.uri.key, a);
                      }
                    }
                  }
                  const o = {
                    node: e,
                    importResult: s,
                    resolvedPath: i,
                    moduleName: C(e.d.module),
                    followsNonImportStatement: n
                  };
                  t.orderedImports.push(o);
                  if (i && !i.isEmpty()) {
                    const e = t.mapByFilePath.get(i.key);
                    if (!e || e.node.nodeType === 23 || e.moduleName.length > o.moduleName.length) {
                      t.mapByFilePath.set(i.key, o);
                    }
                  }
                })(e, n, a, t);
                a = false;
              } else {
                a = r;
              }
            }
          });
        } else {
          a = r;
        }
      });
      return n;
    };
    exports.getTextEditsForAutoImportSymbolAddition = function (e, t, n) {
      const a = [];
      if (!t.node || t.node.nodeType !== 25 || t.node.d.isWildcardImport) {
        return a;
      }
      const r = t.node;
      if ((e = (Array.isArray(e) ? e : [e]).filter(e => !!e.name && !r.d.imports.some(t => {
        var n;
        return t.d.name.d.value === e.name && ((n = t.d.alias) === null || n === undefined ? undefined : n.d.value) === e.alias;
      }))).length === 0) {
        return a;
      }
      for (const r of e) {
        a.push(v(r.name, r.alias, t.node, n));
      }
      const s = o.createMapFromItems(a, e => d.Range.print(e.range));
      const i = [];
      for (const e of s.values()) {
        if (e.length === 1) {
          i.push(e[0]);
        } else {
          i.push({
            range: e[0].range,
            replacementText: e.sort((e, t) => T(e.importName, t.importName)).map(e => e.replacementText).join('')
          });
        }
      }
      return i;
    };
    exports.getTextEditsForAutoImportInsertions = function (e, t, n, a) {
      const r = [];
      if ((e = Array.isArray(e) ? e : [e]).length === 0) {
        return [];
      }
      const s = o.createMapFromItems(e, e => {
        return `${e.module.moduleName}-${e.nameForImportFrom ?? ''}`;
      });
      for (const e of s.values()) {
        o.appendArray(r, _(e, {
          name: e[0].module.moduleName,
          nameForImportFrom: e[0].nameForImportFrom
        }, t, I(e[0].module), n, a));
      }
      return b(n, r);
    };
    exports.getTextEditsForAutoImportInsertion = function (e, t, n, a, r, s) {
      const i = _(e, t, n, a, r, s);
      return b(r, i);
    };
    exports.getContainingImportStatement = function (e, t) {
      while (e && (i.throwIfCancellationRequested(t), e.nodeType !== 23 && e.nodeType !== 25)) {
        e = e.parent;
      }
      return e;
    };
    exports.getAllImportNames = function (e) {
      if (e.nodeType === 23) {
        return e.d.list;
      }
      return e.d.imports;
    };
    exports.getImportGroupFromModuleNameAndType = I;
    exports.getTextRangeForImportNameDeletion = function (e, t, ...n) {
      const a = [];
      for (const r of function (e) {
        if (e.length === 0) {
          return [];
        }
        if (e.length === 1) {
          return [{
            start: e[0],
            end: e[0]
          }];
        }
        const t = [];
        let n = e[0];
        let a = n;
        for (const r of e) {
          if (a !== r) {
            if (a + 1 !== r) {
              t.push({
                start: n,
                end: a
              });
              n = r;
              a = r;
            } else {
              a = r;
            }
          }
        }
        t.push({
          start: n,
          end: a
        });
        return t;
      }(n)) {
        const n = t[r.start];
        const s = t[r.end];
        if (r.start === 0 && t.length === r.end + 1) {
          a.push(d.TextRange.fromBounds(n.start, d.TextRange.getEnd(s)));
        } else {
          if (r.end === t.length - 1) {
            const i = t[r.start - 1];
            a.push(...k(e, i, n, s));
          } else {
            const e = n.start;
            const s = t[r.end + 1].start - e;
            a.push({
              start: e,
              length: s
            });
          }
        }
      }
      return a;
    };
    exports.getRelativeModuleName = function (e, t, n, a, r = false, s) {
      let i;
      let o = t;
      if (s = s !== undefined ? s : u.isFile(e, t)) {
        o = t.getDirectory();
      }
      let l = n;
      if (a.stubPath && l.isChild(a.stubPath) || a.typeshedPath && l.isChild(a.typeshedPath)) {
        return;
      }
      if (s) {
        l = n.getDirectory();
        const e = n.stripAllExtensions().fileName;
        if (e !== '__init__') {
          i = e;
        } else {
          if (r) {
            i = l.fileName;
            l = l.getDirectory();
          }
        }
      }
      const p = o.getRelativePathComponents(l);
      let d = '.';
      for (let e = 0; e < p.length; e++) {
        const t = p[e];
        d += t === '..' ? '.' : t;
        if (t !== '..' && e !== p.length - 1) {
          d += '.';
        }
      }
      if (i) {
        d = d[d.length - 1] === '.' ? d + i : d + '.' + i;
      }
      return d;
    };
    exports.getDirectoryLeadingDotsPointsTo = function (e, t) {
      let n = e;
      for (let e = 1; e < t; e++) {
        if (n.isRoot()) {
          return;
        }
        n = n.getDirectory();
      }
      return n;
    };
    exports.getResolvedFilePath = function (e) {
      if (!e || !e.isImportFound || e.resolvedUris.length === 0) {
        return;
      }
      if (e.resolvedUris.length === 1 && e.resolvedUris[0].equals(c.Uri.empty())) {
        if (e.packageDirectory) {
          return e.packageDirectory;
        } else {
          if (e.searchPath) {
            return e.searchPath;
          } else {
            return undefined;
          }
        }
      }
      return e.resolvedUris[e.resolvedUris.length - 1];
    };
    exports.haveSameParentModule = function (e, t) {
      if (e.length !== t.length) {
        return false;
      }
      let n = 0;
      for (n = 0; n < e.length - 1 && e[n] === t[n]; n++);
      return n === e.length - 1;
    };
    const i = require(91426);
    const o = require(58147);
    const l = require(56814);
    const p = require(89740);
    const d = require(88754);
    const c = require(27113);
    const u = require(5884);
    const m = __importStar(require(26687));
    const y = require(41557);
    const g = __importStar(require(12097));
    function h(e) {
      if (e.importResult) {
        if (e.importResult.importType === 0) {
          return 0;
        } else {
          if (e.importResult.importType === 1 || e.importResult.isLocalTypingsFile) {
            return 1;
          } else {
            if (e.importResult.isRelative) {
              return 3;
            } else {
              return 2;
            }
          }
        }
      } else {
        return 2;
      }
    }
    function f(e) {
      if (g.isConstantName(e)) {
        return 0;
      } else {
        if (g.isTypeAliasName(e)) {
          return 1;
        } else {
          return 2;
        }
      }
    }
    function T(e, t) {
      const n = f(e) - f(t);
      if (n !== 0) {
        return n;
      }
      const a = e.replace(/_/g, '=');
      const r = t.replace(/_/g, '=');
      return p.compareStringsCaseSensitive(a, r);
    }
    function v(e, t, n, a) {
      let r;
      for (const t of n.d.imports) {
        if (T(t.d.name.d.value, e) > 0) {
          break;
        }
        r = t;
      }
      let s = false;
      let i = '';
      if (n.d.imports.length > 0) {
        const e = l.convertOffsetToPosition(n.start, a.tokenizerOutput.lines);
        const t = l.convertOffsetToPosition(n.d.imports[0].start, a.tokenizerOutput.lines);
        const r = n.d.imports.length > 1 ? l.convertOffsetToPosition(n.d.imports[1].start, a.tokenizerOutput.lines) : undefined;
        if (t.line > e.line && (r === undefined || r.line > t.line)) {
          const e = a.tokenizerOutput.lines.getItemAt(t.line);
          i = a.text.substr(e.start, t.character);
          if (/^\s*$/.test(i)) {
            s = true;
          }
        }
      }
      const o = r ? d.TextRange.getEnd(r) : n.d.imports.length > 0 ? n.d.imports[0].start : n.start + n.length;
      const p = l.convertOffsetToPosition(o, a.tokenizerOutput.lines);
      const c = t ? `${e} as ${t}` : `${e}`;
      let u;
      if (s) {
        const e = a.tokenizerOutput.predominantEndOfLineSequence;
        u = r ? `,${e}${i}${c}` : `${c},${e}${i}`;
      } else {
        u = r ? `, ${c}` : `${c}, `;
      }
      return {
        range: {
          start: p,
          end: p
        },
        importName: e,
        replacementText: u
      };
    }
    function b(e, t) {
      if (t.length < 2) {
        return t.map(e => r(e));
      }
      const n = [...o.createMapFromItems(t, e => `${e.importGroup} ${d.Range.print(e.range)}`)].sort((e, t) => p.compareStringsCaseSensitive(e[0], t[0])).map(e => e[1]);
      const a = [];
      for (const t of n) {
        if (t.length === 1) {
          a.push(r(t[0]));
        } else {
          a.push({
            range: t[0].range,
            replacementText: t[0].preChange + t.map(e => e.importStatement).sort((e, t) => s(e, t)).join(e.tokenizerOutput.predominantEndOfLineSequence) + t[0].postChange
          });
        }
      }
      return a;
      function r(e) {
        return {
          range: e.range,
          replacementText: e.preChange + e.importStatement + e.postChange
        };
      }
      function s(e, t) {
        const n = e.startsWith('import');
        if (n === t.startsWith('import')) {
          if (e < t) {
            return -1;
          } else {
            return 1;
          }
        } else {
          if (n) {
            return -1;
          } else {
            return 1;
          }
        }
      }
    }
    function _(e, t, n, a, r, s) {
      const i = [];
      if ((e = Array.isArray(e) ? e : [e]).length === 0) {
        e.push({});
      }
      const p = o.createMapFromItems(e, e => e.name ? 'from' : 'import');
      const c = p.get('import');
      if (c) {
        m(c, e => `import ${e.join(', ')}`);
      }
      const u = p.get('from');
      if (u) {
        m(u, e => {
          var n;
          return `from ${(n = t.nameForImportFrom) !== null && n !== undefined ? n : t.name} import ${e.join(', ')}`;
        });
      }
      return i;
      function m(e, p) {
        const c = e.map(e => function (e, t) {
          const n = e.name ? e.name : t;
          return {
            sortText: n,
            text: e.alias ? `${n} as ${e.alias}` : n
          };
        }(e, t.name)).sort((e, t) => T(e.sortText, t.sortText)).reduce((e, t) => o.addIfUnique(e, t.text), []);
        i.push(function (e, t, n, a, r, s) {
          let i;
          let o = '';
          let p = '';
          const c = l.convertPositionToOffset(s, r.tokenizerOutput.lines);
          if (t.orderedImports.length > 0 && c > t.orderedImports[0].node.start) {
            let e = true;
            let s = t.orderedImports[0];
            let c = 0;
            for (const i of t.orderedImports) {
              const l = i.importResult ? h(i) : c;
              if (a < l) {
                if (!e && c < a) {
                  o = r.tokenizerOutput.predominantEndOfLineSequence + o;
                }
                break;
              }
              if (a === l && i.moduleName > n) {
                e = true;
                s = i;
                break;
              }
              if (i.followsNonImportStatement) {
                if (a > c) {
                  o = r.tokenizerOutput.predominantEndOfLineSequence + o;
                }
                break;
              }
              if (i === t.orderedImports[t.orderedImports.length - 1] && a > l) {
                o = r.tokenizerOutput.predominantEndOfLineSequence + o;
              }
              e = !e && a < c && a === l;
              c = l;
              s = i;
            }
            if (s) {
              if (e) {
                p += r.tokenizerOutput.predominantEndOfLineSequence;
              } else {
                o = r.tokenizerOutput.predominantEndOfLineSequence + o;
              }
              i = l.convertOffsetToPosition(e ? s.node.start : d.TextRange.getEnd(s.node), r.tokenizerOutput.lines);
            } else {
              i = {
                line: 0,
                character: 0
              };
            }
          } else {
            i = {
              line: 0,
              character: 0
            };
            let e = false;
            for (const t of r.parserOutput.parseTree.d.statements) {
              let n = true;
              if (t.nodeType === 47 && t.d.statements.length === 1) {
                const e = t.d.statements[0];
                if (e.nodeType === 48 || e.nodeType === 3 && e.d.leftExpr.nodeType === 38 && g.isDunderName(e.d.leftExpr.d.value)) {
                  n = false;
                }
              }
              if (n) {
                i = l.convertOffsetToPosition(t.start, r.tokenizerOutput.lines);
                e = false;
                break;
              }
              i = l.convertOffsetToPosition(t.start + t.length, r.tokenizerOutput.lines);
              e = true;
            }
            p = p + r.tokenizerOutput.predominantEndOfLineSequence + r.tokenizerOutput.predominantEndOfLineSequence;
            if (e) {
              o = r.tokenizerOutput.predominantEndOfLineSequence + o;
            } else {
              p += r.tokenizerOutput.predominantEndOfLineSequence;
            }
          }
          return {
            range: {
              start: i,
              end: i
            },
            preChange: o,
            importStatement: e,
            postChange: p,
            importGroup: a
          };
        }(p(c), n, t.name, a, r, s));
      }
    }
    function C(e) {
      let t = '';
      for (let n = 0; n < e.d.leadingDots; n++) {
        t += '.';
      }
      t += e.d.nameParts.map(e => e.d.value).join('.');
      return t;
    }
    function I(e) {
      let t = 2;
      if (e.isLocalTypingsFile || e.importType === 1) {
        t = 1;
      } else {
        if (e.importType === 0) {
          t = 0;
        }
      }
      return t;
    }
    function k(e, t, n, a) {
      const r = d.TextRange.getEnd(t);
      const s = y.getTokenAt(e.tokenizerOutput.tokens, n.start);
      if (!s || !s.comments || s.comments.length === 0) {
        return [{
          start: r,
          length: d.TextRange.getEnd(a) - r
        }];
      }
      const i = y.findTokenAfter(e.tokenizerOutput, d.TextRange.getEnd(t), e => e.type === 12);
      if (!i) {
        return [{
          start: r,
          length: d.TextRange.getEnd(a) - r
        }];
      }
      const o = d.TextRange.getEnd(i) - r;
      const l = d.TextRange.getEnd(s.comments[s.comments.length - 1]);
      return [{
        start: r,
        length: o
      }, {
        start: l,
        length: d.TextRange.getEnd(a) - l
      }];
    }
  },
  60055: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createNamedTupleType = function (e, t, n, a) {
      var r;
      var s;
      var d;
      const v = c.getFileInfo(t);
      let b = 'namedtuple';
      const _ = new Set();
      let C = false;
      if (!a) {
        const e = n.find(e => {
          var t;
          return e.argCategory === 0 && ((t = e.name) === null || t === undefined ? undefined : t.d.value) === 'rename';
        });
        if (e == null ? undefined : e.valueExpression) {
          if (m.evaluateStaticBoolExpression(e.valueExpression, v.executionEnvironment, v.definedConstants) === true) {
            C = true;
          }
        }
      }
      if (n.length === 0) {
        e.addDiagnostic(i.DiagnosticRule.reportCallIssue, p.LocMessage.namedTupleFirstArg(), t);
      } else {
        const a = n[0];
        if (a.argCategory !== 0) {
          e.addDiagnostic(i.DiagnosticRule.reportArgumentType, p.LocMessage.namedTupleFirstArg(), n[0].valueExpression || t);
        } else {
          if (a.valueExpression && a.valueExpression.nodeType === 48) {
            b = a.valueExpression.d.strings.map(e => e.d.value).join('');
          }
        }
      }
      const I = n.find(e => {
        var t;
        return ((t = e.name) === null || t === undefined ? undefined : t.d.value) === 'defaults';
      });
      let k = 0;
      if (I && I.valueExpression) {
        const t = e.getTypeOfExpression(I.valueExpression).type;
        k = h.isClassInstance(t) && g.isTupleClass(t) && !g.isUnboundedTupleClass(t) && t.priv.tupleTypeArgs ? t.priv.tupleTypeArgs.length : undefined;
      }
      const w = e.getTypingType(t, 'NamedTuple') || h.UnknownType.create();
      const S = h.ClassType.createInstantiable(b, u.getClassFullName(t, v.moduleName, b), v.moduleName, v.fileUri, 4194304, u.getTypeSourceId(t), undefined, h.isInstantiableClass(w) ? w.shared.effectiveMetaclass : h.UnknownType.create());
      S.shared.baseClasses.push(w);
      S.shared.typeVarScopeId = u.getScopeIdForNode(t);
      const A = h.ClassType.getSymbolTable(S);
      A.set('__class__', y.Symbol.createWithType(68, S));
      const x = g.synthesizeTypeVarForSelfCls(S, true);
      const P = h.FunctionType.createSynthesizedInstance('__new__', 1);
      P.shared.declaredReturnType = g.convertToInstance(x);
      P.priv.constructorTypeVarScopeId = g.getTypeVarScopeId(S);
      if (u.isAssignmentToDefaultsFollowingNamedTuple(t)) {
        P.shared.flags |= 32;
      }
      P.shared.typeVarScopeId = S.shared.typeVarScopeId;
      h.FunctionType.addParam(P, h.FunctionParam.create(0, x, h.FunctionParamFlags.TypeDeclared, 'cls'));
      const D = [];
      const N = h.FunctionParam.create(0, g.synthesizeTypeVarForSelfCls(S, false), h.FunctionParamFlags.TypeDeclared, 'self');
      let F = false;
      const E = [];
      if (n.length < 2) {
        e.addDiagnostic(i.DiagnosticRule.reportCallIssue, p.LocMessage.namedTupleSecondArg(), t);
        F = true;
      } else {
        const t = n[1];
        if (t.argCategory !== 0) {
          F = true;
        } else {
          if (!a && t.valueExpression && t.valueExpression.nodeType === 48) {
            const n = t.valueExpression.d.strings.map(e => e.d.value).join('').split(/[,\s]+/);
            const a = k === undefined ? 0 : Math.max(0, n.length - k);
            n.forEach((n, r) => {
              if (n = n.trim()) {
                n = T(e, n, C, t.valueExpression, r);
                const s = h.UnknownType.create();
                const i = h.FunctionParam.create(0, s, h.FunctionParamFlags.TypeDeclared, n, r >= a ? s : undefined);
                h.FunctionType.addParam(P, i);
                const p = y.Symbol.createWithType(8, s);
                D.push(n);
                const d = t.valueExpression;
                const c = {
                  type: 1,
                  node: d,
                  isRuntimeTypeExpression: true,
                  uri: v.fileUri,
                  range: o.convertOffsetsToRange(d.start, l.TextRange.getEnd(d), v.lines),
                  moduleName: v.moduleName,
                  isInExceptSuite: false
                };
                p.addDeclaration(c);
                A.set(n, p);
                E.push(s);
              }
            });
          } else {
            if (((r = t.valueExpression) === null || r === undefined ? undefined : r.nodeType) === 34 || ((s = t.valueExpression) === null || s === undefined ? undefined : s.nodeType) === 52) {
              const n = t.valueExpression;
              const r = new Map();
              if ((d = t.valueExpression) !== null && d !== undefined) {
                d.nodeType;
              }
              const s = t.valueExpression.d.items;
              const c = k === undefined ? 0 : Math.max(0, s.length - k);
              s.forEach((t, n) => {
                let s;
                let d;
                let u;
                let m = '';
                if (a) {
                  if (t.nodeType === 52 && t.d.items.length === 2) {
                    u = t.d.items[0];
                    s = t.d.items[1];
                    d = g.convertToInstance(e.getTypeOfExpressionExpectingType(s).type);
                  } else {
                    e.addDiagnostic(i.DiagnosticRule.reportArgumentType, p.LocMessage.namedTupleNameType(), t);
                  }
                } else {
                  u = t;
                  d = h.UnknownType.create();
                }
                if (u) {
                  const t = e.getTypeOfExpression(u);
                  if (h.isClassInstance(t.type) && h.ClassType.isBuiltIn(t.type, 'str') && g.isLiteralType(t.type)) {
                    m = t.type.priv.literalValue;
                    if (m) {
                      m = T(e, m, C, u, n);
                    } else {
                      e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, p.LocMessage.namedTupleEmptyName(), u);
                    }
                  } else {
                    F = true;
                  }
                } else {
                  F = true;
                }
                if (!m) {
                  m = `_${n.toString()}`;
                }
                if (r.has(m)) {
                  e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, p.LocMessage.namedTupleNameUnique(), u || t);
                }
                r.set(m, m);
                if (!d) {
                  d = h.UnknownType.create();
                }
                const f = h.FunctionParam.create(0, d, a ? h.FunctionParamFlags.TypeDeclared : h.FunctionParamFlags.None, m, n >= c ? d : undefined);
                h.FunctionType.addParam(P, f);
                E.push(d);
                D.push(m);
                const b = y.Symbol.createWithType(2056, d);
                if (u && u.nodeType === 48) {
                  const e = {
                    type: 1,
                    node: u,
                    uri: v.fileUri,
                    typeAnnotationNode: s,
                    range: o.convertOffsetsToRange(u.start, l.TextRange.getEnd(u), v.lines),
                    moduleName: v.moduleName,
                    isInExceptSuite: false
                  };
                  b.addDeclaration(e);
                }
                A.set(m, b);
                _.add(m);
              });
              e.setTypeResultForNode(n, {
                type: h.UnknownType.create()
              });
            } else {
              F = true;
            }
          }
          if (t.valueExpression && !F) {
            e.setTypeResultForNode(t.valueExpression, {
              type: h.AnyType.create()
            });
          }
        }
      }
      S.shared.namedTupleEntries = _;
      if (F) {
        P.shared.parameters = [];
        h.FunctionType.addDefaultParams(P);
        E.push(h.AnyType.create(false));
        E.push(h.AnyType.create(true));
      }
      const M = h.FunctionType.createSynthesizedInstance('__init__');
      h.FunctionType.addParam(M, N);
      h.FunctionType.addDefaultParams(M);
      M.shared.declaredReturnType = e.getNoneType();
      M.priv.constructorTypeVarScopeId = g.getTypeVarScopeId(S);
      A.set('__new__', y.Symbol.createWithType(4, P));
      A.set('__init__', y.Symbol.createWithType(4, M));
      const O = h.FunctionType.createSynthesizedInstance('__len__');
      O.shared.declaredReturnType = e.getBuiltInObject(t, 'int');
      h.FunctionType.addParam(O, N);
      A.set('__len__', y.Symbol.createWithType(4, O));
      if (F) {
        const n = h.FunctionType.createSynthesizedInstance('__getattribute__');
        n.shared.declaredReturnType = h.AnyType.create();
        h.FunctionType.addParam(n, N);
        h.FunctionType.addParam(n, h.FunctionParam.create(0, e.getBuiltInObject(t, 'str'), h.FunctionParamFlags.TypeDeclared, 'name'));
        A.set('__getattribute__', y.Symbol.createWithType(4, n));
      }
      const z = e.getBuiltInType(t, 'tuple');
      const U = e.getBuiltInType(t, 'str');
      if (!F && U && h.isInstantiableClass(U) && z && h.isInstantiableClass(z)) {
        const e = D.map(e => ({
          type: h.ClassType.cloneAsInstance(h.ClassType.cloneWithLiteral(U, e)),
          isUnbounded: false
        }));
        const t = h.ClassType.cloneAsInstance(g.specializeTupleClass(z, e));
        A.set('__match_args__', y.Symbol.createWithType(4, t));
      }
      f(S, E, !F);
      g.computeMroLinearization(S);
      return S;
    };
    exports.updateNamedTupleBaseClass = f;
    const i = require(65880);
    const o = require(56814);
    const l = require(88754);
    const p = require(67703);
    const d = require(49969);
    const c = require(26687);
    const u = __importStar(require(41557));
    const m = require(28676);
    const y = require(58253);
    const g = require(92324);
    const h = require(21024);
    function f(e, t, n) {
      let a = false;
      e.shared.baseClasses = e.shared.baseClasses.map(e => {
        if (!h.isInstantiableClass(e) || !h.ClassType.isBuiltIn(e, 'NamedTuple')) {
          return e;
        }
        const r = [];
        if (n) {
          t.forEach(e => {
            r.push({
              type: e,
              isUnbounded: false
            });
          });
        } else {
          r.push({
            type: t.length > 0 ? h.combineTypes(t) : h.UnknownType.create(),
            isUnbounded: true
          });
        }
        const s = h.ClassType.specialize(e, undefined, n);
        s.shared = {
          ...s.shared
        };
        s.shared.baseClasses = s.shared.baseClasses.map(e => h.isInstantiableClass(e) && h.ClassType.isBuiltIn(e, 'tuple') ? g.specializeTupleClass(e, r, n) : e);
        g.computeMroLinearization(s);
        a = true;
        return s;
      });
      return a;
    }
    function T(e, t, n, a, r) {
      if (d.Tokenizer.isPythonKeyword(t)) {
        if (n) {
          return `_${r}`;
        } else {
          e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, p.LocMessage.namedTupleNameKeyword(), a);
          return t;
        }
      } else {
        return t;
      }
    }
  },
  19327: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.validateBinaryOperation = h;
    exports.getTypeOfBinaryOperation = function e(t, n, p, d) {
      const m = n.d.leftExpr;
      let g = n.d.rightExpr;
      let T = false;
      let v = false;
      if (l.operatorSupportsChaining(n.d.operator) && g.nodeType === 7 && !g.d.hasParens && l.operatorSupportsChaining(g.d.operator)) {
        e(t, g, p, d);
        g = g.d.leftExpr;
      }
      let b;
      let _ = n.d.operator === 37 || n.d.operator === 36 ? d == null ? undefined : d.expectedType : undefined;
      if (n.d.operator === 26 && d && u.isClassInstance(d.expectedType) && u.ClassType.isBuiltIn(d.expectedType, 'list') && d.expectedType.priv.typeArgs && d.expectedType.priv.typeArgs.length >= 1 && n.d.leftExpr.nodeType === 34) {
        b = d.expectedType;
      }
      const C = _ ?? b;
      const I = t.getTypeOfExpression(m, p, c.makeInferenceContext(C));
      let k = I.type;
      if (!_) {
        if (n.d.operator === 37 || n.d.operator === 36) {
          if (c.someSubtypes(k, e => !!u.isClassInstance(e) && (u.ClassType.isTypedDictClass(e) || e.shared.typeParams.length > 0))) {
            _ = k;
          }
        } else {
          if (n.d.operator === 0 && n.d.rightExpr.nodeType === 34 || n.d.operator === 6 && u.isClassInstance(k) && u.ClassType.isTypedDictClass(k)) {
            _ = k;
          }
        }
      }
      const w = t.getTypeOfExpression(g, p, c.makeInferenceContext(_));
      let S = w.type;
      if (I.isIncomplete || w.isIncomplete) {
        T = true;
      }
      if (n.d.operator === 6 && !f(k, '__or__') && !f(S, '__ror__')) {
        let e = S;
        let a = k;
        if (!c.isNoneInstance(k) && c.isNoneInstance(S)) {
          e = c.convertToInstantiable(t.getNoneType());
        } else {
          if (!c.isNoneInstance(S) && c.isNoneInstance(k)) {
            a = c.convertToInstantiable(t.getNoneType());
          }
        }
        if (c.isUnionableType([a, e])) {
          if (u.isInstantiableClass(a)) {
            a = c.specializeWithDefaultTypeArgs(a);
          }
          if (u.isInstantiableClass(e)) {
            e = c.specializeWithDefaultTypeArgs(e);
          }
          return function (e, t, n, a, l, p, d) {
            var c;
            var m;
            const y = t.d.leftExpr;
            const g = t.d.rightExpr;
            const h = o.getFileInfo(t);
            const f = h.isStubFile || !!(n & 4) || s.PythonVersion.isGreaterOrEqualTo(h.executionEnvironment.pythonVersion, s.pythonVersion3_10);
            if (!f && !u.isAnyOrUnknown(d)) {
              e.addDiagnostic(r.DiagnosticRule.reportGeneralTypeIssues, i.LocMessage.unionSyntaxIllegal(), t, t.d.operatorToken);
            }
            const T = e.validateTypeArg({
              ...a,
              node: y
            });
            const v = e.validateTypeArg({
              ...l,
              node: g
            });
            if (!T || !v) {
              return {
                type: u.UnknownType.create()
              };
            }
            d = e.reportMissingTypeArgs(t.d.leftExpr, d, n | 128);
            p = e.reportMissingTypeArgs(t.d.rightExpr, p, n | 128);
            let b = u.combineTypes([d, p], {
              skipElideRedundantLiterals: true
            });
            const _ = e.getUnionClassType();
            if (_ && u.isInstantiableClass(_)) {
              b = u.TypeBase.cloneAsSpecialForm(b, u.ClassType.cloneAsInstance(_));
            }
            if (((c = a.type.props) === null || c === undefined ? undefined : c.typeForm) && ((m = l.type.props) === null || m === undefined ? undefined : m.typeForm)) {
              const e = u.combineTypes([a.type.props.typeForm, l.type.props.typeForm]);
              b = u.TypeBase.cloneWithTypeForm(b, e);
            }
            if (!h.isStubFile) {
              let t;
              let n;
              let s;
              if (y.nodeType === 48) {
                t = y;
                n = g;
                s = l.type;
              } else {
                if (g.nodeType === 48) {
                  t = g;
                  n = y;
                  s = a.type;
                }
              }
              if (t && n && s) {
                let n = true;
                if (u.isClass(s)) {
                  if (!s.priv.isTypeArgExplicit || !!u.isClassInstance(s)) {
                    n = false;
                  }
                }
                if (!n) {
                  e.addDiagnostic(r.DiagnosticRule.reportGeneralTypeIssues, i.LocMessage.unionForwardReferenceNotAllowed(), t);
                }
              }
            }
            return {
              type: b
            };
          }(t, n, p, I, w, e, a);
        }
      }
      if (p & 256 && n.d.operator !== 6) {
        t.addDiagnostic(r.DiagnosticRule.reportInvalidTypeForm, i.LocMessage.binaryOperationNotAllowed(), n);
        return {
          type: u.UnknownType.create()
        };
      }
      let A = false;
      if (y[n.d.operator] === undefined) {
        if (n.d.operator === 12 || n.d.operator === 28) {
          k = c.removeNoneFromUnion(k);
        } else {
          A = c.isOptionalType(k);
        }
        if (n.d.operator === 12 || n.d.operator === 28) {
          S = c.removeNoneFromUnion(S);
        }
      }
      const x = new a.DiagnosticAddendum();
      const P = !l.isWithinLoop(n) && !l.getEnclosingLambda(n);
      const D = !u.isUnion(k);
      const N = h(t, n.d.operator, {
        type: k,
        isIncomplete: I.isIncomplete
      }, {
        type: S,
        isIncomplete: w.isIncomplete
      }, n, d, x, {
        isLiteralMathAllowed: P,
        isTupleAddAllowed: D
      });
      if (N.isIncomplete) {
        T = true;
      }
      if (!x.isEmpty() && (v = true, !T)) {
        if (A && x.getMessages().length === 1) {
          t.addDiagnostic(r.DiagnosticRule.reportOptionalOperand, i.LocMessage.noneOperator().format({
            operator: l.printOperator(n.d.operator)
          }), n.d.leftExpr);
        } else {
          let e = '';
          if (u.isUnion(t.makeTopLevelTypeVarsConcrete(k)) || u.isUnion(t.makeTopLevelTypeVarsConcrete(S))) {
            e = x.getString();
          }
          t.addDiagnostic(r.DiagnosticRule.reportOperatorIssue, i.LocMessage.typeNotSupportBinaryOperator().format({
            operator: l.printOperator(n.d.operator),
            leftType: t.printType(k),
            rightType: t.printType(S)
          }) + e, n);
        }
      }
      return {
        type: N.type,
        isIncomplete: T,
        typeErrors: v,
        magicMethodDeprecationInfo: N.magicMethodDeprecationInfo
      };
    };
    exports.getTypeOfAugmentedAssignment = function (e, t, n) {
      const s = {
        1: ['__iadd__', 0],
        34: ['__isub__', 33],
        27: ['__imul__', 26],
        14: ['__ifloordiv__', 13],
        11: ['__itruediv__', 10],
        25: ['__imod__', 24],
        30: ['__ipow__', 29],
        23: ['__imatmul__', 22],
        4: ['__iand__', 3],
        7: ['__ior__', 6],
        9: ['__ixor__', 8],
        18: ['__ilshift__', 17],
        32: ['__irshift__', 31]
      };
      let o;
      let d;
      const m = new a.DiagnosticAddendum();
      let y;
      const f = e.getTypeOfExpression(t.d.leftExpr);
      const T = f.type;
      let v;
      if (t.d.operator === 7) {
        v = T;
      }
      const b = e.getTypeOfExpression(t.d.rightExpr, undefined, c.makeInferenceContext(v));
      const _ = b.type;
      const C = !!b.isIncomplete || !!f.isIncomplete;
      if (u.isNever(T) || u.isNever(_)) {
        d = {
          type: u.NeverType.createNever(),
          isIncomplete: C
        };
      } else {
        o = e.mapSubtypesExpandTypeVars(T, undefined, (a, r) => e.mapSubtypesExpandTypeVars(_, {
          conditionFilter: c.getTypeCondition(a)
        }, (i, o) => {
          if (u.isAnyOrUnknown(r) || u.isAnyOrUnknown(o)) {
            return c.preserveUnknown(r, o);
          }
          const d = s[t.d.operator][0];
          let v = e.getTypeOfMagicMethodCall(r, d, [{
            type: o,
            isIncomplete: b.isIncomplete
          }], t, n);
          if (!v && r !== a) {
            v = e.getTypeOfMagicMethodCall(a, d, [{
              type: o,
              isIncomplete: b.isIncomplete
            }], t, n);
          }
          if (!v && o !== i) {
            v = e.getTypeOfMagicMethodCall(a, d, [{
              type: i,
              isIncomplete: b.isIncomplete
            }], t, n);
          }
          if (!v) {
            const a = s[t.d.operator][1];
            const i = !l.isWithinLoop(t) && function (e, t) {
              if (t.nodeType !== 38) {
                return false;
              }
              const n = e.lookUpSymbolRecursive(t, t.d.value, false);
              if (!n) {
                return false;
              }
              const a = p.getScopeForNode(t);
              return a === n.scope;
            }(e, t.d.leftExpr) && c.getUnionSubtypeCount(T) * c.getUnionSubtypeCount(_) < g;
            const d = !u.isUnion(T);
            v = h(e, a, {
              type: r,
              isIncomplete: f.isIncomplete
            }, {
              type: o,
              isIncomplete: b.isIncomplete
            }, t, n, m, {
              isLiteralMathAllowed: i,
              isTupleAddAllowed: d
            });
          }
          if (v == null ? undefined : v.magicMethodDeprecationInfo) {
            y = v.magicMethodDeprecationInfo;
          }
          if (v == null) {
            return undefined;
          } else {
            return v.type;
          }
        }));
        if ((!m.isEmpty() || !o || !!u.isNever(o)) && !C) {
          e.addDiagnostic(r.DiagnosticRule.reportOperatorIssue, i.LocMessage.typeNotSupportBinaryOperator().format({
            operator: l.printOperator(t.d.operator),
            leftType: e.printType(T),
            rightType: e.printType(_)
          }) + m.getString(), t);
        }
        d = {
          type: o,
          isIncomplete: C,
          magicMethodDeprecationInfo: y
        };
      }
      e.assignTypeToExpression(t.d.destExpr, d, t.d.rightExpr);
      return d;
    };
    exports.getTypeOfUnaryOperation = function (e, t, n, a) {
      if (n & 256) {
        e.addDiagnostic(r.DiagnosticRule.reportInvalidTypeForm, i.LocMessage.unaryOperationNotAllowed(), t);
        return {
          type: u.UnknownType.create()
        };
      }
      const s = e.getTypeOfExpression(t.d.expr);
      let o = e.makeTopLevelTypeVarsConcrete(c.transformPossibleRecursiveTypeAlias(s.type));
      const p = s.isIncomplete;
      if (u.isNever(o)) {
        return {
          type: u.NeverType.createNever(),
          isIncomplete: p
        };
      }
      const d = {
        0: '__pos__',
        33: '__neg__',
        5: '__invert__',
        38: '__bool__'
      };
      let m;
      let y;
      if (t.d.operator !== 38 && c.isOptionalType(o)) {
        e.addDiagnostic(r.DiagnosticRule.reportOptionalOperand, i.LocMessage.noneOperator().format({
          operator: l.printOperator(t.d.operator)
        }), t.d.expr);
        o = c.removeNoneFromUnion(o);
      }
      if (!s.isIncomplete) {
        m = function (e, t) {
          let n;
          if (c.getUnionSubtypeCount(t) >= g) {
            return;
          }
          if (c.getTypeCondition(t) || c.someSubtypes(t, e => !!c.getTypeCondition(e))) {
            return;
          }
          const a = c.getLiteralTypeClassName(t);
          if (a === 'int') {
            if (e === 0) {
              n = t;
            } else {
              if (e === 33) {
                n = c.mapSubtypes(t, e => {
                  const t = e;
                  return u.ClassType.cloneWithLiteral(t, -t.priv.literalValue);
                });
              } else {
                if (e === 5) {
                  n = c.mapSubtypes(t, e => {
                    const t = e;
                    return u.ClassType.cloneWithLiteral(t, ~t.priv.literalValue);
                  });
                }
              }
            }
          } else {
            if (a === 'bool' && e === 38) {
              n = c.mapSubtypes(t, e => {
                const t = e;
                return u.ClassType.cloneWithLiteral(t, !t.priv.literalValue);
              });
            }
          }
          return n;
        }(t.d.operator, o);
      }
      if (!m) {
        if (u.isAnyOrUnknown(o)) {
          m = o;
        } else {
          const n = d[t.d.operator];
          let r = true;
          m = e.mapSubtypesExpandTypeVars(o, undefined, s => {
            const i = e.getTypeOfMagicMethodCall(s, n, [], t, a);
            if (!i) {
              r = false;
            }
            if (i == null ? undefined : i.magicMethodDeprecationInfo) {
              y = i.magicMethodDeprecationInfo;
            }
            if (i == null) {
              return undefined;
            } else {
              return i.type;
            }
          });
          if (!r) {
            m = undefined;
          }
        }
        if (t.d.operator === 38) {
          m = e.getBuiltInObject(t, 'bool');
          if (!m) {
            m = u.UnknownType.create();
          }
        }
        if (!m) {
          if (!p) {
            if (a) {
              e.addDiagnostic(r.DiagnosticRule.reportOperatorIssue, i.LocMessage.typeNotSupportUnaryOperatorBidirectional().format({
                operator: l.printOperator(t.d.operator),
                type: e.printType(o),
                expectedType: e.printType(a.expectedType)
              }), t);
            } else {
              e.addDiagnostic(r.DiagnosticRule.reportOperatorIssue, i.LocMessage.typeNotSupportUnaryOperator().format({
                operator: l.printOperator(t.d.operator),
                type: e.printType(o)
              }), t);
            }
          }
          m = u.UnknownType.create(p);
        }
      }
      return {
        type: m,
        isIncomplete: p,
        magicMethodDeprecationInfo: y
      };
    };
    exports.getTypeOfTernaryOperation = function (e, t, n, a) {
      const s = o.getFileInfo(t);
      if (n & 256) {
        e.addDiagnostic(r.DiagnosticRule.reportInvalidTypeForm, i.LocMessage.ternaryNotAllowed(), t);
        return {
          type: u.UnknownType.create()
        };
      }
      e.getTypeOfExpression(t.d.testExpr);
      const l = [];
      let p = false;
      let c = false;
      const m = d.evaluateStaticBoolExpression(t.d.testExpr, s.executionEnvironment, s.definedConstants);
      if (m !== false && e.isNodeReachable(t.d.ifExpr)) {
        const r = e.getTypeOfExpression(t.d.ifExpr, n, a);
        l.push(r.type);
        if (r.isIncomplete) {
          p = true;
        }
        if (r.typeErrors) {
          c = true;
        }
      }
      if (m !== true && e.isNodeReachable(t.d.elseExpr)) {
        const r = e.getTypeOfExpression(t.d.elseExpr, n, a);
        l.push(r.type);
        if (r.isIncomplete) {
          p = true;
        }
        if (r.typeErrors) {
          c = true;
        }
      }
      return {
        type: u.combineTypes(l),
        isIncomplete: p,
        typeErrors: c
      };
    };
    const a = require(11479);
    const r = require(65880);
    const s = require(63808);
    const i = require(67703);
    const o = require(26687);
    const l = require(41557);
    const p = require(95952);
    const d = require(28676);
    const c = require(92324);
    const u = require(21024);
    const m = {
      0: ['__add__', '__radd__'],
      33: ['__sub__', '__rsub__'],
      26: ['__mul__', '__rmul__'],
      13: ['__floordiv__', '__rfloordiv__'],
      10: ['__truediv__', '__rtruediv__'],
      24: ['__mod__', '__rmod__'],
      29: ['__pow__', '__rpow__'],
      22: ['__matmul__', '__rmatmul__'],
      3: ['__and__', '__rand__'],
      6: ['__or__', '__ror__'],
      8: ['__xor__', '__rxor__'],
      17: ['__lshift__', '__rlshift__'],
      31: ['__rshift__', '__rrshift__'],
      12: ['__eq__', '__eq__'],
      28: ['__ne__', '__ne__'],
      20: ['__lt__', '__gt__'],
      21: ['__le__', '__ge__'],
      15: ['__gt__', '__lt__'],
      16: ['__ge__', '__le__']
    };
    const y = {
      36: true,
      37: true,
      39: true,
      40: true,
      41: true,
      42: true
    };
    const g = 64;
    function h(e, t, n, a, r, s, o, p) {
      const d = n.type;
      const h = a.type;
      const f = !!n.isIncomplete || !!a.isIncomplete;
      let v;
      let b;
      let _ = e.makeTopLevelTypeVarsConcrete(d);
      if (y[t] !== undefined) {
        if (t === 36) {
          if (!e.canBeTruthy(_)) {
            return {
              type: d
            };
          }
          if (!e.canBeFalsy(_)) {
            return {
              type: h
            };
          }
          _ = e.removeTruthinessFromType(_);
          if (u.isNever(h)) {
            return {
              type: _
            };
          }
        } else {
          if (t === 37) {
            if (!e.canBeFalsy(_)) {
              return {
                type: d
              };
            }
            if (!e.canBeTruthy(_)) {
              return {
                type: h
              };
            }
            _ = e.removeFalsinessFromType(_);
            if (u.isNever(h)) {
              return {
                type: _
              };
            }
          }
        }
        if (u.isNever(d) || u.isNever(h)) {
          return {
            type: u.NeverType.createNever()
          };
        }
        if (t === 41 || t === 42) {
          const s = function (e, t, n, a, r, s, o) {
            let p;
            const d = e.mapSubtypesExpandTypeVars(r.type, undefined, (d, m) => e.mapSubtypesExpandTypeVars(a, {
              conditionFilter: c.getTypeCondition(d)
            }, a => {
              var y;
              var g;
              if (u.isAnyOrUnknown(a) || u.isAnyOrUnknown(m)) {
                return c.preserveUnknown(a, d);
              }
              let h = e.getTypeOfMagicMethodCall(d, '__contains__', [{
                type: a,
                isIncomplete: n.isIncomplete
              }], s, undefined);
              if (!h) {
                const t = (y = e.getTypeOfIterator({
                  type: d,
                  isIncomplete: r.isIncomplete
                }, false, s, false)) === null || y === undefined ? undefined : y.type;
                if (t && e.assignType(t, a)) {
                  h = {
                    type: e.getBuiltInObject(s, 'bool')
                  };
                }
              }
              if (!h) {
                o.addMessage(i.LocMessage.typeNotSupportBinaryOperator().format({
                  operator: l.printOperator(t),
                  leftType: e.printType(a),
                  rightType: e.printType(d)
                }));
              }
              if (h == null ? undefined : h.magicMethodDeprecationInfo) {
                p = h.magicMethodDeprecationInfo;
              }
              if ((g = h == null ? undefined : h.type) !== null && g !== undefined) {
                return g;
              } else {
                return e.getBuiltInObject(s, 'bool');
              }
            }));
            return {
              type: d,
              magicMethodDeprecationInfo: p
            };
          }(e, t, n, _, a, r, o);
          if (s.magicMethodDeprecationInfo) {
            b = s.magicMethodDeprecationInfo;
          }
          v = s.type;
          if (v && !u.isNever(v)) {
            v = e.getBuiltInObject(r, 'bool');
          }
        } else {
          v = e.mapSubtypesExpandTypeVars(_, undefined, (n, a) => e.mapSubtypesExpandTypeVars(h, {
            conditionFilter: c.getTypeCondition(n)
          }, (n, s) => t === 36 || t === 37 ? u.combineTypes([a, s]) : e.getBuiltInObject(r, 'bool')));
        }
      } else {
        if (m[t]) {
          if (u.isNever(d) || u.isNever(h)) {
            return {
              type: u.NeverType.createNever()
            };
          }
          if (p.isLiteralMathAllowed) {
            v = function (e, t, n) {
              const a = c.getLiteralTypeClassName(t);
              if (!a || c.getTypeCondition(t) || c.someSubtypes(t, e => !!c.getTypeCondition(e))) {
                return;
              }
              const r = c.getLiteralTypeClassName(n);
              if (a !== r || c.getTypeCondition(n) || c.someSubtypes(n, e => !!c.getTypeCondition(e)) || c.getUnionSubtypeCount(t) * c.getUnionSubtypeCount(n) >= g) {
                return;
              }
              if ((a === 'str' || a === 'bytes') && e === 0) {
                return c.mapSubtypes(t, e => c.mapSubtypes(n, t => {
                  const n = e;
                  const a = t;
                  return u.ClassType.cloneWithLiteral(n, n.priv.literalValue + a.priv.literalValue);
                }));
              }
              if (a === 'int') {
                if (![0, 33, 26, 13, 24, 29, 17, 31, 3, 6, 8].includes(e)) {
                  return;
                }
                let a = true;
                const r = c.mapSubtypes(t, t => c.mapSubtypes(n, n => {
                  try {
                    const r = t;
                    const s = n;
                    const i = BigInt(r.priv.literalValue);
                    const o = BigInt(s.priv.literalValue);
                    let l;
                    if (e === 0) {
                      l = i + o;
                    } else {
                      if (e === 33) {
                        l = i - o;
                      } else {
                        if (e === 26) {
                          l = i * o;
                        } else {
                          if (e === 13) {
                            if (o !== BigInt(0)) {
                              l = i / o;
                            }
                          } else {
                            if (e === 24) {
                              if (o !== BigInt(0)) {
                                l = i % o;
                              }
                            } else {
                              if (e === 29) {
                                if (o >= BigInt(0)) {
                                  try {
                                    l = i ** o;
                                  } catch {}
                                }
                              } else {
                                if (e === 17) {
                                  l = i << o;
                                } else {
                                  if (e === 31) {
                                    l = i >> o;
                                  } else {
                                    if (e === 3) {
                                      l = i & o;
                                    } else {
                                      if (e === 6) {
                                        l = i | o;
                                      } else {
                                        if (e === 8) {
                                          l = i ^ o;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    if (l === undefined || typeof l == 'number' && isNaN(l)) {
                      a = false;
                      return;
                    } else {
                      if (l >= Number.MIN_SAFE_INTEGER && l <= Number.MAX_SAFE_INTEGER) {
                        l = Number(l);
                      }
                      return u.ClassType.cloneWithLiteral(r, l);
                    }
                  } catch {
                    a = false;
                    return;
                  }
                }));
                if (a) {
                  return r;
                }
              }
              return;
            }(t, d, h);
          }
          if (!v) {
            const d = function (e, t, n, a, r, s, o, p) {
              let d;
              const y = !!n.isIncomplete || !!a.isIncomplete;
              const g = e.mapSubtypesExpandTypeVars(n.type, undefined, (g, h) => e.mapSubtypesExpandTypeVars(a.type, {
                conditionFilter: c.getTypeCondition(g)
              }, (f, v) => {
                var b;
                if (u.isAnyOrUnknown(h) || u.isAnyOrUnknown(v)) {
                  return c.preserveUnknown(h, v);
                }
                const _ = e.getTupleClassType();
                if (p.isTupleAddAllowed && t === 0 && u.isClassInstance(g) && c.isTupleClass(g) && g.priv.tupleTypeArgs && u.isClassInstance(f) && c.isTupleClass(f) && f.priv.tupleTypeArgs && _ && u.isInstantiableClass(_) && (!c.isUnboundedTupleClass(g) || !c.isUnboundedTupleClass(f))) {
                  return u.ClassType.cloneAsInstance(c.specializeTupleClass(_, [...g.priv.tupleTypeArgs, ...f.priv.tupleTypeArgs]));
                }
                const C = m[t][0];
                let I = e.getTypeOfMagicMethodCall(T(e, h), C, [{
                  type: v,
                  isIncomplete: a.isIncomplete
                }], r, s);
                if (!I && h !== g) {
                  I = e.getTypeOfMagicMethodCall(T(e, g), C, [{
                    type: v,
                    isIncomplete: a.isIncomplete
                  }], r, s);
                }
                if (!I && v !== f) {
                  I = e.getTypeOfMagicMethodCall(T(e, g), C, [{
                    type: f,
                    isIncomplete: a.isIncomplete
                  }], r, s);
                }
                if (!I) {
                  const a = m[t][1];
                  I = e.getTypeOfMagicMethodCall(T(e, v), a, [{
                    type: h,
                    isIncomplete: n.isIncomplete
                  }], r, s);
                  if (!I && v !== f) {
                    I = e.getTypeOfMagicMethodCall(T(e, f), a, [{
                      type: h,
                      isIncomplete: n.isIncomplete
                    }], r, s);
                  }
                  if (!I && h !== g) {
                    I = e.getTypeOfMagicMethodCall(T(e, f), a, [{
                      type: g,
                      isIncomplete: n.isIncomplete
                    }], r, s);
                  }
                }
                if (!I) {
                  if (s) {
                    o.addMessage(i.LocMessage.typeNotSupportBinaryOperatorBidirectional().format({
                      operator: l.printOperator(t),
                      leftType: e.printType(g),
                      rightType: e.printType(f),
                      expectedType: e.printType(s.expectedType)
                    }));
                  } else {
                    o.addMessage(i.LocMessage.typeNotSupportBinaryOperator().format({
                      operator: l.printOperator(t),
                      leftType: e.printType(g),
                      rightType: e.printType(f)
                    }));
                  }
                }
                if (I == null ? undefined : I.magicMethodDeprecationInfo) {
                  d = I.magicMethodDeprecationInfo;
                }
                if ((b = I == null ? undefined : I.type) !== null && b !== undefined) {
                  return b;
                } else {
                  return u.UnknownType.create(y);
                }
              }));
              return {
                type: g,
                magicMethodDeprecationInfo: d
              };
            }(e, t, n, a, r, s, o, p);
            if (d.magicMethodDeprecationInfo) {
              b = d.magicMethodDeprecationInfo;
            }
            v = d.type;
          }
        }
      }
      return {
        type: v ?? u.UnknownType.create(f),
        magicMethodDeprecationInfo: b
      };
    }
    function f(e, t) {
      if (!u.isInstantiableClass(e)) {
        return false;
      }
      const n = e.shared.effectiveMetaclass;
      if (!n || !u.isInstantiableClass(n)) {
        return false;
      }
      if (u.ClassType.isBuiltIn(n, 'type')) {
        return false;
      }
      const a = c.lookUpClassMember(n, t);
      return !!a && !u.isAnyOrUnknown(a.classType) && (!u.isInstantiableClass(a.classType) || !u.ClassType.isBuiltIn(a.classType, 'type'));
    }
    function T(e, t) {
      if (u.isFunction(t) || u.isOverloaded(t)) {
        return e.getObjectType();
      } else {
        return t;
      }
    }
  },
  44321: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ParamKind = undefined;
    exports.isTypedKwargs = function (e, t) {
      return e.category === 2 && r.isClassInstance(t) && r.isUnpackedClass(t) && r.ClassType.isTypedDictClass(t) && !!t.shared.typedDictEntries;
    };
    exports.getParamListDetails = function (e) {
      const t = {
        firstPositionOrKeywordIndex: 0,
        positionParamCount: 0,
        positionOnlyParamCount: 0,
        params: [],
        hasUnpackedTypeVarTuple: false,
        hasUnpackedTypedDict: false
      };
      let n = e.shared.parameters.findIndex(e => r.isPositionOnlySeparator(e));
      if (n < 0) {
        for (let t = 0; t < e.shared.parameters.length; t++) {
          const s = e.shared.parameters[t];
          if (s.category !== 0) {
            break;
          }
          if (!s.name) {
            break;
          }
          if (!a.isDunderName(s.name) && s.name.startsWith('__')) {
            n = t + 1;
          } else {
            if (t > 0 || r.FunctionType.isStaticMethod(e)) {
              break;
            }
          }
        }
      }
      for (let a = 0; a < n && !r.FunctionType.getParamDefaultType(e, a); a++) {
        t.positionOnlyParamCount++;
      }
      let o = false;
      const l = (a, s, l, p, d) => {
        if (a.name) {
          let c;
          c = d !== undefined ? d : a.category === 1 ? i.Positional : o ? i.Keyword : n >= 0 && s < n ? i.Positional : i.Standard;
          t.params.push({
            param: a,
            index: s,
            type: l ?? r.FunctionType.getParamType(e, s),
            declaredType: r.FunctionType.getDeclaredParamType(e, s),
            defaultType: p ?? r.FunctionType.getParamDefaultType(e, s),
            kind: c
          });
        }
      };
      e.shared.parameters.forEach((a, p) => {
        var d;
        var c;
        if (a.category === 1) {
          const s = r.FunctionType.getParamType(e, p);
          if (a.name && r.isUnpackedClass(s) && s.priv.tupleTypeArgs) {
            const d = p < t.positionOnlyParamCount;
            s.priv.tupleTypeArgs.forEach((n, s) => {
              const o = r.isTypeVarTuple(n.type) || n.isUnbounded ? 1 : 0;
              if (o === 1) {
                t.argsIndex = t.params.length;
              }
              if (r.isTypeVarTuple(r.FunctionType.getParamType(e, p))) {
                t.hasUnpackedTypeVarTuple = true;
              }
              l(r.FunctionParam.create(o, n.type, r.FunctionParamFlags.NameSynthesized | r.FunctionParamFlags.TypeDeclared, `${a.name}[${s.toString()}]`), p, n.type, undefined, i.ExpandedArgs);
              if (o === 0) {
                t.positionParamCount++;
              }
              if (s > 0 && d) {
                t.positionOnlyParamCount++;
              }
            });
            if (!o && (n < 0 || p >= n)) {
              t.firstKeywordOnlyIndex = t.params.length;
              o = true;
            }
          } else {
            if (a.name && t.argsIndex === undefined) {
              t.argsIndex = t.params.length;
              if (r.isTypeVarTuple(s)) {
                t.hasUnpackedTypeVarTuple = true;
              }
            }
            if (!o && (n < 0 || p >= n)) {
              t.firstKeywordOnlyIndex = t.params.length;
              if (a.name) {
                t.firstKeywordOnlyIndex++;
              }
              o = true;
            }
            l(a, p);
          }
        } else {
          if (a.category === 2) {
            o = true;
            const n = r.FunctionType.getParamType(e, p);
            if (r.isClassInstance(n) && r.isUnpackedClass(n) && n.shared.typedDictEntries) {
              if (t.firstKeywordOnlyIndex === undefined) {
                t.firstKeywordOnlyIndex = t.params.length;
              }
              const e = n;
              n.shared.typedDictEntries.knownItems.forEach((t, a) => {
                var i;
                var o;
                t = (o = (i = n.priv.typedDictNarrowedEntries) === null || i === undefined ? undefined : i.get(a)) !== null && o !== undefined ? o : t;
                const d = s.partiallySpecializeType(t.valueType, e, undefined);
                const c = t.isRequired ? undefined : d;
                l(r.FunctionParam.create(0, d, r.FunctionParamFlags.TypeDeclared, a, c), p, d, c);
              });
              if (n.shared.typedDictEntries.extraItems) {
                l(r.FunctionParam.create(2, n.shared.typedDictEntries.extraItems.valueType, r.FunctionParamFlags.TypeDeclared, 'kwargs'), p, n.shared.typedDictEntries.extraItems.valueType);
                t.kwargsIndex = t.params.length - 1;
              }
              t.hasUnpackedTypedDict = true;
              t.unpackedKwargsTypedDictType = n;
            } else {
              if (a.name) {
                if (t.kwargsIndex === undefined) {
                  t.kwargsIndex = t.params.length;
                }
                if (t.firstKeywordOnlyIndex === undefined) {
                  t.firstKeywordOnlyIndex = t.params.length;
                }
                l(a, p);
              }
            }
          } else {
            if (a.category === 0) {
              if (a.name && !o) {
                t.positionParamCount++;
              }
              l(a, p, undefined, ((d = e.priv.specializedTypes) === null || d === undefined ? undefined : d.parameterDefaultTypes) ? (c = e.priv.specializedTypes) === null || c === undefined ? undefined : c.parameterDefaultTypes[p] : undefined);
            }
          }
        }
      });
      t.paramSpec = r.FunctionType.getParamSpecFromArgsKwargs(e);
      t.firstPositionOrKeywordIndex = t.params.findIndex(e => e.kind !== i.Positional);
      if (t.firstPositionOrKeywordIndex < 0) {
        t.firstPositionOrKeywordIndex = t.params.length;
      }
      return t;
    };
    exports.isParamSpecArgs = function (e, t) {
      let n = true;
      s.doForEachSubtype(t, t => {
        if ((!r.isParamSpec(t) || t.priv.paramSpecAccess !== 'args' || !r.isTypeSame(t, e, {
          ignoreTypeFlags: true
        })) && (!r.isClassInstance(t) || !t.priv.tupleTypeArgs || t.priv.tupleTypeArgs.length !== 1 || !t.priv.tupleTypeArgs[0].isUnbounded || !r.isAnyOrUnknown(t.priv.tupleTypeArgs[0].type)) && !r.isAnyOrUnknown(t)) {
          n = false;
        }
      });
      return n;
    };
    exports.isParamSpecKwargs = function (e, t) {
      let n = true;
      s.doForEachSubtype(t, t => {
        if ((!r.isParamSpec(t) || t.priv.paramSpecAccess !== 'kwargs' || !r.isTypeSame(t, e, {
          ignoreTypeFlags: true
        })) && (!r.isClassInstance(t) || !r.ClassType.isBuiltIn(t, 'dict') || !t.priv.typeArgs || t.priv.typeArgs.length !== 2 || !r.isClassInstance(t.priv.typeArgs[0]) || !r.ClassType.isBuiltIn(t.priv.typeArgs[0], 'str') || !r.isAnyOrUnknown(t.priv.typeArgs[1])) && !r.isAnyOrUnknown(t)) {
          n = false;
        }
      });
      return n;
    };
    const a = require(12097);
    const r = require(21024);
    const s = require(92324);
    var i;
    (function (e) {
      e[e.Positional = 0] = 'Positional';
      e[e.Standard = 1] = 'Standard';
      e[e.Keyword = 2] = 'Keyword';
      e[e.ExpandedArgs = 3] = 'ExpandedArgs';
    })(i || (exports.ParamKind = i = {}));
  },
  27670: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ParentDirectoryCache = undefined;
    const a = require(58147);
    exports.ParentDirectoryCache = class {
      constructor(e) {
        this._importRootGetter = e;
        this._importChecked = new Map();
        this._cachedResults = new Map();
        this._libPathCache = undefined;
      }
      getImportResult(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        const o = (a = this._cachedResults.get(t)) === null || a === undefined ? undefined : a.get(e.key);
        if (o) {
          return o;
        }
        const l = (r = this._importChecked.get(t)) === null || r === undefined ? undefined : r.get(e.key);
        if (l) {
          if (l.importPath && (i = (s = this._cachedResults.get(t)) === null || s === undefined ? undefined : s.get(l.importPath.key)) !== null && i !== undefined) {
            return i;
          } else {
            return n;
          }
        } else {
          return undefined;
        }
      }
      checkValidPath(e, t, n) {
        var a;
        return !!t.startsWith(n) && (this._libPathCache = (a = this._libPathCache) !== null && a !== undefined ? a : this._importRootGetter().map(t => e.realCasePath(t)).filter(e => e !== n).filter(e => e.startsWith(n)), !this._libPathCache.some(e => t.startsWith(e)));
      }
      checked(e, t, n) {
        a.getOrAdd(this._importChecked, t, () => new Map()).set(e.key, n);
      }
      add(e) {
        a.getOrAdd(this._cachedResults, e.importName, () => new Map()).set(e.path.key, e.importResult);
      }
      reset() {
        this._importChecked.clear();
        this._cachedResults.clear();
        this._libPathCache = undefined;
      }
    };
  },
  25454: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ParseTreeCleanerWalker = undefined;
    const i = __importStar(require(26687));
    const o = require(88744);
    class l extends o.ParseTreeWalker {
      constructor(e) {
        super();
        this._parseTree = e;
      }
      clean() {
        this.walk(this._parseTree);
      }
      visitNode(e) {
        i.cleanNodeAnalysisInfo(e);
        return super.visitNode(e);
      }
    }
    exports.ParseTreeCleanerWalker = l;
  },
  41557: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CallNodeWalker = exports.NameNodeWalker = undefined;
    exports.getNodeDepth = function (e) {
      let t = 0;
      let n = e;
      while (n) {
        t++;
        n = n.parent;
      }
      return t;
    };
    exports.findNodeByPosition = function (e, t, n) {
      const a = p.convertPositionToOffset(t, n);
      if (a === undefined) {
        return;
      }
      return g(e, a);
    };
    exports.findNodeByOffset = g;
    exports.isCompliantWithNodeRangeRules = h;
    exports.getClassFullName = function (e, t, n) {
      const a = [n];
      let r = e;
      while (r) {
        r = b(r);
        if (r) {
          a.push(r.d.name.d.value);
        }
      }
      a.push(t);
      return a.reverse().join('.');
    };
    exports.getTypeSourceId = function (e) {
      return e.start;
    };
    exports.printArg = f;
    exports.printExpression = T;
    exports.printOperator = v;
    exports.getCallForName = function (e) {
      var t;
      var n;
      var a;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 9 && e.parent.d.leftExpr === e) {
        return e.parent;
      }
      if (((n = e.parent) === null || n === undefined ? undefined : n.nodeType) === 35 && e.parent.d.member === e && ((a = e.parent.parent) === null || a === undefined ? undefined : a.nodeType) === 9 && e.parent.parent.d.leftExpr === e.parent) {
        return e.parent.parent;
      }
      return;
    };
    exports.getDecoratorForName = function (e) {
      var t;
      var n;
      var a;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 16 && e.parent.d.expr === e) {
        return e.parent;
      }
      if (((n = e.parent) === null || n === undefined ? undefined : n.nodeType) === 35 && e.parent.d.member === e && ((a = e.parent.parent) === null || a === undefined ? undefined : a.nodeType) === 16 && e.parent.parent.d.expr === e.parent) {
        return e.parent.parent;
      }
      return;
    };
    exports.getEnclosingSuite = function (e) {
      let t = e.parent;
      while (t) {
        if (t.nodeType === 50) {
          return t;
        }
        t = t.parent;
      }
      return;
    };
    exports.getEnclosingClass = b;
    exports.getEnclosingModule = function (e) {
      let t = e.parent;
      while (t) {
        if (t.nodeType === 36) {
          return t;
        }
        t = t.parent;
      }
      l.fail('Module node not found');
      return;
    };
    exports.getEnclosingClassOrModule = function (e, t = false) {
      let n = e.parent;
      while (n) {
        if (n.nodeType === 10) {
          return n;
        }
        if (n.nodeType === 36) {
          return n;
        }
        if (n.nodeType === 31 && t) {
          return;
        }
        n = n.parent;
      }
      return;
    };
    exports.getEnclosingFunction = _;
    exports.getEnclosingFunctionEvaluationScope = function (e) {
      let t = C(e).node;
      while (t) {
        if (t.nodeType === 31) {
          return t;
        }
        if (t.nodeType === 10 || !t.parent) {
          return;
        }
        t = C(t.parent).node;
      }
      return;
    };
    exports.getEnclosingLambda = function (e) {
      let t = e.parent;
      while (t) {
        if (t.nodeType === 33) {
          return t;
        }
        if (t.nodeType === 50) {
          return;
        }
        t = t.parent;
      }
      return;
    };
    exports.getEnclosingClassOrFunction = function (e) {
      let t = e.parent;
      while (t) {
        if (t.nodeType === 31) {
          return t;
        }
        if (t.nodeType === 10) {
          return t;
        }
        t = t.parent;
      }
      return;
    };
    exports.getEnclosingClassOrFunctionSuite = function (e) {
      var t;
      var n;
      let a = e.parent;
      while (a) {
        if (a.nodeType === 50 && (((t = a.parent) === null || t === undefined ? undefined : t.nodeType) === 31 || ((n = a.parent) === null || n === undefined ? undefined : n.nodeType) === 10)) {
          return a;
        }
        a = a.parent;
      }
      return;
    };
    exports.getEnclosingSuiteOrModule = function (e, t = false, n = true) {
      let a = e.parent;
      while (a) {
        if (a.nodeType === 50) {
          return a;
        }
        if (a.nodeType === 36) {
          return a;
        }
        if (a.nodeType === 33 && n) {
          return;
        }
        if (a.nodeType === 31 && t) {
          return;
        }
        a = a.parent;
      }
      return;
    };
    exports.getEvaluationNodeForAssignmentExpression = function (e) {
      let t = false;
      let n = C(e).node;
      while (n !== undefined) {
        switch (n.nodeType) {
          case 31:
          case 33:
          case 36:
            return n;
          case 10:
            if (t) {
              return undefined;
            } else {
              return n;
            }
          case 11:
            t = true;
            n = C(n.parent).node;
            break;
          default:
            return;
        }
      }
      return;
    };
    exports.getEvaluationScopeNode = C;
    exports.getTypeVarScopeNode = I;
    exports.getExecutionScopeNode = function (e) {
      let t = C(e).node;
      while (t.nodeType === 76 || t.nodeType === 10 || t.nodeType === 11) {
        t = C(t.parent).node;
      }
      return t;
    };
    exports.getTypeAnnotationNode = function (e) {
      let t = e;
      let n = e.parent;
      while (n) {
        if (n.nodeType === 54) {
          if (n.d.annotation === t) {
            return n;
          }
          break;
        }
        t = n;
        n = n.parent;
      }
      return;
    };
    exports.getArgsByRuntimeOrder = function (e) {
      const t = e.d.args.filter(e => !e.d.name && e.d.argCategory !== 2);
      const n = e.d.args.filter(e => !!e.d.name || e.d.argCategory === 2);
      return t.concat(n);
    };
    exports.isFinalAllowedForAssignmentTarget = function (e) {
      if (e.nodeType === 38) {
        return true;
      }
      if (e.nodeType === 35) {
        if (e.d.leftExpr.nodeType !== 38) {
          return false;
        }
        if (!b(e)) {
          return false;
        }
        const t = _(e);
        return !!t && t.d.name.d.value === '__init__';
      }
      return false;
    };
    exports.isClassVarAllowedForAssignmentTarget = function (e) {
      if (!b(e, true)) {
        return false;
      }
      return true;
    };
    exports.isRequiredAllowedForAssignmentTarget = function (e) {
      if (!b(e, true)) {
        return false;
      }
      return true;
    };
    exports.isNodeContainedWithin = function (e, t) {
      let n = e;
      while (n) {
        if (n === t) {
          return true;
        }
        n = n.parent;
      }
      return false;
    };
    exports.getParentNodeOfType = k;
    exports.getParentAnnotationNode = function (e) {
      let t;
      let n = e;
      while (n) {
        if (n.nodeType === 31) {
          if (t === n.d.returnAnnotation) {
            return t;
          } else {
            return undefined;
          }
        }
        if (n.nodeType === 41) {
          if (t === n.d.annotation || t === n.d.annotationComment) {
            return t;
          } else {
            return undefined;
          }
        }
        if (n.nodeType === 3) {
          if (t === n.d.annotationComment) {
            return t;
          } else {
            return undefined;
          }
        }
        if (n.nodeType === 54) {
          if (t === n.d.annotation) {
            return t;
          } else {
            return undefined;
          }
        }
        if (n.nodeType === 62) {
          if (t === n.d.returnAnnotation || n.d.paramAnnotations.some(e => e === t)) {
            l.assert(!t || u.isExpressionNode(t));
            return t;
          } else {
            return undefined;
          }
        }
        t = n;
        n = n.parent;
      }
      return;
    };
    exports.isNodeContainedWithinNodeType = function (e, t) {
      return k(e, t) !== undefined;
    };
    exports.isSuiteEmpty = function (e) {
      let t = false;
      for (const n of e.d.statements) {
        if (n.nodeType !== 47) {
          return false;
        }
        for (const e of n.d.statements) {
          if (e.nodeType === 21) {
            t = true;
          } else {
            if (e.nodeType !== 48) {
              return false;
            }
          }
        }
      }
      return t;
    };
    exports.containsAwaitNode = function (e) {
      let t = false;
      class n extends y.ParseTreeWalker {
        visitAwait(e) {
          t = true;
          return false;
        }
      }
      new n().walk(e);
      return t;
    };
    exports.isMatchingExpression = w;
    exports.isPartialMatchingExpression = function e(t, n) {
      if (t.nodeType === 35) {
        return w(t.d.leftExpr, n) || e(t.d.leftExpr, n);
      }
      if (t.nodeType === 27) {
        return w(t.d.leftExpr, n) || e(t.d.leftExpr, n);
      }
      return false;
    };
    exports.isWithinDefaultParamInitializer = function (e) {
      let t;
      let n = e;
      while (n) {
        if (n.nodeType === 41 && t === n.d.defaultValue) {
          return true;
        }
        if (n.nodeType === 33 || n.nodeType === 31 || n.nodeType === 10 || n.nodeType === 36) {
          return false;
        }
        t = n;
        n = n.parent;
      }
      return false;
    };
    exports.isWithinTypeAnnotation = function (e, t) {
      let n;
      let a = e;
      let r = false;
      while (a) {
        if (a.nodeType === 41 && (n === a.d.annotation || n === a.d.annotationComment)) {
          return r || !t;
        }
        if (a.nodeType === 31 && n === a.d.returnAnnotation) {
          return r || !t;
        }
        if (a.nodeType === 31 && n === a.d.funcAnnotationComment) {
          return true;
        }
        if (a.nodeType === 54 && n === a.d.annotation) {
          return r || !t;
        }
        if (a.nodeType === 3 && n === a.d.annotationComment) {
          return true;
        }
        if (a.nodeType === 48 && n === a.d.annotation) {
          r = true;
        }
        if (a.nodeType === 33 || a.nodeType === 31 || a.nodeType === 10 || a.nodeType === 36) {
          return false;
        }
        n = a;
        a = a.parent;
      }
      return false;
    };
    exports.isWithinAnnotationComment = function (e) {
      let t;
      let n = e;
      while (n) {
        if (n.nodeType === 31 && t === n.d.funcAnnotationComment) {
          return true;
        }
        if (n.nodeType === 3 && t === n.d.annotationComment) {
          return true;
        }
        if (n.nodeType === 33 || n.nodeType === 31 || n.nodeType === 10 || n.nodeType === 36) {
          return false;
        }
        t = n;
        n = n.parent;
      }
      return false;
    };
    exports.isWithinLoop = function (e) {
      let t = e;
      while (t) {
        switch (t.nodeType) {
          case 29:
          case 57:
            return true;
        }
        t = t.parent;
      }
      return false;
    };
    exports.isWithinAssertExpression = function (e) {
      let t;
      let n = e;
      while (n) {
        if (n.nodeType === 2) {
          return n.d.testExpr === t;
        }
        t = n;
        n = n.parent;
      }
      return false;
    };
    exports.getDocString = function (e) {
      if (e.length === 0) {
        return;
      }
      if (e[0].nodeType !== 47) {
        return;
      }
      if (!S(e[0])) {
        return;
      }
      const t = e[0].d.statements[0].d.strings;
      if (t.length === 1) {
        return t[0].d.value;
      }
      return t.map(e => e.d.value).join('');
    };
    exports.isDocString = S;
    exports.isAssignmentToDefaultsFollowingNamedTuple = function (e) {
      var t;
      var n;
      if (e.nodeType !== 9 || !e.parent || e.parent.nodeType !== 3 || e.parent.d.leftExpr.nodeType !== 38 || !e.parent.parent || e.parent.parent.nodeType !== 47) {
        return false;
      }
      const a = e.parent.d.leftExpr.d.value;
      const r = e.parent.parent;
      if (r.d.statements[0] !== e.parent || !r.parent || r.parent.nodeType !== 36 && r.parent.nodeType !== 50) {
        return false;
      }
      const s = r.parent;
      let i = s.d.statements.findIndex(e => e === r);
      if (i < 0) {
        return false;
      }
      i++;
      while (i < s.d.statements.length) {
        const e = s.d.statements[i];
        if (e.nodeType !== 47) {
          break;
        }
        if (((t = e.d.statements[0]) === null || t === undefined ? undefined : t.nodeType) !== 48) {
          if (((n = e.d.statements[0]) === null || n === undefined ? undefined : n.nodeType) === 3) {
            const t = e.d.statements[0];
            if (t.d.leftExpr.nodeType === 35 && t.d.leftExpr.d.member.d.value === '__defaults__') {
              const e = t.d.leftExpr.d.leftExpr;
              if (e.nodeType === 35 && e.d.member.d.value === '__new__' && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === a) {
                return true;
              }
            }
          }
          break;
        }
        i++;
      }
      return false;
    };
    exports.getEnclosingParam = function (e) {
      let t = e;
      while (t) {
        if (t.nodeType === 41) {
          return t;
        }
        if (t.nodeType === 31) {
          return;
        }
        t = t.parent;
      }
      return;
    };
    exports.getCallNodeAndActiveParamIndex = function (e, t, n) {
      let a;
      let r = e;
      while (r !== undefined) {
        if (r.nodeType === 9 && c(n, r, t)) {
          a = r;
          break;
        }
        r = r.parent;
      }
      if (!a || !a.d.args) {
        return;
      }
      const s = d.TextRange.getEnd(a);
      if (t > s) {
        return;
      }
      const i = F(n, s - 1);
      if (t === s && (i == null ? undefined : i.type) === 14) {
        return;
      }
      let o = false;
      let l = -1;
      let p = false;
      a.d.args.forEach((e, a) => {
        if (o) {
          return;
        }
        let r = e.start;
        const s = n.getItemAtPosition(r);
        if (s >= 0) {
          r = d.TextRange.getEnd(n.getItemAt(s - 1));
        }
        let i = d.TextRange.getEnd(e);
        const c = n.getItemAtPosition(i);
        if (c >= 0) {
          for (let e = c; e < n.count; e++) {
            const t = n.getItemAt(e);
            switch (t.type) {
              case 12:
              case 14:
                break;
              default:
                continue;
            }
            i = d.TextRange.getEnd(t);
            break;
          }
        }
        if (t < i) {
          l = a;
          p = t >= r;
          o = true;
        }
      });
      if (!o) {
        l = a.d.args.length + 1;
      }
      return {
        callNode: a,
        activeIndex: l,
        activeOrFake: p
      };
      function c(e, t, n) {
        const a = t.d.leftExpr.length > 0 ? d.TextRange.getEnd(t.d.leftExpr) - 1 : t.d.leftExpr.start;
        const r = d.TextRange.getEnd(t);
        if (n < a || r < n) {
          return false;
        }
        if (t.d.args.length > 0) {
          const e = t.d.args[0].start;
          const a = d.TextRange.getEnd(t.d.args[t.d.args.length - 1]);
          if (e <= n && n < a) {
            return true;
          }
        }
        const s = e.getItemAtPosition(a);
        if (s < 0 || e.count <= s) {
          return true;
        }
        const i = e.getItemAt(s + 1);
        return i.type !== 13 || !(n < d.TextRange.getEnd(i));
      }
    };
    exports.getTokenIndexAtLeft = P;
    exports.getTokenAtLeft = function (e, t, n = false, a = false) {
      const r = P(e, t, n, a);
      if (r < 0) {
        return;
      }
      return e.getItemAt(r);
    };
    exports.isWhitespace = D;
    exports.getTokenAtIndex = N;
    exports.getTokenAt = F;
    exports.getTokenOverlapping = function (e, t) {
      const n = E(e, t);
      return N(e, n);
    };
    exports.getIndexOfTokenOverlapping = E;
    exports.findTokenAfter = function (e, t, n) {
      const a = e.tokens;
      const r = a.getItemAtPosition(t);
      if (r < 0) {
        return;
      }
      for (let e = r; e < a.length; e++) {
        const t = a.getItemAt(e);
        if (n(t)) {
          return t;
        }
      }
      return;
    };
    exports.getCommentsAtTokenIndex = function (e, t) {
      let n = N(e, t);
      if (!n) {
        return;
      }
      for (let a = t - 1; a >= 0; --a) {
        const t = N(e, a);
        if (!t || t.start !== n.start) {
          break;
        }
        n = t;
      }
      return n.comments;
    };
    exports.printParseNodeType = function (e) {
      switch (e) {
        case 0:
          return 'Error';
        case 1:
          return 'Argument';
        case 2:
          return 'Assert';
        case 3:
          return 'Assignment';
        case 4:
          return 'AssignmentExpression';
        case 5:
          return 'AugmentedAssignment';
        case 6:
          return 'Await';
        case 7:
          return 'BinaryOperation';
        case 8:
          return 'Break';
        case 9:
          return 'Call';
        case 10:
          return 'Class';
        case 14:
          return 'Constant';
        case 15:
          return 'Continue';
        case 16:
          return 'Decorator';
        case 17:
          return 'Del';
        case 18:
          return 'Dictionary';
        case 19:
          return 'DictionaryExpandEntry';
        case 20:
          return 'DictionaryKeyEntry';
        case 21:
          return 'Ellipsis';
        case 22:
          return 'If';
        case 23:
          return 'Import';
        case 24:
          return 'ImportAs';
        case 25:
          return 'ImportFrom';
        case 26:
          return 'ImportFromAs';
        case 27:
          return 'Index';
        case 28:
          return 'Except';
        case 29:
          return 'For';
        case 30:
          return 'FormatString';
        case 31:
          return 'Function';
        case 32:
          return 'Global';
        case 33:
          return 'Lambda';
        case 34:
          return 'List';
        case 11:
          return 'Comprehension';
        case 12:
          return 'ComprehensionFor';
        case 13:
          return 'ComprehensionIf';
        case 35:
          return 'MemberAccess';
        case 36:
          return 'Module';
        case 37:
          return 'ModuleName';
        case 38:
          return 'Name';
        case 39:
          return 'Nonlocal';
        case 40:
          return 'Number';
        case 41:
          return 'Parameter';
        case 42:
          return 'Pass';
        case 43:
          return 'Raise';
        case 44:
          return 'Return';
        case 45:
          return 'Set';
        case 46:
          return 'Slice';
        case 47:
          return 'StatementList';
        case 48:
          return 'StringList';
        case 49:
          return 'String';
        case 50:
          return 'Suite';
        case 51:
          return 'Ternary';
        case 52:
          return 'Tuple';
        case 53:
          return 'Try';
        case 54:
          return 'TypeAnnotation';
        case 55:
          return 'UnaryOperation';
        case 56:
          return 'Unpack';
        case 57:
          return 'While';
        case 58:
          return 'With';
        case 59:
          return 'WithItem';
        case 60:
          return 'Yield';
        case 61:
          return 'YieldFrom';
        case 62:
          return 'FunctionAnnotation';
        case 63:
          return 'Match';
        case 64:
          return 'Case';
        case 65:
          return 'PatternSequence';
        case 66:
          return 'PatternAs';
        case 67:
          return 'PatternLiteral';
        case 68:
          return 'PatternClass';
        case 69:
          return 'PatternCapture';
        case 70:
          return 'PatternMapping';
        case 71:
          return 'PatternMappingKeyEntry';
        case 72:
          return 'PatternMappingExpandEntry';
        case 73:
          return 'PatternValue';
        case 74:
          return 'PatternClassArgument';
        case 75:
          return 'TypeParameter';
        case 76:
          return 'TypeParameterList';
        case 77:
          return 'TypeAlias';
      }
      l.assertNever(e);
    };
    exports.isWriteAccess = function (e) {
      let t = e;
      let n = t.parent;
      while (n) {
        switch (n.nodeType) {
          case 3:
          case 5:
            return t === n.d.leftExpr;
          case 4:
          case 28:
            return t === n.d.name;
          case 17:
            return true;
          case 29:
          case 12:
            return t === n.d.targetExpr;
          case 24:
            return t === n.d.alias || n.d.module.d.nameParts.length > 0 && t === n.d.module.d.nameParts[0];
          case 26:
            return t === n.d.alias || !n.d.alias && t === n.d.name;
          case 35:
            if (t !== n.d.member) {
              return false;
            }
            break;
          case 58:
            return n.d.withItems.some(e => e === t);
          case 54:
            if (t === n.d.annotation) {
              return false;
            }
            break;
          case 31:
          case 10:
          case 36:
            return false;
        }
        t = n;
        n = n.parent;
      }
      return false;
    };
    exports.getModuleNode = M;
    exports.getFileInfoFromNode = function (e) {
      const t = M(e);
      if (t) {
        return i.getFileInfo(t);
      } else {
        return undefined;
      }
    };
    exports.isFunctionSuiteEmpty = function (e) {
      let t = true;
      e.d.suite.d.statements.forEach(e => {
        if (e.nodeType !== 0) {
          if (e.nodeType === 47) {
            e.d.statements.forEach(e => {
              if (e.nodeType !== 21 && e.nodeType !== 48 && e.nodeType !== 42) {
                t = false;
              }
            });
          } else {
            t = false;
          }
        }
      });
      return t;
    };
    exports.getTypeAnnotationForParam = function (e, t) {
      if (t >= e.d.params.length) {
        return;
      }
      const n = e.d.params[t];
      if (n.d.annotation) {
        return n.d.annotation;
      }
      if (n.d.annotationComment) {
        return n.d.annotationComment;
      }
      if (!e.d.funcAnnotationComment || e.d.funcAnnotationComment.d.isEllipsis) {
        return;
      }
      let a = 0;
      const r = e.d.funcAnnotationComment.d.paramAnnotations;
      if (r.length < e.d.params.length) {
        a = 1;
      }
      const s = t - a;
      if (s < 0 || s >= r.length) {
        return;
      }
      return r[s];
    };
    exports.isImportModuleName = function (e) {
      var t;
      var n;
      return ((n = (t = z(e, 37)) === null || t === undefined ? undefined : t.parent) === null || n === undefined ? undefined : n.nodeType) === 24;
    };
    exports.isImportAlias = function (e) {
      var t;
      return ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 24 && e.parent.d.alias === e;
    };
    exports.isFromImportModuleName = function (e) {
      var t;
      var n;
      return ((n = (t = z(e, 37)) === null || t === undefined ? undefined : t.parent) === null || n === undefined ? undefined : n.nodeType) === 25;
    };
    exports.isFromImportName = function (e) {
      var t;
      return ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 26 && e.parent.d.name === e;
    };
    exports.isFromImportAlias = function (e) {
      var t;
      return ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 26 && e.parent.d.alias === e;
    };
    exports.isLastNameOfModuleName = function (e) {
      var t;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 37) {
        return false;
      }
      const n = e.parent;
      if (n.d.nameParts.length === 0) {
        return false;
      }
      return n.d.nameParts[n.d.nameParts.length - 1] === e;
    };
    exports.getAncestorsIncludingSelf = O;
    exports.getFirstAncestorOrSelfOfKind = z;
    exports.getFirstAncestorOrSelf = U;
    exports.getDottedNameWithGivenNodeAsLastName = function (e) {
      var t;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 35) {
        return e;
      }
      if (e.parent.d.leftExpr === e) {
        return e;
      }
      return e.parent;
    };
    exports.getDecoratorName = function (e) {
      return function e(t) {
        var n;
        if (t.nodeType === 38 || t.nodeType === 35) {
          if ((n = V(t)) === null || n === undefined) {
            return undefined;
          } else {
            return n.map(e => e.d.value).join('.');
          }
        } else {
          if (t.nodeType === 9) {
            return e(t.d.leftExpr);
          } else {
            return undefined;
          }
        }
      }(e.d.expr);
    };
    exports.getDottedName = V;
    exports.getFirstNameOfDottedName = function e(t) {
      if (t.nodeType === 38) {
        return t;
      }
      if (t.d.leftExpr.nodeType === 38 || t.d.leftExpr.nodeType === 35) {
        return e(t.d.leftExpr);
      }
      return;
    };
    exports.isFirstNameOfDottedName = function (e) {
      var t;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 35) {
        return true;
      }
      if (e.parent.d.leftExpr === e) {
        return true;
      }
      return false;
    };
    exports.isLastNameOfDottedName = function (e) {
      var t;
      var n;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 35) {
        return true;
      }
      if (e.parent.d.leftExpr.nodeType !== 38 && e.parent.d.leftExpr.nodeType !== 35) {
        return false;
      }
      if (e.parent.d.leftExpr === e) {
        return false;
      }
      return ((n = e.parent.parent) === null || n === undefined ? undefined : n.nodeType) !== 35;
    };
    exports.getStringNodeValueRange = function (e) {
      return R(e.d.token);
    };
    exports.getStringValueRange = R;
    exports.getFullStatementRange = function (e, t, n) {
      var a;
      const r = p.convertTextRangeToRange(e, t.tokenizerOutput.lines);
      const s = (a = function (e, t, n) {
        const a = n.tokens.getItemAtPosition(t);
        if (a < 0) {
          return;
        }
        let r = a;
        for (; r > 0; r--) {
          const t = n.tokens.getItemAt(r);
          if (p.convertTextRangeToRange(t, n.lines).end.line !== e.start.line) {
            break;
          }
        }
        for (let t = a - 1; t > r; t--) {
          const a = n.tokens.getItemAt(t);
          if (a.type !== 3 && a.type !== 4) {
            if (a.type === 2) {
              return;
            }
            return e.start;
          }
        }
        return;
      }(r, e.start, t.tokenizerOutput)) !== null && a !== undefined ? a : {
        line: r.start.line,
        character: 0
      };
      const i = function (e, t, n) {
        const a = n.tokens.getItemAtPosition(t);
        if (a < 0) {
          return;
        }
        let r = a;
        for (; r < n.tokens.count; r++) {
          const t = n.tokens.getItemAt(r);
          const a = p.convertTextRangeToRange(t, n.lines);
          if (e.end.line !== a.start.line) {
            break;
          }
        }
        let s = false;
        for (let e = a; e < r; e++) {
          const t = n.tokens.getItemAt(e);
          if (t.type === 11 || t.type === 2) {
            s = true;
            continue;
          }
          if (!s) {
            continue;
          }
          return p.convertTextRangeToRange(t, n.lines).start;
        }
        return;
      }(r, d.TextRange.getEnd(e), t.tokenizerOutput);
      if (i) {
        return {
          start: s,
          end: i
        };
      }
      if (r.end.line === t.tokenizerOutput.lines.count - 1) {
        return {
          start: s,
          end: r.end
        };
      }
      let o = 1;
      if (n && n.includeTrailingBlankLines) {
        for (let e = o; r.end.line + e < t.tokenizerOutput.lines.count; e++) {
          if (!L(t.tokenizerOutput, t.text, r.end.line + e)) {
            o = e;
            break;
          }
        }
      }
      return {
        start: s,
        end: {
          line: r.end.line + o,
          character: 0
        }
      };
    };
    exports.isBlankLine = L;
    exports.isUnannotatedFunction = function (e) {
      return e.d.returnAnnotation === undefined && e.d.params.every(e => e.d.annotation === undefined && e.d.annotationComment === undefined);
    };
    exports.isValidLocationForFutureImport = function (e) {
      const t = M(e);
      l.assert(t);
      let n = false;
      for (const a of t.d.statements) {
        if (a.nodeType !== 47) {
          return false;
        }
        for (const t of a.d.statements) {
          if (t === e) {
            return true;
          }
          if (t.nodeType === 48) {
            if (n) {
              return false;
            }
            n = true;
          } else {
            if (t.nodeType !== 25) {
              return false;
            }
            if (t.d.module.d.leadingDots !== 0 || t.d.module.d.nameParts.length !== 1 || t.d.module.d.nameParts[0].d.value !== '__future__') {
              return false;
            }
          }
        }
      }
      return false;
    };
    exports.operatorSupportsChaining = function (e) {
      switch (e) {
        case 12:
        case 28:
        case 20:
        case 21:
        case 15:
        case 16:
        case 39:
        case 40:
        case 41:
        case 42:
          return true;
      }
      return false;
    };
    exports.getVariableDocStringNode = function (e) {
      var t;
      var n;
      var a;
      var r;
      let s;
      let i = e;
      while (i && i.nodeType !== 3 && i.nodeType !== 77 && i.nodeType !== 50) {
        if (i.nodeType === 54 && !s) {
          s = i;
        }
        i = i.parent;
      }
      if ((i == null ? undefined : i.nodeType) !== 3 && (i == null ? undefined : i.nodeType) !== 77) {
        if (!s) {
          return;
        }
        i = s;
      }
      const o = i.parent;
      if ((o == null ? undefined : o.nodeType) !== 47) {
        return;
      }
      const l = o.parent;
      if (!l || l.nodeType !== 36 && l.nodeType !== 50) {
        return;
      }
      const p = l.d.statements.findIndex(e => e === o);
      if (p < 0 || p === l.d.statements.length - 1) {
        return;
      }
      const d = l.d.statements[p + 1];
      if (d.nodeType !== 47 || !S(d)) {
        return;
      }
      let c = false;
      if (((t = o == null ? undefined : o.parent) === null || t === undefined ? undefined : t.nodeType) === 36) {
        c = true;
      } else {
        if (((n = o == null ? undefined : o.parent) === null || n === undefined ? undefined : n.nodeType) === 50 && ((r = (a = o == null ? undefined : o.parent) === null || a === undefined ? undefined : a.parent) === null || r === undefined ? undefined : r.nodeType) === 10) {
          c = true;
        } else {
          const e = _(o);
          if (e && e.d.name.d.value === '__init__' && b(e, true)) {
            c = true;
          }
        }
      }
      if (!c) {
        return;
      }
      return d.d.statements[0];
    };
    exports.getScopeIdForNode = B;
    exports.getTypeVarScopesForNode = function (e) {
      const t = [];
      let n = e;
      while (n && (n = I(n), n)) {
        t.push(B(n));
        n = n.parent;
      }
      return t;
    };
    exports.checkDecorator = function (e, t) {
      return e.d.expr.nodeType === 38 && e.d.expr.d.value === t;
    };
    exports.isSimpleDefault = function e(t) {
      switch (t.nodeType) {
        case 40:
        case 14:
        case 35:
          return true;
        case 49:
          return !(t.d.token.flags & 64);
        case 48:
          return t.d.strings.every(e);
        case 55:
          return e(t.d.expr);
        case 7:
          return e(t.d.leftExpr) && e(t.d.rightExpr);
        default:
          return false;
      }
    };
    const i = __importStar(require(26687));
    const o = require(34455);
    const l = require(48281);
    const p = require(56814);
    const d = require(88754);
    const c = require(95418);
    const u = require(85114);
    const m = require(26687);
    const y = require(88744);
    function g(e, t) {
      if (!d.TextRange.overlaps(e, t)) {
        return;
      }
      let n = y.getChildNodes(e);
      if (h(e) && n.length > 20) {
        let e = c.getIndexContaining(n, t, d.TextRange.overlaps);
        if (e >= 0) {
          let a = e - 1;
          while (a >= 0) {
            const r = n[a];
            if (r) {
              if (!d.TextRange.overlaps(r, t)) {
                break;
              }
              e = a;
            }
            a--;
          }
          n = [n[e]];
        }
      }
      for (const a of n) {
        if (!a) {
          continue;
        }
        const n = g(a, t);
        if (n) {
          if (e.nodeType === 5 && n === e.d.leftExpr) {
            return e.d.destExpr;
          } else {
            return n;
          }
        }
      }
      return e;
    }
    function h(e) {
      return e.nodeType !== 3 && e.nodeType !== 48 && (e.nodeType !== 1 || !e.d.isNameSameAsValue);
    }
    function f(e, t) {
      let n = '';
      if (e.d.argCategory === 1) {
        n = '*';
      } else {
        if (e.d.argCategory === 2) {
          n = '**';
        }
      }
      if (e.d.name) {
        n += e.d.name.d.value + '=';
      }
      if (!e.d.isNameSameAsValue) {
        n += T(e.d.valueExpr, t);
      }
      return n;
    }
    function T(e, t = 0) {
      switch (e.nodeType) {
        case 38:
          return e.d.value;
        case 35:
          return T(e.d.leftExpr, t) + '.' + e.d.member.d.value;
        case 9:
          {
            let n = T(e.d.leftExpr, t);
            if (e.d.leftExpr.nodeType !== 35 && e.d.leftExpr.nodeType !== 38 && e.d.leftExpr.nodeType !== 27 && e.d.leftExpr.nodeType !== 9) {
              n = `(${n})`;
            }
            return n + '(' + e.d.args.map(e => f(e, t)).join(', ') + ')';
          }
        case 27:
          return T(e.d.leftExpr, t) + '[' + e.d.items.map(e => f(e, t)).join(', ') + (e.d.trailingComma ? ',' : '') + ']';
        case 55:
          {
            const n = v(e.d.operator) + T(e.d.expr, t);
            if (e.d.hasParens) {
              return `(${n})`;
            } else {
              return n;
            }
          }
        case 7:
          {
            const n = T(e.d.leftExpr, t) + ' ' + v(e.d.operator) + ' ' + T(e.d.rightExpr, t);
            if (e.d.hasParens) {
              return `(${n})`;
            } else {
              return n;
            }
          }
        case 40:
          {
            let t = e.d.value.toString();
            if (t.endsWith('n')) {
              t = t.substring(0, t.length - 1);
            }
            if (e.d.isImaginary) {
              t += 'j';
            }
            return t;
          }
        case 48:
          if (t & 1 && e.d.annotation) {
            return T(e.d.annotation, t);
          } else {
            return e.d.strings.map(e => T(e, t)).join(' ');
          }
        case 49:
          {
            let n = '';
            if (e.d.token.flags & 8) {
              n += 'r';
            }
            if (e.d.token.flags & 16) {
              n += 'u';
            }
            if (e.d.token.flags & 32) {
              n += 'b';
            }
            if (e.d.token.flags & 64) {
              n += 'f';
            }
            let a = e.d.token.escapedValue;
            if (!(t & 2)) {
              const e = 32;
              a = a.slice(0, e);
            }
            if (e.d.token.flags & 4) {
              if (e.d.token.flags & 1) {
                n += `'''${a}'''`;
              } else {
                n += `"""${a}"""`;
              }
            } else {
              if (e.d.token.flags & 1) {
                n += `'${a}'`;
              } else {
                n += `"${a}"`;
              }
            }
            return n;
          }
        case 30:
          {
            let t = 'f';
            let n = '';
            const a = [...e.d.middleTokens, ...e.d.fieldExprs].sort((e, t) => e.start - t.start);
            while (a.length > 0) {
              const e = a.shift();
              n += 'nodeType' in e ? `{${T(e)}}` : e.escapedValue;
            }
            if (e.d.token.flags & 4) {
              if (e.d.token.flags & 1) {
                t += `'''${n}'''`;
              } else {
                t += `"""${n}"""`;
              }
            } else {
              if (e.d.token.flags & 1) {
                t += `'${n}'`;
              } else {
                t += `"${n}"`;
              }
            }
            return t;
          }
        case 3:
          return T(e.d.leftExpr, t) + ' = ' + T(e.d.rightExpr, t);
        case 4:
          return T(e.d.name, t) + ' := ' + T(e.d.rightExpr, t);
        case 54:
          return T(e.d.valueExpr, t) + ': ' + T(e.d.annotation, t);
        case 5:
          return T(e.d.leftExpr, t) + ' ' + v(e.d.operator) + ' ' + T(e.d.rightExpr, t);
        case 6:
          {
            const n = `await ${T(e.d.expr, t)}`;
            if (e.d.hasParens) {
              return `(${n})`;
            } else {
              return n;
            }
          }
        case 51:
          return T(e.d.ifExpr, t) + ' if ' + T(e.d.testExpr, t) + ' else ' + T(e.d.elseExpr, t);
        case 34:
          return `[${e.d.items.map(e => T(e, t)).join(', ')}]`;
        case 56:
          return `*${T(e.d.expr, t)}`;
        case 52:
          {
            const n = e.d.items.map(e => T(e, t));
            if (n.length === 1) {
              return `(${n[0]}, )`;
            } else {
              return `(${n.join(', ')})`;
            }
          }
        case 60:
          if (e.d.expr) {
            return `yield ${T(e.d.expr, t)}`;
          } else {
            return 'yield';
          }
        case 61:
          return `yield from ${T(e.d.expr, t)}`;
        case 21:
          return '...';
        case 11:
          {
            let n = '<ListExpression>';
            if (u.isExpressionNode(e.d.expr)) {
              n = T(e.d.expr, t);
            } else {
              if (e.d.expr.nodeType === 20) {
                n = `${T(e.d.expr.d.keyExpr, t)}: ${T(e.d.expr.d.valueExpr, t)}`;
              }
            }
            n = n + ' ' + e.d.forIfNodes.map(e => e.nodeType === 12 ? `${(e.d.isAsync ? 'async ' : '') + 'for ' + T(e.d.targetExpr, t)} in ${T(e.d.iterableExpr, t)}` : `if ${T(e.d.testExpr, t)}`).join(' ');
            if (e.d.hasParens) {
              return `(${n})`;
            } else {
              return n;
            }
          }
        case 46:
          {
            let n = '';
            if (e.d.startValue || e.d.endValue || e.d.stepValue) {
              if (e.d.startValue) {
                n += T(e.d.startValue, t);
              }
              if (e.d.endValue) {
                n += `: ${T(e.d.endValue, t)}`;
              }
              if (e.d.stepValue) {
                n += `: ${T(e.d.stepValue, t)}`;
              }
            } else {
              n += ':';
            }
            return n;
          }
        case 33:
          return `lambda ${e.d.params.map(e => {
            let n = '';
            if (e.d.category === 1) {
              n += '*';
            } else {
              if (e.d.category === 2) {
                n += '**';
              }
            }
            if (e.d.name) {
              n += e.d.name.d.value;
            } else {
              if (e.d.category === 0) {
                n += '/';
              }
            }
            if (e.d.defaultValue) {
              n += ` = ${T(e.d.defaultValue, t)}`;
            }
            return n;
          }).join(', ')}: ${T(e.d.expr, t)}`;
        case 14:
          if (e.d.constType === 33) {
            return 'True';
          }
          if (e.d.constType === 15) {
            return 'False';
          }
          if (e.d.constType === 9) {
            return '__debug__';
          }
          if (e.d.constType === 26) {
            return 'None';
          }
          break;
        case 18:
          {
            const n = `${e.d.items.map(e => e.nodeType === 20 ? `${T(e.d.keyExpr, t)}: ${T(e.d.valueExpr, t)}` : e.nodeType === 19 ? `**${T(e.d.expr, t)}` : T(e, t))}`;
            if (n) {
              return `{ ${n} }`;
            } else {
              return '{}';
            }
          }
        case 45:
          return e.d.items.map(e => T(e, t)).join(', ');
        case 0:
          return '<Parse Error>';
        default:
          l.assertNever(e);
      }
      return '<Expression>';
    }
    function v(e) {
      const t = {
        0: '+',
        1: '+=',
        2: '=',
        3: '&',
        4: '&=',
        5: '~',
        6: '|',
        7: '|=',
        8: '^',
        9: '^=',
        10: '/',
        11: '/=',
        12: '==',
        13: '//',
        14: '//=',
        15: '>',
        16: '>=',
        17: '<<',
        18: '<<=',
        19: '<>',
        20: '<',
        21: '<=',
        22: '@',
        23: '@=',
        24: '%',
        25: '%=',
        26: '*',
        27: '*=',
        28: '!=',
        29: '**',
        30: '**=',
        31: '>>',
        32: '>>=',
        33: '-',
        34: '-=',
        36: 'and',
        37: 'or',
        38: 'not ',
        39: 'is',
        40: 'is not',
        41: 'in',
        42: 'not in'
      };
      if (t[e]) {
        return t[e];
      } else {
        return 'unknown';
      }
    }
    function b(e, t = false) {
      let n = e.parent;
      while (n) {
        if (n.nodeType === 10) {
          return n;
        }
        if (n.nodeType === 36) {
          return;
        }
        if (n.nodeType === 31 && t) {
          return;
        }
        n = n.parent;
      }
    }
    function _(e) {
      let t;
      let n = e.parent;
      while (n) {
        if (n.nodeType === 31 && !n.d.decorators.some(e => e === t)) {
          return n;
        }
        if (n.nodeType === 10) {
          return;
        }
        t = n;
        n = n.parent;
      }
    }
    function C(e) {
      let t;
      let n;
      let a = e;
      let r = false;
      let s = false;
      while (a) {
        if (a.nodeType === 41) {
          if (t === a.d.name) {
            r = true;
          } else {
            if (t === a.d.defaultValue) {
              s = true;
            }
          }
        }
        switch (a.nodeType) {
          case 76:
            return {
              node: a,
              useProxyScope: true
            };
          case 31:
            if (!t) {
              break;
            }
            if (a.d.decorators.some(e => e === t)) {
              break;
            }
            if (t === a.d.name) {
              break;
            }
            if (a.d.params.some(e => e === t)) {
              if (s) {
                break;
              }
              if (r && m.getScope(a) !== undefined) {
                return {
                  node: a
                };
              }
            }
            if (t === a.d.suite && m.getScope(a) !== undefined) {
              return {
                node: a
              };
            }
            if (a.d.typeParams) {
              const e = a.d.typeParams;
              if (m.getScope(e) !== undefined) {
                return {
                  node: e,
                  useProxyScope: true
                };
              }
            }
            break;
          case 33:
            if (a.d.params.some(e => e === t)) {
              if (r && m.getScope(a) !== undefined) {
                return {
                  node: a
                };
              }
            } else {
              if ((!t || t === a.d.expr) && m.getScope(a) !== undefined) {
                return {
                  node: a
                };
              }
            }
            break;
          case 10:
            if (!t) {
              break;
            }
            if (a.d.decorators.some(e => e === t)) {
              break;
            }
            if (t === a.d.suite && m.getScope(a) !== undefined) {
              return {
                node: a
              };
            }
            if (a.d.typeParams) {
              const e = a.d.typeParams;
              if (m.getScope(e) !== undefined) {
                return {
                  node: e,
                  useProxyScope: true
                };
              }
            }
            break;
          case 11:
            if (m.getScope(a) !== undefined) {
              if (t !== a.d.forIfNodes[0] || a.d.forIfNodes[0].nodeType !== 12 || a.d.forIfNodes[0].d.iterableExpr !== n) {
                return {
                  node: a
                };
              }
            }
            break;
          case 77:
            if (t === a.d.expr && a.d.typeParams) {
              const e = a.d.typeParams;
              if (m.getScope(e) !== undefined) {
                return {
                  node: e
                };
              }
            }
            break;
          case 36:
            if (m.getScope(a) !== undefined) {
              return {
                node: a
              };
            }
        }
        n = t;
        t = a;
        a = a.parent;
      }
      l.fail('Did not find evaluation scope');
    }
    function I(e) {
      let t;
      let n = e;
      while (n) {
        switch (n.nodeType) {
          case 31:
          case 10:
            if (!n.d.decorators.some(e => e === t)) {
              return n;
            }
            break;
          case 77:
            return n;
        }
        t = n;
        n = n.parent;
      }
    }
    function k(e, t) {
      let n = e;
      while (n) {
        if (n.nodeType === t) {
          return n;
        }
        n = n.parent;
      }
    }
    function w(e, t) {
      if (e.nodeType === 38) {
        if (t.nodeType === 38) {
          return e.d.value === t.d.value;
        } else {
          return t.nodeType === 4 && e.d.value === t.d.name.d.value;
        }
      }
      if (e.nodeType === 35 && t.nodeType === 35) {
        return w(e.d.leftExpr, t.d.leftExpr) && e.d.member.d.value === t.d.member.d.value;
      }
      if (e.nodeType === 27 && t.nodeType === 27) {
        if (!w(e.d.leftExpr, t.d.leftExpr)) {
          return false;
        }
        if (t.d.items.length !== 1 || t.d.trailingComma || t.d.items[0].d.name || t.d.items[0].d.argCategory !== 0) {
          return false;
        }
        const n = e.d.items[0].d.valueExpr;
        if (n.nodeType === 40) {
          const e = t.d.items[0].d.valueExpr;
          return e.nodeType === 40 && !e.d.isImaginary && !!e.d.isInteger && n.d.value === e.d.value;
        }
        if (n.nodeType === 55 && n.d.operator === 33 && n.d.expr.nodeType === 40) {
          const e = t.d.items[0].d.valueExpr;
          return e.nodeType === 55 && e.d.operator === 33 && e.d.expr.nodeType === 40 && !e.d.expr.d.isImaginary && !!e.d.expr.d.isInteger && n.d.expr.d.value === e.d.expr.d.value;
        }
        if (n.nodeType === 48) {
          const e = n;
          const a = t.d.items[0].d.valueExpr;
          if (e.d.strings.length === 1 && e.d.strings[0].nodeType === 49 && a.nodeType === 48 && a.d.strings.length === 1 && a.d.strings[0].nodeType === 49) {
            return e.d.strings[0].d.value === a.d.strings[0].d.value;
          }
        }
        return false;
      }
      return false;
    }
    function S(e) {
      if (e.d.statements.length === 0 || e.d.statements[0].nodeType !== 48) {
        return false;
      }
      const t = e.d.statements[0].d.strings;
      return t.length !== 0 && !t.some(e => e.nodeType === 30);
    }
    class A extends y.ParseTreeWalker {
      constructor(e) {
        super();
        this._callback = e;
      }
      visitName(e) {
        this._callback(e, this._subscriptIndex, this._baseExpression);
        return true;
      }
      visitIndex(e) {
        this.walk(e.d.leftExpr);
        const t = this._subscriptIndex;
        const n = this._baseExpression;
        this._baseExpression = e.d.leftExpr;
        e.d.items.forEach((e, t) => {
          this._subscriptIndex = t;
          this.walk(e);
        });
        this._subscriptIndex = t;
        this._baseExpression = n;
        return false;
      }
    }
    exports.NameNodeWalker = A;
    class x extends y.ParseTreeWalker {
      constructor(e) {
        super();
        this._callback = e;
      }
      visitCall(e) {
        this._callback(e);
        return true;
      }
    }
    function P(e, t, n = false, a = false) {
      const r = e.getItemAtPosition(t);
      if (r < 0) {
        return -1;
      }
      for (let s = r; s >= 0; s--) {
        const r = e.getItemAt(s);
        if ((a || r.length !== 0) && (n || !D(r)) && d.TextRange.getEnd(r) <= t) {
          return s;
        }
      }
      return -1;
    }
    function D(e) {
      return e.type === 2 || e.type === 3 || e.type === 4;
    }
    function N(e, t) {
      if (!(t < 0)) {
        return e.getItemAt(t);
      }
    }
    function F(e, t) {
      return N(e, e.getItemAtPosition(t));
    }
    function E(e, t) {
      const n = e.getItemAtPosition(t);
      if (n < 0) {
        return -1;
      }
      const a = e.getItemAt(n);
      if (d.TextRange.overlaps(a, t)) {
        return n;
      } else {
        return -1;
      }
    }
    function M(e) {
      let t = e;
      while (t && t.nodeType !== 36) {
        t = t.parent;
      }
      return t;
    }
    function* O(e) {
      while (e !== undefined) {
        yield e;
        e = e.parent;
      }
    }
    function z(e, t) {
      return U(e, e => e.nodeType === t);
    }
    function U(e, t) {
      for (const n of O(e)) {
        if (t(n)) {
          return n;
        }
      }
    }
    function V(e) {
      if (e.nodeType === 38) {
        return [e];
      }
      const t = [];
      if (function e(t, n) {
        if (t.nodeType === 38) {
          n.push(t);
          return true;
        }
        n.push(t.d.member);
        if (t.d.leftExpr.nodeType === 38 || t.d.leftExpr.nodeType === 35) {
          return e(t.d.leftExpr, n);
        }
        return false;
      }(e, t)) {
        return t.reverse();
      } else {
        return undefined;
      }
    }
    function R(e) {
      const t = e.quoteMarkLength;
      const n = !(e.flags & 65536);
      return d.TextRange.create(e.start + t, e.length - t - (n ? t : 0));
    }
    function L(e, t, n) {
      const a = e.lines.getItemAt(n);
      return o.containsOnlyWhitespace(t, a);
    }
    function B(e) {
      let t = '';
      if (e.nodeType === 10 || e.nodeType === 31) {
        t = e.d.name.d.value;
      }
      return `${i.getFileInfo(e).fileId}.${e.start.toString()}-${t}`;
    }
    exports.CallNodeWalker = x;
  },
  88744: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ParseTreeWalker = exports.ParseTreeVisitor = undefined;
    exports.getChildNodes = o;
    const i = __importStar(require(48281));
    function o(e) {
      var t;
      var n;
      switch (e.nodeType) {
        case 0:
          return [e.d.child, ...((t = e.d.decorators) !== null && t !== undefined ? t : [])];
        case 1:
          return [e.d.name, e.d.valueExpr];
        case 2:
          return [e.d.testExpr, e.d.exceptionExpr];
        case 4:
          return [e.d.name, e.d.rightExpr];
        case 3:
          return [e.d.leftExpr, e.d.rightExpr, e.d.annotationComment];
        case 5:
        case 7:
          return [e.d.leftExpr, e.d.rightExpr];
        case 6:
        case 16:
        case 19:
        case 67:
        case 73:
        case 44:
        case 55:
        case 56:
        case 60:
        case 61:
          return [e.d.expr];
        case 8:
        case 14:
        case 15:
        case 21:
        case 38:
        case 40:
        case 42:
        case 49:
          return [];
        case 9:
          return [e.d.leftExpr, ...e.d.args];
        case 64:
          return [e.d.pattern, e.d.guardExpr, e.d.suite];
        case 10:
          return [...e.d.decorators, e.d.name, e.d.typeParams, ...e.d.arguments, e.d.suite];
        case 11:
          return [e.d.expr, ...e.d.forIfNodes];
        case 12:
          return [e.d.targetExpr, e.d.iterableExpr];
        case 13:
          return [e.d.testExpr];
        case 17:
        case 32:
        case 39:
          return e.d.targets;
        case 18:
        case 34:
        case 45:
        case 52:
          return e.d.items;
        case 20:
          return [e.d.keyExpr, e.d.valueExpr];
        case 22:
          return [e.d.testExpr, e.d.ifSuite, e.d.elseSuite];
        case 23:
          return e.d.list;
        case 24:
          return [e.d.module, e.d.alias];
        case 25:
          return [e.d.module, ...e.d.imports];
        case 26:
          return [e.d.name, e.d.alias];
        case 27:
          return [e.d.leftExpr, ...e.d.items];
        case 28:
          return [e.d.typeExpr, e.d.name, e.d.exceptSuite];
        case 29:
          return [e.d.targetExpr, e.d.iterableExpr, e.d.forSuite, e.d.elseSuite];
        case 30:
          return [...e.d.fieldExprs, ...((n = e.d.formatExprs) !== null && n !== undefined ? n : [])];
        case 31:
          return [...e.d.decorators, e.d.name, e.d.typeParams, ...e.d.params, e.d.returnAnnotation, e.d.funcAnnotationComment, e.d.suite];
        case 62:
          return [...e.d.paramAnnotations, e.d.returnAnnotation];
        case 33:
          return [...e.d.params, e.d.expr];
        case 63:
          return [e.d.expr, ...e.d.cases];
        case 35:
          return [e.d.leftExpr, e.d.member];
        case 37:
          return e.d.nameParts;
        case 36:
        case 50:
          return [...e.d.statements];
        case 41:
          return [e.d.name, e.d.annotation, e.d.annotationComment, e.d.defaultValue];
        case 66:
          return [...e.d.orPatterns, e.d.target];
        case 68:
          return [e.d.className, ...e.d.args];
        case 74:
          return [e.d.name, e.d.pattern];
        case 69:
        case 72:
          return [e.d.target];
        case 71:
          return [e.d.keyPattern, e.d.valuePattern];
        case 70:
        case 65:
          return [...e.d.entries];
        case 43:
          return [e.d.expr, e.d.fromExpr];
        case 46:
          return [e.d.startValue, e.d.endValue, e.d.stepValue];
        case 47:
          return e.d.statements;
        case 48:
          return [e.d.annotation, ...e.d.strings];
        case 51:
          return [e.d.ifExpr, e.d.testExpr, e.d.elseExpr];
        case 53:
          return [e.d.trySuite, ...e.d.exceptClauses, e.d.elseSuite, e.d.finallySuite];
        case 77:
          return [e.d.name, e.d.typeParams, e.d.expr];
        case 54:
          return [e.d.valueExpr, e.d.annotation];
        case 75:
          return [e.d.name, e.d.boundExpr, e.d.defaultExpr];
        case 76:
          return [...e.d.params];
        case 57:
          return [e.d.testExpr, e.d.whileSuite, e.d.elseSuite];
        case 58:
          return [...e.d.withItems, e.d.suite];
        case 59:
          return [e.d.expr, e.d.target];
        default:
          i.assertNever(e, `Unknown node type ${e}`);
      }
    }
    class l {
      constructor(e) {
        this._default = e;
      }
      visit(e) {
        switch (e.nodeType) {
          case 0:
            return this.visitError(e);
          case 1:
            return this.visitArgument(e);
          case 2:
            return this.visitAssert(e);
          case 4:
            return this.visitAssignmentExpression(e);
          case 3:
            return this.visitAssignment(e);
          case 5:
            return this.visitAugmentedAssignment(e);
          case 6:
            return this.visitAwait(e);
          case 7:
            return this.visitBinaryOperation(e);
          case 8:
            return this.visitBreak(e);
          case 9:
            return this.visitCall(e);
          case 64:
            return this.visitCase(e);
          case 10:
            return this.visitClass(e);
          case 11:
            return this.visitComprehension(e);
          case 12:
            return this.visitComprehensionFor(e);
          case 13:
            return this.visitComprehensionIf(e);
          case 14:
            return this.visitConstant(e);
          case 15:
            return this.visitContinue(e);
          case 16:
            return this.visitDecorator(e);
          case 17:
            return this.visitDel(e);
          case 18:
            return this.visitDictionary(e);
          case 19:
            return this.visitDictionaryExpandEntry(e);
          case 20:
            return this.visitDictionaryKeyEntry(e);
          case 21:
            return this.visitEllipsis(e);
          case 22:
            return this.visitIf(e);
          case 23:
            return this.visitImport(e);
          case 24:
            return this.visitImportAs(e);
          case 25:
            return this.visitImportFrom(e);
          case 26:
            return this.visitImportFromAs(e);
          case 27:
            return this.visitIndex(e);
          case 28:
            return this.visitExcept(e);
          case 29:
            return this.visitFor(e);
          case 30:
            return this.visitFormatString(e);
          case 31:
            return this.visitFunction(e);
          case 62:
            return this.visitFunctionAnnotation(e);
          case 32:
            return this.visitGlobal(e);
          case 33:
            return this.visitLambda(e);
          case 34:
            return this.visitList(e);
          case 63:
            return this.visitMatch(e);
          case 35:
            return this.visitMemberAccess(e);
          case 37:
            return this.visitModuleName(e);
          case 36:
            return this.visitModule(e);
          case 38:
            return this.visitName(e);
          case 39:
            return this.visitNonlocal(e);
          case 40:
            return this.visitNumber(e);
          case 41:
            return this.visitParameter(e);
          case 42:
            return this.visitPass(e);
          case 66:
            return this.visitPatternAs(e);
          case 68:
            return this.visitPatternClass(e);
          case 74:
            return this.visitPatternClassArgument(e);
          case 69:
            return this.visitPatternCapture(e);
          case 67:
            return this.visitPatternLiteral(e);
          case 72:
            return this.visitPatternMappingExpandEntry(e);
          case 71:
            return this.visitPatternMappingKeyEntry(e);
          case 70:
            return this.visitPatternMapping(e);
          case 65:
            return this.visitPatternSequence(e);
          case 73:
            return this.visitPatternValue(e);
          case 43:
            return this.visitRaise(e);
          case 44:
            return this.visitReturn(e);
          case 45:
            return this.visitSet(e);
          case 46:
            return this.visitSlice(e);
          case 47:
            return this.visitStatementList(e);
          case 48:
            return this.visitStringList(e);
          case 49:
            return this.visitString(e);
          case 50:
            return this.visitSuite(e);
          case 51:
            return this.visitTernary(e);
          case 52:
            return this.visitTuple(e);
          case 53:
            return this.visitTry(e);
          case 77:
            return this.visitTypeAlias(e);
          case 54:
            return this.visitTypeAnnotation(e);
          case 75:
            return this.visitTypeParameter(e);
          case 76:
            return this.visitTypeParameterList(e);
          case 55:
            return this.visitUnaryOperation(e);
          case 56:
            return this.visitUnpack(e);
          case 57:
            return this.visitWhile(e);
          case 58:
            return this.visitWith(e);
          case 59:
            return this.visitWithItem(e);
          case 60:
            return this.visitYield(e);
          case 61:
            return this.visitYieldFrom(e);
          default:
            i.assertNever(e, `Unknown node type ${e}`);
        }
      }
      visitArgument(e) {
        return this._default;
      }
      visitAssert(e) {
        return this._default;
      }
      visitAssignment(e) {
        return this._default;
      }
      visitAssignmentExpression(e) {
        return this._default;
      }
      visitAugmentedAssignment(e) {
        return this._default;
      }
      visitAwait(e) {
        return this._default;
      }
      visitBinaryOperation(e) {
        return this._default;
      }
      visitBreak(e) {
        return this._default;
      }
      visitCall(e) {
        return this._default;
      }
      visitCase(e) {
        return this._default;
      }
      visitClass(e) {
        return this._default;
      }
      visitComprehension(e) {
        return this._default;
      }
      visitComprehensionFor(e) {
        return this._default;
      }
      visitComprehensionIf(e) {
        return this._default;
      }
      visitContinue(e) {
        return this._default;
      }
      visitConstant(e) {
        return this._default;
      }
      visitDecorator(e) {
        return this._default;
      }
      visitDel(e) {
        return this._default;
      }
      visitDictionary(e) {
        return this._default;
      }
      visitDictionaryKeyEntry(e) {
        return this._default;
      }
      visitDictionaryExpandEntry(e) {
        return this._default;
      }
      visitError(e) {
        return this._default;
      }
      visitEllipsis(e) {
        return this._default;
      }
      visitIf(e) {
        return this._default;
      }
      visitImport(e) {
        return this._default;
      }
      visitImportAs(e) {
        return this._default;
      }
      visitImportFrom(e) {
        return this._default;
      }
      visitImportFromAs(e) {
        return this._default;
      }
      visitIndex(e) {
        return this._default;
      }
      visitExcept(e) {
        return this._default;
      }
      visitFor(e) {
        return this._default;
      }
      visitFormatString(e) {
        return this._default;
      }
      visitFunction(e) {
        return this._default;
      }
      visitFunctionAnnotation(e) {
        return this._default;
      }
      visitGlobal(e) {
        return this._default;
      }
      visitLambda(e) {
        return this._default;
      }
      visitList(e) {
        return this._default;
      }
      visitMatch(e) {
        return this._default;
      }
      visitMemberAccess(e) {
        return this._default;
      }
      visitModule(e) {
        return this._default;
      }
      visitModuleName(e) {
        return this._default;
      }
      visitName(e) {
        return this._default;
      }
      visitNonlocal(e) {
        return this._default;
      }
      visitNumber(e) {
        return this._default;
      }
      visitParameter(e) {
        return this._default;
      }
      visitPass(e) {
        return this._default;
      }
      visitPatternCapture(e) {
        return this._default;
      }
      visitPatternClass(e) {
        return this._default;
      }
      visitPatternClassArgument(e) {
        return this._default;
      }
      visitPatternAs(e) {
        return this._default;
      }
      visitPatternLiteral(e) {
        return this._default;
      }
      visitPatternMapping(e) {
        return this._default;
      }
      visitPatternMappingExpandEntry(e) {
        return this._default;
      }
      visitPatternMappingKeyEntry(e) {
        return this._default;
      }
      visitPatternSequence(e) {
        return this._default;
      }
      visitPatternValue(e) {
        return this._default;
      }
      visitRaise(e) {
        return this._default;
      }
      visitReturn(e) {
        return this._default;
      }
      visitSet(e) {
        return this._default;
      }
      visitSlice(e) {
        return this._default;
      }
      visitStatementList(e) {
        return this._default;
      }
      visitString(e) {
        return this._default;
      }
      visitStringList(e) {
        return this._default;
      }
      visitSuite(e) {
        return this._default;
      }
      visitTernary(e) {
        return this._default;
      }
      visitTuple(e) {
        return this._default;
      }
      visitTry(e) {
        return this._default;
      }
      visitTypeAlias(e) {
        return this._default;
      }
      visitTypeAnnotation(e) {
        return this._default;
      }
      visitTypeParameter(e) {
        return this._default;
      }
      visitTypeParameterList(e) {
        return this._default;
      }
      visitUnaryOperation(e) {
        return this._default;
      }
      visitUnpack(e) {
        return this._default;
      }
      visitWhile(e) {
        return this._default;
      }
      visitWith(e) {
        return this._default;
      }
      visitWithItem(e) {
        return this._default;
      }
      visitYield(e) {
        return this._default;
      }
      visitYieldFrom(e) {
        return this._default;
      }
    }
    exports.ParseTreeVisitor = l;
    exports.ParseTreeWalker = class extends l {
      constructor() {
        super(true);
      }
      walk(e) {
        const t = this.visitNode(e);
        if (t.length > 0) {
          this.walkMultiple(t);
        }
      }
      walkMultiple(e) {
        e.forEach(e => {
          if (e) {
            this.walk(e);
          }
        });
      }
      visitNode(e) {
        if (this.visit(e)) {
          return o(e);
        } else {
          return [];
        }
      }
    };
  },
  69932: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.narrowTypeBasedOnPattern = f;
    exports.checkForUnusedPattern = function (e, t, n) {
      if (m.isNever(n)) {
        w(e, t, n);
      } else {
        if (t.nodeType === 66 && t.d.orPatterns.length > 1) {
          t.d.orPatterns.forEach(t => {
            const a = f(e, n, t, true);
            if (m.isNever(a)) {
              w(e, t, n);
            }
            n = f(e, n, t, false);
          });
        } else {
          const a = f(e, n, t, true);
          if (m.isNever(a)) {
            w(e, t, n);
          }
        }
      }
    };
    exports.assignTypeToPatternTargets = function e(t, n, a, r) {
      const l = f(t, n, r, true);
      switch (r.nodeType) {
        case 65:
          {
            const n = C(t, r, l).filter(e => !e.isDefiniteNoMatch);
            r.d.entries.forEach((s, i) => {
              const o = m.combineTypes(n.map(e => I(t, r, e, i, r.d.entries.length, r.d.starEntryIndex, false)));
              e(t, o, a, s);
            });
            break;
          }
        case 66:
          {
            if (r.d.target) {
              t.assignTypeToExpression(r.d.target, {
                type: l,
                isIncomplete: a
              }, r.d.target);
            }
            let n = l;
            r.d.orPatterns.forEach(r => {
              e(t, n, a, r);
              n = f(t, n, r, false);
            });
            break;
          }
        case 69:
          if (r.d.isWildcard) {
            if (!a) {
              if (m.isUnknown(l)) {
                t.addDiagnostic(i.DiagnosticRule.reportUnknownVariableType, o.LocMessage.wildcardPatternTypeUnknown(), r.d.target);
              } else {
                if (y.isPartlyUnknown(l)) {
                  const e = new s.DiagnosticAddendum();
                  e.addMessage(o.LocAddendum.typeOfSymbol().format({
                    name: '_',
                    type: t.printType(l, {
                      expandTypeAlias: true
                    })
                  }));
                  t.addDiagnostic(i.DiagnosticRule.reportUnknownVariableType, o.LocMessage.wildcardPatternTypePartiallyUnknown() + e.getString(), r.d.target);
                }
              }
            }
          } else {
            t.assignTypeToExpression(r.d.target, {
              type: l,
              isIncomplete: a
            }, r.d.target);
          }
          break;
        case 70:
          {
            const n = _(t, l, r);
            r.d.entries.forEach(s => {
              const i = [];
              const o = [];
              n.forEach(e => {
                if (e.typedDict) {
                  if (s.nodeType === 71) {
                    const n = f(t, t.getBuiltInObject(r, 'str'), s.d.keyPattern, true);
                    i.push(n);
                    y.doForEachSubtype(n, n => {
                      if (m.isClassInstance(n) && m.ClassType.isBuiltIn(n, 'str') && y.isLiteralType(n)) {
                        const a = c.getTypedDictMembersForClass(t, e.typedDict).knownItems.get(n.priv.literalValue);
                        o.push(a ? a.valueType : m.UnknownType.create());
                      } else {
                        o.push(m.UnknownType.create());
                      }
                    });
                  } else {
                    if (s.nodeType === 72) {
                      i.push(t.getBuiltInObject(r, 'str'));
                      o.push(t.getObjectType());
                    }
                  }
                } else {
                  if (e.dictTypeArgs) {
                    if (s.nodeType === 71) {
                      const n = f(t, e.dictTypeArgs.key, s.d.keyPattern, true);
                      i.push(n);
                      o.push(f(t, e.dictTypeArgs.value, s.d.valuePattern, true));
                    } else {
                      if (s.nodeType === 72) {
                        i.push(e.dictTypeArgs.key);
                        o.push(e.dictTypeArgs.value);
                      }
                    }
                  }
                }
              });
              const l = m.combineTypes(i);
              const p = m.combineTypes(o);
              if (s.nodeType === 71) {
                e(t, l, a, s.d.keyPattern);
                e(t, p, a, s.d.valuePattern);
              } else {
                if (s.nodeType === 72) {
                  const e = t.getBuiltInType(r, 'dict');
                  const n = t.getBuiltInObject(r, 'str');
                  const i = e && m.isInstantiableClass(e) && m.isClassInstance(n) ? m.ClassType.cloneAsInstance(m.ClassType.specialize(e, [l, p])) : m.UnknownType.create();
                  t.assignTypeToExpression(s.d.target, {
                    type: i,
                    isIncomplete: a
                  }, s.d.target);
                }
              }
            });
            break;
          }
        case 68:
          {
            const n = r.d.args.map(e => []);
            t.mapSubtypesExpandTypeVars(l, undefined, e => {
              if (m.isClassInstance(e)) {
                y.doForEachSubtype(l, a => {
                  const s = t.makeTopLevelTypeVarsConcrete(a);
                  if (m.isAnyOrUnknown(s)) {
                    r.d.args.forEach((e, t) => {
                      n[t].push(s);
                    });
                  } else {
                    if (m.isClassInstance(s)) {
                      let a = [];
                      if (r.d.args.some(e => !e.d.name)) {
                        a = T(t, m.ClassType.cloneAsInstantiable(e));
                      }
                      r.d.args.forEach((r, s) => {
                        const i = b(t, r, s, a, m.ClassType.cloneAsInstantiable(e), true);
                        n[s].push(i);
                      });
                    }
                  }
                });
              } else {
                r.d.args.forEach((e, t) => {
                  n[t].push(m.UnknownType.create());
                });
              }
            });
            r.d.args.forEach((r, s) => {
              e(t, m.combineTypes(n[s]), a, r.d.pattern);
            });
            break;
          }
      }
      return l;
    };
    exports.validateClassPattern = function (e, t) {
      var n;
      var a;
      let r = e.getTypeOfExpression(t.d.className, 2).type;
      if ((n = r.props) === null || n === undefined ? undefined : n.specialForm) {
        r = r.props.specialForm;
      }
      if (m.isAnyOrUnknown(r)) {
        return;
      }
      if (((a = r.props) === null || a === undefined ? undefined : a.typeAliasInfo) && m.isInstantiableClass(r) && r.priv.typeArgs && r.priv.isTypeArgExplicit) {
        e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocMessage.classPatternTypeAlias().format({
          type: e.printType(r)
        }), t.d.className);
      } else {
        if (m.isInstantiableClass(r)) {
          const n = v(r);
          if (n && t.d.args.length === 1 && t.d.args[0].d.name) {
            e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocMessage.classPatternBuiltInArgPositional(), t.d.args[0].d.name);
          }
          let a = t.d.args.findIndex(e => e.d.name !== undefined);
          if (a < 0) {
            a = t.d.args.length;
          }
          let s = 1;
          if (!n) {
            let n = [];
            if (t.d.args.some(e => !e.d.name)) {
              n = T(e, r);
            }
            s = n.length;
          }
          if (a > s) {
            e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocMessage.classPatternPositionalArgCount().format({
              type: r.shared.name,
              expected: s,
              received: a
            }), t.d.args[s]);
          }
        } else {
          if (!m.isNever(r)) {
            e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocAddendum.typeNotClass().format({
              type: e.printType(r)
            }), t.d.className);
          }
        }
      }
    };
    exports.getPatternSubtypeNarrowingCallback = function (e, t, n) {
      if (n.nodeType === 27 && n.d.items.length === 1 && !n.d.trailingComma && n.d.items[0].d.argCategory === 0 && d.isMatchingExpression(t, n.d.leftExpr)) {
        const t = e.getTypeOfExpression(n.d.items[0].d.valueExpr);
        const a = t.type;
        if (m.isClassInstance(a) && y.isLiteralType(a) && m.ClassType.isBuiltIn(a, ['int', 'str'])) {
          const r = e.getTypeOfExpression(n.d.leftExpr, 2);
          const s = r.type;
          return n => {
            let i = true;
            const o = [];
            y.doForEachSubtype(n, t => {
              t = e.makeTopLevelTypeVarsConcrete(t);
              if (m.isClassInstance(t) && t.priv.literalValue !== undefined) {
                if (m.ClassType.isBuiltIn(a, 'str')) {
                  o.push(u.narrowTypeForDiscriminatedDictEntryComparison(e, s, a, t, true));
                } else {
                  o.push(u.narrowTypeForDiscriminatedTupleComparison(e, s, a, t, true));
                }
              } else {
                if (!m.isNever(t)) {
                  i = false;
                }
              }
            });
            if (i) {
              return {
                type: m.combineTypes(o),
                isIncomplete: t.isIncomplete || r.isIncomplete
              };
            }
          };
        }
      }
      if (n.nodeType === 52) {
        const a = n.d.items.findIndex(e => d.isMatchingExpression(t, e));
        if (a >= 0) {
          const t = e.getTypeOfExpression(n.d.items[a]);
          return e => {
            let n = true;
            const r = [];
            y.doForEachSubtype(e, t => {
              if (m.isClassInstance(t) && m.ClassType.isBuiltIn(t, 'tuple') && t.priv.tupleTypeArgs && a < t.priv.tupleTypeArgs.length && t.priv.tupleTypeArgs.every(e => !e.isUnbounded)) {
                r.push(t.priv.tupleTypeArgs[a].type);
              } else {
                if (m.isNever(e)) {
                  r.push(e);
                } else {
                  n = false;
                }
              }
            });
            if (n) {
              return {
                type: m.combineTypes(r),
                isIncomplete: t.isIncomplete
              };
            } else {
              return undefined;
            }
          };
        }
      }
      if (n.nodeType === 35 && d.isMatchingExpression(t, n.d.leftExpr)) {
        const t = e.getTypeOfExpression(n.d.leftExpr, 2).type;
        return a => {
          if (m.isNever(a)) {
            return {
              type: m.NeverType.createNever()
            };
          }
          if (!y.isLiteralTypeOrUnion(a)) {
            return;
          }
          return {
            type: y.mapSubtypes(a, a => {
              r.assert(m.isClassInstance(a) && a.priv.literalValue !== undefined);
              return u.narrowTypeForDiscriminatedLiteralFieldComparison(e, t, n.d.member.d.value, a, true);
            })
          };
        };
      }
      return;
    };
    const a = require(58147);
    const r = require(48281);
    const s = require(11479);
    const i = require(65880);
    const o = require(67703);
    const l = require(10081);
    const p = require(86672);
    const d = require(41557);
    const c = require(66308);
    const u = require(18891);
    const m = require(21024);
    const y = require(92324);
    const g = ['builtins.bool', 'builtins.bytearray', 'builtins.bytes', 'builtins.dict', 'builtins.float', 'builtins.frozenset', 'builtins.int', 'builtins.list', 'builtins.set', 'builtins.str', 'builtins.tuple'];
    const h = 128;
    function f(e, t, n, r) {
      switch (n.nodeType) {
        case 65:
          return function (e, t, n, r) {
            let s = false;
            t = y.transformPossibleRecursiveTypeAlias(t);
            let i = C(e, n, t);
            i = i.filter(t => {
              var i;
              if (t.isDefiniteNoMatch) {
                return !r;
              }
              let o = true;
              let l = true;
              const p = [];
              const d = [];
              let c = t.isTuple;
              if (!r && ((t.isIndeterminateLength || t.isUnboundedTuple) && (c = false), m.isClassInstance(t.subtype) && t.subtype.priv.tupleTypeArgs)) {
                const e = t.subtype.priv.tupleTypeArgs.findIndex(e => e.isUnbounded);
                if (e >= 0) {
                  if (n.d.starEntryIndex === undefined || n.d.starEntryIndex !== e) {
                    c = false;
                  }
                }
              }
              if (t.isIndeterminateLength) {
                if (n.d.entries.length !== 1 || n.d.starEntryIndex !== 0) {
                  l = false;
                }
              }
              const u = [];
              n.d.entries.forEach((s, i) => {
                const g = I(e, n, t, i, n.d.entries.length, n.d.starEntryIndex, true);
                d.push(g);
                const h = f(e, g, s, r);
                if (r) {
                  if (i === n.d.starEntryIndex) {
                    if (m.isClassInstance(h) && h.priv.tupleTypeArgs && !y.isUnboundedTupleClass(h) && h.priv.tupleTypeArgs) {
                      a.appendArray(p, h.priv.tupleTypeArgs.map(e => e.type));
                    } else {
                      p.push(h);
                      c = false;
                    }
                  } else {
                    p.push(h);
                    if (m.isNever(h)) {
                      o = false;
                    }
                  }
                } else {
                  if (t.isPotentialNoMatch) {
                    l = false;
                  }
                  if (m.isNever(h)) {
                    p.push(g);
                  } else {
                    l = false;
                    u.push(i);
                    p.push(h);
                  }
                  if (i === n.d.starEntryIndex) {
                    c = false;
                  }
                }
              });
              if (n.d.entries.length === 0) {
                if (t.entryTypes.length > 0) {
                  p.push(m.combineTypes(t.entryTypes));
                }
                if (t.isPotentialNoMatch) {
                  l = false;
                }
              }
              if (!r) {
                if (l) {
                  return false;
                }
                if (c && u.length > 0) {
                  const a = e.getBuiltInType(n, 'tuple');
                  if (a && m.isInstantiableClass(a)) {
                    const e = [];
                    for (const t of u) {
                      const n = [...d];
                      n[t] = p[t];
                      e.push(n);
                    }
                    t.subtype = m.combineTypes(e.map(e => m.ClassType.cloneAsInstance(y.specializeTupleClass(a, e.map(e => ({
                      type: e,
                      isUnbounded: false
                    }))))));
                    s = true;
                  }
                }
                return true;
              }
              if (o) {
                if (c) {
                  const a = e.getBuiltInType(n, 'tuple');
                  if (a && m.isInstantiableClass(a)) {
                    t.subtype = m.ClassType.cloneAsInstance(y.specializeTupleClass(a, p.map(e => ({
                      type: e,
                      isUnbounded: false
                    }))));
                  }
                }
                if (t.isPotentialNoMatch && !t.isTuple) {
                  const a = e.getTypingType(n, 'Sequence');
                  if (a && m.isInstantiableClass(a)) {
                    let n = e.stripLiteralValue(m.combineTypes(p));
                    n = (i = y.containsAnyOrUnknown(n, false)) !== null && i !== undefined ? i : n;
                    t.subtype = m.ClassType.cloneAsInstance(m.ClassType.specialize(a, [n]));
                  }
                }
              }
              return o;
            });
            return m.combineTypes(i.map(e => e.subtype), {
              maxSubtypeCount: s ? h : undefined
            });
          }(e, t, n, r);
        case 67:
          return function (e, t, n, a) {
            const r = e.getTypeOfExpression(n.d.expr).type;
            if (!a) {
              return e.mapSubtypesExpandTypeVars(t, undefined, t => {
                if ((!m.isClassInstance(r) || !y.isLiteralType(r) || !m.isClassInstance(t) || !y.isLiteralType(t) || !e.assignType(r, t)) && (!y.isNoneInstance(t) || !y.isNoneInstance(r))) {
                  if (m.isClassInstance(t) && m.ClassType.isBuiltIn(t, 'bool') && t.priv.literalValue === undefined && m.isClassInstance(r) && m.ClassType.isBuiltIn(r, 'bool') && r.priv.literalValue !== undefined) {
                    return m.ClassType.cloneWithLiteral(r, !r.priv.literalValue);
                  } else {
                    return t;
                  }
                }
              });
            }
            return e.mapSubtypesExpandTypeVars(t, undefined, (t, n) => e.assignType(t, r) ? r : m.isClassInstance(r) && y.isLiteralType(r) && m.isClassInstance(t) && !y.isLiteralType(t) && e.assignType(m.ClassType.cloneWithLiteral(r, undefined), t) ? t : undefined);
          }(e, t, n, r);
        case 68:
          return function (e, t, n, a) {
            var r;
            let s = e.getTypeOfExpression(n.d.className, 2).type;
            if (m.isClass(s) && !((r = s.props) === null || r === undefined ? undefined : r.typeAliasInfo)) {
              s = m.ClassType.cloneRemoveTypePromotions(s);
              s = y.specializeWithUnknownTypeArgs(s, e.getTupleClassType());
            }
            let d = [];
            if (n.d.args.some(e => !e.d.name) && m.isInstantiableClass(s)) {
              d = T(e, s);
            }
            if (!a) {
              if (!m.isInstantiableClass(s)) {
                return t;
              }
              let r = s;
              if (r.shared.typeParams.length > 0) {
                r = m.ClassType.specialize(r, undefined);
              }
              const i = m.ClassType.cloneAsInstance(r);
              const o = y.isMetaclassInstance(i);
              return e.mapSubtypesExpandTypeVars(t, {
                expandCallback: t => e.expandPromotionTypes(n, t)
              }, (t, s) => {
                var l;
                if (o && m.isInstantiableClass(t)) {
                  const n = (l = t.shared.effectiveMetaclass) !== null && l !== undefined ? l : m.UnknownType.create();
                  if (m.isInstantiableClass(r) && e.assignType(r, n)) {
                    return;
                  }
                  return t;
                }
                if (m.isAnyOrUnknown(t) || !m.isInstantiableClass(r) || !m.ClassType.isBuiltIn(r, 'Callable') || !e.assignType(y.getUnknownTypeForCallable(), t)) {
                  if (!y.isNoneInstance(t) && !m.isClassInstance(t)) {
                    return s;
                  }
                  if (!y.isNoneInstance(t) || !m.isInstantiableClass(r) || !m.ClassType.isBuiltIn(r, 'NoneType')) {
                    if (!e.assignType(i, t)) {
                      return t;
                    }
                    if (n.d.args.length === 0) {
                      if (m.isClass(i) && m.isClass(t)) {
                        return;
                      }
                      return t;
                    }
                    if (!e.assignType(t, i) && m.isClass(t) && !m.ClassType.isFinal(t) && !m.ClassType.isProtocolClass(i)) {
                      return t;
                    }
                    for (let r = 0; r < n.d.args.length; r++) {
                      const i = b(e, n.d.args[r], r, d, t, a);
                      if (!m.isNever(i)) {
                        return s;
                      }
                    }
                  }
                }
              });
            }
            if (!m.TypeBase.isInstantiable(s) && !m.isNever(s)) {
              e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocAddendum.typeNotClass().format({
                type: e.printType(s)
              }), n.d.className);
              if (a) {
                return m.UnknownType.create();
              } else {
                return t;
              }
            }
            if (m.isInstantiableClass(s)) {
              if (m.ClassType.isProtocolClass(s) && !m.ClassType.isRuntimeCheckable(s)) {
                e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocAddendum.protocolRequiresRuntimeCheckable(), n.d.className);
                if (a) {
                  return m.UnknownType.create();
                } else {
                  return t;
                }
              }
              if (m.ClassType.isTypedDictClass(s)) {
                e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocMessage.typedDictInClassPattern(), n.d.className);
                if (a) {
                  return m.UnknownType.create();
                } else {
                  return t;
                }
              }
            }
            return e.mapSubtypesExpandTypeVars(s, undefined, (r, s) => {
              if (m.isAnyOrUnknown(r)) {
                return s;
              }
              if (m.isInstantiableClass(r)) {
                const i = y.convertToInstance(r);
                const o = y.isMetaclassInstance(i);
                return e.mapSubtypesExpandTypeVars(t, undefined, t => {
                  var i;
                  if (m.isAnyOrUnknown(t)) {
                    if (m.isInstantiableClass(r) && m.ClassType.isBuiltIn(r, 'Callable')) {
                      const e = m.FunctionType.createSynthesizedInstance('', 32768);
                      m.FunctionType.addDefaultParams(e, m.isUnknown(t));
                      e.shared.declaredReturnType = t;
                      return e;
                    }
                    return y.convertToInstance(s);
                  }
                  if (o && m.isInstantiableClass(t)) {
                    const n = (i = t.shared.effectiveMetaclass) !== null && i !== undefined ? i : m.UnknownType.create();
                    if (e.assignType(r, n) || e.assignType(n, r)) {
                      return t;
                    } else {
                      return undefined;
                    }
                  }
                  if (y.isNoneInstance(t) && m.isInstantiableClass(r) && m.ClassType.isBuiltIn(r, 'NoneType')) {
                    return t;
                  }
                  if (m.isInstantiableClass(r) && m.ClassType.isBuiltIn(r, 'Callable')) {
                    const n = y.getUnknownTypeForCallable();
                    if (e.assignType(n, t)) {
                      return t;
                    }
                    const a = y.convertToInstance(t);
                    if (e.assignType(a, n)) {
                      return n;
                    } else {
                      return undefined;
                    }
                  }
                  if (m.isClassInstance(t)) {
                    let i;
                    if (e.assignType(m.ClassType.cloneAsInstance(r), t)) {
                      i = t;
                    } else {
                      if (!e.assignType(t, m.ClassType.cloneAsInstance(r))) {
                        return;
                      }
                      i = y.addConditionToType(y.convertToInstance(s), y.getTypeCondition(t));
                      if (m.isInstantiableClass(s) && m.isClassInstance(t) && (m.ClassType.isSpecialBuiltIn(s) || s.shared.typeParams.length > 0)) {
                        const n = new p.ConstraintTracker();
                        const a = m.ClassType.specialize(s, undefined);
                        const r = m.ClassType.cloneAsInstance(a);
                        if (l.addConstraintsForExpectedType(e, r, t, n, undefined, undefined)) {
                          i = e.solveAndApplyConstraints(r, n, {
                            replaceUnsolved: {
                              scopeIds: y.getTypeVarScopeIds(s),
                              tupleClassType: e.getTupleClassType()
                            }
                          });
                        }
                      }
                    }
                    let o = [];
                    if (n.d.args.some(e => !e.d.name)) {
                      o = T(e, r);
                    }
                    let d = true;
                    n.d.args.forEach((t, n) => {
                      const r = b(e, t, n, o, i, a);
                      if (m.isNever(r)) {
                        d = false;
                      }
                    });
                    if (d) {
                      return i;
                    }
                  }
                });
              }
            });
          }(e, t, n, r);
        case 66:
          return function (e, t, n, a) {
            let r = t;
            if (!a) {
              n.d.orPatterns.forEach(t => {
                r = f(e, r, t, false);
              });
              return r;
            }
            const s = n.d.orPatterns.map(t => {
              const n = f(e, r, t, true);
              r = f(e, r, t, false);
              return n;
            });
            return m.combineTypes(s);
          }(e, t, n, r);
        case 70:
          return function (e, t, n, a) {
            t = y.transformPossibleRecursiveTypeAlias(t);
            if (!a) {
              if (n.d.entries.length === 1 && n.d.entries[0].nodeType === 72) {
                const a = _(e, t, n);
                return m.combineTypes(a.filter(e => !e.isDefinitelyMapping).map(e => e.subtype));
              }
              if (n.d.entries.length !== 1 || n.d.entries[0].nodeType !== 71) {
                return t;
              }
              const a = n.d.entries[0].d.keyPattern;
              const r = n.d.entries[0].d.valuePattern;
              if (a.nodeType !== 67 || r.nodeType !== 66 || !r.d.orPatterns.every(e => e.nodeType === 67)) {
                return t;
              }
              const s = e.getTypeOfExpression(a.d.expr).type;
              if (!m.isClassInstance(s) || !m.ClassType.isBuiltIn(s, 'str') || s.priv.literalValue === undefined) {
                return t;
              }
              const i = s.priv.literalValue;
              const o = r.d.orPatterns.map(t => e.getTypeOfExpression(t.d.expr).type);
              return y.mapSubtypes(t, t => {
                if (m.isClassInstance(t) && m.ClassType.isTypedDictClass(t)) {
                  const n = c.getTypedDictMembersForClass(e, t, true).knownItems.get(i);
                  if (n && (n.isRequired || n.isProvided) && m.isClassInstance(n.valueType)) {
                    const e = n.valueType;
                    if (o.some(t => m.isClassInstance(t) && m.ClassType.isSameGenericClass(t, e) && t.priv.literalValue === e.priv.literalValue)) {
                      return;
                    }
                  }
                }
                return t;
              });
            }
            let r = _(e, t, n);
            r = r.filter(t => {
              if (t.isDefinitelyNotMapping) {
                return false;
              }
              let r = true;
              n.d.entries.forEach(s => {
                if (t.typedDict) {
                  if (s.nodeType === 71) {
                    const i = f(e, e.getBuiltInObject(n, 'str'), s.d.keyPattern, a);
                    if (m.isNever(i)) {
                      r = false;
                    }
                    const o = y.mapSubtypes(i, n => {
                      if (m.isAnyOrUnknown(n)) {
                        return n;
                      }
                      if (m.isClassInstance(n) && m.ClassType.isBuiltIn(n, 'str')) {
                        if (!y.isLiteralType(n)) {
                          return m.UnknownType.create();
                        }
                        const r = c.getTypedDictMembersForClass(e, t.typedDict).knownItems.get(n.priv.literalValue);
                        if (r) {
                          const i = f(e, r.valueType, s.d.valuePattern, true);
                          if (!m.isNever(i)) {
                            if (!r.isRequired && !r.isProvided && m.isTypeSame(t.subtype, t.typedDict)) {
                              const e = new Map(t.typedDict.priv.typedDictNarrowedEntries ?? []);
                              e.set(n.priv.literalValue, {
                                valueType: r.valueType,
                                isReadOnly: r.isReadOnly,
                                isRequired: false,
                                isProvided: true
                              });
                              t.subtype = m.ClassType.cloneAsInstance(m.ClassType.cloneForNarrowedTypedDictEntries(m.ClassType.cloneAsInstantiable(t.typedDict), e));
                              t.typedDict = t.subtype;
                            }
                            return i;
                          }
                        }
                      }
                    });
                    if (m.isNever(o)) {
                      r = false;
                    }
                  }
                } else {
                  if (t.dictTypeArgs && s.nodeType === 71) {
                    const n = f(e, t.dictTypeArgs.key, s.d.keyPattern, a);
                    const i = f(e, t.dictTypeArgs.value, s.d.valuePattern, a);
                    if (m.isNever(n) || m.isNever(i)) {
                      r = false;
                    }
                  }
                }
              });
              return r;
            });
            return m.combineTypes(r.map(e => e.subtype));
          }(e, t, n, r);
        case 73:
          return function (e, t, n, a) {
            const r = e.getTypeOfExpression(n.d.expr).type;
            const s = [];
            e.mapSubtypesExpandTypeVars(r, undefined, (r, i) => {
              s.push(e.mapSubtypesExpandTypeVars(t, {
                conditionFilter: y.getTypeCondition(r)
              }, t => {
                if (!a) {
                  if (m.isClassInstance(t) && m.isClassInstance(r) && m.isSameWithoutLiteralValue(t, r)) {
                    if (!y.isLiteralType(t) && y.isLiteralType(r)) {
                      const n = u.enumerateLiteralsForType(e, t);
                      if (n) {
                        return m.combineTypes(n.filter(e => !m.ClassType.isLiteralValueSame(r, e)));
                      }
                    }
                    if (y.isLiteralType(t) && m.ClassType.isLiteralValueSame(r, t)) {
                      return;
                    }
                  }
                  return t;
                }
                if (m.isNever(r) || m.isNever(t)) {
                  return m.NeverType.createNever();
                }
                if (m.isAnyOrUnknown(r) || m.isAnyOrUnknown(t)) {
                  if (m.isUnknown(r) || m.isUnknown(t)) {
                    return y.preserveUnknown(r, t);
                  } else {
                    return m.AnyType.create();
                  }
                }
                if (m.isClassInstance(t) && y.isLiteralType(t) && m.isClassInstance(r) && y.isLiteralType(r)) {
                  if (m.isSameWithoutLiteralValue(t, r) && m.ClassType.isLiteralValueSame(r, t)) {
                    return i;
                  } else {
                    return undefined;
                  }
                }
                if (e.useSpeculativeMode(n.d.expr, () => e.getTypeOfMagicMethodCall(r, '__eq__', [{
                  type: t
                }], n.d.expr, undefined))) {
                  return i;
                } else {
                  return undefined;
                }
              }));
            });
            return m.combineTypes(s);
          }(e, t, n, r);
        case 69:
          if (r) {
            return t;
          } else {
            return m.NeverType.createNever();
          }
        case 0:
          return t;
      }
    }
    function T(e, t) {
      const n = y.lookUpClassMember(t, '__match_args__');
      if (n) {
        const t = e.getTypeOfMember(n);
        if (m.isClassInstance(t) && y.isTupleClass(t) && !y.isUnboundedTupleClass(t) && t.priv.tupleTypeArgs) {
          const e = t.priv.tupleTypeArgs;
          if (e.every(e => m.isClassInstance(e.type) && m.ClassType.isBuiltIn(e.type, 'str') && y.isLiteralType(e.type))) {
            return e.map(e => e.type.priv.literalValue);
          }
        }
      }
      return [];
    }
    function v(e) {
      if (g.some(t => e.shared.fullName === t)) {
        return true;
      }
      if (y.lookUpClassMember(e, '__match_args__')) {
        return false;
      }
      for (const t of e.shared.mro) {
        if (m.isClass(t) && g.some(e => t.shared.fullName === e)) {
          return true;
        }
      }
      return false;
    }
    function b(e, t, n, a, r, s) {
      var i;
      let o;
      if (t.d.name) {
        o = t.d.name.d.value;
      } else {
        if (n < a.length) {
          o = a[n];
        }
      }
      if (m.isAnyOrUnknown(r)) {
        return r;
      }
      if (!m.isClass(r)) {
        return m.UnknownType.create();
      }
      let l;
      let p = false;
      let d = r;
      if (!t.d.name && m.isClass(r) && n === 0) {
        if (v(r)) {
          p = true;
        } else {
          if (a.length === 0) {
            r.shared.mro.forEach(e => {
              if (m.isClass(e) && v(e)) {
                d = e;
                p = true;
              }
            });
          }
        }
      }
      if (p) {
        l = m.ClassType.cloneAsInstance(d);
      } else {
        if (o) {
          l = (i = e.useSpeculativeMode(t, () => e.getTypeOfBoundMember(t, m.ClassType.cloneAsInstance(r), o))) === null || i === undefined ? undefined : i.type;
        }
        if (!l) {
          if (!s) {
            return r;
          }
          if (m.ClassType.isFinal(r)) {
            return m.NeverType.createNever();
          }
          l = m.UnknownType.create();
        }
      }
      return f(e, l, t.d.pattern, s);
    }
    function _(e, t, n) {
      const a = [];
      y.doForEachSubtype(t, t => {
        const r = e.makeTopLevelTypeVarsConcrete(t);
        if (m.isAnyOrUnknown(r)) {
          a.push({
            subtype: t,
            isDefinitelyMapping: false,
            isDefinitelyNotMapping: false,
            dictTypeArgs: {
              key: r,
              value: r
            }
          });
        } else {
          if (m.isClassInstance(r)) {
            if (m.ClassType.isTypedDictClass(r)) {
              a.push({
                subtype: t,
                isDefinitelyMapping: true,
                isDefinitelyNotMapping: false,
                typedDict: r
              });
              return;
            }
            const s = e.getTypingType(n, 'Mapping');
            if (!s || !m.isInstantiableClass(s)) {
              return;
            }
            const i = m.ClassType.cloneAsInstance(s);
            const o = new p.ConstraintTracker();
            if (e.assignType(i, t, undefined, o)) {
              const n = e.solveAndApplyConstraints(i, o);
              if (n.priv.typeArgs && n.priv.typeArgs.length >= 2) {
                a.push({
                  subtype: t,
                  isDefinitelyMapping: true,
                  isDefinitelyNotMapping: false,
                  dictTypeArgs: {
                    key: n.priv.typeArgs[0],
                    value: n.priv.typeArgs[1]
                  }
                });
              }
              return;
            }
            if (e.assignType(t, i)) {
              a.push({
                subtype: t,
                isDefinitelyMapping: false,
                isDefinitelyNotMapping: false,
                dictTypeArgs: {
                  key: m.UnknownType.create(),
                  value: m.UnknownType.create()
                }
              });
              return;
            }
            a.push({
              subtype: t,
              isDefinitelyMapping: false,
              isDefinitelyNotMapping: true
            });
          }
        }
      });
      return a;
    }
    function C(e, t, n) {
      const a = t.d.entries.length;
      const r = t.d.starEntryIndex;
      const s = [];
      y.doForEachSubtype(n, n => {
        const o = e.makeTopLevelTypeVarsConcrete(n);
        let c;
        if (m.isClassInstance(o)) {
          for (const e of o.shared.mro) {
            if (!m.isInstantiableClass(e)) {
              break;
            }
            if (m.ClassType.isBuiltIn(e, 'str') || m.ClassType.isBuiltIn(e, 'bytes') || m.ClassType.isBuiltIn(e, 'bytearray')) {
              s.push({
                subtype: n,
                entryTypes: [],
                isIndeterminateLength: true,
                isDefiniteNoMatch: true
              });
              return;
            }
            if (m.ClassType.isBuiltIn(e, 'Sequence')) {
              c = e;
              break;
            }
            if (y.isTupleClass(e)) {
              c = e;
              break;
            }
          }
          if (c) {
            const l = y.partiallySpecializeType(c, o, e.getTypeClassType());
            if (!y.isTupleClass(l)) {
              s.push({
                subtype: n,
                entryTypes: [l.priv.typeArgs && l.priv.typeArgs.length > 0 ? l.priv.typeArgs[0] : m.UnknownType.create()],
                isIndeterminateLength: true,
                isDefiniteNoMatch: false
              });
              return;
            }
            {
              const o = l.priv.tupleTypeArgs ?? [{
                type: m.UnknownType.create(),
                isUnbounded: true
              }];
              const p = o.findIndex(e => e.isUnbounded || m.isUnpackedTypeVarTuple(e.type) || m.isUnpackedTypeVar(e.type));
              let d = o.length;
              if (p >= 0) {
                for (d--; o.length < a;) {
                  o.splice(p, 0, o[p]);
                }
                if (o.length > a && r === undefined) {
                  o.splice(p, 1);
                }
              }
              if (r !== undefined && o.length >= 2 && o.length > a) {
                const e = o.length - a + 1;
                const t = o.splice(r, e);
                o.splice(r, 0, {
                  type: m.combineTypes(t.map(e => e.type)),
                  isUnbounded: t.every(e => e.isUnbounded || m.isUnpackedTypeVarTuple(e.type) || m.isUnpackedTypeVar(e.type))
                });
              }
              if (o.length === a) {
                let i = false;
                let l = p >= 0;
                if (r !== undefined && p >= 0 && t.d.entries.length - 1 === d && r === p) {
                  l = false;
                }
                for (let n = 0; n < a; n++) {
                  const a = t.d.entries[n];
                  const r = o[n].type;
                  const s = f(e, r, a, true);
                  if (m.isNever(s)) {
                    i = true;
                  }
                }
                s.push({
                  subtype: n,
                  entryTypes: i ? [] : o.map(e => e.type),
                  isIndeterminateLength: false,
                  isTuple: true,
                  isUnboundedTuple: p >= 0,
                  isDefiniteNoMatch: i,
                  isPotentialNoMatch: l
                });
                return;
              }
              if (r !== undefined) {
                let i = false;
                if (o.length === a - 1) {
                  i = true;
                  o.splice(r, 0, {
                    type: m.AnyType.create(),
                    isUnbounded: true
                  });
                } else {
                  if (o.length === a && o[r].isUnbounded) {
                    i = true;
                  }
                }
                if (i) {
                  let i = false;
                  for (let n = 0; n < a; n++) {
                    if (n === r) {
                      continue;
                    }
                    const a = t.d.entries[n];
                    const s = o[n].type;
                    const l = f(e, s, a, true);
                    if (m.isNever(l)) {
                      i = true;
                    }
                  }
                  s.push({
                    subtype: n,
                    entryTypes: i ? [] : o.map(e => e.type),
                    isIndeterminateLength: false,
                    isTuple: true,
                    isUnboundedTuple: p >= 0,
                    isDefiniteNoMatch: i
                  });
                  return;
                }
              }
            }
          }
        }
        if (!c) {
          const a = e.getTypingType(t, 'Sequence');
          if (a && m.isInstantiableClass(a)) {
            const r = m.ClassType.cloneAsInstance(a);
            const i = new p.ConstraintTracker();
            if (e.assignType(r, n, undefined, i)) {
              const t = e.solveAndApplyConstraints(r, i);
              if (t.priv.typeArgs && t.priv.typeArgs.length > 0) {
                s.push({
                  subtype: n,
                  entryTypes: [t.priv.typeArgs[0]],
                  isIndeterminateLength: true,
                  isDefiniteNoMatch: false,
                  isPotentialNoMatch: false
                });
                return;
              }
            }
            const o = new p.ConstraintTracker();
            if (l.addConstraintsForExpectedType(e, m.ClassType.cloneAsInstance(a), n, o, d.getTypeVarScopesForNode(t), t.start)) {
              const t = e.solveAndApplyConstraints(m.ClassType.cloneAsInstantiable(a), o);
              if (t.priv.typeArgs && t.priv.typeArgs.length > 0) {
                s.push({
                  subtype: n,
                  entryTypes: [t.priv.typeArgs[0]],
                  isIndeterminateLength: true,
                  isDefiniteNoMatch: false,
                  isPotentialNoMatch: true
                });
                return;
              }
            }
            if (e.assignType(n, m.ClassType.specialize(m.ClassType.cloneAsInstance(a), [m.UnknownType.create()]))) {
              s.push({
                subtype: n,
                entryTypes: [m.UnknownType.create()],
                isIndeterminateLength: true,
                isDefiniteNoMatch: false,
                isPotentialNoMatch: true
              });
              return;
            }
          }
        }
        s.push({
          subtype: n,
          entryTypes: [],
          isIndeterminateLength: true,
          isDefiniteNoMatch: true
        });
      });
      return s;
    }
    function I(e, t, n, a, s, i, o) {
      if (n.isIndeterminateLength) {
        let r = n.entryTypes[0];
        if (!o && a === i && !m.isNever(r)) {
          r = k(e, t, r);
        }
        return r;
      }
      if (i === undefined || a < i) {
        return n.entryTypes[a];
      }
      if (a === i) {
        const a = n.entryTypes.slice(i, i + n.entryTypes.length - s + 1).map(t => m.isTypeVarTuple(t) && !t.priv.isInUnion ? m.UnknownType.create() : e.stripLiteralValue(t));
        let r = m.combineTypes(a);
        if (!o) {
          r = k(e, t, r);
        }
        return r;
      }
      const l = n.entryTypes.length - (s - a);
      r.assert(l >= 0 && l < n.entryTypes.length);
      return n.entryTypes[l];
    }
    function k(e, t, n) {
      var a;
      if (m.isNever(n)) {
        return n;
      }
      const r = y.convertToInstance(e.getBuiltInObject(t, 'list'));
      if (r && m.isClassInstance(r)) {
        n = (a = y.containsAnyOrUnknown(n, false)) !== null && a !== undefined ? a : n;
        return m.ClassType.specialize(r, [n]);
      } else {
        return m.UnknownType.create();
      }
    }
    function w(e, t, n) {
      e.addDiagnostic(i.DiagnosticRule.reportUnnecessaryComparison, o.LocMessage.patternNeverMatches().format({
        type: e.printType(n)
      }), t);
    }
  },
  79253: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Program = undefined;
    const i = require(56911);
    const o = require(55890);
    const l = require(91426);
    const p = require(12522);
    const d = require(25075);
    const c = __importStar(require(48281));
    const u = require(48281);
    const m = require(51862);
    const y = require(56814);
    const g = require(71745);
    require(23070);
    const h = require(88754);
    const f = require(71582);
    const T = require(27113);
    const v = require(5884);
    const b = __importStar(require(26687));
    const _ = require(32720);
    const C = require(1693);
    const I = require(41557);
    const k = require(53266);
    const w = require(67238);
    const S = require(3433);
    const A = require(3113);
    const x = require(15794);
    const P = require(23274);
    const D = require(70930);
    class N {
      constructor() {
        this._isEditMode = false;
        this._mutatedFiles = [];
      }
      get isEditMode() {
        return this._isEditMode;
      }
      addMutatedFiles(e) {
        this._mutatedFiles.push(e);
      }
      enable() {
        this._isEditMode = true;
        this._mutatedFiles = [];
      }
      disable() {
        this._isEditMode = false;
        const e = this._mutatedFiles;
        this._mutatedFiles = [];
        return e;
      }
    }
    class F {
      constructor(e, t, n, a, r, s) {
        var i;
        this.serviceProvider = n;
        this._disableChecker = r;
        this._sourceFileList = [];
        this._sourceFileMap = new Map();
        this._parsedFileCount = 0;
        this._editModeTracker = new N();
        this._lookUpImport = (e, t) => {
          var n;
          let a;
          if (T.Uri.is(e)) {
            a = this.getSourceFileInfo(e);
          } else {
            const t = this._importResolver.resolveImport(e.importingFileUri, this._configOptions.findExecEnvironment(e.importingFileUri), {
              leadingDots: 0,
              nameParts: e.nameParts,
              importedSymbols: undefined
            });
            if (t.isImportFound && !t.isNativeLib && t.resolvedUris.length > 0) {
              const e = t.resolvedUris[t.resolvedUris.length - 1];
              if (!e.isEmpty()) {
                a = this.getSourceFileInfo(e);
                if (!a) {
                  this.addTrackedFile(e);
                  a = this.getSourceFileInfo(e);
                }
              }
            }
          }
          if (!a) {
            return;
          }
          if (t == null ? undefined : t.skipParsing) {
            return {
              symbolTable: new Map(),
              dunderAllNames: undefined,
              usesUnsupportedDunderAllForm: false,
              get docString() {},
              isInPyTypedPackage: false
            };
          }
          if (a.sourceFile.isBindingRequired()) {
            f.timingStats.typeCheckerTime.subtractFromTime(() => {
              this._bindFile(a, undefined, t == null ? undefined : t.skipFileNeededCheck);
            });
          }
          const r = a.sourceFile.getModuleSymbolTable();
          if (!r) {
            return;
          }
          const s = a.sourceFile.getParserOutput();
          const i = s.parseTree;
          const o = b.getFileInfo(i);
          const l = b.getDunderAllInfo(s.parseTree);
          return {
            symbolTable: r,
            dunderAllNames: l == null ? undefined : l.names,
            usesUnsupportedDunderAllForm: (n = l == null ? undefined : l.usesUnsupportedDunderAllForm) !== null && n !== undefined && n,
            get docString() {
              return I.getDocString(i.d.statements);
            },
            isInPyTypedPackage: o.isInPyTypedPackage
          };
        };
        this._console = n.tryGet(g.ServiceKeys.console) || new d.StandardConsole();
        this._logTracker = a ?? new m.LogTracker(this._console, 'FG');
        this._importResolver = e;
        this._configOptions = t;
        this._sourceFileFactory = n.sourceFileFactory();
        this._cacheManager = (i = n.tryGet(g.ServiceKeys.cacheManager)) !== null && i !== undefined ? i : new _.CacheManager();
        this._cacheManager.registerCacheOwner(this);
        this._createNewEvaluator();
        this._id = s ?? `Prog_${F._nextId}`;
        F._nextId += 1;
      }
      get id() {
        return this._id;
      }
      get console() {
        return this._console;
      }
      get rootPath() {
        return this._configOptions.projectRoot;
      }
      get evaluator() {
        return this._evaluator;
      }
      get configOptions() {
        return this._configOptions;
      }
      get importResolver() {
        return this._importResolver;
      }
      get fileSystem() {
        return this._importResolver.fileSystem;
      }
      dispose() {
        this._cacheManager.unregisterCacheOwner(this);
      }
      enterEditMode() {
        this._editModeTracker.enable();
      }
      exitEditMode() {
        const e = this._editModeTracker.disable();
        const t = new Set();
        const n = [];
        e.forEach(e => {
          if (e.isCreatedInEditMode) {
            t.add(e);
          }
          const a = e.restore();
          if (a) {
            const t = o.TextDocument.create(e.sourceFile.getUri().toString(), 'python', 1, e.sourceFile.getFileContent() || '');
            n.push({
              fileUri: e.sourceFile.getUri(),
              range: {
                start: {
                  line: 0,
                  character: 0
                },
                end: {
                  line: t.lineCount,
                  character: 0
                }
              },
              replacementText: a
            });
          }
        });
        if (t.size > 0) {
          for (let e = this._sourceFileList.length - 1; e >= 0; e--) {
            const n = this._sourceFileList[e];
            if (t.has(n)) {
              n.sourceFile.prepareForClose();
              this._removeSourceFileFromListAndMap(n.sourceFile.getUri(), e);
            }
          }
        }
        if (e.length > 0) {
          this._createNewEvaluator();
        }
        return n;
      }
      setConfigOptions(e) {
        this._configOptions = e;
        this._importResolver.setConfigOptions(e);
        this._createNewEvaluator();
      }
      setImportResolver(e) {
        this._importResolver = e;
        this._createNewEvaluator();
      }
      setTrackedFiles(e) {
        if (this._sourceFileList.length > 0) {
          const t = new Map();
          e.forEach(e => {
            t.set(e.key, e);
          });
          this._sourceFileList.forEach(e => {
            const n = e.sourceFile.getUri();
            if (!t.has(n.key)) {
              e.isTracked = false;
            }
          });
        }
        this.addTrackedFiles(e);
        return this._removeUnneededFiles();
      }
      setPreCheckCallback(e) {
        this._preCheckCallback = e;
      }
      setAllowedThirdPartyImports(e) {
        this._allowedThirdPartyImports = e;
      }
      addTrackedFiles(e, t = false, n = false) {
        e.forEach(e => {
          this.addTrackedFile(e, t, n);
        });
      }
      addInterimFile(e) {
        let t = this.getSourceFileInfo(e);
        if (!t) {
          t = this._createInterimFileInfo(e);
          this._addToSourceFileListAndMap(t);
        }
        return t;
      }
      addTrackedFile(e, t = false, n = false) {
        let a = this.getSourceFileInfo(e);
        const r = this._getModuleImportInfoForFile(e).moduleName;
        if (a) {
          a.sourceFile.setModuleName(r);
          a.isTracked = true;
          return a.sourceFile;
        }
        const s = this._sourceFileFactory.createSourceFile(this.serviceProvider, e, r, t, n, this._editModeTracker, this._console, this._logTracker);
        a = new w.SourceFileInfo(s, false, t, n, this._editModeTracker, {
          isTracked: true
        });
        this._addToSourceFileListAndMap(a);
        return s;
      }
      setFileOpened(e, t, n, a) {
        var r;
        var s;
        let i = this.getSourceFileInfo(e);
        if (i) {
          i.isOpenByClient = true;
          i.diagnosticsVersion = 0;
        } else {
          const t = this._getModuleImportInfoForFile(e);
          const n = this._sourceFileFactory.createSourceFile(this.serviceProvider, e, t.moduleName, false, t.isThirdPartyPyTypedPresent, this._editModeTracker, this._console, this._logTracker, (r = a == null ? undefined : a.ipythonMode) !== null && r !== undefined ? r : k.IPythonMode.None);
          const o = a == null ? undefined : a.chainedFileUri;
          i = new w.SourceFileInfo(n, false, false, false, this._editModeTracker, {
            isTracked: (s = a == null ? undefined : a.isTracked) !== null && s !== undefined && s,
            chainedSourceFile: o ? this.getSourceFileInfo(o) : undefined,
            isOpenByClient: true
          });
          this._addToSourceFileListAndMap(i);
        }
        S.verifyNoCyclesInChainedFiles(this, i);
        i.sourceFile.setClientVersion(t, n);
      }
      getChainedUri(e) {
        var t;
        const n = this.getSourceFileInfo(e);
        if ((t = n == null ? undefined : n.chainedSourceFile) === null || t === undefined) {
          return undefined;
        } else {
          return t.sourceFile.getUri();
        }
      }
      updateChainedUri(e, t) {
        const n = this.getSourceFileInfo(e);
        if (n) {
          n.chainedSourceFile = t ? this.getSourceFileInfo(t) : undefined;
          n.sourceFile.markDirty();
          this._markFileDirtyRecursive(n, new Set());
          S.verifyNoCyclesInChainedFiles(this, n);
        }
      }
      setFileClosed(e, t) {
        const n = this.getSourceFileInfo(e);
        if (n) {
          n.isOpenByClient = false;
          n.isTracked = t ?? n.isTracked;
          n.sourceFile.setClientVersion(null, '');
          if (n.sourceFile.didContentsChangeOnDisk()) {
            n.sourceFile.markDirty();
            this._markFileDirtyRecursive(n, new Set());
          }
        }
        return this._removeUnneededFiles();
      }
      markAllFilesDirty(e) {
        const t = new Set();
        this._sourceFileList.forEach(n => {
          if (e) {
            n.sourceFile.markDirty();
          } else {
            if (n.sourceFile.didContentsChangeOnDisk()) {
              n.sourceFile.markDirty();
              this._markFileDirtyRecursive(n, t);
            }
          }
        });
        if (t.size > 0) {
          this._createNewEvaluator();
        }
      }
      markFilesDirty(e, t) {
        const n = new Set();
        e.forEach(e => {
          const a = this.getSourceFileInfo(e);
          if (a) {
            const r = e.fileName;
            if (r === 'builtins.pyi' || r === '__builtins__.pyi') {
              this.markAllFilesDirty(t);
              return;
            }
            if (t || !a.isOpenByClient && a.sourceFile.didContentsChangeOnDisk()) {
              a.sourceFile.markDirty();
              this._markFileDirtyRecursive(a, n);
            }
          }
        });
        if (n.size > 0) {
          this._createNewEvaluator();
        }
      }
      getFileCount(e = true) {
        if (e) {
          return this._sourceFileList.filter(e => S.isUserCode(e)).length;
        } else {
          return this._sourceFileList.length;
        }
      }
      getUserFileCount() {
        return this._sourceFileList.filter(e => S.isUserCode(e)).length;
      }
      getUserFiles() {
        return this._sourceFileList.filter(e => S.isUserCode(e));
      }
      getOpened() {
        return this._sourceFileList.filter(e => e.isOpenByClient);
      }
      getFilesToAnalyzeCount() {
        let e = 0;
        let t = 0;
        if (this._disableChecker) {
          return {
            files: 0,
            cells: 0
          };
        } else {
          this._sourceFileList.forEach(n => {
            const a = n.sourceFile;
            if (a.isCheckingRequired() && this._shouldCheckFile(n)) {
              if (a.getIPythonMode() === k.IPythonMode.CellDocs) {
                t++;
              } else {
                e++;
              }
            }
          });
          return {
            files: e,
            cells: t
          };
        }
      }
      isCheckingOnlyOpenFiles() {
        return this._configOptions.checkOnlyOpenFiles || false;
      }
      functionSignatureDisplay() {
        return this._configOptions.functionSignatureDisplay;
      }
      containsSourceFileIn(e) {
        for (const t of this._sourceFileMap.values()) {
          if (t.sourceFile.getUri().startsWith(e)) {
            return true;
          }
        }
        return false;
      }
      owns(e) {
        const t = this.getSourceFileInfo(e);
        if (t) {
          return t.isTracked;
        } else {
          return p.matchFileSpecs(this._configOptions, e);
        }
      }
      getSourceFile(e) {
        const t = this.getSourceFileInfo(e);
        if (t) {
          return t.sourceFile;
        }
      }
      getBoundSourceFile(e) {
        var t;
        if ((t = this.getBoundSourceFileInfo(e)) === null || t === undefined) {
          return undefined;
        } else {
          return t.sourceFile;
        }
      }
      getSourceFileInfoList() {
        return this._sourceFileList;
      }
      getSourceFileInfo(e) {
        if (!e.isEmpty()) {
          return this._sourceFileMap.get(e.key);
        }
      }
      getBoundSourceFileInfo(e, t, n) {
        const a = this.getSourceFileInfo(e);
        if (a) {
          this._bindFile(a, t, n);
          return a;
        }
      }
      analyze(e, t = i.CancellationToken.None) {
        return this._runEvaluatorWithCancellationToken(t, () => {
          const n = new f.Duration();
          const a = this._sourceFileList.filter(e => e.isOpenByClient && e.sourceFile.isCheckingRequired());
          if (a.length > 0) {
            const r = e ? e.openFilesTimeInMs : Number.MAX_VALUE;
            for (const e of a) {
              if (this._checkTypes(e, t) && n.getDurationInMilliseconds() > r) {
                return true;
              }
            }
            if (e !== undefined) {
              return true;
            }
          }
          if (!this._configOptions.checkOnlyOpenFiles) {
            const a = e ? e.noOpenFilesTimeInMs : Number.MAX_VALUE;
            for (const e of this._sourceFileList) {
              if (S.isUserCode(e) && this._checkTypes(e, t) && n.getDurationInMilliseconds() > a) {
                return true;
              }
            }
          }
          return false;
        });
      }
      analyzeFile(e, t = i.CancellationToken.None) {
        return this._runEvaluatorWithCancellationToken(t, () => {
          const n = this.getSourceFileInfo(e);
          return !!n && !!this._checkTypes(n, t);
        });
      }
      run(e, t) {
        return this._runEvaluatorWithCancellationToken(t, () => e(this));
      }
      runEditMode(e, t) {
        if (this._editModeTracker.isEditMode) {
          return this._runEvaluatorWithCancellationToken(t, () => e(this));
        }
      }
      getSourceMapper(e, t, n, a) {
        const r = this.getSourceFileInfo(e);
        const s = this._configOptions.findExecEnvironment(e);
        return this._createSourceMapper(s, t, r, n, a);
      }
      getParserOutput(e) {
        var t;
        if ((t = this.getBoundSourceFileInfo(e, undefined, true)) === null || t === undefined) {
          return undefined;
        } else {
          return t.sourceFile.getParserOutput();
        }
      }
      getParseResults(e) {
        var t;
        if ((t = this.getBoundSourceFileInfo(e, undefined, true)) === null || t === undefined) {
          return undefined;
        } else {
          return t.sourceFile.getParseResults();
        }
      }
      handleMemoryHighUsage() {
        this._handleMemoryHighUsage();
      }
      printDetailedAnalysisTimes() {
        const e = this._sourceFileList.filter(e => e.sourceFile.getCheckTime() !== undefined).sort((e, t) => t.sourceFile.getCheckTime() - e.sourceFile.getCheckTime());
        this._console.info('');
        this._console.info('Analysis time by file');
        e.forEach(e => {
          const t = e.sourceFile.getCheckTime();
          this._console.info(`${t}ms: ${e.sourceFile.getUri()}`);
        });
      }
      printDependencies(e, t) {
        const n = this._importResolver.fileSystem;
        const a = this._sourceFileList.filter(e => !e.isTypeshedFile).sort((e, t) => n.getOriginalUri(e.sourceFile.getUri()) < n.getOriginalUri(t.sourceFile.getUri()) ? 1 : -1);
        const r = [];
        a.forEach(a => {
          this._console.info('');
          const s = n.getOriginalUri(a.sourceFile.getUri());
          let i = s.toString();
          const o = e.getRelativePathComponents(s);
          if (o) {
            i = o.join('/');
          }
          this._console.info(`${i}`);
          this._console.info(` Imports     ${a.imports.length} file${a.imports.length === 1 ? '' : 's'}`);
          if (t) {
            a.imports.forEach(e => {
              this._console.info(`    ${n.getOriginalUri(e.sourceFile.getUri())}`);
            });
          }
          this._console.info(` Imported by ${a.importedBy.length} file${a.importedBy.length === 1 ? '' : 's'}`);
          if (t) {
            a.importedBy.forEach(e => {
              this._console.info(`    ${n.getOriginalUri(e.sourceFile.getUri())}`);
            });
          }
          if (a.importedBy.length === 0) {
            r.push(a.sourceFile);
          }
        });
        if (r.length > 0) {
          this._console.info('');
          this._console.info(`${r.length} file${r.length === 1 ? '' : 's'} not explicitly imported`);
          r.forEach(e => {
            this._console.info(`    ${n.getOriginalUri(e.getUri())}`);
          });
        }
      }
      writeTypeStub(e, t, n, a) {
        for (const r of this._sourceFileList) {
          l.throwIfCancellationRequested(a);
          const s = r.sourceFile.getUri();
          const i = e.getRelativePath(s);
          if (i !== undefined) {
            let e = n.resolvePaths(i);
            e = t ? e.getDirectory().initPyiUri : e.replaceExtension('.pyi');
            const s = e.getDirectory();
            try {
              v.makeDirectories(this.fileSystem, s, n);
            } catch (e) {
              throw new Error(`Could not create directory for '${s}'`);
            }
            this._bindFile(r);
            this._runEvaluatorWithCancellationToken(a, () => {
              new D.TypeStubWriter(e, r.sourceFile, this._evaluator).write();
            });
            this._handleMemoryHighUsage();
          }
        }
      }
      getTypeOfSymbol(e) {
        this._handleMemoryHighUsage();
        return (this._evaluator || this._createNewEvaluator()).getEffectiveTypeOfSymbol(e);
      }
      printType(e, t) {
        this._handleMemoryHighUsage();
        return (this._evaluator || this._createNewEvaluator()).printType(e, t);
      }
      getTextOnRange(e, t, n) {
        const a = this.getSourceFileInfo(e);
        if (!a) {
          return;
        }
        const r = a.sourceFile;
        const s = r.getOpenFileContents();
        if (s !== undefined) {
          return this._runEvaluatorWithCancellationToken(n, () => {
            this._parseFile(a);
            const e = r.getParseResults();
            const n = y.convertRangeToTextRange(t, e.tokenizerOutput.lines);
            if (n) {
              return s.substr(n.start, n.length);
            }
          });
        } else {
          return undefined;
        }
      }
      getDiagnostics(e, t = true) {
        const n = this._removeUnneededFiles();
        this._sourceFileList.forEach(a => {
          if (this._shouldCheckFile(a)) {
            let r = a.sourceFile.getDiagnostics(e, t ? a.diagnosticsVersion : undefined);
            if (r !== undefined) {
              if (e.disableTaggedHints) {
                r = r.filter(e => e.category !== 4 && e.category !== 3 && e.category !== 5);
              }
              n.push({
                fileUri: a.sourceFile.getUri(),
                version: a.sourceFile.getClientVersion(),
                diagnostics: r
              });
              a.diagnosticsVersion = a.sourceFile.getDiagnosticVersion();
            }
          } else {
            if (!a.isOpenByClient && e.checkOnlyOpenFiles && a.diagnosticsVersion !== undefined) {
              n.push({
                fileUri: a.sourceFile.getUri(),
                version: a.sourceFile.getClientVersion(),
                diagnostics: []
              });
              a.diagnosticsVersion = undefined;
            }
          }
        });
        return n;
      }
      getDiagnosticsForRange(e, t) {
        const n = this.getSourceFile(e);
        if (!n) {
          return [];
        }
        const a = n.getDiagnostics(this._configOptions);
        if (a) {
          return a.filter(e => h.doRangesIntersect(e.range, t));
        } else {
          return [];
        }
      }
      clone() {
        var e;
        var t;
        const n = new F(this._importResolver, this._configOptions, this.serviceProvider, new m.LogTracker(this._console, 'Cloned'), this._disableChecker);
        const a = this.getUserFiles();
        n.setTrackedFiles(a.map(e => e.sourceFile.getUri()));
        n.markAllFilesDirty(true);
        for (const a of this.getOpened()) {
          const r = a.sourceFile.getClientVersion();
          if (r !== undefined) {
            n.setFileOpened(a.sourceFile.getUri(), r, (e = a.sourceFile.getOpenFileContents()) !== null && e !== undefined ? e : '', {
              chainedFileUri: (t = a.chainedSourceFile) === null || t === undefined ? undefined : t.sourceFile.getUri(),
              ipythonMode: a.sourceFile.getIPythonMode(),
              isTracked: a.isTracked
            });
          }
        }
        return n;
      }
      getCacheUsage() {
        const e = this._evaluator.getTypeCacheEntryCount() / 750000;
        const t = this._parsedFileCount / 1000;
        return Math.max(e, t);
      }
      emptyCache() {
        var e;
        this._createNewEvaluator();
        this._discardCachedParseResults();
        this._parsedFileCount = 0;
        if ((e = this.serviceProvider.tryGet(g.ServiceKeys.stateMutationListeners)) !== null && e !== undefined) {
          e.forEach(e => {
            var t;
            if ((t = e.onClearCache) === null || t === undefined) {
              return undefined;
            } else {
              return t.call(e);
            }
          });
        }
      }
      _handleMemoryHighUsage() {
        const e = this._cacheManager.getCacheUsage();
        const t = this._cacheManager.getUsedHeapRatio(this._configOptions.verboseOutput ? this._console : undefined);
        if (e > 0.75 || t > 0.9) {
          const e = 15099494.4;
          if (this._evaluator.getTypeCacheEntryCount() > e || t > 0.9) {
            this._cacheManager.emptyCache(this._console);
          }
        }
      }
      _discardCachedParseResults() {
        for (const e of this._sourceFileList) {
          e.sourceFile.dropParseAndBindInfo();
        }
      }
      _runEvaluatorWithCancellationToken(e, t) {
        try {
          if (e) {
            return this._evaluator.runWithCancellationToken(e, t);
          } else {
            return t();
          }
        } catch (e) {
          if (!l.OperationCanceledException.is(e) || !!e.isTypeCacheInvalid) {
            this._createNewEvaluator();
          }
          throw e;
        }
      }
      _removeUnneededFiles() {
        const e = [];
        for (let t = 0; t < this._sourceFileList.length;) {
          const n = this._sourceFileList[t];
          if (this._isFileNeeded(n)) {
            if (!this._shouldCheckFile(n) && n.diagnosticsVersion !== undefined) {
              e.push({
                fileUri: n.sourceFile.getUri(),
                version: n.sourceFile.getClientVersion(),
                diagnostics: []
              });
              n.diagnosticsVersion = undefined;
            }
            t++;
          } else {
            if (n.diagnosticsVersion !== undefined) {
              e.push({
                fileUri: n.sourceFile.getUri(),
                version: n.sourceFile.getClientVersion(),
                diagnostics: []
              });
            }
            n.sourceFile.prepareForClose();
            this._removeSourceFileFromListAndMap(n.sourceFile.getUri(), t);
            n.imports.forEach(a => {
              const r = a.importedBy.findIndex(e => e === n);
              if (!(r < 0) && !(a.mutate(e => e.importedBy.splice(r, 1)), this._isFileNeeded(a))) {
                const n = this._sourceFileList.findIndex(e => e === a);
                if (n >= 0 && n < t) {
                  if (a.diagnosticsVersion !== undefined) {
                    e.push({
                      fileUri: a.sourceFile.getUri(),
                      version: a.sourceFile.getClientVersion(),
                      diagnostics: []
                    });
                  }
                  a.sourceFile.prepareForClose();
                  this._removeSourceFileFromListAndMap(a.sourceFile.getUri(), n);
                  t--;
                }
              }
            });
            n.shadowedBy.forEach(e => {
              e.mutate(e => e.shadows = e.shadows.filter(e => e !== n));
            });
            n.mutate(e => e.shadowedBy = []);
          }
        }
        return e;
      }
      _isFileNeeded(e, t) {
        return !e.sourceFile.isFileDeleted() && (!!t || !!e.isTracked || !!e.isOpenByClient || e.shadows.length > 0 || e.importedBy.length !== 0 && this._isImportNeededRecursive(e, new Set()));
      }
      _isImportNeededRecursive(e, t) {
        if (e.isTracked || e.isOpenByClient || e.shadows.length > 0) {
          return true;
        }
        const n = e.sourceFile.getUri();
        if (t.has(n.key)) {
          return false;
        }
        t.add(n.key);
        for (const n of e.importedBy) {
          if (this._isImportNeededRecursive(n, t)) {
            return true;
          }
        }
        return false;
      }
      _createSourceMapper(e, t, n, a, r) {
        return new A.SourceMapper(this._importResolver, e, this._evaluator, (e, t) => {
          let n = this.getSourceFileInfo(e);
          if (!n) {
            if (!this.fileSystem.existsSync(e)) {
              return;
            }
            n = this.addInterimFile(e);
          }
          this._addShadowedFile(n, t);
          return this.getBoundSourceFile(t);
        }, e => {
          let t = this.getBoundSourceFileInfo(e);
          if (!t) {
            if (!this.fileSystem.existsSync(e)) {
              return;
            }
            t = this.addInterimFile(e);
            this._parseFile(t, undefined, true);
          }
          return t;
        }, a != null && a, r != null && r, n, t);
      }
      _isImportAllowed(e, t, n) {
        if (t.isNativeLib) {
          return false;
        }
        let a = this._configOptions.useLibraryCodeForTypes || t.importType === 1 && !!t.pyTypedInfo || t.importType === 2 && e.isThirdPartyPyTypedPresent;
        return t.importType !== 1 && (!e.isThirdPartyImport || t.importType !== 2) || !(this._allowedThirdPartyImports ? (t.isRelative || this._allowedThirdPartyImports.some(e => t.importName === e || !!t.importName.startsWith(e + '.'))) && (a = true) : (e.isThirdPartyImport && this._configOptions.useLibraryCodeForTypes || t.isNamespacePackage && Array.from(t.filteredImplicitImports.values()).some(e => !!e.pyTypedInfo)) && (a = true), !n) || a;
      }
      _getSourceFileInfoFromKey(e) {
        return this._sourceFileMap.get(e);
      }
      _updateSourceFileImports(e, t) {
        const n = [];
        const a = e.sourceFile.getImports();
        const r = t => {
          let n = false;
          let a = false;
          if (t.importType === 1) {
            n = true;
            if (t.pyTypedInfo) {
              a = true;
            }
          } else {
            if (e.isThirdPartyImport && t.importType === 2) {
              n = true;
              if (e.isThirdPartyPyTypedPresent) {
                a = true;
              }
            }
          }
          return {
            isThirdPartyImport: n,
            isPyTypedPresent: a
          };
        };
        const s = new Map();
        if (e.chainedSourceFile) {
          if (e.chainedSourceFile.sourceFile.isFileDeleted()) {
            e.chainedSourceFile = undefined;
          } else {
            const t = e.chainedSourceFile.sourceFile.getUri();
            s.set(t.key, {
              path: t,
              isTypeshedFile: false,
              isThirdPartyImport: false,
              isPyTypedPresent: false
            });
          }
        }
        a.forEach(n => {
          if (n.isImportFound) {
            if (this._isImportAllowed(e, n, n.isStubFile) && n.resolvedUris.length > 0) {
              const e = n.resolvedUris[n.resolvedUris.length - 1];
              if (!e.isEmpty()) {
                const t = r(n);
                s.set(e.key, {
                  path: e,
                  isTypeshedFile: !!n.isStdlibTypeshedFile || !!n.isThirdPartyTypeshedFile,
                  isThirdPartyImport: t.isThirdPartyImport,
                  isPyTypedPresent: t.isPyTypedPresent
                });
              }
            }
            n.filteredImplicitImports.forEach(t => {
              if (this._isImportAllowed(e, n, t.isStubFile) && !t.isNativeLib) {
                const e = r(n);
                s.set(t.uri.key, {
                  path: t.uri,
                  isTypeshedFile: !!n.isStdlibTypeshedFile || !!n.isThirdPartyTypeshedFile,
                  isThirdPartyImport: e.isThirdPartyImport,
                  isPyTypedPresent: e.isPyTypedPresent
                });
              }
            });
            if (n.nonStubImportResult && !n.nonStubImportResult.isImportFound) {
              if (!e.sourceFile.isStubFile() && !n.isStdlibTypeshedFile) {
                if (t.verboseOutput) {
                  this._console.info(`Could not resolve source for '${n.importName}' in file '${e.sourceFile.getUri().toUserVisibleString()}'`);
                  if (n.nonStubImportResult.importFailureInfo) {
                    n.nonStubImportResult.importFailureInfo.forEach(e => {
                      this._console.info(`  ${e}`);
                    });
                  }
                }
              }
            }
          } else {
            if (t.verboseOutput) {
              this._console.info(`Could not import '${n.importName}' in file '${e.sourceFile.getUri().toUserVisibleString()}'`);
              if (n.importFailureInfo) {
                n.importFailureInfo.forEach(e => {
                  this._console.info(`  ${e}`);
                });
              }
            }
          }
        });
        const i = new Map();
        e.imports.forEach(t => {
          const n = t.sourceFile.getUri();
          if (s.has(n.key)) {
            i.set(n.key, t);
          } else {
            t.mutate(t => {
              t.importedBy = t.importedBy.filter(t => !t.sourceFile.getUri().equals(e.sourceFile.getUri()));
            });
          }
        });
        s.forEach((t, a) => {
          if (!i.has(a)) {
            let r = this.getSourceFileInfo(t.path);
            if (!r) {
              const e = this._getModuleImportInfoForFile(t.path);
              const a = this._sourceFileFactory.createSourceFile(this.serviceProvider, t.path, e.moduleName, t.isThirdPartyImport, t.isPyTypedPresent, this._editModeTracker, this._console, this._logTracker);
              r = new w.SourceFileInfo(a, t.isTypeshedFile, t.isThirdPartyImport, t.isPyTypedPresent, this._editModeTracker);
              this._addToSourceFileListAndMap(r);
              n.push(r);
            }
            r.mutate(t => t.importedBy.push(e));
            i.set(a, r);
          }
        });
        const o = [];
        s.forEach((e, t) => {
          const n = this._getSourceFileInfoFromKey(t);
          if (n) {
            o.push(n);
          }
        });
        if (o.length !== e.imports.length || !o.every(t => e.imports.includes(t))) {
          e.mutate(e => e.imports = o);
        }
        e.builtinsImport = undefined;
        const l = e.sourceFile.getBuiltinsImport();
        if (l && l.isImportFound) {
          const t = l.resolvedUris[l.resolvedUris.length - 1];
          e.builtinsImport = this.getSourceFileInfo(t);
        }
        return n;
      }
      _removeSourceFileFromListAndMap(e, t) {
        this._sourceFileMap.delete(e.key);
        this._sourceFileList.splice(t, 1);
      }
      _addToSourceFileListAndMap(e) {
        const t = e.sourceFile.getUri();
        u.assert(!this._sourceFileMap.has(t.key));
        u.assert(!t.isEmpty());
        this._sourceFileList.push(e);
        this._sourceFileMap.set(t.key, e);
      }
      static _getPrintTypeFlags(e) {
        let t = 0;
        if (e.diagnosticRuleSet.printUnknownAsAny) {
          t |= 1;
        }
        if (e.diagnosticRuleSet.omitConditionalConstraint) {
          t |= 64;
        }
        if (e.diagnosticRuleSet.omitTypeArgsIfUnknown) {
          t |= 2;
        }
        if (e.diagnosticRuleSet.omitUnannotatedParamType) {
          t |= 4;
        }
        if (e.diagnosticRuleSet.pep604Printing) {
          t |= 8;
        }
        return t;
      }
      _getModuleImportInfoForFile(e) {
        return this._importResolver.getModuleNameForImport(e, this._configOptions.getDefaultExecEnvironment(), true, true);
      }
      _addShadowedFile(e, t) {
        let n = this.getSourceFileInfo(t);
        if (!n) {
          n = this.addInterimFile(t);
        }
        if (!n.shadows.includes(e)) {
          n.mutate(t => t.shadows.push(e));
        }
        if (!e.shadowedBy.includes(n)) {
          e.mutate(e => e.shadowedBy.push(n));
        }
        return n.sourceFile;
      }
      _createInterimFileInfo(e) {
        const t = this._getModuleImportInfoForFile(e);
        const n = this._sourceFileFactory.createSourceFile(this.serviceProvider, e, t.moduleName, false, false, this._editModeTracker, this._console, this._logTracker);
        return new w.SourceFileInfo(n, false, false, false, this._editModeTracker);
      }
      _createNewEvaluator() {
        if (this._evaluator) {
          this._evaluator.disposeEvaluator();
        }
        this._evaluator = P.createTypeEvaluatorWithTracker(this._lookUpImport, {
          printTypeFlags: F._getPrintTypeFlags(this._configOptions),
          logCalls: this._configOptions.logTypeEvaluationTime,
          minimumLoggingThreshold: this._configOptions.typeEvaluationTimeThreshold,
          evaluateUnknownImportsAsAny: !!this._configOptions.evaluateUnknownImportsAsAny,
          verifyTypeCacheEvaluatorFlags: !!this._configOptions.internalTestMode
        }, this._logTracker, this._configOptions.logTypeEvaluationTime ? x.createTracePrinter(this._importResolver.getImportRoots(this._configOptions.findExecEnvironment(this._configOptions.projectRoot))) : undefined);
        return this._evaluator;
      }
      _parseFile(e, t, n) {
        if (this._isFileNeeded(e, n) && e.sourceFile.isParseRequired() && (e.sourceFile.parse(this._configOptions, this._importResolver, t) && (this._parsedFileCount++, this._updateSourceFileImports(e, this._configOptions)), e.sourceFile.isFileDeleted())) {
          e.isTracked = false;
          const t = new Set();
          this._markFileDirtyRecursive(e, t);
          this._importResolver.invalidateCache();
        }
      }
      _getImplicitImports(e) {
        if (e.builtinsImport !== e) {
          if (e.chainedSourceFile && !e.chainedSourceFile.sourceFile.isFileDeleted()) {
            return e.chainedSourceFile;
          } else {
            return e.builtinsImport;
          }
        }
      }
      _bindImplicitImports(e, t) {
        var n;
        var a;
        const r = [];
        const s = new Set();
        let i = this._getImplicitImports(e);
        while (i) {
          const e = i.sourceFile.getUri();
          if (s.has(e.key)) {
            c.fail((a = (n = this.serviceProvider.tryGet(g.ServiceKeys.debugInfoInspector)) === null || n === undefined ? undefined : n.getCycleDetail(this, i)) !== null && a !== undefined ? a : 'Found a cycle in implicit imports files');
          }
          s.add(e.key);
          r.push(i);
          this._parseFile(i, undefined, t);
          i = this._getImplicitImports(i);
        }
        if (r.length === 0) {
          return;
        }
        let o = r.pop();
        while (o) {
          this._bindFile(o, undefined, t, true);
          o = r.pop();
        }
      }
      _bindFile(e, t, n = false, a = false) {
        var r;
        if (!this._isFileNeeded(e, n) || !e.sourceFile.isBindingRequired()) {
          return !e.sourceFile.isBindingRequired();
        }
        this._parseFile(e, t, n);
        const s = t => {
          if (!t || t === e) {
            return;
          }
          if (t.sourceFile.isFileDeleted()) {
            return;
          }
          const n = t.sourceFile.getParserOutput();
          if (!n) {
            return;
          }
          return b.getScope(n.parseTree);
        };
        let i;
        if (e.builtinsImport && e.builtinsImport !== e) {
          if (!a) {
            this._bindImplicitImports(e);
          }
          i = (r = s(e.chainedSourceFile)) !== null && r !== undefined ? r : s(e.builtinsImport);
        }
        let o = e.sourceFile.getParserOutput().futureImports;
        if (e.chainedSourceFile) {
          o = this._getEffectiveFutureImports(o, e.chainedSourceFile);
        }
        e.effectiveFutureImports = o.size > 0 ? o : undefined;
        e.sourceFile.bind(this._configOptions, this._lookUpImport, i, o);
        return true;
      }
      _getEffectiveFutureImports(e, t) {
        var n;
        const a = new Set(e);
        if ((n = t.effectiveFutureImports) !== null && n !== undefined) {
          n.forEach(e => {
            a.add(e);
          });
        }
        return a;
      }
      _shouldCheckFile(e) {
        return !!e.isOpenByClient || !this._configOptions.checkOnlyOpenFiles && !!e.isTracked;
      }
      _checkTypes(e, t, n) {
        return this._logTracker.log(`analyzing: ${e.sourceFile.getUri()}`, a => {
          if (!this._isFileNeeded(e)) {
            a.suppress();
            return false;
          }
          if (!e.sourceFile.isCheckingRequired()) {
            a.suppress();
            return false;
          }
          if (!this._shouldCheckFile(e)) {
            a.suppress();
            return false;
          }
          const r = this._bindFile(e, undefined, e.sourceFile.isBindingRequired());
          if (!this._disableChecker) {
            const a = this._checkDependentFiles(e, n, t);
            if (this._preCheckCallback) {
              const t = e.sourceFile.getParserOutput();
              if (t) {
                this._preCheckCallback(t, this._evaluator);
              }
            }
            if (r) {
              const n = this._configOptions.findExecEnvironment(e.sourceFile.getUri());
              e.sourceFile.check(this.configOptions, this._importResolver, this._evaluator, this._createSourceMapper(n, t, e), a);
            }
          }
          this._handleMemoryHighUsage();
          if (this._configOptions.diagnosticRuleSet.reportImportCycles !== 'none' && !this._allowedThirdPartyImports && e.sourceFile.getIPythonMode() !== k.IPythonMode.CellDocs) {
            const t = new Map();
            this._getImportsRecursive(e, t, 0);
            t.forEach(e => {
              f.timingStats.cycleDetectionTime.timeOperation(() => {
                const t = new Map();
                if (!this._detectAndReportImportCycles(e, t)) {
                  t.forEach(e => {
                    e.sourceFile.setNoCircularDependencyConfirmed();
                  });
                }
              });
            });
          }
          return true;
        });
      }
      _checkDependentFiles(e, t, n) {
        if (e.sourceFile.getIPythonMode() !== k.IPythonMode.CellDocs) {
          return;
        }
        const a = !t;
        const r = (t = t ?? S.createChainedByList(this, e)).findIndex(t => t === e);
        if (r < 0) {
          return;
        }
        const s = r + 1;
        if (s >= t.length) {
          return;
        }
        if (a) {
          const e = this._cacheManager.pauseTracking();
          try {
            for (let e = t.length - 1; e >= s; e--) {
              this._checkTypes(t[e], n, t);
            }
          } finally {
            e.dispose();
          }
        }
        const i = [];
        for (let e = s; e < t.length; e++) {
          const n = t[e];
          const a = n == null ? undefined : n.sourceFile.getParserOutput();
          if (!a) {
            continue;
          }
          if (n.sourceFile.isBindingRequired()) {
            continue;
          }
          if (b.getFileInfo(a.parseTree).accessedSymbolSet) {
            i.push(a);
          }
        }
        return i;
      }
      _getImportsRecursive(e, t, n) {
        const a = e.sourceFile.getUri();
        if (!t.has(a.key)) {
          if (n > 256) {
            e.sourceFile.setHitMaxImportDepth(256);
          } else {
            t.set(a.key, e);
            if (S.isUserCode(e)) {
              this._parseFile(e);
            }
            for (const a of e.imports) {
              this._getImportsRecursive(a, t, n + 1);
            }
          }
        }
      }
      _detectAndReportImportCycles(e, t, n = [], a = new Map()) {
        if (e.sourceFile.isStubFile() || e.isThirdPartyImport) {
          return false;
        }
        if (e.sourceFile.isNoCircularDependencyConfirmed()) {
          return false;
        }
        const r = e.sourceFile.getUri();
        t.set(r.key, e);
        let s = false;
        if (a.has(r.key)) {
          s = true;
          if (n.length > 1 && e === n[0]) {
            this._logImportCycle(n);
          }
        } else {
          if (a.has(r.key)) {
            return false;
          }
          a.set(r.key, true);
          n.push(e);
          for (const r of e.imports) {
            if (this._detectAndReportImportCycles(r, t, n, a)) {
              s = true;
            }
          }
          a.set(r.key, false);
          n.pop();
        }
        return s;
      }
      _logImportCycle(e) {
        const t = new C.CircularDependency();
        e.forEach(e => {
          t.appendPath(e.sourceFile.getUri());
        });
        t.normalizeOrder();
        const n = t.getPaths()[0];
        const a = this.getSourceFileInfo(n);
        u.assert(a !== undefined);
        a.sourceFile.addCircularDependency(this.configOptions, t);
      }
      _markFileDirtyRecursive(e, t, n = false) {
        const a = e.sourceFile.getUri();
        if (t.has(a.key)) {
          return;
        }
        e.sourceFile.markReanalysisRequired(n);
        t.add(a.key);
        e.importedBy.forEach(n => {
          const a = n.chainedSourceFile === e;
          this._markFileDirtyRecursive(n, t, a);
        });
        let r = false;
        let s = e.chainedSourceFile;
        while (s) {
          if (s.sourceFile.isCheckingRequired()) {
            return;
          }
          r = true;
          s.sourceFile.markReanalysisRequired(false);
          s = s.chainedSourceFile;
        }
        if (r) {
          this._createNewEvaluator();
        }
      }
    }
    exports.Program = F;
    F._nextId = 0;
  },
  60356: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ISourceFileFactory = undefined;
    (function (e) {
      e.is = function (e) {
        return e.createSourceFile !== undefined;
      };
    })(n || (exports.ISourceFileFactory = n = {}));
  },
  89460: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.validatePropertyMethod = function (e, t, n) {
      if (p.FunctionType.isStaticMethod(t)) {
        e.addDiagnostic(r.DiagnosticRule.reportGeneralTypeIssues, s.LocMessage.propertyStaticMethod(), n);
      }
    };
    exports.createProperty = function (e, t, n, a) {
      const r = i.getFileInfo(t);
      const s = e.getBuiltInType(t, 'type');
      const l = p.ClassType.isBuiltIn(n, 'property') ? o.getTypeSourceId(t) : n.shared.typeSourceId;
      const u = p.ClassType.createInstantiable(n.shared.name, o.getClassFullName(t, r.moduleName, `__property_${a.shared.name}`), r.moduleName, r.fileUri, 129, l, undefined, p.isInstantiableClass(s) ? s : p.UnknownType.create());
      u.shared.declaration = n.shared.declaration;
      u.shared.typeVarScopeId = n.shared.typeVarScopeId;
      const m = e.getBuiltInType(t, 'object');
      u.shared.baseClasses.push(p.isInstantiableClass(m) ? m : p.UnknownType.create());
      d.computeMroLinearization(u);
      const h = p.ClassType.getSymbolTable(u);
      p.ClassType.getSymbolTable(n).forEach((e, t) => {
        const n = ['__get__', '__set__', '__delete__'];
        if (!e.isIgnoredForProtocolMatch() && !n.some(e => e === t)) {
          h.set(t, e);
        }
      });
      const f = p.ClassType.cloneAsInstance(u);
      u.priv.isAsymmetricDescriptor = false;
      y(e, f);
      f.priv.fgetInfo = {
        methodType: p.FunctionType.cloneWithNewFlags(a, a.shared.flags | 4),
        classType: a.shared.methodClass
      };
      if (p.FunctionType.isClassMethod(a)) {
        u.shared.flags |= 131072;
      }
      c(e, f, a);
      g(f);
      return f;
    };
    exports.clonePropertyWithSetter = function (e, t, n, l) {
      if (!d.isProperty(t)) {
        return t;
      }
      const c = t;
      const m = c.shared.flags;
      let h = !!c.priv.isAsymmetricDescriptor;
      const f = i.getFileInfo(l);
      if (l.d.params.length >= 2) {
        const t = o.getTypeAnnotationForParam(l, 1);
        if (t) {
          const n = e.getGetterTypeFromProperty(c, false);
          if (n && !p.isAnyOrUnknown(n)) {
            const i = e.getTypeOfAnnotation(t, {
              typeVarGetsCurScope: true
            });
            if (f.diagnosticRuleSet.reportPropertyTypeMismatch !== 'none') {
              const o = new a.DiagnosticAddendum();
              if (!e.assignType(n, i, o)) {
                e.addDiagnostic(r.DiagnosticRule.reportPropertyTypeMismatch, s.LocMessage.setterGetterTypeMismatch() + o.getString(), t);
              }
            }
            if (!p.isTypeSame(n, i)) {
              h = true;
            }
          }
        }
      }
      const T = p.ClassType.createInstantiable(c.shared.name, c.shared.fullName, c.shared.moduleName, i.getFileInfo(l).fileUri, m, c.shared.typeSourceId, c.shared.declaredMetaclass, c.shared.effectiveMetaclass);
      T.shared.declaration = c.shared.declaration;
      T.shared.typeVarScopeId = c.shared.typeVarScopeId;
      const v = e.getBuiltInType(l, 'object');
      T.shared.baseClasses.push(p.isInstantiableClass(v) ? v : p.UnknownType.create());
      d.computeMroLinearization(T);
      T.priv.fgetInfo = c.priv.fgetInfo;
      T.priv.fdelInfo = c.priv.fdelInfo;
      T.priv.isAsymmetricDescriptor = h;
      const b = p.ClassType.cloneAsInstance(T);
      const _ = p.ClassType.getSymbolTable(T);
      p.ClassType.getSymbolTable(c).forEach((e, t) => {
        if (!e.isIgnoredForProtocolMatch()) {
          _.set(t, e);
        }
      });
      y(e, b);
      b.priv.fsetInfo = {
        methodType: p.FunctionType.cloneWithNewFlags(n, n.shared.flags | 4),
        classType: n.shared.methodClass
      };
      u(e, b, n);
      g(b);
      return b;
    };
    exports.clonePropertyWithDeleter = function (e, t, n, a) {
      var r;
      if (!d.isProperty(t)) {
        return t;
      }
      const s = t;
      const o = p.ClassType.createInstantiable(s.shared.name, s.shared.fullName, s.shared.moduleName, i.getFileInfo(a).fileUri, s.shared.flags, s.shared.typeSourceId, s.shared.declaredMetaclass, s.shared.effectiveMetaclass);
      o.shared.declaration = s.shared.declaration;
      o.shared.typeVarScopeId = s.shared.typeVarScopeId;
      const l = e.getBuiltInType(a, 'object');
      o.shared.baseClasses.push(p.isInstantiableClass(l) ? l : p.UnknownType.create());
      d.computeMroLinearization(o);
      o.priv.fgetInfo = s.priv.fgetInfo;
      o.priv.fsetInfo = s.priv.fsetInfo;
      const c = p.ClassType.cloneAsInstance(o);
      o.priv.isAsymmetricDescriptor = (r = s.priv.isAsymmetricDescriptor) !== null && r !== undefined && r;
      const u = p.ClassType.getSymbolTable(o);
      p.ClassType.getSymbolTable(s).forEach((e, t) => {
        if (!e.isIgnoredForProtocolMatch()) {
          u.set(t, e);
        }
      });
      y(e, c);
      c.priv.fdelInfo = {
        methodType: p.FunctionType.cloneWithNewFlags(n, n.shared.flags | 4),
        classType: n.shared.methodClass
      };
      m(e, c, n);
      g(c);
      return c;
    };
    exports.assignProperty = function (e, t, n, a, r, i, o, l, c = 0) {
      const u = p.isClass(r) ? p.ClassType.cloneAsInstance(r) : undefined;
      const m = p.ClassType.cloneAsInstance(a);
      let y = true;
      [{
        getFunction: e => {
          var t;
          if ((t = e.priv.fgetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        },
        missingDiagMsg: s.LocAddendum.missingGetter,
        incompatibleDiagMsg: s.LocAddendum.incompatibleGetter
      }, {
        getFunction: e => {
          var t;
          if ((t = e.priv.fsetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        },
        missingDiagMsg: s.LocAddendum.missingSetter,
        incompatibleDiagMsg: s.LocAddendum.incompatibleSetter
      }, {
        getFunction: e => {
          var t;
          if ((t = e.priv.fdelInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        },
        missingDiagMsg: s.LocAddendum.missingDeleter,
        incompatibleDiagMsg: s.LocAddendum.incompatibleDeleter
      }].forEach(a => {
        let r = a.getFunction(t);
        if (r && p.isFunction(r)) {
          let t = a.getFunction(n);
          if (!t || !p.isFunction(t)) {
            if (i != null) {
              i.addMessage(a.missingDiagMsg());
            }
            y = false;
            return;
          }
          e.inferReturnTypeIfNecessary(t);
          e.inferReturnTypeIfNecessary(r);
          if (l) {
            r = d.applySolvedTypeVars(r, l);
          }
          r = p.FunctionType.cloneWithNewFlags(r, r.shared.flags & -5);
          t = p.FunctionType.cloneWithNewFlags(t, t.shared.flags & -5);
          const s = e.bindFunctionToClassOrObject(m, r, undefined, undefined, undefined, i == null ? undefined : i.createAddendum(), c);
          const g = e.bindFunctionToClassOrObject(u, t, undefined, undefined, undefined, i == null ? undefined : i.createAddendum(), c);
          if (!s || !g || !e.assignType(s, g, i, o, 0, c)) {
            y = false;
          }
        }
      });
      return y;
    };
    const a = require(11479);
    const r = require(65880);
    const s = require(67703);
    const i = require(26687);
    const o = require(41557);
    const l = require(58253);
    const p = require(21024);
    const d = require(92324);
    function c(e, t, n) {
      const a = p.ClassType.getSymbolTable(t);
      const r = p.FunctionType.createSynthesizedInstance('__get__', 256);
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'self'));
      p.FunctionType.addParam(r, p.FunctionParam.create(0, e.getNoneType(), p.FunctionParamFlags.TypeDeclared, 'obj'));
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'objtype', p.AnyType.create(true)));
      r.shared.declaredReturnType = p.FunctionType.isClassMethod(n) ? p.FunctionType.getEffectiveReturnType(n) : t;
      r.shared.declaration = n.shared.declaration;
      r.shared.deprecatedMessage = n.shared.deprecatedMessage;
      r.shared.methodClass = n.shared.methodClass;
      r.shared.typeVarScopeId = d.getTypeVarScopeId(n);
      const s = p.FunctionType.createSynthesizedInstance('__get__', 256);
      p.FunctionType.addParam(s, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'self'));
      const i = n.shared.parameters.length > 0 ? p.FunctionType.getParamType(n, 0) : p.AnyType.create();
      p.FunctionType.addParam(s, p.FunctionParam.create(0, i, p.FunctionParamFlags.TypeDeclared, 'obj'));
      p.FunctionType.addParam(s, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'objtype', p.AnyType.create(true)));
      s.shared.declaredReturnType = p.FunctionType.getEffectiveReturnType(n);
      s.shared.declaration = n.shared.declaration;
      s.shared.deprecatedMessage = n.shared.deprecatedMessage;
      s.shared.methodClass = n.shared.methodClass;
      s.shared.typeVarScopeId = d.getTypeVarScopeId(n);
      const o = p.OverloadedType.create([s, r]);
      const c = l.Symbol.createWithType(4, o);
      a.set('__get__', c);
    }
    function u(e, t, n) {
      const a = p.ClassType.getSymbolTable(t);
      const r = p.FunctionType.createSynthesizedInstance('__set__');
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'self'));
      let s = n.shared.parameters.length > 0 ? p.FunctionType.getParamType(n, 0) : p.AnyType.create();
      if (p.isTypeVar(s) && p.TypeVarType.isSelf(s)) {
        s = e.makeTopLevelTypeVarsConcrete(s);
      }
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.combineTypes([s, e.getNoneType()]), p.FunctionParamFlags.TypeDeclared, 'obj'));
      r.shared.declaredReturnType = e.getNoneType();
      r.shared.typeVarScopeId = d.getTypeVarScopeId(n);
      r.shared.deprecatedMessage = n.shared.deprecatedMessage;
      r.shared.methodClass = n.shared.methodClass;
      let i = p.UnknownType.create();
      if (n.shared.parameters.length >= 2 && n.shared.parameters[1].category === 0 && n.shared.parameters[1].name) {
        i = p.FunctionType.getParamType(n, 1);
      }
      p.FunctionType.addParam(r, p.FunctionParam.create(0, i, p.FunctionParamFlags.TypeDeclared, 'value'));
      const o = l.Symbol.createWithType(4, r);
      a.set('__set__', o);
    }
    function m(e, t, n) {
      const a = p.ClassType.getSymbolTable(t);
      const r = p.FunctionType.createSynthesizedInstance('__delete__');
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'self'));
      r.shared.typeVarScopeId = d.getTypeVarScopeId(n);
      r.shared.deprecatedMessage = n.shared.deprecatedMessage;
      r.shared.methodClass = n.shared.methodClass;
      let s = n.shared.parameters.length > 0 ? p.FunctionType.getParamType(n, 0) : p.AnyType.create();
      if (p.isTypeVar(s) && p.TypeVarType.isSelf(s)) {
        s = e.makeTopLevelTypeVarsConcrete(s);
      }
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.combineTypes([s, e.getNoneType()]), p.FunctionParamFlags.TypeDeclared, 'obj'));
      r.shared.declaredReturnType = e.getNoneType();
      const i = l.Symbol.createWithType(4, r);
      a.set('__delete__', i);
    }
    function y(e, t) {
      const n = t.priv.fgetInfo;
      if (n && p.isFunction(n.methodType)) {
        c(e, t, n.methodType);
      }
      const a = t.priv.fsetInfo;
      if (a && p.isFunction(a.methodType)) {
        u(e, t, a.methodType);
      }
      const r = t.priv.fdelInfo;
      if (r && p.isFunction(r.methodType)) {
        m(e, t, r.methodType);
      }
    }
    function g(e) {
      const t = p.ClassType.getSymbolTable(e);
      ['getter', 'setter', 'deleter'].forEach(n => {
        const a = p.FunctionType.createSynthesizedInstance(n);
        p.FunctionType.addParam(a, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'self'));
        p.FunctionType.addParam(a, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'accessor'));
        a.shared.declaredReturnType = e;
        const r = l.Symbol.createWithType(4, a);
        t.set(n, r);
      });
    }
  },
  54500: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.assignClassToProtocol = function (e, t, n, s, i, o, l) {
      a.assert(c.isInstantiableClass(t) && c.ClassType.isProtocolClass(t));
      if (n.priv.literalValue !== undefined) {
        n = e.stripLiteralValue(n);
      }
      const p = !!(o & 1);
      if (m.some(e => c.isTypeSame(e.srcType, n) && c.isTypeSame(e.destType, t))) {
        return !p;
      }
      const d = function (e, t, n, a) {
        const r = t.shared.protocolCompatibility;
        const s = r == null ? undefined : r.get(e.shared.fullName);
        if (s === undefined) {
          return;
        }
        for (const r of s) {
          if (r.flags === n) {
            if (r.srcType !== undefined) {
              if (c.isTypeSame(r.destType, e, {
                honorIsTypeArgExplicit: true,
                honorTypeForm: true
              }) && c.isTypeSame(r.srcType, t, {
                honorIsTypeArgExplicit: true,
                honorTypeForm: true
              }) && g(a, r.preConstraints)) {
                return r;
              }
            } else {
              if (c.ClassType.isSameGenericClass(r.destType, e)) {
                return r;
              }
            }
          }
        }
        return;
      }(t, n, o, i);
      if (d !== undefined) {
        if (d.isCompatible) {
          if (d.postConstraints) {
            if (i != null) {
              i.copyFromClone(d.postConstraints);
            }
          }
          return true;
        }
        if (!s || s.getNestLevel() > r.defaultMaxDiagnosticDepth) {
          return false;
        }
      }
      m.push({
        srcType: n,
        destType: t
      });
      let f = true;
      const T = i == null ? undefined : i.clone();
      try {
        f = h(e, t, n, s, i, o, l);
      } catch (e) {
        m.pop();
        throw e;
      }
      m.pop();
      if (!d) {
        (function (e, t, n, a, r, s, i, o) {
          let l = n.shared.protocolCompatibility;
          if (!l) {
            l = new Map();
            n.shared.protocolCompatibility = l;
          }
          let p = l.get(t.shared.fullName);
          if (!p) {
            p = [];
            l.set(t.shared.fullName, p);
          }
          let d = false;
          if (!i && !p.some(e => e.flags === a && c.ClassType.isSameGenericClass(e.destType, t))) {
            if (!h(e, u.requiresTypeArgs(t) ? u.selfSpecializeClass(t, {
              overrideTypeArgs: true
            }) : t, u.requiresTypeArgs(n) ? u.selfSpecializeClass(n, {
              overrideTypeArgs: true
            }) : n, undefined, undefined, a, o)) {
              d = true;
            }
          }
          const m = {
            destType: t,
            srcType: d ? undefined : n,
            flags: a,
            preConstraints: r,
            postConstraints: s,
            isCompatible: i
          };
          p.push(m);
          if (p.length > y) {
            p.shift();
          }
        })(e, t, n, o, T, i == null ? undefined : i.clone(), f, l);
      }
      return f;
    };
    exports.assignModuleToProtocol = function (e, t, n, a, r, s, i) {
      return h(e, t, n, a, r, s, i);
    };
    exports.isMethodOnlyProtocol = function e(t) {
      if (!c.ClassType.isProtocolClass(t)) {
        return false;
      }
      for (const n of t.shared.baseClasses) {
        if (c.isClass(n) && c.ClassType.isProtocolClass(n) && !e(n)) {
          return false;
        }
      }
      for (const [, e] of c.ClassType.getSymbolTable(t)) {
        if (!e.isIgnoredForProtocolMatch() && e.getDeclarations().some(e => e.type !== 5)) {
          return false;
        }
      }
      return true;
    };
    exports.isProtocolUnsafeOverlap = function (e, t, n) {
      if (e.assignType(t, n)) {
        return false;
      }
      let a = true;
      t.shared.mro.forEach(e => {
        if (a && c.isInstantiableClass(e) && c.ClassType.isProtocolClass(e)) {
          c.ClassType.getSymbolTable(e).forEach((e, t) => {
            if (!a || !e.isClassMember() || e.isIgnoredForProtocolMatch()) {
              return;
            }
            if (!u.lookUpClassMember(n, t)) {
              a = false;
            }
          });
        }
      });
      return a;
    };
    const a = require(48281);
    const r = require(11479);
    const s = require(67703);
    const i = require(70617);
    const o = require(10081);
    const l = require(86672);
    const p = require(89460);
    const d = require(4064);
    const c = require(21024);
    const u = require(92324);
    const m = [];
    const y = 64;
    function g(e, t) {
      if (e && t) {
        return e.isSame(t);
      } else {
        return e === t;
      }
    }
    function h(e, t, n, r, m, y, g) {
      var h;
      var f;
      if (y & 1) {
        return c.isTypeSame(t, n);
      }
      e.inferVarianceForClass(t);
      const T = c.isClass(n) && c.TypeBase.isInstantiable(n);
      const v = function (e, t, n) {
        const a = new l.ConstraintTracker();
        t.shared.typeParams.forEach((r, s) => {
          const i = n == null ? undefined : n.getMainConstraintSet().getTypeVar(r);
          if (i) {
            a.copyBounds(i);
          } else {
            if (t.priv.typeArgs && s < t.priv.typeArgs.length) {
              let i;
              let l = t.priv.typeArgs[s];
              let p = u.requiresSpecialization(l);
              if (p && n) {
                l = e.solveAndApplyConstraints(l, n, undefined, {
                  useLowerBoundOnly: true
                });
                i = 0;
                p = u.requiresSpecialization(l);
              } else {
                i = 2048;
                const e = c.TypeVarType.getVariance(r);
                if (e === 2) {
                  i |= 1;
                } else {
                  if (e === 4) {
                    i |= 2;
                  }
                }
              }
              if (!p) {
                o.assignTypeVar(e, r, l, undefined, a, i);
              }
            }
          }
        });
        return a;
      }(e, t, m);
      const b = new i.ConstraintSolution();
      let _;
      if (c.isClass(n)) {
        const e = (f = (h = n.props) === null || h === undefined ? undefined : h.condition) === null || f === undefined ? undefined : f.find(e => c.TypeVarType.isSelf(e.typeVar));
        if (e) {
          _ = u.synthesizeTypeVarForSelfCls(c.TypeBase.cloneForCondition(n, undefined), false);
          if (c.TypeVarType.isBound(e.typeVar)) {
            _ = c.TypeVarType.cloneAsBound(_);
          }
        } else {
          _ = n;
        }
        u.addSolutionForSelfType(b, t, _);
      }
      if (c.isClass(n) && c.ClassType.isTypedDictClass(n)) {
        const t = e.getTypedDictClassType();
        if (t && c.isInstantiableClass(t)) {
          n = t;
        }
      }
      let C = true;
      const I = new Set();
      let k = y & 48;
      k |= u.containsLiteralType(n, true) ? 256 : 0;
      t.shared.mro.forEach(i => {
        if (c.isInstantiableClass(i) && c.ClassType.isProtocolClass(i) && (C || r)) {
          c.ClassType.getSymbolTable(i).forEach((o, l) => {
            var m;
            if (!C && !r) {
              return;
            }
            if (!o.isClassMember() || o.isIgnoredForProtocolMatch() || I.has(l)) {
              return;
            }
            let y;
            let h;
            let f = false;
            if (!T && l === '__class_getitem__') {
              return;
            }
            if (l === '__slots__') {
              return;
            }
            I.add(l);
            let w;
            let S = (m = e.getDeclaredTypeOfSymbol(o)) === null || m === undefined ? undefined : m.type;
            if (!S) {
              return;
            }
            let A = false;
            let x = false;
            if (c.isClass(n)) {
              if (T && n.shared.effectiveMetaclass && c.isInstantiableClass(n.shared.effectiveMetaclass)) {
                y = u.lookUpClassMember(n.shared.effectiveMetaclass, l);
                if (y) {
                  f = true;
                }
              }
              if (!y) {
                y = u.lookUpClassMember(n, l);
              }
              if (!y) {
                if (r != null) {
                  r.addMessage(s.LocAddendum.protocolMemberMissing().format({
                    name: l
                  }));
                }
                C = false;
                return;
              }
              h = y.symbol;
              if (!c.ClassType.isSameGenericClass(i, t)) {
                S = u.partiallySpecializeType(S, i, e.getTypeClassType(), _);
              }
              if (c.isInstantiableClass(y.classType)) {
                const t = e.getEffectiveTypeOfSymbol(y.symbol);
                if (c.isFunction(t)) {
                  e.inferReturnTypeIfNecessary(t);
                }
                w = u.partiallySpecializeType(t, y.classType, e.getTypeClassType(), _);
              } else {
                w = c.UnknownType.create();
              }
              if ((c.isFunction(w) || c.isOverloaded(w)) && (f || c.isInstantiableClass(y.classType))) {
                let t = !y.symbol.isClassMember();
                if (c.ClassType.isDataClass(n)) {
                  if (c.ClassType.getDataClassEntries(n).some(e => e.name === l)) {
                    t = true;
                  }
                }
                if (f) {
                  t = false;
                }
                if (!t) {
                  const t = e.bindFunctionToClassOrObject(T && !f ? n : c.ClassType.cloneAsInstance(n), w, f ? undefined : y.classType, undefined, f ? n : _, r == null ? undefined : r.createAddendum(), g);
                  if (!t) {
                    C = false;
                    return;
                  }
                  w = t;
                }
              }
              if (y.isReadOnly) {
                A = true;
              }
            } else {
              h = n.priv.fields.get(l);
              if (!h) {
                if (r != null) {
                  r.addMessage(s.LocAddendum.protocolMemberMissing().format({
                    name: l
                  }));
                }
                C = false;
                return;
              }
              w = e.getEffectiveTypeOfSymbol(h);
            }
            S = u.applySolvedTypeVars(S, b);
            if (!o.isInstanceMember() && (c.isFunction(S) || c.isOverloaded(S))) {
              let s;
              x = true;
              if (c.isClass(n)) {
                a.assert(y);
                if (f || c.isInstantiableClass(y.classType)) {
                  s = e.bindFunctionToClassOrObject(c.ClassType.cloneAsInstance(n), S, f ? undefined : y.classType, undefined, f ? n : _, r, g);
                }
              } else {
                s = e.bindFunctionToClassOrObject(c.ClassType.cloneAsInstance(t), S, t, undefined, undefined, r, g);
              }
              if (!s) {
                C = false;
                return;
              }
              s = u.makeFunctionTypeVarsBound(s);
              S = s;
            }
            const P = r == null ? undefined : r.createAddendum();
            const D = o.getTypedDeclarations().some(e => e.type === 1 && !!e.isFinal);
            if (h.getTypedDeclarations().some(e => e.type === 1 && !!e.isFinal)) {
              A = true;
            }
            if (D) {
              x = true;
            }
            if (c.isClassInstance(S) && c.ClassType.isPropertyClass(S)) {
              if (c.isClassInstance(w) && c.ClassType.isPropertyClass(w) && !T) {
                if (!p.assignProperty(e, c.ClassType.cloneAsInstantiable(S), c.ClassType.cloneAsInstantiable(w), i, n, P == null ? undefined : P.createAddendum(), v, b, g)) {
                  if (P) {
                    P.addMessage(s.LocAddendum.memberTypeMismatch().format({
                      name: l
                    }));
                  }
                  C = false;
                }
              } else {
                let t = e.getGetterTypeFromProperty(S, true);
                if (t) {
                  t = u.partiallySpecializeType(t, i, e.getTypeClassType());
                }
                if (!t || !e.assignType(t, w, P == null ? undefined : P.createAddendum(), v, k, g)) {
                  if (P) {
                    P.addMessage(s.LocAddendum.memberTypeMismatch().format({
                      name: l
                    }));
                  }
                  C = false;
                }
                if (!u.lookUpClassMember(S, '__set__', 16) && !u.lookUpClassMember(S, '__delete__', 16)) {
                  x = true;
                }
                if (A) {
                  if (!x) {
                    if (P) {
                      P.addMessage(s.LocAddendum.memberIsWritableInProtocol().format({
                        name: l
                      }));
                    }
                    C = false;
                  }
                }
              }
            } else {
              const t = o.getDeclarations()[0];
              const n = (t == null ? undefined : t.type) === 1 && !t.isFinal;
              const a = v.clone();
              if (e.assignType(S, w, P == null ? undefined : P.createAddendum(), a, n ? k | 1 : k, g)) {
                v.copyFromClone(a);
              } else {
                if (P) {
                  if (n) {
                    P.addMessage(s.LocAddendum.memberIsInvariant().format({
                      name: l
                    }));
                  }
                  P.addMessage(s.LocAddendum.memberTypeMismatch().format({
                    name: l
                  }));
                }
                C = false;
              }
            }
            if (!x && A) {
              if (P) {
                P.addMessage(s.LocAddendum.memberIsNotReadOnlyInProtocol().format({
                  name: l
                }));
              }
              C = false;
            }
            const N = d.isEffectivelyClassVar(o, false);
            const F = d.isEffectivelyClassVar(h, c.isClass(n) && c.ClassType.isDataClass(n));
            const E = h.getDeclarations().some(e => e.type === 1);
            if (T) {
              if (N) {
                if (P != null) {
                  P.addMessage(s.LocAddendum.memberIsClassVarInProtocol().format({
                    name: l
                  }));
                }
                C = false;
              } else {
                if (E && !F) {
                  if (!f) {
                    if (P != null) {
                      P.addMessage(s.LocAddendum.memberIsNotClassVarInClass().format({
                        name: l
                      }));
                    }
                    C = false;
                  }
                }
              }
            } else {
              if (N !== F) {
                if (N) {
                  if (P != null) {
                    P.addMessage(s.LocAddendum.memberIsClassVarInProtocol().format({
                      name: l
                    }));
                  }
                } else {
                  if (P != null) {
                    P.addMessage(s.LocAddendum.memberIsNotClassVarInProtocol().format({
                      name: l
                    }));
                  }
                }
                C = false;
              }
            }
            const M = d.getLastTypedDeclarationForSymbol(o);
            const O = d.getLastTypedDeclarationForSymbol(h);
            if ((M == null ? undefined : M.type) === 1 && (O == null ? undefined : O.type) === 1) {
              const e = !!M.isConstant || !!M.isFinal;
              let t = !!O.isConstant;
              if (y && c.isClass(y.classType) && y.isReadOnly) {
                t = true;
              }
              if (!e && t) {
                if (P) {
                  P.addMessage(s.LocAddendum.memberIsWritableInProtocol().format({
                    name: l
                  }));
                }
                C = false;
              }
            }
          });
        }
      });
      if (C && t.shared.typeParams.length > 0) {
        const n = c.ClassType.specialize(t, undefined);
        const a = e.solveAndApplyConstraints(n, v);
        if (t.priv.typeArgs) {
          if (!e.assignTypeArgs(t, a, r, m, y, g)) {
            C = false;
          }
        } else {
          if (m) {
            for (const e of t.shared.typeParams) {
              const t = v.getMainConstraintSet().getTypeVar(e);
              if (t) {
                m.copyBounds(t);
              }
            }
          }
        }
      }
      return C;
    }
  },
  92031: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getPyTypedInfo = function (e, t) {
      if (!e.existsSync(t) || !a.isDirectory(e, t)) {
        return;
      }
      const n = t.pytypedUri;
      if (!e.existsSync(n) || !a.isFile(e, n)) {
        return;
      }
      return r(e, n);
    };
    exports.getPyTypedInfoForPyTypedFile = r;
    const a = require(5884);
    function r(e, t) {
      let n = false;
      const a = e.statSync(t);
      if (a.size > 0 && a.size < 65536) {
        const a = e.readFileSync(t, 'utf8');
        if (a.match(/partial\n/) || a.match(/partial\r\n/)) {
          n = true;
        }
      }
      return {
        pyTypedPath: t,
        isPartiallyTyped: n
      };
    }
  },
  16259: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.thirdPartyFolderName = exports.stdLibFolderName = undefined;
    exports.getTypeShedFallbackPath = function (e) {
      const t = e.getModulePath();
      if (!t || t.isEmpty()) {
        return;
      }
      const n = t.combinePaths(o.typeshedFallback);
      if (e.existsSync(n)) {
        return e.realCasePath(n);
      }
      const a = t.getDirectory().combinePaths(o.typeshedFallback);
      if (e.existsSync(a)) {
        return e.realCasePath(a);
      }
      return;
    };
    exports.getTypeshedSubdirectory = function (e, n) {
      return e.combinePaths(n ? exports.stdLibFolderName : exports.thirdPartyFolderName);
    };
    exports.findPythonSearchPaths = function (e, t, n, a, r, s) {
      a.push('Finding python search paths');
      if (t.venvPath !== undefined && t.venv) {
        const n = t.venv;
        const r = t.venvPath.combinePaths(n);
        const s = [];
        const i = [];
        [o.lib, o.lib64, o.libAlternate].forEach(n => {
          const d = function (e, t, n, a) {
            if (!e.existsSync(t)) {
              a.push(`Did not find '${t}'`);
              return;
            }
            a.push(`Found path '${t}'; looking for ${o.sitePackages}`);
            const r = t.combinePaths(o.sitePackages);
            if (e.existsSync(r)) {
              a.push(`Found path '${r}'`);
              return r;
            }
            a.push(`Did not find '${r}', so looking for python subdirectory`);
            const s = p.getFileSystemEntries(e, t);
            const i = s.directories.filter(t => {
              if (t.fileName.startsWith('python3.')) {
                const n = t.combinePaths(o.sitePackages);
                return e.existsSync(n);
              }
              return false;
            });
            if (n) {
              const e = i.find(e => e.fileName === `python${l.PythonVersion.toMajorMinorString(n)}`);
              if (e) {
                const t = e.combinePaths(o.sitePackages);
                a.push(`Found path '${t}'`);
                return t;
              }
            }
            if (i.length > 0) {
              const e = i[0].combinePaths(o.sitePackages);
              a.push(`Found path '${e}'`);
              return e;
            }
            return;
          }(e, r.combinePaths(n), t.defaultPythonVersion, a);
          if (d) {
            c(s, d);
            i.push(e.realCasePath(d));
          }
        });
        i.forEach(t => {
          d(e, t).forEach(e => {
            c(s, e);
          });
        });
        if (s.length > 0) {
          a.push(`Found the following '${o.sitePackages}' dirs`);
          s.forEach(e => {
            a.push(`  ${e}`);
          });
          return s;
        }
        a.push(`Did not find any '${o.sitePackages}' dirs. Falling back on python interpreter.`);
      }
      const i = n.getPythonSearchPaths(t.pythonPath, a);
      if (r && s && !s.isEmpty()) {
        return i.paths.filter(e => !e.startsWith(s) || e.startsWith(i.prefix)).map(t => e.realCasePath(t));
      }
      return i.paths.map(t => e.realCasePath(t));
    };
    exports.isPythonBinary = function (e) {
      return (e = e.trim()) === 'python' || e === 'python3';
    };
    exports.getPathsFromPthFiles = d;
    const i = require(34455);
    const o = __importStar(require(4883));
    const l = require(63808);
    const p = require(5884);
    function d(e, t) {
      const n = [];
      e.readdirEntriesSync(t).filter(e => (e.isFile() || e.isSymbolicLink()) && e.name.endsWith('.pth')).sort((e, t) => i.compareComparableValues(e.name, t.name)).forEach(a => {
        const r = e.realCasePath(t.combinePaths(a.name));
        const s = p.tryStat(e, r);
        if ((s == null ? undefined : s.isFile()) && s.size > 0 && s.size < 65536) {
          e.readFileSync(r, 'utf8').split(/\r?\n/).forEach(a => {
            const r = a.trim();
            if (r.length > 0 && !r.startsWith('#') && !r.match(/^import\s/)) {
              const a = t.combinePaths(r);
              if (e.existsSync(a) && p.isDirectory(e, a)) {
                n.push(e.realCasePath(a));
              }
            }
          });
        }
      });
      return n;
    }
    function c(e, t) {
      return !e.some(e => e.key === t.key) && (e.push(t), true);
    }
    exports.stdLibFolderName = 'stdlib';
    exports.thirdPartyFolderName = 'stubs';
  },
  35197: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Scope = undefined;
    const a = require(48281);
    const r = require(58253);
    exports.Scope = class {
      constructor(e, t, n) {
        this.symbolTable = new Map();
        this.notLocalBindings = new Map();
        this.type = e;
        this.parent = t;
        this.proxy = n;
      }
      getGlobalScope() {
        let e = this;
        let t = false;
        while (e) {
          if (e.type === 4 || e.type === 5) {
            return {
              scope: e,
              isBeyondExecutionScope: t
            };
          }
          if (e.type === 2) {
            t = true;
          }
          e = e.parent;
        }
        a.fail('failed to find scope');
        return {
          scope: this,
          isBeyondExecutionScope: t
        };
      }
      isIndependentlyExecutable() {
        return this.type === 4 || this.type === 2;
      }
      lookUpSymbol(e) {
        return this.symbolTable.get(e);
      }
      lookUpSymbolRecursive(e, t) {
        let n;
        let a = this;
        let r = this.symbolTable.get(e);
        if (!r && (t == null ? undefined : t.useProxyScope) && this.proxy) {
          r = this.proxy.symbolTable.get(e);
          a = this.proxy;
        }
        if (r) {
          if ((t == null ? undefined : t.isOutsideCallerModule) && r.isExternallyHidden()) {
            return;
          }
          const e = r.getDeclarations();
          if (e.length === 0 || e.some(e => e.type !== 1 || !e.isDefinedByMemberAccess)) {
            return {
              symbol: r,
              isOutsideCallerModule: !!(t == null ? undefined : t.isOutsideCallerModule),
              isBeyondExecutionScope: !!(t == null ? undefined : t.isBeyondExecutionScope),
              scope: a,
              usesNonlocalBinding: !!(t == null ? undefined : t.usesNonlocalBinding),
              usesGlobalBinding: !!(t == null ? undefined : t.usesGlobalBinding)
            };
          }
        }
        let s = (t == null ? undefined : t.isBeyondExecutionScope) || this.isIndependentlyExecutable();
        const i = this.notLocalBindings.get(e);
        if (i === 1) {
          const e = this.getGlobalScope();
          if (e.scope !== this) {
            n = e.scope;
            if (e.isBeyondExecutionScope) {
              s = true;
            }
          }
        } else {
          n = this.parent;
        }
        if (n) {
          return n.lookUpSymbolRecursive(e, {
            isOutsideCallerModule: !!(t == null ? undefined : t.isOutsideCallerModule) || this.type === 4,
            isBeyondExecutionScope: s,
            usesNonlocalBinding: i === 0 || !!(t == null ? undefined : t.usesNonlocalBinding),
            usesGlobalBinding: i === 1 || !!(t == null ? undefined : t.usesGlobalBinding)
          });
        }
      }
      addSymbol(e, t) {
        const n = new r.Symbol(t);
        this.symbolTable.set(e, n);
        return n;
      }
      getBindingType(e) {
        return this.notLocalBindings.get(e);
      }
      setBindingType(e, t) {
        return this.notLocalBindings.set(e, t);
      }
      setSlotsNames(e) {
        this.slotsNames = e;
      }
      getSlotsNames() {
        return this.slotsNames;
      }
    };
  },
  95952: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getBuiltInScope = function (e) {
      let t = e;
      while (t.type !== 5) {
        t = t.parent;
      }
      return t;
    };
    exports.getScopeForNode = function (e) {
      const t = r.getEvaluationScopeNode(e).node;
      return a.getScope(t);
    };
    exports.getScopeHierarchy = function (e, t) {
      const n = [];
      let s = e;
      while (s) {
        const e = r.getEvaluationScopeNode(s).node;
        const i = a.getScope(e);
        if (!i) {
          return;
        }
        if (n.length === 0 || n[n.length - 1] !== i) {
          n.push(i);
        }
        if (i === t) {
          return n;
        }
        s = e.parent;
      }
      if (t) {
        return undefined;
      } else {
        return n;
      }
    };
    exports.findTopNodeInScope = function (e, t) {
      let n;
      let r = e;
      let s = false;
      while (r) {
        if (a.getScope(r) === t) {
          s = true;
        } else {
          if (s) {
            return n;
          }
        }
        n = r;
        r = r.parent;
      }
      return;
    };
    exports.isScopeContainedWithin = function (e, t) {
      let n = e;
      while (n) {
        if (n.parent === t) {
          return true;
        }
        n = n.parent;
      }
      return false;
    };
    const a = require(26687);
    const r = require(41557);
  },
  33970: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.AnalyzerService = undefined;
    exports.getNextServiceId = P;
    const i = __importStar(require(8753));
    const o = require(33351);
    const l = require(91426);
    const p = require(12522);
    const d = require(25075);
    const c = require(34455);
    const u = require(12060);
    const m = require(50918);
    const y = require(4883);
    const g = require(54010);
    const h = require(63808);
    const f = require(71745);
    const T = require(71582);
    const v = require(27113);
    const b = require(5884);
    const _ = require(67703);
    const C = require(82695);
    const I = require(75130);
    const k = require(16259);
    const w = require(39045);
    const S = require(53266);
    const A = g.normalizeSlashes('/.git/');
    let x = 1;
    function P(e) {
      return `${e}_${x++}`;
    }
    class D {
      constructor(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        var o;
        this._typeStubTargetIsSingleFile = false;
        this._extendedConfigFileUris = [];
        this._requireTrackedFileUpdate = true;
        this._lastUserInteractionTime = 0;
        this._disposed = false;
        this._pendingLibraryChanges = {
          changesOnly: true
        };
        this._instanceName = e;
        this._executionRootUri = v.Uri.empty();
        this.options = n;
        this.options.serviceId = (a = this.options.serviceId) !== null && a !== undefined ? a : P(e);
        this.options.console = n.console || new d.StandardConsole();
        this._serviceProvider = t.clone();
        if (this.options.console) {
          this._serviceProvider.add(f.ServiceKeys.console, this.options.console);
        }
        if (this.options.fileSystem) {
          this._serviceProvider.add(f.ServiceKeys.fs, this.options.fileSystem);
        }
        this.options.importResolverFactory = (r = n.importResolverFactory) !== null && r !== undefined ? r : D.createImportResolver;
        this.options.cancellationProvider = (s = n.cancellationProvider) !== null && s !== undefined ? s : new l.DefaultCancellationProvider();
        this.options.hostFactory = (i = n.hostFactory) !== null && i !== undefined ? i : () => new m.NoAccessHost();
        this.options.configOptions = (o = n.configOptions) !== null && o !== undefined ? o : new p.ConfigOptions(v.Uri.file(process.cwd(), this._serviceProvider));
        const c = this.options.importResolverFactory(this._serviceProvider, this.options.configOptions, this.options.hostFactory());
        this._backgroundAnalysisProgram = this.options.backgroundAnalysisProgramFactory !== undefined ? this.options.backgroundAnalysisProgramFactory(this.options.serviceId, this._serviceProvider, this.options.configOptions, c, this.options.backgroundAnalysis, this.options.maxAnalysisTime) : new C.BackgroundAnalysisProgram(this.options.serviceId, this._serviceProvider, this.options.configOptions, c, this.options.backgroundAnalysis, this.options.maxAnalysisTime, undefined);
      }
      get fs() {
        return this._backgroundAnalysisProgram.importResolver.fileSystem;
      }
      get serviceProvider() {
        return this._serviceProvider;
      }
      get cancellationProvider() {
        return this.options.cancellationProvider;
      }
      get librarySearchUrisToWatch() {
        return this._librarySearchUrisToWatch;
      }
      get backgroundAnalysisProgram() {
        return this._backgroundAnalysisProgram;
      }
      get test_program() {
        return this._program;
      }
      get id() {
        return this.options.serviceId;
      }
      setServiceName(e) {
        this._instanceName = e;
      }
      clone(e, t, n, a) {
        var r;
        const s = new D(e, this._serviceProvider, {
          ...this.options,
          serviceId: t,
          backgroundAnalysis: n,
          skipScanningUserFiles: true,
          fileSystem: a
        });
        const i = this.getUserFiles();
        s.backgroundAnalysisProgram.setTrackedFiles(i);
        s.backgroundAnalysisProgram.markAllFilesDirty(true);
        for (const e of this.backgroundAnalysisProgram.program.getOpened()) {
          const t = e.sourceFile.getClientVersion();
          if (t !== undefined) {
            s.setFileOpened(e.sourceFile.getUri(), t, e.sourceFile.getOpenFileContents(), e.sourceFile.getIPythonMode(), (r = e.chainedSourceFile) === null || r === undefined ? undefined : r.sourceFile.getUri());
          }
        }
        return s;
      }
      runEditMode(e, t) {
        let n = [];
        this._backgroundAnalysisProgram.enterEditMode();
        try {
          this._program.runEditMode(e, t);
        } finally {
          n = this._backgroundAnalysisProgram.exitEditMode();
        }
        if (t.isCancellationRequested) {
          return [];
        } else {
          return n;
        }
      }
      dispose() {
        if (!this._disposed) {
          this._backgroundAnalysisProgram.dispose();
        }
        this._disposed = true;
        this._removeSourceFileWatchers();
        this._removeConfigFileWatcher();
        this._removeLibraryFileWatcher();
        this._clearReloadConfigTimer();
        this._clearReanalysisTimer();
        this._clearLibraryReanalysisTimer();
      }
      static createImportResolver(e, t, n) {
        return new I.ImportResolver(e, t, n);
      }
      setCompletionCallback(e) {
        this._onCompletionCallback = e;
        this._backgroundAnalysisProgram.setCompletionCallback(e);
      }
      setOptions(e) {
        this._commandLineOptions = e;
        const t = this._hostFactory();
        const n = this._getConfigOptions(t, e);
        this._backgroundAnalysisProgram.setConfigOptions(n);
        this._executionRootUri = n.projectRoot;
        this.applyConfigOptions(t);
      }
      hasSourceFile(e) {
        return this.backgroundAnalysisProgram.hasSourceFile(e);
      }
      isTracked(e) {
        return this._program.owns(e);
      }
      getUserFiles() {
        return this._program.getUserFiles().map(e => e.sourceFile.getUri());
      }
      getOpenFiles() {
        return this._program.getOpened().map(e => e.sourceFile.getUri());
      }
      setFileOpened(e, t, n, a = S.IPythonMode.None, r) {
        this._backgroundAnalysisProgram.setFileOpened(e, t, n, {
          isTracked: this.isTracked(e) || a !== S.IPythonMode.None,
          ipythonMode: a,
          chainedFileUri: r
        });
        this._scheduleReanalysis(false);
      }
      getChainedUri(e) {
        return this._backgroundAnalysisProgram.getChainedUri(e);
      }
      updateChainedUri(e, t) {
        this._backgroundAnalysisProgram.updateChainedUri(e, t);
        this._scheduleReanalysis(false);
      }
      updateOpenFileContents(e, t, n, a = S.IPythonMode.None) {
        this._backgroundAnalysisProgram.updateOpenFileContents(e, t, n, {
          isTracked: this.isTracked(e),
          ipythonMode: a,
          chainedFileUri: undefined
        });
        this._scheduleReanalysis(false);
      }
      setFileClosed(e, t) {
        this._backgroundAnalysisProgram.setFileClosed(e, t);
        this._scheduleReanalysis(false);
      }
      addInterimFile(e) {
        this._backgroundAnalysisProgram.addInterimFile(e);
      }
      getParserOutput(e) {
        return this._program.getParserOutput(e);
      }
      getParseResults(e) {
        return this._program.getParseResults(e);
      }
      getSourceFile(e) {
        return this._program.getBoundSourceFile(e);
      }
      getTextOnRange(e, t, n) {
        return this._program.getTextOnRange(e, t, n);
      }
      run(e, t) {
        return this._program.run(e, t);
      }
      printStats() {
        this._console.info('');
        this._console.info('Analysis stats');
        const e = this._program.getFileCount(false);
        this._console.info(`Total files parsed and bound: ${e.toString()}`);
        const t = this._program.getUserFileCount();
        this._console.info(`Total files checked: ${t.toString()}`);
      }
      printDetailedAnalysisTimes() {
        this._program.printDetailedAnalysisTimes();
      }
      printDependencies(e) {
        this._program.printDependencies(this._executionRootUri, e);
      }
      analyzeFile(e, t) {
        return this._backgroundAnalysisProgram.analyzeFile(e, t);
      }
      getDiagnosticsForRange(e, t, n) {
        return this._backgroundAnalysisProgram.getDiagnosticsForRange(e, t, n);
      }
      getConfigOptions() {
        return this._configOptions;
      }
      getImportResolver() {
        return this._backgroundAnalysisProgram.importResolver;
      }
      recordUserInteractionTime() {
        this._lastUserInteractionTime = Date.now();
        if (this._analyzeTimer) {
          this._scheduleReanalysis(false);
        }
      }
      test_getConfigOptions(e) {
        return this._getConfigOptions(this._backgroundAnalysisProgram.host, e);
      }
      test_getFileNamesFromFileSpecs() {
        return this._getFileNamesFromFileSpecs();
      }
      test_shouldHandleSourceFileWatchChanges(e, t) {
        return this._shouldHandleSourceFileWatchChanges(e, t);
      }
      test_shouldHandleLibraryFileWatchChanges(e, t) {
        return this._shouldHandleLibraryFileWatchChanges(e, t);
      }
      writeTypeStub(e) {
        var t;
        const n = this._getTypeStubFolder();
        this._program.writeTypeStub((t = this._typeStubTargetUri) !== null && t !== undefined ? t : v.Uri.empty(), this._typeStubTargetIsSingleFile, n, e);
      }
      writeTypeStubInBackground(e) {
        var t;
        const n = this._getTypeStubFolder();
        return this._backgroundAnalysisProgram.writeTypeStub((t = this._typeStubTargetUri) !== null && t !== undefined ? t : v.Uri.empty(), this._typeStubTargetIsSingleFile, n, e);
      }
      invalidateAndForceReanalysis(e) {
        this._backgroundAnalysisProgram.invalidateAndForceReanalysis(e);
      }
      restart() {
        this.applyConfigOptions(this._hostFactory());
        this._backgroundAnalysisProgram.restart();
      }
      runAnalysis(e) {
        if (this._backgroundAnalysisProgram.startAnalysis(e)) {
          this._scheduleReanalysis(false);
        }
      }
      applyConfigOptions(e) {
        var t;
        var n;
        const a = this._importResolverFactory(this._serviceProvider, this._backgroundAnalysisProgram.configOptions, e);
        this._backgroundAnalysisProgram.setImportResolver(a);
        if (((t = this._commandLineOptions) === null || t === undefined ? undefined : t.fromLanguageServer) || this._configOptions.verboseOutput) {
          const e = this._configOptions.verboseOutput ? d.LogLevel.Info : d.LogLevel.Log;
          const t = this._configOptions.getExecutionEnvironments();
          for (const r of t) {
            d.log(this._console, e, `Execution environment: ${r.name}`);
            d.log(this._console, e, '  Extra paths:');
            if (r.extraPaths.length > 0) {
              r.extraPaths.forEach(t => {
                d.log(this._console, e, `    ${t.toUserVisibleString()}`);
              });
            } else {
              d.log(this._console, e, '    (none)');
            }
            d.log(this._console, e, `  Python version: ${h.PythonVersion.toString(r.pythonVersion)}`);
            d.log(this._console, e, `  Python platform: ${(n = r.pythonPlatform) !== null && n !== undefined ? n : 'All'}`);
            d.log(this._console, e, '  Search paths:');
            a.getImportRoots(r, true).forEach(t => {
              d.log(this._console, e, `    ${t.toUserVisibleString()}`);
            });
          }
        }
        this._updateLibraryFileWatcher();
        this._updateConfigFileWatcher();
        this._updateSourceFileWatchers();
        this._updateTrackedFileList(true);
        this._scheduleReanalysis(false);
      }
      get _console() {
        return this.options.console;
      }
      get _hostFactory() {
        return this.options.hostFactory;
      }
      get _importResolverFactory() {
        return this.options.importResolverFactory;
      }
      get _program() {
        return this._backgroundAnalysisProgram.program;
      }
      get _configOptions() {
        return this._backgroundAnalysisProgram.configOptions;
      }
      get _watchForSourceChanges() {
        var e;
        return !!((e = this._commandLineOptions) === null || e === undefined ? undefined : e.languageServerSettings.watchForSourceChanges);
      }
      get _watchForLibraryChanges() {
        var e;
        return !!((e = this._commandLineOptions) === null || e === undefined ? undefined : e.languageServerSettings.watchForLibraryChanges) && !!this.options.libraryReanalysisTimeProvider;
      }
      get _watchForConfigChanges() {
        var e;
        return !!((e = this._commandLineOptions) === null || e === undefined ? undefined : e.languageServerSettings.watchForConfigChanges);
      }
      get _typeCheckingMode() {
        var e;
        if ((e = this._commandLineOptions) === null || e === undefined) {
          return undefined;
        } else {
          return e.configSettings.typeCheckingMode;
        }
      }
      get _verboseOutput() {
        return !!this._configOptions.verboseOutput;
      }
      get _typeStubTargetImportName() {
        var e;
        if ((e = this._commandLineOptions) === null || e === undefined) {
          return undefined;
        } else {
          return e.languageServerSettings.typeStubTargetImportName;
        }
      }
      _getConfigOptions(e, t) {
        const n = t.executionRoot;
        const a = v.Uri.is(n) ? n : c.isString(n) && n.length > 0 ? v.Uri.file(n, this.serviceProvider, true) : v.Uri.defaultWorkspace(this.serviceProvider);
        const r = this.fs.realCasePath(a);
        let s;
        let i;
        let o = r;
        if (t.configFilePath) {
          s = this.fs.realCasePath(g.isRootedDiskPath(t.configFilePath) ? v.Uri.file(t.configFilePath, this.serviceProvider, true) : o.resolvePaths(t.configFilePath));
          if (this.fs.existsSync(s)) {
            if (s.lastExtension.endsWith('.json') || s.lastExtension.endsWith('.toml')) {
              o = s.getDirectory();
            } else {
              o = s;
              s = w.findConfigFile(this.fs, s);
              if (!s) {
                this._console.info(`Configuration file not found at ${o.toUserVisibleString()}.`);
              }
            }
          } else {
            this._console.info(`Configuration file not found at ${s.toUserVisibleString()}.`);
            s = o;
          }
        } else {
          if (t.executionRoot) {
            s = w.findConfigFile(this.fs, o);
            if (!s && !t.fromLanguageServer) {
              s = w.findConfigFileHereOrUp(this.fs, o);
            }
            if (s) {
              o = s.getDirectory();
            } else {
              this._console.log('No configuration file found.');
              s = undefined;
            }
          }
        }
        if (!s) {
          i = w.findPyprojectTomlFile(this.fs, o);
          if (!i && !t.fromLanguageServer) {
            i = w.findPyprojectTomlFileHereOrUp(this.fs, o);
          }
          if (i) {
            o = i.getDirectory();
            this._console.log(`pyproject.toml file found at ${o.toUserVisibleString()}.`);
          } else {
            this._console.log('No pyproject.toml file found.');
          }
        }
        const l = new p.ConfigOptions(o);
        const d = this._getExtendedConfigurations(s ?? i);
        if (d && d.length > 0) {
          l.initializeTypeCheckingMode('standard');
          for (const t of d) {
            l.initializeFromJson(t.configFileJsonObj, t.configFileDirUri, this.serviceProvider, e);
          }
          l.configFileSource = s ?? i;
          if (!t.fromLanguageServer) {
            this._applyCommandLineOverrides(l, t.configSettings, o, false);
          }
        } else {
          l.initializeTypeCheckingMode(t.fromLanguageServer ? 'off' : 'standard');
          this._applyCommandLineOverrides(l, t.configSettings, o, t.fromLanguageServer);
        }
        this._applyLanguageServerOptions(l, o, t.languageServerSettings);
        this._ensureDefaultOptions(e, l, o, r, t);
        if (d) {
          for (const e of d) {
            l.setupExecutionEnvironments(e.configFileJsonObj, e.configFileDirUri, this.serviceProvider.console());
          }
        }
        return l;
      }
      _ensureDefaultOptions(e, t, n, a, r) {
        var s;
        var i;
        const o = ['**/node_modules', '**/__pycache__', '**/.*'];
        if (t.include.length === 0) {
          this._console.info(`No include entries specified; assuming ${n.toUserVisibleString()}`);
          t.include.push(b.getFileSpec(n, '.'));
        }
        if (t.exclude.length === 0) {
          o.forEach(e => {
            this._console.info(`Auto-excluding ${e}`);
            t.exclude.push(b.getFileSpec(n, e));
          });
          if (t.autoExcludeVenv === undefined) {
            t.autoExcludeVenv = true;
          }
        }
        if (!t.defaultExtraPaths) {
          t.ensureDefaultExtraPaths(this.fs, (s = r.configSettings.autoSearchPaths) !== null && s !== undefined && s, r.configSettings.extraPaths);
        }
        if (t.defaultPythonPlatform === undefined) {
          t.defaultPythonPlatform = r.configSettings.pythonPlatform;
        }
        if (t.defaultPythonVersion === undefined) {
          t.defaultPythonVersion = r.configSettings.pythonVersion;
        }
        if (t.typeshedPath && t.typeshedPath === n && t.defaultPythonVersion !== undefined) {
          const e = this.getImportResolver().getTypeshedStdlibExcludeList(t.typeshedPath, t.defaultPythonVersion, t.defaultPythonPlatform);
          this._console.info('Excluding typeshed stdlib stubs according to VERSIONS file:');
          e.forEach(e => {
            this._console.info(`    ${e}`);
            t.exclude.push(b.getFileSpec(a, e.getFilePath()));
          });
        }
        if (t.useLibraryCodeForTypes === undefined) {
          t.useLibraryCodeForTypes = true;
        }
        if (t.stubPath) {
          if (!this.fs.existsSync(t.stubPath) || !b.isDirectory(this.fs, t.stubPath)) {
            this._console.warn(`stubPath ${t.stubPath} is not a valid directory.`);
          }
        } else {
          t.stubPath = t.projectRoot.resolvePaths(y.defaultStubsDirectory);
        }
        if (t.venvPath && (this.fs.existsSync(t.venvPath) && b.isDirectory(this.fs, t.venvPath) || this._console.error(`venvPath ${t.venvPath.toUserVisibleString()} is not a valid directory.`), t.venv = (i = t.venv) !== null && i !== undefined ? i : this._configOptions.venv, t.venv && t.venvPath)) {
          const n = t.venvPath.resolvePaths(t.venv);
          if (this.fs.existsSync(n) && b.isDirectory(this.fs, n)) {
            const n = [];
            if (k.findPythonSearchPaths(this.fs, t, e, n) === undefined) {
              this._console.error(`site-packages directory cannot be located for venvPath ${t.venvPath.toUserVisibleString()} and venv ${t.venv}.`);
              if (t.verboseOutput) {
                n.forEach(e => {
                  this._console.error(`  ${e}`);
                });
              }
            }
          } else {
            this._console.error(`venv ${t.venv} subdirectory not found in venv path ${t.venvPath.toUserVisibleString()}.`);
          }
        }
        if (t.venv) {
          if (!t.venvPath) {
            this._console.warn('venvPath not specified, so venv settings will be ignored.');
          }
        }
        if (t.typeshedPath) {
          if (!this.fs.existsSync(t.typeshedPath) || !b.isDirectory(this.fs, t.typeshedPath)) {
            this._console.error(`typeshedPath ${t.typeshedPath.toUserVisibleString()} is not a valid directory.`);
          }
        }
        if (r.configSettings.verboseOutput !== undefined) {
          t.verboseOutput = r.configSettings.verboseOutput;
        }
        if (t.pythonPath) {
          t.ensureDefaultPythonVersion(e, this._console);
        }
        t.ensureDefaultPythonPlatform(e, this._console);
      }
      _applyLanguageServerOptions(e, t, n) {
        e.disableTaggedHints = !!n.disableTaggedHints;
        if (n.checkOnlyOpenFiles !== undefined) {
          e.checkOnlyOpenFiles = n.checkOnlyOpenFiles;
        }
        if (n.autoImportCompletions !== undefined) {
          e.autoImportCompletions = n.autoImportCompletions;
        }
        if (n.indexing !== undefined) {
          e.indexing = n.indexing;
        }
        if (n.taskListTokens) {
          e.taskListTokens = n.taskListTokens;
        }
        if (n.logTypeEvaluationTime !== undefined) {
          e.logTypeEvaluationTime = n.logTypeEvaluationTime;
        }
        e.typeEvaluationTimeThreshold = n.typeEvaluationTimeThreshold;
        if (n.pythonPath) {
          this._console.info(`Setting pythonPath for service "${this._instanceName}": "${n.pythonPath}"`);
          e.pythonPath = this.fs.realCasePath(v.Uri.file(n.pythonPath, this.serviceProvider, true));
        }
        if (n.venvPath) {
          if (!e.venvPath) {
            e.venvPath = t.resolvePaths(n.venvPath);
          }
        }
      }
      _applyCommandLineOverrides(e, t, n, a) {
        var r;
        var s;
        var i;
        if (t.typeCheckingMode) {
          e.initializeTypeCheckingMode(t.typeCheckingMode);
        }
        if (t.extraPaths) {
          e.ensureDefaultExtraPaths(this.fs, (r = t.autoSearchPaths) !== null && r !== undefined && r, t.extraPaths);
        }
        if (t.pythonVersion || t.pythonPlatform) {
          e.defaultPythonVersion = (s = t.pythonVersion) !== null && s !== undefined ? s : e.defaultPythonVersion;
          e.defaultPythonPlatform = (i = t.pythonPlatform) !== null && i !== undefined ? i : e.defaultPythonPlatform;
        }
        if (t.pythonPath) {
          this._console.info(`Setting pythonPath for service "${this._instanceName}": "${t.pythonPath}"`);
          e.pythonPath = this.fs.realCasePath(v.Uri.file(t.pythonPath, this.serviceProvider, true));
        }
        if (t.pythonEnvironmentName) {
          this._console.info(`Setting environmentName for service "${this._instanceName}": "${t.pythonEnvironmentName}"`);
          e.pythonEnvironmentName = t.pythonEnvironmentName;
        }
        t.includeFileSpecs.forEach(t => {
          e.include.push(b.getFileSpec(n, t));
        });
        t.excludeFileSpecs.forEach(t => {
          e.exclude.push(b.getFileSpec(n, t));
        });
        t.ignoreFileSpecs.forEach(t => {
          e.ignore.push(b.getFileSpec(n, t));
        });
        e.applyDiagnosticOverrides(t.diagnosticSeverityOverrides);
        e.applyDiagnosticOverrides(t.diagnosticBooleanOverrides);
        if (t.analyzeUnannotatedFunctions !== undefined) {
          e.diagnosticRuleSet.analyzeUnannotatedFunctions = t.analyzeUnannotatedFunctions;
        }
        if (t.includeFileSpecsOverride) {
          e.include = [];
          t.includeFileSpecsOverride.forEach(t => {
            e.include.push(b.getFileSpec(v.Uri.file(t, this.serviceProvider, true), '.'));
          });
        }
        if (t.venvPath) {
          e.venvPath = n.resolvePaths(t.venvPath);
        }
        const o = (e, t) => {
          const n = a ? 'the client settings' : 'a command-line option';
          this._console.warn(`The ${e} has been specified in both the config file and ${n}. The value in the config file (${t}) will take precedence`);
        };
        if (t.typeshedPath) {
          if (e.typeshedPath) {
            o('typeshedPath', e.typeshedPath.toUserVisibleString());
          } else {
            e.typeshedPath = n.resolvePaths(t.typeshedPath);
          }
        }
        if (e.useLibraryCodeForTypes === undefined) {
          e.useLibraryCodeForTypes = t.useLibraryCodeForTypes;
        } else {
          if (t.useLibraryCodeForTypes !== undefined) {
            o('useLibraryCodeForTypes', e.useLibraryCodeForTypes);
          }
        }
        if (t.stubPath) {
          if (e.stubPath) {
            o('stubPath', e.stubPath.toUserVisibleString());
          } else {
            e.stubPath = this.fs.realCasePath(n.resolvePaths(t.stubPath));
          }
        }
      }
      _getExtendedConfigurations(e) {
        this._primaryConfigFileUri = e;
        this._extendedConfigFileUris = [];
        if (!e) {
          return;
        }
        let t = e;
        const n = [];
        while (true) {
          let e;
          this._extendedConfigFileUris.push(t);
          if (t.lastExtension.endsWith('.toml')) {
            this._console.info(`Loading pyproject.toml file at ${t.toUserVisibleString()}`);
            e = this._parsePyprojectTomlFile(t);
          } else {
            this._console.info(`Loading configuration file at ${t.toUserVisibleString()}`);
            e = this._parseJsonConfigFile(t);
          }
          if (!e) {
            break;
          }
          n.unshift({
            configFileJsonObj: e,
            configFileDirUri: t.getDirectory()
          });
          const a = p.ConfigOptions.resolveExtends(e, t.getDirectory());
          if (!a) {
            break;
          }
          if (this._extendedConfigFileUris.some(e => e.equals(a))) {
            this._console.error(`Circular reference in configuration file "extends" setting: ${t.toUserVisibleString()} extends ${a.toUserVisibleString()}`);
            break;
          }
          t = a;
        }
        return n;
      }
      _getTypeStubFolder() {
        var e;
        const t = (e = this._configOptions.stubPath) !== null && e !== undefined ? e : this.fs.realCasePath(this._configOptions.projectRoot.resolvePaths(y.defaultStubsDirectory));
        if (!this._typeStubTargetUri || !this._typeStubTargetImportName) {
          const e = `Import '${this._typeStubTargetImportName}' could not be resolved`;
          this._console.error(e);
          throw new Error(e);
        }
        const n = this._typeStubTargetImportName.split('.');
        if (n[0].length === 0) {
          const e = `Import '${this._typeStubTargetImportName}' could not be resolved`;
          this._console.error(e);
          throw new Error(e);
        }
        try {
          if (!this.fs.existsSync(t)) {
            this.fs.mkdirSync(t);
          }
        } catch (e) {
          const n = `Could not create typings directory '${t.toUserVisibleString()}'`;
          this._console.error(n);
          throw new Error(n);
        }
        const a = t.resolvePaths(n[0]);
        const r = t.resolvePaths(...n);
        try {
          if (!this.fs.existsSync(r)) {
            b.makeDirectories(this.fs, r, t);
          }
        } catch (e) {
          const t = `Could not create typings subdirectory '${r.toUserVisibleString()}'`;
          this._console.error(t);
          throw new Error(t);
        }
        return a;
      }
      _parseJsonConfigFile(e) {
        return this._attemptParseFile(e, e => {
          const t = [];
          const n = i.parse(e, t, {
            allowTrailingComma: true
          });
          if (t.length > 0) {
            throw new Error('Errors parsing JSON file');
          }
          return n;
        });
      }
      _parsePyprojectTomlFile(e) {
        return this._attemptParseFile(e, (t, n) => {
          try {
            const e = o.parse(t);
            if (e && 'tool' in e) {
              return e.tool.pyright;
            }
          } catch (e) {
            this._console.error(`Pyproject file parse attempt ${n} error: ${JSON.stringify(e)}`);
            throw e;
          }
          this._console.info(`Pyproject file "${e.toUserVisibleString()}" has no "[tool.pyright]" section.`);
        });
      }
      _attemptParseFile(e, t) {
        let n = '';
        let a = 0;
        while (true) {
          try {
            n = this.fs.readFileSync(e, 'utf8');
          } catch {
            this._console.error(`Config file "${e.toUserVisibleString()}" could not be read.`);
            this._reportConfigParseError();
            return;
          }
          let r = false;
          try {
            return t(n, a + 1);
          } catch (e) {
            r = true;
          }
          if (!r) {
            break;
          }
          if (a++ >= 5) {
            this._console.error(`Config file "${e.toUserVisibleString()}" could not be parsed. Verify that format is correct.`);
            this._reportConfigParseError();
            return;
          }
        }
      }
      _getFileNamesFromFileSpecs() {
        const e = new Map();
        T.timingStats.findFilesTime.timeOperation(() => {
          const t = this._matchFiles(this._configOptions.include, this._configOptions.exclude);
          for (const n of t) {
            e.set(n.key, n);
          }
        });
        this._backgroundAnalysisProgram.program.getOpened().map(e => e.sourceFile.getUri()).filter(e => p.matchFileSpecs(this._program.configOptions, e)).forEach(t => e.set(t.key, t));
        return Array.from(e.values());
      }
      _updateTrackedFileList(e) {
        if (this._typeStubTargetImportName) {
          const e = this._configOptions.findExecEnvironment(this._executionRootUri);
          const t = I.createImportedModuleDescriptor(this._typeStubTargetImportName);
          const n = this._backgroundAnalysisProgram.importResolver.resolveImport(v.Uri.empty(), e, t);
          if (n.isImportFound) {
            const e = [];
            const t = n.resolvedUris[n.resolvedUris.length - 1];
            const a = b.isFile(this.fs, t);
            const r = a && t.stripAllExtensions().fileName === '__init__';
            let s = t;
            if (a) {
              s = s.getDirectory();
            }
            for (let e = n.resolvedUris.length - 2; e >= 0; e--) {
              s = n.resolvedUris[e].isEmpty() ? s.getDirectory() : n.resolvedUris[e];
            }
            if (b.isDirectory(this.fs, s)) {
              this._typeStubTargetUri = s;
            } else {
              if (b.isFile(this.fs, s)) {
                this._typeStubTargetUri = s.getDirectory();
              }
            }
            if (t.isEmpty()) {
              this._typeStubTargetIsSingleFile = false;
            } else {
              e.push(t);
              this._typeStubTargetIsSingleFile = n.resolvedUris.length === 1 && !r;
            }
            n.filteredImplicitImports.forEach(t => {
              if (I.ImportResolver.isSupportedImportSourceFile(t.uri)) {
                e.push(t.uri);
              }
            });
            this._backgroundAnalysisProgram.setAllowedThirdPartyImports([this._typeStubTargetImportName]);
            this._backgroundAnalysisProgram.setTrackedFiles(e);
          } else {
            this._console.error(`Import '${this._typeStubTargetImportName}' not found`);
          }
        } else {
          if (!this.options.skipScanningUserFiles) {
            let t = [];
            this._console.log('Searching for source files');
            t = this._getFileNamesFromFileSpecs();
            this._backgroundAnalysisProgram.setConfigOptions(this._configOptions);
            this._backgroundAnalysisProgram.setTrackedFiles(t);
            this._backgroundAnalysisProgram.markAllFilesDirty(e);
            if (t.length === 0) {
              this._console.info('No source files found.');
            } else {
              this._console.info(`Found ${t.length} source ${t.length === 1 ? 'file' : 'files'}`);
            }
          }
        }
        this._requireTrackedFileUpdate = false;
      }
      _tryShowLongOperationMessageBox() {
        const e = this.serviceProvider.tryGet(f.ServiceKeys.windowService);
        if (!e) {
          return;
        }
        const t = _.Localizer.Service.longOperation();
        const n = e.createGoToOutputAction();
        e.showInformationMessage(t, n);
      }
      _matchFiles(e, t) {
        if (this._executionRootUri.isEmpty()) {
          return [];
        }
        const n = [['bin', 'activate'], ['Scripts', 'activate'], ['pyvenv.cfg'], ['conda-meta']];
        const a = [];
        const r = Date.now();
        let s = false;
        let i = 0;
        const o = (e, o, l) => {
          if (!s) {
            if ((Date.now() - r) * 0.001 >= 10 && i >= 50) {
              this._console.error('Enumeration of workspace source files is taking longer than 10 seconds.\nThis may be because:\n* You have opened your home directory or entire hard drive as a workspace\n* Your workspace contains a very large number of directories and files\n* Your workspace contains a symlink to a directory with many files\n* Your workspace is remote, and file enumeration is slow\nTo reduce this time, open a workspace directory with fewer files or add a pyrightconfig.json configuration file with an "exclude" section to exclude subdirectories from your workspace. For more details, refer to https://github.com/microsoft/pyright/blob/main/docs/configuration.md.');
              this._tryShowLongOperationMessageBox();
              s = true;
            }
          }
          if (this._configOptions.autoExcludeVenv && n.some(t => this.fs.existsSync(e.resolvePaths(...t)))) {
            if (!b.FileSpec.isInPath(e, t)) {
              t.push(b.getFileSpec(this._configOptions.projectRoot, `${e}/**`));
            }
            this._console.info(`Auto-excluding ${e.toUserVisibleString()}`);
            return;
          }
          const {
            files: d,
            directories: c
          } = b.getFileSystemEntries(this.fs, e);
          for (const e of d) {
            if (b.FileSpec.matchIncludeFileSpec(o, t, e)) {
              i++;
              a.push(e);
            }
          }
          for (const e of c) {
            if (e.matchesRegex(o) || l) {
              if (!b.FileSpec.isInPath(e, t)) {
                p(e, o, l);
              }
            }
          }
        };
        const l = new Set();
        const p = (e, t, n) => {
          const a = b.tryRealpath(this.fs, e);
          if (a) {
            if (l.has(a.key)) {
              this._console.warn(`Skipping recursive symlink "${e}" -> "${a}"`);
            } else {
              l.add(a.key);
              try {
                o(e, t, n);
              } finally {
                l.delete(a.key);
              }
            }
          } else {
            this._console.warn(`Skipping broken link "${e}"`);
          }
        };
        e.forEach(e => {
          if (!b.FileSpec.isInPath(e.wildcardRoot, t)) {
            let t = false;
            const n = b.tryStat(this.fs, e.wildcardRoot);
            if (n == null ? undefined : n.isFile()) {
              a.push(e.wildcardRoot);
              t = true;
            } else {
              if (n == null ? undefined : n.isDirectory()) {
                p(e.wildcardRoot, e.regExp, e.hasDirectoryWildcard);
                t = true;
              }
            }
            if (!t) {
              this._console.error(`File or directory "${e.wildcardRoot.toUserVisibleString()}" does not exist.`);
            }
          }
        });
        return a;
      }
      _removeSourceFileWatchers() {
        if (this._sourceFileWatcher) {
          this._sourceFileWatcher.close();
          this._sourceFileWatcher = undefined;
        }
      }
      _updateSourceFileWatchers() {
        this._removeSourceFileWatchers();
        if (this._watchForSourceChanges && this._configOptions.include.length > 0) {
          const e = this._configOptions.include.map(e => e.wildcardRoot);
          try {
            if (this._verboseOutput) {
              this._console.info(`Adding fs watcher for directories:\n ${e.join('\n')}`);
            }
            const t = u.ignoredWatchEventFunction(e.map(e => e.getFilePath()));
            this._sourceFileWatcher = this.fs.createFileSystemWatcher(e, (e, n) => {
              if (!n) {
                return;
              }
              if (this._verboseOutput) {
                this._console.info(`SourceFile: Received fs event '${e}' for path '${n}'`);
              }
              if (t(n)) {
                return;
              }
              if (n.endsWith('.tmp') || n.endsWith('.git') || n.includes(A)) {
                return;
              }
              let a = v.Uri.file(n, this.serviceProvider, true);
              a = this.fs.realCasePath(a);
              const r = function (e, t, n, a, r) {
                const s = b.tryStat(e, r);
                if (a === 'add') {
                  if (!s) {
                    return;
                  }
                  return {
                    event: a,
                    isFile: s.isFile()
                  };
                }
                if (a === 'change') {
                  if (!s) {
                    const e = !!n.getSourceFile(r);
                    if (!e && !n.containsSourceFileIn(r)) {
                      return;
                    }
                    return {
                      event: 'unlink',
                      isFile: e
                    };
                  }
                  return {
                    event: a,
                    isFile: s.isFile()
                  };
                }
                t.warn(`Received unknown file change event: '${a}' for '${r}'`);
                return;
              }(this.fs, this._console, this._program, e, a);
              if (r && this._shouldHandleSourceFileWatchChanges(a, r.isFile)) {
                if (r.isFile && r.event === 'change') {
                  this._backgroundAnalysisProgram.markFilesDirty([a], false);
                  this._scheduleReanalysis(false);
                  return;
                }
                this.invalidateAndForceReanalysis(C.InvalidatedReason.SourceWatcherChanged);
                this._scheduleReanalysis(true);
              }
            });
          } catch {
            this._console.error(`Exception caught when installing fs watcher for:\n ${e.map(e => e.toUserVisibleString()).join('\n')}`);
          }
        }
      }
      _shouldHandleSourceFileWatchChanges(e, t) {
        if (t) {
          return !!b.hasPythonExtension(e) && !function (e) {
            const t = e.fileName;
            const n = t.split('.');
            if (n.length === 4 && n[3] === n[1] && n[2].length === 32) {
              return true;
            }
            return false;
          }(e) && (!!this.isTracked(e) || !!this._program.getSourceFileInfo(e));
        }
        if (!p.matchFileSpecs(this._program.configOptions, e, false)) {
          return false;
        }
        const n = e.getDirectory();
        return !!n.startsWith(this._configOptions.projectRoot) && (!!this.fs.existsSync(n.initPyUri) || !!this.fs.existsSync(n.initPyiUri)) || !!this._program.containsSourceFileIn(e);
      }
      _removeLibraryFileWatcher() {
        if (this._libraryFileWatcher) {
          this._libraryFileWatcher.close();
          this._libraryFileWatcher = undefined;
        }
      }
      _updateLibraryFileWatcher() {
        this._removeLibraryFileWatcher();
        if (!this._watchForLibraryChanges) {
          this._librarySearchUrisToWatch = undefined;
          return;
        }
        this._librarySearchUrisToWatch = k.findPythonSearchPaths(this.fs, this._backgroundAnalysisProgram.configOptions, this._backgroundAnalysisProgram.host, [], true, this._executionRootUri);
        const e = this._configOptions.getExecutionEnvironments().map(e => e.extraPaths.filter(e => !p.matchFileSpecs(this._configOptions, e, false))).flat();
        const t = b.deduplicateFolders([this._librarySearchUrisToWatch, e]);
        if (t.length > 0) {
          try {
            if (this._verboseOutput) {
              this._console.info(`Adding fs watcher for library directories:\n ${t.join('\n')}`);
            }
            const e = u.ignoredWatchEventFunction(t.map(e => e.getFilePath()));
            this._libraryFileWatcher = this.fs.createFileSystemWatcher(t, (n, a) => {
              if (!a) {
                return;
              }
              if (this._verboseOutput) {
                this._console.info(`LibraryFile: Received fs event '${n}' for path '${a}'`);
              }
              if (e(a)) {
                return;
              }
              const r = v.Uri.file(a, this.serviceProvider, true);
              if (!this._shouldHandleLibraryFileWatchChanges(r, t)) {
                return;
              }
              const s = n === 'change' && this.fs.existsSync(r);
              this._scheduleLibraryAnalysis(s);
            });
          } catch {
            this._console.error(`Exception caught when installing fs watcher for:\n ${t.map(e => e.toUserVisibleString()).join('\n')}`);
          }
        }
      }
      _shouldHandleLibraryFileWatchChanges(e, t) {
        if (this._program.getSourceFileInfo(e)) {
          return true;
        }
        let n;
        for (const a of t) {
          if (e.isChild(a) && (!n || n.getPathLength() < a.getPathLength())) {
            n = a;
          }
        }
        if (!n) {
          return true;
        }
        const a = n.getPathComponents();
        const r = e.getPathComponents();
        for (let e = a.length; e < r.length; e++) {
          if (r[e].startsWith('.')) {
            return false;
          }
        }
        return true;
      }
      _clearLibraryReanalysisTimer() {
        var e;
        var t;
        var n;
        if (this._libraryReanalysisTimer) {
          clearTimeout(this._libraryReanalysisTimer);
          this._libraryReanalysisTimer = undefined;
          const a = (e = this._backgroundAnalysisProgram) === null || e === undefined ? undefined : e.libraryUpdated();
          if ((n = (t = this.options.libraryReanalysisTimeProvider) === null || t === undefined ? undefined : t.libraryUpdated) !== null && n !== undefined) {
            n.call(t, a);
          }
        }
      }
      _scheduleLibraryAnalysis(e) {
        if (this._disposed) {
          return;
        }
        this._clearLibraryReanalysisTimer();
        const t = this.options.libraryReanalysisTimeProvider;
        const n = t == null ? undefined : t();
        if (n) {
          this._pendingLibraryChanges.changesOnly = this._pendingLibraryChanges.changesOnly && e;
          this._libraryReanalysisTimer = setTimeout(() => {
            var e;
            var n;
            this._clearLibraryReanalysisTimer();
            this.invalidateAndForceReanalysis(this._pendingLibraryChanges.changesOnly ? C.InvalidatedReason.LibraryWatcherContentOnlyChanged : C.InvalidatedReason.LibraryWatcherChanged);
            this._scheduleReanalysis(false);
            if ((n = (e = t).libraryReanalysisStarted) !== null && n !== undefined) {
              n.call(e);
            }
            this._pendingLibraryChanges.changesOnly = true;
          }, n);
        }
      }
      _removeConfigFileWatcher() {
        if (this._configFileWatcher) {
          this._configFileWatcher.close();
          this._configFileWatcher = undefined;
        }
      }
      _updateConfigFileWatcher() {
        this._removeConfigFileWatcher();
        if (this._watchForConfigChanges) {
          if (this._primaryConfigFileUri) {
            this._configFileWatcher = this.fs.createFileSystemWatcher(this._extendedConfigFileUris, e => {
              if (this._verboseOutput) {
                this._console.info(`Received fs event '${e}' for config file`);
              }
              this._scheduleReloadConfigFile();
            });
          } else {
            if (!this._executionRootUri.isEmpty()) {
              this._configFileWatcher = this.fs.createFileSystemWatcher([this._executionRootUri], (e, t) => {
                if (t && (e === 'add' || e === 'change')) {
                  if (g.getFileName(t) === y.configFileName) {
                    if (this._verboseOutput) {
                      this._console.info(`Received fs event '${e}' for config file`);
                    }
                    if (this._commandLineOptions) {
                      this.setOptions(this._commandLineOptions);
                    }
                  }
                }
              });
            }
          }
        }
      }
      _clearReloadConfigTimer() {
        if (this._reloadConfigTimer) {
          clearTimeout(this._reloadConfigTimer);
          this._reloadConfigTimer = undefined;
        }
      }
      _scheduleReloadConfigFile() {
        this._clearReloadConfigTimer();
        this._reloadConfigTimer = setTimeout(() => {
          this._clearReloadConfigTimer();
          this._reloadConfigFile();
        }, 100);
      }
      _reloadConfigFile() {
        this._updateConfigFileWatcher();
        if (this._primaryConfigFileUri) {
          this._console.info(`Reloading configuration file at ${this._primaryConfigFileUri.toUserVisibleString()}`);
          const e = this._backgroundAnalysisProgram.host;
          const t = this._getConfigOptions(e, this._commandLineOptions);
          this._backgroundAnalysisProgram.setConfigOptions(t);
          this.applyConfigOptions(e);
        }
      }
      _clearReanalysisTimer() {
        if (this._analyzeTimer) {
          clearTimeout(this._analyzeTimer);
          this._analyzeTimer = undefined;
        }
      }
      _scheduleReanalysis(e) {
        var t;
        var n;
        if (this._disposed || !((t = this._commandLineOptions) === null || t === undefined ? undefined : t.languageServerSettings.enableAmbientAnalysis)) {
          return;
        }
        if (e) {
          this._requireTrackedFileUpdate = true;
        }
        if ((n = this._backgroundAnalysisCancellationSource) !== null && n !== undefined) {
          n.cancel();
        }
        this._clearReanalysisTimer();
        const a = Date.now() - this._lastUserInteractionTime;
        const r = Math.max(250 - a, 5);
        this._analyzeTimer = setTimeout(() => {
          this._analyzeTimer = undefined;
          if (this._requireTrackedFileUpdate) {
            this._updateTrackedFileList(false);
          }
          this._backgroundAnalysisCancellationSource = this.cancellationProvider.createCancellationTokenSource();
          this.runAnalysis(this._backgroundAnalysisCancellationSource.token);
        }, r);
      }
      _reportConfigParseError() {
        if (this._onCompletionCallback) {
          this._onCompletionCallback({
            diagnostics: [],
            filesInProgram: 0,
            requiringAnalysisCount: {
              files: 0,
              cells: 0
            },
            checkingOnlyOpenFiles: true,
            fatalErrorOccurred: false,
            configParseErrorOccurred: true,
            elapsedTime: 0,
            reason: 'analysis'
          });
        }
      }
    }
    exports.AnalyzerService = D;
  },
  39045: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.findPyprojectTomlFileHereOrUp = function (e, t) {
      return r.forEachAncestorDirectory(t, t => s(e, t));
    };
    exports.findPyprojectTomlFile = s;
    exports.findConfigFileHereOrUp = function (e, t) {
      return r.forEachAncestorDirectory(t, t => i(e, t));
    };
    exports.findConfigFile = i;
    const a = require(4883);
    const r = require(5884);
    function s(e, t) {
      const n = t.resolvePaths(a.pyprojectTomlName);
      if (e.existsSync(n)) {
        return e.realCasePath(n);
      }
    }
    function i(e, t) {
      const n = t.resolvePaths(a.configFileName);
      if (e.existsSync(n)) {
        return e.realCasePath(n);
      }
    }
  },
  53266: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SourceFile = exports.IPythonMode = exports.maxSourceFileSize = undefined;
    const i = require(28167);
    const o = require(91426);
    const l = require(58147);
    const p = require(12522);
    const d = require(25075);
    const c = require(48281);
    const u = require(11479);
    const m = require(65880);
    const y = require(36316);
    const g = require(51862);
    const h = require(54010);
    const f = require(56814);
    const T = require(71745);
    require(23070);
    const v = __importStar(require(89740));
    const b = require(88754);
    const _ = require(95418);
    const C = require(71582);
    const I = require(67703);
    const k = require(85114);
    const w = require(96941);
    const S = require(49969);
    const A = __importStar(require(26687));
    const x = require(15157);
    const P = require(56798);
    const D = __importStar(require(22415));
    const N = require(25454);
    const F = require(22519);
    var E;
    exports.maxSourceFileSize = 52428800;
    (function (e) {
      e[e.None = 0] = 'None';
      e[e.CellDocs = 1] = 'CellDocs';
    })(E || (exports.IPythonMode = E = {}));
    let M = 1;
    class O {
      constructor() {
        this.diagnosticVersion = 0;
        this.fileContentsVersion = 0;
        this.lastFileContentLength = undefined;
        this.lastFileContentHash = undefined;
        this.analyzedFileContentsVersion = -1;
        this.parseTreeNeedsCleaning = false;
        this.isBindingInProgress = false;
        this.parseDiagnostics = [];
        this.commentDiagnostics = [];
        this.bindDiagnostics = [];
        this.checkerDiagnostics = [];
        this.taskListDiagnostics = [];
        this.typeIgnoreLines = new Map();
        this.pyrightIgnoreLines = new Map();
        this.accumulatedDiagnostics = [];
        this.circularDependencies = [];
        this.noCircularDependencyConfirmed = false;
        this.isBindingNeeded = true;
        this.isCheckingNeeded = true;
        this.isFileDeleted = false;
      }
      debugPrint() {
        var e;
        var t;
        var n;
        var a;
        var r;
        var s;
        var i;
        var o;
        var l;
        var p;
        var d;
        var c;
        var u;
        return `WritableData: \n diagnosticVersion=${this.diagnosticVersion}, \n noCircularDependencyConfirmed=${this.noCircularDependencyConfirmed}, \n isBindingNeeded=${this.isBindingNeeded},\n isBindingInProgress=${this.isBindingInProgress},\n isCheckingNeeded=${this.isCheckingNeeded},\n isFileDeleted=${this.isFileDeleted},\n hitMaxImportDepth=${this.hitMaxImportDepth},\n parseTreeNeedsCleaning=${this.parseTreeNeedsCleaning},\n fileContentsVersion=${this.fileContentsVersion},\n analyzedFileContentsVersion=${this.analyzedFileContentsVersion},\n clientDocumentVersion=${this.clientDocumentVersion},\n lastFileContentLength=${this.lastFileContentLength},\n lastFileContentHash=${this.lastFileContentHash},\n typeIgnoreAll=${this.typeIgnoreAll},\n imports=${(e = this.imports) === null || e === undefined ? undefined : e.length},\n builtinsImport=${(t = this.builtinsImport) === null || t === undefined ? undefined : t.importName},\n circularDependencies=${(n = this.circularDependencies) === null || n === undefined ? undefined : n.length},\n parseDiagnostics=${(a = this.parseDiagnostics) === null || a === undefined ? undefined : a.length},\n commentDiagnostics=${(r = this.commentDiagnostics) === null || r === undefined ? undefined : r.length},\n bindDiagnostics=${(s = this.bindDiagnostics) === null || s === undefined ? undefined : s.length},\n checkerDiagnostics=${(i = this.checkerDiagnostics) === null || i === undefined ? undefined : i.length},\n taskListDiagnostics=${(o = this.taskListDiagnostics) === null || o === undefined ? undefined : o.length},\n accumulatedDiagnostics=${(l = this.accumulatedDiagnostics) === null || l === undefined ? undefined : l.length},\n typeIgnoreLines=${(p = this.typeIgnoreLines) === null || p === undefined ? undefined : p.size},\n pyrightIgnoreLines=${(d = this.pyrightIgnoreLines) === null || d === undefined ? undefined : d.size},\n checkTime=${this.checkTime},\n clientDocumentContents=${(c = this.clientDocumentContents) === null || c === undefined ? undefined : c.length},\n parseResults=${(u = this.parserOutput) === null || u === undefined ? undefined : u.parseTree.length}`;
      }
    }
    exports.SourceFile = class {
      constructor(e, t, n, a, r, s, o, l, c) {
        this.serviceProvider = e;
        this._diagnosticRuleSet = p.getBasicDiagnosticRuleSet();
        this._ipythonMode = E.None;
        this.fileSystem = e.get(T.ServiceKeys.fs);
        this._console = o || new d.StandardConsole();
        this._writableData = new O();
        this._editMode = s;
        this._uri = t;
        this._fileId = this._makeFileId(t);
        this._moduleName = n;
        this._isStubFile = t.hasExtension('.pyi');
        this._isThirdPartyImport = a;
        this._isThirdPartyPyTypedPresent = r;
        const u = t.fileName;
        this._isTypingStubFile = this._isStubFile && (this._uri.pathEndsWith('stdlib/typing.pyi') || u === 'typing_extensions.pyi');
        this._isTypingExtensionsStubFile = this._isStubFile && u === 'typing_extensions.pyi';
        this._isTypeshedStubFile = this._isStubFile && this._uri.pathEndsWith('stdlib/_typeshed/__init__.pyi');
        this._isBuiltInStubFile = false;
        if (this._isStubFile && (this._uri.pathEndsWith('stdlib/collections/__init__.pyi') || this._uri.pathEndsWith('stdlib/asyncio/futures.pyi') || this._uri.pathEndsWith('stdlib/asyncio/tasks.pyi') || this._uri.pathEndsWith('stdlib/builtins.pyi') || this._uri.pathEndsWith('stdlib/_importlib_modulespec.pyi') || this._uri.pathEndsWith('stdlib/dataclasses.pyi') || this._uri.pathEndsWith('stdlib/abc.pyi') || this._uri.pathEndsWith('stdlib/enum.pyi') || this._uri.pathEndsWith('stdlib/queue.pyi') || this._uri.pathEndsWith('stdlib/types.pyi') || this._uri.pathEndsWith('stdlib/warnings.pyi'))) {
          this._isBuiltInStubFile = true;
        }
        this._logTracker = l ?? new g.LogTracker(o, i.isMainThread ? 'FG' : 'BG');
        this._ipythonMode = c ?? E.None;
      }
      getIPythonMode() {
        return this._ipythonMode;
      }
      getUri() {
        return this._uri;
      }
      getModuleName() {
        if (this._moduleName) {
          return this._moduleName;
        } else {
          return h.stripFileExtension(this._uri.fileName);
        }
      }
      setModuleName(e) {
        this._moduleName = e;
      }
      getDiagnosticVersion() {
        return this._writableData.diagnosticVersion;
      }
      isStubFile() {
        return this._isStubFile;
      }
      isTypingStubFile() {
        return this._isTypingStubFile;
      }
      isThirdPartyPyTypedPresent() {
        return this._isThirdPartyPyTypedPresent;
      }
      getDiagnostics(e, t) {
        if (this._writableData.diagnosticVersion !== t) {
          return this._writableData.accumulatedDiagnostics;
        }
      }
      getImports() {
        return this._writableData.imports || [];
      }
      getBuiltinsImport() {
        return this._writableData.builtinsImport;
      }
      getModuleSymbolTable() {
        return this._writableData.moduleSymbolTable;
      }
      getCheckTime() {
        return this._writableData.checkTime;
      }
      restore() {
        if (this._preEditData) {
          const e = this._writableData.clientDocumentContents;
          this._writableData = this._preEditData;
          this._preEditData = undefined;
          return e;
        }
      }
      didContentsChangeOnDisk() {
        if (this._writableData.clientDocumentContents) {
          return false;
        }
        if (this._writableData.lastFileContentLength === undefined) {
          return false;
        }
        try {
          if (!this.fileSystem.existsSync(this._uri)) {
            return true;
          }
          {
            const e = this.fileSystem.readFileSync(this._uri, 'utf8');
            if (e.length !== this._writableData.lastFileContentLength) {
              return true;
            }
            if (v.hashString(e) !== this._writableData.lastFileContentHash) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
        return false;
      }
      dropParseAndBindInfo() {
        this._fireFileDirtyEvent();
        this._writableData.parserOutput = undefined;
        this._writableData.tokenizerLines = undefined;
        this._writableData.tokenizerOutput = undefined;
        this._writableData.parsedFileContents = undefined;
        this._writableData.moduleSymbolTable = undefined;
        this._writableData.isBindingNeeded = true;
      }
      markDirty() {
        this._writableData.fileContentsVersion++;
        this._writableData.noCircularDependencyConfirmed = false;
        this._writableData.isCheckingNeeded = true;
        this._writableData.isBindingNeeded = true;
        this._writableData.moduleSymbolTable = undefined;
        this._fireFileDirtyEvent();
      }
      markReanalysisRequired(e) {
        this._writableData.isCheckingNeeded = true;
        this._writableData.noCircularDependencyConfirmed = false;
        if (this._writableData.parserOutput && (this._writableData.parserOutput.containsWildcardImport || A.getDunderAllInfo(this._writableData.parserOutput.parseTree) !== undefined || e)) {
          this._writableData.parseTreeNeedsCleaning = true;
          this._writableData.isBindingNeeded = true;
          this._writableData.moduleSymbolTable = undefined;
        }
      }
      getFileContentsVersion() {
        return this._writableData.fileContentsVersion;
      }
      getClientVersion() {
        return this._writableData.clientDocumentVersion;
      }
      getOpenFileContents() {
        return this._writableData.clientDocumentContents;
      }
      getFileContent() {
        const e = this.getOpenFileContents();
        if (e !== undefined) {
          return e;
        }
        try {
          const e = this.fileSystem.statSync(this._uri);
          if (e.size > exports.maxSourceFileSize) {
            this._console.error(`File length of "${this._uri}" is ${e.size} which exceeds the maximum supported file size of ${exports.maxSourceFileSize}`);
            throw new Error('File larger than max');
          }
          return this.fileSystem.readFileSync(this._uri, 'utf8');
        } catch (e) {
          return;
        }
      }
      setClientVersion(e, t) {
        this._cachePreEditState();
        if (e === null) {
          this._writableData.clientDocumentVersion = undefined;
          this._writableData.clientDocumentContents = undefined;
          this._writableData.tokenizerOutput = undefined;
        } else {
          this._writableData.clientDocumentVersion = e;
          this._writableData.clientDocumentContents = t;
          const n = v.hashString(t);
          if (t.length !== this._writableData.lastFileContentLength || n !== this._writableData.lastFileContentHash) {
            this.markDirty();
          }
          this._writableData.lastFileContentLength = t.length;
          this._writableData.lastFileContentHash = n;
          this._writableData.isFileDeleted = false;
        }
      }
      prepareForClose() {
        this._fireFileDirtyEvent();
      }
      isFileDeleted() {
        return this._writableData.isFileDeleted;
      }
      isParseRequired() {
        return !this._writableData.parserOutput || this._writableData.analyzedFileContentsVersion !== this._writableData.fileContentsVersion;
      }
      isBindingRequired() {
        return !this._writableData.isBindingInProgress && (!!this.isParseRequired() || this._writableData.isBindingNeeded);
      }
      isCheckingRequired() {
        return this._writableData.isCheckingNeeded;
      }
      getParseResults() {
        var e;
        if (this.isParseRequired()) {
          return;
        }
        c.assert(this._writableData.parserOutput !== undefined && this._writableData.parsedFileContents !== undefined);
        const t = (e = this._writableData.tokenizerOutput) !== null && e !== undefined ? e : this._tokenizeContents(this._writableData.parsedFileContents);
        return {
          parserOutput: this._writableData.parserOutput,
          tokenizerOutput: t,
          text: this._writableData.parsedFileContents
        };
      }
      getParserOutput() {
        if (!this.isParseRequired()) {
          c.assert(this._writableData.parserOutput !== undefined);
          return this._writableData.parserOutput;
        }
      }
      addCircularDependency(e, t) {
        let n = false;
        if (this._writableData.circularDependencies.length < 4) {
          if (!this._writableData.circularDependencies.some(e => e.isEqual(t))) {
            this._writableData.circularDependencies.push(t);
            n = true;
          }
        }
        if (n) {
          this._recomputeDiagnostics(e);
        }
      }
      setNoCircularDependencyConfirmed() {
        this._writableData.noCircularDependencyConfirmed = true;
      }
      isNoCircularDependencyConfirmed() {
        return !this.isParseRequired() && this._writableData.noCircularDependencyConfirmed;
      }
      setHitMaxImportDepth(e) {
        this._writableData.hitMaxImportDepth = e;
      }
      parse(e, t, n) {
        return this._logTracker.log(`parsing: ${this._getPathForLogging(this._uri)}`, a => {
          if (!this.isParseRequired()) {
            a.suppress();
            return false;
          }
          const r = this.createDiagnosticSink();
          let s = this.getOpenFileContents();
          if (s === undefined) {
            try {
              const e = C.timingStats.readFileTime.totalTime;
              C.timingStats.readFileTime.timeOperation(() => {
                s = n ?? this.getFileContent();
                if (s === undefined) {
                  throw new Error('Can\'t get file content');
                }
                this._writableData.lastFileContentLength = s.length;
                this._writableData.lastFileContentHash = v.hashString(s);
              });
              a.add(`fs read ${C.timingStats.readFileTime.totalTime - e}ms`);
            } catch (e) {
              r.addError('Source file could not be read', b.getEmptyRange());
              s = '';
              if (!this.fileSystem.existsSync(this._uri)) {
                this._writableData.isFileDeleted = true;
              }
            }
          }
          try {
            const n = this._parseFile(e, this._uri, s, this._ipythonMode, r);
            c.assert(n !== undefined && n.tokenizerOutput !== undefined);
            this._writableData.parserOutput = n.parserOutput;
            this._writableData.tokenizerLines = n.tokenizerOutput.lines;
            this._writableData.parsedFileContents = s;
            this._writableData.typeIgnoreLines = n.tokenizerOutput.typeIgnoreLines;
            this._writableData.typeIgnoreAll = n.tokenizerOutput.typeIgnoreAll;
            this._writableData.pyrightIgnoreLines = n.tokenizerOutput.pyrightIgnoreLines;
            if (this._writableData.clientDocumentContents !== undefined) {
              this._writableData.tokenizerOutput = n.tokenizerOutput;
            }
            const a = e.findExecEnvironment(this._uri);
            C.timingStats.resolveImportsTime.timeOperation(() => {
              const s = this._resolveImports(t, n.parserOutput.importedModules, a);
              this._writableData.imports = s.imports;
              this._writableData.builtinsImport = s.builtinsImportResult;
              this._writableData.parseDiagnostics = r.fetchAndClear();
              this._writableData.taskListDiagnostics = [];
              this._addTaskListDiagnostics(e.taskListTokens, n.tokenizerOutput, this._writableData.taskListDiagnostics);
            });
            const i = e.strict.find(e => this._uri.matchesRegex(e.regExp)) !== undefined;
            const o = [];
            this._diagnosticRuleSet = D.getFileLevelDirectives(n.tokenizerOutput.tokens, n.tokenizerOutput.lines, a.diagnosticRuleSet, i, o);
            this._writableData.commentDiagnostics = [];
            o.forEach(e => {
              this._writableData.commentDiagnostics.push(new u.Diagnostic(0, e.message, f.convertTextRangeToRange(e.range, n.tokenizerOutput.lines)));
            });
          } catch (e) {
            const t = (e.stack ? e.stack.toString() : undefined) || (typeof e.message == 'string' ? e.message : undefined) || JSON.stringify(e);
            this._console.error(I.LocMessage.internalParseError().format({
              file: this.getUri().toUserVisibleString(),
              message: t
            }));
            this._writableData.parsedFileContents = '';
            this._writableData.parserOutput = {
              parseTree: k.ModuleNode.create({
                start: 0,
                length: 0
              }),
              importedModules: [],
              futureImports: new Set(),
              containsWildcardImport: false,
              typingSymbolAliases: new Map()
            };
            this._writableData.tokenizerLines = new _.TextRangeCollection([]);
            this._writableData.tokenizerOutput = {
              tokens: new _.TextRangeCollection([]),
              lines: this._writableData.tokenizerLines,
              typeIgnoreAll: undefined,
              typeIgnoreLines: new Map(),
              pyrightIgnoreLines: new Map(),
              predominantEndOfLineSequence: '\n',
              hasPredominantTabSequence: false,
              predominantTabSequence: '    ',
              predominantSingleQuoteCharacter: '\''
            };
            this._writableData.imports = undefined;
            this._writableData.builtinsImport = undefined;
            const n = this.createDiagnosticSink();
            n.addError(I.LocMessage.internalParseError().format({
              file: this.getUri().toUserVisibleString(),
              message: t
            }), b.getEmptyRange());
            this._writableData.parseDiagnostics = n.fetchAndClear();
            this._writableData.taskListDiagnostics = n.fetchAndClear();
          }
          this._writableData.analyzedFileContentsVersion = this._writableData.fileContentsVersion;
          this._writableData.isBindingNeeded = true;
          this._writableData.isCheckingNeeded = true;
          this._writableData.parseTreeNeedsCleaning = false;
          this._writableData.hitMaxImportDepth = undefined;
          this._recomputeDiagnostics(e);
          return true;
        });
      }
      bind(e, t, n, a) {
        c.assert(!this.isParseRequired(), 'Bind called before parsing');
        c.assert(this.isBindingRequired(), 'Bind called unnecessarily');
        c.assert(!this._writableData.isBindingInProgress, 'Bind called while binding in progress');
        c.assert(this._writableData.parserOutput !== undefined, 'Parse results not available');
        return this._logTracker.log(`binding: ${this._getPathForLogging(this._uri)}`, () => {
          try {
            C.timingStats.bindTime.timeOperation(() => {
              this._cleanParseTreeIfRequired();
              const r = this._buildFileInfo(e, this._writableData.parsedFileContents, t, n, a);
              A.setFileInfo(this._writableData.parserOutput.parseTree, r);
              const s = new x.Binder(r, e.indexGenerationMode);
              this._writableData.isBindingInProgress = true;
              s.bindModule(this._writableData.parserOutput.parseTree);
              if (e.internalTestMode) {
                new F.TestWalker().walk(this._writableData.parserOutput.parseTree);
              }
              this._writableData.bindDiagnostics = r.diagnosticSink.fetchAndClear();
              const i = A.getScope(this._writableData.parserOutput.parseTree);
              c.assert(i !== undefined, 'Module scope not returned by binder');
              this._writableData.moduleSymbolTable = i.symbolTable;
            });
          } catch (e) {
            const t = (e.stack ? e.stack.toString() : undefined) || (typeof e.message == 'string' ? e.message : undefined) || JSON.stringify(e);
            this._console.error(I.LocMessage.internalBindError().format({
              file: this.getUri().toUserVisibleString(),
              message: t
            }));
            const n = this.createDiagnosticSink();
            n.addError(I.LocMessage.internalBindError().format({
              file: this.getUri().toUserVisibleString(),
              message: t
            }), b.getEmptyRange());
            this._writableData.bindDiagnostics = n.fetchAndClear();
          } finally {
            this._writableData.isBindingInProgress = false;
          }
          this._writableData.isCheckingNeeded = true;
          this._writableData.isBindingNeeded = false;
          this._recomputeDiagnostics(e);
        });
      }
      check(e, t, n, a, r) {
        c.assert(!this.isParseRequired(), `Check called before parsing: state=${this._writableData.debugPrint()}`);
        c.assert(!this.isBindingRequired(), `Check called before binding: state=${this._writableData.debugPrint()}`);
        c.assert(!this._writableData.isBindingInProgress, 'Check called while binding in progress');
        c.assert(this.isCheckingRequired(), 'Check called unnecessarily');
        c.assert(this._writableData.parserOutput !== undefined, 'Parse results not available');
        return this._logTracker.log(`checking: ${this._getPathForLogging(this._uri)}`, () => {
          try {
            C.timingStats.typeCheckerTime.timeOperation(() => {
              const e = new C.Duration();
              new P.Checker(t, n, this._writableData.parserOutput, a, r).check();
              this._writableData.isCheckingNeeded = false;
              const s = A.getFileInfo(this._writableData.parserOutput.parseTree);
              this._writableData.checkerDiagnostics = s.diagnosticSink.fetchAndClear();
              this._writableData.checkTime = e.getDurationInMilliseconds();
            });
          } catch (e) {
            if (!o.OperationCanceledException.is(e)) {
              const t = (e.stack ? e.stack.toString() : undefined) || (typeof e.message == 'string' ? e.message : undefined) || JSON.stringify(e);
              this._console.error(I.LocMessage.internalTypeCheckingError().format({
                file: this.getUri().toUserVisibleString(),
                message: t
              }));
              const n = this.createDiagnosticSink();
              n.addError(I.LocMessage.internalTypeCheckingError().format({
                file: this.getUri().toUserVisibleString(),
                message: t
              }), b.getEmptyRange());
              this._writableData.checkerDiagnostics = n.fetchAndClear();
              this._writableData.isCheckingNeeded = false;
            }
            throw e;
          } finally {
            this._writableData.circularDependencies = [];
            this._recomputeDiagnostics(e);
          }
        });
      }
      test_enableIPythonMode(e) {
        this._ipythonMode = e ? E.CellDocs : E.None;
      }
      createDiagnosticSink() {
        return new y.DiagnosticSink();
      }
      createTextRangeDiagnosticSink(e) {
        return new y.TextRangeDiagnosticSink(e);
      }
      _makeFileId(e) {
        let t = e.fileNameWithoutExtensions;
        if (t.length > 8) {
          t = t.substring(t.length - 8);
        }
        return `${t}/${(M++).toString()}`;
      }
      _recomputeDiagnostics(e) {
        this._writableData.diagnosticVersion++;
        let t = true;
        if (this._isThirdPartyImport) {
          t = false;
        }
        let n = [];
        l.appendArray(n, this._writableData.parseDiagnostics);
        l.appendArray(n, this._writableData.commentDiagnostics);
        l.appendArray(n, this._writableData.bindDiagnostics);
        l.appendArray(n, this._writableData.checkerDiagnostics);
        l.appendArray(n, this._writableData.taskListDiagnostics);
        const a = n;
        const r = new Map(this._writableData.typeIgnoreLines);
        const s = new Map(this._writableData.pyrightIgnoreLines);
        if (this._diagnosticRuleSet.enableTypeIgnoreComments && this._writableData.typeIgnoreLines.size > 0) {
          n = n.filter(e => {
            if (e.category !== 3 && e.category !== 4 && e.category !== 5) {
              for (let t = e.range.start.line; t <= e.range.end.line; t++) {
                if (this._writableData.typeIgnoreLines.has(t)) {
                  r.delete(t);
                  return false;
                }
              }
            }
            return true;
          });
        }
        if (this._writableData.pyrightIgnoreLines.size > 0) {
          n = n.filter(e => {
            if (e.category !== 3 && e.category !== 4 && e.category !== 5) {
              for (let t = e.range.start.line; t <= e.range.end.line; t++) {
                const n = this._writableData.pyrightIgnoreLines.get(t);
                if (n) {
                  if (!n.rulesList) {
                    s.delete(t);
                    return false;
                  }
                  const a = e.getRule();
                  if (!a) {
                    return true;
                  }
                  if (n.rulesList.find(e => e.text === a)) {
                    const e = s.get(t);
                    if (e == null ? undefined : e.rulesList) {
                      const n = e.rulesList.filter(e => e.text !== a);
                      if (n.length === 0) {
                        s.delete(t);
                      } else {
                        s.set(t, {
                          range: e.range,
                          rulesList: n
                        });
                      }
                    }
                    return false;
                  }
                  return true;
                }
              }
            }
            return true;
          });
        }
        const i = [];
        if (this._diagnosticRuleSet.reportUnnecessaryTypeIgnoreComment !== 'none' && !this._writableData.isCheckingNeeded) {
          const e = u.convertLevelToCategory(this._diagnosticRuleSet.reportUnnecessaryTypeIgnoreComment);
          const t = a.filter(e => e.category === 0 || e.category === 1 || e.category === 2);
          const n = e => a.find(t => t.category === 4 && t.range.start.line <= e.start.line && t.range.end.line >= e.end.line);
          if (t.length === 0 && this._writableData.typeIgnoreAll !== undefined) {
            const t = this._writableData.typeIgnoreAll.range.start;
            const a = t + this._writableData.typeIgnoreAll.range.length;
            const r = f.convertOffsetsToRange(t, a, this._writableData.tokenizerLines);
            if (!n(r) && this._diagnosticRuleSet.enableTypeIgnoreComments) {
              const t = new u.Diagnostic(e, I.LocMessage.unnecessaryTypeIgnore(), r);
              t.setRule(m.DiagnosticRule.reportUnnecessaryTypeIgnoreComment);
              i.push(t);
            }
          }
          r.forEach(t => {
            if (this._writableData.tokenizerLines) {
              const a = t.range.start;
              const r = a + t.range.length;
              const s = f.convertOffsetsToRange(a, r, this._writableData.tokenizerLines);
              if (!n(s) && this._diagnosticRuleSet.enableTypeIgnoreComments) {
                const t = new u.Diagnostic(e, I.LocMessage.unnecessaryTypeIgnore(), s);
                t.setRule(m.DiagnosticRule.reportUnnecessaryTypeIgnoreComment);
                i.push(t);
              }
            }
          });
          s.forEach(t => {
            if (this._writableData.tokenizerLines) {
              if (t.rulesList) {
                t.rulesList.forEach(t => {
                  const a = t.range.start;
                  const r = a + t.range.length;
                  const s = f.convertOffsetsToRange(a, r, this._writableData.tokenizerLines);
                  if (!n(s)) {
                    const n = new u.Diagnostic(e, I.LocMessage.unnecessaryPyrightIgnoreRule().format({
                      name: t.text
                    }), s);
                    n.setRule(m.DiagnosticRule.reportUnnecessaryTypeIgnoreComment);
                    i.push(n);
                  }
                });
              } else {
                const a = t.range.start;
                const r = a + t.range.length;
                const s = f.convertOffsetsToRange(a, r, this._writableData.tokenizerLines);
                if (!n(s)) {
                  const t = new u.Diagnostic(e, I.LocMessage.unnecessaryTypeIgnore(), s);
                  t.setRule(m.DiagnosticRule.reportUnnecessaryTypeIgnoreComment);
                  i.push(t);
                }
              }
            }
          });
        }
        if (this._diagnosticRuleSet.reportImportCycles !== 'none' && this._writableData.circularDependencies.length > 0) {
          const e = u.convertLevelToCategory(this._diagnosticRuleSet.reportImportCycles);
          this._writableData.circularDependencies.forEach(t => {
            const a = new u.Diagnostic(e, I.LocMessage.importCycleDetected() + '\n' + t.getPaths().map(e => `  ${e.toUserVisibleString()}`).join('\n'), b.getEmptyRange());
            a.setRule(m.DiagnosticRule.reportImportCycles);
            n.push(a);
          });
        }
        if (this._writableData.hitMaxImportDepth !== undefined) {
          n.push(new u.Diagnostic(0, I.LocMessage.importDepthExceeded().format({
            depth: this._writableData.hitMaxImportDepth
          }), b.getEmptyRange()));
        }
        if (this._diagnosticRuleSet.enableTypeIgnoreComments && this._writableData.typeIgnoreAll !== undefined) {
          n = n.filter(e => e.category !== 0 && e.category !== 1 && e.category !== 2);
        }
        n = n.concat(i);
        if (!t) {
          n = n.filter(e => e.category === 3 || e.category === 4 || e.category === 5);
        }
        if (e.ignore.find(e => this._uri.matchesRegex(e.regExp))) {
          n = [];
        }
        this._writableData.accumulatedDiagnostics = n;
      }
      _cachePreEditState() {
        if (this._editMode.isEditMode && !this._preEditData) {
          this._preEditData = this._writableData;
          this._writableData = new O();
        }
      }
      _addTaskListDiagnostics(e, t, n) {
        if (e && e.length !== 0 && n) {
          for (let a = 0; a < t.tokens.count; a++) {
            const r = t.tokens.getItemAt(a);
            if (r.comments && r.comments.length !== 0) {
              for (const a of r.comments) {
                for (const r of e) {
                  const e = `^[\\s]*${r.text}([\\s]*\$|[\\W]+)`;
                  if (!RegExp(e, 'i').test(a.value)) {
                    continue;
                  }
                  let s = a.start;
                  s += a.value.toLowerCase().indexOf(r.text.toLowerCase());
                  const i = b.TextRange.getEnd(a);
                  const o = f.convertOffsetsToRange(s, i, t.lines);
                  n.push(new u.Diagnostic(6, a.value.trim(), o, r.priority));
                }
              }
            }
          }
        }
      }
      _buildFileInfo(e, t, n, a, r) {
        c.assert(this._writableData.parserOutput !== undefined, 'Parse results not available');
        return {
          importLookup: n,
          futureImports: r,
          builtinsScope: a,
          diagnosticSink: this.createTextRangeDiagnosticSink(this._writableData.tokenizerLines),
          executionEnvironment: e.findExecEnvironment(this._uri),
          diagnosticRuleSet: this._diagnosticRuleSet,
          lines: this._writableData.tokenizerLines,
          typingSymbolAliases: this._writableData.parserOutput.typingSymbolAliases,
          definedConstants: e.defineConstant,
          fileId: this._fileId,
          fileUri: this._uri,
          moduleName: this.getModuleName(),
          isStubFile: this._isStubFile,
          isTypingStubFile: this._isTypingStubFile,
          isTypingExtensionsStubFile: this._isTypingExtensionsStubFile,
          isTypeshedStubFile: this._isTypeshedStubFile,
          isBuiltInStubFile: this._isBuiltInStubFile,
          isInPyTypedPackage: this._isThirdPartyPyTypedPresent,
          ipythonMode: this._ipythonMode,
          accessedSymbolSet: new Set()
        };
      }
      _cleanParseTreeIfRequired() {
        if (this._writableData.parserOutput && this._writableData.parseTreeNeedsCleaning) {
          new N.ParseTreeCleanerWalker(this._writableData.parserOutput.parseTree).clean();
          this._writableData.parseTreeNeedsCleaning = false;
        }
      }
      _resolveImports(e, t, n) {
        const a = [];
        const r = (t, r = false) => {
          const s = e.resolveImport(this._uri, n, {
            leadingDots: 0,
            nameParts: t,
            importedSymbols: undefined
          });
          if (!r || s.isImportFound) {
            if (s.resolvedUris.length === 0 || s.resolvedUris[0] !== this._uri) {
              a.push(s);
              return s;
            } else {
              return undefined;
            }
          }
        };
        let s;
        if (!this._isThirdPartyImport && !this._isStubFile) {
          s = r(['__builtins__'], true);
        }
        if (!s) {
          s = r(['builtins']);
        }
        for (const r of t) {
          const t = e.resolveImport(this._uri, n, {
            leadingDots: r.leadingDots,
            nameParts: r.nameParts,
            importedSymbols: r.importedSymbols
          });
          a.push(t);
          if (r.nameParts.length === r.nameNode.d.nameParts.length) {
            A.setImportInfo(r.nameNode, t);
          } else {
            c.assert(r.nameParts.length > 0);
            c.assert(r.nameParts.length - 1 < r.nameNode.d.nameParts.length);
            A.setImportInfo(r.nameNode.d.nameParts[r.nameParts.length - 1], t);
          }
        }
        return {
          imports: a,
          builtinsImportResult: s
        };
      }
      _getPathForLogging(e) {
        return g.getPathForLogging(this.fileSystem, e);
      }
      _parseFile(e, t, n, a, r) {
        var s;
        const i = e.findExecEnvironment(t);
        const o = new w.ParseOptions();
        o.ipythonMode = a;
        if (t.pathEndsWith('pyi')) {
          o.isStubFile = true;
        }
        o.pythonVersion = i.pythonVersion;
        o.skipFunctionAndClassBody = (s = e.indexGenerationMode) !== null && s !== undefined && s;
        return new w.Parser().parseSourceFile(n, o, r);
      }
      _tokenizeContents(e) {
        const t = new S.Tokenizer().tokenize(e);
        if (this._writableData.clientDocumentContents !== undefined) {
          this._writableData.tokenizerOutput = t;
          this._writableData.tokenizerLines = t.lines;
        }
        return t;
      }
      _fireFileDirtyEvent() {
        var e;
        if ((e = this.serviceProvider.tryGet(T.ServiceKeys.stateMutationListeners)) !== null && e !== undefined) {
          e.forEach(e => {
            var t;
            try {
              if ((t = e.onFileDirty) !== null && t !== undefined) {
                t.call(e, this._uri);
              }
            } catch (e) {
              const t = this.serviceProvider.tryGet(T.ServiceKeys.console);
              if (t) {
                t.error(`State mutation listener exception: ${e.message}`);
              }
            }
          });
        }
      }
    };
  },
  67238: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SourceFileInfo = undefined;
    exports.SourceFileInfo = class {
      constructor(e, t, n, a, r, s = {}) {
        this.sourceFile = e;
        this.isTypeshedFile = t;
        this.isThirdPartyImport = n;
        this.isThirdPartyPyTypedPresent = a;
        this._editModeTracker = r;
        this.isCreatedInEditMode = this._editModeTracker.isEditMode;
        this._writableData = this._createWriteableData(s);
        this._cachePreEditState();
      }
      get diagnosticsVersion() {
        return this._writableData.diagnosticsVersion;
      }
      get builtinsImport() {
        return this._writableData.builtinsImport;
      }
      get chainedSourceFile() {
        return this._writableData.chainedSourceFile;
      }
      get effectiveFutureImports() {
        return this._writableData.effectiveFutureImports;
      }
      get isTracked() {
        return this._writableData.isTracked;
      }
      get isOpenByClient() {
        return this._writableData.isOpenByClient;
      }
      get imports() {
        return this._writableData.imports;
      }
      get importedBy() {
        return this._writableData.importedBy;
      }
      get shadows() {
        return this._writableData.shadows;
      }
      get shadowedBy() {
        return this._writableData.shadowedBy;
      }
      set diagnosticsVersion(e) {
        this._cachePreEditState();
        this._writableData.diagnosticsVersion = e;
      }
      set builtinsImport(e) {
        this._cachePreEditState();
        this._writableData.builtinsImport = e;
      }
      set chainedSourceFile(e) {
        this._cachePreEditState();
        this._writableData.chainedSourceFile = e;
      }
      set effectiveFutureImports(e) {
        this._cachePreEditState();
        this._writableData.effectiveFutureImports = e;
      }
      set isTracked(e) {
        this._cachePreEditState();
        this._writableData.isTracked = e;
      }
      set isOpenByClient(e) {
        this._cachePreEditState();
        this._writableData.isOpenByClient = e;
      }
      mutate(e) {
        this._cachePreEditState();
        e(this._writableData);
      }
      restore() {
        if (this._preEditData) {
          this._writableData = this._preEditData;
          this._preEditData = undefined;
          this.sourceFile.dropParseAndBindInfo();
        }
        return this.sourceFile.restore();
      }
      _cachePreEditState() {
        if (this._editModeTracker.isEditMode && !this._preEditData) {
          this._preEditData = this._writableData;
          this._writableData = this._cloneWriteableData(this._writableData);
          this._editModeTracker.addMutatedFiles(this);
        }
      }
      _createWriteableData(e) {
        var t;
        var n;
        return {
          isTracked: (t = e.isTracked) !== null && t !== undefined && t,
          isOpenByClient: (n = e.isOpenByClient) !== null && n !== undefined && n,
          builtinsImport: e.builtinsImport,
          chainedSourceFile: e.chainedSourceFile,
          diagnosticsVersion: e.diagnosticsVersion,
          effectiveFutureImports: e.effectiveFutureImports,
          imports: [],
          importedBy: [],
          shadows: [],
          shadowedBy: []
        };
      }
      _cloneWriteableData(e) {
        return {
          isTracked: e.isTracked,
          isOpenByClient: e.isOpenByClient,
          builtinsImport: e.builtinsImport,
          chainedSourceFile: e.chainedSourceFile,
          diagnosticsVersion: e.diagnosticsVersion,
          effectiveFutureImports: e.effectiveFutureImports,
          imports: e.imports.slice(),
          importedBy: e.importedBy.slice(),
          shadows: e.shadows.slice(),
          shadowedBy: e.shadowedBy.slice()
        };
      }
    };
  },
  3433: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.isUserCode = function (e) {
      return !!e && e.isTracked && !e.isThirdPartyImport && !e.isTypeshedFile;
    };
    exports.collectImportedByCells = function (e, t) {
      (function (e) {
        for (const t of e.getSourceFileInfoList()) {
          if (t.sourceFile.getIPythonMode() === s.IPythonMode.CellDocs) {
            e.getParserOutput(t.sourceFile.getUri());
            e.handleMemoryHighUsage();
          }
        }
      })(e);
      const n = new Set();
      i(t, n);
      return n;
    };
    exports.verifyNoCyclesInChainedFiles = function (e, t) {
      var n;
      var s;
      let i = t.chainedSourceFile;
      if (!i) {
        return;
      }
      const o = new Set([t.sourceFile.getUri().key]);
      while (i) {
        const t = i.sourceFile.getUri().key;
        if (o.has(t)) {
          a.fail((s = (n = e.serviceProvider.tryGet(r.ServiceKeys.debugInfoInspector)) === null || n === undefined ? undefined : n.getCycleDetail(e, i)) !== null && s !== undefined ? s : `Found a cycle in implicit imports files for ${t}`);
        }
        o.add(t);
        i = i.chainedSourceFile;
      }
    };
    exports.createChainedByList = function (e, t) {
      var n;
      var s;
      const i = new Map();
      for (const t of e.getSourceFileInfoList()) {
        if (t.chainedSourceFile) {
          i.set(t.chainedSourceFile, t);
        }
      }
      const o = new Set();
      const l = [t];
      let p = t;
      while (p) {
        if (o.has(p)) {
          a.fail((s = (n = e.serviceProvider.tryGet(r.ServiceKeys.debugInfoInspector)) === null || n === undefined ? undefined : n.getCycleDetail(e, p)) !== null && s !== undefined ? s : 'detected a cycle in chained files');
        }
        o.add(p);
        p = i.get(p);
        if (p) {
          l.push(p);
        }
      }
      return l;
    };
    const a = require(48281);
    const r = require(71745);
    const s = require(53266);
    function i(e, t) {
      e.importedBy.forEach(e => {
        if (!t.has(e)) {
          t.add(e);
          i(e, t);
        }
      });
    }
  },
  3113: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SourceMapper = undefined;
    exports.isStubFile = h;
    const i = __importStar(require(26687));
    const o = __importStar(require(41557));
    const l = require(58147);
    const p = require(34455);
    const d = require(48281);
    const c = require(28445);
    const u = require(3433);
    const m = require(15132);
    const y = require(92324);
    const g = require(21024);
    function h(e) {
      return e.lastExtension === '.pyi';
    }
    exports.SourceMapper = class {
      constructor(e, t, n, a, r, s, i, o, l) {
        this._importResolver = e;
        this._execEnv = t;
        this._evaluator = n;
        this._fileBinder = a;
        this._boundSourceGetter = r;
        this._mapCompiled = s;
        this._preferStubs = i;
        this._fromFile = o;
        this._cancelToken = l;
      }
      findModules(e) {
        var t;
        return (this._isStubThatShouldBeMappedToImplementation(e) ? this._getBoundSourceFilesFromStubFile(e) : [(t = this._boundSourceGetter(e)) === null || t === undefined ? undefined : t.sourceFile]).filter(p.isDefined).map(e => {
          var t;
          if ((t = e.getParserOutput()) === null || t === undefined) {
            return undefined;
          } else {
            return t.parseTree;
          }
        }).filter(p.isDefined);
      }
      getModuleNode(e) {
        var t;
        var n;
        if ((n = (t = this._boundSourceGetter(e)) === null || t === undefined ? undefined : t.sourceFile.getParserOutput()) === null || n === undefined) {
          return undefined;
        } else {
          return n.parseTree;
        }
      }
      findDeclarations(e) {
        if (c.isClassDeclaration(e)) {
          return this._findClassOrTypeAliasDeclarations(e);
        } else {
          if (c.isFunctionDeclaration(e)) {
            return this._findFunctionOrTypeAliasDeclarations(e);
          } else {
            if (c.isVariableDeclaration(e)) {
              return this._findVariableDeclarations(e);
            } else {
              if (c.isParamDeclaration(e)) {
                return this._findParamDeclarations(e);
              } else {
                if (c.isSpecialBuiltInClassDeclaration(e)) {
                  return this._findSpecialBuiltInClassDeclarations(e);
                } else {
                  return [];
                }
              }
            }
          }
        }
      }
      findDeclarationsByType(e, t, n = false) {
        const a = [];
        this._addClassTypeDeclarations(e, t, a, new Set(), n);
        return a;
      }
      findClassDeclarationsByType(e, t) {
        return this.findDeclarationsByType(e, t).filter(e => c.isClassDeclaration(e)).map(e => e);
      }
      findFunctionDeclarations(e) {
        return this._findFunctionOrTypeAliasDeclarations(e).filter(e => c.isFunctionDeclaration(e)).map(e => e);
      }
      isUserCode(e) {
        return u.isUserCode(this._boundSourceGetter(e));
      }
      getNextFileName(e) {
        const t = e.stripExtension();
        let n = 1;
        let a = t.addExtension(`_${n}.py`);
        while (this.isUserCode(a) && n < 1000) {
          n += 1;
          a = t.addExtension(`_${n}.py`);
        }
        return a;
      }
      _findSpecialBuiltInClassDeclarations(e, t = new Set()) {
        if (e.node.d.valueExpr.nodeType === 38) {
          const n = e.node.d.valueExpr.d.value;
          return this._getBoundSourceFilesFromStubFile(e.uri).flatMap(e => this._findClassDeclarationsByName(e, n, t));
        }
        return [];
      }
      _findClassOrTypeAliasDeclarations(e, t = new Set()) {
        const n = this._getFullClassName(e.node);
        return this._getBoundSourceFilesFromStubFile(e.uri).flatMap(e => this._findClassDeclarationsByName(e, n, t));
      }
      _findFunctionOrTypeAliasDeclarations(e, t = new Set()) {
        const n = e.node.d.name.d.value;
        const a = this._getBoundSourceFilesFromStubFile(e.uri);
        if (e.isMethod) {
          const r = o.getEnclosingClass(e.node);
          if (r === undefined) {
            return [];
          }
          const s = this._getFullClassName(r);
          return a.flatMap(e => this._findMethodDeclarationsByName(e, s, n, t));
        }
        return a.flatMap(e => this._findFunctionDeclarationsByName(e, n, t));
      }
      _findVariableDeclarations(e, t = new Set()) {
        if (e.node.nodeType !== 38) {
          return [];
        }
        const n = e.node.d.value;
        const a = this._getBoundSourceFilesFromStubFile(e.uri);
        const r = o.getEnclosingClass(e.node);
        if (r) {
          const e = this._getFullClassName(r);
          return a.flatMap(a => this._findFieldDeclarationsByName(a, e, n, t));
        }
        return a.flatMap(e => this._findVariableDeclarationsByName(e, n, t));
      }
      _findParamDeclarations(e) {
        var t;
        const n = [];
        if (!e.node.d.name) {
          return n;
        }
        const a = o.getEnclosingFunction(e.node);
        if (!a) {
          return n;
        }
        const r = (t = this._evaluator.getDeclInfoForNameNode(a.d.name)) === null || t === undefined ? undefined : t.decls;
        if (!r) {
          return n;
        }
        const s = new Set();
        for (const t of r) {
          if (c.isFunctionDeclaration(t)) {
            for (const a of this._findFunctionOrTypeAliasDeclarations(t, s)) {
              l.appendArray(n, this._lookUpSymbolDeclarations(a.node, e.node.d.name.d.value).filter(e => c.isParamDeclaration(e)).map(e => e));
            }
          }
        }
        return n;
      }
      _findMemberDeclarationsByName(e, t, n, a, r) {
        const s = [];
        const i = this._findClassDeclarationsByName(e, t, r);
        for (const e of i.filter(e => c.isClassDeclaration(e)).map(e => e)) {
          const t = this._evaluator.getTypeOfClass(e.node);
          if (!t) {
            continue;
          }
          const i = y.lookUpClassMember(t.classType, n);
          if (i) {
            for (const e of i.symbol.getDeclarations()) {
              a(e, r, s);
            }
          }
        }
        return s;
      }
      _findFieldDeclarationsByName(e, t, n, a) {
        let r = [];
        const s = `@${e.getUri()}/c/${t}/v/${n}`;
        if (!a.has(s)) {
          a.add(s);
          r = this._findMemberDeclarationsByName(e, t, n, (e, t, n) => {
            if (c.isVariableDeclaration(e)) {
              if (this._isStubThatShouldBeMappedToImplementation(e.uri)) {
                for (const a of this._findVariableDeclarations(e, t)) {
                  if (c.isVariableDeclaration(a)) {
                    n.push(a);
                  }
                }
              } else {
                n.push(e);
              }
            }
          }, a);
          a.delete(s);
        }
        return r;
      }
      _findMethodDeclarationsByName(e, t, n, a) {
        let r = [];
        const s = `@${e.getUri()}/c/${t}/f/${n}`;
        if (!a.has(s)) {
          a.add(s);
          r = this._findMemberDeclarationsByName(e, t, n, (e, t, n) => {
            if (c.isFunctionDeclaration(e)) {
              if (this._isStubThatShouldBeMappedToImplementation(e.uri)) {
                l.appendArray(n, this._findFunctionOrTypeAliasDeclarations(e, t));
              } else {
                n.push(e);
              }
            }
          }, a);
          a.delete(s);
        }
        return r;
      }
      _findVariableDeclarationsByName(e, t, n) {
        var a;
        const r = [];
        const s = `@${e.getUri()}/v/${t}`;
        if (n.has(s)) {
          return r;
        }
        n.add(s);
        const i = (a = e.getParserOutput()) === null || a === undefined ? undefined : a.parseTree;
        if (!i) {
          return r;
        }
        const o = this._lookUpSymbolDeclarations(i, t);
        if (o.length === 0) {
          this._addDeclarationsFollowingWildcardImports(i, t, r, n);
        } else {
          for (const e of o) {
            this._addVariableDeclarations(e, r, n);
          }
        }
        n.delete(s);
        return r;
      }
      _findFunctionDeclarationsByName(e, t, n) {
        var a;
        const r = [];
        const s = `@${e.getUri()}/f/${t}`;
        if (n.has(s)) {
          return r;
        }
        n.add(s);
        const i = (a = e.getParserOutput()) === null || a === undefined ? undefined : a.parseTree;
        if (!i) {
          return r;
        }
        const o = this._lookUpSymbolDeclarations(i, t);
        if (o.length === 0) {
          this._addDeclarationsFollowingWildcardImports(i, t, r, n);
        } else {
          for (const e of o) {
            this._addClassOrFunctionDeclarations(e, r, n);
          }
        }
        n.delete(s);
        return r;
      }
      _findClassDeclarationsByName(e, t, n) {
        var a;
        let r = [];
        const s = (a = e.getParserOutput()) === null || a === undefined ? undefined : a.parseTree;
        if (s) {
          let a = t.split('.');
          if (a.length > 0) {
            r = this._findClassDeclarations(e, a[0], s, n);
            a = a.slice(1);
          }
          for (const t of a) {
            r = r.flatMap(a => this._findClassDeclarations(e, t, a.node, n));
          }
        }
        return r;
      }
      _findClassDeclarations(e, t, n, a) {
        const r = [];
        const s = `@${e.getUri()}[${n.start}]${t}`;
        if (a.has(s)) {
          return r;
        }
        a.add(s);
        const i = this._lookUpSymbolDeclarations(n, t);
        if (i.length === 0 && n.nodeType === 36) {
          this._addDeclarationsFollowingWildcardImports(n, t, r, a);
        } else {
          for (const e of i) {
            this._addClassOrFunctionDeclarations(e, r, a);
          }
        }
        a.delete(s);
        return r;
      }
      _addVariableDeclarations(e, t, n) {
        if (c.isVariableDeclaration(e)) {
          if (this._isStubThatShouldBeMappedToImplementation(e.uri)) {
            l.appendArray(t, this._findVariableDeclarations(e, n));
          } else {
            t.push(e);
          }
        } else {
          if (c.isAliasDeclaration(e)) {
            const a = this._evaluator.resolveAliasDeclaration(e, true);
            if (a) {
              if (c.isVariableDeclaration(a)) {
                this._addVariableDeclarations(a, t, n);
              } else {
                if (c.isClassDeclaration(a) || c.isFunctionDeclaration(a)) {
                  this._addClassOrFunctionDeclarations(a, t, n);
                }
              }
            }
          }
        }
      }
      _addClassOrFunctionDeclarations(e, t, n) {
        var a;
        if (c.isClassDeclaration(e)) {
          if (this._isStubThatShouldBeMappedToImplementation(e.uri)) {
            l.appendArray(t, this._findClassOrTypeAliasDeclarations(e, n));
          } else {
            t.push(e);
          }
        } else {
          if (c.isSpecialBuiltInClassDeclaration(e)) {
            t.push(e);
          } else {
            if (c.isFunctionDeclaration(e)) {
              if (this._isStubThatShouldBeMappedToImplementation(e.uri)) {
                l.appendArray(t, this._findFunctionOrTypeAliasDeclarations(e, n));
              } else {
                t.push(e);
              }
            } else {
              if (c.isAliasDeclaration(e)) {
                const a = this._handleSpecialBuiltInModule(e);
                const r = this._evaluator.resolveAliasDeclaration(a, true);
                if (r && !c.isAliasDeclaration(r)) {
                  this._addClassOrFunctionDeclarations(r, t, n);
                }
              } else {
                if (c.isVariableDeclaration(e)) {
                  this._addVariableDeclarations(e, t, n);
                  const r = (a = e.typeAliasName) !== null && a !== undefined ? a : e.node;
                  const s = this._evaluator.getType(r);
                  if (!s) {
                    return;
                  }
                  if (g.isFunction(s) && s.shared.declaration) {
                    this._addClassOrFunctionDeclarations(s.shared.declaration, t, n);
                  } else {
                    if (g.isOverloaded(s)) {
                      const e = g.OverloadedType.getOverloads(s);
                      for (const a of e.map(e => e.shared.declaration).filter(p.isDefined)) {
                        this._addClassOrFunctionDeclarations(a, t, n);
                      }
                    } else {
                      if (g.isInstantiableClass(s)) {
                        this._addClassTypeDeclarations(e.uri, s, t, n);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      _handleSpecialBuiltInModule(e) {
        if (!e.uri.isEmpty() || !e.node) {
          return e;
        }
        if (e.moduleName !== 'io' && e.moduleName !== 'collections') {
          return e;
        }
        const t = this._importResolver.getTypeshedStdLibPath(this._execEnv);
        if (!t) {
          return e;
        }
        const n = o.getFileInfoFromNode(e.node);
        if (!n) {
          return e;
        }
        const a = t.combinePaths(function () {
          var t;
          switch (e.node.nodeType) {
            case 24:
            case 25:
              return e.node.d.module;
            case 26:
              d.assert(((t = e.node.parent) === null || t === undefined ? undefined : t.nodeType) === 25);
              return e.node.parent.d.module;
            default:
              return d.assertNever(e.node);
          }
        }().d.nameParts.map(e => e.d.value).join('.') + '.pyi');
        const r = this._getSourceFiles(a, n.fileUri);
        if (r.length === 0) {
          return e;
        }
        const s = {
          ...e
        };
        s.uri = r[0].getUri();
        return s;
      }
      _addClassTypeDeclarations(e, t, n, a, r = false) {
        var s;
        var i;
        var o;
        const p = r && ((s = t.props) === null || s === undefined ? undefined : s.typeAliasInfo) ? t.props.typeAliasInfo.shared.fileUri : t.shared.fileUri;
        const d = this._getSourceFiles(p, undefined, e);
        const c = r && ((i = t.props) === null || i === undefined ? undefined : i.typeAliasInfo) ? t.props.typeAliasInfo.shared.fullName : t.shared.fullName;
        const u = r && ((o = t.props) === null || o === undefined ? undefined : o.typeAliasInfo) ? t.props.typeAliasInfo.shared.moduleName : t.shared.moduleName;
        const m = c.substring(u.length + 1);
        for (const e of d) {
          l.appendArray(n, this._findClassDeclarationsByName(e, m, a));
        }
      }
      _getSourceFiles(e, t, n) {
        const a = [];
        if (this._isStubThatShouldBeMappedToImplementation(e)) {
          l.appendArray(a, this._getBoundSourceFilesFromStubFile(e, t, n));
        } else {
          const t = this._boundSourceGetter(e);
          if (t) {
            a.push(t.sourceFile);
          }
        }
        return a;
      }
      _addDeclarationsFollowingWildcardImports(e, t, n, a) {
        var r;
        var s;
        const o = (r = i.getScope(e)) === null || r === undefined ? undefined : r.symbolTable;
        if (o) {
          for (const e of o.values()) {
            for (const r of e.getDeclarations()) {
              if (!c.isAliasDeclaration(r) || r.uri.isEmpty() || r.node.nodeType !== 25 || !r.node.d.isWildcardImport) {
                continue;
              }
              const e = `@${r.uri.key}/l/${t}`;
              if (a.has(e)) {
                continue;
              }
              a.add(e);
              const i = this._getSourceFiles(r.uri);
              for (const e of i) {
                const r = (s = e.getParserOutput()) === null || s === undefined ? undefined : s.parseTree;
                if (!r) {
                  continue;
                }
                const i = this._lookUpSymbolDeclarations(r, t);
                if (i.length === 0) {
                  this._addDeclarationsFollowingWildcardImports(r, t, n, a);
                } else {
                  for (const e of i) {
                    const t = this._evaluator.resolveAliasDeclaration(e, true);
                    if (t) {
                      if (c.isFunctionDeclaration(t) || c.isClassDeclaration(t)) {
                        this._addClassOrFunctionDeclarations(t, n, a);
                      } else {
                        if (c.isVariableDeclaration(t)) {
                          this._addVariableDeclarations(t, n, a);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      _lookUpSymbolDeclarations(e, t) {
        if (e === undefined) {
          return [];
        }
        const n = i.getScope(e);
        const a = n == null ? undefined : n.lookUpSymbol(t);
        const r = a == null ? undefined : a.getDeclarations();
        if (r != null) {
          return r;
        } else {
          return [];
        }
      }
      _getFullClassName(e) {
        const t = [];
        let n = e;
        while (n !== undefined) {
          t.push(n.d.name.d.value);
          n = o.getEnclosingClass(n);
        }
        return t.reverse().join('.');
      }
      _getBoundSourceFilesFromStubFile(e, t, n) {
        var a;
        return this._getSourcePathsFromStub(e, n ?? ((a = this._fromFile) === null || a === undefined ? undefined : a.sourceFile.getUri())).map(n => this._fileBinder(t ?? e, n)).filter(p.isDefined);
      }
      _getSourcePathsFromStub(e, t) {
        let n = this._importResolver.getSourceFilesFromStub(e, this._execEnv, this._mapCompiled);
        if (n.length > 0) {
          return n;
        }
        const a = this._getStubFileImportTree(e, t);
        for (let e = 0; e < a.length; e++) {
          n = this._importResolver.getSourceFilesFromStub(a[e], this._execEnv, this._mapCompiled);
          if (n.length > 0) {
            return n;
          }
        }
        return [];
      }
      _getStubFileImportTree(e, t) {
        if (t && this._isStubThatShouldBeMappedToImplementation(e)) {
          return m.buildImportTree(t, e, e => {
            const t = this._boundSourceGetter(e);
            if (t) {
              return t.importedBy.map(e => e.sourceFile.getUri());
            } else {
              return [];
            }
          }, this._cancelToken).filter(e => this._isStubThatShouldBeMappedToImplementation(e));
        } else {
          return [e];
        }
      }
      _isStubThatShouldBeMappedToImplementation(e) {
        if (this._preferStubs) {
          return false;
        }
        return !!h(e) && this._importResolver.getSourceFilesFromStub(e, this._execEnv, this._mapCompiled).every(t => t !== e);
      }
    };
  },
  15132: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.buildImportTree = function (e, t, n, s) {
      const i = new a();
      const o = r(e, t, n, [], i, s);
      if (o.length > 0) {
        return o;
      } else {
        return [t];
      }
    };
    const n = 1000;
    class a {
      constructor() {
        this.value = 0;
      }
    }
    function r(e, t, a, s, i, o) {
      if (i.value > n || o.isCancellationRequested) {
        return [];
      }
      i.value += 1;
      if (t.equals(e)) {
        if (s.length) {
          return s;
        } else {
          return [t];
        }
      }
      if (s.length > 1 && s.find(e => e.equals(t))) {
        return [];
      }
      const l = a(t);
      for (let n = 0; n < l.length && !o.isCancellationRequested; n++) {
        const p = r(e, l[n], a, [...s, t], i, o);
        if (p.length > 0) {
          return p;
        }
      }
      return [];
    }
  },
  28676: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.evaluateStaticBoolExpression = s;
    exports.evaluateStaticBoolLikeExpression = i;
    const a = require(12522);
    const r = require(63808);
    function s(e, t, n, d, c) {
      if (e.nodeType === 4) {
        return s(e.d.rightExpr, t, n, d, c);
      }
      if (e.nodeType === 55) {
        if (e.d.operator === 38) {
          const a = i(e.d.expr, t, n, d, c);
          if (a !== undefined) {
            return !a;
          }
        }
      } else {
        if (e.nodeType === 7) {
          if (e.d.operator === 37 || e.d.operator === 36) {
            const a = s(e.d.leftExpr, t, n, d, c);
            const r = s(e.d.rightExpr, t, n, d, c);
            if (a === undefined || r === undefined) {
              return;
            }
            if (e.d.operator === 37) {
              return a || r;
            } else {
              return a && r;
            }
          }
          if (p(e.d.leftExpr, c) && e.d.rightExpr.nodeType === 52) {
            const n = function (e) {
              if (e.d.items.length >= 2) {
                if (e.d.items[0].nodeType === 40 && !e.d.items[0].d.isImaginary && e.d.items[1].nodeType === 40 && !e.d.items[1].d.isImaginary) {
                  const t = e.d.items[0];
                  const n = e.d.items[1];
                  if (typeof t.d.value != 'number' || typeof n.d.value != 'number') {
                    return;
                  }
                  const a = t.d.value;
                  const s = n.d.value;
                  let i;
                  let o;
                  let l;
                  if (e.d.items.length >= 3 && e.d.items[2].nodeType === 40 && !e.d.items[2].d.isImaginary && typeof e.d.items[2].d.value == 'number') {
                    i = e.d.items[2].d.value;
                  }
                  if (e.d.items.length >= 4 && e.d.items[3].nodeType === 48 && e.d.items[3].d.strings.length === 1 && e.d.items[3].d.strings[0].nodeType === 49) {
                    o = e.d.items[3].d.strings[0].d.value;
                  }
                  if (e.d.items.length >= 5 && e.d.items[4].nodeType === 40 && !e.d.items[4].d.isImaginary && typeof e.d.items[4].d.value == 'number') {
                    l = e.d.items[4].d.value;
                  }
                  return r.PythonVersion.create(a, s, i, o, l);
                }
              } else {
                if (e.d.items.length === 1) {
                  const t = e.d.items[0];
                  if (typeof t.d.value == 'number') {
                    return r.PythonVersion.create(t.d.value, 0);
                  }
                }
              }
              return;
            }(e.d.rightExpr);
            return o(e.d.operator, t.pythonVersion, n);
          }
          if (e.d.leftExpr.nodeType === 27 && p(e.d.leftExpr.d.leftExpr, c) && e.d.leftExpr.d.items.length === 1 && !e.d.leftExpr.d.trailingComma && !e.d.leftExpr.d.items[0].d.name && e.d.leftExpr.d.items[0].d.argCategory === 0 && e.d.leftExpr.d.items[0].d.valueExpr.nodeType === 40 && !e.d.leftExpr.d.items[0].d.valueExpr.d.isImaginary && e.d.leftExpr.d.items[0].d.valueExpr.d.value === 0 && e.d.rightExpr.nodeType === 40 && e.d.rightExpr.d.isInteger && typeof e.d.rightExpr.d.value == 'number') {
            return o(e.d.operator, r.PythonVersion.create(t.pythonVersion.major, 0), r.PythonVersion.create(e.d.rightExpr.d.value, 0));
          }
          if (function (e, t = ['sys']) {
            if (e.nodeType === 35 && e.d.leftExpr.nodeType === 38 && e.d.member.d.value === 'platform' && t.some(t => t === e.d.leftExpr.d.value)) {
              return true;
            }
            return false;
          }(e.d.leftExpr, c) && e.d.rightExpr.nodeType === 48) {
            const n = e.d.rightExpr.d.strings.map(e => e.d.value).join('');
            const r = function (e) {
              if (e.pythonPlatform === a.PythonPlatform.Darwin) {
                return 'darwin';
              }
              if (e.pythonPlatform === a.PythonPlatform.Windows) {
                return 'win32';
              }
              if (e.pythonPlatform === a.PythonPlatform.Linux) {
                return 'linux';
              }
              return;
            }(t);
            return l(e.d.operator, r, n);
          }
          if (function (e) {
            if (e.nodeType === 35 && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'os' && e.d.member.d.value === 'name') {
              return true;
            }
            return false;
          }(e.d.leftExpr) && e.d.rightExpr.nodeType === 48) {
            const n = e.d.rightExpr.d.strings.map(e => e.d.value).join('');
            const r = function (e) {
              if (e.pythonPlatform === a.PythonPlatform.Darwin) {
                return 'posix';
              }
              if (e.pythonPlatform === a.PythonPlatform.Windows) {
                return 'nt';
              }
              if (e.pythonPlatform === a.PythonPlatform.Linux) {
                return 'posix';
              }
              return;
            }(t);
            if (r !== undefined) {
              return l(e.d.operator, r, n);
            }
          } else {
            if (e.d.rightExpr.nodeType === 48) {
              let t;
              if (e.d.leftExpr.nodeType === 38) {
                t = n.get(e.d.leftExpr.d.value);
              } else {
                if (e.d.leftExpr.nodeType === 35) {
                  t = n.get(e.d.leftExpr.d.member.d.value);
                }
              }
              if (t !== undefined && typeof t == 'string') {
                const n = e.d.rightExpr.d.strings.map(e => e.d.value).join('');
                return l(e.d.operator, t, n);
              }
            }
          }
        } else {
          if (e.nodeType === 14) {
            if (e.d.constType === 33) {
              return true;
            }
            if (e.d.constType === 15) {
              return false;
            }
          } else {
            if (e.nodeType === 38) {
              if (e.d.value === 'TYPE_CHECKING') {
                return true;
              }
              const t = n.get(e.d.value);
              if (t !== undefined) {
                return !!t;
              }
            } else {
              if (e.nodeType === 35) {
                if (d && e.d.member.d.value === 'TYPE_CHECKING' && e.d.leftExpr.nodeType === 38 && d.some(t => t === e.d.leftExpr.d.value)) {
                  return true;
                }
                const t = n.get(e.d.member.d.value);
                if (t !== undefined) {
                  return !!t;
                }
              }
            }
          }
        }
      }
    }
    function i(e, t, n, a, r) {
      return (e.nodeType !== 14 || e.d.constType !== 26) && s(e, t, n, a, r);
    }
    function o(e, t, n) {
      if (t !== undefined && n !== undefined) {
        if (e === 20) {
          return r.PythonVersion.isLessThan(t, n);
        }
        if (e === 21) {
          return r.PythonVersion.isLessOrEqualTo(t, n);
        }
        if (e === 15) {
          return r.PythonVersion.isGreaterThan(t, n);
        }
        if (e === 16) {
          return r.PythonVersion.isGreaterOrEqualTo(t, n);
        }
        if (e === 12) {
          return r.PythonVersion.isEqualTo(t, n);
        }
        if (e === 28) {
          return !r.PythonVersion.isEqualTo(t, n);
        }
      }
    }
    function l(e, t, n) {
      if (t !== undefined && n !== undefined) {
        if (e === 12) {
          return t === n;
        }
        if (e === 28) {
          return t !== n;
        }
      }
    }
    function p(e, t = ['sys']) {
      return e.nodeType === 35 && e.d.leftExpr.nodeType === 38 && e.d.member.d.value === 'version_info' && !!t.some(t => t === e.d.leftExpr.d.value);
    }
  },
  58253: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Symbol = exports.indeterminateSymbolId = undefined;
    const a = require(83760);
    let r = 1;
    exports.indeterminateSymbolId = 0;
    class s {
      constructor(e) {
        this.id = r++;
        this._flags = e;
      }
      static createWithType(e, t, n) {
        const a = new s(e);
        a._synthesizedTypeInfo = {
          type: t,
          node: n
        };
        return a;
      }
      isInitiallyUnbound() {
        return !!(this._flags & 1);
      }
      setIsExternallyHidden() {
        this._flags |= 2;
      }
      isExternallyHidden() {
        return !!(this._flags & 2);
      }
      setIsIgnoredForProtocolMatch() {
        this._flags |= 64;
      }
      isIgnoredForProtocolMatch() {
        return !!(this._flags & 64);
      }
      setIsClassMember() {
        this._flags |= 4;
      }
      isClassMember() {
        return !!(this._flags & 4);
      }
      setIsInstanceMember() {
        this._flags |= 8;
      }
      isInstanceMember() {
        return !!(this._flags & 8);
      }
      setIsClassVar() {
        this._flags |= 128;
      }
      isClassVar() {
        return !!(this._flags & 128);
      }
      setIsFinalVarInClassBody() {
        this._flags |= 8192;
      }
      isFinalVarInClassBody() {
        return !!(this._flags & 8192);
      }
      setIsInitVar() {
        this._flags |= 1024;
      }
      isInitVar() {
        return !!(this._flags & 1024);
      }
      setIsInDunderAll() {
        this._flags |= 256;
      }
      isInDunderAll() {
        return !!(this._flags & 256);
      }
      setIsPrivateMember() {
        this._flags |= 32;
      }
      isPrivateMember() {
        return !!(this._flags & 32);
      }
      setPrivatePyTypedImport() {
        this._flags |= 512;
      }
      isPrivatePyTypedImport() {
        return !!(this._flags & 512);
      }
      isNamedTupleMemberMember() {
        return !!(this._flags & 2048);
      }
      isIgnoredForOverrideChecks() {
        return !!(this._flags & 4096);
      }
      setTypingSymbolAlias(e) {
        this._typingSymbolAlias = e;
      }
      getTypingSymbolAlias() {
        return this._typingSymbolAlias;
      }
      addDeclaration(e) {
        if (this._declarations) {
          const t = this._declarations.findIndex(t => a.areDeclarationsSame(t, e));
          if (t < 0) {
            this._declarations.push(e);
            this._declarations.forEach(e => {
              if (e.type === 1 && e.typeAliasName) {
                delete e.typeAliasName;
              }
            });
          } else {
            const n = this._declarations[t];
            if (a.hasTypeForDeclaration(e)) {
              this._declarations[t] = e;
              if (n.type === 1 && e.type === 1 && !e.inferredTypeSource && n.inferredTypeSource) {
                e.inferredTypeSource = n.inferredTypeSource;
              }
            } else {
              if (e.type === 1 && n.type === 1) {
                if (e.isFinal) {
                  n.isFinal = true;
                }
                n.typeAliasName = e.typeAliasName;
                if (!n.inferredTypeSource && e.inferredTypeSource) {
                  n.inferredTypeSource = e.inferredTypeSource;
                }
              }
            }
          }
        } else {
          this._declarations = [e];
        }
      }
      hasDeclarations() {
        return !!this._declarations && this._declarations.length > 0;
      }
      getDeclarations() {
        if (this._declarations) {
          return this._declarations;
        } else {
          return [];
        }
      }
      hasTypedDeclarations() {
        return !!this._synthesizedTypeInfo || this.getDeclarations().some(e => a.hasTypeForDeclaration(e));
      }
      getTypedDeclarations() {
        return this.getDeclarations().filter(e => a.hasTypeForDeclaration(e));
      }
      getSynthesizedType() {
        return this._synthesizedTypeInfo;
      }
    }
    exports.Symbol = s;
  },
  12097: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.isPrivateName = s;
    exports.isProtectedName = i;
    exports.isPrivateOrProtectedName = o;
    exports.isDunderName = function (e) {
      return e.length > 4 && e.startsWith('__') && e.endsWith('__');
    };
    exports.isSingleDunderName = function (e) {
      return e.length > 2 && e.startsWith('_') && e.endsWith('_');
    };
    exports.isConstantName = l;
    exports.isTypeAliasName = p;
    exports.isPublicConstantOrTypeAlias = function (e) {
      return !o(e) && (l(e) || p(e));
    };
    const n = /^[A-Z0-9_]+$/;
    const a = /^[_]+$/;
    const r = /^_{0,2}[A-Z][A-Za-z0-9_]+$/;
    function s(e) {
      return e.length > 2 && e.startsWith('__') && !e.endsWith('__');
    }
    function i(e) {
      return e.length > 1 && e.startsWith('_') && !e.startsWith('__');
    }
    function o(e) {
      return s(e) || i(e);
    }
    function l(e) {
      return !!e.match(n) && !e.match(a);
    }
    function p(e) {
      return !!e.match(r);
    }
  },
  4064: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getLastTypedDeclarationForSymbol = function (e) {
      const t = e.getTypedDeclarations();
      if (t.length > 0) {
        return t[t.length - 1];
      }
      return;
    };
    exports.isTypedDictMemberAccessedThroughIndex = function (e) {
      const t = e.getTypedDeclarations();
      if (t.length > 0) {
        if (t[t.length - 1].type === 1) {
          return true;
        }
      }
      return false;
    };
    exports.isVisibleExternally = function (e) {
      return !e.isExternallyHidden() && !e.isPrivatePyTypedImport();
    };
    exports.isEffectivelyClassVar = function (e, t) {
      if (e.isClassVar()) {
        return true;
      }
      if (e.isFinalVarInClassBody()) {
        return !t;
      }
      return false;
    };
  },
  22519: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.NameTypeWalker = exports.TestWalker = undefined;
    const a = require(88744);
    const r = require(48281);
    const s = require(88754);
    const i = require(41557);
    class o extends a.ParseTreeWalker {
      constructor() {
        super();
      }
      visitNode(e) {
        const t = super.visitNode(e);
        this._verifyParentChildLinks(e, t);
        this._verifyChildRanges(e, t);
        return t;
      }
      _verifyParentChildLinks(e, t) {
        t.forEach(t => {
          if (t && t.parent !== e) {
            r.fail(`Child node ${t.nodeType} does not contain a reference to its parent ${e.nodeType}`);
          }
        });
      }
      _verifyChildRanges(e, t) {
        let n;
        const a = i.isCompliantWithNodeRangeRules(e);
        t.forEach(t => {
          if (t) {
            let i = false;
            if (!a) {
              switch (e.nodeType) {
                case 3:
                  if (t === e.d.annotationComment) {
                    i = true;
                  }
                  if (t.nodeType === 3) {
                    i = true;
                  }
                  break;
                case 48:
                  if (t === e.d.annotation) {
                    i = true;
                  }
                  break;
                case 1:
                  if (e.d.isNameSameAsValue) {
                    i = true;
                  }
                  break;
                default:
                  r.fail(`node ${e.nodeType} is not marked as not following range rules.`);
              }
            }
            if (!i) {
              if (t.start < e.start || s.TextRange.getEnd(t) > s.TextRange.getEnd(e)) {
                r.fail(`Child node ${t.nodeType} is not contained within its parent ${e.nodeType}`);
              }
              if (n && t.start < s.TextRange.getEnd(n)) {
                let t = n.nodeType === 62;
                if (e.nodeType === 1 && e.d.isNameSameAsValue) {
                  t = true;
                }
                if (!t) {
                  r.fail('Child node is not after previous child node');
                }
              }
              n = t;
            }
          }
        });
      }
    }
    exports.TestWalker = o;
    class l extends a.ParseTreeWalker {
      constructor(e) {
        super();
        this._evaluator = e;
      }
      visitName(e) {
        var t;
        var n;
        if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 26 && ((n = e.parent) === null || n === undefined ? undefined : n.nodeType) !== 24 && this._evaluator.isNodeReachable(e, undefined)) {
          this._evaluator.getType(e);
        }
        return true;
      }
    }
    exports.NameTypeWalker = l;
  },
  15794: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createTracePrinter = function (e) {
      function t(e, t = '\'') {
        if (e) {
          return `${t}${e}${t}`;
        } else {
          return '';
        }
      }
      e = e.sort((e, t) => e.key.localeCompare(t.key)).reverse();
      const n = /[\\/]/g;
      function a(t) {
        if (t) {
          if (d.Uri.is(t)) {
            for (const a of e) {
              if (t.isChild(a)) {
                const e = a.getRelativePath(t);
                return l.stripFileExtension(e).replace(n, '.');
              }
            }
            return t.toUserVisibleString();
          }
          if (t.nameParts) {
            return t.nameParts.join('.');
          }
        }
        return '';
      }
      function r(e) {
        var n;
        var a;
        var s;
        var i;
        var l;
        var p;
        var d;
        var c;
        var u;
        var m;
        if (e) {
          switch (e.category) {
            case 2:
              return `Any ${t((a = (n = e.props) === null || n === undefined ? undefined : n.typeAliasInfo) === null || a === undefined ? undefined : a.shared.fullName)}`;
            case 6:
              if (g.TypeBase.isInstantiable(e)) {
                return `Class '${e.shared.name}' (${e.shared.moduleName})`;
              } else {
                return `Object '${e.shared.name}' (${e.shared.moduleName})`;
              }
            case 4:
              return `Function '${e.shared.name}' (${e.shared.moduleName})`;
            case 7:
              return `Module '${e.priv.moduleName}' (${e.priv.moduleName})`;
            case 3:
              return `Never ${t((i = (s = e.props) === null || s === undefined ? undefined : s.typeAliasInfo) === null || i === undefined ? undefined : i.shared.fullName)}`;
            case 5:
              return `Overloaded [${g.OverloadedType.getOverloads(e).map(e => t(r(e), '"')).join(',')}]`;
            case 9:
              return `TypeVar '${e.shared.name}' ${t((p = (l = e.props) === null || l === undefined ? undefined : l.typeAliasInfo) === null || p === undefined ? undefined : p.shared.fullName)}`;
            case 0:
              return `Unbound ${t((c = (d = e.props) === null || d === undefined ? undefined : d.typeAliasInfo) === null || c === undefined ? undefined : c.shared.fullName)}`;
            case 8:
              return `Union [${e.priv.subtypes.map(e => t(r(e), '"')).join(',')}]`;
            case 1:
              return `Unknown ${t((m = (u = e.props) === null || u === undefined ? undefined : u.typeAliasInfo) === null || m === undefined ? undefined : m.shared.fullName)}`;
            default:
              o.assertNever(e);
          }
        }
        return '';
      }
      function s(e) {
        if (e) {
          switch (e.type) {
            case 8:
              return `Alias, ${f(e.node)} (${a(e.uri)})`;
            case 6:
              return `Class, ${f(e.node)} (${a(e.uri)})`;
            case 5:
              return `Function, ${f(e.node)} (${a(e.uri)})`;
            case 0:
              return `Intrinsic, ${f(e.node)} ${e.intrinsicType} (${a(e.uri)})`;
            case 2:
              return `Param, ${f(e.node)} (${a(e.uri)})`;
            case 3:
              return `TypeParam, ${f(e.node)} (${a(e.uri)})`;
            case 7:
              return `SpecialBuiltInClass, ${f(e.node)} (${a(e.uri)})`;
            case 1:
              return `Variable, ${f(e.node)} (${a(e.uri)})`;
            case 4:
              return `TypeAlias, ${f(e.node)} (${a(e.uri)})`;
            default:
              o.assertNever(e);
          }
        }
        return '';
      }
      function h(e) {
        while (e.nodeType !== 36 && e.parent) {
          e = e.parent;
        }
        if (e.nodeType === 36) {
          return u.getFileInfo(e);
        } else {
          return undefined;
        }
      }
      function f(e, n = false) {
        var r;
        if (!e) {
          return '';
        }
        let s = n ? `(${a((r = h(e)) === null || r === undefined ? undefined : r.fileUri)})` : '';
        const i = h(e);
        if (i == null ? undefined : i.lines) {
          const t = p.convertOffsetToPosition(e.start, i.lines);
          s += ` [${t.line + 1}:${t.character + 1}]`;
        }
        if (c.isExpressionNode(e)) {
          return `${t(function (e, t = 30) {
            if (e.length < t) {
              return e;
            } else {
              return e.substring(0, t) + ' <shortened> ';
            }
          }(m.printExpression(e)), '"')} ${s}`;
        }
        switch (e.nodeType) {
          case 24:
            return `importAs '${f(e.d.module)}' ${t(e.d.alias ? f(e.d.alias) : '')} ${s}`;
          case 25:
            return `importFrom [${e.d.imports.map(e => t(f(e), '"')).join(',')}]`;
          case 26:
            return `ImportFromAs '${f(e.d.name)}' ${t(e.d.alias ? f(e.d.alias) : '')} ${s}`;
          case 36:
            return `module ${s}`;
          case 10:
            return `class '${f(e.d.name)}' ${s}`;
          case 31:
            return `function '${f(e.d.name)}' ${s}`;
          case 37:
            return `moduleName '${e.d.nameParts.map(e => f(e)).join('.')}' ${s}`;
          case 1:
            return `argument '${e.d.name ? f(e.d.name) : 'N/A'}' ${s}`;
          case 41:
            return `parameter '${e.d.name ? f(e.d.name) : 'N/A'}' ${s}`;
          default:
            return `${m.printParseNodeType(e.nodeType)} ${s}`;
        }
      }
      return {
        print: function (e) {
          if (e) {
            if (function (e) {
              const t = e;
              return t && i.isNumber(t.nodeType);
            }(e)) {
              return f(e, true);
            } else {
              if (function (e) {
                const t = e;
                return t && i.isNumber(t.type) && d.Uri.is(t.uri) && i.isString(t.moduleName);
              }(e)) {
                return s(e);
              } else {
                if (e instanceof y.Symbol) {
                  if (t = e) {
                    if (t.hasDeclarations()) {
                      return `symbol ${s(t.getDeclarations()[0])}`;
                    } else {
                      return '<symbol>';
                    }
                  } else {
                    return '';
                  }
                } else {
                  if (function (e) {
                    const t = e;
                    return t && i.isNumber(t.category) && i.isNumber(t.flags);
                  }(e)) {
                    return r(e);
                  } else {
                    return '';
                  }
                }
              }
            }
          } else {
            return '';
          }
          var t;
        },
        printFileOrModuleName: a
      };
    };
    const i = require(34455);
    const o = require(48281);
    const l = require(54010);
    const p = require(56814);
    const d = require(27113);
    const c = require(85114);
    const u = __importStar(require(26687));
    const m = __importStar(require(41557));
    const y = require(58253);
    const g = require(21024);
  },
  63278: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.makeTupleObject = m;
    exports.getTypeOfTuple = function (e, t, n, i) {
      var o;
      if (n & 256 && ((o = t.parent) === null || o === undefined ? undefined : o.nodeType) !== 1) {
        const n = new a.DiagnosticAddendum();
        n.addMessage(s.LocAddendum.useTupleInstead());
        e.addDiagnostic(r.DiagnosticRule.reportInvalidTypeForm, s.LocMessage.tupleInAnnotation() + n.getString(), t);
        return {
          type: d.UnknownType.create()
        };
      }
      if (n & 128 && t.d.items.length === 0 && !i) {
        return {
          type: m(e, []),
          isEmptyTupleShorthand: true
        };
      }
      n &= -393;
      let l;
      let p = i == null ? undefined : i.expectedType;
      let u = i && d.isAny(i.expectedType);
      if (i && d.isUnion(i.expectedType)) {
        let a;
        c.doForEachSubtype(i.expectedType, r => {
          if (d.isAny(r)) {
            u = true;
          }
          if (!a) {
            const s = e.useSpeculativeMode(t, () => y(e, t, n, c.makeInferenceContext(r)));
            if (s && e.assignType(r, s.type)) {
              a = r;
            }
          }
        }, true);
        p = a;
      }
      if (p) {
        const a = y(e, t, n, c.makeInferenceContext(p));
        if (a && !a.typeErrors) {
          return a;
        }
        l = a == null ? undefined : a.expectedTypeDiagAddendum;
      }
      const h = g(e, t, n);
      if (u) {
        h.type = d.AnyType.create();
      }
      return {
        ...h,
        expectedTypeDiagAddendum: l
      };
    };
    exports.getTypeOfTupleWithContext = y;
    exports.getTypeOfTupleInferred = g;
    exports.assignTupleTypeArgs = function (e, t, n, a, r, i, o) {
      var l;
      var p;
      const u = [...((l = t.priv.tupleTypeArgs) !== null && l !== undefined ? l : [])];
      const m = [...((p = n.priv.tupleTypeArgs) !== null && p !== undefined ? p : [])];
      if (!h(e, u, m, i)) {
        const e = u.some(e => e.isUnbounded || d.isTypeVarTuple(e.type));
        if (m.some(e => e.isUnbounded || d.isTypeVarTuple(e.type))) {
          if (e) {
            if (a != null) {
              a.addMessage(s.LocAddendum.tupleSizeIndeterminateSrcDest().format({
                expected: u.length - 1
              }));
            }
          } else {
            if (a != null) {
              a.addMessage(s.LocAddendum.tupleSizeIndeterminateSrc().format({
                expected: u.length
              }));
            }
          }
        } else {
          if (e) {
            if (a != null) {
              a.addMessage(s.LocAddendum.tupleSizeMismatchIndeterminateDest().format({
                expected: u.length - 1,
                received: m.length
              }));
            }
          } else {
            if (a != null) {
              a.addMessage(s.LocAddendum.tupleSizeMismatch().format({
                expected: u.length,
                received: m.length
              }));
            }
          }
        }
        return false;
      }
      for (let t = 0; t < m.length; t++) {
        const n = a == null ? undefined : a.createAddendum();
        const l = u[t].type;
        const p = m[t].type;
        if (d.isTypeVarTuple(l) && l.priv.isUnpacked && !l.priv.isInUnion && c.isTupleGradualForm(p)) {
          return true;
        }
        if (!e.assignType(l, p, n == null ? undefined : n.createAddendum(), r, i, o)) {
          if (n) {
            n.addMessage(s.LocAddendum.tupleEntryTypeMismatch().format({
              entry: t + 1
            }));
          }
          return false;
        }
      }
      return true;
    };
    exports.adjustTupleTypeArgs = h;
    exports.getSlicedTupleType = function (e, t, n) {
      if (n.d.stepValue || !t.priv.tupleTypeArgs) {
        return;
      }
      const a = t.priv.tupleTypeArgs;
      const r = f(e, n.d.startValue, 0, a);
      const s = f(e, n.d.endValue, a.length, a);
      if (r === undefined || s === undefined || s < r) {
        return;
      }
      const i = a.slice(r, s);
      return d.ClassType.cloneAsInstance(c.specializeTupleClass(t, i));
    };
    const a = require(11479);
    const r = require(65880);
    const s = require(67703);
    const i = require(10081);
    const o = require(86672);
    const l = require(41557);
    const p = require(83055);
    const d = require(21024);
    const c = require(92324);
    const u = 256;
    function m(e, t, n = false) {
      const a = e.getTupleClassType();
      if (a && d.isInstantiableClass(a)) {
        return c.convertToInstance(c.specializeTupleClass(a, t, true, n));
      } else {
        return d.UnknownType.create();
      }
    }
    function y(e, t, n, r) {
      r.expectedType = c.transformPossibleRecursiveTypeAlias(r.expectedType);
      if (!d.isClassInstance(r.expectedType)) {
        return;
      }
      const s = e.getTupleClassType();
      if (!s || !d.isInstantiableClass(s)) {
        return;
      }
      let p = [];
      if (c.isTupleClass(r.expectedType) && r.expectedType.priv.tupleTypeArgs) {
        p = r.expectedType.priv.tupleTypeArgs.map(e => c.transformPossibleRecursiveTypeAlias(e.type));
        const e = r.expectedType.priv.tupleTypeArgs.findIndex(e => e.isUnbounded);
        if (e >= 0) {
          if (p.length > t.d.items.length) {
            p.splice(e, 1);
          } else {
            while (p.length < t.d.items.length) {
              p.splice(e, 0, p[e]);
            }
          }
        }
      } else {
        const n = new o.ConstraintTracker();
        if (!i.addConstraintsForExpectedType(e, d.ClassType.cloneAsInstance(s), r.expectedType, n, l.getTypeVarScopesForNode(t), t.start)) {
          return;
        }
        const a = e.solveAndApplyConstraints(s, n);
        if (!a.priv.typeArgs || a.priv.typeArgs.length !== 1) {
          return;
        }
        const u = c.transformPossibleRecursiveTypeAlias(a.priv.typeArgs[0]);
        for (let e = 0; e < t.d.items.length; e++) {
          p.push(u);
        }
      }
      const y = t.d.items.map((t, a) => e.getTypeOfExpression(t, n | 268435456, c.makeInferenceContext(a < p.length ? p[a] : undefined, r.isTypeIncomplete)));
      const g = y.some(e => e.isIncomplete);
      let h;
      let f;
      if (y.some(e => e.expectedTypeDiagAddendum)) {
        h = new a.DiagnosticAddendum();
        y.forEach(e => {
          if (e.expectedTypeDiagAddendum) {
            h.addAddendum(e.expectedTypeDiagAddendum);
          }
        });
      }
      f = t.d.items.length > u && y.some(e => e.typeErrors) ? m(e, [{
        type: d.UnknownType.create(),
        isUnbounded: true
      }]) : m(e, e.buildTupleTypesList(y, false));
      return {
        type: f,
        expectedTypeDiagAddendum: h,
        isIncomplete: g
      };
    }
    function g(e, t, n) {
      const a = t.d.items.map(t => e.getTypeOfExpression(t, n | 268435456));
      const r = a.some(e => e.isIncomplete);
      if (t.d.items.length > u) {
        return {
          type: m(e, [{
            type: d.UnknownType.create(),
            isUnbounded: true
          }])
        };
      }
      const s = m(e, e.buildTupleTypesList(a, !!(n & 268435456)));
      if (r && c.getContainerDepth(s) > p.maxInferredContainerDepth) {
        return {
          type: d.UnknownType.create()
        };
      } else {
        return {
          type: s,
          isIncomplete: r
        };
      }
    }
    function h(e, t, n, a) {
      const r = t.findIndex(e => e.isUnbounded || d.isUnpackedTypeVarTuple(e.type) || d.isUnpackedTypeVar(e.type));
      const s = n.findIndex(e => e.isUnbounded);
      const i = n.findIndex(e => d.isUnpackedTypeVarTuple(e.type) || d.isUnpackedTypeVar(e.type));
      if (s >= 0) {
        if (d.isAnyOrUnknown(n[s].type)) {
          const e = n.length > 0 ? n[s].type : d.AnyType.create();
          while (n.length < t.length) {
            n.splice(s, 0, {
              type: e,
              isUnbounded: true
            });
          }
          if (n.length > t.length) {
            n.splice(s, 1);
          }
        } else {
          if (r < 0) {
            return false;
          }
        }
      }
      if (r >= 0 && t[r].isUnbounded && d.isAnyOrUnknown(t[r].type)) {
        while (t.length < n.length) {
          t.splice(r, 0, t[r]);
        }
      }
      while (n.length > t.length && n[n.length - 1].isOptional) {
        n.splice(n.length - 1, 1);
      }
      while (t.length > n.length && t[t.length - 1].isOptional) {
        t.splice(t.length - 1, 1);
      }
      const o = n.length - t.length + 1;
      let l = false;
      if (a & 2) {
        const a = t.length - n.length + 1;
        if (i >= 0 && a >= 0) {
          const n = a === 1 && d.isTypeVarTuple(t[i].type);
          const r = e.getTupleClassType();
          if (!n && r && d.isInstantiableClass(r)) {
            const e = t.splice(i, a);
            const n = d.ClassType.cloneAsInstance(c.specializeTupleClass(r, e.map(e => ({
              type: e.type,
              isUnbounded: e.isUnbounded,
              isOptional: e.isOptional
            })), true, true));
            t.splice(i, 0, {
              type: n,
              isUnbounded: false
            });
          }
          l = true;
        }
      } else {
        if (r >= 0 && o >= 0 && d.isTypeVarTuple(t[r].type)) {
          const t = e.getTupleClassType();
          if (t && d.isInstantiableClass(t)) {
            const e = n.splice(r, o);
            let a;
            a = e.length === 1 && d.isUnpackedTypeVarTuple(e[0].type) ? e[0].type : d.ClassType.cloneAsInstance(c.specializeTupleClass(t, e.map(e => ({
              type: e.type,
              isUnbounded: e.isUnbounded,
              isOptional: e.isOptional
            })), true, true));
            n.splice(r, 0, {
              type: a,
              isUnbounded: false
            });
          }
          l = true;
        }
      }
      if (!l && r >= 0 && o >= 0 && (s < 0 || s >= r && s < r + o)) {
        const e = n.splice(r, o).map(e => d.isTypeVar(e.type) && d.isUnpackedTypeVarTuple(e.type) ? d.TypeVarType.cloneForUnpacked(e.type, true) : e.type);
        n.splice(r, 0, {
          type: e.length > 0 ? d.combineTypes(e) : d.AnyType.create(),
          isUnbounded: false
        });
      }
      return t.length === n.length;
    }
    function f(e, t, n, a) {
      let r = n;
      if (t) {
        const n = e.getTypeOfExpression(t).type;
        if (!d.isClassInstance(n) || !d.ClassType.isBuiltIn(n, 'int') || !c.isLiteralType(n)) {
          return;
        }
        r = n.priv.literalValue;
        const s = a.findIndex(e => e.isUnbounded || d.isTypeVarTuple(e.type));
        if (r < 0) {
          r = a.length + r;
          if (s >= 0 && r <= s) {
            return;
          }
          if (r < 0) {
            return 0;
          }
        } else {
          if (s >= 0 && r > s) {
            return;
          }
          if (r > a.length) {
            return a.length;
          }
        }
      }
      return r;
    }
  },
  17486: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SpeculativeTypeTracker = undefined;
    const i = require(48281);
    const o = __importStar(require(41557));
    const l = require(21024);
    exports.SpeculativeTypeTracker = class {
      constructor() {
        this._speculativeContextStack = [];
        this._speculativeTypeCache = new Map();
        this._activeDependentTypes = [];
      }
      enterSpeculativeContext(e, t) {
        this._speculativeContextStack.push({
          speculativeRootNode: e,
          entriesToUndo: [],
          dependentType: t == null ? undefined : t.dependentType,
          allowDiagnostics: t == null ? undefined : t.allowDiagnostics
        });
        if (t == null ? undefined : t.dependentType) {
          this._activeDependentTypes.push({
            speculativeRootNode: e,
            dependentType: t.dependentType
          });
        }
      }
      leaveSpeculativeContext() {
        i.assert(this._speculativeContextStack.length > 0);
        const e = this._speculativeContextStack.pop();
        if (e == null ? undefined : e.dependentType) {
          i.assert(this._activeDependentTypes.length > 0);
          this._activeDependentTypes.pop();
        }
        e.entriesToUndo.forEach(e => {
          e.cache.delete(e.id);
        });
      }
      isSpeculative(e, t = false) {
        if (this._speculativeContextStack.length === 0) {
          return false;
        }
        if (!e) {
          return true;
        }
        for (let n = this._speculativeContextStack.length - 1; n >= 0; n--) {
          const a = this._speculativeContextStack[n];
          if (o.isNodeContainedWithin(e, a.speculativeRootNode) && (!t || !a.allowDiagnostics)) {
            return true;
          }
        }
        return false;
      }
      trackEntry(e, t) {
        const n = this._speculativeContextStack.length;
        if (n > 0) {
          this._speculativeContextStack[n - 1].entriesToUndo.push({
            cache: e,
            id: t
          });
        }
      }
      disableSpeculativeMode() {
        const e = this._speculativeContextStack;
        this._speculativeContextStack = [];
        return e;
      }
      enableSpeculativeMode(e) {
        i.assert(this._speculativeContextStack.length === 0);
        this._speculativeContextStack = e;
      }
      addSpeculativeType(e, t, n, a) {
        i.assert(this._speculativeContextStack.length > 0);
        let r = this._speculativeTypeCache.get(e.id);
        if (r) {
          r = r.filter(e => (!e.typeResult.isIncomplete || e.incompleteGenerationCount === n) && (a ? !e.expectedType || !l.isTypeSame(e.expectedType, a) : !!e.expectedType));
          if (r.length >= 8) {
            r.slice(1);
          }
        } else {
          r = [];
        }
        const s = {
          typeResult: t,
          expectedType: a,
          incompleteGenerationCount: n
        };
        if (this._activeDependentTypes.length > 0) {
          s.dependentTypes = Array.from(this._activeDependentTypes);
        }
        r.push(s);
        this._speculativeTypeCache.set(e.id, r);
      }
      getSpeculativeType(e, t) {
        if (this._speculativeContextStack.some(t => o.isNodeContainedWithin(e, t.speculativeRootNode))) {
          const n = this._speculativeTypeCache.get(e.id);
          if (n) {
            for (const e of n) {
              if (t) {
                if (e.expectedType && l.isTypeSame(t, e.expectedType) && this._dependentTypesMatch(e)) {
                  return e;
                }
              } else {
                if (!e.expectedType && this._dependentTypesMatch(e)) {
                  return e;
                }
              }
            }
          }
        }
      }
      _dependentTypesMatch(e) {
        var t;
        const n = (t = e.dependentTypes) !== null && t !== undefined ? t : [];
        return n.length === this._activeDependentTypes.length && n.every((e, t) => {
          const n = this._activeDependentTypes[t];
          return e.speculativeRootNode === n.speculativeRootNode && l.isTypeSame(e.dependentType, n.dependentType);
        });
      }
    };
  },
  53529: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getComplexityScoreForType = r;
    const a = require(21024);
    function r(e, t = 0) {
      if (t > a.maxTypeRecursionCount) {
        return 1;
      }
      t++;
      switch (e.category) {
        case 1:
        case 2:
          return 0.5;
        case 9:
          if (a.TypeBase.isInstantiable(e)) {
            return 0.55;
          } else {
            return 0.5;
          }
        case 4:
        case 5:
          if (a.TypeBase.isInstantiable(e)) {
            return 0.85;
          } else {
            return 0.8;
          }
        case 0:
        case 3:
          return 1;
        case 8:
          {
            let n = 0;
            if (e.priv.subtypes.length < 16) {
              e.priv.subtypes.forEach(e => {
                const a = r(e, t);
                n = Math.max(n, a);
              });
            } else {
              n = 0.5;
            }
            return n;
          }
        case 6:
          return function (e, t) {
            let n = 0;
            let s = 0;
            if (e.priv.tupleTypeArgs) {
              e.priv.tupleTypeArgs.forEach(e => {
                n += r(e.type, t);
                s++;
              });
            } else {
              if (e.priv.typeArgs) {
                e.priv.typeArgs.forEach(e => {
                  n += r(e, t);
                  s++;
                });
              } else {
                if (e.shared.typeParams) {
                  e.shared.typeParams.forEach(e => {
                    n += r(a.AnyType.create(), t);
                    s++;
                  });
                }
              }
            }
            let i = 0.5 + (s > 0 ? n / s : 0) * 0.25;
            if (a.isInstantiableClass(e)) {
              i += 0.05;
            }
            return i;
          }(e, t);
      }
      return 0;
    }
  },
  30889: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getFunctionDocStringInherited = function (e, t, n, a) {
      let r;
      if (!m(e, a) && t && i.isFunctionDeclaration(t)) {
        r = function (e, t, n) {
          if (!p.isFunction(e)) {
            return;
          }
          let a = e.shared.docString;
          if (!a && t) {
            a = v(t, n);
          }
          if (!a && e.shared.declaration) {
            a = v(e.shared.declaration, n);
          }
          return a;
        }(e, t, n);
      }
      if (!r && a) {
        const t = e.shared.name;
        const s = c.getClassMemberIterator(a, t, u);
        for (const e of s) {
          if (e.symbol.getDeclarations().length > 0) {
            const t = e.symbol.getDeclarations().slice(-1)[0];
            if (i.isFunctionDeclaration(t) && (r = v(t, n), r)) {
              break;
            }
          }
        }
      }
      return r || e.shared.docString;
    };
    exports.getOverloadedDocStringsInherited = function (e, t, n, a, r) {
      var s;
      let i;
      if (!m(e, r)) {
        for (const a of t) {
          i = T(e, a, n);
          if (i && i.length > 0) {
            return i;
          }
        }
      }
      const o = p.OverloadedType.getOverloads(e);
      if (r && o.length > 0) {
        const e = o[0].shared.name;
        const t = c.getClassMemberIterator(r, e, u);
        for (const e of t) {
          const t = e.symbol.getDeclarations().slice(-1)[0];
          const r = (s = a.getTypeForDeclaration(t)) === null || s === undefined ? undefined : s.type;
          if (r && (i = T(r, t, n), i && i.length > 0)) {
            break;
          }
        }
      }
      if (i != null) {
        return i;
      } else {
        return [];
      }
    };
    exports.getPropertyDocStringInherited = function (e, t, n) {
      const a = o.getEnclosingClass(e.node.d.name, false);
      const r = a ? n.getTypeOfClass(a) : undefined;
      if (r) {
        return function (e, t, n, a) {
          var r;
          var s;
          if (!e || !i.isFunctionDeclaration(e)) {
            return;
          }
          const o = (r = n.getTypeForDeclaration(e)) === null || r === undefined ? undefined : r.type;
          if (!o || !c.isMaybeDescriptorInstance(o)) {
            return;
          }
          const l = e.node.nodeType === 31 ? e.node.d.name.d.value : undefined;
          if (!l) {
            return;
          }
          const d = c.getClassIterator(a, 0);
          for (const [e] of d) {
            if (!p.isInstantiableClass(e)) {
              continue;
            }
            const a = p.ClassType.getSymbolTable(e).get(l);
            const r = a == null ? undefined : a.getDeclarations();
            if (r) {
              for (const e of r) {
                if (i.isFunctionDeclaration(e)) {
                  const a = (s = n.getTypeForDeclaration(e)) === null || s === undefined ? undefined : s.type;
                  if (a && c.isMaybeDescriptorInstance(a)) {
                    const n = v(e, t);
                    if (n) {
                      return n;
                    }
                  }
                }
              }
            }
          }
          return;
        }(e, t, n, r.classType);
      }
      return;
    };
    exports.getVariableInStubFileDocStrings = y;
    exports.isBuiltInModule = function (e) {
      if (e) {
        return e.getPath().includes('typeshed-fallback/stdlib');
      }
      return false;
    };
    exports.getModuleDocStringFromModuleNodes = g;
    exports.getModuleDocStringFromUris = h;
    exports.getModuleDocString = function (e, t, n) {
      var a;
      let r = e.priv.docString;
      if (!r) {
        r = h([(a = t == null ? undefined : t.uri) !== null && a !== undefined ? a : e.priv.fileUri], n);
      }
      return r;
    };
    exports.getClassDocString = function (e, t, n) {
      let a = e.shared.docString;
      if (!a && t && (r = t, i.isClassDeclaration(r) || i.isSpecialBuiltInClassDeclaration(r)) && (a = i.isClassDeclaration(t) ? b([t]) : undefined, !a && t && l.isStubFile(t.uri))) {
        for (const e of n.findDeclarations(t)) {
          if (i.isVariableDeclaration(e) && e.docString) {
            a = e.docString;
            break;
          }
          if (i.isClassDeclaration(e) || i.isFunctionDeclaration(e)) {
            a = f(e);
            break;
          }
        }
      }
      var r;
      if (!a && t) {
        const r = n.findClassDeclarationsByType(t.uri, e);
        if (r) {
          a = b(r.filter(e => i.isClassDeclaration(e)).map(e => e));
        }
      }
      return a;
    };
    exports.getFunctionOrClassDeclDocString = f;
    exports.getVariableDocString = function (e, t) {
      if (!e) {
        return;
      }
      if (e.docString !== undefined) {
        return e.docString;
      } else {
        return y(e, t).find(e => e);
      }
    };
    const i = require(28445);
    const o = __importStar(require(41557));
    const l = require(3113);
    const p = require(21024);
    const d = require(58147);
    const c = require(92324);
    const u = 85;
    function m(e, t) {
      if (e.category === 5) {
        const t = p.OverloadedType.getOverloads(e);
        if (t.length === 0) {
          return false;
        }
        e = t[0];
      }
      return !!e.shared.methodClass && p.ClassType.isBuiltIn(e.shared.methodClass) && !!e.priv.boundToType && !p.ClassType.isBuiltIn(e.priv.boundToType);
    }
    function y(e, t) {
      const n = [];
      if (!l.isStubFile(e.uri)) {
        return n;
      }
      for (const a of t.findDeclarations(e)) {
        if (i.isVariableDeclaration(a) && a.docString) {
          n.push(a.docString);
        } else {
          if (i.isClassDeclaration(a) || i.isFunctionDeclaration(a)) {
            const e = f(a);
            if (e) {
              n.push(e);
            }
          }
        }
      }
      return n;
    }
    function g(e) {
      for (const t of e) {
        if (t.d.statements) {
          const e = o.getDocString(t.d.statements);
          if (e) {
            return e;
          }
        }
      }
    }
    function h(e, t) {
      const n = [];
      for (const a of e) {
        if (l.isStubFile(a)) {
          d.addIfNotNull(n, t.getModuleNode(a));
        }
        d.appendArray(n, t.findModules(a));
      }
      return g(n);
    }
    function f(e) {
      var t;
      var n;
      var a;
      return o.getDocString((a = (n = (t = e.node) === null || t === undefined ? undefined : t.d.suite) === null || n === undefined ? undefined : n.d.statements) !== null && a !== undefined ? a : []);
    }
    function T(e, t, n) {
      if (!p.isOverloaded(e)) {
        return;
      }
      const a = [];
      const r = p.OverloadedType.getOverloads(e);
      const s = p.OverloadedType.getImplementation(e);
      if (r.some(e => e.shared.docString)) {
        r.forEach(e => {
          if (e.shared.docString) {
            a.push(e.shared.docString);
          }
        });
      }
      if (s && p.isFunction(s) && s.shared.docString) {
        a.push(s.shared.docString);
      }
      if (a.length === 0 && t && l.isStubFile(t.uri) && i.isFunctionDeclaration(t)) {
        const e = b(n.findFunctionDeclarations(t));
        if (e) {
          a.push(e);
        }
      }
      return a;
    }
    function v(e, t) {
      let n = b([e]);
      if (!n && l.isStubFile(e.uri)) {
        n = b(t.findFunctionDeclarations(e));
      }
      return n;
    }
    function b(e) {
      for (const t of e) {
        const e = f(t);
        if (e) {
          return e;
        }
      }
    }
  },
  90080: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.maxCodeComplexity = undefined;
    exports.createTypeEvaluator = function (e, n, a) {
      const r = [];
      const s = new Set();
      const ue = new G.SpeculativeTypeTracker();
      const me = [];
      const ye = [];
      let ge;
      let he = new Set();
      let fe = new Map();
      let Te = new Map();
      let ve = new Map();
      let be = new Map();
      let _e = [];
      let Ce = 0;
      let Ie = 0;
      const ke = [];
      let we;
      const Se = [];
      let Ae;
      function xe() {
        if (ge) {
          i.throwIfCancellationRequested(ge);
        }
      }
      function Pe(e) {
        if (we && Me(e)) {
          return we.get(e.id);
        } else {
          return Te.get(e.id);
        }
      }
      function De(e) {
        const t = Pe(e);
        return !!t && (!t.typeResult.isIncomplete || t.incompleteGenerationCount === Ie);
      }
      function Ne(e, t) {
        var a;
        var r;
        const s = Pe(e);
        if (s && !s.typeResult.isIncomplete) {
          if ((n.verifyTypeCacheEvaluatorFlags || de) && t !== undefined) {
            const i = s.flags;
            if (i !== undefined && t !== i) {
              const s = v.getFileInfo(e);
              const o = c.convertOffsetToPosition(e.start, s.lines);
              const p = `Type cache flag mismatch for node type ${e.nodeType} (parent ${(r = (a = e.parent) === null || a === undefined ? undefined : a.nodeType) !== null && r !== undefined ? r : 'none'}): cached flags = ${i}, access flags = ${t}, file = {${s.fileUri} [${o.line + 1}:${o.character + 1}]}`;
              if (n.verifyTypeCacheEvaluatorFlags) {
                l.fail(p);
              } else {
                console.log(p);
              }
            }
          }
          return s.typeResult.type;
        }
      }
      function Fe(e, t, n, a, r = false) {
        const s = we && Me(e) ? we : Te;
        if (t.isIncomplete) {
          const n = s.get(e.id);
          if (n !== undefined && !H.isTypeSame(t.type, n.typeResult.type)) {
            Ie++;
          }
        } else {
          Ie++;
        }
        s.set(e.id, {
          typeResult: t,
          flags: n,
          incompleteGenerationCount: Ie
        });
        if (ar(e)) {
          ue.trackEntry(s, e.id);
          if (r) {
            ue.addSpeculativeType(e, t, Ie, a == null ? undefined : a.expectedType);
          }
        }
      }
      function Ee(e, t, n = 0) {
        Fe(e, t, n);
      }
      function Me(e) {
        const t = ke.length;
        if (t === 0) {
          return false;
        }
        const n = ke[t - 1];
        let a = e;
        while (a) {
          if (a === n.functionNode) {
            return true;
          }
          a = a.parent;
        }
        return false;
      }
      function Oe(e, t) {
        return r.findIndex(n => n.symbolId === e.id && n.declaration === t);
      }
      function ze(e, t) {
        const n = Oe(e, t);
        if (n >= 0) {
          for (let e = n + 1; e < r.length; e++) {
            r[e].isResultValid = false;
          }
          return false;
        }
        r.push({
          symbolId: e.id,
          declaration: t,
          isResultValid: true
        });
        return true;
      }
      function Ue(e) {
        const t = r.pop();
        l.assert(t.symbolId === e.id);
        return t.isResultValid;
      }
      function Ve(e, t, n) {
        const a = Oe(e, t);
        if (a >= 0) {
          r[a].partialType = n;
        }
      }
      function Re(e, t) {
        const n = Oe(e, t);
        if (n >= 0) {
          return r[n].partialType;
        }
      }
      function Le(e) {
        var t;
        var n;
        var a;
        var r;
        je(e);
        let s = (t = Ba(e, () => {
          Va(e);
        })) === null || t === undefined ? undefined : t.type;
        if (s && H.isTypeVar(s) && s.shared.declaredVariance === 0) {
          const t = s;
          const i = M.getParentNodeOfType(e, 76);
          if (((n = i == null ? undefined : i.parent) === null || n === undefined ? undefined : n.nodeType) === 10) {
            const e = ca(i.parent);
            if (e) {
              ya(e.classType);
              const n = e.classType.shared.typeParams.find(e => H.isTypeSame(e, t, {
                ignoreTypeFlags: true
              }));
              if ((n == null ? undefined : n.priv.computedVariance) !== undefined) {
                s = H.TypeVarType.cloneWithComputedVariance(s, n.priv.computedVariance);
              }
            }
          } else {
            if (((a = i == null ? undefined : i.parent) === null || a === undefined ? undefined : a.nodeType) === 77) {
              const t = oa(i.parent);
              const n = i.d.params.findIndex(t => t.d.name === e);
              if (n >= 0) {
                Ht(t);
                const e = (r = t.props) === null || r === undefined ? undefined : r.typeAliasInfo;
                if (e == null ? undefined : e.shared.computedVariance) {
                  const t = e.shared.computedVariance[n];
                  s = H.TypeVarType.cloneWithComputedVariance(s, t);
                }
              }
            }
          }
        }
        if (s) {
          s = Z.transformPossibleRecursiveTypeAlias(s);
        }
        return s;
      }
      function Be(e) {
        je(e);
        let t = e;
        let n = e;
        while (n) {
          if (h.isExpressionNode(n)) {
            t = n;
          }
          n = n.parent;
        }
        Va(t);
        n = e;
        while (n) {
          const e = be.get(n.id);
          if (e) {
            return {
              type: e,
              node: n
            };
          }
          if (n === t) {
            break;
          }
          n = n.parent;
        }
      }
      function je(e) {
        var t;
        if (!Ae && (Ae = {}, Ae.objectClass = Za(e, 'object'), Ae.typeClass = Za(e, 'type'), Ae.functionClass = Za(e, 'function'), Ae.unionTypeClass = function (e, t) {
          return mt(e, t, ['types']);
        }(e, 'UnionType'), Ae.unionTypeClass && H.isClass(Ae.unionTypeClass) && (Ae.unionTypeClass.shared.flags |= 8388608), ct(e, 'Collection'), Ae.noneTypeClass = (t = ut(e, 'NoneType')) !== null && t !== undefined ? t : H.UnknownType.create(), Ae.tupleClass = Za(e, 'tuple'), Ae.boolClass = Za(e, 'bool'), Ae.intClass = Za(e, 'int'), Ae.strClass = Za(e, 'str'), Ae.dictClass = Za(e, 'dict'), Ae.moduleTypeClass = ct(e, 'ModuleType'), Ae.typedDictClass = ct(e, 'TypedDict'), Ae.typedDictPrivateClass = ct(e, '_TypedDict'), Ae.awaitableClass = ct(e, 'Awaitable'), Ae.mappingClass = ct(e, 'Mapping'), Ae.supportsKeysAndGetItemClass = ut(e, 'SupportsKeysAndGetItem'), Ae.supportsKeysAndGetItemClass ||= Ae.mappingClass, Ae.objectClass && H.isInstantiableClass(Ae.objectClass) && Ae.typeClass && H.isInstantiableClass(Ae.typeClass))) {
          const t = H.ClassType.createInstantiable('Any', 'typing.Any', 'typing', y.Uri.empty(), 25165825, -1, undefined, Ae.typeClass);
          t.shared.baseClasses.push(Ae.objectClass);
          Z.computeMroLinearization(t);
          const n = H.AnyType.createSpecialForm();
          if (H.isAny(n)) {
            H.TypeBase.setSpecialForm(n, t);
            if (Zr(e)) {
              H.TypeBase.setTypeForm(n, Z.convertToInstance(n));
            }
          }
        }
      }
      function qe(e, t = 0, n) {
        const a = Pe(e);
        if (a && (!a.typeResult.isIncomplete || a.incompleteGenerationCount === Ie)) {
          if (ce) {
            console.log(`${Jr()}${M.printExpression(e)} (${Qr(e)}): Cached ${Yr(a.typeResult.type)} ${a.typeResult.typeErrors ? ' Errors' : ''}`);
          }
          return a.typeResult;
        }
        {
          const t = ue.getSpeculativeType(e, n == null ? undefined : n.expectedType);
          if (t && (!t.typeResult.isIncomplete || t.incompleteGenerationCount === Ie)) {
            if (ce) {
              console.log(`${Jr()}${M.printExpression(e)} (${Qr(e)}): Speculative ${Yr(t.typeResult.type)}`);
            }
            return t.typeResult;
          }
        }
        if (ce) {
          console.log(`${Jr()}${M.printExpression(e)} (${Qr(e)}): Pre`);
          Ce++;
        }
        xe();
        if (n) {
          n.expectedType = Z.transformPossibleRecursiveTypeAlias(n.expectedType);
        }
        je(e);
        let r = function (e, t = 0, n) {
          var a;
          var r;
          let s;
          let i = !!(t & 128);
          switch (e.nodeType) {
            case 38:
              s = function (e, t) {
                const n = v.getFileInfo(e);
                const a = e.d.value;
                let r;
                let s;
                let i = false;
                const o = !!(t & 4) || n.isStubFile;
                let p = Ja(e, a, !o, o && !!(t & 256));
                if (!p) {
                  const n = sr(e);
                  if (n) {
                    p = Ja(n, n.d.value, !o, o && !!(t & 256));
                  }
                }
                if (p) {
                  let c = !o;
                  if (p.scope.type === 5) {
                    c = false;
                  }
                  r = p.symbol;
                  Et(n, r, e);
                  if (!n.diagnosticRuleSet.analyzeUnannotatedFunctions) {
                    const t = M.getEnclosingFunction(e);
                    if (t && M.isUnannotatedFunction(t)) {
                      return {
                        type: H.AnyType.create(),
                        isIncomplete: false
                      };
                    }
                  }
                  const u = ur(r, c ? e : undefined);
                  let m = Z.transformPossibleRecursiveTypeAlias(u.type);
                  if (u.isIncomplete) {
                    if (H.isUnbound(m)) {
                      m = H.UnknownType.create(true);
                    }
                    i = true;
                  }
                  if (u.isRecursiveDefinition && gt(e)) {
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.recursiveDefinition().format({
                      name: a
                    }), e);
                  }
                  const y = !!m && H.isInstantiableClass(m) && H.ClassType.isSpecialBuiltIn(m);
                  s = m;
                  if (c && !y) {
                    let n = m;
                    let o = false;
                    if (!p.isBeyondExecutionScope && r.isInitiallyUnbound() && (n = H.UnboundType.create(), p.scope.type === 4)) {
                      l.assert(p.scope.parent);
                      const e = p.scope.parent.lookUpSymbol(a);
                      if (e) {
                        n = ur(e).type;
                      }
                    }
                    if (p.isBeyondExecutionScope) {
                      const t = function (e, t, n) {
                        if (t.usesGlobalBinding || t.usesNonlocalBinding) {
                          return;
                        }
                        const a = t.symbol.getDeclarations();
                        if (!a.every(e => e.type === 1 || e.type === 2 || e.type === 8)) {
                          return;
                        }
                        if (!a.every(e => e.type === 2 || V.getScopeForNode(e.node) === t.scope)) {
                          return;
                        }
                        if (!a.every(e => {
                          var t;
                          return e.type !== 1 || e.isFinal || ((t = V.getScopeForNode(e.node)) === null || t === undefined ? undefined : t.type) !== 4;
                        })) {
                          return;
                        }
                        const r = V.getScopeHierarchy(e, t.scope);
                        if (r && r.length >= 2) {
                          const a = V.findTopNodeInScope(e, r[r.length - 2]);
                          if ((a == null ? undefined : a.nodeType) === 31 || (a == null ? undefined : a.nodeType) === 33 || (a == null ? undefined : a.nodeType) === 10) {
                            const r = v.getFlowNode(a);
                            if (r && t.symbol.getDeclarations().every(e => {
                              if (e.type === 2) {
                                return true;
                              }
                              const t = v.getFlowNode(e.node);
                              return !!t && ts.getFlowNodeReachability(t, r, true) !== K.Reachability.Reachable;
                            })) {
                              let r = n;
                              if (t.symbol.isInitiallyUnbound()) {
                                r = H.UnboundType.create();
                              }
                              return qa(e, a, {
                                targetSymbolId: t.symbol.id,
                                typeAtStart: {
                                  type: r
                                }
                              });
                            }
                          }
                        }
                        return;
                      }(e, p, m);
                      if (t == null ? undefined : t.type) {
                        s = t.type;
                        n = s;
                        o = !!t.isIncomplete;
                      }
                    }
                    const d = qa(e, undefined, {
                      targetSymbolId: r.id,
                      typeAtStart: {
                        type: n,
                        isIncomplete: o
                      },
                      skipConditionalNarrowing: !!(t & 256)
                    });
                    if (d.type) {
                      s = d.type;
                    }
                    if (d.isIncomplete) {
                      i = true;
                    }
                  }
                  s = Rt(e, s, t);
                  if (t & 256) {
                    s = zt(e, s, !!u.includesVariableDecl);
                  }
                  if (H.isTypeVar(s) && !s.shared.isSynthesized) {
                    s = Vt(e, s, t);
                  }
                  s = Mt(e, s, t, !!u.includesVariableDecl);
                } else {
                  if (a === 'reveal_type' || a === 'reveal_locals') {
                    s = H.AnyType.create();
                  } else {
                    kt(d.DiagnosticRule.reportUndefinedVariable, g.LocMessage.symbolIsUndefined().format({
                      name: a
                    }), e);
                    s = H.UnknownType.create();
                  }
                }
                if (H.isParamSpec(s) && s.priv.scopeId && t & 32) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.paramSpecContext(), e);
                  s = H.UnknownType.create();
                }
                s = Ut(s, t);
                if (!(t & 256)) {
                  Ge(s, e);
                }
                if (t & 128) {
                  if (!(t & 1024)) {
                    if (H.isInstantiableClass(s) && H.ClassType.isBuiltIn(s, 'Generic')) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.genericNotAllowed(), e);
                    }
                  }
                }
                return {
                  type: s,
                  isIncomplete: i
                };
              }(e, t);
              break;
            case 35:
              s = function (e, t) {
                var n;
                var a;
                let r = 2;
                r |= t & 567556;
                if (t & 128) {
                  const t = e.d.member.d.value;
                  if (t === 'args' || t === 'kwargs') {
                    r |= 33554432;
                  }
                }
                const s = qe(e.d.leftExpr, r);
                if (Z.isTypeAliasPlaceholder(s.type)) {
                  return {
                    type: H.UnknownType.create(true),
                    isIncomplete: true
                  };
                }
                const i = Bt(e, s, {
                  method: 'get'
                }, t | 2);
                if (_.isCodeFlowSupportedForReference(e)) {
                  Fe(e, {
                    ...i,
                    isIncomplete: true
                  }, t);
                  Fe(e.d.member, {
                    ...i,
                    isIncomplete: true
                  }, t);
                  let n = i.type;
                  let a = !!i.isIncomplete;
                  if (H.isUnbound(n)) {
                    const t = Pt(s.type);
                    let r;
                    if (H.isInstantiableClass(t)) {
                      r = Z.lookUpClassMember(t, e.d.member.d.value, 1);
                    } else {
                      if (H.isClassInstance(t)) {
                        r = Z.lookUpObjectMember(t, e.d.member.d.value, 1);
                      }
                    }
                    if (r) {
                      n = Tr(r);
                      a = false;
                    }
                  }
                  const r = qa(e, undefined, {
                    targetSymbolId: L.indeterminateSymbolId,
                    typeAtStart: {
                      type: n,
                      isIncomplete: a
                    },
                    skipConditionalNarrowing: !!(t & 256)
                  });
                  if (r.type) {
                    i.type = r.type;
                  }
                  if (r.isIncomplete) {
                    i.isIncomplete = true;
                  }
                  i.type = Rt(e, i.type, t);
                  i.type = Mt(e, i.type, t, false);
                }
                if (s.isIncomplete) {
                  i.isIncomplete = true;
                }
                let o = i.isIncomplete;
                if (H.isInstantiableClass(i.type) && !i.type.priv.includeSubclasses || ((n = i.type.props) === null || n === undefined ? undefined : n.specialForm)) {
                  const t = M.getParentNodeOfType(e, 1);
                  if (t && ((a = t == null ? undefined : t.parent) === null || a === undefined ? undefined : a.nodeType) === 9) {
                    o = true;
                  }
                }
                if (!o) {
                  Un(v.getFileInfo(e).diagnosticRuleSet.reportUnknownMemberType, d.DiagnosticRule.reportUnknownMemberType, e.d.member, i.type, e, false);
                }
                Fe(e.d.member, i, t);
                return i;
              }(e, t);
              break;
            case 27:
              s = function (e, t = 0) {
                const n = qe(e.d.leftExpr, t | 2);
                if (t & 128 && e.d.leftExpr.nodeType === 48) {
                  kt(d.DiagnosticRule.reportIndexIssue, g.LocMessage.stringNotSubscriptable(), e.d.leftExpr);
                }
                if (!(t & 4)) {
                  let a = !!(t & 32768);
                  if (a) {
                    const t = M.getExecutionScopeNode(e);
                    if ((t == null ? undefined : t.nodeType) === 36) {
                      a = false;
                    }
                  }
                  if (!a) {
                    const t = v.getFileInfo(e);
                    if (H.isInstantiableClass(n.type) && H.ClassType.isBuiltIn(n.type) && !n.type.priv.aliasName) {
                      const a = Y.get(n.type.shared.fullName);
                      if (a !== undefined && u.PythonVersion.isLessThan(t.executionEnvironment.pythonVersion, a) && !t.isStubFile) {
                        kt(d.DiagnosticRule.reportIndexIssue, g.LocMessage.classNotRuntimeSubscriptable().format({
                          name: n.type.priv.aliasName || n.type.shared.name
                        }), e.d.leftExpr);
                      }
                    }
                  }
                }
                const a = $t(e, n, {
                  method: 'get'
                }, t);
                if (_.isCodeFlowSupportedForReference(e)) {
                  let r = !H.isAny(n.type);
                  Dt(n.type, undefined, e => {
                    if (!H.isClassInstance(e) || !H.ClassType.isBuiltIn(e) && !H.ClassType.isTypedDictClass(e)) {
                      r = false;
                    }
                  });
                  if (r) {
                    Fe(e, {
                      ...a,
                      isIncomplete: true
                    }, t);
                    const r = qa(e, undefined, {
                      targetSymbolId: L.indeterminateSymbolId,
                      typeAtStart: {
                        type: a.type,
                        isIncomplete: !!n.isIncomplete || !!a.isIncomplete
                      },
                      skipConditionalNarrowing: !!(t & 256)
                    });
                    if (r.type) {
                      a.type = r.type;
                    }
                    if (r.isIncomplete) {
                      a.isIncomplete = true;
                    }
                  }
                }
                if (n.isIncomplete) {
                  a.isIncomplete = true;
                }
                return a;
              }(e, t);
              break;
            case 9:
              s = er(e, () => function (e, t, n) {
                var a;
                let r;
                if (t & 256 && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'type') {
                  const t = new p.DiagnosticAddendum();
                  t.addMessage(g.LocAddendum.useTypeInstead());
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeCallNotAllowed() + t.getString(), e);
                }
                r = e.d.leftExpr.nodeType === 33 ? function (e, t) {
                  l.assert(e.d.leftExpr.nodeType === 33);
                  const n = H.FunctionType.createSynthesizedInstance('');
                  n.shared.declaredReturnType = t ? t.expectedType : H.UnknownType.create();
                  let a = false;
                  e.d.args.forEach((e, t) => {
                    const r = qe(e.d.valueExpr);
                    if (r.isIncomplete) {
                      a = true;
                    }
                    H.FunctionType.addParam(n, H.FunctionParam.create(0, r.type, H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `p${t.toString()}`));
                  });
                  const r = e.d.leftExpr.d.params;
                  if (r.length > 0) {
                    const e = r[r.length - 1];
                    if (e.d.category === 0 && !e.d.name) {
                      H.FunctionType.addPositionOnlyParamSeparator(n);
                    }
                  }
                  function s() {
                    return qe(e.d.leftExpr, 2, Z.makeInferenceContext(n));
                  }
                  let i = a || ar(e) || (t == null ? undefined : t.isTypeIncomplete) ? nr(e.d.leftExpr, s) : s();
                  if (i.typeErrors) {
                    i = qe(e.d.leftExpr, 2);
                  }
                  return i;
                }(e, n) : qe(e.d.leftExpr, t & 4 | 2);
                const s = M.getArgsByRuntimeOrder(e).map(e => ({
                  valueExpression: e.d.valueExpr,
                  argCategory: e.d.argCategory,
                  node: e,
                  name: e.d.name
                }));
                let i = {
                  type: H.UnknownType.create()
                };
                r.type = tr(r.type, e);
                if (Z.isTypeAliasPlaceholder(r.type)) {
                  i.isIncomplete = true;
                } else {
                  if (e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'super') {
                    i = function (e) {
                      var t;
                      var n;
                      var a;
                      if (e.d.args.length > 2) {
                        kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.superCallArgCount(), e.d.args[2]);
                      }
                      const r = M.getEnclosingFunctionEvaluationScope(e);
                      const s = r ? M.getEnclosingClass(r) : undefined;
                      const i = s ? (t = ca(s)) === null || t === undefined ? undefined : t.classType : undefined;
                      let o;
                      if (e.d.args.length > 0) {
                        o = qe(e.d.args[0].d.valueExpr).type;
                        const t = Pt(o);
                        if (!H.isAnyOrUnknown(t) && !H.isInstantiableClass(t) && !Z.isMetaclassInstance(t)) {
                          kt(d.DiagnosticRule.reportArgumentType, g.LocMessage.superCallFirstArg().format({
                            type: Yr(o)
                          }), e.d.args[0].d.valueExpr);
                        }
                      } else {
                        if (i) {
                          o = i ?? H.UnknownType.create();
                          if (r) {
                            const t = x.getFunctionInfoFromDecorators(es, r, true);
                            if ((t == null ? undefined : t.flags) & 4) {
                              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.superCallZeroArgFormStaticMethod(), e.d.leftExpr);
                            }
                          }
                        } else {
                          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.superCallZeroArgForm(), e.d.leftExpr);
                          o = H.UnknownType.create();
                        }
                      }
                      const l = Pt(o);
                      let p;
                      let c;
                      if (e.d.args.length > 1) {
                        p = qe(e.d.args[1].d.valueExpr).type;
                        const t = Pt(p);
                        let n = false;
                        if (!H.isAnyOrUnknown(t)) {
                          if (H.isClassInstance(t)) {
                            if (H.isInstantiableClass(l)) {
                              if (!Z.derivesFromClassRecursive(H.ClassType.cloneAsInstantiable(t), l, true)) {
                                n = true;
                              }
                            }
                            c = t;
                          } else {
                            if (H.isInstantiableClass(t)) {
                              if (H.isInstantiableClass(l)) {
                                if (!H.ClassType.isBuiltIn(l, 'type') && !Z.derivesFromClassRecursive(t, l, true)) {
                                  n = true;
                                }
                              }
                              c = t;
                            } else {
                              n = true;
                            }
                          }
                        }
                        if (n) {
                          kt(d.DiagnosticRule.reportArgumentType, g.LocMessage.superCallSecondArg().format({
                            type: Yr(o)
                          }), e.d.args[1].d.valueExpr);
                          return {
                            type: H.UnknownType.create()
                          };
                        }
                      } else {
                        if (i) {
                          c = H.ClassType.cloneAsInstance(i);
                          const t = M.getEnclosingFunction(e);
                          let n;
                          if (t) {
                            const a = va(t);
                            if (a) {
                              const t = a.functionType;
                              if ((H.FunctionType.isClassMethod(t) || H.FunctionType.isConstructorMethod(t) || H.FunctionType.isInstanceMethod(t)) && t.shared.parameters.length > 0 && H.FunctionParam.isTypeDeclared(t.shared.parameters[0])) {
                                let a = H.FunctionType.getParamType(t, 0);
                                const r = M.getTypeVarScopesForNode(e);
                                a = Z.makeTypeVarsBound(a, r);
                                n = Pt(a);
                              }
                            }
                          }
                          if (c && n) {
                            const e = Z.getTypeCondition(n);
                            if (e) {
                              c = Z.addConditionToType(c, e);
                            } else {
                              if (H.isClass(n)) {
                                c = n;
                              }
                            }
                          }
                        }
                      }
                      let u = true;
                      if (e.d.args.length <= 1) {
                        const t = M.getEnclosingFunction(e);
                        if (t) {
                          const e = va(t);
                          if (e && (H.FunctionType.isStaticMethod(e.functionType) || H.FunctionType.isConstructorMethod(e.functionType) || H.FunctionType.isClassMethod(e.functionType))) {
                            u = false;
                          }
                        }
                      }
                      const m = e.parent;
                      if ((m == null ? undefined : m.nodeType) === 35) {
                        const e = m.d.member.d.value;
                        let t = H.isClass(l) ? l : undefined;
                        let r = false;
                        if (c && H.ClassType.isProtocolClass(c) && t && !H.ClassType.isSameGenericClass(H.TypeBase.isInstance(c) ? H.ClassType.cloneAsInstantiable(c) : c, t)) {
                          r = true;
                          t = undefined;
                        }
                        if (c) {
                          c = Z.selfSpecializeClass(c, {
                            useBoundTypeVars: true
                          });
                        }
                        const s = c ? Z.lookUpClassMember(c, e, 0, t) : undefined;
                        let i;
                        let o;
                        if (s && H.isInstantiableClass(s.classType)) {
                          i = s.classType;
                          if (r) {
                            i = H.ClassType.cloneIncludeSubclasses(i);
                          }
                        } else {
                          i = !t || H.isAnyOrUnknown(t) || Z.derivesFromAnyOrUnknown(t) ? H.UnknownType.create() : (n = Ae == null ? undefined : Ae.objectClass) !== null && n !== undefined ? n : H.UnknownType.create();
                        }
                        if (c) {
                          if (p) {
                            if (H.isTypeVar(p)) {
                              o = Z.convertToInstance(p);
                            }
                          } else {
                            o = H.TypeBase.cloneForCondition(H.TypeVarType.cloneAsBound(Z.synthesizeTypeVarForSelfCls(H.ClassType.cloneIncludeSubclasses(c, false), false)), (a = c.props) === null || a === undefined ? undefined : a.condition);
                          }
                        }
                        return {
                          type: u ? Z.convertToInstance(i, false) : i,
                          bindToSelfType: o
                        };
                      }
                      if (H.isInstantiableClass(l)) {
                        if (c) {
                          let e;
                          if (H.ClassType.isSameGenericClass(H.TypeBase.isInstance(c) ? H.ClassType.cloneAsInstantiable(c) : c, l)) {
                            if (c.shared.baseClasses.length > 0) {
                              e = c.shared.baseClasses[0];
                            }
                          } else {
                            const t = c.shared.baseClasses.findIndex(e => H.isClass(e) && H.ClassType.isSameGenericClass(e, l));
                            if (t >= 0 && t < c.shared.baseClasses.length - 1) {
                              e = c.shared.baseClasses[t + 1];
                            }
                          }
                          if (e) {
                            if (H.isInstantiableClass(e)) {
                              e = Z.specializeForBaseClass(c, e);
                            }
                            return {
                              type: u ? Z.convertToInstance(e) : e
                            };
                          }
                          if ((Ae == null ? undefined : Ae.typeClass) && H.isInstantiableClass(Ae.typeClass)) {
                            return {
                              type: u ? lt() : Z.convertToInstance(Ae.typeClass)
                            };
                          }
                        } else {
                          if (l.shared.mro.some(e => H.isAnyOrUnknown(e))) {
                            return {
                              type: H.UnknownType.create()
                            };
                          }
                          const e = l.shared.baseClasses;
                          if (e.length > 0) {
                            const t = e[0];
                            if (H.isInstantiableClass(t)) {
                              return {
                                type: u ? H.ClassType.cloneAsInstance(t) : t
                              };
                            }
                          }
                        }
                      }
                      return {
                        type: H.UnknownType.create()
                      };
                    }(e);
                  } else {
                    if (H.isAnyOrUnknown(r.type) && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'reveal_type') {
                      i = tn(e, n);
                    } else {
                      if (H.isFunction(r.type) && H.FunctionType.isBuiltIn(r.type, 'reveal_type')) {
                        i = tn(e, n);
                      } else {
                        if (H.isFunction(r.type) && H.FunctionType.isBuiltIn(r.type, 'assert_type')) {
                          i = function (e, t) {
                            if (e.d.args.length !== 2 || e.d.args[0].d.argCategory !== 0 || e.d.args[0].d.name !== undefined || e.d.args[0].d.argCategory !== 0 || e.d.args[1].d.name !== undefined) {
                              kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.assertTypeArgs(), e);
                              return {
                                type: H.UnknownType.create()
                              };
                            }
                            const n = qe(e.d.args[0].d.valueExpr, undefined, t);
                            if (n.isIncomplete) {
                              return {
                                type: H.UnknownType.create(true),
                                isIncomplete: true
                              };
                            }
                            const a = Z.convertToInstance($a(en(e.d.args[1]), {
                              typeExpression: true
                            }).type);
                            const r = Qe(n.type);
                            if (!H.isTypeSame(a, r, {
                              treatAnySameAsUnknown: true,
                              ignorePseudoGeneric: true,
                              ignoreConditions: true
                            })) {
                              const t = Hr(n.type, a, {
                                expandTypeAlias: true
                              });
                              kt(d.DiagnosticRule.reportAssertTypeFailure, g.LocMessage.assertTypeTypeMismatch().format({
                                expected: t.destType,
                                received: t.sourceType
                              }), e.d.args[0].d.valueExpr);
                            }
                            return {
                              type: n.type
                            };
                          }(e, n);
                        } else {
                          if (H.isClass(r.type) && H.ClassType.isBuiltIn(r.type, 'TypeForm')) {
                            i = function (e, t) {
                              var n;
                              if (e.d.args.length !== 1 || e.d.args[0].d.argCategory !== 0 || e.d.args[0].d.name !== undefined) {
                                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.typeFormArgs(), e);
                                return {
                                  type: H.UnknownType.create()
                                };
                              }
                              const a = $a(en(e.d.args[0]), {
                                typeFormArg: Zr(e),
                                noNonTypeSpecialForms: true,
                                typeExpression: true
                              });
                              if (!a.typeErrors && ((n = a.type.props) === null || n === undefined ? undefined : n.typeForm)) {
                                a.type = Z.convertToInstance(H.ClassType.specialize(t, [Z.convertToInstance(a.type.props.typeForm)]));
                              }
                              return a;
                            }(e, r.type);
                          } else {
                            if (H.isAnyOrUnknown(r.type) && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'reveal_locals') {
                              if (e.d.args.length === 0) {
                                i.type = function (e) {
                                  let t;
                                  let n = e;
                                  while (n && (t = V.getScopeForNode(n), !t || t.type === 1)) {
                                    n = n.parent;
                                  }
                                  const a = [];
                                  if (t) {
                                    t.symbolTable.forEach((e, t) => {
                                      if (!e.isIgnoredForProtocolMatch()) {
                                        const n = cr(e);
                                        a.push(g.LocAddendum.typeOfSymbol().format({
                                          name: t,
                                          type: Yr(n, {
                                            expandTypeAlias: true
                                          })
                                        }));
                                      }
                                    });
                                  }
                                  if (a.length > 0) {
                                    bt(a.join('\n'), e);
                                  } else {
                                    bt(g.LocMessage.revealLocalsNone(), e);
                                  }
                                  return pt();
                                }(e);
                              } else {
                                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.revealLocalsArgs(), e);
                              }
                            } else {
                              const t = pn(e, s, r, undefined, false, n);
                              i.type = (a = t.returnType) !== null && a !== undefined ? a : H.UnknownType.create();
                              if (t.argumentErrors) {
                                i.typeErrors = true;
                              } else {
                                i.overloadsUsedForCall = t.overloadsUsedForCall;
                              }
                              if (t.isTypeIncomplete) {
                                i.isIncomplete = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (r.isIncomplete) {
                    i.isIncomplete = true;
                  }
                }
                if (!ar(e) && !r.isIncomplete) {
                  if (!H.isInstantiableClass(r.type) || !H.ClassType.isBuiltIn(r.type, 'TypeVar') || !v.getFileInfo(e).isTypingStubFile) {
                    s.forEach(e => {
                      if (e.valueExpression && e.valueExpression.nodeType !== 48 && !De(e.valueExpression)) {
                        qe(e.valueExpression);
                      }
                    });
                  }
                }
                if (t & 256) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeAnnotationCall(), e);
                  i = {
                    type: H.UnknownType.create()
                  };
                }
                return i;
              }(e, t, n));
              break;
            case 52:
              s = q.getTypeOfTuple(es, e, t, n);
              break;
            case 14:
              s = function (e, t) {
                let n;
                if (e.d.constType === 26) {
                  if (Ae == null ? undefined : Ae.noneTypeClass) {
                    n = t & 128 ? Ae.noneTypeClass : Z.convertToInstance(Ae.noneTypeClass);
                    if (Zr(e)) {
                      n = H.TypeBase.cloneWithTypeForm(n, Z.convertToInstance(n));
                    }
                  }
                } else {
                  if (e.d.constType === 33 || e.d.constType === 15 || e.d.constType === 9) {
                    n = Ya(e, 'bool');
                    if (n && H.isClassInstance(n)) {
                      if (e.d.constType === 33) {
                        n = H.ClassType.cloneWithLiteral(n, true);
                      } else {
                        if (e.d.constType === 15) {
                          n = H.ClassType.cloneWithLiteral(n, false);
                        }
                      }
                    }
                  }
                }
                return {
                  type: n ?? H.UnknownType.create()
                };
              }(e, t);
              break;
            case 48:
              if (t & 8) {
                i = false;
              }
              s = function (e, t) {
                var n;
                let a;
                if (t & 8 && !(t & 1073741824)) {
                  return We(e, t);
                }
                const r = e => !!(e.d.token.flags & 32);
                const s = e.d.strings.findIndex(e => !r(e));
                const i = e.d.strings.findIndex(e => r(e));
                if (s >= 0 && i >= 0) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.mixingBytesAndStr(), e.d.strings[Math.max(i, s)]);
                  return {
                    type: H.UnknownType.create()
                  };
                }
                const o = i >= 0;
                let l = true;
                let p = false;
                e.d.strings.forEach(e => {
                  const t = Ke(e);
                  if (t.isIncomplete) {
                    p = true;
                  }
                  let n = false;
                  if (H.isClassInstance(t.type) && (H.ClassType.isBuiltIn(t.type, 'str') && t.type.priv.literalValue !== undefined || H.ClassType.isBuiltIn(t == null ? undefined : t.type, 'LiteralString'))) {
                    n = true;
                  }
                  if (!n) {
                    l = false;
                  }
                });
                if (e.d.strings.some(e => e.nodeType === 30)) {
                  if (l) {
                    const t = ct(e, 'LiteralString');
                    if (t && H.isInstantiableClass(t)) {
                      a = {
                        type: H.ClassType.cloneAsInstance(t)
                      };
                    }
                  }
                  if (!a) {
                    a = {
                      type: Ya(e, o ? 'bytes' : 'str'),
                      isIncomplete: p
                    };
                  }
                } else {
                  a = {
                    type: qn(e, o ? 'bytes' : 'str', e.d.strings.map(e => e.d.value).join('')),
                    isIncomplete: p
                  };
                }
                if (e.d.strings.length !== 1 || e.d.strings[0].nodeType !== 49 || !Zr(e)) {
                  return a;
                }
                const c = e.d.strings[0];
                const u = c.d.token.flags;
                const m = 256;
                if (u & 108 || c.d.token.escapedValue.length >= m) {
                  return a;
                }
                const y = We(e, t);
                if ((n = y.type.props) === null || n === undefined ? undefined : n.typeForm) {
                  a.type = H.TypeBase.cloneWithTypeForm(a.type, y.type.props.typeForm);
                }
                return a;
              }(e, t);
              break;
            case 40:
              s = function (e, t) {
                t = e.d.isImaginary ? {
                  type: Ya(e, 'complex')
                } : e.d.isInteger ? {
                  type: qn(e, 'int', e.d.value)
                } : {
                  type: Ya(e, 'float')
                };
                return t;
              }(e, s);
              break;
            case 21:
              s = function (e, t, n) {
                var a;
                var r;
                if (e & 1) {
                  t = {
                    type: H.AnyType.create(true)
                  };
                } else {
                  if (e & 256 && !(e & 65536)) {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisContext(), n);
                    t = {
                      type: H.UnknownType.create()
                    };
                  } else {
                    t = {
                      type: (r = (a = Ya(n, 'EllipsisType')) !== null && a !== undefined ? a : Ya(n, 'ellipsis')) !== null && r !== undefined ? r : H.AnyType.create()
                    };
                  }
                }
                return t;
              }(t, s, e);
              break;
            case 55:
              s = F.getTypeOfUnaryOperation(es, e, t, n);
              break;
            case 7:
              {
                let a = t;
                if (i && e.d.operator !== 6) {
                  a &= -129;
                }
                s = F.getTypeOfBinaryOperation(es, e, a, n);
                break;
              }
            case 5:
              s = F.getTypeOfAugmentedAssignment(es, e, n);
              break;
            case 34:
            case 45:
              s = function (e, t, n) {
                var a;
                if (t & 256 && e.nodeType === 34 && ((a = e.parent) === null || a === undefined ? undefined : a.nodeType) !== 1) {
                  const t = new p.DiagnosticAddendum();
                  t.addMessage(g.LocAddendum.useListInstead());
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.listInAnnotation() + t.getString(), e);
                }
                t &= -393;
                let r;
                let s = n == null ? undefined : n.expectedType;
                if (n && H.isUnion(n.expectedType)) {
                  let a;
                  let r;
                  Z.doForEachSubtype(n.expectedType, n => {
                    if (r && !r.typeErrors) {
                      return;
                    }
                    const s = nr(e, () => Fn(e, t, Z.makeInferenceContext(n)));
                    if (s && Ir(n, s.type) && (!r || r.typeErrors && !s.typeErrors)) {
                      a = n;
                      r = s;
                    }
                  }, true);
                  s = a;
                }
                if (s) {
                  const n = Fn(e, t, Z.makeInferenceContext(s));
                  if (n && !n.typeErrors) {
                    return n;
                  }
                  r = n == null ? undefined : n.expectedTypeDiagAddendum;
                }
                const i = function (e, t, n) {
                  const a = e.nodeType === 34 ? 'list' : 'set';
                  const r = e.nodeType === 45;
                  let s = false;
                  let i = false;
                  let o = false;
                  let l = [];
                  e.d.items.forEach((e, a) => {
                    let s;
                    s = e.nodeType !== 11 || e.d.isGenerator ? qe(e, t | 268435456) : Rn(e, t | 268435456);
                    s.type = Z.stripTypeForm(Ut(s.type, t, true));
                    if (s.isIncomplete) {
                      i = true;
                    }
                    if (s.typeErrors) {
                      o = true;
                    }
                    if (n || a < ae) {
                      l.push(s.type);
                    }
                    if (!!r && !s.isIncomplete && !s.typeErrors) {
                      Mn(e, s.type, false);
                    }
                  });
                  l = l.map(e => $e(e));
                  let p = n ? H.AnyType.create() : H.UnknownType.create();
                  if (l.length > 0) {
                    const t = v.getFileInfo(e);
                    p = a === 'list' && t.diagnosticRuleSet.strictListInference || a === 'set' && t.diagnosticRuleSet.strictSetInference || n ? H.combineTypes(l, {
                      maxSubtypeCount: K.maxSubtypesForInferredType
                    }) : Z.areTypesSame(l, {
                      ignorePseudoGeneric: true
                    }) ? l[0] : p;
                  } else {
                    s = true;
                  }
                  const d = Za(e, a);
                  const c = H.isInstantiableClass(d) ? H.ClassType.cloneAsInstance(H.ClassType.specialize(d, [p], true, undefined, undefined, s)) : H.UnknownType.create();
                  if (i && Z.getContainerDepth(c) > K.maxInferredContainerDepth) {
                    return {
                      type: H.UnknownType.create()
                    };
                  }
                  return {
                    type: c,
                    isIncomplete: i,
                    typeErrors: o
                  };
                }(e, t, !!(n == null ? undefined : n.expectedType));
                return {
                  ...i,
                  expectedTypeDiagAddendum: r
                };
              }(e, t, n);
              break;
            case 46:
              s = function (e) {
                if (!ar(e)) {
                  if (e.d.startValue) {
                    qe(e.d.startValue);
                  }
                  if (e.d.endValue) {
                    qe(e.d.endValue);
                  }
                  if (e.d.stepValue) {
                    qe(e.d.stepValue);
                  }
                }
                return {
                  type: Ya(e, 'slice')
                };
              }(e);
              break;
            case 6:
              s = function (e, t, n) {
                if (t & 256) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.awaitNotAllowed(), e);
                  return {
                    type: H.UnknownType.create()
                  };
                }
                const a = n ? Sa(e, n.expectedType, false, false) : undefined;
                const r = qe(e.d.expr, t, Z.makeInferenceContext(a));
                const s = {
                  type: rt(r.type, e.d.expr),
                  isIncomplete: r.isIncomplete,
                  typeErrors: r.typeErrors
                };
                if (r.isIncomplete) {
                  s.isIncomplete = true;
                }
                return s;
              }(e, t, n);
              break;
            case 51:
              s = F.getTypeOfTernaryOperation(es, e, t, n);
              break;
            case 11:
              s = function (e, t, n) {
                let a = false;
                let r = false;
                let s = e.d.forIfNodes.some((e, t) => e.nodeType === 12 && !!e.d.isAsync || t > 0 && M.containsAwaitNode(e));
                let i = H.UnknownType.create();
                if (M.containsAwaitNode(e.d.expr)) {
                  s = true;
                }
                const o = ct(e, s ? 'AsyncGenerator' : 'Generator');
                const l = En(e, o, n);
                const p = Rn(e, t | 268435456, l);
                if (p.isIncomplete) {
                  a = true;
                }
                if (p.typeErrors) {
                  r = true;
                }
                let d = p.type;
                if (!l || !Z.containsLiteralType(l)) {
                  d = $e(d);
                }
                if (o && H.isInstantiableClass(o)) {
                  i = H.ClassType.cloneAsInstance(H.ClassType.specialize(o, s ? [d, pt()] : [d, pt(), pt()]));
                }
                return {
                  type: i,
                  isIncomplete: a,
                  typeErrors: r
                };
              }(e, t, n);
              break;
            case 18:
              s = function (e, t, n) {
                var a;
                if (t & 256 && ((a = e.parent) === null || a === undefined ? undefined : a.nodeType) !== 1) {
                  const t = new p.DiagnosticAddendum();
                  t.addMessage(g.LocAddendum.useDictInstead());
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.dictInAnnotation() + t.getString(), e);
                }
                let r = n == null ? undefined : n.expectedType;
                if (n && H.isUnion(n.expectedType)) {
                  let a;
                  let s;
                  Z.doForEachSubtype(n.expectedType, n => {
                    if (s && !s.typeErrors) {
                      return;
                    }
                    const r = nr(e, () => Dn(e, t, Z.makeInferenceContext(n)));
                    if (r && Ir(n, r.type) && (!s || s.typeErrors && !r.typeErrors)) {
                      a = n;
                      s = r;
                    }
                  }, true);
                  r = a;
                }
                let s;
                if (r) {
                  s = new p.DiagnosticAddendum();
                  const n = Dn(e, t, Z.makeInferenceContext(r), s);
                  if (n) {
                    return n;
                  }
                }
                const i = function (e, t, n) {
                  const a = n ? H.AnyType.create() : H.UnknownType.create();
                  let r = a;
                  let s = a;
                  const i = [];
                  const o = [];
                  let l = false;
                  let p = false;
                  let d = false;
                  const c = Nn(e, t, i, o, n, false);
                  if (c.isIncomplete) {
                    p = true;
                  }
                  if (c.typeErrors) {
                    d = true;
                  }
                  const u = i.map(e => Z.stripTypeForm(Ut($e(e.type), t, true)));
                  const m = o.map(e => Z.stripTypeForm(Ut($e(e.type), t, true)));
                  r = u.length > 0 ? H.combineTypes(u) : a;
                  if (m.length > 0) {
                    s = v.getFileInfo(e).diagnosticRuleSet.strictDictionaryInference || n ? H.combineTypes(m) : Z.areTypesSame(m, {
                      ignorePseudoGeneric: true
                    }) ? m[0] : a;
                  } else {
                    s = a;
                    l = true;
                  }
                  const y = Za(e, 'dict');
                  const g = H.isInstantiableClass(y) ? H.ClassType.cloneAsInstance(H.ClassType.specialize(y, [r, s], true, undefined, undefined, l)) : H.UnknownType.create();
                  if (p && Z.getContainerDepth(g) > K.maxInferredContainerDepth) {
                    return {
                      type: H.UnknownType.create()
                    };
                  }
                  return {
                    type: g,
                    isIncomplete: p,
                    typeErrors: d
                  };
                }(e, t, !!(n == null ? undefined : n.expectedType));
                return {
                  ...i,
                  expectedTypeDiagAddendum: s
                };
              }(e, t, n);
              break;
            case 33:
              s = function (e, t) {
                let n;
                let a = [];
                if (t) {
                  Z.mapSubtypes(t.expectedType, e => {
                    if (H.isFunction(e)) {
                      a.push(e);
                    }
                    if (H.isClassInstance(e)) {
                      const t = tt(e, '__call__');
                      if (t && H.isFunction(t)) {
                        a.push(t);
                      }
                    }
                  });
                }
                if (a.length > 1) {
                  a = Z.sortTypes(a);
                  for (const r of a) {
                    if (!zn(e, r, t, true).typeErrors) {
                      n = r;
                      break;
                    }
                  }
                }
                if (!n && a.length > 0) {
                  n = a[0];
                }
                return zn(e, n, t, false);
              }(e, n);
              break;
            case 3:
              s = qe(e.d.rightExpr, t, n);
              Nt(e.d.leftExpr, s, e.d.rightExpr, true, true);
              break;
            case 4:
              if (t & 256) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.walrusNotAllowed(), e);
              }
              s = qe(e.d.rightExpr, t, n);
              Nt(e.d.name, s, e.d.rightExpr, true);
              break;
            case 60:
              s = function (e) {
                let t;
                let n;
                let a = false;
                const r = M.getEnclosingFunction(e);
                if (r) {
                  const a = va(r);
                  if (a) {
                    let s = H.FunctionType.getEffectiveReturnType(a.functionType);
                    if (s) {
                      const a = M.getTypeVarScopesForNode(e);
                      s = Z.makeTypeVarsBound(s, a);
                      t = Z.getGeneratorYieldType(s, !!r.d.isAsync);
                      const i = Z.getGeneratorTypeArgs(s);
                      if (i && i.length >= 2) {
                        n = Z.makeTypeVarsBound(i[1], a);
                      }
                    }
                  }
                }
                if (e.d.expr) {
                  if (qe(e.d.expr, undefined, Z.makeInferenceContext(t)).isIncomplete) {
                    a = true;
                  }
                }
                return {
                  type: n || H.UnknownType.create(),
                  isIncomplete: a
                };
              }(e);
              break;
            case 61:
              s = function (e) {
                const t = qe(e.d.expr);
                const n = t.type;
                const a = Z.mapSubtypes(n, n => {
                  let s = Z.getGeneratorTypeArgs(n);
                  if (s) {
                    if (s.length >= 2) {
                      return s[2];
                    } else {
                      return H.UnknownType.create();
                    }
                  }
                  if (H.isClassInstance(n) && H.ClassType.isBuiltIn(n, 'Coroutine')) {
                    return H.UnknownType.create();
                  }
                  const i = it(t, false, e)?.type ?? H.UnknownType.create();
                  s = Z.getGeneratorTypeArgs(i);
                  if (s && s.length >= 2) {
                    return s[2];
                  } else {
                    return H.UnknownType.create();
                  }
                });
                return {
                  type: a
                };
              }(e);
              break;
            case 56:
              s = function (e, t, n) {
                var a;
                let r;
                let s;
                if (n) {
                  const t = Za(e, 'Iterable');
                  if (t && H.isInstantiableClass(t)) {
                    s = H.ClassType.cloneAsInstance(H.ClassType.specialize(t, [n.expectedType]));
                  }
                }
                const i = qe(e.d.expr, t, Z.makeInferenceContext(s));
                const o = i.type;
                if (t & 64 || !H.isTypeVarTuple(o) || o.priv.isUnpacked) {
                  if (t & 4194304 && H.isInstantiableClass(o) && H.ClassType.isBuiltIn(o, 'tuple')) {
                    r = {
                      type: H.ClassType.cloneForUnpacked(o)
                    };
                  } else {
                    if (t & 256) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackInAnnotation(), e, e.d.starToken);
                      r = {
                        type: H.UnknownType.create()
                      };
                    } else {
                      const t = (a = st(i, false, e)) !== null && a !== undefined ? a : {
                        type: H.UnknownType.create(!!i.isIncomplete),
                        isIncomplete: i.isIncomplete
                      };
                      r = {
                        type: t.type,
                        typeErrors: i.typeErrors,
                        unpackedType: o,
                        isIncomplete: t.isIncomplete
                      };
                    }
                  }
                } else {
                  r = {
                    type: H.TypeVarType.cloneForUnpacked(o)
                  };
                }
                return r;
              }(e, t, n);
              break;
            case 54:
              s = qe(e.d.annotation, 33256);
              break;
            case 49:
            case 30:
              s = Ke(e);
              break;
            case 0:
              Qa(e, () => {
                if (e.d.child) {
                  qe(e.d.child);
                }
              });
              s = {
                type: H.UnknownType.create()
              };
              break;
            default:
              l.assertNever(e, `Illegal node type: ${e.nodeType}`);
          }
          if (!s) {
            l.fail(`Unhandled expression type '${M.printExpression(e)}'`);
          }
          if (i) {
            (function (e, t, n) {
              if (e.isIncomplete) {
                return;
              }
              if (t & 64 && H.isTypeVarTuple(e.type) && !e.type.priv.isInUnion) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeVarTupleContext(), n);
                e.type = H.UnknownType.create();
              }
              if (Z.isEffectivelyInstantiable(e.type, {
                honorTypeVarBounds: true
              })) {
                return;
              }
              if (H.isClassInstance(e.type) && H.ClassType.isBuiltIn(e.type, ['EllipsisType', 'ellipsis'])) {
                return;
              }
              if (t & 256) {
                const t = new p.DiagnosticAddendum();
                if (H.isUnion(e.type)) {
                  Z.doForEachSubtype(e.type, e => {
                    if (!Z.isEffectivelyInstantiable(e, {
                      honorTypeVarBounds: true
                    })) {
                      t.addMessage(g.LocAddendum.typeNotClass().format({
                        type: Yr(e)
                      }));
                    }
                  });
                }
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeExpectedClass().format({
                  type: Yr(e.type)
                }) + t.getString(), n);
                e.type = H.UnknownType.create();
              }
              e.typeErrors = true;
            })(s, t, e);
          }
          if (t & 256 && ((a = s.type.props) === null || a === undefined ? undefined : a.typeForm) === undefined) {
            const e = (r = s.type.props) === null || r === undefined ? undefined : r.specialForm;
            if (e && H.ClassType.isBuiltIn(e, 'TypeAliasType')) {
              s.type = H.TypeBase.cloneAsSpecialForm(s.type, undefined);
            }
          }
          return s;
        }(e, t, n);
        if (H.isInstantiableClass(r.type) && r.type.priv.includePromotions && !r.type.priv.includeSubclasses && H.ClassType.isBuiltIn(r.type, 'bytes') && v.getFileInfo(e).diagnosticRuleSet.disableBytesTypePromotions) {
          r = {
            ...r,
            type: H.ClassType.cloneRemoveTypePromotions(r.type)
          };
        }
        if (n) {
          r.type = function (e, t) {
            var n;
            var a;
            var r;
            if (!((n = t.props) === null || n === undefined ? undefined : n.typeForm)) {
              return t;
            }
            let s;
            let i;
            if ((a = t.props) === null || a === undefined ? undefined : a.typeForm) {
              s = t.props.typeForm;
            } else {
              if (H.isClass(t)) {
                if (H.TypeBase.isInstantiable(t)) {
                  if (!H.ClassType.isSpecialBuiltIn(t)) {
                    s = H.ClassType.cloneAsInstance(t);
                  }
                } else {
                  if (H.ClassType.isBuiltIn(t, 'type')) {
                    s = ((r = t.priv.typeArgs) === null || r === undefined ? undefined : r.length) && t.priv.typeArgs.length > 0 ? t.priv.typeArgs[0] : H.UnknownType.create();
                  }
                }
              } else {
                if (H.isTypeVar(t) && H.TypeBase.isInstantiable(t)) {
                  if (!H.isTypeVarTuple(t) || !t.priv.isInUnion) {
                    s = Z.convertToInstance(t);
                  }
                }
              }
            }
            if (!s) {
              return t;
            }
            Z.doForEachSubtype(e, e => {
              if (i || !H.isClassInstance(e) || !H.ClassType.isBuiltIn(e, 'TypeForm')) {
                return;
              }
              if (Ir(e.priv.typeArgs && e.priv.typeArgs.length > 0 ? e.priv.typeArgs[0] : H.UnknownType.create(), s)) {
                i = H.ClassType.specialize(e, [s]);
              }
            });
            if (i != null) {
              return i;
            } else {
              return t;
            }
          }(n.expectedType, r.type);
        }
        Fe(e, r, t, n, e.nodeType !== 4);
        if (e.nodeType === 38 || e.nodeType === 35) {
          r.type = tr(r.type, e);
        }
        if (n && !H.isAnyOrUnknown(n.expectedType) && !H.isNever(n.expectedType) && (be.set(e.id, n.expectedType), !r.isIncomplete && !r.expectedTypeDiagAddendum)) {
          const t = new p.DiagnosticAddendum();
          if (!Ir(n.expectedType, r.type, t, undefined, 0)) {
            r.typeErrors = true;
            r.expectedTypeDiagAddendum = t;
            t.addTextRange(e);
          }
        }
        if (ce) {
          Ce--;
          console.log(`${Jr()}${M.printExpression(e)} (${Qr(e)}): Post ${Yr(r.type)}${r.isIncomplete ? ' Incomplete' : ''}`);
        }
        return r;
      }
      function Ge(e, t) {
        let n = false;
        let a = '';
        if (H.isInstantiableClass(e) && !e.priv.includeSubclasses) {
          n = H.ClassType.isTypeCheckOnly(e);
          a = e.shared.name;
        } else {
          if (H.isFunction(e)) {
            n = H.FunctionType.isTypeCheckOnly(e);
            a = e.shared.name;
          }
        }
        if (n) {
          if (!v.getFileInfo(t).isStubFile) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeCheckOnly().format({
              name: a
            }), t);
          }
        }
      }
      function We(e, t) {
        const n = !!(t & 8);
        let a;
        let r = t | 132;
        if (!(t & 16777216)) {
          r |= 524288;
        }
        r &= -1073741825;
        if (e.d.annotation && t & 256) {
          return qe(e.d.annotation, r);
        }
        if (e.d.strings.length === 1) {
          const t = e.d.strings[0].d.token.flags;
          if (t & 32) {
            if (n) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.annotationBytesString(), e);
            }
            return {
              type: H.UnknownType.create()
            };
          }
          if (t & 8) {
            if (n) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.annotationRawString(), e);
            }
            return {
              type: H.UnknownType.create()
            };
          }
          if (t & 64) {
            if (n) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.annotationFormatString(), e);
            }
            return {
              type: H.UnknownType.create()
            };
          }
          const s = function (e, t) {
            const n = v.getFileInfo(e);
            const a = new f.Parser();
            const r = e.d.strings[0].d.value;
            let s = e.d.strings[0].start;
            if (e.d.strings[0].nodeType === 49) {
              s += e.d.strings[0].d.token.prefixLength + e.d.strings[0].d.token.quoteMarkLength;
            }
            const i = ' '.repeat(s) + r;
            const o = new f.ParseOptions();
            o.isStubFile = n.isStubFile;
            o.pythonVersion = n.executionEnvironment.pythonVersion;
            o.reportErrorsForParsedStringContents = true;
            const l = a.parseTextExpression(i, s, r.length, o, 0, undefined, n.typingSymbolAliases);
            if (l.parseTree) {
              if (!t && l.diagnostics.length > 0) {
                return;
              }
              const n = v.getFileInfo(e);
              l.diagnostics.forEach(t => {
                n.diagnosticSink.addDiagnosticWithTextRange('error', t.message, e);
              });
              l.parseTree.parent = e;
              if (t) {
                e.d.annotation = l.parseTree;
              }
              return l.parseTree;
            }
            return;
          }(e, n);
          if (s) {
            a = nr(n ? undefined : e, () => qe(s, r));
          }
        }
        if (!a) {
          if (n) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.expectedTypeNotString(), e);
          }
          a = {
            type: H.UnknownType.create()
          };
        }
        return a;
      }
      function Ke(e) {
        const t = !!(e.d.token.flags & 32);
        let n;
        let a = false;
        if (e.nodeType === 30) {
          let r = true;
          e.d.fieldExprs.forEach(e => {
            const t = qe(e);
            const n = t.type;
            if (t.isIncomplete) {
              a = true;
            }
            Z.doForEachSubtype(n, e => {
              if (!H.isClassInstance(e) || !H.ClassType.isBuiltIn(e, 'LiteralString') && (!H.ClassType.isBuiltIn(e, 'str') || e.priv.literalValue === undefined)) {
                r = false;
              }
            });
          });
          if (!t && r) {
            const t = ct(e, 'LiteralString');
            if (t && H.isInstantiableClass(t)) {
              n = {
                type: H.ClassType.cloneAsInstance(t),
                isIncomplete: a
              };
            }
          }
          if (!n) {
            n = {
              type: Ya(e, t ? 'bytes' : 'str'),
              isIncomplete: a
            };
            if (H.isClass(n.type) && n.type.priv.includePromotions) {
              n.type = H.ClassType.cloneRemoveTypePromotions(n.type);
            }
          }
        } else {
          n = {
            type: qn(e, t ? 'bytes' : 'str', e.d.value),
            isIncomplete: a
          };
        }
        return n;
      }
      function $e(e) {
        var t;
        var n;
        var a;
        if (H.isUnion(e) && e.priv.subtypes.length > 0 && (((t = e.priv.literalInstances.literalStrMap) === null || t === undefined ? undefined : t.size) === e.priv.subtypes.length || ((n = e.priv.literalInstances.literalIntMap) === null || n === undefined ? undefined : n.size) === e.priv.subtypes.length || ((a = e.priv.literalInstances.literalEnumMap) === null || a === undefined ? undefined : a.size) === e.priv.subtypes.length)) {
          return $e(e.priv.subtypes[0]);
        } else {
          return Z.mapSubtypes(e, e => {
            if (H.isClass(e) && (e.priv.literalValue !== undefined && (e = H.ClassType.cloneWithLiteral(e, undefined)), H.ClassType.isBuiltIn(e, 'LiteralString') && (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass))) {
              let t = H.ClassType.cloneAsInstance(Ae.strClass);
              t = H.TypeBase.cloneForCondition(t, Z.getTypeCondition(e));
              return t;
            }
            return e;
          });
        }
      }
      function He(e, t) {
        return Ze(e, {
          typeVarGetsCurScope: true,
          allowUnpackedTuple: t === 1,
          allowUnpackedTypedDict: t === 2
        });
      }
      function Ze(e, t) {
        var n;
        var a;
        var r;
        const s = v.getFileInfo(e);
        if (s.isTypingStubFile || s.isTypingExtensionsStubFile) {
          const t = function (e) {
            var t;
            if (!e.parent || e.parent.nodeType !== 54) {
              return;
            }
            if (e.parent.d.valueExpr.nodeType !== 38) {
              return;
            }
            const n = e.parent.d.valueExpr;
            const a = n.d.value;
            const r = new Map([['Tuple', {
              alias: 'tuple',
              module: 'builtins'
            }], ['Generic', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Protocol', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Callable', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Type', {
              alias: 'type',
              module: 'builtins'
            }], ['ClassVar', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Final', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Literal', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['TypedDict', {
              alias: '_TypedDict',
              module: 'self'
            }], ['Union', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Optional', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Annotated', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true,
              isIllegalInIsinstance: true
            }], ['TypeAlias', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Concatenate', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['TypeGuard', {
              alias: '',
              module: 'builtins',
              implicitBaseClass: 'bool',
              isSpecialForm: true,
              typeParamVariance: 3
            }], ['Unpack', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Required', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['NotRequired', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Self', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['NoReturn', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Never', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['LiteralString', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['ReadOnly', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['TypeIs', {
              alias: '',
              module: 'builtins',
              implicitBaseClass: 'bool',
              isSpecialForm: true,
              typeParamVariance: 2
            }], ['TypeForm', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true,
              typeParamVariance: 3,
              isIllegalInIsinstance: true
            }]]).get(a);
            if (r) {
              const n = Ne(e, 0);
              if (n) {
                return n;
              }
              let s = ra(e, a, r);
              if (a === 'LiteralString') {
                s.shared.baseClasses.push((t = Ae == null ? undefined : Ae.strClass) !== null && t !== undefined ? t : H.AnyType.create());
                Z.computeMroLinearization(s);
                if (Zr(e)) {
                  s = H.TypeBase.cloneWithTypeForm(s, Z.convertToInstance(s));
                }
              }
              if (a === 'Never' || a === 'NoReturn') {
                s = H.TypeBase.cloneAsSpecialForm(a === 'Never' ? H.NeverType.createNever() : H.NeverType.createNoReturn(), s);
                if (Zr(e)) {
                  s = H.TypeBase.cloneWithTypeForm(s, Z.convertToInstance(s));
                }
              }
              Fe(e, {
                type: s
              }, 0);
              return s;
            }
            return;
          }(e);
          if (t) {
            return t;
          }
        }
        const i = t ? {
          ...t
        } : {};
        i.typeExpression = true;
        i.convertEllipsisToAny = true;
        if (((n = e == null ? undefined : e.parent) === null || n === undefined ? undefined : n.nodeType) === 3 && e.parent.d.annotationComment === e) {
          i.forwardRefs = true;
          i.notParsed = true;
        } else {
          if (((a = e == null ? undefined : e.parent) === null || a === undefined ? undefined : a.nodeType) === 62) {
            if (e.parent.d.returnAnnotation === e || e.parent.d.paramAnnotations.some(t => t === e)) {
              i.forwardRefs = true;
              i.notParsed = true;
            }
          } else {
            if (((r = e == null ? undefined : e.parent) === null || r === undefined ? undefined : r.nodeType) === 41 && e.parent.d.annotationComment === e) {
              i.forwardRefs = true;
              i.notParsed = true;
            }
          }
        }
        const o = Ha(e, i).type;
        if (H.isModule(o)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.moduleAsType(), e);
        }
        return Z.convertToInstance(o);
      }
      function Ye(e, t = 0) {
        e = Pt(e);
        if (t > H.maxTypeRecursionCount) {
          return true;
        }
        t++;
        switch (e.category) {
          case 0:
          case 1:
          case 2:
          case 3:
            return true;
          case 8:
            return H.findSubtype(e, e => Ye(e, t)) !== undefined;
          case 4:
          case 5:
          case 7:
          case 9:
            return false;
          case 6:
            {
              if (H.TypeBase.isInstantiable(e)) {
                return false;
              }
              if (Z.isTupleClass(e) && e.priv.tupleTypeArgs) {
                return Z.isUnboundedTupleClass(e) || e.priv.tupleTypeArgs.length === 0;
              }
              const n = e.shared.mro.find(e => !H.isClass(e) || Z.isTupleClass(e));
              if (n && H.isClass(n) && n.priv.tupleTypeArgs) {
                return Z.isUnboundedTupleClass(n) || n.priv.tupleTypeArgs.length === 0;
              }
              if (H.ClassType.isTypedDictClass(e)) {
                const t = W.getTypedDictMembersForClass(es, e, true);
                if (t) {
                  for (const e of t.knownItems.values()) {
                    if (e.isRequired || e.isProvided) {
                      return false;
                    }
                  }
                }
              }
              if (e.priv.literalValue !== undefined) {
                if (H.ClassType.isBuiltIn(e, ['bool', 'int', 'str', 'bytes'])) {
                  return !e.priv.literalValue || e.priv.literalValue === BigInt(0);
                }
                if (e.priv.literalValue instanceof H.EnumLiteral && e.priv.literalValue.isReprEnum) {
                  return Ye(e.priv.literalValue.itemType, t);
                }
              }
              if (H.ClassType.isProtocolClass(e)) {
                return true;
              }
              if (Z.lookUpObjectMember(e, '__len__')) {
                return true;
              }
              const a = Z.lookUpObjectMember(e, '__bool__');
              if (a) {
                const e = Tr(a);
                if (H.isFunction(e) && e.shared.declaredReturnType) {
                  const t = e.shared.declaredReturnType;
                  if (H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'bool') && t.priv.literalValue === true) {
                    return false;
                  }
                }
                return true;
              }
              return H.ClassType.isBuiltIn(e, 'object');
            }
        }
      }
      function Je(e, t = 0) {
        e = Pt(e);
        if (t > H.maxTypeRecursionCount) {
          return true;
        }
        t++;
        switch (e.category) {
          case 1:
          case 4:
          case 5:
          case 7:
          case 9:
          case 3:
          case 2:
            return true;
          case 8:
            return H.findSubtype(e, e => Je(e, t)) !== undefined;
          case 0:
            return false;
          case 6:
            {
              if (H.TypeBase.isInstantiable(e)) {
                return true;
              }
              if (Z.isNoneInstance(e)) {
                return false;
              }
              if (e.priv.tupleTypeArgs && e.priv.tupleTypeArgs.length === 0) {
                return false;
              }
              if (e.priv.literalValue !== undefined) {
                if (H.ClassType.isBuiltIn(e, ['bool', 'int', 'str', 'bytes'])) {
                  return !!e.priv.literalValue && e.priv.literalValue !== BigInt(0);
                }
                if (e.priv.literalValue instanceof H.EnumLiteral && e.priv.literalValue.isReprEnum) {
                  return Je(e.priv.literalValue.itemType, t);
                }
              }
              if (H.ClassType.isProtocolClass(e)) {
                return true;
              }
              const n = Z.lookUpObjectMember(e, '__bool__');
              if (n) {
                const e = Tr(n);
                if (H.isFunction(e) && e.shared.declaredReturnType) {
                  const t = e.shared.declaredReturnType;
                  if (H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'bool') && t.priv.literalValue === false) {
                    return false;
                  }
                }
              }
              return true;
            }
        }
      }
      function Qe(e) {
        return Z.mapSubtypes(e, e => H.isClassInstance(e) && H.ClassType.isBuiltIn(e, ['TypeGuard', 'TypeIs']) ? (Ae == null ? undefined : Ae.boolClass) ? Z.convertToInstance(Ae.boolClass) : H.UnknownType.create() : e);
      }
      function Xe(e, t, n, a) {
        const r = I.solveConstraints(es, t, a);
        return Z.applySolvedTypeVars(e, r, n);
      }
      function et(e, t, n, a = {
        method: 'get'
      }, r = undefined, s = 0, i, o = 0) {
        if (H.ClassType.isPartiallyEvaluated(t)) {
          if (e) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.classDefinitionCycle().format({
              name: t.shared.name
            }), e);
          }
          return {
            type: H.UnknownType.create()
          };
        }
        if (H.isInstantiableClass(t) && !t.priv.includeSubclasses && t.shared.typeParams.length > 0) {
          if (!(s & 512)) {
            t = Z.specializeWithDefaultTypeArgs(t);
          }
        }
        const l = H.TypeBase.isInstantiable(t);
        const c = t.shared.effectiveMetaclass;
        let u;
        let m;
        let y = l && !!(s & 16);
        if (a.method === 'get' && l && c && H.isInstantiableClass(c) && !H.ClassType.isBuiltIn(c, 'type') && !H.ClassType.isSameGenericClass(c, t)) {
          const r = jt(e, c, n, a, undefined, s | 512, t, o);
          if (r) {
            const e = H.isClassInstance(r.type) && H.ClassType.isPropertyClass(r.type);
            if (Z.isDescriptorInstance(r.type, true) || e) {
              y = true;
            }
          }
        }
        if (!y) {
          let d = s;
          if (l) {
            d |= 1552;
            d &= -33;
          } else {
            d |= 128;
          }
          m = r ? new p.DiagnosticAddendum() : undefined;
          u = jt(e, t, n, a, m, d, i, o);
        }
        if (!u && c && H.isInstantiableClass(c)) {
          let i = s;
          if (!l) {
            i |= 552;
            i &= -17;
          }
          const d = r ? new p.DiagnosticAddendum() : undefined;
          u = jt(e, H.ClassType.cloneAsInstance(c), n, a, d, i, l ? t : H.ClassType.cloneAsInstantiable(t), o);
          if (u == null ? undefined : u.isDescriptorError) {
            m = d;
          }
        }
        if (u) {
          if (u.isDescriptorError && r && m) {
            r.addAddendum(m);
          }
          return {
            type: u.type,
            classType: u.classType,
            isIncomplete: !!u.isTypeIncomplete,
            isAsymmetricAccessor: u.isAsymmetricAccessor,
            narrowedTypeForSet: u.narrowedTypeForSet,
            memberAccessDeprecationInfo: u.memberAccessDeprecationInfo,
            typeErrors: u.isDescriptorError
          };
        }
        if (H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'type') && t.priv.includeSubclasses && !(s & 520)) {
          const e = t.priv.typeArgs && t.priv.typeArgs.length >= 1 ? t.priv.typeArgs[0] : H.UnknownType.create();
          if (H.isAnyOrUnknown(e)) {
            return {
              type: e,
              classType: H.UnknownType.create()
            };
          }
        }
        if (r && m) {
          r.addAddendum(m);
        }
      }
      function tt(e, t, n, a, r = 0) {
        const s = et(undefined, e, t, undefined, a, 528, n, r);
        if (s && !s.typeErrors) {
          if (H.isFunction(s.type) || H.isOverloaded(s.type)) {
            return s.type;
          }
          if (H.isClassInstance(s.type)) {
            if (r > H.maxTypeRecursionCount) {
              return;
            }
            r++;
            return tt(s.type, '__call__', n ?? H.ClassType.cloneAsInstance(e), a, r);
          }
          if (H.isAnyOrUnknown(s.type)) {
            return Z.getUnknownTypeForCallable();
          } else {
            return undefined;
          }
        }
      }
      function nt(e) {
        var t;
        var n;
        const a = e.shared.parameters.findIndex(e => e.category === 2);
        if (a < 0) {
          return e;
        }
        l.assert(a === e.shared.parameters.length - 1);
        const r = H.FunctionType.getParamType(e, a);
        if (!H.isClassInstance(r) || !H.ClassType.isTypedDictClass(r) || !r.priv.isUnpacked) {
          return e;
        }
        const s = (t = r.priv.typedDictNarrowedEntries) !== null && t !== undefined ? t : (n = r.shared.typedDictEntries) === null || n === undefined ? undefined : n.knownItems;
        if (!s) {
          return e;
        }
        const i = H.FunctionType.clone(e);
        i.shared.parameters.splice(a);
        if (i.priv.specializedTypes) {
          i.priv.specializedTypes.parameterTypes.splice(a);
        }
        if (e.shared.parameters.findIndex(e => e.category === 1) < 0 && s.size > 0) {
          H.FunctionType.addKeywordOnlyParamSeparator(i);
        }
        s.forEach((e, t) => {
          H.FunctionType.addParam(i, H.FunctionParam.create(0, e.valueType, H.FunctionParamFlags.TypeDeclared, t, e.isRequired ? undefined : e.valueType));
        });
        return i;
      }
      function at(e, t) {
        var n;
        var a;
        let r;
        let s;
        let i;
        let o;
        let l = true;
        let p = false;
        switch (e.nodeType) {
          case 38:
            {
              const t = Ja(e, e.d.value, true);
              if (t && (r = t.symbol, !((n = yr(r, e)) === null || n === undefined ? undefined : n.type) && t.scope.type === 3)) {
                const t = M.getEnclosingClassOrFunction(e);
                if (t && t.nodeType === 10) {
                  const n = ca(t);
                  if (n) {
                    const t = Z.lookUpClassMember(n.classType, e.d.value, 80);
                    if (t) {
                      r = t.symbol;
                    }
                  }
                }
              }
              break;
            }
          case 54:
            return at(e.d.valueExpr, t);
          case 35:
            {
              const t = qe(e.d.leftExpr, 2).type;
              const n = Pt(t);
              let a;
              if (H.isClassInstance(n)) {
                a = Z.lookUpObjectMember(n, e.d.member.d.value, 64);
                i = n;
                o = a == null ? undefined : a.classType;
                if (a == null ? undefined : a.isInstanceMember) {
                  l = false;
                }
                p = true;
              } else {
                if (H.isInstantiableClass(n)) {
                  a = Z.lookUpClassMember(n, e.d.member.d.value, 80);
                  i = n;
                  o = a == null ? undefined : a.classType;
                }
              }
              if (H.isTypeVar(t)) {
                s = t;
              }
              if (a) {
                r = a.symbol;
              }
              break;
            }
          case 27:
            {
              const n = Pt(qe(e.d.leftExpr, 2).type);
              if (n && H.isClassInstance(n)) {
                const a = tt(n, '__setitem__');
                if (a && H.isFunction(a) && a.shared.parameters.length >= 2) {
                  const e = H.FunctionType.getParamType(a, 1);
                  if (!H.isAnyOrUnknown(e)) {
                    return e;
                  }
                } else {
                  if (H.ClassType.isTypedDictClass(n)) {
                    const a = W.getTypeOfIndexedTypedDict(es, e, n, t || {
                      method: 'get'
                    });
                    if (a) {
                      return a.type;
                    }
                  }
                }
              }
              break;
            }
        }
        if (r) {
          let e = (a = yr(r)) === null || a === undefined ? undefined : a.type;
          if (e) {
            if (p && H.isClassInstance(e)) {
              const t = tt(e, '__set__');
              if (t && H.isFunction(t) && t.shared.parameters.length >= 2 && (e = H.FunctionType.getParamType(t, 1), H.isAnyOrUnknown(e))) {
                return;
              }
            }
            if (i) {
              if (o && H.isInstantiableClass(o)) {
                e = Z.partiallySpecializeType(e, o, dt(), s);
              }
              if ((H.isFunction(e) || H.isOverloaded(e)) && l) {
                e = Ur(i, e, undefined, undefined, s);
              }
            }
            return e;
          }
        }
      }
      function rt(e, t) {
        if (!(Ae == null ? undefined : Ae.awaitableClass) || !H.isInstantiableClass(Ae.awaitableClass) || Ae.awaitableClass.shared.typeParams.length !== 1) {
          return H.UnknownType.create();
        }
        const n = H.ClassType.cloneAsInstance(Ae.awaitableClass);
        return Z.mapSubtypes(e, e => {
          e = Pt(e);
          if (H.isAnyOrUnknown(e)) {
            return e;
          }
          const a = t ? new p.DiagnosticAddendum() : undefined;
          if (H.isClassInstance(e)) {
            const t = new k.ConstraintTracker();
            if (Ir(n, e, a, t)) {
              const e = Xe(n, t);
              if (H.isClass(e) && e.priv.typeArgs && e.priv.typeArgs.length > 0) {
                return e.priv.typeArgs[0];
              } else {
                return H.UnknownType.create();
              }
            }
          }
          if (t) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeNotAwaitable().format({
              type: Yr(e)
            }) + (a == null ? undefined : a.getString()), t);
          }
          return H.UnknownType.create();
        });
      }
      function st(e, t, n, a = true) {
        const r = t ? '__aiter__' : '__iter__';
        const s = t ? '__anext__' : '__next__';
        let i = true;
        let o = Z.transformPossibleRecursiveTypeAlias(e.type);
        o = Pt(o);
        o = H.removeUnbound(o);
        if (Z.isOptionalType(o) && a) {
          if (!e.isIncomplete) {
            kt(d.DiagnosticRule.reportOptionalIterable, g.LocMessage.noneNotIterable(), n);
          }
          o = Z.removeNoneFromUnion(o);
        }
        const l = Z.mapSubtypes(o, o => {
          o = Pt(o);
          if (H.isAnyOrUnknown(o)) {
            return o;
          }
          const u = new p.DiagnosticAddendum();
          if (H.isClass(o)) {
            if (H.TypeBase.isInstance(o) && Z.isTupleClass(o) && o.priv.tupleTypeArgs && o.priv.tupleTypeArgs.length === 0) {
              return H.NeverType.createNever();
            }
            const e = Pn(o, r, [], n)?.type;
            if (e) {
              const a = new p.DiagnosticAddendum();
              const r = Dt(e, undefined, e => {
                var r;
                if (H.isAnyOrUnknown(e)) {
                  return e;
                }
                let i = (r = Pn(e, s, [], n)) === null || r === undefined ? undefined : r.type;
                if (i) {
                  i = Z.mapSubtypes(i, e => H.isTypeVar(e) && H.isUnpackedTypeVarTuple(e) ? lt() : e);
                  if (t) {
                    return rt(i, n);
                  } else {
                    return i;
                  }
                }
                a.addMessage(g.LocMessage.methodNotDefinedOnType().format({
                  name: s,
                  type: Yr(e)
                }));
              });
              if (a.isEmpty()) {
                return r;
              }
              u.addAddendum(a);
            } else {
              if (!t && H.isClassInstance(o)) {
                const e = Pn(o, '__getitem__', [{
                  type: (Ae == null ? undefined : Ae.intClass) && H.isInstantiableClass(Ae.intClass) ? H.ClassType.cloneAsInstance(Ae.intClass) : H.UnknownType.create()
                }], n)?.type;
                if (e) {
                  return e;
                }
              }
              u.addMessage(g.LocMessage.methodNotDefined().format({
                name: r
              }));
            }
          }
          if (!e.isIncomplete && a) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeNotIterable().format({
              type: Yr(o)
            }) + u.getString(), n);
          }
          i = false;
        });
        if (i) {
          return {
            type: l,
            isIncomplete: e.isIncomplete
          };
        } else {
          return undefined;
        }
      }
      function it(e, t, n, a = true) {
        const r = t ? '__aiter__' : '__iter__';
        let s = true;
        let i = Pt(e.type);
        if (Z.isOptionalType(i)) {
          if (!e.isIncomplete && a) {
            kt(d.DiagnosticRule.reportOptionalIterable, g.LocMessage.noneNotIterable(), n);
          }
          i = Z.removeNoneFromUnion(i);
        }
        const o = Z.mapSubtypes(i, e => {
          if (H.isAnyOrUnknown(e)) {
            return e;
          }
          if (H.isClass(e)) {
            const a = Pn(e, r, [], n)?.type;
            if (a) {
              return Pt(a);
            }
          }
          if (a) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeNotIterable().format({
              type: Yr(e)
            }), n);
          }
          s = false;
        });
        if (s) {
          return {
            type: o,
            isIncomplete: e.isIncomplete
          };
        } else {
          return undefined;
        }
      }
      function ot() {
        if ((Ae == null ? undefined : Ae.tupleClass) && H.isInstantiableClass(Ae.tupleClass)) {
          return Ae.tupleClass;
        } else {
          return undefined;
        }
      }
      function lt() {
        if (Ae == null ? undefined : Ae.objectClass) {
          return Z.convertToInstance(Ae.objectClass);
        } else {
          return H.UnknownType.create();
        }
      }
      function pt() {
        if (Ae == null ? undefined : Ae.noneTypeClass) {
          return Z.convertToInstance(Ae.noneTypeClass);
        } else {
          return H.UnknownType.create();
        }
      }
      function dt() {
        if ((Ae == null ? undefined : Ae.typeClass) && H.isInstantiableClass(Ae.typeClass)) {
          return Ae.typeClass;
        }
      }
      function ct(e, t) {
        var n;
        if ((n = mt(e, t, ['typing'])) !== null && n !== undefined) {
          return n;
        } else {
          return mt(e, t, ['typing_extensions']);
        }
      }
      function ut(e, t) {
        return mt(e, t, ['_typeshed']);
      }
      function mt(t, n, a) {
        const r = v.getFileInfo(t);
        const s = e({
          nameParts: a,
          importingFileUri: r.fileUri
        });
        if (!s) {
          return;
        }
        const i = s.symbolTable.get(n);
        if (i) {
          return cr(i);
        } else {
          return undefined;
        }
      }
      function yt(e) {
        const n = e.nodeType === 31 ? e : M.getExecutionScopeNode(e);
        if (v.getCodeFlowComplexity(n) > exports.maxCodeComplexity) {
          let t = n;
          if (n.nodeType === 31) {
            t = n.d.name;
          } else {
            if (n.nodeType === 36) {
              t = {
                start: 0,
                length: 0
              };
            }
          }
          wt(v.getFileInfo(e), d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.codeTooComplexToAnalyze(), t);
          return true;
        }
        return false;
      }
      function gt(e, t) {
        return ft(e, t) === K.Reachability.Reachable;
      }
      function ht(e) {
        return Tt(e) === K.Reachability.Reachable;
      }
      function ft(e, t) {
        if (yt(e)) {
          return K.Reachability.Reachable;
        }
        const n = v.getFlowNode(e);
        if (!n) {
          if (e.parent) {
            return ft(e.parent, t);
          } else {
            return K.Reachability.UnreachableAlways;
          }
        }
        const a = t ? v.getFlowNode(t) : undefined;
        return ts.getFlowNodeReachability(n, a);
      }
      function Tt(e) {
        const t = v.getAfterFlowNode(e);
        if (!t) {
          return K.Reachability.UnreachableAlways;
        }
        if (yt(e)) {
          return K.Reachability.Reachable;
        }
        const n = ts.getFlowNodeReachability(t);
        if (n !== K.Reachability.Reachable) {
          return n;
        } else {
          if (function (e, t) {
            const n = ja(e.id, undefined);
            if (yt(e)) {
              return true;
            }
            const a = n.getTypeFromCodeFlow(t, undefined, {
              typeAtStart: {
                type: H.UnboundType.create()
              }
            });
            return a.type !== undefined && !H.isNever(a.type);
          }(e, t)) {
            return K.Reachability.Reachable;
          } else {
            return K.Reachability.UnreachableByAnalysis;
          }
        }
      }
      function vt(e, t, n = true) {
        if (yt(e)) {
          return true;
        }
        const a = v.getFlowNode(e);
        const r = v.getFlowNode(t);
        return !!a && !!r && (a === r ? n : ts.getFlowNodeReachability(r, a, true) === K.Reachability.Reachable);
      }
      function bt(e, t, n) {
        return _t('information', e, t, n);
      }
      function _t(e, t, n, a) {
        var r;
        if (Ct(n)) {
          const e = me.find(e => M.isNodeContainedWithin(n, e.node) && e.suppressedDiags);
          if ((r = e == null ? undefined : e.suppressedDiags) !== null && r !== undefined) {
            r.push(t);
          }
        } else {
          if (gt(n)) {
            return v.getFileInfo(n).diagnosticSink.addDiagnosticWithTextRange(e, t, a ?? n);
          }
        }
      }
      function Ct(e) {
        return !!ue.isSpeculative(e, true) || me.some(t => M.isNodeContainedWithin(e, t.node));
      }
      function It(e) {
        if (ue.isSpeculative(e, true)) {
          return true;
        }
        const t = me.filter(t => M.isNodeContainedWithin(e, t.node));
        return t.length !== 0 && t.every(e => !e.suppressedDiags);
      }
      function kt(e, t, n, a) {
        const r = v.getFileInfo(n).diagnosticRuleSet[e];
        if (r === 'none') {
          return;
        }
        const s = M.getEnclosingFunction(n);
        if (s) {
          if (!v.getFileInfo(n).diagnosticRuleSet.analyzeUnannotatedFunctions && M.isUnannotatedFunction(s) && M.isNodeContainedWithin(n, s.d.suite)) {
            return;
          }
          const e = M.getEnclosingClass(s, true);
          if (x.getFunctionInfoFromDecorators(es, s, !!e).flags & 524288) {
            return;
          }
        }
        const i = _t(r, t, n, a);
        if (i) {
          i.setRule(e);
        }
        return i;
      }
      function wt(e, t, n, a) {
        const r = e.diagnosticRuleSet[t];
        if (r === 'none') {
          return;
        }
        const s = e.diagnosticSink.addDiagnosticWithTextRange(r, n, a);
        if (t) {
          s.setRule(t);
        }
        return s;
      }
      function St(e, t, n, a, r = false, s) {
        var i;
        var o;
        var l;
        const c = e.d.value;
        const u = Ja(e, c, false);
        if (!u) {
          return;
        }
        const m = u.symbol.getDeclarations();
        let y = (i = yr(u.symbol)) === null || i === undefined ? undefined : i.type;
        const h = v.getFileInfo(e);
        if (y === undefined && u.scope.type === 3) {
          const t = M.getEnclosingClass(e);
          if (t) {
            const n = ca(t);
            if (n) {
              const t = Z.lookUpClassMember(n.classType, e.d.value, 1);
              if (t == null ? undefined : t.isTypeDeclared) {
                y = Tr(t);
              }
            }
          }
        }
        let f = t.type;
        const T = !!y && H.isClassInstance(y) && H.ClassType.isBuiltIn(y, 'TypeAlias');
        if (y && !T) {
          let n = new p.DiagnosticAddendum();
          const r = M.getTypeVarScopesForNode(e);
          if (Ir(Z.makeTypeVarsBound(y, r), Z.makeTypeVarsBound(t.type, r), n)) {
            f = Er(e, y, t).type;
          } else {
            if (s) {
              n = s;
            }
            if (!t.isIncomplete) {
              kt(d.DiagnosticRule.reportAssignmentType, g.LocMessage.typeAssignmentMismatch().format(Hr(t.type, y)) + n.getString(), a ?? e, (l = (o = n.getEffectiveTextRange()) !== null && o !== undefined ? o : a) !== null && l !== undefined ? l : e);
            }
            f = y;
          }
        } else {
          const t = V.getScopeForNode(e);
          if ((t == null ? undefined : t.type) === 3) {
            if (!!H.TypeBase.isInstance(f) && !B.isConstantName(c) && !Rr(u.symbol)) {
              f = Z.stripTypeForm($e(f));
            }
          }
        }
        const b = m.findIndex(e => e.type === 1);
        const _ = b >= 0 ? m[b] : undefined;
        const C = m.find((e, t) => b < t && e.type !== 1);
        if (_ && _.type === 1) {
          if (_.isConstant) {
            if (e !== A.getNameNodeForDeclaration(m[0]) || C) {
              kt(d.DiagnosticRule.reportConstantRedefinition, g.LocMessage.constantRedefinition().format({
                name: c
              }), e);
            }
          } else {
            if (Lr(_) && !r) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalReassigned().format({
                name: c
              }), e);
            }
          }
        }
        if (!t.isIncomplete) {
          Un(h.diagnosticRuleSet.reportUnknownVariableType, d.DiagnosticRule.reportUnknownVariableType, e, f, e, n);
        }
        Fe(e, {
          type: f,
          isIncomplete: t.isIncomplete
        }, 0);
      }
      function At(e, t, n, a) {
        var r;
        const i = qe(e.d.leftExpr, 2);
        const o = Pt(i.type);
        let l;
        if (e.d.leftExpr.nodeType === 38) {
          const a = M.getEnclosingClass(e);
          if (a) {
            const r = ca(a);
            if (r && H.isInstantiableClass(r.classType) && (l = r.classType, H.isClassInstance(o) ? H.ClassType.isSameGenericClass(H.ClassType.cloneAsInstantiable(o), r.classType) && xt(e, t, true, n) : H.isInstantiableClass(o) && H.ClassType.isSameGenericClass(o, r.classType) && xt(e, t, false, n), H.ClassType.isProtocolClass(r.classType))) {
              const t = H.ClassType.getSymbolTable(r.classType).get(e.d.member.d.value);
              if (t) {
                if (t.getDeclarations().filter(e => !M.getEnclosingFunction(e.node)).length === 0) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.assignmentInProtocol(), e.d.member);
                }
              }
            }
          }
        }
        const p = Bt(e, i, {
          method: 'set',
          setType: t,
          setErrorNode: n,
          setExpectedTypeDiag: a
        }, 0);
        var c;
        if (p.isAsymmetricAccessor) {
          c = e;
          if (!ar(undefined)) {
            s.add(c.id);
          }
        }
        const u = {
          type: (r = p.narrowedTypeForSet) !== null && r !== undefined ? r : t.type,
          isIncomplete: t.isIncomplete,
          memberAccessDeprecationInfo: p.memberAccessDeprecationInfo
        };
        Fe(e, u, 0);
        let m = u;
        if (l == null ? undefined : l.shared.typeVarScopeId) {
          m = {
            ...u,
            type: Z.makeTypeVarsFree(u.type, [l.shared.typeVarScopeId]),
            memberAccessDeprecationInfo: p.memberAccessDeprecationInfo
          };
        }
        Fe(e.d.member, m, 0);
      }
      function xt(e, t, n, a) {
        var r;
        const s = e.d.member.d.value;
        const i = v.getFileInfo(e);
        const o = M.getEnclosingClass(e);
        if (!o) {
          return;
        }
        const p = ca(o);
        if (p && H.isInstantiableClass(p.classType)) {
          let o = Z.lookUpClassMember(p.classType, s, n ? 0 : 16);
          const c = H.ClassType.getSymbolTable(p.classType);
          if (o) {
            const u = H.isInstantiableClass(o.classType) ? o.classType : undefined;
            const m = u && H.ClassType.isSameGenericClass(p.classType, u);
            if (m && n && u) {
              const t = H.ClassType.getInheritedSlotsNames(u);
              if (t && u.shared.localSlotsNames && (u.shared.localSlotsNames.length > 0 || H.ClassType.isFinal(u)) && !t.some(e => e === s)) {
                const t = Z.lookUpClassMember(u, s, 16);
                let n = false;
                if (t) {
                  const e = cr(t.symbol);
                  if (H.isAnyOrUnknown(e) || H.isUnbound(e) || Z.isMaybeDescriptorInstance(e)) {
                    n = true;
                  }
                }
                if (!n) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.slotsAttributeError().format({
                    name: s
                  }), e.d.member);
                }
              }
            }
            if (m && o.isInstanceMember === n) {
              const t = c.get(s);
              l.assert(t !== undefined);
              const n = t.getDeclarations();
              if (n.length > 0 && n[0].type === 1 && a && e.d.member !== n[0].node && n[0].isConstant) {
                kt(d.DiagnosticRule.reportConstantRedefinition, g.LocMessage.constantRedefinition().format({
                  name: e.d.member.d.value
                }), e.d.member);
              }
            } else {
              const a = (r = yr(o.symbol)) === null || r === undefined ? undefined : r.type;
              if (a && !Z.isProperty(a) && !o.isInstanceMember && n) {
                Et(i, o.symbol, e.d.member);
                const n = Tr(o);
                t = {
                  ...t,
                  type: H.combineTypes([t.type, n])
                };
              }
            }
          }
          o = Z.lookUpClassMember(p.classType, s, 64);
          if (!o && !!a && !t.isIncomplete) {
            Un(i.diagnosticRuleSet.reportUnknownMemberType, d.DiagnosticRule.reportUnknownMemberType, e.d.member, t.type, e, true);
          }
        }
      }
      function Pt(e, t = false, n) {
        e = Z.transformPossibleRecursiveTypeAlias(e);
        return Z.mapSubtypes(e, e => {
          if (H.isParamSpec(e)) {
            if (e.priv.paramSpecAccess === 'args') {
              return q.makeTupleObject(es, [{
                type: lt(),
                isUnbounded: true
              }]);
            }
            if (e.priv.paramSpecAccess === 'kwargs') {
              if ((Ae == null ? undefined : Ae.dictClass) && H.isInstantiableClass(Ae.dictClass) && (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass)) {
                return H.ClassType.cloneAsInstance(H.ClassType.specialize(Ae.dictClass, [Z.convertToInstance(Ae.strClass), lt()]));
              } else {
                return H.UnknownType.create();
              }
            }
          }
          if (t && H.isFunction(e)) {
            const t = Z.simplifyFunctionToParamSpec(e);
            if (H.isParamSpec(t)) {
              return H.ParamSpecType.getUnknown();
            }
          }
          if (H.isTypeVarTuple(e)) {
            if (e.priv.isInUnion) {
              if (H.TypeBase.isInstantiable(e)) {
                if ((Ae == null ? undefined : Ae.typeClass) && H.isInstantiableClass(Ae.typeClass)) {
                  return Ae.typeClass;
                } else {
                  return H.AnyType.create();
                }
              } else {
                return lt();
              }
            } else {
              return q.makeTupleObject(es, [{
                type: lt(),
                isUnbounded: true
              }], true);
            }
          }
          if (H.isTypeVar(e)) {
            if (e.shared.recursiveAlias) {
              return e;
            }
            if (H.TypeVarType.hasConstraints(e)) {
              const t = [];
              e.shared.constraints.forEach((a, r) => {
                if (n) {
                  const t = H.TypeVarType.getNameWithScope(e);
                  const a = n.find(e => e.typeVar.priv.nameWithScope === t);
                  if (a && a.constraintIndex !== r) {
                    return;
                  }
                }
                if (H.TypeBase.isInstantiable(e)) {
                  a = Z.convertToInstantiable(a);
                }
                t.push(Z.addConditionToType(a, [{
                  typeVar: e,
                  constraintIndex: r
                }]));
              });
              return H.combineTypes(t);
            }
            if (e.shared.isExemptFromBoundCheck) {
              return H.AnyType.create();
            }
            let t = e.shared.boundType ?? lt();
            if (H.TypeVarType.isSelf(e) && H.isClass(t) && !H.ClassType.isPseudoGenericClass(t)) {
              t = Z.selfSpecializeClass(t, {
                useBoundTypeVars: H.TypeVarType.isBound(e)
              });
            }
            if (e.priv.isUnpacked && H.isClass(t)) {
              t = H.ClassType.cloneForUnpacked(t);
            }
            t = H.TypeBase.isInstantiable(e) ? Z.convertToInstantiable(t) : t;
            return Z.addConditionToType(t, [{
              typeVar: e,
              constraintIndex: 0
            }]);
          }
          return e;
        });
      }
      function Dt(e, t, n, a = 0) {
        const r = [];
        let s = false;
        function i(e, i) {
          let o = H.isUnion(e) ? e : Pt(e);
          o = Z.transformPossibleRecursiveTypeAlias(o);
          if (t == null ? undefined : t.expandCallback) {
            o = t.expandCallback(o);
          }
          Z.doForEachSubtype(o, (o, l, p) => {
            var d;
            if (t == null ? undefined : t.conditionFilter) {
              const e = function (e, t, n) {
                if (n > H.maxTypeRecursionCount) {
                  return e;
                }
                n++;
                if (!H.TypeCondition.isCompatible(Z.getTypeCondition(e), t)) {
                  return;
                }
                if (H.isClass(e) && e.priv.typeArgs && !e.priv.tupleTypeArgs) {
                  ya(e);
                  let a = false;
                  const r = e.priv.typeArgs.map((r, s) => {
                    if (s >= e.shared.typeParams.length) {
                      return r;
                    }
                    if (H.TypeVarType.getVariance(e.shared.typeParams[s]) !== 3) {
                      return r;
                    }
                    if (H.isTypeVar(r) && r.shared.recursiveAlias) {
                      return r;
                    }
                    const i = Dt(r, {
                      conditionFilter: t
                    }, e => e, n);
                    if (i !== r) {
                      a = true;
                    }
                    return i;
                  });
                  if (a) {
                    return H.ClassType.specialize(e, r);
                  }
                }
                return e;
              }(o, t.conditionFilter, a);
              if (!e) {
                return;
              }
              o = e;
            }
            let c = n(o, e, i && l === p.length - 1);
            if (c !== e) {
              s = true;
            }
            if (c) {
              const e = (d = Z.getTypeCondition(o)) === null || d === undefined ? undefined : d.filter(e => H.TypeVarType.hasConstraints(e.typeVar));
              if (e && e.length > 0) {
                c = Z.addConditionToType(c, e);
              }
              if (r.length === 0 || !H.isTypeSame(c, r[r.length - 1])) {
                r.push(c);
              }
            }
          }, t == null ? undefined : t.sortSubtypes);
        }
        if (H.isUnion(e)) {
          ((t == null ? undefined : t.sortSubtypes) ? Z.sortTypes(e.priv.subtypes) : e.priv.subtypes).forEach((t, n) => {
            i(t, n === e.priv.subtypes.length - 1);
          });
        } else {
          i(e, true);
        }
        if (!s) {
          return e;
        }
        const o = H.combineTypes(r);
        if (o.category === 8) {
          H.UnionType.addTypeAliasSource(o, e);
        }
        return o;
      }
      function Nt(e, t, n, a = false, r = false, s) {
        if (H.isTypeVar(t.type) && n && n.nodeType === 9) {
          const a = qe(n.d.leftExpr, 2).type;
          if (H.isInstantiableClass(a) && (H.ClassType.isBuiltIn(a, 'TypeVar') || H.ClassType.isBuiltIn(a, 'TypeVarTuple') || H.ClassType.isBuiltIn(a, 'ParamSpec'))) {
            const n = e.nodeType === 54 ? e.d.valueExpr : e;
            if (n.nodeType !== 38 || n.d.value !== t.type.shared.name) {
              const e = H.TypeVarType.getReadableName(t.type);
              kt(d.DiagnosticRule.reportGeneralTypeIssues, H.isParamSpec(t.type) ? g.LocMessage.paramSpecAssignedName().format({
                name: e
              }) : g.LocMessage.typeVarAssignedName().format({
                name: e
              }), n);
            }
          }
        }
        if (H.findSubtype(t.type, e => H.isUnbound(e))) {
          t = {
            ...t,
            type: H.removeUnbound(t.type)
          };
        }
        switch (e.nodeType) {
          case 38:
            St(e, t, a, n, r, s);
            break;
          case 35:
            At(e, t, n, s);
            break;
          case 27:
            {
              const a = qe(e.d.leftExpr, 2);
              $t(e, a, {
                method: 'set',
                setType: t,
                setErrorNode: n,
                setExpectedTypeDiag: s
              }, 0);
              Fe(e, t, 0);
              break;
            }
          case 34:
          case 52:
            (function (e, t, n) {
              e.nodeType;
              const a = e.d.items;
              const r = new Array(a.length);
              for (let e = 0; e < a.length; e++) {
                r[e] = [];
              }
              const s = a.findIndex(e => e.nodeType === 56);
              const i = a.findIndex(e => e.nodeType === 56);
              t = {
                ...t,
                type: Pt(t.type)
              };
              const o = new p.DiagnosticAddendum();
              Z.doForEachSubtype(t.type, l => {
                const c = Z.getSpecializedTupleType(l);
                if (c && c.priv.tupleTypeArgs) {
                  const t = c.priv.tupleTypeArgs.map(e => Z.addConditionToType(e.type, Z.getTypeCondition(l), {
                    skipSelfCondition: true
                  }));
                  const n = c.priv.tupleTypeArgs.findIndex(e => e.isUnbounded);
                  if (n >= 0 && t.length < r.length) {
                    const e = t.length > 0 ? t[n] : H.AnyType.create();
                    while (t.length < r.length) {
                      t.splice(n, 0, e);
                    }
                  }
                  if (s >= 0) {
                    if (t.length > r.length) {
                      const n = t.splice(s, t.length - r.length + 1);
                      let a = H.combineTypes(n);
                      if (e.nodeType === 34) {
                        a = $e(a);
                      }
                      t.splice(s, 0, a);
                    } else {
                      if (t.length === r.length - 1) {
                        t.splice(s, 0, H.NeverType.createNever());
                      }
                    }
                  }
                  t.forEach((e, t) => {
                    if (t < r.length) {
                      r[t].push(e);
                    }
                  });
                  if (t.length !== a.length) {
                    const n = o.createAddendum();
                    n.addMessage((e.nodeType === 34 ? g.LocAddendum.listAssignmentMismatch() : g.LocAddendum.tupleAssignmentMismatch()).format({
                      type: Yr(l)
                    }));
                    n.createAddendum().addMessage((i >= 0 ? g.LocAddendum.tupleSizeMismatchIndeterminateDest() : g.LocAddendum.tupleSizeMismatch()).format({
                      expected: i >= 0 ? a.length - 1 : a.length,
                      received: t.length
                    }));
                  }
                } else {
                  const e = st({
                    type: l,
                    isIncomplete: t.isIncomplete
                  }, false, n)?.type ?? H.UnknownType.create();
                  for (let t = 0; t < a.length; t++) {
                    r[t].push(Z.addConditionToType(e, Z.getTypeCondition(l)));
                  }
                }
              });
              if (!o.isEmpty()) {
                kt(d.DiagnosticRule.reportAssignmentType, (e.nodeType === 34 ? g.LocMessage.listAssignmentMismatch() : g.LocMessage.tupleAssignmentMismatch()).format({
                  type: Yr(t.type)
                }) + o.getString(), e);
              }
              a.forEach((e, a) => {
                const s = r[a];
                Nt(e, {
                  type: s.length === 0 ? H.UnknownType.create() : H.combineTypes(s),
                  isIncomplete: t.isIncomplete
                }, n, true);
              });
              Fe(e, t, 0);
            })(e, t, n);
            break;
          case 54:
            {
              let i = Ze(e.d.annotation, {
                varTypeAnnotation: true,
                allowFinal: M.isFinalAllowedForAssignmentTarget(e.d.valueExpr),
                allowClassVar: M.isClassVarAllowedForAssignmentTarget(e.d.valueExpr)
              });
              if (i) {
                const t = M.getTypeVarScopesForNode(e);
                i = Z.makeTypeVarsBound(i, t);
              }
              if (!H.isClassInstance(i) || !H.ClassType.isBuiltIn(i, 'Final') && !H.ClassType.isBuiltIn(i, 'ClassVar')) {
                if (!H.isClassInstance(i) || !H.ClassType.isBuiltIn(i, 'TypeAlias')) {
                  if (Ir(i, t.type)) {
                    if (!H.isClassInstance(t.type) || !H.ClassType.isEnumClass(t.type)) {
                      t = Er(e, i, t);
                    }
                  }
                }
              }
              Nt(e.d.valueExpr, t, n, a, r, s);
              break;
            }
          case 56:
            if (e.d.expr.nodeType === 38) {
              St(e.d.expr, {
                type: Ya(e.d.expr, 'list', [t.type]),
                isIncomplete: t.isIncomplete
              }, a, n);
            }
            break;
          case 0:
            if (e.d.child) {
              Qa(e.d.child, () => {
                qe(e.d.child);
              });
            }
            break;
          default:
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.assignmentTargetExpr(), e);
        }
      }
      function Ft(e) {
        switch (e.nodeType) {
          case 38:
            qe(e);
            break;
          case 35:
            {
              const t = qe(e.d.leftExpr, 2);
              const n = Bt(e, t, {
                method: 'del'
              }, 0);
              const a = {
                type: n.type,
                memberAccessDeprecationInfo: n.memberAccessDeprecationInfo
              };
              Fe(e.d.member, a, 0);
              Fe(e, a, 0);
              break;
            }
          case 27:
            {
              const t = qe(e.d.leftExpr, 2);
              $t(e, t, {
                method: 'del'
              }, 0);
              Fe(e, {
                type: H.UnboundType.create()
              }, 0);
              break;
            }
          case 52:
            e.d.items.forEach(e => {
              Ft(e);
            });
            break;
          case 0:
            if (e.d.child) {
              Qa(e.d.child, () => {
                qe(e.d.child);
              });
            }
            break;
          default:
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.delTargetExpr(), e);
        }
      }
      function Et(e, t, n) {
        if (!ar(n)) {
          e.accessedSymbolSet.add(t.id);
        }
      }
      function Mt(e, t, n, a) {
        var r;
        var s;
        if (!Zr(e)) {
          return t;
        }
        const i = Ot(t, a);
        if ((r = t.props) === null || r === undefined ? undefined : r.typeForm) {
          if (n & 33554432 && !i) {
            t = H.TypeBase.cloneWithTypeForm(t, undefined);
          }
          return t;
        }
        if (!i) {
          return t;
        }
        if (H.isTypeVar(t) && t.priv.scopeId && !t.shared.isSynthesized) {
          if (!H.isTypeVarTuple(t) || !t.priv.isInUnion) {
            const n = M.getTypeVarScopesForNode(e);
            t = H.TypeBase.cloneWithTypeForm(t, Z.convertToInstance(Z.makeTypeVarsBound(t, n)));
          }
        } else {
          if (!!H.isInstantiableClass(t) && !t.priv.includeSubclasses && !H.ClassType.isSpecialBuiltIn(t)) {
            t = H.ClassType.isBuiltIn(t, 'Any') ? H.TypeBase.cloneWithTypeForm(t, H.AnyType.create()) : H.TypeBase.cloneWithTypeForm(t, H.ClassType.cloneAsInstance(Z.specializeWithDefaultTypeArgs(t)));
          }
        }
        if (((s = t.props) === null || s === undefined ? undefined : s.typeAliasInfo) && H.TypeBase.isInstantiable(t)) {
          let e = t;
          if (!(n & 2)) {
            e = Wt(e, undefined);
          }
          t = H.TypeBase.cloneWithTypeForm(t, Z.convertToInstance(e));
        }
        return t;
      }
      function Ot(e, t) {
        var n;
        return !t || !!((n = e.props) === null || n === undefined ? undefined : n.typeAliasInfo) || !!Z.isTypeAliasPlaceholder(e) || !!H.isTypeVar(e) || !!H.isClass(e) && !e.priv.includeSubclasses && !!H.ClassType.isValidTypeAliasClass(e);
      }
      function zt(e, t, n) {
        if (Ot(t, n)) {
          return t;
        }
        if (v.getFileInfo(e).isTypingStubFile) {
          return t;
        } else {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeAnnotationVariable(), e);
          return H.UnknownType.create();
        }
      }
      function Ut(e, t, n = false) {
        var a;
        var r;
        var s;
        var i;
        if (t & 33554816) {
          return e;
        } else {
          if (n && H.isModule(e) && (Ae == null ? undefined : Ae.moduleTypeClass) && H.isInstantiableClass(Ae.moduleTypeClass)) {
            return H.ClassType.cloneAsInstance(Ae.moduleTypeClass);
          } else {
            if (t & 536870912 && H.isUnion(e) && ((a = e.props) === null || a === undefined ? undefined : a.typeAliasInfo) && !e.props.typeAliasInfo.shared.isPep695Syntax) {
              return e;
            } else {
              if ((r = e.props) === null || r === undefined ? undefined : r.specialForm) {
                if (t & 2 && ((s = e.props) === null || s === undefined ? undefined : s.typeAliasInfo) && !H.ClassType.isBuiltIn(e.props.specialForm, 'TypeAliasType')) {
                  return e;
                } else {
                  if ((i = e.props) === null || i === undefined ? undefined : i.typeForm) {
                    return H.TypeBase.cloneWithTypeForm(e.props.specialForm, e.props.typeForm);
                  } else {
                    return e.props.specialForm;
                  }
                }
              } else {
                return e;
              }
            }
          }
        }
      }
      function Vt(e, t, n) {
        var a;
        if (!H.TypeBase.isInstantiable(t) || Z.isTypeAliasPlaceholder(t)) {
          return t;
        }
        if (!t.priv.scopeId) {
          t = function (e, t, n) {
            var a;
            const r = Lt(e, t);
            t = r.type;
            if (!!(n & 2048) && !!t.priv.scopeId) {
              if (t.shared.isSynthesized || H.isParamSpec(t)) {
                return t;
              }
              if (t.shared.isTypeParamSyntax) {
                return t;
              }
              const n = M.getTypeVarScopeNode(e);
              if (!n || !n.d.typeParams || !!n.d.typeParams.d.params.some(t => t.d.name === e)) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarUsedByOuterScope().format({
                  name: t.shared.name
                }), e);
              }
              return t;
            }
            if (n & 8192) {
              if (t.priv.scopeId) {
                return t;
              }
              if (r.foundInterveningClass) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarUsedByOuterScope().format({
                  name: t.shared.name
                }), e);
                return t;
              }
              let n = M.getEnclosingClassOrFunction(e);
              if (n && ((a = e.parent) === null || a === undefined ? undefined : a.nodeType) === 35 && e.parent.d.leftExpr === e) {
                const a = e.parent.d.member.d.value;
                if (a === 'args' || a === 'kwargs') {
                  const a = M.getEnclosingClassOrFunction(n);
                  if ((a == null ? undefined : a.nodeType) === 31) {
                    n = a;
                  } else {
                    if (!r.type.priv.scopeId) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecNotUsedByOuterScope().format({
                        name: t.shared.name
                      }), e);
                    }
                  }
                }
              }
              if (!n) {
                l.fail('AssociateTypeVarsWithCurrentScope flag was set but enclosing scope not found');
              }
              if (n.d.typeParams && !n.d.typeParams.d.params.some(e => e.d.name.d.value === t.shared.name)) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeParameterNotDeclared().format({
                  name: t.shared.name,
                  container: n.d.name.d.value
                }), e);
              }
              const s = M.getScopeIdForNode(n);
              return H.TypeVarType.cloneForScopeId(t, s, n.d.name.d.value, n.nodeType === 31 ? 1 : 0);
            }
            if (!(n & 4096)) {
              if (t.priv.scopeId && !r.foundInterveningClass) {
                return t;
              }
              if (!t.shared.isSynthesized && n & 128) {
                const n = H.isParamSpec(t) ? g.LocMessage.paramSpecNotUsedByOuterScope() : g.LocMessage.typeVarNotUsedByOuterScope();
                kt(d.DiagnosticRule.reportGeneralTypeIssues, n.format({
                  name: t.shared.name
                }), e);
              }
            }
            return t;
          }(e, t, n);
        }
        if (t.priv.scopeId && !H.TypeVarType.isBound(t)) {
          const n = (a = Lt(e, t)) === null || a === undefined ? undefined : a.scopeNode;
          if (n) {
            const a = M.getEnclosingClassOrFunctionSuite(e);
            if (a && M.isNodeContainedWithin(a, n)) {
              if (n.nodeType !== 10 || n.d.suite !== a) {
                t = H.TypeVarType.cloneAsBound(t);
              }
            }
          }
        }
        if (H.isUnpackedTypeVarTuple(t)) {
          t = H.TypeVarType.cloneForPacked(t);
        }
        if (n & -2147483648 && !function (e, t) {
          var n;
          var a;
          const r = (a = (n = t.priv.freeTypeVar) === null || n === undefined ? undefined : n.priv.scopeId) !== null && a !== undefined ? a : t.priv.scopeId;
          if (!r) {
            return true;
          }
          const s = M.getEnclosingClass(e);
          if (s) {
            if (!M.getTypeVarScopesForNode(s).includes(r)) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarInvalidForMemberVariable().format({
                name: H.TypeVarType.getReadableName(t)
              }), e);
              return false;
            }
          }
          return true;
        }(e, t)) {
          return H.UnknownType.create();
        } else {
          return t;
        }
      }
      function Rt(e, t, n) {
        var a;
        var r;
        if (!(n & 2)) {
          if (H.isInstantiableClass(t)) {
            if (n & 128 && !(n & 512) && !((a = t.props) === null || a === undefined ? undefined : a.typeAliasInfo) && Z.requiresTypeArgs(t)) {
              if (!t.priv.typeArgs || !t.priv.isTypeArgExplicit) {
                kt(d.DiagnosticRule.reportMissingTypeArgument, g.LocMessage.typeArgsMissingForClass().format({
                  name: t.priv.aliasName || t.shared.name
                }), e);
              }
            }
            if (!t.priv.typeArgs) {
              t = (r = Ga(t, undefined, n, e)) === null || r === undefined ? undefined : r.type;
            }
          }
          if (n & 128) {
            t = Wt(t, e);
          }
        }
        return t;
      }
      function Lt(e, t) {
        var n;
        var a;
        let r = e;
        let s = 0;
        for (l.assert(H.TypeBase.isInstantiable(t)); r;) {
          const e = M.getTypeVarScopeNode(r);
          if (!e) {
            break;
          }
          let n;
          r = e;
          let a = false;
          if (r.nodeType === 10) {
            const e = ca(r);
            if (e && !H.ClassType.isPartiallyEvaluated(e.classType)) {
              n = e.classType.shared.typeParams;
            }
            a = !!r.d.typeParams;
            s++;
          } else {
            if (r.nodeType === 31) {
              const e = ba(r);
              if (e) {
                n = e.shared.typeParams;
              }
              a = !!r.d.typeParams;
            } else {
              if (r.nodeType === 77) {
                a = !!r.d.typeParams;
              }
            }
          }
          if (n) {
            const r = n.find(e => e.shared.name === t.shared.name);
            if ((r == null ? undefined : r.priv.scopeId) !== undefined && r.priv.scopeName !== undefined && r.priv.scopeType !== undefined) {
              return {
                type: t = H.TypeVarType.cloneForScopeId(t, r.priv.scopeId, r.priv.scopeName, r.priv.scopeType),
                scopeNode: e,
                foundInterveningClass: s > 1 && !a
              };
            }
          }
          r = r.parent;
        }
        for (r = e; r;) {
          let s;
          let i;
          let o;
          if (r.nodeType === 77) {
            s = Ne(r.d.name, 0);
            i = r;
            o = r;
          } else {
            if (r.nodeType === 3) {
              s = Ne(r.d.leftExpr, 0);
              o = r;
            }
          }
          if (s && o && s && H.isTypeVar(s) && s.shared.recursiveAlias) {
            if (!i || t.shared.isTypeParamSyntax || ((n = t.props) === null || n === undefined ? undefined : n.typeAliasInfo)) {
              const e = (a = s.shared.recursiveAlias) === null || a === undefined ? undefined : a.typeParams;
              if (e && !e.some(e => e.shared.name === t.shared.name)) {
                return {
                  type: t,
                  scopeNode: o,
                  foundInterveningClass: false
                };
              }
            } else {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeParameterNotDeclared().format({
                name: t.shared.name,
                container: i.d.name.d.value
              }), e);
            }
            return {
              type: H.TypeVarType.cloneForScopeId(t, s.shared.recursiveAlias.typeVarScopeId, s.shared.recursiveAlias.name, 2),
              scopeNode: o,
              foundInterveningClass: false
            };
          }
          r = r.parent;
        }
        return {
          type: t,
          scopeNode: undefined,
          foundInterveningClass: false
        };
      }
      function Bt(e, t, a, r) {
        var s;
        var i;
        var o;
        var c;
        let m = Z.transformPossibleRecursiveTypeAlias(t.type);
        const y = e.d.member.d.value;
        let h = new p.DiagnosticAddendum();
        const f = v.getFileInfo(e);
        let T;
        let b;
        let _;
        let C = false;
        let I = !!t.isIncomplete;
        let k;
        if ((s = a == null ? undefined : a.setType) === null || s === undefined ? undefined : s.isIncomplete) {
          I = true;
        }
        if (t.isIncomplete && H.isUnbound(m)) {
          return {
            type: H.UnknownType.create(true),
            isIncomplete: true
          };
        }
        if (!!((i = m.props) === null || i === undefined ? undefined : i.specialForm) && !(r & 256)) {
          m = m.props.specialForm;
        }
        if (H.isParamSpec(m) && m.priv.paramSpecAccess) {
          m = Pt(m);
        }
        switch (m.category) {
          case 2:
          case 1:
          case 3:
            T = m;
            break;
          case 0:
            break;
          case 9:
            if (H.isParamSpec(m)) {
              if (y === 'args' || y === 'kwargs') {
                const t = y === 'args';
                const n = M.getEnclosingParam(e);
                const a = t ? 1 : 2;
                if (!n || n.d.category !== a) {
                  const n = t ? g.LocMessage.paramSpecArgsUsage() : g.LocMessage.paramSpecKwargsUsage();
                  kt(d.DiagnosticRule.reportInvalidTypeForm, n, e);
                  T = H.UnknownType.create(I);
                  break;
                }
                T = H.TypeVarType.cloneForParamSpecAccess(m, y);
                break;
              }
              if (!I) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecUnknownMember().format({
                  name: y
                }), e);
              }
              T = H.UnknownType.create(I);
              break;
            }
            if (r & 256) {
              if (!I) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarNoMember().format({
                  type: Yr(m),
                  name: y
                }), e.d.leftExpr);
              }
              T = H.UnknownType.create(I);
              break;
            }
            if (m.shared.recursiveAlias) {
              T = H.UnknownType.create(true);
              I = true;
              break;
            }
            if (H.isTypeVarTuple(m)) {
              break;
            }
            return Bt(e, {
              type: Pt(m),
              bindToSelfType: H.TypeBase.isInstantiable(m) ? Z.convertToInstance(m) : m,
              isIncomplete: I
            }, a, 0);
          case 6:
            {
              let n;
              const s = P.getTypeOfEnumMember(es, e, m, y, I);
              if (s) {
                if (a.method === 'get') {
                  n = s;
                } else {
                  if (H.isClassInstance(s.type) && H.ClassType.isSameGenericClass(s.type, H.ClassType.cloneAsInstance(m)) && s.type.priv.literalValue !== undefined) {
                    const t = a.method === 'set' ? g.LocMessage.enumMemberSet() : g.LocMessage.enumMemberDelete();
                    kt(d.DiagnosticRule.reportAttributeAccessIssue, t.format({
                      name: y
                    }) + h.getString(), e.d.member, (o = h.getEffectiveTextRange()) !== null && o !== undefined ? o : e.d.member);
                  }
                }
              }
              if (!n) {
                n = et(e.d.member, m, y, a, h, r & 256 ? 2048 : undefined, t.bindToSelfType);
              }
              if (n) {
                if (n.typeErrors) {
                  C = true;
                } else {
                  T = Z.addConditionToType(n.type, Z.getTypeCondition(m), {
                    skipSelfCondition: true,
                    skipBoundTypeVars: true
                  });
                }
                if (n.isAsymmetricAccessor) {
                  _ = true;
                }
                if (n.isIncomplete) {
                  I = true;
                }
                if (n.narrowedTypeForSet) {
                  b = Z.addConditionToType(n.narrowedTypeForSet, Z.getTypeCondition(m), {
                    skipSelfCondition: true,
                    skipBoundTypeVars: true
                  });
                }
                if (n.memberAccessDeprecationInfo) {
                  k = n.memberAccessDeprecationInfo;
                }
              }
              break;
            }
          case 7:
            {
              const t = H.ModuleType.getField(m, y);
              if (t && !t.isExternallyHidden()) {
                if (a.method === 'get') {
                  Et(f, t, e.d.member);
                }
                const n = ur(t, undefined, true);
                T = n.type;
                if (r & 256) {
                  T = zt(e, T, !!n.includesVariableDecl);
                }
                T = Mt(e, T, r, !!n.includesVariableDecl);
                if (H.isTypeVar(T)) {
                  T = Vt(e, T, r);
                }
                if (H.isUnbound(T)) {
                  T = H.UnknownType.create(true);
                }
                if (t.isPrivateMember()) {
                  kt(d.DiagnosticRule.reportPrivateUsage, g.LocMessage.privateUsedOutsideOfModule().format({
                    name: y
                  }), e.d.member);
                }
                if (t.isPrivatePyTypedImport()) {
                  kt(d.DiagnosticRule.reportPrivateImportUsage, g.LocMessage.privateImportFromPyTypedModule().format({
                    name: y,
                    module: m.priv.moduleName
                  }), e.d.member);
                }
              } else {
                if (a.method === 'get') {
                  const e = H.ModuleType.getField(m, '__getattr__');
                  if (e) {
                    if (u.PythonVersion.isGreaterOrEqualTo(f.executionEnvironment.pythonVersion, u.pythonVersion3_7) || e.getDeclarations().some(e => e.uri.hasExtension('.pyi'))) {
                      const t = ur(e);
                      if (H.isFunction(t.type)) {
                        T = hr(t.type);
                        if (t.isIncomplete) {
                          I = true;
                        }
                      }
                    }
                  }
                }
                if (!T && m.priv.notPresentFieldType) {
                  T = m.priv.notPresentFieldType;
                }
                if (!T) {
                  if (!I) {
                    kt(d.DiagnosticRule.reportAttributeAccessIssue, g.LocMessage.moduleUnknownMember().format({
                      memberName: y,
                      moduleName: m.priv.moduleName
                    }), e.d.member);
                  }
                  T = n.evaluateUnknownImportsAsAny ? H.AnyType.create() : H.UnknownType.create();
                }
              }
              break;
            }
          case 8:
            T = Z.mapSubtypes(m, n => {
              if (H.isUnbound(n)) {
                return;
              }
              if (Z.isNoneInstance(n)) {
                l.assert(H.isClassInstance(n));
                const t = et(e.d.member, n, y, a, h);
                if (t && !t.typeErrors) {
                  T = Z.addConditionToType(t.type, Z.getTypeCondition(m), {
                    skipBoundTypeVars: true
                  });
                  if (t.isIncomplete) {
                    I = true;
                  }
                  return T;
                } else {
                  if (!I) {
                    kt(d.DiagnosticRule.reportOptionalMemberAccess, g.LocMessage.noneUnknownMember().format({
                      name: y
                    }), e.d.member);
                  }
                  return;
                }
              }
              const r = Bt(e, {
                type: n,
                isIncomplete: t.isIncomplete
              }, a, 0);
              if (r.isIncomplete) {
                I = true;
              }
              if (r.memberAccessDeprecationInfo) {
                k = r.memberAccessDeprecationInfo;
              }
              if (r.typeErrors) {
                C = true;
              }
              return r.type;
            });
            break;
          case 4:
          case 5:
            if (y === '__self__') {
              let e;
              if (H.isFunction(m)) {
                e = m;
              } else {
                const t = H.OverloadedType.getOverloads(m);
                if (t.length > 0) {
                  e = t[0];
                }
              }
              if (!!e && e.priv.preBoundFlags !== undefined && !(e.priv.preBoundFlags & 4)) {
                T = e.priv.boundToType;
              }
            } else {
              T = Bt(e, {
                type: (Ae == null ? undefined : Ae.functionClass) ? Z.convertToInstance(Ae.functionClass) : H.UnknownType.create()
              }, a, r).type;
            }
            break;
          default:
            l.assertNever(m);
        }
        if (!T) {
          const n = H.isFunction(m) || H.isOverloaded(m) || H.isClassInstance(m) && H.ClassType.isBuiltIn(m, 'function');
          if (!t.isIncomplete) {
            let t = g.LocMessage.memberAccess();
            if (a.method === 'set') {
              t = g.LocMessage.memberSet();
            } else {
              if (a.method === 'del') {
                t = g.LocMessage.memberDelete();
              }
            }
            if (a.setExpectedTypeDiag) {
              h = a.setExpectedTypeDiag;
            }
            if (H.isClass(m) && m.shared.typedDictEntries) {
              if (m.shared.typedDictEntries.knownItems.get(y)) {
                const e = new p.DiagnosticAddendum();
                e.addMessage(g.LocAddendum.typedDictKeyAccess().format({
                  name: y
                }));
                h.addAddendum(e);
              }
            }
            kt(n ? d.DiagnosticRule.reportFunctionMemberAccess : d.DiagnosticRule.reportAttributeAccessIssue, t.format({
              name: y,
              type: Yr(m)
            }) + h.getString(), e.d.member, (c = h.getEffectiveTextRange()) !== null && c !== undefined ? c : e.d.member);
          }
          T = n ? H.AnyType.create() : H.UnknownType.create();
        }
        if (!(r & 256)) {
          Ge(T, e.d.member);
        }
        T = Ut(T, r);
        return {
          type: T,
          isIncomplete: I,
          isAsymmetricAccessor: _,
          narrowedTypeForSet: b,
          isRequired: false,
          isNotRequired: false,
          memberAccessDeprecationInfo: k,
          typeErrors: C
        };
      }
      function jt(e, t, n, a, r, s, i, o = 0) {
        var d;
        var c;
        var u;
        const m = H.TypeBase.isInstance(t);
        let y;
        let h = Z.lookUpClassMember(t, n, s | 64);
        if (!h) {
          h = Z.lookUpClassMember(t, n, s);
        }
        if (!h) {
          if (!(s & 512) && e) {
            const r = function (e, t, n, a, r) {
              var s;
              var i;
              var o;
              var p;
              var d;
              const c = n => {
                var a;
                if ((a = et(e, t, n, undefined, undefined, 540, r)) === null || a === undefined) {
                  return undefined;
                } else {
                  return a.type;
                }
              };
              let u;
              if (n.method === 'get') {
                u = (s = c('__getattribute__')) !== null && s !== undefined ? s : c('__getattr__');
              } else {
                if (n.method === 'set') {
                  u = c('__setattr__');
                } else {
                  l.assert(n.method === 'del');
                  u = c('__delattr__');
                }
              }
              if (!u) {
                return;
              }
              const m = [];
              m.push({
                argCategory: 0,
                typeResult: {
                  type: (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass) ? H.ClassType.cloneWithLiteral(H.ClassType.cloneAsInstance(Ae.strClass), a) : H.AnyType.create()
                }
              });
              if (n.method === 'set') {
                m.push({
                  argCategory: 0,
                  typeResult: {
                    type: (o = (i = n.setType) === null || i === undefined ? undefined : i.type) !== null && o !== undefined ? o : H.UnknownType.create(),
                    isIncomplete: !!((p = n.setType) === null || p === undefined ? undefined : p.isIncomplete)
                  }
                });
              }
              if (!H.isFunction(u) && !H.isOverloaded(u)) {
                if (H.isAnyOrUnknown(u)) {
                  return {
                    type: u
                  };
                } else {
                  return undefined;
                }
              }
              const y = pn(e, m, {
                type: u
              }, undefined, true, undefined);
              let g = false;
              if (n.method === 'set') {
                g = function (e) {
                  var t;
                  if (e.priv.isAsymmetricAttributeAccessor !== undefined) {
                    return e.priv.isAsymmetricAttributeAccessor;
                  }
                  let n = false;
                  const a = Z.lookUpClassMember(e, '__getattr__', 2);
                  const r = Z.lookUpClassMember(e, '__setattr__', 2);
                  if (a && r) {
                    const e = cr(a.symbol);
                    const s = cr(r.symbol);
                    if (H.isFunction(e) && H.isFunction(s) && s.shared.parameters.length >= 3 && e.shared.declaredReturnType) {
                      const a = H.FunctionType.getParamType(s, 2);
                      const r = (t = H.FunctionType.getEffectiveReturnType(e)) !== null && t !== undefined ? t : H.UnknownType.create();
                      if (!H.isTypeSame(a, r)) {
                        n = true;
                      }
                    }
                  } else {
                    n = false;
                  }
                  e.priv.isAsymmetricAttributeAccessor = n;
                  return n;
                }(t);
              }
              return {
                type: (d = y.returnType) !== null && d !== undefined ? d : H.UnknownType.create(),
                typeErrors: y.argumentErrors,
                isAsymmetricAccessor: g
              };
            }(e, t, a, n, i);
            if (r) {
              return {
                symbol: undefined,
                type: r.type,
                isTypeIncomplete: false,
                isDescriptorError: false,
                isClassMember: false,
                isClassVar: false,
                isAsymmetricAccessor: !!r.isAsymmetricAccessor
              };
            }
          }
          if (r != null) {
            r.addMessage(g.LocAddendum.memberUnknown().format({
              name: n
            }));
          }
          return;
        }
        let f;
        let T = false;
        if (h.symbol.isInitVar()) {
          if (r != null) {
            r.addMessage(g.LocAddendum.memberIsInitVar().format({
              name: n
            }));
          }
          return;
        }
        if (a.method !== 'get' && e) {
          const r = M.getEnclosingClass(e);
          if (r) {
            const o = (d = ca(r)) === null || d === undefined ? undefined : d.classType;
            if (o && H.isInstantiableClass(o) && H.ClassType.isSameGenericClass(m ? H.ClassType.cloneAsInstance(o) : o, t)) {
              y = (c = yr(h.symbol)) === null || c === undefined ? undefined : c.type;
              if (y && H.isInstantiableClass(h.classType)) {
                y = Z.partiallySpecializeType(y, h.classType, undefined, i);
              }
              if (a.method === 'set' && j.isEffectivelyClassVar(h.symbol, H.ClassType.isDataClass(o)) && m) {
                const a = vr(e, h, i ?? n === '__new__' ? undefined : t, s);
                if (a && Z.isDescriptorInstance(a.type, true)) {
                  y = a.type;
                  s &= 128;
                }
              }
              if (!y) {
                y = H.UnknownType.create();
              }
            }
          }
        }
        if (!y) {
          let a;
          if (i) {
            a = Z.convertToInstantiable(i);
          } else {
            if (n !== '__new__') {
              a = t;
            }
          }
          const r = vr(e, h, a, s);
          y = (u = r == null ? undefined : r.type) !== null && u !== undefined ? u : H.UnknownType.create();
          if (r == null ? undefined : r.isIncomplete) {
            T = true;
          }
        }
        if (H.isClass(h.classType) && H.ClassType.isTypedDictClass(h.classType)) {
          const e = h.symbol.getTypedDeclarations();
          if (e.length > 0 && e[0].type === 1) {
            if (r != null) {
              r.addMessage(g.LocAddendum.memberUnknown().format({
                name: n
              }));
            }
            return;
          }
        }
        if (a.method === 'get') {
          if (e && H.isInstantiableClass(h.classType) && H.ClassType.isSameGenericClass(h.classType, m ? H.ClassType.cloneAsInstantiable(t) : t)) {
            Et(v.getFileInfo(e), h.symbol, e);
          }
          if (n === '__init_subclass__' || n === '__class_getitem__') {
            if (H.isFunction(y) && !H.FunctionType.isClassMethod(y)) {
              y = H.FunctionType.cloneWithNewFlags(y, y.shared.flags | 2);
            }
          }
        }
        let b;
        let _ = false;
        let C = false;
        let I = false;
        y = Z.mapSubtypes(y, l => {
          const d = Pt(l);
          const c = !h || h.isClassMember;
          let u;
          if (H.isClass(d) && c && e) {
            const o = function (e, t, n, a, r, s, i, o, l, d) {
              var c;
              var u;
              var m;
              var y;
              var h;
              var f;
              var T;
              const v = H.TypeBase.isInstance(a);
              let b;
              b = l.method === 'get' ? '__get__' : l.method === 'set' ? '__set__' : '__delete__';
              const _ = d ? new p.DiagnosticAddendum() : undefined;
              const C = et(i, t, b, undefined, _, 528);
              if (!C || C.typeErrors) {
                if (H.ClassType.isPropertyClass(t) && l.method !== 'get') {
                  const e = l.method === 'set' ? g.LocAddendum.propertyMissingSetter() : g.LocAddendum.propertyMissingDeleter();
                  if (d != null) {
                    d.addMessage(e.format({
                      name: o
                    }));
                  }
                  return {
                    type: H.AnyType.create(),
                    typeErrors: true
                  };
                }
                if (a.shared.typeVarScopeId) {
                  e = Z.makeTypeVarsBound(e, [a.shared.typeVarScopeId]);
                }
                return {
                  type: e
                };
              }
              const I = C.classType;
              let w = C.type;
              if (C.typeErrors || !I) {
                if (d && _) {
                  d.addAddendum(_);
                }
                return {
                  type: H.UnknownType.create(),
                  typeErrors: true
                };
              }
              if (!H.isFunction(w) && !H.isOverloaded(w)) {
                if (H.isAnyOrUnknown(w)) {
                  return {
                    type: w
                  };
                } else {
                  return {
                    type: e,
                    typeErrors: true
                  };
                }
              }
              if (H.ClassType.isPropertyClass(t) && n && H.isInstantiableClass(n.classType) && w) {
                if (s & 16 && H.ClassType.isProtocolClass(a)) {
                  if (d != null) {
                    d.addMessage(g.LocAddendum.propertyAccessFromProtocolClass());
                  }
                  return {
                    type: e,
                    typeErrors: true
                  };
                }
                let i;
                gr(w);
                i = l.method === 'get' ? (c = t.priv.fgetInfo) === null || c === undefined ? undefined : c.classType : l.method === 'set' ? (u = t.priv.fsetInfo) === null || u === undefined ? undefined : u.classType : (m = t.priv.fdelInfo) === null || m === undefined ? undefined : m.classType;
                if (i) {
                  const e = new k.ConstraintTracker();
                  i = Z.selfSpecializeClass(i);
                  Ir(H.ClassType.cloneAsInstance(i), H.ClassType.cloneAsInstance(n.classType), undefined, e);
                  i = Xe(i, e);
                  const t = Z.partiallySpecializeType(w, i, dt(), r ? Z.convertToInstantiable(r) : a);
                  if (H.isFunction(t) || H.isOverloaded(t)) {
                    w = t;
                  }
                }
              }
              let S = false;
              if (l.method === 'set' && H.isClass(I) && function (e) {
                var t;
                if (e.priv.isAsymmetricDescriptor !== undefined) {
                  return e.priv.isAsymmetricDescriptor;
                }
                let n = false;
                const a = Z.lookUpClassMember(e, '__get__', 2);
                const r = Z.lookUpClassMember(e, '__set__', 2);
                if (a && r) {
                  let e = Tr(a);
                  const s = Tr(r);
                  if (H.isOverloaded(e)) {
                    const t = H.OverloadedType.getOverloads(e).filter(e => {
                      if (e.shared.parameters.length < 2) {
                        return false;
                      }
                      const t = H.FunctionType.getParamType(e, 1);
                      return !Z.isNoneInstance(t);
                    });
                    if (t.length === 1) {
                      e = t[0];
                    } else {
                      n = true;
                    }
                  }
                  if (H.isOverloaded(s)) {
                    n = true;
                  }
                  if (H.isFunction(e) && H.isFunction(s) && s.shared.parameters.length >= 3 && e.shared.declaredReturnType) {
                    const a = H.FunctionType.getParamType(s, 2);
                    const r = (t = H.FunctionType.getEffectiveReturnType(e)) !== null && t !== undefined ? t : H.UnknownType.create();
                    if (!H.isTypeSame(a, r)) {
                      n = true;
                    }
                  }
                } else {
                  n = false;
                }
                e.priv.isAsymmetricDescriptor = n;
                return n;
              }(I)) {
                S = true;
              }
              if (!w) {
                if (d != null) {
                  d.addMessage(g.LocAddendum.descriptorAccessBindingFailed().format({
                    name: b,
                    className: Yr(Z.convertToInstance(I))
                  }));
                }
                return {
                  type: H.UnknownType.create(),
                  typeErrors: true,
                  isDescriptorApplied: true,
                  isAsymmetricAccessor: S
                };
              }
              const A = [];
              let x;
              x = H.ClassType.isClassProperty(t) ? v ? H.ClassType.cloneAsInstantiable(a) : a : v ? r ?? H.ClassType.cloneAsInstance(a) : pt();
              A.push({
                argCategory: 0,
                typeResult: {
                  type: x
                }
              });
              if (l.method === 'get') {
                let e;
                e = r ? Z.convertToInstantiable(r) : v ? H.ClassType.cloneAsInstantiable(a) : a;
                A.push({
                  argCategory: 0,
                  typeResult: {
                    type: e
                  }
                });
              } else {
                if (l.method === 'set') {
                  A.push({
                    argCategory: 0,
                    typeResult: {
                      type: (h = (y = l.setType) === null || y === undefined ? undefined : y.type) !== null && h !== undefined ? h : H.UnknownType.create(),
                      isIncomplete: !!((f = l.setType) === null || f === undefined ? undefined : f.isIncomplete)
                    }
                  });
                }
              }
              const P = Qa(i, () => pn(i, A, {
                type: w
              }, undefined, true, undefined), e => {
                if (d) {
                  e.forEach(e => {
                    if (d != null) {
                      d.addMessageMultiline(e);
                    }
                  });
                }
              });
              let D;
              if (P.overloadsUsedForCall && P.overloadsUsedForCall.length >= 1) {
                const e = P.overloadsUsedForCall[0];
                if (e.shared.deprecatedMessage) {
                  D = {
                    deprecatedMessage: e.shared.deprecatedMessage,
                    accessType: H.ClassType.isPropertyClass(t) ? 'property' : 'descriptor',
                    accessMethod: l.method
                  };
                }
              }
              if (!P.argumentErrors) {
                return {
                  type: l.method === 'get' ? (T = P.returnType) !== null && T !== undefined ? T : H.UnknownType.create() : H.AnyType.create(),
                  isDescriptorApplied: true,
                  isAsymmetricAccessor: S,
                  memberAccessDeprecationInfo: D
                };
              }
              return {
                type: H.UnknownType.create(),
                typeErrors: true,
                isDescriptorApplied: true,
                isAsymmetricAccessor: S,
                memberAccessDeprecationInfo: D
              };
            }(l, d, h, t, i, s, e, n, a, r);
            if (o.isAsymmetricAccessor) {
              C = true;
            }
            if (o.memberAccessDeprecationInfo) {
              b = o.memberAccessDeprecationInfo;
            }
            if (o.typeErrors) {
              _ = true;
            }
            if (o.isDescriptorApplied) {
              I = true;
            }
            u = o.type;
          } else {
            if (H.isFunction(d) || H.isOverloaded(d)) {
              const e = function (e, t, n, a, r, s, i, o, l, p = 0) {
                if (o.method === 'set') {
                  const e = H.isFunction(t) ? t : H.OverloadedType.getImplementation(t);
                  if (e && H.isFunction(e) && H.FunctionType.isFinal(e) && n && H.isClass(n.classType)) {
                    if (l != null) {
                      l.addMessage(g.LocMessage.finalMethodOverride().format({
                        name: i,
                        className: n.classType.shared.name
                      }));
                    }
                    return {
                      type: H.UnknownType.create(),
                      typeErrors: true
                    };
                  }
                }
                if (H.TypeBase.isInstance(a) && (!n || n.isInstanceMember)) {
                  return {
                    type: e
                  };
                }
                const d = Ur(a, t, n && H.isInstantiableClass(n.classType) ? n.classType : undefined, !!(s & 256), r && H.isClass(r) ? H.ClassType.cloneIncludeSubclasses(r) : r, l, p);
                return {
                  type: d ?? H.UnknownType.create(),
                  typeErrors: !d
                };
              }(l, d, h, t, i, s, n, a, r, o);
              u = e.type;
              if (e.typeErrors) {
                _ = true;
              }
            } else {
              u = l;
            }
          }
          if (a.method === 'get') {
            return u;
          }
          if (!I && h && j.isEffectivelyClassVar(h.symbol, H.ClassType.isDataClass(t)) && s & 128) {
            if (r != null) {
              r.addMessage(g.LocAddendum.memberSetClassVar().format({
                name: n
              }));
            }
            _ = true;
          }
          const m = h == null ? undefined : h.symbol.getDeclarations().find(e => Lr(e));
          if (m && e && !M.isNodeContainedWithin(e, m.node)) {
            const a = M.getEnclosingFunction(e);
            if (!a || a.d.name.d.value !== '__init__' || m.inferredTypeSource !== undefined || !!H.isInstantiableClass(t)) {
              if (r != null) {
                r.addMessage(g.LocMessage.finalReassigned().format({
                  name: n
                }));
              }
              _ = true;
            }
          }
          if ((h == null ? undefined : h.isInstanceMember) && H.isClass(h.classType) && h.isReadOnly) {
            if (r != null) {
              r.addMessage(g.LocAddendum.readOnlyAttribute().format({
                name: n
              }));
            }
            _ = true;
          }
          return u;
        });
        if (!_ && a.method === 'set' && a.setType) {
          if (e && h.symbol.hasTypedDeclarations()) {
            f = I ? a.setType.type : Er(e, y, a.setType).type;
          }
          if (!Ir(y, a.setType.type, r == null ? undefined : r.createAddendum())) {
            if (!a.setType.isIncomplete && r != null) {
              r.addMessage(g.LocAddendum.memberAssignment().format({
                type: Yr(a.setType.type),
                name: n,
                classType: $r(t)
              }));
            }
            f = y;
            _ = true;
          }
          if (H.isInstantiableClass(h.classType) && H.ClassType.isDataClassFrozen(h.classType) && m) {
            if (r != null) {
              r.addMessage(g.LocAddendum.dataClassFrozen().format({
                name: Yr(H.ClassType.cloneAsInstance(h.classType))
              }));
            }
            _ = true;
          }
        }
        return {
          symbol: h.symbol,
          type: y,
          isTypeIncomplete: T,
          isDescriptorError: _,
          isClassMember: !h.isInstanceMember,
          isClassVar: h.isClassVar,
          classType: h.classType,
          isAsymmetricAccessor: C,
          narrowedTypeForSet: f,
          memberAccessDeprecationInfo: b
        };
      }
      function qt(e, t, n) {
        const a = t.findIndex(e => H.isTypeVarTuple(e));
        let r;
        let s = e.findIndex(e => !!H.isUnpackedClass(e.type) && !!e.type.priv.tupleTypeArgs && e.type.priv.tupleTypeArgs.length === 1 && !!e.type.priv.tupleTypeArgs[0].isUnbounded && (r = e.type.priv.tupleTypeArgs[0].type, true));
        if (r && s >= 0 && a >= 0 && e.length < t.length) {
          while (a > s) {
            e = [...e.slice(0, s), {
              node: e[s].node,
              type: r
            }, ...e.slice(s)];
            s++;
          }
          while (e.length < t.length) {
            e = [...e.slice(0, s + 1), {
              node: e[s].node,
              type: r
            }, ...e.slice(s + 1)];
          }
        }
        if (a >= 0) {
          const r = t[a];
          let s = t.length;
          while (s > 0) {
            const e = t[s - 1];
            if (!H.isParamSpec(e) || !e.shared.isDefaultExplicit) {
              break;
            }
            s--;
          }
          if (a < e.length) {
            let t = a + 1 + e.length - s;
            while (t > a && e[t - 1].typeList) {
              t--;
            }
            const n = e.slice(a, t);
            if (n.length === 1 && H.isTypeVarTuple(n[0].type)) {
              Gt(n[0].type, n[0].node);
            } else {
              n.forEach((e, t) => {
                Ln(e, {
                  allowEmptyTuple: t === 0,
                  allowTypeVarTuple: true,
                  allowUnpackedTuples: true
                });
              });
              const r = [];
              if (n.length !== 1 || !n[0].isEmptyTupleShorthand) {
                n.forEach(e => {
                  if (H.isUnpackedClass(e.type) && e.type.priv.tupleTypeArgs) {
                    o.appendArray(r, e.type.priv.tupleTypeArgs);
                  } else {
                    r.push({
                      type: Z.convertToInstance(e.type),
                      isUnbounded: false
                    });
                  }
                });
              }
              const s = q.makeTupleObject(es, r, true);
              e = [...e.slice(0, a), {
                node: e[a].node,
                type: s
              }, ...e.slice(t, e.length)];
            }
          } else {
            if (!r.shared.isDefaultExplicit) {
              e.push({
                node: n,
                type: q.makeTupleObject(es, [], true)
              });
            }
          }
        }
        return e;
      }
      function Gt(e, t) {
        return !!e.priv.isUnpacked || (kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackedTypeVarTupleExpected().format({
          name1: e.shared.name,
          name2: e.shared.name
        }), t), false);
      }
      function Wt(e, t) {
        var n;
        const a = (n = e.props) === null || n === undefined ? undefined : n.typeAliasInfo;
        if (!a) {
          return e;
        }
        if (!a.shared.typeParams || a.shared.typeParams.length === 0 || a.typeArgs) {
          return e;
        }
        let r = false;
        const s = [];
        const i = new k.ConstraintTracker();
        a.shared.typeParams.forEach(e => {
          let t;
          if (!e.shared.isDefaultExplicit) {
            r = true;
          }
          t = e.shared.isDefaultExplicit || H.isParamSpec(e) ? Xe(e, i, {
            replaceUnsolved: {
              scopeIds: [a.shared.typeVarScopeId],
              tupleClassType: ot()
            }
          }) : H.isTypeVarTuple(e) && (Ae == null ? undefined : Ae.tupleClass) && H.isInstantiableClass(Ae.tupleClass) ? q.makeTupleObject(es, [{
            type: H.UnknownType.create(),
            isUnbounded: true
          }], true) : H.UnknownType.create();
          s.push(t);
          i.setBounds(e, t);
        });
        if (r && t) {
          kt(d.DiagnosticRule.reportMissingTypeArgument, g.LocMessage.typeArgsMissingForAlias().format({
            name: a.shared.name
          }), t);
        }
        return e = H.TypeBase.cloneForTypeAlias(Xe(e, i, {
          replaceUnsolved: {
            scopeIds: [a.shared.typeVarScopeId],
            tupleClassType: ot()
          }
        }), {
          ...a,
          typeArgs: s
        });
      }
      function Kt(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        var o;
        var l;
        var c;
        let u = (a = t.props) === null || a === undefined ? undefined : a.typeAliasInfo;
        let m = t;
        if (!u && ((r = t.props) === null || r === undefined ? undefined : r.typeForm)) {
          u = (i = (s = t.props.typeForm) === null || s === undefined ? undefined : s.props) === null || i === undefined ? undefined : i.typeAliasInfo;
          m = Z.convertToInstantiable(t.props.typeForm);
        }
        if (!(u == null ? undefined : u.shared.typeParams) || u.shared.typeParams.length === 0 && u.typeArgs) {
          return;
        }
        if (!H.TypeBase.isInstantiable(m)) {
          return;
        }
        if (u.typeArgs) {
          return;
        }
        Ht(t);
        const y = u.shared.typeParams;
        let h;
        h = qt(Qt(e, n), y, e);
        let f = false;
        h = Wa(y, h, e);
        if (!h) {
          h = [];
          f = true;
        }
        let T = y.length;
        const v = y.findIndex(e => !!e.shared.isDefaultExplicit);
        if (v >= 0) {
          T = v;
        }
        if (h.length > y.length) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsTooMany().format({
            name: Yr(m),
            expected: y.length,
            received: h.length
          }), h[y.length].node);
          f = true;
        } else {
          if (h.length < T) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsTooFew().format({
              name: Yr(m),
              expected: y.length,
              received: h.length
            }), e.d.items[e.d.items.length - 1]);
            f = true;
          }
        }
        if (H.isInstantiableClass(m) && m.shared.fullName === 'mypy_extensions.FlexibleAlias' && h.length >= 1) {
          return {
            node: e,
            type: h[0].type
          };
        }
        const b = new k.ConstraintTracker();
        const _ = new p.DiagnosticAddendum();
        y.forEach((e, t) => {
          if (H.isParamSpec(e) && t < h.length) {
            const n = h[t].type;
            const a = h[t].typeList;
            if (a) {
              const t = H.FunctionType.createSynthesizedInstance('', 65536);
              a.forEach((e, n) => {
                let a = e.type;
                if (!Ln(e)) {
                  a = H.UnknownType.create();
                }
                H.FunctionType.addParam(t, H.FunctionParam.create(0, Z.convertToInstance(a), H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${n}`));
              });
              if (a.length > 0) {
                H.FunctionType.addPositionOnlyParamSeparator(t);
              }
              I.assignTypeVar(es, e, t, _, b, 256);
            } else {
              if (H.isParamSpec(n)) {
                I.assignTypeVar(es, e, Z.convertToInstance(n), _, b, 256);
              } else {
                if (H.isInstantiableClass(n) && H.ClassType.isBuiltIn(n, 'Concatenate')) {
                  const t = n.priv.typeArgs;
                  const a = H.FunctionType.createInstance('', '', '', 0);
                  if (t && t.length > 0) {
                    t.forEach((e, n) => {
                      if (n === t.length - 1) {
                        H.FunctionType.addPositionOnlyParamSeparator(a);
                        if (H.isParamSpec(e)) {
                          H.FunctionType.addParamSpecVariadics(a, e);
                        } else {
                          if (Z.isEllipsisType(e)) {
                            H.FunctionType.addDefaultParams(a);
                            a.shared.flags |= 32768;
                          }
                        }
                      } else {
                        H.FunctionType.addParam(a, H.FunctionParam.create(0, e, H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${n}`));
                      }
                    });
                  }
                  I.assignTypeVar(es, e, a, _, b, 256);
                } else {
                  if (Z.isEllipsisType(n)) {
                    const t = H.FunctionType.createSynthesizedInstance('', 98304);
                    H.FunctionType.addDefaultParams(t);
                    I.assignTypeVar(es, e, t, _, b);
                  } else {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgListExpected(), h[t].node);
                    f = true;
                  }
                }
              }
            }
          } else {
            let a;
            if (t < h.length && h[t].typeList) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgListNotAllowed(), h[t].node);
              f = true;
            }
            a = t < h.length ? Z.convertToInstance(h[t].type) : e.shared.isDefaultExplicit ? Xe(e, b, {
              replaceUnsolved: {
                scopeIds: [u.shared.typeVarScopeId],
                tupleClassType: ot()
              }
            }) : H.UnknownType.create();
            if (n & 16384) {
              const e = Ht(m);
              if (e && t < e.length) {
                const n = e[t];
                if (!Z.isVarianceOfTypeArgCompatible(a, n)) {
                  const e = _.createAddendum();
                  e.addMessage(g.LocAddendum.varianceMismatchForTypeAlias().format({
                    typeVarName: Yr(a),
                    typeAliasParam: Yr(y[t])
                  }));
                  e.addTextRange(h[t].node);
                }
              }
            }
            if (H.isUnpacked(a) && !H.isTypeVarTuple(e)) {
              const e = _.createAddendum();
              e.addMessage(g.LocMessage.unpackedArgInTypeArgument());
              e.addTextRange(h[t].node);
              a = H.UnknownType.create();
            }
            I.assignTypeVar(es, e, a, _, b, 256);
          }
        });
        if (!_.isEmpty()) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeNotSpecializable().format({
            type: Yr(m)
          }) + _.getString(), e, (o = _.getEffectiveTextRange()) !== null && o !== undefined ? o : e);
          f = true;
        }
        const C = I.solveConstraints(es, b).getMainSolutionSet();
        const w = [];
        if ((l = u.shared.typeParams) !== null && l !== undefined) {
          l.forEach(e => {
            let t = C.getType(e);
            if (!t) {
              t = Z.getUnknownForTypeVar(e, ot());
              b.setBounds(e, t);
            }
            w.push(t);
          });
        }
        let S = H.TypeBase.cloneForTypeAlias(Xe(m, b), {
          ...u,
          typeArgs: w
        });
        if (Zr(e)) {
          S = H.TypeBase.cloneWithTypeForm(S, f ? undefined : Z.convertToInstance(S));
        }
        if ((c = t.props) === null || c === undefined ? undefined : c.typeAliasInfo) {
          return {
            type: S,
            node: e
          };
        } else {
          return {
            type: H.TypeBase.cloneWithTypeForm(t, Z.convertToInstance(S)),
            node: e
          };
        }
      }
      function $t(e, t, n, a) {
        var r;
        var s;
        var i;
        const o = Kt(e, t.type, a);
        if (o) {
          return o;
        }
        if (H.isNever(t.type) && ((r = t.type.props) === null || r === undefined ? undefined : r.specialForm)) {
          t = {
            ...t,
            type: t.type.props.specialForm
          };
        }
        if (H.isClassInstance(t.type) && H.ClassType.isBuiltIn(t.type, 'TypeAliasType') && ((s = t.type.props) === null || s === undefined ? undefined : s.typeForm)) {
          const n = (i = t.type.props.typeForm.props) === null || i === undefined ? undefined : i.typeAliasInfo;
          if (n && n.shared.typeParams) {
            const r = H.TypeBase.cloneForTypeAlias(Z.convertToInstantiable(t.type.props.typeForm), {
              ...n,
              typeArgs: undefined
            });
            const s = Kt(e, r, a);
            if (s) {
              return {
                type: H.TypeBase.cloneWithTypeForm(t.type, Z.convertToInstance(s.type))
              };
            }
          }
        }
        if (H.isTypeVar(t.type) && Z.isTypeAliasPlaceholder(t.type)) {
          const n = Qt(e, a).map(e => Z.convertToInstance(e.type));
          return {
            type: H.TypeBase.cloneForTypeAlias(t.type, {
              shared: t.type.shared.recursiveAlias,
              typeArgs: n
            })
          };
        }
        let l = t.isIncomplete;
        let p = false;
        let c = false;
        let u = false;
        const m = Dt(t.type, undefined, (t, r) => {
          var s;
          const i = H.isTypeVar(r) ? r : undefined;
          if (H.isAnyOrUnknown(t)) {
            if (a & 256) {
              Qt(e, a);
            }
            return t;
          }
          if (a & 128 && H.isTypeVar(r)) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarNotSubscriptable().format({
              type: Yr(r)
            }), e.d.leftExpr);
            Qt(e, a);
            return H.UnknownType.create();
          }
          if (H.isInstantiableClass(t)) {
            if (t.shared.effectiveMetaclass && H.isInstantiableClass(t.shared.effectiveMetaclass) && !H.ClassType.isBuiltIn(t.shared.effectiveMetaclass, ['type', '_InitVarMeta']) && !(a & 128)) {
              const r = tt(t, Yt(n));
              if (a & 256) {
                kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsExpectingNone().format({
                  name: Yr(H.ClassType.cloneAsInstance(t))
                }), e);
              }
              if (r) {
                return Jt(e, t, i, n).type;
              }
            }
            if (n.method === 'set') {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.genericClassAssigned(), e.d.leftExpr);
            } else {
              if (n.method === 'del') {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.genericClassDeleted(), e.d.leftExpr);
              }
            }
            if (H.ClassType.isSpecialBuiltIn(t, 'Literal')) {
              return function (e, t, n) {
                var a;
                if (t.d.items.length === 0) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.literalEmptyArgs(), t.d.leftExpr);
                  return H.UnknownType.create();
                }
                const r = [];
                let s = true;
                for (const i of t.d.items) {
                  let o;
                  const l = i.d.valueExpr;
                  if (i.d.argCategory !== 0) {
                    if (n & 256) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackedArgInTypeArgument(), l);
                      o = H.UnknownType.create();
                      s = false;
                    }
                  } else {
                    if (i.d.name) {
                      if (n & 256) {
                        kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.keywordArgInTypeArgument(), l);
                        o = H.UnknownType.create();
                        s = false;
                      }
                    } else {
                      if (l.nodeType === 48) {
                        const a = !!(l.d.strings[0].d.token.flags & 32);
                        const r = l.d.strings.map(e => e.d.value).join('');
                        o = Gn(t, e, a ? 'bytes' : 'str', r);
                        if (n & 256) {
                          l.d.strings.forEach(e => {
                            if (e.d.token.flags & 512) {
                              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.literalNamedUnicodeEscape(), e);
                              s = false;
                            }
                          });
                        }
                      } else {
                        if (l.nodeType === 40) {
                          if (!l.d.isImaginary && l.d.isInteger) {
                            o = Gn(t, e, 'int', l.d.value);
                          }
                        } else {
                          if (l.nodeType === 14) {
                            if (l.d.constType === 33) {
                              o = Gn(t, e, 'bool', true);
                            } else {
                              if (l.d.constType === 15) {
                                o = Gn(t, e, 'bool', false);
                              } else {
                                if (l.d.constType === 26) {
                                  o = (a = Ae == null ? undefined : Ae.noneTypeClass) !== null && a !== undefined ? a : H.UnknownType.create();
                                }
                              }
                            }
                          } else {
                            if (l.nodeType === 55) {
                              if (l.d.operator === 33 || l.d.operator === 0) {
                                if (l.d.expr.nodeType === 40 && !l.d.expr.d.isImaginary && l.d.expr.d.isInteger) {
                                  o = Gn(t, e, 'int', l.d.operator === 33 ? -l.d.expr.d.value : l.d.expr.d.value);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (!o) {
                    const e = qe(l, n & 260 | 33554432);
                    if (H.isClassInstance(e.type) && H.ClassType.isEnumClass(e.type) && e.type.priv.literalValue !== undefined) {
                      o = H.ClassType.cloneAsInstantiable(e.type);
                    } else {
                      let t = true;
                      Z.doForEachSubtype(e.type, e => {
                        if ((!H.isInstantiableClass(e) || e.priv.literalValue === undefined) && !Z.isNoneTypeClass(e)) {
                          t = false;
                        }
                      });
                      if (t) {
                        o = e.type;
                      }
                    }
                  }
                  if (!o) {
                    if (!(n & 256)) {
                      return H.ClassType.cloneAsInstance(e);
                    }
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.literalUnsupportedType(), i);
                    o = H.UnknownType.create();
                    s = false;
                  }
                  r.push(o);
                }
                let i = H.combineTypes(r, {
                  skipElideRedundantLiterals: true
                });
                if (H.isUnion(i) && (Ae == null ? undefined : Ae.unionTypeClass) && H.isInstantiableClass(Ae.unionTypeClass)) {
                  i = H.TypeBase.cloneAsSpecialForm(i, H.ClassType.cloneAsInstance(Ae.unionTypeClass));
                }
                if (Zr(t) && s) {
                  i = H.TypeBase.cloneWithTypeForm(i, Z.convertToInstance(i));
                }
                return i;
              }(t, e, a);
            }
            if (H.ClassType.isBuiltIn(t, 'InitVar')) {
              const t = Qt(e, a);
              if (a & 256) {
                if (!(a & 32768)) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.initVarNotAllowed(), e.d.leftExpr);
                }
              }
              if (t.length === 1) {
                return t[0].type;
              } else {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsMismatchOne().format({
                  received: t.length
                }), e.d.leftExpr);
                return H.UnknownType.create();
              }
            }
            if (H.ClassType.isEnumClass(t)) {
              return H.ClassType.cloneAsInstance(t);
            }
            const r = H.isInstantiableClass(t) && H.ClassType.isBuiltIn(t, 'Annotated');
            const o = H.isInstantiableClass(t) && H.ClassType.hasCustomClassGetItem(t);
            const l = ((s = t.shared.typeParams) === null || s === undefined ? undefined : s.length) > 0 || H.ClassType.isSpecialBuiltIn(t) || H.ClassType.isBuiltIn(t, 'type') || H.ClassType.isPartiallyEvaluated(t);
            const m = H.isInstantiableClass(t) && H.ClassType.isBuiltIn(t, 'Final');
            const y = H.isInstantiableClass(t) && H.ClassType.isBuiltIn(t, 'ClassVar');
            const h = v.getFileInfo(e).diagnosticRuleSet.enableExperimentalFeatures && H.ClassType.isBuiltIn(t, 'TypedDict');
            let f = Qt(e, a, {
              isAnnotatedClass: r,
              hasCustomClassGetItem: o || !l,
              isFinalAnnotation: m,
              isClassVarAnnotation: y,
              supportsTypedDictTypeArg: h
            });
            if (!r) {
              f = qt(f, t.shared.typeParams, e);
            }
            if (o) {
              return t;
            }
            if (t.priv.typeArgs) {
              kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.classAlreadySpecialized().format({
                type: Yr(Z.convertToInstance(t), {
                  expandTypeAlias: true
                })
              }), e.d.leftExpr);
              return t;
            }
            const T = Ga(t, f, a, e);
            if (T.isRequired) {
              p = true;
            } else {
              if (T.isNotRequired) {
                c = true;
              }
            }
            if (T.isReadOnly) {
              u = true;
            }
            return T.type;
          }
          if (Z.isNoneInstance(t)) {
            if (!l) {
              kt(d.DiagnosticRule.reportOptionalSubscript, g.LocMessage.noneNotSubscriptable(), e.d.leftExpr);
            }
            return H.UnknownType.create();
          }
          if (H.isClassInstance(t)) {
            const a = Jt(e, t, i, n);
            if (a.isIncomplete) {
              l = true;
            }
            return a.type;
          }
          if (H.isNever(t)) {
            return H.NeverType.createNever();
          } else {
            if (!H.isUnbound(t) && !l) {
              kt(d.DiagnosticRule.reportIndexIssue, g.LocMessage.typeNotSubscriptable().format({
                type: Yr(t)
              }), e.d.leftExpr);
            }
            return H.UnknownType.create();
          }
        });
        if (!t.isIncomplete) {
          e.d.items.forEach(e => {
            if (!De(e.d.valueExpr)) {
              qe(e.d.valueExpr, a & 4);
            }
          });
        }
        return {
          type: m,
          isIncomplete: l,
          isReadOnly: u,
          isRequired: p,
          isNotRequired: c
        };
      }
      function Ht(e) {
        var t;
        const n = (t = e.props) === null || t === undefined ? undefined : t.typeAliasInfo;
        if (!n || !n.shared.typeParams) {
          return;
        }
        if (n.shared.computedVariance) {
          return n.shared.computedVariance;
        }
        const a = n.shared.typeParams;
        const r = a.map(() => 1);
        n.shared.computedVariance = r;
        Zt(e, a, r, 3);
        return r;
      }
      function Zt(e, t, n, a, r = [], s = 0) {
        if (s > H.maxTypeRecursionCount) {
          return;
        }
        const i = Z.transformPossibleRecursiveTypeAlias(e);
        if (i !== e) {
          if (r.filter(t => H.isTypeSame(t, e)).length > 1) {
            return;
          }
        }
        function o(e, a) {
          Z.doForEachSubtype(e, i => {
            const o = t.findIndex(e => H.isTypeSame(e, i));
            if (o >= 0) {
              n[o] = Z.combineVariances(n[o], a);
            } else {
              r.push(e);
              Zt(i, t, n, a, r, s);
              r.pop();
            }
          });
        }
        s++;
        Z.doForEachSubtype(i, e => {
          if (e.category === 4) {
            e.shared.parameters.forEach((t, n) => {
              o(H.FunctionType.getParamType(e, n), Z.invertVariance(a));
            });
            const t = H.FunctionType.getEffectiveReturnType(e);
            if (t) {
              o(t, a);
            }
          } else {
            if (e.category === 6 && e.priv.typeArgs) {
              ya(e);
              e.priv.typeArgs.forEach((t, n) => {
                var r;
                if (Z.isTupleClass(e)) {
                  o(t, a);
                } else {
                  if (n < e.shared.typeParams.length) {
                    const s = e.shared.typeParams[n];
                    if (H.isUnpackedClass(t) && t.priv.tupleTypeArgs) {
                      t.priv.tupleTypeArgs.forEach(e => {
                        o(e.type, 2);
                      });
                    } else {
                      const e = (r = s.priv.computedVariance) !== null && r !== undefined ? r : s.shared.declaredVariance;
                      o(t, a === 4 ? Z.invertVariance(e) : e);
                    }
                  }
                }
              });
            }
          }
        });
      }
      function Yt(e) {
        if (e.method === 'get') {
          return '__getitem__';
        } else {
          if (e.method === 'set') {
            return '__setitem__';
          } else {
            l.assert(e.method === 'del');
            return '__delitem__';
          }
        }
      }
      function Jt(e, t, n, a) {
        var r;
        var s;
        var i;
        var o;
        var l;
        if (H.isClassInstance(t) && H.ClassType.isTypedDictClass(t)) {
          const n = W.getTypeOfIndexedTypedDict(es, e, t, a);
          if (n) {
            return n;
          }
        }
        const p = Yt(a);
        const c = tt(t, p, n);
        if (!c) {
          kt(d.DiagnosticRule.reportIndexIssue, g.LocMessage.methodNotDefinedOnType().format({
            name: p,
            type: Yr(t)
          }), e.d.leftExpr);
          return {
            type: H.UnknownType.create()
          };
        }
        if (e.d.items.length === 1 && !e.d.trailingComma && !e.d.items[0].d.name && e.d.items[0].d.argCategory === 0 && H.isClassInstance(t)) {
          const n = e.d.items[0].d.valueExpr;
          const a = qe(n).type;
          if (H.isClassInstance(a) && H.ClassType.isBuiltIn(a, 'int') && Z.isLiteralType(a) && typeof a.priv.literalValue == 'number') {
            const e = a.priv.literalValue;
            const n = Z.getSpecializedTupleType(t);
            if (n && n.priv.tupleTypeArgs && Z.isTupleIndexUnambiguous(n, e)) {
              if (e >= 0 && e < n.priv.tupleTypeArgs.length) {
                return {
                  type: n.priv.tupleTypeArgs[e].type
                };
              }
              if (e < 0 && n.priv.tupleTypeArgs.length + e >= 0) {
                return {
                  type: n.priv.tupleTypeArgs[n.priv.tupleTypeArgs.length + e].type
                };
              }
            }
          } else {
            if (H.isClassInstance(a) && H.ClassType.isBuiltIn(a, 'slice')) {
              const e = Z.getSpecializedTupleType(t);
              if (e && n.nodeType === 46) {
                const t = q.getSlicedTupleType(es, e, n);
                if (t) {
                  return {
                    type: t
                  };
                }
              }
            }
          }
        }
        const u = e.d.items.filter(e => e.d.argCategory === 0 && !e.d.name);
        const m = e.d.items.filter(e => e.d.argCategory === 1);
        const y = e.d.items.filter(e => e.d.argCategory === 0 && !!e.d.name);
        const h = e.d.items.filter(e => e.d.argCategory === 2);
        let f;
        let T = false;
        if (u.length !== 1 || m.length !== 0 || e.d.trailingComma) {
          if (u.length === 0 && m.length === 0) {
            f = q.makeTupleObject(es, []);
          } else {
            const e = [];
            u.forEach(t => {
              const n = qe(t.d.valueExpr);
              e.push({
                type: n.type,
                isUnbounded: false
              });
              if (n.isIncomplete) {
                T = true;
              }
            });
            m.forEach(t => {
              var n;
              var a;
              const r = qe(t.d.valueExpr);
              if (r.isIncomplete) {
                T = true;
              }
              const s = (a = (n = st(r, false, t.d.valueExpr)) === null || n === undefined ? undefined : n.type) !== null && a !== undefined ? a : H.UnknownType.create();
              e.push({
                type: s,
                isUnbounded: true
              });
            });
            f = q.makeTupleObject(es, e);
          }
        } else {
          const e = qe(u[0].d.valueExpr);
          f = e.type;
          if (e.isIncomplete) {
            T = true;
          }
        }
        const v = [{
          argCategory: 0,
          typeResult: {
            type: f,
            isIncomplete: T
          }
        }];
        if (a.method === 'set') {
          let e = (s = (r = a.setType) === null || r === undefined ? undefined : r.type) !== null && s !== undefined ? s : H.AnyType.create();
          if (H.isTypeVar(e) && H.TypeVarType.hasConstraints(e)) {
            e = Pt(e, undefined, H.isClassInstance(t) ? (i = t.props) === null || i === undefined ? undefined : i.condition : undefined);
          }
          v.push({
            argCategory: 0,
            typeResult: {
              type: e,
              isIncomplete: !!((o = a.setType) === null || o === undefined ? undefined : o.isIncomplete)
            }
          });
        }
        y.forEach(e => {
          v.push({
            argCategory: 0,
            valueExpression: e.d.valueExpr,
            node: e,
            name: e.d.name
          });
        });
        h.forEach(e => {
          v.push({
            argCategory: 2,
            valueExpression: e.d.valueExpr,
            node: e
          });
        });
        const b = pn(e, v, {
          type: c
        }, undefined, true, undefined);
        return {
          type: (l = b.returnType) !== null && l !== undefined ? l : H.UnknownType.create(),
          isIncomplete: !!b.isTypeIncomplete
        };
      }
      function Qt(e, t, n) {
        const a = [];
        let r = t | 33554432;
        r &= -1073741825;
        const s = () => {
          const t = M.getEnclosingClass(e, true);
          if (t) {
            const e = ca(t);
            if (e && H.ClassType.isDataClass(e.classType)) {
              return true;
            }
          }
          return false;
        };
        if (n == null ? undefined : n.isFinalAnnotation) {
          r |= 16;
          if (!s()) {
            r |= 131072;
          }
        } else {
          if (n == null ? undefined : n.isClassVarAnnotation) {
            r |= 131072;
            if (!s()) {
              r |= 16;
            }
          } else {
            r &= -1065059;
            if (!(n == null ? undefined : n.isAnnotatedClass)) {
              r |= 131088;
            }
            r |= 138412032;
          }
        }
        const i = (t, a) => {
          let s;
          if (n == null ? undefined : n.hasCustomClassGetItem) {
            r = 131170;
            s = {
              ...qe(t, r),
              node: t
            };
          } else {
            if ((n == null ? undefined : n.isAnnotatedClass) && a > 0) {
              r = 131170;
              if (T.isAnnotationEvaluationPostponed(v.getFileInfo(e))) {
                r |= 4;
              }
              s = {
                ...qe(t, r),
                node: t
              };
            } else {
              s = function (e, t, n) {
                let a;
                let r = t | 137;
                const s = v.getFileInfo(e);
                if (s.isStubFile) {
                  r |= 4;
                }
                if (e.nodeType === 34) {
                  a = {
                    type: H.UnknownType.create(),
                    typeList: e.d.items.map(e => ({
                      ...qe(e, r),
                      node: e
                    })),
                    node: e
                  };
                  Ee(e, {
                    type: H.UnknownType.create()
                  });
                } else {
                  if (e.nodeType === 18 && n) {
                    const t = (Ae == null ? undefined : Ae.typedDictClass) && H.isInstantiableClass(Ae.typedDictClass) ? W.createTypedDictTypeInlined(es, e, Ae.typedDictClass) : undefined;
                    a = {
                      type: (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass) ? Ae.strClass : H.UnknownType.create(),
                      inlinedTypeDict: t,
                      node: e
                    };
                  } else {
                    a = {
                      ...qe(e, r),
                      node: e
                    };
                    if (e.nodeType === 18) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.dictInAnnotation(), e);
                    }
                    if (t & 131072 && H.isClass(a.type) && H.ClassType.isBuiltIn(a.type, 'ClassVar')) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.classVarNotAllowed(), e);
                    }
                  }
                }
                return a;
              }(t, r, !!(n == null ? undefined : n.supportsTypedDictTypeArg) && a === 0);
            }
          }
          return s;
        };
        if (e.d.items.length !== 1 || e.d.trailingComma || e.d.items[0].d.name || e.d.items[0].d.valueExpr.nodeType !== 52) {
          e.d.items.forEach((e, r) => {
            const s = i(e.d.valueExpr, r);
            if (e.d.argCategory !== 0 && e.d.argCategory === 1 && (!(n == null ? undefined : n.isAnnotatedClass) || r === 0)) {
              const n = Xt(s.type);
              if (n) {
                s.type = n;
              } else {
                if (t & 256) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackNotAllowed(), e.d.valueExpr);
                  s.typeErrors = true;
                } else {
                  s.type = H.UnknownType.create();
                }
              }
            }
            if (e.d.name) {
              if (t & 256) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.keywordArgInTypeArgument(), e.d.valueExpr);
                s.typeErrors = true;
              } else {
                s.type = H.UnknownType.create();
              }
            }
            if (e.d.valueExpr.nodeType !== 0 || e.d.valueExpr.d.category !== 3) {
              a.push(s);
            }
          });
          return a;
        } else {
          e.d.items[0].d.valueExpr.d.items.forEach((e, t) => {
            a.push(i(e, t));
          });
          Ee(e.d.items[0].d.valueExpr, {
            type: H.UnknownType.create()
          });
          return a;
        }
      }
      function Xt(e) {
        if (H.isTypeVarTuple(e)) {
          if (e.priv.isUnpacked) {
            return undefined;
          } else {
            return H.TypeVarType.cloneForUnpacked(e);
          }
        }
        if (!H.isParamSpec(e)) {
          if (H.isTypeVar(e)) {
            const t = e.shared.boundType;
            if (t && H.isClassInstance(t) && Z.isTupleClass(t)) {
              return H.TypeVarType.cloneForUnpacked(e);
            } else {
              return undefined;
            }
          }
          if (H.isInstantiableClass(e) && !e.priv.includeSubclasses && Z.isTupleClass(e)) {
            return H.ClassType.cloneForUnpacked(e);
          } else {
            return undefined;
          }
        }
      }
      function en(e) {
        return {
          argCategory: e.d.argCategory,
          name: e.d.name,
          valueExpression: e.d.valueExpr
        };
      }
      function tn(e, t) {
        let n;
        let a;
        let r;
        let s;
        let i;
        e.d.args.forEach((e, t) => {
          if (t === 0) {
            if (e.d.argCategory === 0 && !e.d.name) {
              n = e.d.valueExpr;
            }
          } else {
            if (e.d.argCategory === 0 && e.d.name) {
              if (e.d.name.d.value === 'expected_text') {
                s = e.d.valueExpr;
                const t = qe(e.d.valueExpr).type;
                if (H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'str') && typeof t.priv.literalValue == 'string') {
                  i = t.priv.literalValue;
                } else {
                  kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.revealTypeExpectedTextArg(), e.d.valueExpr);
                }
              } else {
                if (e.d.name.d.value === 'expected_type') {
                  a = e.d.valueExpr;
                  r = Z.convertToInstance($a(en(e), {
                    typeExpression: true
                  }).type);
                }
              }
            } else {
              n = undefined;
            }
          }
        });
        if (!n) {
          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.revealTypeArgs(), e);
          return {
            type: H.UnknownType.create()
          };
        }
        const o = qe(n, undefined, t);
        const l = o.type;
        const p = M.printExpression(n);
        const c = Yr(l, {
          expandTypeAlias: true
        });
        if (!o.isIncomplete) {
          if (i !== undefined && i !== c) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.revealTypeExpectedTextMismatch().format({
              expected: i,
              received: c
            }), s ?? n);
          }
          if (r && !H.isTypeSame(r, l, {
            ignorePseudoGeneric: true
          })) {
            const e = Yr(r);
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.revealTypeExpectedTypeMismatch().format({
              expected: e,
              received: c
            }), a ?? n);
          }
          bt(g.LocAddendum.typeOfSymbol().format({
            name: p,
            type: c
          }), e.d.args[0]);
        }
        return {
          type: l,
          isIncomplete: o.isIncomplete
        };
      }
      function nn(e) {
        var t;
        const n = M.getParentNodeOfType(e, 1);
        if (n == null ? undefined : n.parent) {
          return n.parent;
        } else {
          if (e.nodeType === 38 && ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 10 && e.parent.d.name === e) {
            return e.parent;
          } else {
            return e;
          }
        }
      }
      function an(e, t, n, a, r, s) {
        var i;
        var o;
        const l = [];
        const p = [];
        let d = false;
        let c = [];
        let u = false;
        const m = nn(e);
        for (let r = 0; r < t.length; r++) {
          let y;
          const g = t[r];
          const h = g.some(e => e !== undefined);
          let f = [];
          let T = false;
          u = false;
          for (let t = 0; t < n.length; t++) {
            const r = n[t].overload;
            let v = n[t];
            if (h) {
              v = {
                ...n[t]
              };
              v.argParams = v.argParams.map((e, t) => {
                if (!g[t]) {
                  return e;
                }
                const n = {
                  ...e
                };
                n.argType = g[t];
                return n;
              });
            }
            const b = (i = a == null ? undefined : a.clone()) !== null && i !== undefined ? i : new k.ConstraintTracker();
            const _ = nr(m, () => mn(e, v, b, true, s));
            if (_.isTypeIncomplete) {
              d = true;
            }
            if (!_.argumentErrors && _.returnType) {
              c.push(r);
              y = r;
              const e = {
                overload: y,
                matchResults: v,
                constraints: b,
                returnType: _.returnType,
                argResults: (o = _.argResults) !== null && o !== undefined ? o : []
              };
              p.push(e);
              if (!_.anyOrUnknownArg) {
                l.push(_.returnType);
                u = true;
                break;
              }
              f.push(e);
              if (Z.isIncompleteUnknown(_.anyOrUnknownArg)) {
                T = true;
              }
            }
          }
          if (!u && f.length > 0) {
            f = rn(f);
            if (f.length === 1) {
              c = [f[0].overload];
              l.push(f[0].returnType);
            } else {
              let e = [];
              let t = false;
              f.forEach(n => {
                let a = false;
                for (let r = 0; r < e.length; r++) {
                  if (Ir(e[r], n.returnType)) {
                    const n = Z.containsAnyOrUnknown(e[r], false);
                    if (n) {
                      if (H.isAny(n)) {
                        t = true;
                      }
                    } else {
                      a = true;
                    }
                    break;
                  }
                  if (Ir(n.returnType, e[r])) {
                    const a = Z.containsAnyOrUnknown(n.returnType, false);
                    if (a) {
                      if (H.isAny(a)) {
                        t = true;
                      }
                    } else {
                      e[r] = H.NeverType.createNever();
                    }
                    break;
                  }
                }
                if (!a) {
                  e.push(n.returnType);
                }
              });
              e = e.filter(e => !H.isNever(e));
              const n = H.combineTypes(e);
              let a = n;
              if (e.length > 1) {
                a = t ? H.AnyType.create() : H.UnknownType.createPossibleType(n, T);
              }
              l.push(a);
            }
          }
          if (!y) {
            return {
              argumentErrors: true,
              isTypeIncomplete: d,
              overloadsUsedForCall: c
            };
          }
        }
        if (a && u) {
          a.copyFromClone(p[p.length - 1].constraints);
        }
        const y = a ?? p[0].constraints;
        const g = mn(e, p[0].matchResults, y, r, s);
        if (g.isTypeIncomplete) {
          d = true;
        }
        return {
          argumentErrors: g.argumentErrors,
          anyOrUnknownArg: g.anyOrUnknownArg,
          returnType: H.combineTypes(l),
          isTypeIncomplete: d,
          specializedInitSelfType: g.specializedInitSelfType,
          overloadsUsedForCall: c
        };
      }
      function rn(e) {
        if (e.length < 2) {
          return e;
        }
        if (e[0].matchResults.relevance !== e[e.length - 1].matchResults.relevance && (e = e.filter(t => t.matchResults.relevance === e[0].matchResults.relevance)).length < 2) {
          return e;
        }
        if (Z.areTypesSame(e.map(e => e.returnType), {
          treatAnySameAsUnknown: true
        })) {
          return [e[0]];
        }
        const t = e[0].argResults;
        if (!t) {
          return e;
        }
        let n = false;
        for (let a = 0; a < t.length; a++) {
          if (H.isAnyOrUnknown(t[a].argType)) {
            const t = e.map(e => a < e.matchResults.argParams.length ? e.matchResults.argParams[a].paramType : H.UnknownType.create());
            if (!Z.areTypesSame(t, {
              treatAnySameAsUnknown: true
            })) {
              n = true;
            }
          }
        }
        if (n || e.some(e => e.argResults.length !== t.length)) {
          return e;
        } else {
          return [e[0]];
        }
      }
      function sn(e) {
        return e.sort((e, t) => e.relevance !== t.relevance ? t.relevance - e.relevance : e.overloadIndex - t.overloadIndex);
      }
      function on(e, t, n, a, r, s) {
        let i;
        let o = [];
        let l = !!n.isIncomplete;
        const c = n.type;
        nr(nn(e), () => {
          let a = 0;
          H.OverloadedType.getOverloads(c).forEach(r => {
            const s = un(e, t, {
              type: r,
              isIncomplete: n.isIncomplete
            }, a);
            if (!s.argumentErrors) {
              o.push(s);
            }
            a++;
          });
        });
        o = sn(o);
        if (o.length === 0) {
          if (!It(e)) {
            const n = H.OverloadedType.getOverloads(c);
            const a = n.length > 0 && n[0].shared.name ? n[0].shared.name : '<anonymous function>';
            const r = new p.DiagnosticAddendum();
            const s = t.map(e => {
              const t = Yr(Ka(e, undefined).type);
              if (e.argCategory === 1) {
                return `*${t}`;
              } else {
                if (e.argCategory === 2) {
                  return `**${t}`;
                } else {
                  return t;
                }
              }
            });
            r.addMessage(g.LocAddendum.argumentTypes().format({
              types: s.join(', ')
            }));
            kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.noOverload().format({
              name: a
            }) + r.getString(), e);
          }
          return {
            argumentErrors: true,
            isTypeIncomplete: l,
            overloadsUsedForCall: []
          };
        }
        function u(t, n) {
          const r = o.reduce((e, t) => t.argumentMatchScore === e.argumentMatchScore ? t.overloadIndex > e.overloadIndex ? t : e : t.argumentMatchScore < e.argumentMatchScore ? t : e);
          if (n) {
            const t = r.overload.shared.name || '<anonymous function>';
            const n = kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.noOverload().format({
              name: t
            }), e);
            const a = r.overload.shared.declaration;
            if (n && a) {
              n.addRelatedInfo(g.LocAddendum.overloadIndex().format({
                index: r.overloadIndex + 1
              }), a.uri, a.range);
            }
          }
          const i = a ?? new k.ConstraintTracker();
          return mn(e, r, i, t, s);
        }
        if (o.length === 1) {
          return u(false, false);
        }
        let m = [t.map(e => {})];
        while (true) {
          const n = an(e, m, o, a, r, s);
          if (n.isTypeIncomplete) {
            l = true;
          }
          if (!n.argumentErrors) {
            return n;
          }
          if (!i) {
            nr(nn(e), () => {
              i = t.map(e => {
                if (e.typeResult) {
                  return e.typeResult.type;
                }
                if (e.valueExpression) {
                  const t = e.valueExpression;
                  return nr(t, () => qe(t).type);
                }
                return H.AnyType.create();
              });
            });
          }
          m = ln(i, m);
          if (!m || m.length > ie) {
            break;
          }
        }
        if (!It(e) && !l) {
          const e = u(true, true);
          e.returnType = H.UnknownType.create();
          return {
            ...e,
            argumentErrors: true
          };
        }
        return {
          argumentErrors: true,
          isTypeIncomplete: l,
          overloadsUsedForCall: []
        };
      }
      function ln(e, t) {
        let n;
        let a = e.length - 1;
        while (a >= 0 && !t[0][a]) {
          a--;
        }
        a++;
        if (a >= e.length) {
          return;
        }
        while (a < e.length) {
          const t = e[a];
          if (H.isUnion(t)) {
            n = Pt(t);
            break;
          }
          if (H.isTypeVar(t) && H.TypeVarType.hasConstraints(t)) {
            n = Pt(t);
            break;
          }
          a++;
        }
        if (!n) {
          return;
        }
        const r = [];
        t.forEach(e => {
          Z.doForEachSubtype(n, t => {
            const n = [...e];
            n[a] = t;
            r.push(n);
          });
        });
        return r;
      }
      function pn(e, t, n, a, r, s, i = 0) {
        var l;
        let c;
        let u = false;
        let m = false;
        const y = [];
        if (i > H.maxTypeRecursionCount) {
          return {
            returnType: H.UnknownType.create(),
            argumentErrors: true,
            overloadsUsedForCall: y
          };
        }
        i++;
        if ((l = n.type.props) === null || l === undefined ? undefined : l.specialForm) {
          const t = e.nodeType === 9 ? e.d.leftExpr : e;
          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.objectNotCallable().format({
            type: Yr(n.type.props.specialForm, {
              expandTypeAlias: true
            })
          }), t);
          return {
            returnType: H.UnknownType.create(),
            argumentErrors: true,
            overloadsUsedForCall: y
          };
        }
        let h = Dt(n.type, {
          sortSubtypes: true
        }, (l, h, f) => nr(f ? undefined : nn(e), () => {
          const f = function (e, t, n, a, r, s, i, o, l) {
            switch (n.category) {
              case 3:
              case 1:
              case 2:
                if (!r) {
                  t.forEach(e => {
                    if (e.valueExpression && !ar(e.valueExpression)) {
                      Ka(e, undefined);
                    }
                  });
                }
                return {
                  returnType: n
                };
              case 4:
                return function (e, t, n, a, r, s, i) {
                  var o;
                  if (H.TypeBase.isInstantiable(n)) {
                    kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.callableNotInstantiable().format({
                      type: Yr(n)
                    }), e);
                    return {
                      returnType: undefined,
                      argumentErrors: true
                    };
                  }
                  if (H.FunctionType.isBuiltIn(n, 'namedtuple')) {
                    kt(d.DiagnosticRule.reportUntypedNamedTuple, g.LocMessage.namedTupleNoTypes(), e);
                    const a = {
                      returnType: N.createNamedTupleType(es, e, t, false)
                    };
                    fn(e, t, {
                      type: n
                    }, r, s, i);
                    return a;
                  }
                  if (H.FunctionType.isBuiltIn(n, 'NewType')) {
                    return {
                      returnType: An(e, t)
                    };
                  }
                  const l = fn(e, t, {
                    type: n,
                    isIncomplete: a
                  }, r, s, i);
                  let p = !!l.isTypeIncomplete;
                  let c = l.returnType;
                  let u = !!l.argumentErrors;
                  if (!u) {
                    const a = D.applyFunctionTransform(es, e, t, n, {
                      argumentErrors: !!l.argumentErrors,
                      returnType: (o = l.returnType) !== null && o !== undefined ? o : H.UnknownType.create(p),
                      isTypeIncomplete: p
                    });
                    c = a.returnType;
                    if (a.isTypeIncomplete) {
                      p = true;
                    }
                    if (a.argumentErrors) {
                      u = true;
                    }
                  }
                  if (H.FunctionType.isBuiltIn(n, '__import__')) {
                    c = H.AnyType.create();
                  }
                  return {
                    returnType: c,
                    isTypeIncomplete: p,
                    argumentErrors: u,
                    overloadsUsedForCall: l.overloadsUsedForCall,
                    specializedInitSelfType: l.specializedInitSelfType
                  };
                }(e, t, n, r, s, i, o);
              case 5:
                return function (e, t, n, a, r, s, i) {
                  var o;
                  var l;
                  const p = H.OverloadedType.getOverloads(n);
                  if (p.length > 0 && H.FunctionType.isBuiltIn(p[0], ['typing.cast', 'typing_extensions.cast']) && t.length === 2) {
                    return {
                      returnType: cn(t, e)
                    };
                  }
                  const d = on(e, t, {
                    type: n,
                    isIncomplete: a
                  }, r, s, i);
                  let c = (o = d.returnType) !== null && o !== undefined ? o : H.UnknownType.create();
                  let u = !!d.isTypeIncomplete;
                  let m = !!d.argumentErrors;
                  if (!m) {
                    const a = D.applyFunctionTransform(es, e, t, n, {
                      argumentErrors: !!d.argumentErrors,
                      returnType: (l = d.returnType) !== null && l !== undefined ? l : H.UnknownType.create(u),
                      isTypeIncomplete: u
                    });
                    c = a.returnType;
                    if (a.isTypeIncomplete) {
                      u = true;
                    }
                    if (a.argumentErrors) {
                      m = true;
                    }
                  }
                  return {
                    returnType: c,
                    isTypeIncomplete: u,
                    argumentErrors: m,
                    overloadsUsedForCall: d.overloadsUsedForCall,
                    specializedInitSelfType: d.specializedInitSelfType
                  };
                }(e, t, n, r, s, i, o);
              case 6:
                if (Z.isNoneInstance(n)) {
                  kt(d.DiagnosticRule.reportOptionalCall, g.LocMessage.noneNotCallable(), e);
                  return {
                    argumentErrors: true
                  };
                } else {
                  if (H.TypeBase.isInstantiable(n)) {
                    return function (e, t, n, a, r, s) {
                      var i;
                      var o;
                      if (n.priv.literalValue !== undefined) {
                        kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.literalNotCallable(), e);
                        return {
                          returnType: H.UnknownType.create(),
                          argumentErrors: true
                        };
                      }
                      if (H.ClassType.isBuiltIn(n)) {
                        const a = (i = n.priv.aliasName) !== null && i !== undefined ? i : n.shared.name;
                        if (Z.isInstantiableMetaclass(n)) {
                          if (n.priv.typeArgs && n.priv.isTypeArgExplicit) {
                            kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.objectNotCallable().format({
                              type: Yr(n)
                            }), e);
                            return {
                              returnType: H.UnknownType.create(),
                              argumentErrors: true
                            };
                          }
                          w.validateConstructorArgs(es, e, t, n, r, s);
                          if (n.shared.name === 'type' && t.length === 1) {
                            const e = Ka(t[0], undefined);
                            const a = e.type;
                            return {
                              returnType: Z.mapSubtypes(a, e => H.isNever(e) ? e : H.isClass(e) ? Z.convertToInstantiable($e(e)) : H.TypeBase.isInstance(e) && (H.isFunction(e) || H.isTypeVar(e)) ? Z.convertToInstantiable(e) : H.ClassType.specialize(H.ClassType.cloneAsInstance(n), [H.UnknownType.create()])),
                              isTypeIncomplete: e.isIncomplete
                            };
                          }
                          if (t.length >= 2) {
                            return {
                              returnType: xn(e, t, n) || H.AnyType.create()
                            };
                          } else {
                            return {
                              returnType: H.AnyType.create()
                            };
                          }
                        }
                        if (a === 'TypeVar') {
                          return {
                            returnType: bn(e, n, t)
                          };
                        }
                        if (a === 'TypeVarTuple') {
                          return {
                            returnType: Cn(e, n, t)
                          };
                        }
                        if (a === 'ParamSpec') {
                          return {
                            returnType: kn(e, n, t)
                          };
                        }
                        if (a === 'TypeAliasType') {
                          const n = function (e, t) {
                            if (e.nodeType !== 9 || !e.parent || t.length < 2) {
                              return;
                            }
                            if (e.parent.nodeType !== 3 || e.parent.d.rightExpr !== e || e.parent.d.leftExpr.nodeType !== 38) {
                              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeMustBeAssigned(), e);
                              return;
                            }
                            const n = e.parent.d.leftExpr;
                            const a = t[0];
                            if (!a.valueExpression || a.valueExpression.nodeType !== 48) {
                              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeNameArg(), a.valueExpression || e);
                              return;
                            }
                            if (a.valueExpression.d.strings.map(e => e.d.value).join('') !== n.d.value) {
                              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeNameMismatch(), a.valueExpression);
                            }
                            let r;
                            let s;
                            let i;
                            for (let e = 1; e < t.length; e++) {
                              const n = t[e].name;
                              const a = n ? n.d.value : undefined;
                              if (a) {
                                if (a !== 'type_params' || s) {
                                  if (a !== 'value' || r) {
                                    return;
                                  }
                                  r = t[e].valueExpression;
                                } else {
                                  s = t[e].valueExpression;
                                }
                              } else {
                                if (e !== 1) {
                                  return;
                                }
                                r = t[e].valueExpression;
                              }
                            }
                            if (!r) {
                              return;
                            }
                            if (s) {
                              if (s.nodeType !== 52) {
                                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeParamInvalid(), s);
                                return;
                              }
                              i = [];
                              let e = true;
                              s.d.items.map(t => {
                                let a = qe(t, 4224).type;
                                if (H.isTypeVar(a)) {
                                  if (a.priv.scopeId || H.isTypeVarTuple(a) && a.priv.isUnpacked) {
                                    e = false;
                                  } else {
                                    a = H.TypeVarType.cloneForScopeId(a, M.getScopeIdForNode(n), n.d.value, 2);
                                  }
                                  i.push(a);
                                } else {
                                  e = false;
                                }
                              });
                              if (!e) {
                                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeParamInvalid(), s);
                                return;
                              }
                            }
                            return la(n, n, r, true, undefined, () => i);
                          }(e, t);
                          if (n) {
                            return {
                              returnType: n
                            };
                          }
                        }
                        if (a === 'NamedTuple') {
                          const a = {
                            returnType: N.createNamedTupleType(es, e, t, true)
                          };
                          const s = w.getBoundInitMethod(es, e, H.ClassType.cloneAsInstance(n), undefined, 0);
                          if (s && H.isOverloaded(s.type)) {
                            on(e, t, {
                              type: s.type
                            }, undefined, r, undefined);
                          }
                          return a;
                        }
                        if (a === 'NewType') {
                          return {
                            returnType: An(e, t)
                          };
                        }
                        if (H.ClassType.isSpecialFormClass(n)) {
                          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.typeNotIntantiable().format({
                            type: a
                          }), e);
                          return {
                            returnType: H.UnknownType.create(),
                            argumentErrors: true
                          };
                        }
                        if (a === 'TypedDict') {
                          return {
                            returnType: W.createTypedDictType(es, e, n, t)
                          };
                        }
                        if (a === 'auto' && t.length === 0) {
                          return {
                            returnType: P.getEnumAutoValueType(es, e)
                          };
                        }
                      }
                      if (H.isClass(n) && n.shared.effectiveMetaclass && H.isClass(n.shared.effectiveMetaclass) && P.isEnumMetaclass(n.shared.effectiveMetaclass) && !P.isEnumClassWithMembers(es, n)) {
                        return {
                          returnType: (o = P.createEnumType(es, e, n, t)) !== null && o !== undefined ? o : Z.convertToInstance(a)
                        };
                      }
                      if (H.ClassType.supportsAbstractMethods(n)) {
                        const t = zr(n);
                        if (t.length > 0 && !n.priv.includeSubclasses && !H.isTypeVar(a)) {
                          const a = new p.DiagnosticAddendum();
                          const r = 2;
                          t.forEach((e, n) => {
                            if (n === r) {
                              a.addMessage(g.LocAddendum.memberIsAbstractMore().format({
                                count: t.length - r
                              }));
                            } else {
                              if (n < r && H.isInstantiableClass(e.classType)) {
                                const t = e.classType.shared.name;
                                a.addMessage(g.LocAddendum.memberIsAbstract().format({
                                  type: t,
                                  name: e.symbolName
                                }));
                              }
                            }
                          });
                          kt(d.DiagnosticRule.reportAbstractUsage, g.LocMessage.instantiateAbstract().format({
                            type: n.shared.name
                          }) + a.getString(), e);
                        }
                      }
                      if (H.ClassType.isProtocolClass(n) && !n.priv.includeSubclasses) {
                        kt(d.DiagnosticRule.reportAbstractUsage, g.LocMessage.instantiateProtocol().format({
                          type: n.shared.name
                        }), e);
                      }
                      const l = w.validateConstructorArgs(es, e, t, n, r, s);
                      const c = l.overloadsUsedForCall;
                      const u = l.argumentErrors;
                      const m = l.isTypeIncomplete;
                      let y = l.returnType;
                      if (H.isTypeVar(a)) {
                        y = Z.convertToInstance(a);
                      }
                      if (e.nodeType === 9 && y && H.isClassInstance(y) && H.ClassType.isBuiltIn(y, 'deprecated')) {
                        y = H.ClassType.cloneForDeprecatedInstance(y, x.getDeprecatedMessageFromCall(e));
                      }
                      if (y && H.isClassInstance(y) && y.shared.mro.some(e => H.isInstantiableClass(e) && H.ClassType.isBuiltIn(e, 'type'))) {
                        let a = `__class_${y.shared.name}`;
                        if (t.length === 3) {
                          const e = Ka(t[0], undefined).type;
                          if (H.isClassInstance(e) && H.ClassType.isBuiltIn(e, 'str') && typeof e.priv.literalValue == 'string') {
                            a = e.priv.literalValue;
                          }
                        }
                        const r = H.ClassType.createInstantiable(a, '', '', v.getFileInfo(e).fileUri, 0, M.getTypeSourceId(e), H.ClassType.cloneAsInstantiable(y), H.ClassType.cloneAsInstantiable(y));
                        r.shared.baseClasses.push(Za(e, 'object'));
                        r.shared.effectiveMetaclass = n;
                        r.shared.declaration = y.shared.declaration;
                        Z.computeMroLinearization(r);
                        y = r;
                      }
                      return {
                        returnType: y,
                        overloadsUsedForCall: c,
                        argumentErrors: u,
                        isTypeIncomplete: m
                      };
                    }(e, t, n, a, i, o);
                  } else {
                    return function (e, t, n, a, r, s, i, o) {
                      var l;
                      const c = new p.DiagnosticAddendum();
                      const u = et(e, n, '__call__', undefined, c, 528, undefined, o);
                      const m = u == null ? undefined : u.type;
                      if (!m || u.typeErrors) {
                        kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.objectNotCallable().format({
                          type: Yr(n)
                        }) + c.getString(), e);
                        return {
                          returnType: H.UnknownType.create(),
                          argumentErrors: true
                        };
                      }
                      const y = pn(e, t, {
                        type: m
                      }, r, s, i, o);
                      let h = (l = y.returnType) !== null && l !== undefined ? l : H.UnknownType.create();
                      if (H.isTypeVar(a) && H.TypeBase.isInstantiable(a) && H.isClass(n) && H.ClassType.isBuiltIn(n, 'type')) {
                        h = Z.convertToInstance(a);
                      }
                      return {
                        returnType: h,
                        argumentErrors: y.argumentErrors,
                        overloadsUsedForCall: y.overloadsUsedForCall
                      };
                    }(e, t, n, a, s, i, o, l);
                  }
                }
              case 9:
                return pn(e, t, {
                  type: Z.transformPossibleRecursiveTypeAlias(n),
                  isIncomplete: r
                }, s, i, o, l);
              case 7:
                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.moduleNotCallable(), e);
                return {
                  argumentErrors: true
                };
            }
            return {
              argumentErrors: true
            };
          }(e, t, l, h, !!n.isIncomplete, a, r, s, i);
          if (f.argumentErrors) {
            u = true;
          }
          if (f.isTypeIncomplete) {
            m = true;
          }
          if (f.overloadsUsedForCall) {
            o.appendArray(y, f.overloadsUsedForCall);
          }
          c = f.specializedInitSelfType;
          return f.returnType;
        }, {
          allowDiagnostics: true
        }));
        if (u && H.isNever(h) && !h.priv.isNoReturn) {
          h = H.UnknownType.create();
        }
        return {
          argumentErrors: u,
          returnType: h,
          isTypeIncomplete: m,
          specializedInitSelfType: c,
          overloadsUsedForCall: y
        };
      }
      function dn(e, t) {
        const n = H.ClassType.isProtocolClass(e);
        const a = H.ClassType.getSymbolTable(e).get(t);
        if (!a) {
          return;
        }
        if (!a.isClassMember() && !a.isNamedTupleMemberMember()) {
          return;
        }
        const r = j.getLastTypedDeclarationForSymbol(a);
        if (!r) {
          return;
        }
        if (n && r.type === 1) {
          if (!a.getDeclarations().some(e => e.type === 1 && !!e.inferredTypeSource)) {
            return {
              symbol: a,
              symbolName: t,
              classType: e,
              hasImplementation: false
            };
          }
        }
        if (r.type !== 5) {
          return;
        }
        let s = false;
        const i = x.getFunctionInfoFromDecorators(es, r.node, true);
        if (i.flags & 8) {
          s = true;
        }
        const o = v.getFileInfo(r.node).isStubFile;
        const l = a.getDeclarations()[0];
        let p;
        if (l !== r && l.type === 5 && (p = x.getFunctionInfoFromDecorators(es, l.node, true), p.flags & 8 && (s = true), n && i.flags & 256)) {
          if (n && !s && o) {
            return;
          }
          return {
            symbol: a,
            symbolName: t,
            classType: e,
            hasImplementation: false
          };
        }
        if (!n && !s) {
          return;
        }
        const d = !M.isSuiteEmpty(r.node.d.suite) && !xa(r);
        if (!n || s || !d && !o) {
          return {
            symbol: a,
            symbolName: t,
            classType: e,
            hasImplementation: d
          };
        } else {
          return undefined;
        }
      }
      function cn(e, t) {
        var n;
        let a = $a(e[0], {
          typeExpression: true
        }).type;
        const r = M.getTypeVarScopesForNode(t);
        a = Z.makeTypeVarsBound(a, r);
        let s = Ka(e[1], undefined).type;
        if ((n = s.props) === null || n === undefined ? undefined : n.specialForm) {
          s = s.props.specialForm;
        }
        if (H.TypeBase.isInstantiable(a) && !H.isUnknown(a) && H.isTypeSame(Z.convertToInstance(a), s, {
          ignorePseudoGeneric: true
        })) {
          kt(d.DiagnosticRule.reportUnnecessaryCast, g.LocMessage.unnecessaryCast().format({
            type: Yr(s)
          }), t);
        }
        return Z.convertToInstance(a);
      }
      function un(e, t, n, a) {
        var r;
        var s;
        var i;
        var o;
        var c;
        var u;
        var m;
        var y;
        var h;
        var f;
        var T;
        const v = n.type;
        const b = E.getParamListDetails(v);
        const _ = H.FunctionType.getParamSpecFromArgsKwargs(v);
        let C = 0;
        let I = false;
        let w = false;
        let S = !!n.isIncomplete;
        let A = false;
        t = function (e) {
          var t;
          const n = [];
          for (const a of e) {
            if (a.argCategory === 1) {
              const e = Ka(a, undefined).type;
              const r = Z.combineSameSizedTuples(Pt(e), Ae == null ? undefined : Ae.tupleClass);
              if (H.isClassInstance(r) && Z.isTupleClass(r)) {
                const e = (t = r.priv.tupleTypeArgs) !== null && t !== undefined ? t : [];
                if (e.length !== 1 || !e[0].isUnbounded) {
                  for (const t of e) {
                    if (t.isUnbounded) {
                      n.push({
                        ...a,
                        argCategory: 1,
                        valueExpression: undefined,
                        typeResult: {
                          type: q.makeTupleObject(es, [t])
                        }
                      });
                    } else {
                      n.push({
                        ...a,
                        argCategory: 0,
                        valueExpression: undefined,
                        typeResult: {
                          type: t.type
                        }
                      });
                    }
                  }
                  continue;
                }
              }
            }
            n.push(a);
          }
          return n;
        }(t);
        const x = new Map();
        b.params.forEach(e => {
          var t;
          var n;
          l.assert(e !== undefined, 'paramInfo is undefined for param name map');
          const a = e.param;
          if (a.name && a.category === 0 && e.kind !== E.ParamKind.Positional) {
            let r = (n = (t = x.get(a.name)) === null || t === undefined ? undefined : t.argsNeeded) !== null && n !== undefined ? n : 0;
            if (a.category === 0 && !e.defaultType) {
              r += 1;
            }
            x.set(a.name, {
              argsNeeded: r,
              argsReceived: 0
            });
          }
        });
        let P = b.positionOnlyParamCount;
        let D = (r = b.firstKeywordOnlyIndex) !== null && r !== undefined ? r : b.params.length;
        const N = b.argsIndex;
        const F = b.kwargsIndex;
        let M;
        let O;
        let z = false;
        let U = t.findIndex(e => e.argCategory === 2 || e.name !== undefined);
        if (U < 0) {
          U = t.length;
        }
        if (N !== undefined && F !== undefined) {
          l.assert(b.params[N], 'varArgListParamIndex params entry is undefined');
          const e = b.params[N].type;
          l.assert(b.params[F], 'varArgDictParamIndex params entry is undefined');
          const t = b.params[F].type;
          if (H.isParamSpec(e) && e.priv.paramSpecAccess === 'args' && H.isParamSpec(t) && t.priv.paramSpecAccess === 'kwargs' && e.shared.name === t.shared.name) {
            z = true;
            const t = e.priv.scopeId;
            if (Z.getTypeVarScopeIds(v).some(e => e === t)) {
              M = [];
              O = H.TypeVarType.cloneForParamSpecAccess(e, undefined);
            } else {
              P = N;
              U = Math.min(N, U);
              D = N;
            }
          }
        } else {
          if (_ && Z.getTypeVarScopeIds(v).some(e => e === _.priv.scopeId)) {
            z = true;
            M = [];
            O = _;
          }
        }
        if (t.some(e => e.argCategory === 1)) {
          t.forEach(e => {
            if (e.name) {
              const t = b.params.findIndex(t => {
                l.assert(t, 'paramInfo entry is undefined fork kwargs check');
                return t.param.name === e.name.d.value && t.param.category === 0;
              });
              if (t >= 0 && t >= P && (D < 0 || t < D)) {
                D = t;
              }
            }
          });
        }
        if (D < 0) {
          D = b.params.length;
        }
        let V;
        let R = [];
        function L(e, t) {
          if (e.active) {
            V = t;
          }
        }
        const B = t.find(e => e.argCategory === 1) !== undefined;
        let j = 0;
        while (C < U) {
          if (C < P && t[C].name) {
            const e = t[C].name;
            if (e) {
              kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.argPositional(), e);
              w = true;
            }
          }
          const n = U - C;
          const a = D - j - 1;
          if (j >= D) {
            if (M) {
              while (C < U) {
                M.push(t[C]);
                C++;
              }
            } else {
              let n = false;
              if (B && t[C].argCategory === 1) {
                const e = Ka(t[C], undefined).type;
                if (H.isClassInstance(e) && Z.isTupleClass(e) && !Z.isUnboundedTupleClass(e) && e.priv.tupleTypeArgs !== undefined && e.priv.tupleTypeArgs.length > 0) {
                  n = true;
                } else {
                  I = true;
                }
              } else {
                n = true;
              }
              if (n) {
                if (!It(e) && !S) {
                  kt(d.DiagnosticRule.reportCallIssue, D === 1 ? g.LocMessage.argPositionalExpectedOne() : g.LocMessage.argPositionalExpectedCount().format({
                    expected: D
                  }), (s = t[C].valueExpression) !== null && s !== undefined ? s : e);
                }
                w = true;
              }
            }
            break;
          }
          if (j >= b.params.length) {
            break;
          }
          l.assert(b.params[j], 'paramIndex params entry is undefined');
          const r = b.params[j];
          const p = r.type;
          const u = r.param.name;
          const m = r.param.category === 1 && H.isUnpacked(p);
          if (t[C].argCategory === 1) {
            let s = false;
            const l = Ka(t[C], undefined);
            let y;
            let h = false;
            if (j < D && H.isParamSpec(l.type) && l.type.priv.paramSpecAccess === 'args' && r.param.category !== 1) {
              if (!It(e) && !S) {
                kt(d.DiagnosticRule.reportCallIssue, D === 1 ? g.LocMessage.argPositionalExpectedOne() : g.LocMessage.argPositionalExpectedCount().format({
                  expected: D
                }), (i = t[C].valueExpression) !== null && i !== undefined ? i : e);
              }
              w = true;
            }
            const f = l.type;
            if (m && H.isUnpackedTypeVarTuple(f)) {
              y = f;
              s = true;
              h = true;
              A = true;
            } else {
              if (H.isClassInstance(f) && Z.isTupleClass(f) && f.priv.tupleTypeArgs && f.priv.tupleTypeArgs.length === 1 && H.isUnpackedTypeVarTuple(f.priv.tupleTypeArgs[0].type)) {
                y = f.priv.tupleTypeArgs[0].type;
                s = true;
                h = true;
                A = true;
              } else {
                if (m && H.isClassInstance(f) && Z.isTupleClass(f)) {
                  s = true;
                  h = true;
                  if (n < a) {
                    A = true;
                  }
                  y = H.ClassType.cloneForUnpacked(f);
                } else {
                  if (H.isParamSpec(f) && f.priv.paramSpecAccess === 'args') {
                    y = undefined;
                  } else {
                    y = (o = st({
                      type: f,
                      isIncomplete: l.isIncomplete
                    }, false, e, false)) === null || o === undefined ? undefined : o.type;
                    if (r.param.category !== 1) {
                      I = true;
                    }
                  }
                }
              }
            }
            const T = y ? {
              argCategory: 0,
              typeResult: {
                type: y,
                isIncomplete: l.isIncomplete
              }
            } : {
              ...t[C]
            };
            if (l.isIncomplete) {
              S = true;
            }
            if (m && !s) {
              if (!It(e) && !S) {
                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.unpackedArgWithVariadicParam(), t[C].valueExpression || e);
              }
              w = true;
            } else {
              if (M && r.param.category !== 0) {
                M.push(t[C]);
              }
              if (T) {
                R.push({
                  paramCategory: r.param.category,
                  paramType: p,
                  requiresTypeVarMatching: Z.requiresSpecialization(p),
                  argument: T,
                  errorNode: (c = t[C].valueExpression) !== null && c !== undefined ? c : e,
                  paramName: u,
                  isParamNameSynthesized: H.FunctionParam.isNameSynthesized(r.param),
                  mapsToVarArgList: m && n > a
                });
              }
            }
            L(t[C], b.params[j].param);
            if (u && b.params[j].param.category === 0 && x.has(u)) {
              x.get(u).argsReceived++;
            }
            if (h || b.params[j].param.category === 1) {
              C++;
            }
            if (A || b.params[j].param.category !== 1) {
              j++;
            }
          } else {
            if (b.params[j].param.category === 1) {
              L(t[C], b.params[j].param);
              if (M) {
                M.push(t[C]);
                C++;
              } else {
                let r = b.params[j].param.category;
                let s = p;
                const i = b.params[j].param.name;
                if (H.isUnpackedClass(p) && p.priv.tupleTypeArgs && p.priv.tupleTypeArgs.length > 0) {
                  s = p.priv.tupleTypeArgs[0].type;
                }
                r = H.isUnpacked(s) ? 1 : 0;
                if (n <= a) {
                  if (n < a) {
                    if (!It(e) && !S) {
                      kt(d.DiagnosticRule.reportCallIssue, n === 1 ? g.LocMessage.argMorePositionalExpectedOne() : g.LocMessage.argMorePositionalExpectedCount().format({
                        expected: n
                      }), t[C].valueExpression || e);
                    }
                    w = true;
                  }
                  j++;
                } else {
                  R.push({
                    paramCategory: r,
                    paramType: s,
                    requiresTypeVarMatching: Z.requiresSpecialization(p),
                    argument: t[C],
                    errorNode: t[C].valueExpression || e,
                    paramName: i,
                    isParamNameSynthesized: H.FunctionParam.isNameSynthesized(b.params[j].param),
                    mapsToVarArgList: true
                  });
                  C++;
                }
              }
            } else {
              const n = b.params[j];
              const a = n.param.name;
              R.push({
                paramCategory: n.param.category,
                paramType: p,
                requiresTypeVarMatching: Z.requiresSpecialization(p),
                argument: t[C],
                errorNode: t[C].valueExpression || e,
                paramName: a,
                isParamNameSynthesized: H.FunctionParam.isNameSynthesized(n.param)
              });
              L(t[C], n.param);
              if (a && x.has(a) && n.kind !== E.ParamKind.Positional) {
                x.get(a).argsReceived++;
              }
              C++;
              j++;
            }
          }
        }
        let G = false;
        if (P >= 0 && j < P && j < b.params.length && b.params[j].param.category === 1 && !H.isParamSpec(b.params[j].type)) {
          j++;
          G = true;
        }
        if (P >= 0 && j < P && (!B || z)) {
          const n = b.params.findIndex(e => !!e.defaultType);
          let a = (n >= 0 && n < P ? n : P) - U;
          if (G) {
            a--;
          }
          const r = b.params.findIndex(e => e.param.category === 1 && !H.isParamSpec(e.type));
          if (r >= j && r < P) {
            a--;
          }
          if (a > 0) {
            if (!It(e) && !S) {
              kt(d.DiagnosticRule.reportCallIssue, a === 1 ? g.LocMessage.argMorePositionalExpectedOne() : g.LocMessage.argMorePositionalExpectedCount().format({
                expected: a
              }), t.length > U && t[U].valueExpression || e);
            }
            w = true;
          }
        }
        if (!w) {
          let n;
          let a;
          while (C < t.length) {
            if (t[C].argCategory === 2) {
              const r = Ka(t[C], Z.makeInferenceContext(b.unpackedKwargsTypedDictType));
              const s = r.type;
              if (r.isIncomplete) {
                S = true;
              }
              if (H.isAnyOrUnknown(s)) {
                a = s;
              } else {
                if (H.isClassInstance(s) && H.ClassType.isTypedDictClass(s)) {
                  const n = W.getTypedDictMembersForClass(es, s);
                  const a = new p.DiagnosticAddendum();
                  n.knownItems.forEach((n, r) => {
                    var s;
                    var i;
                    const o = x.get(r);
                    if (o) {
                      if (o.argsReceived > 0) {
                        a.addMessage(g.LocMessage.paramAlreadyAssigned().format({
                          name: r
                        }));
                      } else {
                        o.argsReceived++;
                        const a = b.params.findIndex(e => e.param.name === r);
                        l.assert(a >= 0);
                        const i = b.params[a].type;
                        R.push({
                          paramCategory: 0,
                          paramType: i,
                          requiresTypeVarMatching: Z.requiresSpecialization(i),
                          argument: {
                            argCategory: 0,
                            typeResult: {
                              type: n.valueType
                            }
                          },
                          errorNode: (s = t[C].valueExpression) !== null && s !== undefined ? s : e,
                          paramName: r
                        });
                      }
                    } else {
                      if (b.kwargsIndex !== undefined) {
                        const a = b.params[b.kwargsIndex].type;
                        R.push({
                          paramCategory: 2,
                          paramType: a,
                          requiresTypeVarMatching: Z.requiresSpecialization(a),
                          argument: {
                            argCategory: 0,
                            typeResult: {
                              type: n.valueType
                            }
                          },
                          errorNode: (i = t[C].valueExpression) !== null && i !== undefined ? i : e,
                          paramName: r
                        });
                        x.set(r, {
                          argsNeeded: 1,
                          argsReceived: 1
                        });
                      } else {
                        if (!b.hasUnpackedTypedDict) {
                          a.addMessage(g.LocMessage.paramNameMissing().format({
                            name: r
                          }));
                        }
                      }
                    }
                  });
                  const r = (m = (u = n.extraItems) === null || u === undefined ? undefined : u.valueType) !== null && m !== undefined ? m : lt();
                  if (!H.isNever(r) && b.kwargsIndex !== undefined) {
                    const n = b.params[b.kwargsIndex];
                    R.push({
                      paramCategory: 2,
                      paramType: n.declaredType,
                      requiresTypeVarMatching: Z.requiresSpecialization(n.declaredType),
                      argument: {
                        argCategory: 2,
                        typeResult: {
                          type: r
                        }
                      },
                      errorNode: (y = t[C].valueExpression) !== null && y !== undefined ? y : e,
                      paramName: n.param.name
                    });
                  }
                  if (!a.isEmpty()) {
                    if (!It(e) && !S) {
                      kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.unpackedTypedDictArgument() + a.getString(), t[C].valueExpression || e);
                    }
                    w = true;
                  }
                } else {
                  if (_ && E.isParamSpecKwargs(_, s)) {
                    a = H.AnyType.create();
                    if (!M) {
                      R.push({
                        paramCategory: 2,
                        paramType: _,
                        requiresTypeVarMatching: false,
                        argument: t[C],
                        argType: H.isParamSpec(s) ? undefined : H.AnyType.create(),
                        errorNode: t[C].valueExpression || e
                      });
                    }
                  } else {
                    const r = Ya(e, 'str');
                    if ((Ae == null ? undefined : Ae.supportsKeysAndGetItemClass) && H.isInstantiableClass(Ae.supportsKeysAndGetItemClass) && r && H.isClassInstance(r)) {
                      const i = new k.ConstraintTracker();
                      let o = false;
                      if (H.isTypeVar(s)) {
                        o = true;
                      } else {
                        if (Ir(H.ClassType.cloneAsInstance(Ae.supportsKeysAndGetItemClass), s, undefined, i)) {
                          const e = Xe(Ae.supportsKeysAndGetItemClass, i).priv.typeArgs;
                          if (e && e.length >= 2) {
                            if (Ir(r, e[0])) {
                              o = true;
                            }
                            n = [];
                            Z.doForEachSubtype(e[0], e => {
                              if (H.isClassInstance(e) && typeof e.priv.literalValue == 'string') {
                                if (n != null) {
                                  n.push(e.priv.literalValue);
                                }
                              } else {
                                n = undefined;
                              }
                            });
                            a = e[1];
                          } else {
                            o = true;
                            a = H.UnknownType.create();
                          }
                        }
                      }
                      if (b.kwargsIndex !== undefined && a) {
                        const n = b.params[b.kwargsIndex].type;
                        R.push({
                          paramCategory: 0,
                          paramType: n,
                          requiresTypeVarMatching: Z.requiresSpecialization(n),
                          argType: a,
                          argument: t[C],
                          errorNode: t[C].valueExpression || e,
                          paramName: b.params[b.kwargsIndex].param.name
                        });
                      }
                      if (!o) {
                        if (!It(e) && !S) {
                          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.unpackedDictArgumentNotMapping(), t[C].valueExpression || e);
                        }
                        w = true;
                      }
                    }
                  }
                }
              }
              if (M) {
                M.push(t[C]);
              }
            } else {
              const n = t[C].name;
              if (n) {
                const a = n.d.value;
                const r = x.get(a);
                if (r) {
                  if (r.argsReceived > 0) {
                    if (!It(e) && !S) {
                      kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramAlreadyAssigned().format({
                        name: a
                      }), n);
                    }
                    w = true;
                  } else {
                    r.argsReceived++;
                    const n = b.params.findIndex(e => e.param.name === a && e.kind !== E.ParamKind.Positional);
                    l.assert(n >= 0);
                    const s = b.params[n].type;
                    R.push({
                      paramCategory: 0,
                      paramType: s,
                      requiresTypeVarMatching: Z.requiresSpecialization(s),
                      argument: t[C],
                      errorNode: (h = t[C].valueExpression) !== null && h !== undefined ? h : e,
                      paramName: a
                    });
                    L(t[C], b.params[n].param);
                  }
                } else {
                  if (M) {
                    M.push(t[C]);
                  } else {
                    if (b.kwargsIndex !== undefined) {
                      const r = b.params[b.kwargsIndex].type;
                      if (H.isParamSpec(r)) {
                        if (!It(e) && !S) {
                          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramNameMissing().format({
                            name: n.d.value
                          }), n);
                        }
                        w = true;
                      } else {
                        R.push({
                          paramCategory: 2,
                          paramType: r,
                          requiresTypeVarMatching: Z.requiresSpecialization(r),
                          argument: t[C],
                          errorNode: (f = t[C].valueExpression) !== null && f !== undefined ? f : e,
                          paramName: a
                        });
                        x.set(a, {
                          argsNeeded: 1,
                          argsReceived: 1
                        });
                        l.assert(b.params[b.kwargsIndex], 'paramDetails.kwargsIndex params entry is undefined');
                      }
                      L(t[C], b.params[b.kwargsIndex].param);
                    } else {
                      if (!It(e) && !S) {
                        kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramNameMissing().format({
                          name: n.d.value
                        }), n);
                      }
                      w = true;
                    }
                  }
                }
              } else {
                if (t[C].argCategory === 0) {
                  if (M) {
                    M.push(t[C]);
                  } else {
                    if (!It(e) && !S) {
                      kt(d.DiagnosticRule.reportCallIssue, D === 1 ? g.LocMessage.argPositionalExpectedOne() : g.LocMessage.argPositionalExpectedCount().format({
                        expected: D
                      }), t[C].valueExpression || e);
                    }
                    w = true;
                  }
                } else {
                  if (t[C].argCategory === 1 && _) {
                    const n = Ka(t[C], undefined);
                    const a = n.type;
                    if (n.isIncomplete) {
                      S = true;
                    }
                    if (E.isParamSpecArgs(_, a)) {
                      R.push({
                        paramCategory: 1,
                        paramType: _,
                        requiresTypeVarMatching: false,
                        argument: t[C],
                        argType: H.isParamSpec(a) ? undefined : H.AnyType.create(),
                        errorNode: (T = t[C].valueExpression) !== null && T !== undefined ? T : e
                      });
                    }
                  }
                }
              }
            }
            C++;
          }
          if (!!a && (!B || b.argsIndex !== undefined)) {
            b.params.forEach((r, s) => {
              var i;
              var o;
              const l = r.param;
              if (s >= b.firstPositionOrKeywordIndex && l.category === 0 && l.name && x.has(l.name) && x.get(l.name).argsReceived === 0) {
                const r = b.params[s].type;
                if (!n || !!n.includes(l.name)) {
                  R.push({
                    paramCategory: 0,
                    paramType: r,
                    requiresTypeVarMatching: Z.requiresSpecialization(r),
                    argument: {
                      argCategory: 0,
                      typeResult: {
                        type: a
                      }
                    },
                    errorNode: (o = (i = t.find(e => e.argCategory === 2)) === null || i === undefined ? undefined : i.valueExpression) !== null && o !== undefined ? o : e,
                    paramName: l.name,
                    isParamNameSynthesized: H.FunctionParam.isNameSynthesized(l)
                  });
                  x.get(l.name).argsReceived = 1;
                }
              }
            });
          }
          if (!a && !H.FunctionType.isDefaultParamCheckDisabled(v)) {
            const t = Array.from(x.keys()).filter(e => {
              const t = x.get(e);
              return !t || t.argsReceived < t.argsNeeded;
            });
            if (t.length > 0) {
              if (!It(e)) {
                const n = t.map(e => `"${e}"`).join(', ');
                if (!It(e) && !S) {
                  kt(d.DiagnosticRule.reportCallIssue, t.length === 1 ? g.LocMessage.argMissingForParam().format({
                    name: n
                  }) : g.LocMessage.argMissingForParams().format({
                    names: n
                  }), e);
                }
              }
              w = true;
            }
            b.params.forEach(t => {
              const n = t.param;
              if (n.category === 0 && n.name) {
                const a = x.get(n.name);
                if (a && a.argsNeeded === 0 && a.argsReceived === 0) {
                  const a = t.defaultType;
                  if (a && !Z.isEllipsisType(a) && Z.requiresSpecialization(t.declaredType)) {
                    R.push({
                      paramCategory: n.category,
                      paramType: t.type,
                      requiresTypeVarMatching: true,
                      argument: {
                        argCategory: 0,
                        typeResult: {
                          type: a
                        }
                      },
                      isDefaultArg: true,
                      errorNode: e,
                      paramName: n.name,
                      isParamNameSynthesized: H.FunctionParam.isNameSynthesized(n)
                    });
                  }
                }
              }
            });
          }
        }
        if ((!w || !ar(undefined)) && (l.assert(b.argsIndex === undefined || b.argsIndex < b.params.length, 'paramDetails.argsIndex params entry is invalid'), b.argsIndex !== undefined && b.argsIndex >= 0 && H.FunctionParam.isTypeDeclared(b.params[b.argsIndex].param) && !A)) {
          const t = b.params[b.argsIndex].type;
          const n = R.filter(e => e.mapsToVarArgList);
          if (H.isUnpacked(t) && (!H.isTypeVarTuple(t) || !t.priv.isInUnion)) {
            const a = n.map(t => {
              var n;
              const a = Ka(t.argument, undefined).type;
              if ((H.isUnpackedTypeVarTuple(a) || H.isClassInstance(a) && Z.isTupleClass(a) && a.priv.tupleTypeArgs && a.priv.tupleTypeArgs.length === 1 && H.isUnpackedTypeVarTuple(a.priv.tupleTypeArgs[0].type)) && t.argument.argCategory !== 1 && !t.mapsToVarArgList) {
                if (!It(e) && !S) {
                  kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.typeVarTupleMustBeUnpacked(), (n = t.argument.valueExpression) !== null && n !== undefined ? n : e);
                }
                w = true;
              }
              return {
                type: a,
                isUnbounded: t.argument.argCategory === 1
              };
            });
            let r;
            if (a.length === 1 && !a[0].isUnbounded) {
              const e = a[0].type;
              if (H.isUnpacked(e)) {
                r = Z.makePacked(e);
              }
            }
            if (!r) {
              r = q.makeTupleObject(es, a, false);
            }
            const s = {
              paramCategory: 0,
              paramType: Z.makePacked(t),
              requiresTypeVarMatching: true,
              argument: {
                argCategory: 0,
                typeResult: {
                  type: r
                }
              },
              errorNode: e,
              paramName: b.params[b.argsIndex].param.name,
              isParamNameSynthesized: H.FunctionParam.isNameSynthesized(b.params[b.argsIndex].param),
              mapsToVarArgList: true
            };
            R = [...R.filter(e => !e.mapsToVarArgList), s];
          }
        }
        let K = 0;
        if (I) {
          K--;
        }
        if (H.FunctionType.isBuiltIn(v, ['isinstance', 'issubclass']) && R.length === 2) {
          R[1].isinstanceParam = true;
        }
        return {
          overload: v,
          overloadIndex: a,
          argumentErrors: w,
          isTypeIncomplete: S,
          argParams: R,
          paramSpecTarget: O,
          paramSpecArgList: M,
          activeParam: V,
          relevance: K,
          argumentMatchScore: 0
        };
      }
      function mn(e, t, n, a = false, r) {
        var s;
        const i = t.overload;
        let o = r == null ? undefined : r.expectedType;
        const l = (s = r == null ? undefined : r.returnTypeOverride) !== null && s !== undefined ? s : hr(i);
        if (!l || !Z.requiresSpecialization(l)) {
          o = undefined;
        }
        const p = a => {
          const s = n.clone();
          const i = yn(e, t, s, true, a, l);
          if (!i.argumentErrors && i.returnType) {
            if (Ir(a, (r == null ? undefined : r.returnTypeOverride) ? Xe(r.returnTypeOverride, s) : i.returnType, undefined, undefined, 0)) {
              const e = Z.containsAnyOrUnknown(i.returnType, true);
              if (e) {
                if (H.isAny(e)) {
                  return 2;
                } else {
                  return 1;
                }
              } else {
                return 3;
              }
            }
          }
          return 0;
        };
        if (o) {
          o = nr(nn(e), () => {
            let e;
            let t = -1;
            if (H.isUnion(o)) {
              Z.doForEachSubtype(o, n => {
                if (t < 3) {
                  const a = p(n);
                  if (a > 0 && a > t) {
                    e = n;
                    t = a;
                  }
                }
              }, true);
            }
            if (t < 3) {
              const n = p(o);
              if (n > 0 && n > t) {
                e = o;
              }
            }
            return e;
          });
        }
        if (!o || H.isAnyOrUnknown(o) || H.isNever(o)) {
          return gn(e, t, n, a);
        } else {
          return yn(e, t, n, a, o, l);
        }
      }
      function yn(e, t, n, a = false, r, s) {
        const i = M.getTypeVarScopesForNode(e);
        let o = 2048;
        if (Z.containsLiteralType(r, true)) {
          o |= 256;
        }
        if (H.isClassInstance(s) && H.isClassInstance(r) && !H.isTypeSame(s, r)) {
          const t = new k.ConstraintTracker();
          if (I.addConstraintsForExpectedType(es, s, r, t, i, e.start)) {
            r = Xe(Z.selfSpecializeClass(s, {
              overrideTypeArgs: true
            }), t, {
              replaceUnsolved: {
                scopeIds: Z.getTypeVarScopeIds(s),
                useUnknown: true,
                tupleClassType: ot()
              }
            });
            o |= 4096;
          }
        }
        Ir(s, r = Z.transformExpectedType(r, i, e.start), undefined, n, o);
        return gn(e, t, n, a);
      }
      function gn(e, t, n, a) {
        const r = t.overload;
        let s;
        let i;
        let l = t.isTypeIncomplete;
        let p = false;
        let c = 0;
        const u = nn(e);
        const m = Z.getTypeCondition(r);
        const y = H.FunctionType.getParamSpecFromArgsKwargs(r);
        if (r.priv.boundToType && !r.priv.boundToType.priv.includeSubclasses && r.shared.methodClass) {
          const t = dn(r.shared.methodClass, r.shared.name);
          if (t && !t.hasImplementation) {
            kt(d.DiagnosticRule.reportAbstractUsage, g.LocMessage.abstractMethodInvocation().format({
              method: r.shared.name
            }), e.nodeType === 9 ? e.d.leftExpr : e);
          }
        }
        if (r.shared.name === '__init__' && r.priv.strippedFirstParamType && r.priv.boundToType && H.isClassInstance(r.priv.strippedFirstParamType) && H.isClassInstance(r.priv.boundToType) && H.ClassType.isSameGenericClass(r.priv.strippedFirstParamType, r.priv.boundToType) && r.priv.strippedFirstParamType.priv.typeArgs) {
          const e = r.priv.strippedFirstParamType.shared.typeParams;
          s = r.priv.strippedFirstParamType;
          r.priv.strippedFirstParamType.priv.typeArgs.forEach((t, a) => {
            if (a < e.length) {
              const r = e[a];
              if (!H.isTypeSame(r, t, {
                ignorePseudoGeneric: true
              })) {
                n.setBounds(e[a], t);
              }
            }
          });
        }
        if (H.FunctionType.isBuiltIn(r, ['typing.cast', 'typing_extensions.cast', 'builtins.isinstance', 'builtins.issubclass'])) {
          a = true;
        }
        const h = t.argParams.filter(e => e.requiresTypeVarMatching).length;
        if (h > 0) {
          let e = Math.min(h, 2);
          for (let s = 0; s < e; s++) {
            nr(u, () => {
              t.argParams.forEach(i => {
                if (!i.requiresTypeVarMatching) {
                  return;
                }
                const o = vn(i, n, {
                  type: r,
                  isIncomplete: t.isTypeIncomplete
                }, {
                  skipUnknownArgCheck: a,
                  isArgFirstPass: e > 1 && s === 0,
                  conditionFilter: m,
                  skipReportError: true
                });
                if (o.isTypeIncomplete) {
                  l = true;
                }
                if (s === 0 && e < 2 && o.skippedBareTypeVarExpectedType) {
                  e++;
                }
              });
            });
          }
        }
        let f = false;
        let T = false;
        let v = [];
        const b = [];
        t.argParams.forEach((e, s) => {
          var o;
          const u = vn(e, n, {
            type: r,
            isIncomplete: t.isTypeIncomplete
          }, {
            skipUnknownArgCheck: a,
            conditionFilter: m
          });
          b.push(u);
          if (!u.isCompatible) {
            p = true;
            c += t.argParams.length - s + 1;
          }
          if (u.isTypeIncomplete) {
            l = true;
          }
          if (u.condition) {
            v = (o = H.TypeCondition.combine(v, u.condition)) !== null && o !== undefined ? o : [];
          }
          if (H.isAnyOrUnknown(u.argType)) {
            i = i ? Z.preserveUnknown(u.argType, i) : u.argType;
          }
          if (y) {
            if (e.argument.argCategory === 1 && E.isParamSpecArgs(y, u.argType)) {
              if (f) {
                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecArgsKwargsDuplicate().format({
                  type: Yr(y)
                }), e.errorNode);
              }
              f = true;
            }
            if (e.argument.argCategory === 2 && E.isParamSpecKwargs(y, u.argType)) {
              if (T) {
                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecArgsKwargsDuplicate().format({
                  type: Yr(y)
                }), e.errorNode);
              }
              T = true;
            }
          }
        });
        let _ = [];
        if (t.paramSpecArgList && t.paramSpecTarget) {
          const a = function (e, t, n, a) {
            const r = a.getConstraintSets();
            if (r.length === 1) {
              return Tn(e, t, n, r[0]);
            }
            const s = [];
            const i = [];
            const l = nn(e);
            r.forEach(a => {
              nr(l, () => {
                const r = Tn(e, t, n, a);
                if (!r.argumentErrors) {
                  s.push(a);
                }
                o.appendArray(i, r.constraintTrackers);
              });
            });
            if (s.length > 0) {
              a.addConstraintSets(s);
            }
            const p = Tn(e, t, n, s.length > 0 ? s[0] : r[0]);
            return {
              argumentErrors: p.argumentErrors,
              constraintTrackers: i
            };
          }(e, t.paramSpecArgList, t.paramSpecTarget, n);
          if (a.argumentErrors) {
            p = true;
            c += 1;
          }
          _ = a.constraintTrackers;
        } else {
          if (y) {
            if (!f || !T) {
              if (!l) {
                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecArgsMissing().format({
                  type: Yr(y)
                }), e);
              }
              p = true;
              c += 1;
            }
          }
        }
        let k = hr(r, {
          callSiteInfo: {
            args: t.argParams,
            errorNode: e
          }
        });
        if (v.length > 0) {
          k = H.TypeBase.cloneForCondition(k, v);
        }
        let w = true;
        if (H.isFunction(k) || H.isOverloaded(k)) {
          w = false;
        }
        let S = Xe(k, n, {
          replaceUnsolved: {
            scopeIds: Z.getTypeVarScopeIds(r),
            unsolvedExemptTypeVars: hn(r, k),
            tupleClassType: ot(),
            eliminateUnsolvedInUnions: w
          }
        });
        S = Z.addConditionToType(S, m, {
          skipBoundTypeVars: true
        });
        if (_.length > 0) {
          _.forEach(e => {
            if (e) {
              S = Xe(S, e);
              I.applySourceSolutionToConstraints(n, I.solveConstraints(es, e));
            }
          });
        }
        if (H.isUnpackedClass(S)) {
          S = H.ClassType.cloneForPacked(S);
        }
        const A = M.getTypeVarScopesForNode(e);
        S = function (e, t, n) {
          if (!H.isFunction(t)) {
            return t;
          }
          const a = Z.getTypeVarArgsRecursive(t).filter(e => !n.some(t => e.priv.scopeId === t));
          if (a.length === 0) {
            return t;
          }
          gr(t);
          const r = M.getScopeIdForNode(e);
          const s = new C.ConstraintSolution();
          const i = a.map(e => {
            const t = H.TypeVarType.cloneForScopeId(e, r, e.priv.scopeName, 1);
            s.setType(e, t);
            return t;
          });
          return Z.applySolvedTypeVars(H.FunctionType.cloneWithNewTypeVarScopeId(t, r, undefined, i), s);
        }(e, S, A);
        if (s) {
          s = Xe(s, n);
        }
        t.argumentMatchScore = c;
        return {
          argumentErrors: p,
          argResults: b,
          anyOrUnknownArg: i,
          returnType: S,
          isTypeIncomplete: l,
          activeParam: t.activeParam,
          specializedInitSelfType: s,
          overloadsUsedForCall: p ? [] : [r]
        };
      }
      function hn(e, t) {
        if (H.isFunction(t) && !t.shared.name) {
          if (t.shared.typeVarScopeId && e.shared.typeVarScopeId) {
            let n = Z.getTypeVarArgsRecursive(t);
            e.shared.parameters.forEach((t, a) => {
              if (H.FunctionParam.isTypeDeclared(t)) {
                const t = Z.getTypeVarArgsRecursive(H.FunctionType.getParamType(e, a));
                n = n.filter(e => !t.some(t => H.isTypeSame(e, t)));
              }
            });
            return n;
          }
        }
        return [];
      }
      function fn(e, t, n, a, r = false, s) {
        const i = un(e, t, n, 0);
        if (i.argumentErrors) {
          t.forEach(e => {
            if (e.valueExpression && !ar(e.valueExpression)) {
              qe(e.valueExpression);
            }
          });
          return {
            argumentErrors: true,
            activeParam: i.activeParam,
            overloadsUsedForCall: []
          };
        } else {
          return mn(e, i, a ?? new k.ConstraintTracker(), r, Z.makeInferenceContext(s == null ? undefined : s.expectedType, s == null ? undefined : s.isTypeIncomplete, s == null ? undefined : s.returnTypeOverride));
        }
      }
      function Tn(e, t, n, a) {
        var r;
        let s = I.solveConstraintSet(es, a).getType(n);
        s = Z.convertTypeToParamSpecValue(s ?? n);
        const i = un(e, t, {
          type: s
        }, 0);
        const o = i.overload;
        const l = new k.ConstraintTracker();
        if (i.argumentErrors) {
          t.forEach(e => {
            if (e.valueExpression && !ar(e.valueExpression)) {
              qe(e.valueExpression);
            }
          });
          return {
            argumentErrors: true,
            constraintTrackers: [l]
          };
        }
        const p = H.FunctionType.getParamSpecFromArgsKwargs(o);
        const c = H.FunctionType.cloneRemoveParamSpecArgsKwargs(o);
        if (p && c.shared.parameters.length === 0 && H.isTypeSame(p, n)) {
          let a;
          let s = 0;
          let i = 0;
          let o = false;
          for (const e of t) {
            const t = (r = Ka(e, undefined)) === null || r === undefined ? undefined : r.type;
            if (e.argCategory === 1) {
              if (E.isParamSpecArgs(n, t)) {
                s++;
              }
            } else {
              if (e.argCategory === 2) {
                if (E.isParamSpecKwargs(n, t)) {
                  i++;
                }
              } else {
                a = a ?? e.valueExpression;
                o = true;
              }
            }
          }
          if (s !== 1 || i !== 1) {
            o = true;
          }
          if (o) {
            kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecArgsMissing().format({
              type: Yr(p)
            }), a ?? e);
          }
          return {
            argumentErrors: o,
            constraintTrackers: [l]
          };
        }
        return {
          argumentErrors: !!gn(e, i, l, undefined).argumentErrors,
          constraintTrackers: [l]
        };
      }
      function vn(e, t, n, a) {
        var r;
        var s;
        let i;
        let o;
        let l = !!(n == null ? undefined : n.isIncomplete);
        let c = true;
        const u = n == null ? undefined : n.type.shared.name;
        let m = false;
        if (e.argument.valueExpression) {
          let T;
          let b = true;
          Z.doForEachSubtype(e.paramType, e => {
            if (!H.isTypeVar(e) || e.priv.scopeId !== (n == null ? undefined : n.type.shared.typeVarScopeId)) {
              b = false;
            }
          });
          if (a.isArgFirstPass && b) {
            m = true;
          } else {
            T = e.paramType;
            if (!H.isFunction(e.paramType) || !H.FunctionType.getParamSpecFromArgsKwargs(e.paramType) || !(t.getConstraintSets().length > 1)) {
              T = Xe(T, t, undefined, {
                useLowerBoundOnly: !!a.isArgFirstPass
              });
            }
          }
          if (T && H.isUnknown(T)) {
            T = undefined;
          }
          if (e.argType) {
            i = e.argType;
          } else {
            const _ = e.isinstanceParam ? 536871546 : 18;
            const C = qe(e.argument.valueExpression, _, Z.makeInferenceContext(T, !!(n == null ? undefined : n.isIncomplete)));
            i = C.type;
            if (C.isIncomplete) {
              l = true;
            }
            if (C.typeErrors) {
              c = false;
            } else {
              if (T && Z.requiresSpecialization(T)) {
                const I = t.clone();
                if (Ir(T, i, undefined, I, (a == null ? undefined : a.isArgFirstPass) ? 8 : 0)) {
                  t.copyFromClone(I);
                } else {
                  c = false;
                }
              }
            }
            o = C.expectedTypeDiagAddendum;
          }
          if (e.argument && e.argument.name && !ar(e.errorNode)) {
            Fe(e.argument.name, {
              type: T ?? i,
              isIncomplete: l
            }, 0);
          }
        } else {
          if (e.argType) {
            i = e.argType;
          } else {
            const k = Ka(e.argument, undefined);
            i = k.type;
            if (k.isIncomplete) {
              l = true;
            }
          }
          if (e.isDefaultArg) {
            i = Xe(i, t);
          }
        }
        if (e.paramCategory === 2 && H.isTypeVar(e.paramType)) {
          i = $e(i);
        }
        if (a.conditionFilter) {
          i = Dt(i, {
            conditionFilter: a.conditionFilter
          }, e => e);
        }
        const y = (r = i.props) === null || r === undefined ? undefined : r.condition;
        let h = (a == null ? undefined : a.skipReportError) ? undefined : new p.DiagnosticAddendum();
        if (H.isParamSpec(e.paramType)) {
          if (e.paramType.priv.paramSpecAccess !== undefined) {
            return {
              isCompatible: c,
              argType: i,
              isTypeIncomplete: l,
              condition: y
            };
          }
          if (H.isParamSpec(i) && i.priv.paramSpecAccess !== undefined) {
            return {
              isCompatible: c,
              argType: i,
              isTypeIncomplete: l,
              condition: y
            };
          }
        }
        let f = 0;
        if (e.isinstanceParam) {
          f |= 16384;
        }
        if (a == null ? undefined : a.isArgFirstPass) {
          f |= 8;
        }
        if (!Ir(e.paramType, i, h == null ? undefined : h.createAddendum(), t, f)) {
          if (!(a == null ? undefined : a.skipReportError)) {
            if (v.getFileInfo(e.errorNode).diagnosticRuleSet.reportArgumentType !== 'none' && !It(e.errorNode) && !l) {
              const w = Yr(i);
              const S = Yr(e.paramType);
              let A;
              A = e.paramName && !e.isParamNameSynthesized ? u ? g.LocMessage.argAssignmentParamFunction().format({
                argType: w,
                paramType: S,
                functionName: u,
                paramName: e.paramName
              }) : g.LocMessage.argAssignmentParam().format({
                argType: w,
                paramType: S,
                paramName: e.paramName
              }) : u ? g.LocMessage.argAssignmentFunction().format({
                argType: w,
                paramType: S,
                functionName: u
              }) : g.LocMessage.argAssignment().format({
                argType: w,
                paramType: S
              });
              if (o) {
                h = o;
              }
              kt(d.DiagnosticRule.reportArgumentType, A + (h == null ? undefined : h.getString()), e.errorNode, (s = h == null ? undefined : h.getEffectiveTextRange()) !== null && s !== undefined ? s : e.errorNode);
            }
          }
          return {
            isCompatible: false,
            argType: i,
            isTypeIncomplete: l,
            skippedBareTypeVarExpectedType: m,
            condition: y
          };
        }
        if (!a.skipUnknownArgCheck) {
          const x = Pt(H.removeUnbound(i));
          function P() {
            const t = new p.DiagnosticAddendum();
            if (e.paramName) {
              t.addMessage((u ? g.LocAddendum.argParamFunction().format({
                paramName: e.paramName,
                functionName: u
              }) : g.LocAddendum.argParam().format({
                paramName: e.paramName
              })) + t.getString());
            }
            return t;
          }
          if (v.getFileInfo(e.errorNode).diagnosticRuleSet.reportUnknownArgumentType !== 'none' && !H.isAny(e.paramType) && !l) {
            if (H.isUnknown(x)) {
              const D = P();
              kt(d.DiagnosticRule.reportUnknownArgumentType, g.LocMessage.argTypeUnknown() + D.getString(), e.errorNode);
            } else {
              if (Z.isPartlyUnknown(x) && !Z.isPartlyUnknown(e.paramType)) {
                const N = P();
                N.addMessage(g.LocAddendum.argumentType().format({
                  type: Yr(x, {
                    expandTypeAlias: true
                  })
                }));
                kt(d.DiagnosticRule.reportUnknownArgumentType, g.LocMessage.argTypePartiallyUnknown() + N.getString(), e.errorNode);
              }
            }
          }
        }
        return {
          isCompatible: c,
          argType: i,
          isTypeIncomplete: l,
          skippedBareTypeVarExpectedType: m,
          condition: y
        };
      }
      function bn(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        var o;
        var l;
        var p;
        let c;
        let m;
        let y = '';
        if (n.length === 0) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarFirstArg(), e);
          return;
        }
        const h = n[0];
        if (h.valueExpression && h.valueExpression.nodeType === 48) {
          y = h.valueExpression.d.strings.map(e => e.d.value).join('');
        } else {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarFirstArg(), h.valueExpression || e);
        }
        const f = H.TypeBase.cloneAsSpecialForm(H.TypeVarType.createInstantiable(y), H.ClassType.cloneAsInstance(t));
        const T = new Map();
        for (let y = 1; y < n.length; y++) {
          const h = n[y].name;
          const b = h ? h.d.value : undefined;
          if (b) {
            if (T.get(b)) {
              kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.duplicateParam().format({
                name: b
              }), n[y].valueExpression || e);
            }
            if (b === 'bound') {
              if (H.TypeVarType.hasConstraints(f)) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarBoundAndConstrained(), n[y].valueExpression || e);
              } else {
                const t = (r = (a = n[y].typeResult) === null || a === undefined ? undefined : a.type) !== null && r !== undefined ? r : Ha(n[y].valueExpression, {
                  noNonTypeSpecialForms: true,
                  typeExpression: true,
                  parsesStringLiteral: true
                }).type;
                if (Z.requiresSpecialization(t, {
                  ignorePseudoGeneric: true,
                  ignoreImplicitTypeArgs: true
                })) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarBoundGeneric(), n[y].valueExpression || e);
                }
                f.shared.boundType = Z.convertToInstance(t);
              }
            } else {
              if (b === 'covariant') {
                if (n[y].valueExpression && Sn(n[y].valueExpression)) {
                  if (f.shared.declaredVariance === 4 || f.shared.declaredVariance === 0) {
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarVariance(), n[y].valueExpression);
                  } else {
                    f.shared.declaredVariance = 3;
                  }
                }
              } else {
                if (b === 'contravariant') {
                  if (n[y].valueExpression && Sn(n[y].valueExpression)) {
                    if (f.shared.declaredVariance === 3 || f.shared.declaredVariance === 0) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarVariance(), n[y].valueExpression);
                    } else {
                      f.shared.declaredVariance = 4;
                    }
                  }
                } else {
                  if (b === 'infer_variance') {
                    if (n[y].valueExpression && Sn(n[y].valueExpression)) {
                      if (f.shared.declaredVariance === 3 || f.shared.declaredVariance === 4) {
                        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarVariance(), n[y].valueExpression);
                      } else {
                        f.shared.declaredVariance = 0;
                      }
                    }
                  } else {
                    if (b === 'default') {
                      m = n[y].valueExpression;
                      const a = (i = (s = n[y].typeResult) === null || s === undefined ? undefined : s.type) !== null && i !== undefined ? i : Ha(m, {
                        allowTypeVarsWithoutScopeId: true,
                        typeExpression: true
                      }).type;
                      f.shared.defaultType = Z.convertToInstance(a);
                      f.shared.isDefaultExplicit = true;
                      const r = v.getFileInfo(e);
                      if (!r.isStubFile && u.PythonVersion.isLessThan(r.executionEnvironment.pythonVersion, u.pythonVersion3_13) && t.shared.moduleName !== 'typing_extensions') {
                        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultIllegal(), m);
                      }
                    } else {
                      kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.typeVarUnknownParam().format({
                        name: b
                      }), ((o = n[y].node) === null || o === undefined ? undefined : o.d.name) || n[y].valueExpression || e);
                    }
                  }
                }
              }
            }
            T.set(b, b);
          } else {
            if (H.TypeVarType.hasBound(f)) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarBoundAndConstrained(), n[y].valueExpression || e);
            } else {
              const t = (p = (l = n[y].typeResult) === null || l === undefined ? undefined : l.type) !== null && p !== undefined ? p : Ha(n[y].valueExpression, {
                typeExpression: true
              }).type;
              if (Z.requiresSpecialization(t, {
                ignorePseudoGeneric: true
              })) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarConstraintGeneric(), n[y].valueExpression || e);
              }
              H.TypeVarType.addConstraint(f, Z.convertToInstance(t));
              if (c === undefined) {
                c = n[y];
              }
            }
          }
        }
        if (f.shared.constraints.length === 1 && c) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarSingleConstraint(), c.valueExpression || e);
        }
        if (f.shared.isDefaultExplicit && m) {
          _n(f, m);
        }
        return f;
      }
      function _n(e, t) {
        l.assert(e.shared.isDefaultExplicit);
        const n = new k.ConstraintTracker();
        const a = Pt(Xe(e.shared.defaultType, n, {
          replaceUnsolved: {
            scopeIds: Z.getTypeVarScopeIds(e),
            tupleClassType: ot()
          }
        }));
        if (e.shared.boundType) {
          if (!Ir(e.shared.boundType, a)) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultBoundMismatch(), t);
          }
        } else {
          if (H.TypeVarType.hasConstraints(e)) {
            let n = true;
            if (H.isTypeVar(e.shared.defaultType) && H.TypeVarType.hasConstraints(e.shared.defaultType)) {
              for (const t of e.shared.defaultType.shared.constraints) {
                if (!e.shared.constraints.some(e => H.isTypeSame(e, t))) {
                  n = false;
                }
              }
            } else {
              if (!e.shared.constraints.some(e => H.isTypeSame(e, a, {
                ignoreConditions: true
              }))) {
                n = false;
              }
            }
            if (!n) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultConstraintMismatch(), t);
            }
          }
        }
      }
      function Cn(e, t, n) {
        var a;
        var r;
        let s = '';
        if (n.length === 0) {
          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.typeVarFirstArg(), e);
          return;
        }
        const i = n[0];
        if (i.valueExpression && i.valueExpression.nodeType === 48) {
          s = i.valueExpression.d.strings.map(e => e.d.value).join('');
        } else {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarFirstArg(), i.valueExpression || e);
        }
        const o = H.TypeBase.cloneAsSpecialForm(H.TypeVarType.createInstantiable(s, H.TypeVarKind.TypeVarTuple), H.ClassType.cloneAsInstance(t));
        o.shared.defaultType = q.makeTupleObject(es, [{
          type: H.UnknownType.create(),
          isUnbounded: true
        }]);
        for (let s = 1; s < n.length; s++) {
          const i = n[s].name;
          const l = i ? i.d.value : undefined;
          if (l) {
            if (l === 'default') {
              const a = n[s].valueExpression;
              if (a) {
                const e = In(a, false);
                if (e) {
                  o.shared.defaultType = e;
                  o.shared.isDefaultExplicit = true;
                }
              }
              const r = v.getFileInfo(e);
              if (!r.isStubFile && u.PythonVersion.isLessThan(r.executionEnvironment.pythonVersion, u.pythonVersion3_13) && t.shared.moduleName !== 'typing_extensions') {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultIllegal(), a);
              }
            } else {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarTupleUnknownParam().format({
                name: ((a = n[s].name) === null || a === undefined ? undefined : a.d.value) || '?'
              }), ((r = n[s].node) === null || r === undefined ? undefined : r.d.name) || n[s].valueExpression || e);
            }
          } else {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarTupleConstraints(), n[s].valueExpression || e);
          }
        }
        return o;
      }
      function In(e, t) {
        const n = Ha(e, {
          allowUnpackedTuple: true,
          allowTypeVarsWithoutScopeId: true,
          forwardRefs: t,
          typeExpression: true
        }).type;
        const a = H.isClass(n) && Z.isTupleClass(n) && n.priv.isUnpacked;
        const r = H.isUnpackedTypeVarTuple(n);
        if (a || r) {
          return Z.convertToInstance(n);
        }
        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarTupleDefaultNotUnpacked(), e);
      }
      function kn(e, t, n) {
        if (n.length === 0) {
          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecFirstArg(), e);
          return;
        }
        const a = n[0];
        let r = '';
        if (a.valueExpression && a.valueExpression.nodeType === 48) {
          r = a.valueExpression.d.strings.map(e => e.d.value).join('');
        } else {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecFirstArg(), a.valueExpression || e);
        }
        const s = H.TypeBase.cloneAsSpecialForm(H.TypeVarType.createInstantiable(r, H.TypeVarKind.ParamSpec), H.ClassType.cloneAsInstance(t));
        s.shared.defaultType = H.ParamSpecType.getUnknown();
        for (let a = 1; a < n.length; a++) {
          const r = n[a].name;
          const i = r ? r.d.value : undefined;
          if (!i) {
            kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecUnknownArg(), n[a].valueExpression || e);
            break;
          }
          if (i === 'default') {
            const r = n[a].valueExpression;
            if (r) {
              const e = wn(r, false);
              if (e) {
                s.shared.defaultType = e;
                s.shared.isDefaultExplicit = true;
              }
            }
            const i = v.getFileInfo(e);
            if (!i.isStubFile && u.PythonVersion.isLessThan(i.executionEnvironment.pythonVersion, u.pythonVersion3_13) && t.shared.moduleName !== 'typing_extensions') {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultIllegal(), r);
            }
          } else {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecUnknownParam().format({
              name: i
            }), r || n[a].valueExpression || e);
          }
        }
        return s;
      }
      function wn(e, t) {
        const n = H.FunctionType.createSynthesizedInstance('', 65536);
        if (e.nodeType === 21) {
          H.FunctionType.addDefaultParams(n);
          n.shared.flags |= 32768;
          return n;
        }
        if (e.nodeType === 34) {
          e.d.items.forEach((e, a) => {
            const r = Ha(e, {
              allowTypeVarsWithoutScopeId: true,
              forwardRefs: t,
              typeExpression: true
            });
            H.FunctionType.addParam(n, H.FunctionParam.create(0, Z.convertToInstance(r.type), H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${a}`));
          });
          if (e.d.items.length > 0) {
            H.FunctionType.addPositionOnlyParamSeparator(n);
          }
          Fe(e, {
            type: H.AnyType.create()
          }, undefined);
          return n;
        }
        {
          const t = Ha(e, {
            allowParamSpec: true,
            allowTypeVarsWithoutScopeId: true,
            allowEllipsis: true,
            typeExpression: true
          });
          if (t.typeErrors) {
            return;
          }
          if (H.isParamSpec(t.type)) {
            H.FunctionType.addParamSpecVariadics(n, t.type);
            return n;
          }
          if (H.isClassInstance(t.type) && H.ClassType.isBuiltIn(t.type, ['EllipsisType', 'ellipsis'])) {
            H.FunctionType.addDefaultParams(n);
            return n;
          }
        }
        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecDefaultNotTuple(), e);
      }
      function Sn(e) {
        if (e.nodeType === 14) {
          if (e.d.constType === 15) {
            return false;
          }
          if (e.d.constType === 33) {
            return true;
          }
        }
        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.expectedBoolLiteral(), e);
        return false;
      }
      function An(e, t) {
        var n;
        var a;
        var r;
        var s;
        var i;
        const o = v.getFileInfo(e);
        let l = '';
        if (t.length !== 2) {
          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.newTypeParamCount(), e);
          return;
        }
        const p = t[0];
        if (p.argCategory === 0 && p.valueExpression && p.valueExpression.nodeType === 48) {
          l = p.valueExpression.d.strings.map(e => e.d.value).join('');
        }
        if (!l) {
          kt(d.DiagnosticRule.reportArgumentType, g.LocMessage.newTypeBadName(), (n = t[0].node) !== null && n !== undefined ? n : e);
          return;
        }
        if (((a = e.parent) === null || a === undefined ? undefined : a.nodeType) === 3 && e.parent.d.leftExpr.nodeType === 38 && e.parent.d.leftExpr.d.value !== l) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeNameMismatch(), e.parent.d.leftExpr);
          return;
        }
        let c = $a(t[1]).type;
        let u = false;
        if (H.isAnyOrUnknown(c)) {
          c = (r = Ae == null ? undefined : Ae.objectClass) !== null && r !== undefined ? r : H.UnknownType.create();
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeAnyOrUnknown(), (s = t[1].node) !== null && s !== undefined ? s : e);
          u = true;
        }
        if (((i = c.props) === null || i === undefined ? undefined : i.specialForm) && H.isClassInstance(c.props.specialForm) && H.ClassType.isBuiltIn(c.props.specialForm, 'Annotated')) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeNotAClass(), t[1].node || e);
          return;
        }
        if (!H.isInstantiableClass(c)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeNotAClass(), t[1].node || e);
          return;
        }
        if (H.ClassType.isProtocolClass(c) || H.ClassType.isTypedDictClass(c)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeProtocolClass(), t[1].node || e);
        } else {
          if (c.priv.literalValue !== undefined) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeLiteral(), t[1].node || e);
          }
        }
        const m = H.ClassType.createInstantiable(l, M.getClassFullName(e, o.moduleName, l), o.moduleName, o.fileUri, 6291712, M.getTypeSourceId(e), undefined, c.shared.effectiveMetaclass);
        m.shared.baseClasses.push(u ? H.AnyType.create() : c);
        Z.computeMroLinearization(m);
        if (!u) {
          const e = H.FunctionType.createSynthesizedInstance('__init__');
          H.FunctionType.addParam(e, H.FunctionParam.create(0, H.ClassType.cloneAsInstance(m), H.FunctionParamFlags.TypeDeclared, 'self'));
          H.FunctionType.addParam(e, H.FunctionParam.create(0, H.ClassType.cloneAsInstance(c), H.FunctionParamFlags.TypeDeclared, '_x'));
          e.shared.declaredReturnType = pt();
          H.ClassType.getSymbolTable(m).set('__init__', L.Symbol.createWithType(4, e));
          const t = H.FunctionType.createSynthesizedInstance('__new__', 1);
          H.FunctionType.addParam(t, H.FunctionParam.create(0, m, H.FunctionParamFlags.TypeDeclared, 'cls'));
          H.FunctionType.addDefaultParams(t);
          t.shared.declaredReturnType = H.ClassType.cloneAsInstance(m);
          t.priv.constructorTypeVarScopeId = Z.getTypeVarScopeId(m);
          H.ClassType.getSymbolTable(m).set('__new__', L.Symbol.createWithType(4, t));
        }
        return m;
      }
      function xn(e, t, n) {
        const a = v.getFileInfo(e);
        const r = Ka(t[0], undefined).type;
        if (!H.isClassInstance(r) || !H.ClassType.isBuiltIn(r, 'str')) {
          return;
        }
        const s = r.priv.literalValue || '_';
        const i = Ka(t[1], undefined).type;
        if (!H.isClassInstance(i) || !Z.isTupleClass(i) || i.priv.tupleTypeArgs === undefined) {
          return;
        }
        const o = H.ClassType.createInstantiable(s, M.getClassFullName(e, a.moduleName, s), a.moduleName, a.fileUri, 4194304, M.getTypeSourceId(e), n, i.shared.effectiveMetaclass);
        i.priv.tupleTypeArgs.forEach(e => {
          const t = Pt(e.type);
          if (Z.isEffectivelyInstantiable(t)) {
            o.shared.baseClasses.push(t);
          } else {
            o.shared.baseClasses.push(H.UnknownType.create());
          }
        });
        if (!Z.computeMroLinearization(o)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.methodOrdering(), e);
        }
        return o;
      }
      function Pn(e, t, n, a, r, s) {
        let i;
        let o = true;
        let p = false;
        const d = [];
        const c = e => {
          let c;
          const u = Pt(e);
          if (H.isClass(u)) {
            c = tt(u, t, e, s);
          }
          if (c) {
            const e = n.map(e => ({
              argCategory: 0,
              typeResult: e
            }));
            let s;
            s = nr(a, () => {
              l.assert(c !== undefined);
              return pn(a, e, {
                type: c
              }, undefined, true, r);
            });
            if (s.argumentErrors && r) {
              s = nr(a, () => {
                l.assert(c !== undefined);
                return pn(a, e, {
                  type: c
                }, undefined, true, undefined);
              });
            }
            if (s.argumentErrors) {
              o = false;
            } else {
              if (s.overloadsUsedForCall) {
                s.overloadsUsedForCall.forEach(e => {
                  d.push(e);
                  if (e.shared.deprecatedMessage && H.isClass(u)) {
                    i = {
                      deprecatedMessage: e.shared.deprecatedMessage,
                      className: u.shared.name,
                      methodName: t
                    };
                  }
                });
              }
            }
            if (s.isTypeIncomplete) {
              p = true;
            }
            return s.returnType;
          }
          o = false;
        };
        const u = Z.mapSubtypes(e, e => H.isAnyOrUnknown(e) ? e : H.isClassInstance(e) || H.isInstantiableClass(e) || H.isTypeVar(e) ? c(e) : Z.isNoneInstance(e) && (Ae == null ? undefined : Ae.objectClass) && H.isInstantiableClass(Ae.objectClass) ? c(H.ClassType.cloneAsInstance(Ae.objectClass)) : Z.isNoneTypeClass(e) && (Ae == null ? undefined : Ae.typeClass) && H.isInstantiableClass(Ae.typeClass) ? c(H.ClassType.cloneAsInstance(Ae.typeClass)) : void (o = false));
        if (o) {
          return {
            type: u,
            isIncomplete: p,
            magicMethodDeprecationInfo: i,
            overloadsUsedForCall: d
          };
        }
      }
      function Dn(e, t, n, a) {
        n.expectedType = Z.transformPossibleRecursiveTypeAlias(n.expectedType);
        let r = Pt(n.expectedType);
        if (!H.isClassInstance(r)) {
          return;
        }
        const s = [];
        const i = [];
        let o;
        let l;
        let p = false;
        let d = false;
        if (H.ClassType.isTypedDictClass(r)) {
          r = H.TypeBase.cloneForCondition(r, undefined);
          const n = Nn(e, t, s, i, true, true, undefined, undefined, W.getTypedDictMembersForClass(es, r), a);
          if (n.isIncomplete) {
            p = true;
          }
          if (n.typeErrors) {
            d = true;
          }
          const o = W.assignToTypedDict(es, r, s, i, (a == null ? undefined : a.isEmpty()) ? a : undefined);
          if (o) {
            return {
              type: o,
              isIncomplete: p
            };
          } else {
            return undefined;
          }
        }
        if (H.isAnyOrUnknown(n.expectedType)) {
          o = n.expectedType;
          l = n.expectedType;
        } else {
          const t = Ya(e, 'dict');
          if (!H.isClassInstance(t)) {
            return;
          }
          const a = new k.ConstraintTracker();
          if (!I.addConstraintsForExpectedType(es, t, n.expectedType, a, M.getTypeVarScopesForNode(e), e.start)) {
            return;
          }
          const r = Xe(H.ClassType.cloneAsInstantiable(t), a);
          if (!r.priv.typeArgs || r.priv.typeArgs.length !== 2) {
            return;
          }
          o = r.priv.typeArgs[0];
          l = r.priv.typeArgs[1];
        }
        let c = false;
        if (H.isClassInstance(n.expectedType) && n.expectedType.shared.typeParams.length >= 2) {
          const e = n.expectedType.shared.typeParams[1];
          if (H.TypeVarType.getVariance(e) === 2) {
            c = true;
          }
        }
        const u = Nn(e, t, s, i, true, c, o, l, undefined, a);
        if (u.isIncomplete) {
          p = true;
        }
        if (u.typeErrors) {
          d = true;
        }
        const m = On(Z.makeInferenceContext(o), s.map(e => e.type), false);
        const y = On(Z.makeInferenceContext(l), i.map(e => e.type), !c);
        if (!m || !y) {
          return;
        }
        return {
          type: Ya(e, 'dict', [m, y]),
          isIncomplete: p,
          typeErrors: d
        };
      }
      function Nn(e, t, n, a, r, s, i, o, l, p) {
        let c = false;
        let u = false;
        const m = t & -393;
        e.d.items.forEach((y, h) => {
          var f;
          var T;
          var v;
          var b;
          var _;
          var C;
          let I = true;
          if (y.nodeType === 20) {
            const d = qe(y.d.keyExpr, m | 268435456, Z.makeInferenceContext(i ?? (r ? H.NeverType.createNever() : undefined)));
            if (d.isIncomplete) {
              c = true;
            }
            if (d.typeErrors) {
              u = true;
            }
            const g = d.type;
            let b;
            let _;
            if (!d.isIncomplete && !d.typeErrors) {
              Mn(y.d.keyExpr, g, true);
            }
            if (p && d.expectedTypeDiagAddendum) {
              p.addAddendum(d.expectedTypeDiagAddendum);
            }
            if (l && H.isClassInstance(g) && H.ClassType.isBuiltIn(g, 'str') && Z.isLiteralType(g) && (l.knownItems.has(g.priv.literalValue) || l.extraItems)) {
              let n = (T = (f = l.knownItems.get(g.priv.literalValue)) === null || f === undefined ? undefined : f.valueType) !== null && T !== undefined ? T : (v = l.extraItems) === null || v === undefined ? undefined : v.valueType;
              if (n) {
                const t = M.getTypeVarScopesForNode(e);
                n = Z.transformExpectedType(n, t, e.start);
              }
              _ = Z.makeInferenceContext(n);
              b = qe(y.d.valueExpr, t | 268435456, _);
            } else {
              let n = o ?? (r ? H.NeverType.createNever() : undefined);
              if (n) {
                const t = M.getTypeVarScopesForNode(e);
                n = Z.transformExpectedType(n, t, e.start);
              }
              _ = Z.makeInferenceContext(n);
              b = qe(y.d.valueExpr, t | 268435456, _);
            }
            if (_ && !b.typeErrors) {
              const e = On(_, [b.type], !s);
              if (e) {
                b = {
                  ...b,
                  type: e
                };
              }
            }
            if (p && b.expectedTypeDiagAddendum) {
              p.addAddendum(b.expectedTypeDiagAddendum);
            }
            const C = b.type;
            if (b.isIncomplete) {
              c = true;
            }
            if (b.typeErrors) {
              u = true;
            }
            if (r || h < ae) {
              if (H.isClass(g) && Z.isLiteralType(g)) {
                const e = n.findIndex(e => H.isTypeSame(g, e.type));
                if (e >= 0) {
                  n.splice(e, 1);
                  a.splice(e, 1);
                }
              }
              n.push({
                node: y.d.keyExpr,
                type: g
              });
              a.push({
                node: y.d.valueExpr,
                type: C
              });
            }
            I = false;
          } else {
            if (y.nodeType === 19) {
              let e;
              if (i && o && (Ae == null ? undefined : Ae.supportsKeysAndGetItemClass) && H.isInstantiableClass(Ae.supportsKeysAndGetItemClass)) {
                e = H.ClassType.cloneAsInstance(H.ClassType.specialize(Ae.supportsKeysAndGetItemClass, [i, o]));
              }
              const p = Z.makeInferenceContext(e);
              let m = qe(y.d.expr, t | 268435456, p);
              if (p && !m.typeErrors) {
                const e = On(p, [m.type], !s);
                if (e) {
                  m = {
                    ...m,
                    type: e
                  };
                }
              }
              if (m.isIncomplete) {
                c = true;
              }
              if (m.typeErrors) {
                u = true;
              }
              const f = m.type;
              if (H.isAnyOrUnknown(f)) {
                I = false;
              } else {
                if (H.isClassInstance(f) && H.ClassType.isTypedDictClass(f)) {
                  if ((Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass)) {
                    const e = H.ClassType.cloneAsInstance(Ae.strClass);
                    const t = W.getTypedDictMembersForClass(es, f, true);
                    t.knownItems.forEach((t, r) => {
                      if (t.isRequired || t.isProvided) {
                        n.push({
                          node: y,
                          type: H.ClassType.cloneWithLiteral(e, r)
                        });
                        a.push({
                          node: y,
                          type: t.valueType
                        });
                      }
                    });
                    if (!l) {
                      n.push({
                        node: y,
                        type: H.ClassType.cloneAsInstance(e)
                      });
                      a.push({
                        node: y,
                        type: (_ = (b = t.extraItems) === null || b === undefined ? undefined : b.valueType) !== null && _ !== undefined ? _ : lt()
                      });
                    }
                    I = false;
                  }
                } else {
                  if ((Ae == null ? undefined : Ae.supportsKeysAndGetItemClass) && H.isInstantiableClass(Ae.supportsKeysAndGetItemClass)) {
                    const e = new k.ConstraintTracker();
                    const t = Z.selfSpecializeClass(Ae.supportsKeysAndGetItemClass);
                    if (Ir(H.ClassType.cloneAsInstance(t), f, undefined, e, 256)) {
                      const s = Xe(t, e).priv.typeArgs;
                      if (s && s.length >= 2) {
                        if (r || h < ae) {
                          n.push({
                            node: y,
                            type: s[0]
                          });
                          a.push({
                            node: y,
                            type: s[1]
                          });
                        }
                        I = false;
                      }
                    } else {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.dictUnpackIsNotMapping(), y);
                    }
                  }
                }
              }
            } else {
              if (y.nodeType === 11) {
                const e = Rn(y, t | 268435456, o, i);
                const s = e.type;
                if (e.isIncomplete) {
                  c = true;
                }
                if (e.typeErrors) {
                  u = true;
                }
                if (H.isClassInstance(s) && Z.isTupleClass(s)) {
                  const e = (C = s.priv.tupleTypeArgs) === null || C === undefined ? undefined : C.map(e => e.type);
                  if (e && e.length === 2) {
                    if (r || h < ae) {
                      n.push({
                        node: y,
                        type: e[0]
                      });
                      a.push({
                        node: y,
                        type: e[1]
                      });
                    }
                    I = false;
                  }
                }
              }
            }
          }
          if (I && (r || h < ae)) {
            n.push({
              node: y,
              type: H.UnknownType.create()
            });
            a.push({
              node: y,
              type: H.UnknownType.create()
            });
          }
        });
        return {
          type: H.AnyType.create(),
          isIncomplete: c,
          typeErrors: u
        };
      }
      function Fn(e, t, n) {
        const a = e.nodeType === 34 ? 'list' : 'set';
        n.expectedType = Z.transformPossibleRecursiveTypeAlias(n.expectedType);
        let r = false;
        let s = false;
        const i = e.nodeType === 45;
        const o = En(e, Za(e, a), n);
        if (!o) {
          return;
        }
        const l = [];
        const d = new p.DiagnosticAddendum();
        e.d.items.forEach(e => {
          let n;
          n = e.nodeType === 11 ? Rn(e, t | 268435456, o) : qe(e, t | 268435456, Z.makeInferenceContext(o));
          l.push(n.type);
          if (n.isIncomplete) {
            r = true;
          }
          if (n.typeErrors) {
            s = true;
          }
          if (n.expectedTypeDiagAddendum) {
            d.addAddendum(n.expectedTypeDiagAddendum);
          }
          if (!!i && !n.isIncomplete && !n.typeErrors) {
            Mn(e, n.type, false);
          }
        });
        let c = false;
        if (H.isClassInstance(n.expectedType)) {
          ya(n.expectedType);
          if (n.expectedType.shared.typeParams.some(e => H.TypeVarType.getVariance(e) === 2)) {
            c = true;
          }
        }
        const u = On(Z.makeInferenceContext(o), l, !c);
        if (!u) {
          return {
            type: H.UnknownType.create(),
            isIncomplete: r,
            typeErrors: true,
            expectedTypeDiagAddendum: d
          };
        }
        return {
          type: Ya(e, a, [u]),
          isIncomplete: r,
          typeErrors: s,
          expectedTypeDiagAddendum: d
        };
      }
      function En(e, t, n) {
        if (!n) {
          return;
        }
        if (!t || !H.isInstantiableClass(t)) {
          return;
        }
        if (H.isAnyOrUnknown(n.expectedType)) {
          return n.expectedType;
        }
        if (!H.isClassInstance(n.expectedType)) {
          return;
        }
        const a = new k.ConstraintTracker();
        if (!I.addConstraintsForExpectedType(es, H.ClassType.cloneAsInstance(t), n.expectedType, a, M.getTypeVarScopesForNode(e), e.start)) {
          return;
        }
        const r = Xe(t, a);
        if (r.priv.typeArgs) {
          return r.priv.typeArgs[0];
        } else {
          return undefined;
        }
      }
      function Mn(e, t, n) {
        if (!function (e) {
          let t = true;
          Z.doForEachSubtype(Pt(e), e => {
            if (H.isClassInstance(e)) {
              let n = true;
              if (e.shared.isInstanceHashable !== undefined) {
                n = e.shared.isInstanceHashable;
              } else {
                const t = Z.lookUpObjectMember(e, '__hash__', 4);
                if (t && t.isTypeDeclared) {
                  const e = t.symbol.getTypedDeclarations();
                  const a = t.symbol.getSynthesizedType();
                  if (a) {
                    n = !Z.isNoneInstance(a.type);
                  } else {
                    if (e.every(e => e.type === 1)) {
                      n = false;
                    }
                  }
                }
                e.shared.isInstanceHashable = n;
              }
              if (!n) {
                t = false;
              }
            }
          });
          return t;
        }(t)) {
          const a = new p.DiagnosticAddendum();
          a.addMessage(g.LocAddendum.unhashableType().format({
            type: Yr(t)
          }));
          const r = n ? g.LocMessage.unhashableDictKey() : g.LocMessage.unhashableSetEntry();
          kt(d.DiagnosticRule.reportUnhashable, r + a.getString(), e);
        }
      }
      function On(e, t, n) {
        if (H.isAny(e.expectedType)) {
          return e.expectedType;
        }
        const a = new k.ConstraintTracker();
        const r = e.expectedType;
        let s = true;
        t.forEach(e => {
          if (s && !Ir(r, e, undefined, a)) {
            s = false;
          }
        });
        if (s) {
          if (n && t.length > 0) {
            const n = H.combineTypes(t);
            if (Z.containsLiteralType(e.expectedType)) {
              return n;
            } else {
              return $e(n);
            }
          }
          return Z.mapSubtypes(Xe(e.expectedType, a, {
            replaceUnsolved: {
              scopeIds: [],
              tupleClassType: ot()
            }
          }), e => {
            if (t.length !== 1) {
              return e;
            }
            const n = t[0];
            if (H.isTypeSame(e, n, {
              ignoreTypedDictNarrowEntries: true
            }) && H.isClass(e) && H.isClass(n) && H.ClassType.isTypedDictClass(n)) {
              return H.ClassType.cloneForNarrowedTypedDictEntries(e, n.priv.typedDictNarrowedEntries);
            } else {
              return e;
            }
          });
        }
      }
      function zn(e, t, n, a) {
        let r;
        let s;
        let o = !!(n == null ? undefined : n.isTypeIncomplete);
        let l = true;
        if (t) {
          const n = M.getTypeVarScopesForNode(e);
          t = Z.transformExpectedType(t, n, e.start);
          s = E.getParamListDetails(t);
          r = hr(t);
        }
        let p = H.FunctionType.createInstance('', '', '', 131072);
        p.shared.typeVarScopeId = M.getScopeIdForNode(e);
        return i.invalidateTypeCacheIfCanceled(() => {
          Fe(e, {
            type: p,
            isIncomplete: true
          }, 0);
          let i = false;
          e.d.params.forEach((t, a) => {
            let r;
            if (s && !i) {
              if (a < s.params.length) {
                const e = s.params[a];
                if (e.param.category === t.d.category && !t.d.name == !e.param.name) {
                  r = e.type;
                } else {
                  i = true;
                }
              } else {
                if (t.d.defaultValue) {
                  r = qe(t.d.defaultValue, undefined, n).type;
                }
              }
            } else {
              if (t.d.defaultValue) {
                r = ka(t.d.defaultValue);
              }
            }
            if (t.d.name) {
              Fe(t.d.name, {
                type: wa(e, t.d.category, r ?? H.UnknownType.create())
              }, 0);
            }
            if (t.d.defaultValue) {
              qe(t.d.defaultValue, 1);
            }
            if (a >= 0) {
              let e = false;
              if (t.d.category === 0 && t.d.name) {
                if (B.isPrivateName(t.d.name.d.value)) {
                  e = true;
                }
              } else {
                l = false;
              }
              if (l && !e && p.shared.parameters.length > 0) {
                H.FunctionType.addPositionOnlyParamSeparator(p);
              }
              if (!e) {
                l = false;
              }
            }
            const o = H.FunctionParam.create(t.d.category, r ?? H.UnknownType.create(), H.FunctionParamFlags.TypeDeclared, t.d.name ? t.d.name.d.value : undefined, t.d.defaultValue ? H.AnyType.create(true) : undefined, t.d.defaultValue);
            H.FunctionType.addParam(p, o);
          });
          if (l && p.shared.parameters.length > 0) {
            H.FunctionType.addPositionOnlyParamSeparator(p);
          }
          let d = false;
          nr(a || ar(e) || (n == null ? undefined : n.isTypeIncomplete) ? e.d.expr : undefined, () => {
            const t = qe(e.d.expr, undefined, Z.makeInferenceContext(r));
            p.priv.inferredReturnType = t.type;
            if (t.isIncomplete) {
              o = true;
            }
            if (t.typeErrors) {
              d = true;
            } else {
              if (r && Z.requiresSpecialization(r)) {
                const e = new k.ConstraintTracker();
                if (Ir(r, t.type, undefined, e)) {
                  p = Xe(p, e, {
                    replaceUnsolved: {
                      scopeIds: [],
                      tupleClassType: ot()
                    }
                  });
                }
              }
            }
          }, {
            dependentType: n == null ? undefined : n.expectedType,
            allowDiagnostics: !a && !It(e) && !(n == null ? undefined : n.isTypeIncomplete)
          });
          p.shared.flags &= -131073;
          if (t && !Ir(t, p)) {
            d = true;
          }
          return {
            type: p,
            isIncomplete: o,
            typeErrors: d
          };
        });
      }
      function Un(e, t, n, a, r, s) {
        if (e === 'none') {
          return;
        }
        const i = n.d.value;
        const o = H.removeUnbound(a);
        if (H.isUnknown(o)) {
          kt(t, g.LocMessage.typeUnknown().format({
            name: i
          }), r);
        } else {
          if (Z.isPartlyUnknown(o) && (!s || !H.isClassInstance(a) || !a.priv.isEmptyContainer)) {
            const e = new p.DiagnosticAddendum();
            e.addMessage(g.LocAddendum.typeOfSymbol().format({
              name: i,
              type: Yr(o, {
                expandTypeAlias: true
              })
            }));
            kt(t, g.LocMessage.typePartiallyUnknown().format({
              name: i
            }) + e.getString(), r);
          }
        }
      }
      function Vn(e) {
        var t;
        let n = false;
        if (e.nodeType === 12) {
          const a = qe(e.d.iterableExpr);
          if (a.isIncomplete) {
            n = true;
          }
          const r = (t = st({
            type: $e(a.type),
            isIncomplete: a.isIncomplete
          }, !!e.d.isAsync, e.d.iterableExpr)) !== null && t !== undefined ? t : {
            type: H.UnknownType.create(),
            isIncomplete: a.isIncomplete
          };
          Nt(e.d.targetExpr, r, e.d.iterableExpr);
        } else {
          l.assert(e.nodeType === 13);
          qe(e.d.testExpr);
        }
        return n;
      }
      function Rn(e, t, n, a) {
        let r = false;
        let s = false;
        for (const t of e.d.forIfNodes) {
          if (Vn(t)) {
            r = true;
          }
        }
        let i = H.UnknownType.create();
        if (e.d.expr.nodeType === 20) {
          const o = qe(e.d.expr.d.keyExpr, t, Z.makeInferenceContext(a));
          if (o.isIncomplete) {
            r = true;
          }
          if (o.typeErrors) {
            s = true;
          }
          let l = o.type;
          if (!a || !Z.containsLiteralType(a)) {
            l = $e(l);
          }
          const p = qe(e.d.expr.d.valueExpr, t, Z.makeInferenceContext(n));
          if (p.isIncomplete) {
            r = true;
          }
          if (p.typeErrors) {
            s = true;
          }
          let d = p.type;
          if (!n || !Z.containsLiteralType(n)) {
            d = $e(d);
          }
          i = q.makeTupleObject(es, [{
            type: l,
            isUnbounded: false
          }, {
            type: d,
            isUnbounded: false
          }]);
        } else {
          if (e.d.expr.nodeType === 19) {
            qe(e.d.expr.d.expr, t, Z.makeInferenceContext(n));
          } else {
            if (h.isExpressionNode(e)) {
              const a = qe(e.d.expr, t, Z.makeInferenceContext(n));
              if (a.isIncomplete) {
                r = true;
              }
              if (a.typeErrors) {
                s = true;
              }
              i = a.type;
            }
          }
        }
        return {
          type: i,
          isIncomplete: r,
          typeErrors: s
        };
      }
      function Ln(e, t) {
        if (e.typeList) {
          if (!(t == null ? undefined : t.allowTypeArgList)) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgListNotAllowed(), e.node);
            return false;
          }
          e.typeList.forEach(e => {
            Ln(e);
          });
        }
        if (Z.isEllipsisType(e.type) && !(t == null ? undefined : t.allowTypeArgList)) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisContext(), e.node);
          return false;
        }
        if (H.isModule(e.type)) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.moduleAsType(), e.node);
          return false;
        }
        if (H.isParamSpec(e.type) && !(t == null ? undefined : t.allowParamSpec)) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.paramSpecContext(), e.node);
          return false;
        }
        if (H.isTypeVarTuple(e.type) && !e.type.priv.isInUnion) {
          if (!(t == null ? undefined : t.allowTypeVarTuple)) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeVarTupleContext(), e.node);
            return false;
          }
          Gt(e.type, e.node);
        }
        if (!(t == null ? undefined : t.allowEmptyTuple) && e.isEmptyTupleShorthand) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.zeroLengthTupleNotAllowed(), e.node);
          return false;
        } else {
          return !H.isUnpackedClass(e.type) || !!(t == null ? undefined : t.allowUnpackedTuples) || (kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackedArgInTypeArgument(), e.node), false);
        }
      }
      function Bn(e, t, n) {
        let a;
        let r = H.FunctionType.createInstantiable(0);
        let s = true;
        H.TypeBase.setSpecialForm(r, H.ClassType.cloneAsInstance(e));
        r.shared.declaredReturnType = H.UnknownType.create();
        r.shared.typeVarScopeId = M.getScopeIdForNode(n);
        if (t && t.length > 0) {
          r.priv.isCallableWithTypeArgs = true;
          if (t[0].typeList) {
            const e = t[0].typeList;
            let n = false;
            let a = false;
            const i = e => {
              if (n) {
                if (!a) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.variadicTypeArgsTooMany(), e.node);
                  a = true;
                  s = false;
                }
              }
              n = true;
            };
            e.forEach((e, t) => {
              var n;
              let a = e.type;
              let s = 0;
              const o = `__p${t.toString()}`;
              if (H.isTypeVarTuple(a)) {
                Gt(a, e.node);
                s = 1;
                i(e);
              } else {
                if (Ln(e, {
                  allowUnpackedTuples: true
                })) {
                  if (H.isUnpackedClass(a)) {
                    s = 1;
                    if ((n = a.priv.tupleTypeArgs) === null || n === undefined ? undefined : n.some(e => H.isTypeVarTuple(e.type) || e.isUnbounded)) {
                      i(e);
                    }
                  }
                } else {
                  a = H.UnknownType.create();
                }
              }
              H.FunctionType.addParam(r, H.FunctionParam.create(s, Z.convertToInstance(a), H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, o));
            });
            if (e.length > 0) {
              H.FunctionType.addPositionOnlyParamSeparator(r);
            }
          } else {
            if (Z.isEllipsisType(t[0].type)) {
              H.FunctionType.addDefaultParams(r);
              r.shared.flags |= 32768;
            } else {
              if (H.isParamSpec(t[0].type)) {
                a = t[0].type;
              } else {
                if (H.isInstantiableClass(t[0].type) && H.ClassType.isBuiltIn(t[0].type, 'Concatenate')) {
                  const e = t[0].type.priv.typeArgs;
                  if (e && e.length > 0) {
                    e.forEach((t, n) => {
                      if (n === e.length - 1) {
                        H.FunctionType.addPositionOnlyParamSeparator(r);
                        if (H.isParamSpec(t)) {
                          a = t;
                        } else {
                          if (Z.isEllipsisType(t)) {
                            H.FunctionType.addDefaultParams(r);
                            r.shared.flags |= 32768;
                          }
                        }
                      } else {
                        H.FunctionType.addParam(r, H.FunctionParam.create(0, t, H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${n}`));
                      }
                    });
                  }
                } else {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.callableFirstArg(), t[0].node);
                  s = false;
                }
              }
            }
          }
          if (t.length > 1) {
            let e = t[1].type;
            if (!Ln(t[1])) {
              e = H.UnknownType.create();
            }
            r.shared.declaredReturnType = Z.convertToInstance(e);
          } else {
            kt(d.DiagnosticRule.reportMissingTypeArgument, g.LocMessage.callableSecondArg(), n);
            r.shared.declaredReturnType = H.UnknownType.create();
            s = false;
          }
          if (t.length > 2) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.callableExtraArgs(), t[2].node);
            s = false;
          }
        } else {
          H.FunctionType.addDefaultParams(r, true);
          r.shared.flags |= 32768;
          if (t && t.length === 0) {
            s = false;
          }
        }
        if (a) {
          H.FunctionType.addParamSpecVariadics(r, Z.convertToInstance(a));
        }
        if (Zr(n) && s) {
          r = H.TypeBase.cloneWithTypeForm(r, Z.convertToInstance(r));
        }
        return r;
      }
      function jn(e, t, n, a) {
        var r;
        var s;
        var i;
        if (!n) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.optionalExtraArgs(), t);
            return H.UnknownType.create();
          } else {
            return e;
          }
        }
        if (n.length !== 1) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.optionalExtraArgs(), t);
          return H.UnknownType.create();
        }
        let o = n[0].type;
        if (!Ln(n[0])) {
          o = H.UnknownType.create();
        }
        let l = H.combineTypes([o, (r = Ae == null ? undefined : Ae.noneTypeClass) !== null && r !== undefined ? r : H.UnknownType.create()]);
        if ((Ae == null ? undefined : Ae.unionTypeClass) && H.isInstantiableClass(Ae.unionTypeClass)) {
          l = H.TypeBase.cloneAsSpecialForm(l, H.ClassType.cloneAsInstance(Ae.unionTypeClass));
        }
        if ((s = o.props) === null || s === undefined ? undefined : s.typeForm) {
          const e = H.combineTypes([o.props.typeForm, Z.convertToInstance((i = Ae == null ? undefined : Ae.noneTypeClass) !== null && i !== undefined ? i : H.UnknownType.create())]);
          l = H.TypeBase.cloneWithTypeForm(l, e);
        }
        return l;
      }
      function qn(e, t, n) {
        const a = Ya(e, t);
        if (H.isClassInstance(a)) {
          return H.ClassType.cloneWithLiteral(H.ClassType.cloneRemoveTypePromotions(a), n);
        } else {
          return H.UnknownType.create();
        }
      }
      function Gn(e, t, n, a) {
        const r = Za(e, n);
        if (H.isInstantiableClass(r)) {
          const e = H.ClassType.cloneWithLiteral(r, a);
          H.TypeBase.setSpecialForm(e, t);
          return e;
        }
        return H.UnknownType.create();
      }
      function Wn(e, t, n, a) {
        var r;
        if (a & 131072) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.classVarNotAllowed(), t);
          return H.AnyType.create();
        }
        if (!n) {
          return e;
        }
        if (n.length === 0) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.classVarFirstArgMissing(), t);
          return H.UnknownType.create();
        }
        if (n.length > 1) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.classVarTooManyArgs(), n[1].node);
          return H.UnknownType.create();
        }
        const s = n[0].type;
        if (Z.requiresSpecialization(s, {
          ignorePseudoGeneric: true,
          ignoreSelf: true
        })) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.classVarWithTypeVar(), (r = n[0].node) !== null && r !== undefined ? r : t);
        }
        return s;
      }
      function Kn(e, t, n) {
        if (!n || n.length === 0) {
          return H.ClassType.specialize(e, [H.UnknownType.create()]);
        }
        if (n.length > 1) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsTooMany().format({
            name: e.priv.aliasName || e.shared.name,
            expected: 1,
            received: n.length
          }), n[1].node);
          return H.UnknownType.create();
        }
        const a = n.map(e => Z.convertToInstance(Ln(e) ? e.type : H.UnknownType.create()));
        let r = H.ClassType.specialize(e, a);
        if (Zr(t)) {
          r = H.TypeBase.cloneWithTypeForm(r, Z.convertToInstance(r));
        }
        return r;
      }
      function $n(e, t, n, a) {
        if (!n) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeGuardArgCount(), t);
          }
          return e;
        }
        if (n.length !== 1) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeGuardArgCount(), t);
          return H.UnknownType.create();
        }
        const r = n.map(e => Z.convertToInstance(Ln(e) ? e.type : H.UnknownType.create()));
        let s = H.ClassType.specialize(e, r);
        if (Zr(t)) {
          s = H.TypeBase.cloneWithTypeForm(s, Z.convertToInstance(s));
        }
        return s;
      }
      function Hn(e, t, n, a) {
        var r;
        if (n) {
          kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsExpectingNone().format({
            name: e.shared.name
          }), (r = n[0].node) !== null && r !== undefined ? r : t);
        }
        let s = M.getEnclosingClass(t);
        if (s && !M.isNodeContainedWithin(t, s.d.suite)) {
          s = undefined;
        }
        const i = s ? ca(s) : undefined;
        if (!i) {
          if (a & 384) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.selfTypeContext(), t);
          }
          return H.UnknownType.create();
        }
        if (Z.isInstantiableMetaclass(i.classType)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.selfTypeMetaclass(), t);
          return H.UnknownType.create();
        }
        const o = M.getEnclosingFunction(t);
        if (o) {
          const e = x.getFunctionInfoFromDecorators(es, o, true);
          if (!M.getEnclosingFunction(o)) {
            if (e.flags & 4) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.selfTypeContext(), t);
              return H.UnknownType.create();
            }
            if (o.d.params.length > 0) {
              const e = M.getTypeAnnotationForParam(o, 0);
              if (e && !M.isNodeContainedWithin(t, e)) {
                const n = Ze(e, {
                  typeVarGetsCurScope: true
                });
                if (!H.isTypeVar(n) || !H.TypeVarType.isSelf(n)) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.selfTypeWithTypedSelfOrCls(), t);
                }
              }
            }
          }
        }
        let l = Z.synthesizeTypeVarForSelfCls(i.classType, true);
        if (s) {
          const e = M.getEnclosingClassOrFunctionSuite(t);
          if (e && M.isNodeContainedWithin(e, s) && s.d.suite !== e) {
            l = H.TypeVarType.cloneAsBound(l);
          }
        }
        return l;
      }
      function Zn(e, t, n, a) {
        if (!n && !(a & 256)) {
          return {
            type: e
          };
        }
        if (!n || n.length !== 1) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, e.shared.name === 'ReadOnly' ? g.LocMessage.readOnlyArgCount() : e.shared.name === 'Required' ? g.LocMessage.requiredArgCount() : g.LocMessage.notRequiredArgCount(), t);
          }
          return {
            type: e
          };
        }
        const r = n[0].type;
        const s = M.getEnclosingClass(t, true);
        const i = s ? ca(s) : undefined;
        let o = false;
        if (i && H.isInstantiableClass(i.classType) && H.ClassType.isTypedDictClass(i.classType) && M.isNodeContainedWithinNodeType(t, 54)) {
          o = true;
        }
        let l = n[0].isReadOnly;
        let p = n[0].isRequired;
        let c = n[0].isNotRequired;
        if (e.shared.name === 'ReadOnly') {
          if (a & 2097152) {
            o = true;
          }
          if (n[0].isReadOnly) {
            o = false;
          }
          l = true;
        } else {
          if (a & 1048576) {
            o = true;
          }
          if (n[0].isRequired || n[0].isNotRequired) {
            o = false;
          }
          p = e.shared.name === 'Required';
          c = e.shared.name === 'NotRequired';
        }
        if (o) {
          return {
            type: r,
            isReadOnly: l,
            isRequired: p,
            isNotRequired: c
          };
        } else {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, e.shared.name === 'ReadOnly' ? g.LocMessage.readOnlyNotInTypedDict() : e.shared.name === 'Required' ? g.LocMessage.requiredNotInTypedDict() : g.LocMessage.notRequiredNotInTypedDict(), t);
          }
          return {
            type: e
          };
        }
      }
      function Yn(e, t, n, a) {
        if (!n || n.length !== 1) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackArgCount(), t);
          }
          return e;
        }
        const r = n[0].type;
        if (a & 4194304) {
          const n = Xt(r);
          return n || (a & 256 ? (kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.unpackExpectedTypeVarTuple(), t), H.UnknownType.create()) : e);
        }
        if (a & 8388608) {
          if (H.isInstantiableClass(r) && H.ClassType.isTypedDictClass(r)) {
            return H.ClassType.cloneForUnpacked(r);
          } else {
            if (a & 256) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.unpackExpectedTypedDict(), t);
              return H.UnknownType.create();
            } else {
              return e;
            }
          }
        } else {
          if (a & 256) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.unpackNotAllowed(), t);
            return H.UnknownType.create();
          } else {
            return e;
          }
        }
      }
      function Jn(e, t, n, a) {
        if (a & 16) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.finalContext(), t);
          }
          return e;
        } else {
          if (a & 256 && n && n.length !== 0) {
            if (n.length > 1) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.finalTooManyArgs(), t);
            }
            return H.TypeBase.cloneAsSpecialForm(n[0].type, e);
          } else {
            return e;
          }
        }
      }
      function Qn(e, t, n, a) {
        if (a & 134217728) {
          if (n && n.length !== 0) {
            n.forEach((e, t) => {
              if (t === n.length - 1) {
                if (!H.isParamSpec(e.type) && !Z.isEllipsisType(e.type)) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.concatenateParamSpecMissing(), e.node);
                }
              } else {
                if (H.isParamSpec(e.type)) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.paramSpecContext(), e.node);
                } else {
                  if (H.isUnpackedTypeVarTuple(e.type)) {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeVarTupleContext(), e.node);
                  } else {
                    if (H.isUnpackedClass(e.type)) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackedArgInTypeArgument(), e.node);
                    }
                  }
                }
              }
            });
          } else {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.concatenateTypeArgsMissing(), t);
          }
          return ea(e, n, undefined, true);
        } else {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.concatenateContext(), t);
          }
          return e;
        }
      }
      function Xn(e, t, n, a) {
        var r;
        let s;
        if (a & 33554688) {
          if (n && n.length > 0) {
            s = n[0].type;
            if (n.length < 2) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.annotatedTypeArgMissing(), t);
            } else {
              s = function (e, t, n) {
                for (const e of n);
                return t;
              }(0, n[0].type, n.slice(1));
            }
          }
          return s && n && n.length !== 0 ? (n[0].typeList && kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgListNotAllowed(), n[0].node), {
            type: H.TypeBase.cloneAsSpecialForm(s, H.ClassType.cloneAsInstance(e)),
            isReadOnly: n[0].isReadOnly,
            isRequired: n[0].isRequired,
            isNotRequired: n[0].isNotRequired
          }) : {
            type: H.AnyType.create()
          };
        } else {
          s = H.ClassType.cloneAsInstance(e);
          if (n && n.length >= 1 && ((r = n[0].type.props) === null || r === undefined ? undefined : r.typeForm)) {
            s = H.TypeBase.cloneWithTypeForm(s, n[0].type.props.typeForm);
          }
          return {
            type: s
          };
        }
      }
      function ea(e, t, n, a = false, r = true) {
        const s = H.ClassType.isTupleClass(e);
        if (t) {
          if (s && t.length === 1 && t[0].isEmptyTupleShorthand) {
            t = [];
          } else {
            let e = false;
            const r = t => {
              if (e) {
                if (!i) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.variadicTypeArgsTooMany(), t.node);
                  i = true;
                }
              }
              e = true;
            };
            let i = false;
            t.forEach((e, i) => {
              var o;
              l.assert(t !== undefined);
              if (Z.isEllipsisType(e.type)) {
                if (s) {
                  if (t.length !== 2 || i !== 1) {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisSecondArg(), e.node);
                  } else {
                    if (H.isTypeVarTuple(t[0].type) && !t[0].type.priv.isInUnion) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeVarTupleContext(), t[0].node);
                    } else {
                      if (H.isUnpackedClass(t[0].type)) {
                        kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisAfterUnpacked(), e.node);
                      }
                    }
                  }
                } else {
                  if (!a) {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisContext(), e.node);
                  }
                }
              } else {
                if (!H.isParamSpec(e.type) || !a) {
                  if (n === undefined && H.isTypeVarTuple(e.type)) {
                    if (!e.type.priv.isInUnion) {
                      r(e);
                    }
                    Gt(e.type, e.node);
                  } else {
                    if (n === undefined && H.isUnpackedClass(e.type)) {
                      if ((o = e.type.priv.tupleTypeArgs) === null || o === undefined ? undefined : o.some(e => H.isTypeVarTuple(e.type) || e.isUnbounded)) {
                        r(e);
                      }
                      Ln(e, {
                        allowUnpackedTuples: true
                      });
                    } else {
                      Ln(e);
                    }
                  }
                }
              }
            });
          }
        }
        let i;
        let p = t ? t.map(e => Z.convertToInstance(e.type)) : [];
        if (n !== undefined) {
          if (t && p.length > n) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsTooMany().format({
              name: e.priv.aliasName || e.shared.name,
              expected: n,
              received: p.length
            }), t[n].node);
            p = p.slice(0, n);
          } else {
            if (p.length < n) {
              while (p.length < n) {
                p.push(H.UnknownType.create());
              }
            }
          }
        }
        if (s) {
          const n = [];
          if (t) {
            t.forEach((e, t) => {
              if (t === 1 && Z.isEllipsisType(p[t])) {
                if (n.length === 1 && !n[0].isUnbounded) {
                  n[0] = {
                    type: n[0].type,
                    isUnbounded: true
                  };
                }
              } else {
                if (H.isUnpackedClass(e.type) && e.type.priv.tupleTypeArgs) {
                  o.appendArray(n, e.type.priv.tupleTypeArgs);
                } else {
                  n.push({
                    type: p[t],
                    isUnbounded: false
                  });
                }
              }
            });
          } else {
            n.push({
              type: H.UnknownType.create(),
              isUnbounded: true
            });
          }
          i = Z.specializeTupleClass(e, n, t !== undefined);
        } else {
          i = H.ClassType.specialize(e, p, t !== undefined);
        }
        if (r) {
          i = H.TypeBase.cloneAsSpecialForm(i, e);
        }
        return i;
      }
      function ta(e, t, n, a) {
        var r;
        const s = v.getFileInfo(t);
        const i = [];
        let o = false;
        let l = true;
        if (!n) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unionTypeArgCount(), t);
            return H.NeverType.createNever();
          } else {
            return e;
          }
        }
        for (const e of n) {
          let n = e.type;
          if (!Ln(e, {
            allowTypeVarTuple: s.diagnosticRuleSet.enableExperimentalFeatures
          })) {
            n = H.UnknownType.create();
          }
          if (H.isTypeVar(n) && H.isUnpackedTypeVarTuple(n)) {
            if (s.diagnosticRuleSet.enableExperimentalFeatures) {
              n = H.TypeVarType.cloneForUnpacked(n, true);
              o = true;
            } else {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.unionUnpackedTypeVarTuple(), t);
              n = H.UnknownType.create();
              l = false;
            }
          }
          i.push(n);
        }
        if (i.length === 1 && !o && !Z.isNoneInstance(i[0])) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.unionTypeArgCount(), t);
          }
          l = false;
        }
        let p = H.combineTypes(i, {
          skipElideRedundantLiterals: true
        });
        if ((Ae == null ? undefined : Ae.unionTypeClass) && H.isInstantiableClass(Ae.unionTypeClass)) {
          p = H.TypeBase.cloneAsSpecialForm(p, H.ClassType.cloneAsInstance(Ae.unionTypeClass));
        }
        if (!l || i.some(e => {
          var t;
          return !((t = e.props) === null || t === undefined ? undefined : t.typeForm);
        })) {
          if ((r = p.props) === null || r === undefined ? undefined : r.typeForm) {
            p = H.TypeBase.cloneWithTypeForm(p, undefined);
          }
        } else {
          if (Zr(t)) {
            const e = H.combineTypes(i.map(e => e.props.typeForm));
            p = H.TypeBase.cloneWithTypeForm(p, e);
          }
        }
        return p;
      }
      function na(e, t, n, a) {
        if (!n) {
          if (a & 262400) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.genericTypeArgMissing(), t);
          }
          return e;
        }
        const r = [];
        if (n) {
          if (n.length === 0) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.genericTypeArgMissing(), t);
          }
          n.forEach(e => {
            if (H.isTypeVar(e.type)) {
              if (r.some(t => H.isTypeSame(t, e.type))) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.genericTypeArgUnique(), e.node);
              }
              r.push(e.type);
            } else {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.genericTypeArgTypeVar(), e.node);
            }
          });
        }
        return ea(e, n, undefined, true);
      }
      function aa(e, t, n, a, r) {
        var s;
        if (Z.isTypeAliasPlaceholder(e)) {
          return e;
        }
        const i = n.shared.recursiveAlias;
        l.assert(i !== undefined);
        let o = i.typeParams;
        if (!o) {
          o = [];
          Z.addTypeVarsToListIfUnique(o, Z.getTypeVarArgsRecursive(e));
          o = o.filter(e => !e.shared.isSynthesized);
        }
        o = o.map(e => H.TypeBase.isInstance(e) ? e : Z.convertToInstance(e));
        const p = o.findIndex(e => H.isTypeVarTuple(e));
        if (p >= 0) {
          const e = o.findIndex((e, t) => t > p && !H.isParamSpec(e) && e.shared.isDefaultExplicit);
          if (e >= 0) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarWithDefaultFollowsVariadic().format({
              typeVarName: o[e].shared.name,
              variadicName: o[p].shared.name
            }), r ? r[e].d.name : t);
          }
        }
        o.forEach((e, n) => {
          var a;
          l.assert(o !== undefined);
          let s = t;
          if (r && n < r.length) {
            s = (a = r[n].d.defaultExpr) !== null && a !== undefined ? a : r[n].d.name;
          }
          ma(s, e, o.slice(0, n), i.typeVarScopeId);
        });
        const c = o.filter(e => H.isTypeVarTuple(e));
        if (c.length > 1) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.variadicTypeParamTooManyAlias().format({
            names: c.map(e => `"${e.shared.name}"`).join(', ')
          }), t);
        }
        if (!i.isPep695Syntax && !a) {
          const e = o.filter(e => e.priv.scopeId !== i.typeVarScopeId && e.priv.scopeType === 0);
          if (e.length > 0) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.genericTypeAliasBoundTypeVar().format({
              names: e.map(e => `${e.shared.name}`).join(', ')
            }), t);
          }
        }
        if (!H.TypeBase.isInstantiable(e)) {
          return e;
        }
        i.typeParams = o.length > 0 ? o : undefined;
        let u = H.TypeBase.cloneForTypeAlias(e, {
          shared: i,
          typeArgs: undefined
        });
        if (i.isPep695Syntax || a) {
          const e = ct(t, 'TypeAliasType');
          if (e && H.isInstantiableClass(e)) {
            u = H.TypeBase.cloneAsSpecialForm(u, H.ClassType.cloneAsInstance(e));
          }
        }
        if ((s = u.props) === null || s === undefined ? undefined : s.typeForm) {
          u = H.TypeBase.cloneWithTypeForm(u, undefined);
        }
        return u;
      }
      function ra(e, t, n) {
        var a;
        const r = v.getFileInfo(e);
        let s = H.ClassType.createInstantiable(t, M.getClassFullName(e, r.moduleName, t), r.moduleName, r.fileUri, 3, 0, undefined, undefined);
        if (n.isSpecialForm) {
          s.shared.flags |= 8388608;
        }
        if (n.isIllegalInIsinstance) {
          s.shared.flags |= 16777216;
        }
        if (n.typeParamVariance !== undefined) {
          let a = H.TypeVarType.createInstance('T');
          a = H.TypeVarType.cloneForScopeId(a, M.getScopeIdForNode(e), t, 0);
          a.shared.declaredVariance = n.typeParamVariance;
          s.shared.typeParams.push(a);
        }
        const i = (a = v.getDeclaration(e)) !== null && a !== undefined ? a : e.parent ? v.getDeclaration(e.parent) : undefined;
        s.shared.declaration = i;
        if (r.isTypingExtensionsStubFile) {
          s.shared.flags |= 4096;
        }
        const o = n.implicitBaseClass || n.alias || 'object';
        let l;
        if (n.module === 'builtins') {
          l = Za(e, o);
        } else {
          if (n.module === 'collections') {
            l = mt(e, o, ['collections']);
          } else {
            if (n.module === 'self') {
              const t = Ja(e, o, false);
              if (t) {
                l = cr(t.symbol);
                if (H.isInstantiableClass(l) && H.ClassType.isBuiltIn(l, '_TypedDict')) {
                  l = H.ClassType.cloneWithNewFlags(l, l.shared.flags & -1048641);
                }
              }
            }
          }
        }
        if (l && H.isInstantiableClass(l)) {
          if (n.alias) {
            s = H.ClassType.cloneForTypingAlias(l, t);
          } else {
            s.shared.baseClasses.push(l);
            s.shared.effectiveMetaclass = l.shared.effectiveMetaclass;
            Z.computeMroLinearization(s);
          }
        } else {
          s.shared.baseClasses.push(H.UnknownType.create());
          s.shared.effectiveMetaclass = H.UnknownType.create();
          Z.computeMroLinearization(s);
        }
        return s;
      }
      function sa(e) {
        var t;
        var n;
        const a = v.getFileInfo(e);
        if (De(e)) {
          return;
        }
        let r = 0;
        if (a.isStubFile) {
          r |= 1;
        }
        if (e.d.rightExpr.nodeType === 38 || e.d.rightExpr.nodeType === 35) {
          r |= 2;
        }
        let s;
        let i = Ne(e.d.rightExpr, undefined);
        let o = false;
        if (!i) {
          if (a.isTypingStubFile || a.isTypingExtensionsStubFile) {
            i = function (e) {
              if (e.d.leftExpr.nodeType !== 38) {
                return;
              }
              const t = e.d.leftExpr.d.value;
              if (t === 'Any') {
                return H.AnyType.createSpecialForm();
              }
              const n = new Map([['overload', {
                alias: '',
                module: 'builtins'
              }], ['TypeVar', {
                alias: '',
                module: 'builtins'
              }], ['_promote', {
                alias: '',
                module: 'builtins'
              }], ['no_type_check', {
                alias: '',
                module: 'builtins'
              }], ['NoReturn', {
                alias: '',
                module: 'builtins'
              }], ['Never', {
                alias: '',
                module: 'builtins'
              }], ['Counter', {
                alias: 'Counter',
                module: 'collections'
              }], ['List', {
                alias: 'list',
                module: 'builtins'
              }], ['Dict', {
                alias: 'dict',
                module: 'builtins'
              }], ['DefaultDict', {
                alias: 'defaultdict',
                module: 'collections'
              }], ['Set', {
                alias: 'set',
                module: 'builtins'
              }], ['FrozenSet', {
                alias: 'frozenset',
                module: 'builtins'
              }], ['Deque', {
                alias: 'deque',
                module: 'collections'
              }], ['ChainMap', {
                alias: 'ChainMap',
                module: 'collections'
              }], ['OrderedDict', {
                alias: 'OrderedDict',
                module: 'collections'
              }]]).get(t);
              if (n) {
                qe(e.d.rightExpr);
                return ra(e, t, n);
              } else {
                return undefined;
              }
            }(e);
            if (i) {
              Fe(e.d.rightExpr, {
                type: i
              }, 0);
            }
          }
        }
        if (!i) {
          let p;
          let c;
          let u = false;
          if (function (e) {
            if (e.nodeType === 54 && e.d.valueExpr.nodeType === 38) {
              const t = Ja(e, e.d.valueExpr.d.value, false);
              if (t) {
                return t.symbol.getDeclarations().find(e => Br(e)) !== undefined;
              }
            }
            return false;
          }(e.d.leftExpr)) {
            r = 131560;
            p = e.d.leftExpr.d.valueExpr;
            if (!qr(e.d.rightExpr, true)) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeAliasIllegalExpressionForm(), e.d.rightExpr);
            }
          } else {
            if (e.d.leftExpr.nodeType === 38) {
              const t = Ja(e.d.leftExpr, e.d.leftExpr.d.value, false);
              if (t) {
                const n = t.symbol.getDeclarations();
                if (n.length === 1) {
                  if (jr(n[0])) {
                    p = e.d.leftExpr;
                    u = true;
                    r |= 33554432;
                  } else {
                    if (Kr(n[0])) {
                      p = e.d.leftExpr;
                    }
                  }
                }
              }
            }
          }
          if (p) {
            c = ia(p, false);
            Fe(e, {
              type: c
            }, undefined);
            Fe(e.d.leftExpr, {
              type: c
            }, undefined);
            if (e.d.leftExpr.nodeType === 54) {
              Fe(e.d.leftExpr.d.valueExpr, {
                type: c
              }, undefined);
            }
          }
          let m = at(e.d.leftExpr, {
            method: 'set'
          });
          if (m) {
            const t = M.getTypeVarScopesForNode(e);
            m = Z.makeTypeVarsBound(m, t);
          }
          const y = qe(e.d.rightExpr, r, Z.makeInferenceContext(m));
          i = y.type;
          s = y.expectedTypeDiagAddendum;
          if (y.isIncomplete) {
            o = true;
          }
          if (u && !Gr(i)) {
            p = undefined;
          }
          if (p) {
            l.assert(c !== undefined);
            i = aa(i, p, c, false);
            if (Z.isTypeAliasRecursive(c, i)) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasIsRecursiveDirect().format({
                name: p.d.value
              }), e.d.rightExpr);
              i = H.UnknownType.create();
            }
            c.shared.boundType = i;
            c.shared.recursiveAlias.typeParams = (n = (t = i.props) === null || t === undefined ? undefined : t.typeAliasInfo) === null || n === undefined ? undefined : n.shared.typeParams;
          } else {
            const t = R.evaluateStaticBoolExpression(e.d.rightExpr, a.executionEnvironment, a.definedConstants);
            if (t !== undefined) {
              const n = Ya(e, 'bool');
              if (H.isClassInstance(n)) {
                i = H.ClassType.cloneWithLiteral(n, t);
              }
            }
          }
        }
        Nt(e.d.leftExpr, {
          type: i,
          isIncomplete: o
        }, e.d.rightExpr, true, true, s);
        Fe(e, {
          type: i,
          isIncomplete: o
        }, 0);
      }
      function ia(e, t) {
        const n = H.TypeVarType.createInstantiable(`__type_alias_${e.d.value}`);
        n.shared.isSynthesized = true;
        const a = M.getScopeIdForNode(e);
        const r = v.getFileInfo(e);
        n.shared.recursiveAlias = {
          name: e.d.value,
          fullName: M.getClassFullName(e, r.moduleName, e.d.value),
          moduleName: r.moduleName,
          fileUri: r.fileUri,
          typeVarScopeId: a,
          isPep695Syntax: t,
          typeParams: undefined,
          computedVariance: undefined
        };
        n.priv.scopeId = a;
        return n;
      }
      function oa(e) {
        var t;
        return la(e, e.d.name, e.d.expr, true, (t = e.d.typeParams) === null || t === undefined ? undefined : t.d.params, () => {
          if (e.d.typeParams) {
            return ga(e.d.typeParams);
          }
        });
      }
      function la(e, t, n, a, r, s) {
        const i = Ne(t, 0);
        if (i) {
          return i;
        }
        const o = ia(t, a);
        Fe(t, {
          type: o
        }, undefined);
        const l = V.getScopeForNode(e);
        const p = l == null ? undefined : l.lookUpSymbolRecursive(t.d.value);
        const c = v.getDeclaration(e);
        if (c && p) {
          Ve(p.symbol, c, o);
        }
        const u = s();
        if (o.shared.recursiveAlias) {
          o.shared.recursiveAlias.typeParams = u ?? [];
        }
        const m = Ha(n, {
          forwardRefs: true,
          typeExpression: true
        });
        let y = false;
        let h = m.type;
        if (m.isIncomplete) {
          y = true;
        }
        h = aa(h, t, o, true, r);
        if (Z.isTypeAliasRecursive(o, h)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasIsRecursiveDirect().format({
            name: t.d.value
          }), n);
          h = H.UnknownType.create();
        }
        o.shared.boundType = h;
        Fe(t, {
          type: h,
          isIncomplete: y
        }, 0);
        return h;
      }
      function pa(e) {
        if (De(e)) {
          return;
        }
        Fe(e, F.getTypeOfAugmentedAssignment(es, e, undefined), 0);
      }
      function da(e) {
        return `__type_of_${e}`;
      }
      function ca(e) {
        je(e);
        const t = Ne(e.d.name, 0);
        if (t) {
          if (!H.isInstantiableClass(t)) {
            return;
          }
          return {
            classType: t,
            decoratedType: Ne(e, 0) || H.UnknownType.create()
          };
        }
        const n = V.getScopeForNode(e);
        const a = v.getFileInfo(e);
        let r = 0;
        if ((n == null ? undefined : n.type) === 5 || a.isTypingStubFile || a.isTypingExtensionsStubFile || a.isBuiltInStubFile || a.isTypeshedStubFile) {
          r |= 1;
          if (a.isTypingExtensionsStubFile) {
            r |= 4096;
          }
          if (e.d.name.d.value === 'property') {
            r |= 128;
          }
          if (e.d.name.d.value === 'tuple') {
            r |= 32768;
          }
        }
        if (a.isStubFile) {
          r |= 262144;
        }
        const s = H.ClassType.createInstantiable(e.d.name.d.value, M.getClassFullName(e, a.moduleName, e.d.name.d.value), a.moduleName, a.fileUri, r, 0, undefined, undefined, M.getDocString(e.d.suite.d.statements));
        s.shared.typeVarScopeId = M.getScopeIdForNode(e);
        if (J.has(s.shared.fullName)) {
          s.priv.includePromotions = true;
        }
        const c = n == null ? undefined : n.lookUpSymbol(e.d.name.d.value);
        let y;
        const h = v.getDeclaration(e);
        if (h) {
          y = h;
        }
        if (y && c) {
          Ve(c, y, s);
        }
        s.shared.flags |= 8192;
        s.shared.declaration = y;
        return i.invalidateTypeCacheIfCanceled(() => {
          Fe(e, {
            type: s
          }, undefined);
          Fe(e.d.name, {
            type: s
          }, undefined);
          let n;
          let r;
          let i = [];
          if (e.d.typeParams) {
            i = ga(e.d.typeParams).map(e => H.TypeVarType.cloneAsInstance(e));
          }
          let c = false;
          const y = [];
          let h;
          let f = 289920;
          if (a.isStubFile) {
            f |= 4;
          }
          e.d.arguments.forEach(t => {
            var o;
            var p;
            var m;
            if (t.d.argCategory !== 2) {
              if (t.d.name) {
                if (H.ClassType.isTypedDictClass(s)) {
                  if (t.d.name.d.value === 'total' || t.d.name.d.value === 'closed') {
                    const n = R.evaluateStaticBoolExpression(t.d.valueExpr, a.executionEnvironment, a.definedConstants);
                    if (n === undefined) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictBoolParam().format({
                        name: t.d.name.d.value
                      }), t.d.valueExpr);
                    } else {
                      if (t.d.name.d.value !== 'total' || n) {
                        if (t.d.name.d.value === 'closed' && n && v.getFileInfo(e).diagnosticRuleSet.enableExperimentalFeatures) {
                          s.shared.flags |= 24;
                          if (s.shared.typedDictExtraItemsExpr) {
                            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictExtraItemsClosed(), s.shared.typedDictExtraItemsExpr);
                          }
                        }
                      } else {
                        s.shared.flags |= 32;
                      }
                    }
                  } else {
                    if (t.d.name.d.value === 'extra_items') {
                      if (v.getFileInfo(e).diagnosticRuleSet.enableExperimentalFeatures) {
                        s.shared.typedDictExtraItemsExpr = t.d.valueExpr;
                        s.shared.flags |= 16;
                        if (H.ClassType.isTypedDictMarkedClosed(s)) {
                          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictExtraItemsClosed(), s.shared.typedDictExtraItemsExpr);
                        }
                      }
                    } else {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictInitsubclassParameter().format({
                        name: t.d.name.d.value
                      }), t);
                    }
                  }
                } else {
                  if (t.d.name.d.value === 'metaclass') {
                    if (h) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.metaclassDuplicate(), t);
                    } else {
                      h = t.d.valueExpr;
                    }
                  } else {
                    y.push({
                      argCategory: 0,
                      node: t,
                      name: t.d.name,
                      valueExpression: t.d.valueExpr
                    });
                  }
                }
              } else {
                let y;
                if (t.d.argCategory === 1) {
                  qe(t.d.valueExpr);
                  y = H.UnknownType.create();
                } else {
                  y = qe(t.d.valueExpr, f).type;
                  if (H.isTypeVar(y) && ((o = y.props) === null || o === undefined ? undefined : o.specialForm) && H.TypeBase.isInstance(y.props.specialForm)) {
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.baseClassInvalid(), t);
                    y = H.UnknownType.create();
                  }
                  y = Pt(y);
                }
                if (H.isUnion(y)) {
                  y = H.removeUnbound(y);
                }
                if (H.isAny(y) && ((p = y.props) === null || p === undefined ? undefined : p.specialForm)) {
                  y = H.AnyType.create();
                }
                y = Z.stripTypeFormRecursive(y);
                if (!H.isAnyOrUnknown(y) && !H.isUnbound(y)) {
                  if (H.isClass(y) && H.TypeBase.getInstantiableDepth(y) > 0 && y.shared.effectiveMetaclass && H.isClass(y.shared.effectiveMetaclass)) {
                    y = y.shared.effectiveMetaclass;
                  }
                  if (Z.isMetaclassInstance(y)) {
                    l.assert(H.isClassInstance(y));
                    y = y.priv.typeArgs && y.priv.typeArgs.length > 0 ? y.priv.typeArgs[0] : H.UnknownType.create();
                  } else {
                    if (H.isInstantiableClass(y)) {
                      if (H.ClassType.isPartiallyEvaluated(y) || y.shared.mro.some(e => H.isClass(e) && H.ClassType.isPartiallyEvaluated(e))) {
                        fa(e, y);
                      }
                      if (H.ClassType.isBuiltIn(y, 'Protocol')) {
                        if (!a.isStubFile && !H.ClassType.isTypingExtensionClass(y) && !!u.PythonVersion.isLessThan(a.executionEnvironment.pythonVersion, u.pythonVersion3_7)) {
                          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.protocolIllegal(), t.d.valueExpr);
                        }
                        s.shared.flags |= 512;
                      }
                      if (H.ClassType.isBuiltIn(y, 'property')) {
                        s.shared.flags |= 128;
                      }
                      if (u.PythonVersion.isGreaterOrEqualTo(a.executionEnvironment.pythonVersion, u.pythonVersion3_6) && H.ClassType.isBuiltIn(y, 'NamedTuple')) {
                        c = true;
                      }
                      if (H.ClassType.isBuiltIn(y, 'TypedDict') || H.ClassType.isTypedDictClass(y)) {
                        s.shared.flags |= 4;
                        if (H.ClassType.isTypedDictEffectivelyClosed(y)) {
                          s.shared.flags |= 16;
                        }
                      }
                      if (Z.derivesFromClassRecursive(y, s, true)) {
                        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.baseClassCircular(), t);
                        y = H.UnknownType.create();
                      }
                      if (((m = y.props) === null || m === undefined ? undefined : m.specialForm) && H.ClassType.isBuiltIn(y.props.specialForm, 'TypeAliasType')) {
                        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeBaseClass(), t);
                        y = H.UnknownType.create();
                      }
                    } else {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.baseClassInvalid(), t);
                      y = H.UnknownType.create();
                    }
                  }
                }
                if (H.isUnknown(y)) {
                  kt(d.DiagnosticRule.reportUntypedBaseClass, g.LocMessage.baseClassUnknown(), t);
                }
                if (s.shared.baseClasses.some(e => H.isInstantiableClass(e) && H.isInstantiableClass(y) && H.ClassType.isSameGenericClass(y, e))) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.duplicateBaseClass(), t.d.name || t);
                }
                s.shared.baseClasses.push(y);
                if (H.isInstantiableClass(y) && (H.ClassType.isEnumClass(y) && (s.shared.flags |= 65536), (H.ClassType.supportsAbstractMethods(y) || H.ClassType.isProtocolClass(y) && !H.ClassType.isBuiltIn(y)) && (s.shared.flags |= 64), H.ClassType.isPropertyClass(y) && (s.shared.flags |= 128), H.ClassType.isFinal(y))) {
                  const e = $r(y);
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.baseClassFinal().format({
                    type: e
                  }), t.d.valueExpr);
                }
                Z.addTypeVarsToListIfUnique(i, Z.getTypeVarArgsRecursive(y));
                if (H.isInstantiableClass(y)) {
                  if (H.ClassType.isBuiltIn(y, 'Generic')) {
                    if (e.d.typeParams) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.genericBaseClassNotAllowed(), t.d.valueExpr);
                    } else {
                      if (!n) {
                        if (r) {
                          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.duplicateGenericAndProtocolBase(), t.d.valueExpr);
                        }
                        n = ua(y);
                      }
                    }
                  } else {
                    if (H.ClassType.isBuiltIn(y, 'Protocol') && y.priv.typeArgs && y.priv.typeArgs.length > 0) {
                      if (!r) {
                        if (n) {
                          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.duplicateGenericAndProtocolBase(), t.d.valueExpr);
                        }
                        r = ua(y);
                        if (e.d.typeParams && r.length > 0) {
                          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.protocolBaseClassWithTypeArgs(), t.d.valueExpr);
                          r = [];
                        }
                      }
                    }
                  }
                }
              }
            } else {
              qe(t.d.valueExpr);
            }
          });
          if (s.shared.baseClasses.length > 1) {
            let t = false;
            let n = false;
            s.shared.baseClasses.forEach(e => {
              if (H.isInstantiableClass(e)) {
                if (H.ClassType.isBuiltIn(e, 'NamedTuple')) {
                  t = true;
                } else {
                  if (!H.ClassType.isBuiltIn(e, 'Generic')) {
                    n = true;
                  }
                }
              }
            });
            if (t && n) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.namedTupleMultipleInheritance(), e.d.name);
            }
          }
          if (!H.ClassType.isBuiltIn(s, 'object') && s.shared.baseClasses.filter(e => H.isClass(e)).length === 0) {
            s.shared.baseClasses.push(Za(e, 'object'));
          }
          n = n ?? r;
          if (n && !e.d.typeParams) {
            (function (e, t, n) {
              const a = t.filter(e => !n.some(t => t.shared.name === e.shared.name));
              if (a.length > 0) {
                const t = new p.DiagnosticAddendum();
                t.addMessage(g.LocAddendum.typeVarsMissing().format({
                  names: a.map(e => `"${e.shared.name}"`).join(', ')
                }));
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarsNotInGenericOrProtocol() + t.getString(), e);
              }
            })(e.d.name, i, n);
          }
          s.shared.typeParams = n ?? i;
          if (s.shared.typeParams.some(e => e.shared.declaredVariance === 0 && e.priv.computedVariance === undefined)) {
            s.shared.requiresVarianceInference = true;
          }
          const T = i.filter(e => H.isTypeVarTuple(e));
          if (T.length > 1) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.variadicTypeParamTooManyClass().format({
              names: T.map(e => `"${e.shared.name}"`).join(', ')
            }), e.d.name, m.TextRange.combine(e.d.arguments) || e.d.name);
          } else {
            if (T.length > 0) {
              const t = s.shared.typeParams.findIndex(e => H.isTypeVarTuple(e));
              const n = s.shared.typeParams.findIndex((e, n) => n > t && !H.isParamSpec(e) && e.shared.isDefaultExplicit);
              if (n >= 0) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarWithDefaultFollowsVariadic().format({
                  typeVarName: i[n].shared.name,
                  variadicName: i[t].shared.name
                }), e.d.typeParams ? e.d.typeParams.d.params[n].d.name : e.d.name);
              }
            }
          }
          s.shared.typeParams.forEach((t, n) => {
            var a;
            let r = e.d.name;
            if (e.d.typeParams && n < e.d.typeParams.d.params.length) {
              const t = e.d.typeParams.d.params[n];
              r = (a = t.d.defaultExpr) !== null && a !== undefined ? a : t.d.name;
            }
            ma(r, t, s.shared.typeParams.slice(0, n), s.shared.typeVarScopeId);
          });
          if (!Z.computeMroLinearization(s)) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.methodOrdering(), e.d.name);
          }
          const b = V.getScopeForNode(e.d.suite);
          s.shared.fields = (b == null ? undefined : b.symbolTable) ? new Map(b.symbolTable) : new Map();
          if (s.shared.fields.has('__eq__') && !s.shared.fields.has('__hash__')) {
            s.shared.fields.set('__hash__', L.Symbol.createWithType(4292, pt()));
          }
          const _ = b == null ? undefined : b.getSlotsNames();
          if (_) {
            s.shared.localSlotsNames = _;
          }
          if (!a.isStubFile && s.shared.typeParams.length === 0) {
            const t = s.shared.fields.get('__init__');
            if (t) {
              const n = t.getTypedDeclarations();
              if (n.length === 1 && n[0].type === 5) {
                const t = n[0].node;
                const a = t.d.params;
                if (a.length > 1 && !a.some((e, n) => !!M.getTypeAnnotationForParam(t, n))) {
                  const n = a.filter((e, t) => t > 0 && e.d.name && e.d.category === 0 && !e.d.defaultValue);
                  if (n.length > 0) {
                    s.shared.flags |= 1024;
                    s.shared.typeParams = n.map(n => {
                      const a = H.TypeVarType.createInstance(da(n.d.name.d.value));
                      a.shared.isSynthesized = true;
                      a.priv.scopeId = M.getScopeIdForNode(t);
                      a.shared.boundType = H.UnknownType.create();
                      return H.TypeVarType.cloneForScopeId(a, M.getScopeIdForNode(e), e.d.name.d.value, 0);
                    });
                  }
                }
              }
            }
          }
          if (s.shared.typeParams.length === 0 && !H.ClassType.isBuiltIn(s, 'type')) {
            if (s.shared.baseClasses.some(e => H.isInstantiableClass(e) && H.ClassType.hasCustomClassGetItem(e)) || s.shared.fields.has('__class_getitem__')) {
              s.shared.flags |= 16384;
            }
          }
          if (h) {
            let e = qe(h, f).type;
            if (H.isInstantiableClass(e) || H.isUnknown(e)) {
              if (Z.requiresSpecialization(e, {
                ignorePseudoGeneric: true
              })) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.metaclassIsGeneric(), h);
              }
              if (H.TypeBase.getInstantiableDepth(e) > 0 && H.isClass(e) && e.shared.effectiveMetaclass && H.isClass(e.shared.effectiveMetaclass)) {
                e = e.shared.effectiveMetaclass;
              }
              s.shared.declaredMetaclass = e;
              if (H.isInstantiableClass(e)) {
                if (P.isEnumMetaclass(e)) {
                  s.shared.flags |= 65536;
                }
                if (Z.derivesFromStdlibClass(e, 'ABCMeta')) {
                  s.shared.flags |= 64;
                }
              }
            }
          }
          const C = ha(s, e.d.name);
          s.shared.flags &= -8193;
          let I;
          let k = s;
          let w = false;
          for (let n = e.d.decorators.length - 1; n >= 0; n--) {
            const a = e.d.decorators[n];
            const r = er(e.parent ?? e, () => x.applyClassDecorator(es, k, s, a));
            const i = Z.containsAnyOrUnknown(r, false);
            if (i && H.isUnknown(i)) {
              if (!w) {
                kt(d.DiagnosticRule.reportUntypedClassDecorator, g.LocMessage.classDecoratorTypeUnknown(), e.d.decorators[n].d.expr);
                w = true;
              }
            } else {
              k = r;
            }
          }
          if (H.isInstantiableClass(C) && C.shared.classDataClassTransform) {
            I = C.shared.classDataClassTransform;
          } else {
            const e = s.shared.mro.find(e => H.isClass(e) && e.shared.classDataClassTransform !== undefined && !H.ClassType.isSameGenericClass(e, s));
            if (e) {
              I = e.shared.classDataClassTransform;
            }
          }
          var A;
          if (I) {
            S.applyDataClassClassBehaviorOverrides(es, e.d.name, s, y, I);
          }
          A = s;
          _e.forEach(e => {
            if (H.ClassType.isSameGenericClass(e.dependsUpon, A)) {
              e.classesToComplete.forEach(e => {
                const t = Ne(e.d.name, 0);
                if (t) {
                  (function (e, t) {
                    if (!Z.computeMroLinearization(e)) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.methodOrdering(), t);
                    }
                    ha(e, t);
                  })(t, e.d.name);
                }
              });
            }
          });
          _e = _e.filter(e => !H.ClassType.isSameGenericClass(e.dependsUpon, A));
          fa(e, undefined);
          if (H.ClassType.isTypedDictClass(s)) {
            let t = false;
            const n = new p.DiagnosticAddendum();
            s.shared.baseClasses.forEach(e => {
              if (!!H.isClass(e) && !H.ClassType.isTypedDictClass(e) && !H.ClassType.isBuiltIn(e, ['_TypedDict', 'Generic'])) {
                t = true;
                n.addMessage(g.LocAddendum.typedDictBaseClass().format({
                  type: e.shared.name
                }));
              }
            });
            if (t) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictBaseClass() + n.getString(), e.d.name);
            }
            W.synthesizeTypedDictClassMethods(es, e, s);
          }
          if (H.ClassType.isDataClass(s) || c) {
            const t = H.ClassType.isDataClassSkipGenerateInit(s);
            let n = t;
            if (!t) {
              const e = s.shared.fields.get('__init__');
              if (e && e.isClassMember()) {
                n = true;
              }
            }
            let a = false;
            const r = s.shared.fields.get('__hash__');
            if (r && r.isClassMember() && !r.getSynthesizedType()) {
              a = true;
            }
            const i = () => S.synthesizeDataClassMethods(es, e, s, c, t, n, a);
            if (c) {
              i();
            } else {
              s.shared.synthesizeMethodsDeferred = () => {
                delete s.shared.synthesizeMethodsDeferred;
                i();
              };
            }
          }
          s.shared.calculateInheritedSlotsNamesDeferred = () => {
            delete s.shared.calculateInheritedSlotsNamesDeferred;
            if (s.shared.localSlotsNames) {
              let e = true;
              const t = Array.from(s.shared.localSlotsNames);
              s.shared.baseClasses.forEach(n => {
                if (H.isInstantiableClass(n)) {
                  if (!H.ClassType.isBuiltIn(n, 'object') && !H.ClassType.isBuiltIn(n, 'type') && !H.ClassType.isBuiltIn(n, 'Generic')) {
                    const a = H.ClassType.getInheritedSlotsNames(n);
                    if (a) {
                      o.appendArray(t, a);
                    } else {
                      e = false;
                    }
                  }
                } else {
                  e = false;
                }
              });
              if (e) {
                s.shared.inheritedSlotsNamesCached = t;
              }
            }
          };
          Fe(e.d.name, {
            type: s
          }, 0);
          Fe(e, {
            type: k
          }, 0);
          return {
            classType: s,
            decoratedType: k
          };
        });
      }
      function ua(e) {
        var t;
        const n = [];
        ((t = e.priv.typeArgs) !== null && t !== undefined ? t : []).forEach((e, t) => {
          if (H.isTypeVar(e)) {
            n.push(e);
            return;
          }
          const a = H.TypeVarType.createInstance(`__P${t}`);
          a.shared.isSynthesized = true;
          n.push(a);
        });
        return n;
      }
      function ma(e, t, n, a) {
        if (!t.shared.isDefaultExplicit && !t.shared.isSynthesized && !H.TypeVarType.isSelf(t)) {
          const r = n.find(e => e.shared.isDefaultExplicit && e.priv.scopeId === a);
          if (r) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarWithoutDefault().format({
              name: t.shared.name,
              other: r.shared.name
            }), e);
          }
          return;
        }
        const r = new Set();
        Z.validateTypeVarDefault(t, n, r);
        if (r.size > 0) {
          const n = new p.DiagnosticAddendum();
          r.forEach(e => {
            n.addMessage(g.LocAddendum.typeVarDefaultOutOfScope().format({
              name: e
            }));
          });
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultInvalidTypeVar().format({
            name: t.shared.name
          }) + n.getString(), e);
        }
      }
      function ya(e) {
        if (!e.shared.requiresVarianceInference) {
          return;
        }
        e.shared.requiresVarianceInference = false;
        e.shared.typeParams.forEach(e => {
          if (e.shared.declaredVariance === 0) {
            e.priv.computedVariance = 1;
          }
        });
        const t = H.ClassType.createInstantiable('__varianceDummy', '', '', y.Uri.empty(), 0, 0, undefined, undefined);
        e.shared.typeParams.forEach((n, a) => {
          if (H.isTypeVarTuple(n) || H.isParamSpec(n)) {
            return;
          }
          if (n.shared.declaredVariance !== 0) {
            return;
          }
          const r = e.shared.typeParams.map((e, n) => H.isTypeVarTuple(e) ? e : n === a ? lt() : t);
          const s = e.shared.typeParams.map((e, n) => n === a || H.isTypeVarTuple(e) ? e : t);
          const i = H.ClassType.specialize(e, r);
          const o = H.ClassType.specialize(e, s);
          let l;
          if (_r(i, o, 3, false)) {
            l = 3;
          } else {
            l = _r(o, i, 4, false) ? 4 : 2;
          }
          e.shared.typeParams[a].priv.computedVariance = l;
        });
      }
      function ga(e) {
        const t = [];
        const n = v.getScope(e);
        e.d.params.forEach(e => {
          var a;
          const r = n == null ? undefined : n.symbolTable.get(e.d.name.d.value);
          if (!r) {
            return;
          }
          const s = (a = yr(r, e.d.name)) === null || a === undefined ? undefined : a.type;
          if (s && H.isTypeVar(s)) {
            Fe(e.d.name, {
              type: s
            }, 0);
            t.push(s);
          }
        });
        return t;
      }
      function ha(e, t) {
        var n;
        let a = e.shared.declaredMetaclass;
        let r = false;
        if (!a || H.isInstantiableClass(a)) {
          for (const s of e.shared.baseClasses) {
            if (!H.isInstantiableClass(s)) {
              a = H.UnknownType.create();
              break;
            }
            {
              const e = (n = s.shared.effectiveMetaclass) !== null && n !== undefined ? n : Ae == null ? undefined : Ae.typeClass;
              if (!e || !H.isInstantiableClass(e)) {
                a = e ? H.UnknownType.create() : undefined;
                break;
              }
              if (a) {
                if (Z.derivesFromClassRecursive(e, a, false)) {
                  a = e;
                } else {
                  if (!Z.derivesFromClassRecursive(a, e, false) && !r) {
                    const n = new p.DiagnosticAddendum();
                    n.addMessage(g.LocAddendum.metaclassConflict().format({
                      metaclass1: Yr(Z.convertToInstance(a)),
                      metaclass2: Yr(Z.convertToInstance(e))
                    }));
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.metaclassConflict() + n.getString(), t);
                    r = true;
                  }
                }
              } else {
                a = e;
              }
            }
          }
        }
        if (!a) {
          const e = Za(t, 'type');
          a = e && H.isInstantiableClass(e) ? e : H.UnknownType.create();
        }
        e.shared.effectiveMetaclass = a;
        return a;
      }
      function fa(e, t) {
        if (t) {
          const n = _e.find(e => H.ClassType.isSameGenericClass(e.dependsUpon, t));
          if (n) {
            n.classesToComplete.push(e);
          } else {
            _e.push({
              dependsUpon: t,
              classesToComplete: [e]
            });
          }
        } else {
          _e.forEach(t => {
            t.classesToComplete.push(e);
          });
        }
      }
      function Ta(e, t) {
        const n = [];
        let a;
        e.d.arguments.forEach(e => {
          if (e.d.name && e.d.name.d.value !== 'metaclass') {
            n.push({
              argCategory: 0,
              node: e,
              name: e.d.name,
              valueExpression: e.d.valueExpr
            });
          }
        });
        if (t.shared.effectiveMetaclass && H.isClass(t.shared.effectiveMetaclass)) {
          if (!H.ClassType.isBuiltIn(t.shared.effectiveMetaclass, ['ABCMeta', 'type']) || !!H.ClassType.isTypedDictClass(t)) {
            a = Z.lookUpClassMember(t.shared.effectiveMetaclass, '__new__', 8);
          }
        }
        if (a) {
          const t = Tr(a);
          if (H.isFunction(t)) {
            const a = E.getParamListDetails(t);
            if (a.firstKeywordOnlyIndex !== undefined) {
              const r = new Map();
              for (let e = a.firstKeywordOnlyIndex; e < a.params.length; e++) {
                const t = a.params[e];
                if (t.param.category === 0 && t.param.name && t.kind !== E.ParamKind.Positional) {
                  r.set(t.param.name, e);
                }
              }
              n.forEach(n => {
                var s;
                var i;
                var o;
                if (n.argCategory === 0 && n.name) {
                  const l = (s = r.get(n.name.d.value)) !== null && s !== undefined ? s : a.kwargsIndex;
                  if (l !== undefined) {
                    const s = a.params[l];
                    vn({
                      paramCategory: s.param.category,
                      paramType: s.type,
                      requiresTypeVarMatching: false,
                      argument: n,
                      errorNode: (i = n.valueExpression) !== null && i !== undefined ? i : e.d.name
                    }, new k.ConstraintTracker(), {
                      type: t
                    }, {
                      skipUnknownArgCheck: true
                    });
                    r.delete(n.name.d.value);
                  } else {
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramNameMissing().format({
                      name: n.name.d.value
                    }), (o = n.name) !== null && o !== undefined ? o : e.d.name);
                  }
                }
              });
              const s = [];
              r.forEach((e, t) => {
                if (!a.params[e].defaultType) {
                  s.push(t);
                }
              });
              if (s.length > 0) {
                const t = s.map(e => `"${e}"`).join(', ');
                kt(d.DiagnosticRule.reportGeneralTypeIssues, s.length === 1 ? g.LocMessage.argMissingForParam().format({
                  name: t
                }) : g.LocMessage.argMissingForParams().format({
                  names: t
                }), e.d.name);
              }
            }
          }
        } else {
          const a = et(e.d.name, t, '__init_subclass__', undefined, undefined, 545);
          if (a) {
            const t = a.type;
            if (t && a.classType) {
              if (pn(e.d.name, n, {
                type: t
              }, undefined, false, Z.makeInferenceContext(pt())).argumentErrors) {
                const n = kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.initSubclassCallFailed(), e.d.name);
                const r = H.isOverloaded(t) ? H.OverloadedType.getOverloads(t)[0] : t;
                const s = H.isFunction(r) ? r.shared.declaration : undefined;
                if (n && s) {
                  n.addRelatedInfo(g.LocAddendum.initSubclassLocation().format({
                    name: Yr(Z.convertToInstance(a.classType))
                  }), s.uri, s.range);
                }
              }
            }
          }
        }
        n.forEach(e => {
          if (e.valueExpression) {
            qe(e.valueExpression);
          }
        });
      }
      function va(e) {
        var t;
        je(e);
        let n = Ne(e.d.name, 0);
        if (n) {
          if (!H.isFunction(n)) {
            return;
          }
          if (H.FunctionType.isPartiallyEvaluated(n)) {
            return {
              functionType: n,
              decoratedType: n
            };
          }
        } else {
          n = ba(e);
        }
        let a = Ne(e, 0);
        if (a) {
          return {
            functionType: n,
            decoratedType: a
          };
        }
        Fe(e, {
          type: n
        }, undefined);
        n.shared.flags |= 131072;
        const r = e.d.isAsync ? function (e, t) {
          l.assert(H.FunctionType.isAsync(t));
          const n = H.FunctionType.cloneWithNewFlags(t, t.shared.flags & -131585);
          if (t.shared.declaredReturnType) {
            n.shared.declaredReturnType = Sa(e, t.shared.declaredReturnType, H.FunctionType.isGenerator(t));
          } else {
            n.priv.inferredReturnType = Sa(e, Xr(t), H.FunctionType.isGenerator(t));
          }
          return n;
        }(e, n) : n;
        n.shared.flags &= -131073;
        a = r;
        let s = false;
        for (let r = e.d.decorators.length - 1; r >= 0; r--) {
          const i = e.d.decorators[r];
          const o = er((t = e.parent) !== null && t !== undefined ? t : e, () => {
            l.assert(a !== undefined);
            return x.applyFunctionDecorator(es, a, n, i, e);
          });
          const p = Z.containsAnyOrUnknown(o, false);
          if (p && H.isUnknown(p)) {
            if (!s) {
              kt(d.DiagnosticRule.reportUntypedFunctionDecorator, g.LocMessage.functionDecoratorTypeUnknown(), e.d.decorators[r].d.expr);
              s = true;
            }
          } else {
            a = o;
          }
        }
        if (H.isFunction(a)) {
          a.shared.deprecatedMessage = n.shared.deprecatedMessage;
          if (H.FunctionType.isOverloaded(a)) {
            e.d.params.forEach(e => {
              _a(e);
            });
          }
        }
        a = x.addOverloadsToFunctionType(es, e, a);
        Fe(e, {
          type: a
        }, 0);
        return {
          functionType: n,
          decoratedType: a
        };
      }
      function ba(e) {
        var t;
        const n = v.getFileInfo(e);
        const a = Ne(e.d.name, 0);
        if (a && H.isFunction(a)) {
          return a;
        }
        let r;
        const s = v.getDeclaration(e);
        if (s) {
          r = s;
        }
        const o = M.getEnclosingClass(e, true);
        let l;
        if (o) {
          l = (t = ca(o)) === null || t === undefined ? undefined : t.classType;
        }
        const c = x.getFunctionInfoFromDecorators(es, e, !!o);
        let u = c.flags;
        if (r == null ? undefined : r.isGenerator) {
          u |= 16;
        }
        if (n.isStubFile) {
          u |= 2048;
        } else {
          if (n.isInPyTypedPackage) {
            u |= 4096;
          }
        }
        if (e.d.isAsync) {
          u |= 512;
        }
        const m = H.FunctionType.createInstance(e.d.name.d.value, function (e, t, n) {
          const a = [n];
          let r = e;
          while (r) {
            r = M.getEnclosingClassOrFunction(r);
            if (r) {
              a.push(r.d.name.d.value);
            }
          }
          a.push(t);
          return a.reverse().join('.');
        }(e, n.moduleName, e.d.name.d.value), n.moduleName, u | 131072, M.getDocString(e.d.suite.d.statements));
        m.shared.typeVarScopeId = M.getScopeIdForNode(e);
        m.shared.deprecatedMessage = c.deprecationMessage;
        m.shared.methodClass = l;
        if (e.d.name.d.value === '__init__' || e.d.name.d.value === '__new__') {
          if (o) {
            m.priv.constructorTypeVarScopeId = M.getScopeIdForNode(o);
          }
        }
        if (n.isBuiltInStubFile || n.isTypingStubFile || n.isTypingExtensionsStubFile) {
          m.shared.flags |= 1048576;
        }
        m.shared.declaration = r;
        const y = V.getScopeForNode(e);
        const h = y == null ? undefined : y.lookUpSymbolRecursive(e.d.name.d.value);
        if (r && h) {
          Ve(h.symbol, r, m);
        }
        return i.invalidateTypeCacheIfCanceled(() => {
          var a;
          Fe(e.d.name, {
            type: m
          }, undefined);
          const r = l && H.ClassType.isPseudoGenericClass(l) && e.d.name.d.value === '__init__';
          const s = [];
          let i = 0;
          if (!!l && !(m.shared.flags & 4)) {
            i = 1;
          }
          if (e.d.funcAnnotationComment && !e.d.funcAnnotationComment.d.isEllipsis) {
            const t = e.d.params.length - i;
            const n = e.d.funcAnnotationComment.d.paramAnnotations.length;
            if (i > 0 && n === e.d.params.length) {
              i = 0;
            } else {
              if (n !== t) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.annotatedParamCountMismatch().format({
                  expected: t,
                  received: n
                }), e.d.funcAnnotationComment);
              }
            }
          }
          const o = [];
          if (e.d.typeParams) {
            m.shared.typeParams = ga(e.d.typeParams).map(e => Z.convertToInstance(e));
          } else {
            m.shared.typeParams = o;
          }
          let u = true;
          const y = l && (H.FunctionType.isClassMethod(m) || H.FunctionType.isInstanceMethod(m) || H.FunctionType.isConstructorMethod(m));
          const h = y ? 1 : 0;
          e.d.params.forEach((t, a) => {
            let f;
            let T;
            let v;
            let b;
            if (t.d.name && (a === 0 && y || H.FunctionType.isAbstractMethod(m) || l && H.ClassType.isProtocolClass(l))) {
              _a(t);
            }
            if (t.d.annotation) {
              v = t.d.annotation;
            } else {
              if (t.d.annotationComment) {
                v = t.d.annotationComment;
              } else {
                if (e.d.funcAnnotationComment && !e.d.funcAnnotationComment.d.isEllipsis) {
                  const t = a - i;
                  if (t >= 0 && t < e.d.funcAnnotationComment.d.paramAnnotations.length) {
                    v = e.d.funcAnnotationComment.d.paramAnnotations[t];
                  }
                }
              }
            }
            if (v) {
              T = c.flags & 524288 ? H.UnknownType.create() : He(v, t.d.category);
              if (T) {
                Z.addTypeVarsToListIfUnique(o, Z.getTypeVarArgsRecursive(T), m.shared.typeVarScopeId);
              }
              if (H.isTypeVarTuple(T) && !T.priv.isUnpacked) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackedTypeVarTupleExpected().format({
                  name1: T.shared.name,
                  name2: T.shared.name
                }), v);
                T = H.UnknownType.create();
              }
            }
            if (!T && r && a > 0 && t.d.category === 0 && t.d.name && !t.d.defaultValue) {
              const e = da(t.d.name.d.value);
              T = l.shared.typeParams.find(t => t.shared.name === e);
            }
            if (T) {
              const e = Ca(t, T);
              if (e !== T) {
                T = e;
              }
            }
            if (t.d.defaultValue) {
              let a = n.isStubFile || M.isSuiteEmpty(e.d.suite);
              if (l && H.ClassType.isProtocolClass(l)) {
                a = true;
              }
              if (H.FunctionType.isOverloaded(m) || H.FunctionType.isAbstractMethod(m)) {
                a = true;
              }
              b = qe(t.d.defaultValue, a ? 1 : 0, Z.makeInferenceContext(T)).type;
            }
            if (T) {
              if (t.d.defaultValue && b) {
                const e = new p.DiagnosticAddendum();
                if (!Ir(T, b, e)) {
                  kt(d.DiagnosticRule.reportArgumentType, g.LocMessage.paramAssignmentMismatch().format({
                    sourceType: Yr(b),
                    paramType: Yr(T)
                  }) + e.getString(), t.d.defaultValue);
                }
              }
              f = T;
            }
            if (a >= h) {
              let n = false;
              if (t.d.category === 0 && t.d.name) {
                if (B.isPrivateName(t.d.name.d.value) && !e.d.params.some(e => e.d.category === 0 && !e.d.name)) {
                  n = true;
                  if (!u && m.shared.parameters.every(e => e.category === 0)) {
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.positionOnlyAfterNon(), t.d.name);
                  }
                }
              } else {
                u = false;
              }
              if (u && !n && m.shared.parameters.length > h) {
                H.FunctionType.addPositionOnlyParamSeparator(m);
              }
              if (!n) {
                u = false;
              }
            }
            let _ = false;
            if (!v) {
              _ = true;
              const t = Ia(e, m.shared.flags, a, l);
              if (t) {
                f = t;
              }
            }
            f = f ?? H.UnknownType.create();
            const C = H.FunctionParam.create(t.d.category, f, (_ ? H.FunctionParamFlags.TypeInferred : H.FunctionParamFlags.None) | (v ? H.FunctionParamFlags.TypeDeclared : H.FunctionParamFlags.None), t.d.name ? t.d.name.d.value : undefined, b, t.d.defaultValue);
            H.FunctionType.addParam(m, C);
            if (H.FunctionParam.isTypeDeclared(C)) {
              Z.addTypeVarsToListIfUnique(o, Z.getTypeVarArgsRecursive(f), m.shared.typeVarScopeId);
            }
            if (t.d.name) {
              const n = wa(e, t.d.category, f);
              s.push(n);
            } else {
              s.push(f);
            }
          });
          if (u && m.shared.parameters.length > h) {
            H.FunctionType.addPositionOnlyParamSeparator(m);
          }
          const f = M.getTypeVarScopesForNode(e);
          s.forEach((t, n) => {
            const a = e.d.params[n].d.name;
            if (a) {
              if (H.isUnknown(t)) {
                m.shared.flags |= 16384;
              }
              Fe(a, {
                type: t = Z.makeTypeVarsBound(t, f)
              }, 0);
            }
          });
          if (s.length >= 2) {
            const e = s[s.length - 2];
            const t = s[s.length - 1];
            if (H.isParamSpec(e) && e.priv.paramSpecAccess === 'args' && H.isParamSpec(t) && t.priv.paramSpecAccess === 'kwargs') {
              m.shared.flags |= 32768;
            }
          }
          if (m.shared.parameters.filter((e, t) => e.category !== 0 && e.name && H.isAnyOrUnknown(H.FunctionType.getParamType(m, t))).length >= 2) {
            m.shared.flags |= 32768;
          }
          const T = e.d.returnAnnotation ?? ((a = e.d.funcAnnotationComment) === null || a === undefined ? undefined : a.d.returnAnnotation);
          if (T) {
            m.shared.declaredReturnType = H.UnknownType.create();
            const e = Ze(T, {
              typeVarGetsCurScope: true
            });
            m.shared.declaredReturnType = e;
          } else {
            if (n.isStubFile) {
              if (e.d.name.d.value === '__init__') {
                m.shared.declaredReturnType = pt();
              } else {
                m.shared.declaredReturnType = H.UnknownType.create();
              }
            }
          }
          if (m.shared.declaredReturnType && T) {
            Z.addTypeVarsToListIfUnique(o, Z.getTypeVarArgsRecursive(m.shared.declaredReturnType), m.shared.typeVarScopeId);
          }
          if ((n.isStubFile || M.isSuiteEmpty(e.d.suite)) && m.shared.declaredReturnType && H.isClassInstance(m.shared.declaredReturnType) && H.ClassType.isBuiltIn(m.shared.declaredReturnType, ['Generator', 'AsyncGenerator', 'AwaitableGenerator'])) {
            m.shared.flags |= 16;
          }
          m.shared.typeParams.forEach((t, n) => {
            var a;
            let r = e.d.name;
            if (e.d.typeParams && n < e.d.typeParams.d.params.length) {
              const t = e.d.typeParams.d.params[n];
              r = (a = t.d.defaultExpr) !== null && a !== undefined ? a : t.d.name;
            }
            ma(r, t, m.shared.typeParams.slice(0, n), m.shared.typeVarScopeId);
          });
          m.shared.flags &= -131073;
          Fe(e.d.name, {
            type: m
          }, 0);
          return m;
        });
      }
      function _a(e) {
        if (e.d.name) {
          const t = Ja(e.d.name, e.d.name.d.value, false);
          if (t) {
            Et(v.getFileInfo(e), t.symbol, e.d.name);
          }
        }
      }
      function Ca(e, t) {
        var n;
        if (((n = e.d.defaultValue) === null || n === undefined ? undefined : n.nodeType) !== 14 || e.d.defaultValue.d.constType !== 26 || Z.isOptionalType(t) || v.getFileInfo(e).diagnosticRuleSet.strictParameterNoneValue) {
          return t;
        } else {
          return H.combineTypes([t, pt()]);
        }
      }
      function Ia(e, t, n, a) {
        var r;
        if (a) {
          if (n === 0 && !(t & 4)) {
            const e = !!(t & 3);
            return Z.synthesizeTypeVarForSelfCls(a, e);
          }
          const s = e.d.name.d.value;
          const i = Z.lookUpClassMember(a, s, 1);
          if (i) {
            const t = i.symbol.getDeclarations();
            if (t.length === 1 && t[0].type === 5) {
              const a = t[0].node;
              if (a.d.params.length === e.d.params.length && a.d.params.every((t, n) => {
                var a;
                var r;
                const s = e.d.params[n];
                return ((a = s.d.name) === null || a === undefined ? undefined : a.d.value) === ((r = t.d.name) === null || r === undefined ? undefined : r.d.value) && s.d.category === t.d.category;
              })) {
                const t = a.d.params[n];
                const s = (r = t.d.annotation) !== null && r !== undefined ? r : t.d.annotationComment;
                if (s) {
                  let t = He(s, e.d.params[n].d.category);
                  if (Z.requiresSpecialization(t) && H.isClass(i.classType)) {
                    const e = Z.getTypeVarScopeIds(i.classType);
                    const n = Z.buildSolutionFromSpecializedClass(i.classType);
                    e.push(M.getScopeIdForNode(a));
                    t = Z.applySolvedTypeVars(t, n, {
                      replaceUnsolved: {
                        scopeIds: e,
                        tupleClassType: ot()
                      }
                    });
                  }
                  const r = v.getFileInfo(e);
                  if (r.isInPyTypedPackage && !r.isStubFile) {
                    t = H.TypeBase.cloneForAmbiguousType(t);
                  }
                  return t;
                }
              }
            }
          }
        }
        const s = e.d.params[n].d.defaultValue;
        if (s) {
          return ka(s);
        }
      }
      function ka(e) {
        const t = qe(e, 1).type;
        let n;
        if (Z.isNoneInstance(t) || H.isClassInstance(t) && B.isPrivateOrProtectedName(t.shared.name)) {
          n = H.combineTypes([t, H.UnknownType.create()]);
        } else {
          let e = false;
          if (H.isFunction(t) || H.isOverloaded(t) || H.isClassInstance(t) && H.ClassType.isBuiltIn(t, ['tuple', 'list', 'set', 'dict'])) {
            e = true;
          }
          if (!e) {
            n = Ut(t, 0, true);
            n = Z.stripTypeForm(n);
            n = $e(n);
          }
        }
        if (n) {
          const t = v.getFileInfo(e);
          if (t.isInPyTypedPackage && !t.isStubFile) {
            n = H.TypeBase.cloneForAmbiguousType(n);
          }
        }
        return n;
      }
      function wa(e, t, n) {
        switch (t) {
          case 0:
            return n;
          case 1:
            if (H.isParamSpec(n) && n.priv.paramSpecAccess) {
              return n;
            } else {
              if (H.isUnpackedClass(n)) {
                return H.ClassType.cloneForPacked(n);
              } else {
                return q.makeTupleObject(es, [{
                  type: n,
                  isUnbounded: !H.isTypeVarTuple(n)
                }]);
              }
            }
          case 2:
            {
              if (H.isParamSpec(n) && n.priv.paramSpecAccess) {
                return n;
              }
              if (H.isClassInstance(n) && H.ClassType.isTypedDictClass(n) && n.priv.isUnpacked) {
                return H.ClassType.cloneForPacked(n);
              }
              const t = Za(e, 'dict');
              const a = Ya(e, 'str');
              if (H.isInstantiableClass(t) && H.isClassInstance(a)) {
                return H.ClassType.cloneAsInstance(H.ClassType.specialize(t, [a, n]));
              } else {
                return H.UnknownType.create();
              }
            }
        }
      }
      function Sa(e, t, n, a = true) {
        let r;
        if (H.isClassInstance(t) && H.ClassType.isBuiltIn(t)) {
          if (t.shared.name === 'Generator') {
            const n = ct(e, 'AsyncGenerator');
            if (n && H.isInstantiableClass(n)) {
              const e = [];
              const a = t.priv.typeArgs;
              if (a && a.length > 0) {
                e.push(a[0]);
              }
              if (a && a.length > 1) {
                e.push(a[1]);
              }
              r = H.ClassType.cloneAsInstance(H.ClassType.specialize(n, e));
            }
          } else {
            if (['AsyncGenerator', 'AsyncIterator', 'AsyncIterable'].some(e => e === t.shared.name)) {
              r = t;
            }
          }
        }
        if (!r || !n) {
          const n = ct(e, a ? 'Coroutine' : 'Awaitable');
          r = n && H.isInstantiableClass(n) ? H.ClassType.cloneAsInstance(H.ClassType.specialize(n, a ? [H.AnyType.create(), H.AnyType.create(), t] : [t])) : H.UnknownType.create();
        }
        return r;
      }
      function Aa(e, t) {
        var n;
        if (e.d.returnAnnotation || ((n = e.d.funcAnnotationComment) === null || n === undefined ? undefined : n.d.returnAnnotation)) {
          return;
        }
        let a = Ne(e.d.suite, 0);
        let r = false;
        if (a) {
          return {
            type: a,
            isIncomplete: r
          };
        }
        if (he.has(e.id) || he.size >= oe) {
          a = H.UnknownType.create();
          r = true;
        } else {
          he.add(e.id);
          try {
            let n;
            const s = v.getDeclaration(e);
            if (s) {
              n = s;
            }
            const i = !ht(e);
            const o = ht(e.d.suite);
            if (v.getFileInfo(e).isStubFile) {
              a = H.UnknownType.create();
            } else {
              if (i) {
                a = t || xa(n) ? H.UnknownType.create() : H.NeverType.createNoReturn();
              } else {
                const e = [];
                if (n == null ? undefined : n.returnStatements) {
                  n.returnStatements.forEach(t => {
                    var n;
                    if (gt(t)) {
                      if (t.d.expr) {
                        const a = qe(t.d.expr);
                        if (a.isIncomplete) {
                          r = true;
                        }
                        let s = a.type;
                        if ((n = s.props) === null || n === undefined ? undefined : n.specialForm) {
                          s = s.props.specialForm;
                        }
                        s = Z.mapSubtypes(s, e => H.isClassInstance(e) && e.priv.isEmptyContainer ? H.ClassType.specialize(e, e.priv.typeArgs, !!e.priv.isTypeArgExplicit, e.priv.includeSubclasses, e.priv.tupleTypeArgs, false) : e);
                        s = Z.stripTypeForm(s);
                        e.push(s);
                      } else {
                        e.push(pt());
                      }
                    }
                  });
                }
                if (!i && o) {
                  e.push(pt());
                }
                a = H.combineTypes(e);
                a = H.removeUnbound(a);
              }
              if (n == null ? undefined : n.isGenerator) {
                const t = [];
                let r = false;
                let s = false;
                if (n.yieldStatements) {
                  n.yieldStatements.forEach(e => {
                    var n;
                    var a;
                    if (gt(e)) {
                      if (e.nodeType === 61) {
                        s = true;
                        const a = qe(e.d.expr);
                        if (H.isClassInstance(a.type) && H.ClassType.isBuiltIn(a.type, 'Coroutine')) {
                          const e = a.type.priv.typeArgs && a.type.priv.typeArgs.length > 0 ? a.type.priv.typeArgs[0] : H.UnknownType.create();
                          t.push(e);
                          r = true;
                        } else {
                          const r = (n = st(a, false, e)) === null || n === undefined ? undefined : n.type;
                          t.push(r ?? H.UnknownType.create());
                        }
                      } else {
                        if (((a = e == null ? undefined : e.parent) === null || a === undefined ? undefined : a.nodeType) !== 47) {
                          s = true;
                        }
                        if (e.d.expr) {
                          const n = qe(e.d.expr).type;
                          t.push(n ?? H.UnknownType.create());
                        } else {
                          t.push(pt());
                        }
                      }
                    }
                  });
                }
                const i = H.combineTypes(t);
                const o = ct(e, r ? 'AwaitableGenerator' : 'Generator');
                if (o && H.isInstantiableClass(o)) {
                  const e = [];
                  const t = s ? H.UnknownType.create() : H.AnyType.create();
                  e.push(i, t, a);
                  if (r) {
                    e.push(H.AnyType.create());
                  }
                  a = H.ClassType.cloneAsInstance(H.ClassType.specialize(o, e));
                } else {
                  a = H.UnknownType.create();
                }
              }
            }
            Fe(e.d.suite, {
              type: a,
              isIncomplete: r
            }, 0);
          } catch (t) {
            if ((t == null ? undefined : t.message) === 'Maximum call stack size exceeded') {
              const t = v.getFileInfo(e);
              console.error(`Overflowed stack when inferring return type for function: ${e.d.name.d.value} in file ${t.fileUri.toUserVisibleString()}`);
              return;
            }
            throw t;
          } finally {
            he.delete(e.id);
          }
        }
        if (a) {
          return {
            type: a,
            isIncomplete: r
          };
        } else {
          return undefined;
        }
      }
      function xa(e) {
        if (!e || !e.isMethod || e.returnStatements || e.yieldStatements || !e.raiseStatements) {
          return false;
        }
        if (e.node.d.suite.d.statements.some(e => e.nodeType !== 47)) {
          return false;
        }
        for (const t of e.raiseStatements) {
          if (!t.d.expr || t.d.fromExpr) {
            return false;
          }
          const e = qe(t.d.expr).type;
          const n = H.isInstantiableClass(e) || H.isClassInstance(e) ? e : undefined;
          if (!n || !Z.derivesFromStdlibClass(n, 'NotImplementedError')) {
            return false;
          }
        }
        return true;
      }
      function Pa(e) {
        var t;
        var n;
        if (De(e)) {
          return;
        }
        const a = qe(e.d.iterableExpr);
        const r = (n = (t = st(a, !!e.d.isAsync, e.d.iterableExpr)) === null || t === undefined ? undefined : t.type) !== null && n !== undefined ? n : H.UnknownType.create();
        Nt(e.d.targetExpr, {
          type: r,
          isIncomplete: a.isIncomplete
        }, e.d.targetExpr);
        Fe(e, {
          type: r,
          isIncomplete: !!a.isIncomplete
        }, 0);
      }
      function Da(e) {
        l.assert(e.d.typeExpr !== undefined);
        if (De(e)) {
          return;
        }
        const t = qe(e.d.typeExpr);
        const n = t.type;
        let a = false;
        function r(e, n) {
          var r;
          var s;
          e = Pt(e);
          if (H.isAnyOrUnknown(e)) {
            return e;
          }
          if (H.isInstantiableClass(e)) {
            if (H.ClassType.isBuiltIn(e, 'BaseException')) {
              a = true;
            }
            return H.ClassType.cloneAsInstance(e);
          }
          if (H.isClassInstance(e)) {
            const a = (s = (r = st({
              type: e,
              isIncomplete: t.isIncomplete
            }, false, n)) === null || r === undefined ? undefined : r.type) !== null && s !== undefined ? s : H.UnknownType.create();
            return Z.mapSubtypes(a, e => H.isAnyOrUnknown(e) ? e : H.UnknownType.create());
          }
          return H.UnknownType.create();
        }
        let s = Z.mapSubtypes(n, t => {
          const n = Z.getSpecializedTupleType(t);
          if (n && n.priv.tupleTypeArgs) {
            const t = n.priv.tupleTypeArgs.map(t => r(t.type, e.d.typeExpr));
            return H.combineTypes(t);
          }
          return r(t, e.d.typeExpr);
        });
        if (e.d.isExceptGroup) {
          s = Ya(e, a ? 'BaseExceptionGroup' : 'ExceptionGroup', [s]);
        }
        if (e.d.name) {
          Nt(e.d.name, {
            type: s
          }, e.d.name);
        }
        Fe(e, {
          type: s
        }, 0);
      }
      function Na(e) {
        if (De(e)) {
          return;
        }
        const t = qe(e.d.expr);
        let n = t.type;
        const a = e.parent && e.parent.nodeType === 58 && !!e.parent.d.isAsync;
        if (Z.isOptionalType(n)) {
          kt(d.DiagnosticRule.reportOptionalContextManager, g.LocMessage.noneNotUsableWith(), e.d.expr);
          n = Z.removeNoneFromUnion(n);
        }
        const r = a ? '__aenter__' : '__enter__';
        const s = Z.mapSubtypes(n, t => {
          t = Pt(t);
          if (H.isAnyOrUnknown(t)) {
            return t;
          }
          const i = new p.DiagnosticAddendum();
          if (H.isClass(t)) {
            let o = Pn(t, r, [], e.d.expr, undefined, i.createAddendum())?.type;
            if (o) {
              if (a) {
                o = rt(o, e.d.expr);
              }
              return o;
            }
            if (!a) {
              if (Pn(t, '__aenter__', [], e.d.expr, undefined)?.type) {
                i.addMessage(g.LocAddendum.asyncHelp());
              }
            }
          }
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeNotUsableWith().format({
            type: Yr(t),
            method: r
          }) + i.getString(), e.d.expr);
          return H.UnknownType.create();
        });
        const i = a ? '__aexit__' : '__exit__';
        Z.doForEachSubtype(n, t => {
          t = Pt(t);
          if (!H.isAnyOrUnknown(t)) {
            if (H.isClass(t)) {
              const a = {
                type: H.AnyType.create()
              };
              if (Pn(t, i, [a, a, a], e.d.expr, undefined)?.type) {
                return;
              }
            }
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeNotUsableWith().format({
              type: Yr(t),
              method: i
            }), e.d.expr);
          }
        });
        if (e.d.target) {
          Nt(e.d.target, {
            type: s,
            isIncomplete: t.isIncomplete
          }, e.d.target);
        }
        Fe(e, {
          type: s,
          isIncomplete: !!t.isIncomplete
        }, 0);
      }
      function Fa(e) {
        var t;
        if (De(e)) {
          return;
        }
        let n;
        n = e.d.alias ? e.d.alias : e.d.module.d.nameParts[0];
        if (!n) {
          return;
        }
        let a = (t = Ua(e, n.d.value)) !== null && t !== undefined ? t : H.UnknownType.create();
        const r = Ne(e, 0);
        if (r && H.isModule(r) && a && H.isTypeSame(a, r)) {
          a = r;
        }
        St(n, {
          type: a
        }, false);
        Fe(e, {
          type: a
        }, 0);
      }
      function Ea(t) {
        var n;
        if (De(t)) {
          return;
        }
        const a = t.d.alias || t.d.name;
        const r = v.getFileInfo(t);
        if (((n = t.d.alias) === null || n === undefined ? undefined : n.d.value) === t.d.name.d.value) {
          const e = Ja(t, t.d.name.d.value, true);
          if (e) {
            Et(r, e.symbol, t);
          }
        }
        if (M.getEnclosingClass(t, true)) {
          const e = Ja(t, a.d.value, true);
          if (e) {
            Et(r, e.symbol, t);
          }
        }
        let s = Ua(t, a.d.value);
        if (!s) {
          const n = t.parent;
          l.assert(n && n.nodeType === 25);
          l.assert(!n.d.isWildcardImport);
          const a = v.getImportInfo(n.d.module);
          if (a && a.isImportFound && !a.isNativeLib) {
            const n = a.resolvedUris[a.resolvedUris.length - 1];
            const i = e(n);
            let o = false;
            if (i) {
              o = true;
              if (u.PythonVersion.isGreaterOrEqualTo(r.executionEnvironment.pythonVersion, u.pythonVersion3_7) || r.isStubFile) {
                const e = i.symbolTable.get('__getattr__');
                if (e) {
                  const t = cr(e);
                  if (H.isFunction(t)) {
                    s = hr(t);
                    o = false;
                  }
                }
              }
            } else {
              if (n.isEmpty()) {
                o = true;
              }
            }
            if (o) {
              kt(d.DiagnosticRule.reportAttributeAccessIssue, g.LocMessage.importSymbolUnknown().format({
                name: t.d.name.d.value
              }), t.d.name);
            }
          }
          if (!s) {
            s = H.UnknownType.create();
          }
        }
        St(a, {
          type: s
        }, false);
        Fe(t, {
          type: s
        }, 0);
      }
      function Ma(e) {
        if (De(e)) {
          return;
        }
        if (!e.parent || e.parent.nodeType !== 63) {
          l.fail('Expected parent of case statement to be match statement');
          return;
        }
        const t = v.getFileInfo(e);
        const n = qe(e.parent.d.expr);
        let a = n.type;
        for (const r of e.parent.d.cases) {
          if (r === e) {
            if (t.diagnosticRuleSet.reportUnnecessaryComparison !== 'none') {
              if (!n.isIncomplete) {
                O.checkForUnusedPattern(es, e.d.pattern, a);
              }
            }
            break;
          }
          if (!r.d.guardExpr) {
            a = O.narrowTypeBasedOnPattern(es, a, r.d.pattern, false);
          }
        }
        Fe(e, {
          type: O.assignTypeToPatternTargets(es, a, !!n.isIncomplete, e.d.pattern),
          isIncomplete: !!n.isIncomplete
        }, 0);
      }
      function Oa(e) {
        if (!De(e)) {
          if (e.d.isWildcardImport) {
            Fe(e, {
              type: H.AnyType.create()
            }, 0);
            const t = v.getFlowNode(e);
            if (t && t.flags & _.FlowFlags.WildcardImport) {
              t.names.forEach(t => {
                var n;
                var a;
                const r = Ua(e, t);
                if (!r) {
                  return;
                }
                const s = Ja(e, t, false);
                if (!s) {
                  return;
                }
                const i = (n = yr(s.symbol)) === null || n === undefined ? undefined : n.type;
                if (!i) {
                  return;
                }
                const o = new p.DiagnosticAddendum();
                if (!Ir(i, r, o)) {
                  kt(d.DiagnosticRule.reportAssignmentType, g.LocMessage.typeAssignmentMismatchWildcard().format({
                    ...Hr(r, i),
                    name: t
                  }) + o.getString(), e, (a = e.d.wildcardToken) !== null && a !== undefined ? a : e);
                }
              });
            }
          } else {
            const t = e.d.module.d.nameParts[0];
            let n = Ua(e, t.d.value);
            if (!n) {
              return;
            }
            const a = Ne(e, 0);
            if (a && H.isModule(a) && n && H.isTypeSame(n, a)) {
              n = a;
            }
            St(t, {
              type: n
            }, false);
            Fe(e, {
              type: n
            }, 0);
          }
        }
      }
      function za(e) {
        var t;
        if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 3) {
          sa(e.parent);
        } else {
          const t = Ze(e.d.annotation, {
            varTypeAnnotation: true,
            allowFinal: M.isFinalAllowedForAssignmentTarget(e.d.valueExpr),
            allowClassVar: M.isClassVarAllowedForAssignmentTarget(e.d.valueExpr)
          });
          Fe(e.d.valueExpr, {
            type: t
          }, 0);
        }
      }
      function Ua(e, t) {
        const a = Ja(e, t, true);
        if (!a) {
          return;
        }
        const r = a.symbol.getDeclarations().filter(t => M.isNodeContainedWithin(e, t.node) && t.type === 8);
        let s = r.length > 0 ? r[r.length - 1] : undefined;
        if (!s) {
          s = a.symbol.getDeclarations().find(e => e.type === 8);
        }
        if (!s) {
          return;
        }
        l.assert(s.type === 8);
        const i = dr(s, true, {
          allowExternallyHiddenAccess: v.getFileInfo(e).isStubFile
        });
        if (i) {
          if (!i.declaration) {
            if (n.evaluateUnknownImportsAsAny) {
              return H.AnyType.create();
            } else {
              return H.UnknownType.create();
            }
          }
          if (e.nodeType === 26 && (i.isPrivate && kt(d.DiagnosticRule.reportPrivateUsage, g.LocMessage.privateUsedOutsideOfModule().format({
            name: e.d.name.d.value
          }), e.d.name), i.privatePyTypedImporter)) {
            const t = new p.DiagnosticAddendum();
            if (i.privatePyTypedImported) {
              t.addMessage(g.LocAddendum.privateImportFromPyTypedSource().format({
                module: i.privatePyTypedImported
              }));
            }
            kt(d.DiagnosticRule.reportPrivateImportUsage, g.LocMessage.privateImportFromPyTypedModule().format({
              name: e.d.name.d.value,
              module: i.privatePyTypedImporter
            }) + t.getString(), e.d.name);
          }
          return lr(a.symbol, s);
        }
      }
      function Va(e) {
        var t;
        var n;
        var a;
        var r;
        var s;
        var i;
        if (e.nodeType === 38 && e.parent) {
          if (e.parent.nodeType === 31 && e.parent.d.name === e) {
            va(e.parent);
            return;
          }
          if (e.parent.nodeType === 10 && e.parent.d.name === e) {
            ca(e.parent);
            return;
          }
          if (e.parent.nodeType === 26) {
            Ea(e.parent);
            return;
          }
          if (e.parent.nodeType === 24) {
            Fa(e.parent);
            return;
          }
          if (e.parent.nodeType === 77 && e.parent.d.name === e) {
            oa(e.parent);
            return;
          }
          if (e.parent.nodeType === 32 || e.parent.nodeType === 39) {
            qe(e, 4);
            return;
          }
          if (e.parent.nodeType === 37) {
            return;
          }
        }
        const o = M.getParentAnnotationNode(e);
        if (o) {
          const e = o.parent;
          l.assert(e !== undefined);
          if (e.nodeType === 3) {
            if (o === e.d.annotationComment) {
              Ze(o, {
                varTypeAnnotation: true,
                allowFinal: M.isFinalAllowedForAssignmentTarget(e.d.leftExpr),
                allowClassVar: M.isClassVarAllowedForAssignmentTarget(e.d.leftExpr)
              });
            } else {
              sa(e);
            }
            return;
          } else {
            if (e.nodeType === 54) {
              za(e);
              return;
            } else {
              if (e.nodeType === 31 && o === e.d.returnAnnotation) {
                Ze(o, {
                  typeVarGetsCurScope: true
                });
                return;
              } else {
                Ze(o, {
                  varTypeAnnotation: ((t = o.parent) === null || t === undefined ? undefined : t.nodeType) === 54,
                  allowUnpackedTuple: e.nodeType === 41 && e.d.category === 1,
                  allowUnpackedTypedDict: e.nodeType === 41 && e.d.category === 2
                });
                return;
              }
            }
          }
        }
        const p = M.getParentNodeOfType(e, 64);
        if (p && M.isNodeContainedWithin(e, p.d.pattern)) {
          Ma(p);
          return;
        }
        let d = e;
        let c = 0;
        while (true) {
          const t = M.getParentNodeOfType(d, 1);
          if (t && t !== d) {
            l.assert(t.parent !== undefined);
            if (t.parent.nodeType === 9 || t.parent.nodeType === 27) {
              d = t.parent;
              continue;
            }
            if (t.parent.nodeType === 10) {
              ca(t.parent);
              return;
            }
          }
          let n = d.parent;
          if (!n) {
            break;
          }
          if (n.nodeType === 4 && d === n.d.name) {
            d = n;
            continue;
          }
          const a = M.getParentNodeOfType(n, 48);
          if (a) {
            d = a;
          } else {
            if (n.nodeType === 9 || n.nodeType === 35) {
              if (d === n.d.leftExpr) {
                if (d.nodeType === 9 && d.d.leftExpr.nodeType === 38 && d.d.leftExpr.d.value === 'super') {
                  d = n;
                  continue;
                }
                if (n.nodeType === 9 && d.nodeType === 33) {
                  d = n;
                  continue;
                }
                c = 2;
                break;
              }
            } else {
              if (n.nodeType === 27 && d === n.d.leftExpr) {
                c = 2;
              }
            }
            if (!h.isExpressionNode(n)) {
              if (n.nodeType === 20 || n.nodeType === 19 || n.nodeType === 12 || n.nodeType === 13) {
                l.assert(n.parent !== undefined && h.isExpressionNode(n.parent));
                n = n.parent;
              } else {
                if (n.nodeType !== 41) {
                  if (n.nodeType === 75) {
                    if (e === n.d.boundExpr || e === n.d.defaultExpr) {
                      or(n);
                      return;
                    }
                    break;
                  }
                  break;
                }
                l.assert(n.parent !== undefined);
                if (n.parent.nodeType !== 33) {
                  break;
                }
                n = n.parent;
              }
            }
            d = n;
          }
        }
        const u = d.parent;
        l.assert(u !== undefined);
        switch (u.nodeType) {
          case 17:
            Ft(d);
            return;
          case 75:
            if (d === u.d.name && ((n = u.parent) === null || n === undefined ? undefined : n.nodeType) === 76 && ((a = u.parent.parent) === null || a === undefined ? undefined : a.nodeType) === 77) {
              oa(u.parent.parent);
              return;
            }
            break;
          case 77:
            oa(u);
            return;
          case 16:
            if (((r = u.parent) === null || r === undefined ? undefined : r.nodeType) === 10) {
              ca(u.parent);
            } else {
              if (((s = u.parent) === null || s === undefined ? undefined : s.nodeType) === 31) {
                va(u.parent);
              }
            }
            return;
          case 41:
            if (d !== u.d.defaultValue) {
              Ra(u);
              return;
            }
            break;
          case 1:
            if (d === u.d.name) {
              return;
            }
            if (((i = u.parent) === null || i === undefined ? undefined : i.nodeType) === 10) {
              ca(u.parent);
              return;
            }
            break;
          case 44:
            if (u.d.expr) {
              const t = M.getEnclosingFunction(e);
              let n = t ? fr(t) : undefined;
              if (n) {
                const t = M.getTypeVarScopesForNode(e);
                n = Z.makeTypeVarsBound(n, t);
              }
              qe(u.d.expr, 0, Z.makeInferenceContext(n));
              return;
            }
            break;
          case 54:
            za(u);
            return;
          case 3:
            sa(u);
            return;
        }
        if (d.nodeType !== 54) {
          qe(d, c);
        } else {
          za(d);
        }
      }
      function Ra(e) {
        var t;
        if (!e.d.name) {
          return;
        }
        const n = e.parent;
        if (n.nodeType === 33) {
          Va(n);
          return;
        }
        l.assert(n.nodeType === 31);
        const a = n;
        const r = a.d.params.findIndex(t => t === e);
        const s = M.getTypeAnnotationForParam(a, r);
        if (s) {
          const t = a.d.params[r];
          let n = He(s, a.d.params[r].d.category);
          const i = M.getTypeVarScopesForNode(t);
          n = Z.makeTypeVarsBound(n, i);
          const o = wa(e, e.d.category, Ca(t, n));
          Fe(e.d.name, {
            type: o
          }, 0);
          return;
        }
        const i = M.getEnclosingClass(a, true);
        const o = i ? ca(i) : undefined;
        if (o && H.ClassType.isPseudoGenericClass(o == null ? undefined : o.classType) && a.d.name.d.value === '__init__') {
          const t = da(e.d.name.d.value);
          const n = o.classType.shared.typeParams.find(e => e.shared.name === t);
          if (n) {
            Fe(e.d.name, {
              type: H.TypeVarType.cloneAsBound(n)
            }, 0);
            return;
          }
        }
        let p = (t = Ia(a, x.getFunctionInfoFromDecorators(es, a, true).flags, r, o == null ? undefined : o.classType)) !== null && t !== undefined ? t : H.UnknownType.create();
        const d = M.getTypeVarScopesForNode(e);
        p = Z.makeTypeVarsBound(p, d);
        Fe(e.d.name, {
          type: wa(e, e.d.category, p)
        }, 0);
      }
      function La(e) {
        je(e);
        let t = e;
        while (t) {
          switch (t.nodeType) {
            case 3:
              if (!t.parent || t.parent.nodeType !== 3 && t.parent.nodeType !== 4 && t.parent.nodeType !== 5 || t.parent.d.rightExpr !== t) {
                sa(t);
                return;
              }
              break;
            case 77:
              oa(t);
              return;
            case 4:
            case 33:
              Va(t);
              return;
            case 5:
              pa(t);
              return;
            case 10:
              ca(t);
              return;
            case 41:
              Ra(t);
              return;
            case 31:
              va(t);
              return;
            case 29:
              Pa(t);
              return;
            case 28:
              Da(t);
              return;
            case 59:
              Na(t);
              return;
            case 12:
              {
                const e = t.parent;
                l.assert(e.nodeType === 11);
                if (t === e.d.expr) {
                  Va(e);
                } else {
                  for (const n of e.d.forIfNodes) {
                    Vn(n);
                    if (n === t) {
                      break;
                    }
                  }
                }
                return;
              }
            case 24:
              Fa(t);
              return;
            case 26:
              Ea(t);
              return;
            case 25:
              Oa(t);
              return;
            case 64:
              Ma(t);
              return;
          }
          t = t.parent;
        }
        l.fail('Unexpected statement');
      }
      function Ba(e, t) {
        let n = Pe(e);
        if (n && !n.typeResult.isIncomplete) {
          const e = n.typeResult;
          if (H.isFunction(e.type) && H.FunctionType.isPartiallyEvaluated(e.type) || H.isClass(e.type) && H.ClassType.isPartiallyEvaluated(e.type)) {
            return {
              ...e,
              isIncomplete: true
            };
          } else {
            return e;
          }
        }
        t();
        n = Pe(e);
        if (n) {
          return n.typeResult;
        }
      }
      function ja(e, t) {
        let n = fe.get(e);
        if (n) {
          const e = n.find(e => t && e.typeAtStart ? !t.isIncomplete == !e.typeAtStart.isIncomplete && H.isTypeSame(t.type, e.typeAtStart.type) : !t && !e.typeAtStart);
          if (e) {
            return e.codeFlowAnalyzer;
          }
        }
        const a = ts.createCodeFlowAnalyzer();
        if (n) {
          n.push({
            typeAtStart: t,
            codeFlowAnalyzer: a
          });
        } else {
          n = [{
            typeAtStart: t,
            codeFlowAnalyzer: a
          }];
          fe.set(e, n);
        }
        return a;
      }
      function qa(e, t, n) {
        var a;
        const r = _.createKeyForReference(e);
        const s = M.getExecutionScopeNode((a = t == null ? undefined : t.parent) !== null && a !== undefined ? a : e);
        const i = v.getCodeFlowExpressions(s);
        if (!i || !i.has(r) && !i.has(_.wildcardImportReferenceKey)) {
          return b.FlowNodeTypeResult.create(undefined, false);
        }
        if (yt(e)) {
          return b.FlowNodeTypeResult.create(undefined, true);
        }
        let o;
        o = Me(s) ? function () {
          const e = ke.length;
          l.assert(e > 0);
          return ke[e - 1].codeFlowAnalyzer;
        }() : ja(s.id, n == null ? undefined : n.typeAtStart);
        const p = v.getFlowNode(t ?? e);
        if (p === undefined) {
          return b.FlowNodeTypeResult.create(undefined, false);
        } else {
          return o.getTypeFromCodeFlow(p, e, n);
        }
      }
      function Ga(e, t, n, a) {
        let r = true;
        if (H.ClassType.isSpecialBuiltIn(e)) {
          const s = e.priv.aliasName || e.shared.name;
          switch (s) {
            case 'Callable':
              return {
                type: Bn(e, t, a)
              };
            case 'Never':
            case 'NoReturn':
              {
                if (t && t.length > 0) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsExpectingNone().format({
                    name: s
                  }), t[0].node);
                }
                let n = s === 'Never' ? H.NeverType.createNever() : H.NeverType.createNoReturn();
                n = H.TypeBase.cloneAsSpecialForm(n, e);
                if (Zr(a)) {
                  n = H.TypeBase.cloneWithTypeForm(n, Z.convertToInstance(n));
                }
                return {
                  type: n
                };
              }
            case 'Optional':
              return {
                type: jn(e, a, t, n)
              };
            case 'Type':
              {
                let n = ea(e, t, 1, undefined, false);
                if (H.isInstantiableClass(n)) {
                  n = Z.explodeGenericClass(n);
                }
                if (Zr(a)) {
                  n = H.TypeBase.cloneWithTypeForm(n, Z.convertToInstance(n));
                }
                return {
                  type: n
                };
              }
            case 'ClassVar':
              return {
                type: Wn(e, a, t, n)
              };
            case 'Protocol':
              if (n & 67109120) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.protocolNotAllowed(), a);
              }
              if (t != null) {
                t.forEach(e => {
                  if (!!e.typeList || !H.isTypeVar(e.type)) {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.protocolTypeArgMustBeTypeParam(), e.node);
                  }
                });
              }
              return {
                type: ea(e, t, undefined, true)
              };
            case 'TypedDict':
              if (n & 67109120) {
                if (!v.getFileInfo(a).diagnosticRuleSet.enableExperimentalFeatures || !t) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typedDictNotAllowed(), a);
                }
              }
              r = false;
              break;
            case 'Literal':
              if (n & 67109120) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.literalNotAllowed(), a);
              }
              r = false;
              break;
            case 'Tuple':
              return {
                type: ea(e, t, undefined, false, false)
              };
            case 'Union':
              return {
                type: ta(e, a, t, n)
              };
            case 'Generic':
              return {
                type: na(e, a, t, n)
              };
            case 'Final':
              return {
                type: Jn(e, a, t, n)
              };
            case 'Annotated':
              return Xn(e, a, t, n);
            case 'Concatenate':
              return {
                type: Qn(e, a, t, n)
              };
            case 'TypeGuard':
            case 'TypeIs':
              return {
                type: $n(e, a, t, n)
              };
            case 'Unpack':
              return {
                type: Yn(e, a, t, n)
              };
            case 'Required':
            case 'NotRequired':
            case 'ReadOnly':
              return Zn(e, a, t, n);
            case 'Self':
              return {
                type: Hn(e, a, t, n)
              };
            case 'LiteralString':
              return {
                type: ea(e, t, 0)
              };
            case 'TypeForm':
              return {
                type: Kn(e, a, t)
              };
          }
        }
        const s = v.getFileInfo(a);
        if (s.isStubFile || u.PythonVersion.isGreaterOrEqualTo(s.executionEnvironment.pythonVersion, u.pythonVersion3_9) || T.isAnnotationEvaluationPostponed(v.getFileInfo(a)) || n & 4) {
          if (H.ClassType.isBuiltIn(e, 'type') && t) {
            if (t.length >= 1 && (H.isFunction(t[0].type) || H.isOverloaded(t[0].type))) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeAnnotationWithCallable(), t[0].node);
              return {
                type: H.UnknownType.create()
              };
            }
            if ((Ae == null ? undefined : Ae.typeClass) && H.isInstantiableClass(Ae.typeClass)) {
              let e = ea(Ae.typeClass, t, 1, undefined, false);
              if (H.isInstantiableClass(e)) {
                e = Z.explodeGenericClass(e);
              }
              if (Zr(a)) {
                e = H.TypeBase.cloneWithTypeForm(e, Z.convertToInstance(e));
              }
              return {
                type: e
              };
            }
          }
          if (Z.isTupleClass(e)) {
            let n = ea(e, t, undefined, undefined, false);
            if (Zr(a)) {
              n = H.TypeBase.cloneWithTypeForm(n, Z.convertToInstance(n));
            }
            return {
              type: n
            };
          }
        }
        let i = t ? t.length : 0;
        const o = H.ClassType.isPseudoGenericClass(e) ? [] : H.ClassType.getTypeParams(e);
        if (o.length === 0 && i === 0) {
          return {
            type: e
          };
        }
        const c = o.findIndex(e => H.isTypeVarTuple(e));
        if (t) {
          let n = o.length;
          const s = o.findIndex(e => !!e.shared.isDefaultExplicit);
          if (s >= 0) {
            n = s;
          }
          if (t.length > 0 && t[0].inlinedTypeDict) {
            if (t.length > 1) {
              kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsTooMany().format({
                name: e.priv.aliasName || e.shared.name,
                expected: 1,
                received: i
              }), t[1].node);
            }
            return {
              type: t[0].inlinedTypeDict
            };
          }
          if (i > o.length) {
            if (!H.ClassType.isPartiallyEvaluated(e) && !H.ClassType.isTupleClass(e)) {
              if (o.length === 0) {
                r = false;
                kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsExpectingNone().format({
                  name: e.priv.aliasName || e.shared.name
                }), t[o.length].node);
              } else {
                if (o.length !== 1 || !H.isParamSpec(o[0])) {
                  r = false;
                  kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsTooMany().format({
                    name: e.priv.aliasName || e.shared.name,
                    expected: o.length,
                    received: i
                  }), t[o.length].node);
                }
              }
              i = o.length;
            }
          } else {
            if (i < n) {
              r = false;
              kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsTooFew().format({
                name: e.priv.aliasName || e.shared.name,
                expected: n,
                received: i
              }), t.length > 0 ? t[0].node.parent : a);
            }
          }
          t.forEach((e, t) => {
            var n;
            if (!((n = e.type.props) === null || n === undefined ? undefined : n.typeForm)) {
              r = false;
            }
            if (t === c) {
              if (H.isClassInstance(e.type) && Z.isTupleClass(e.type)) {
                return;
              }
              if (H.isTypeVarTuple(e.type)) {
                if (!Gt(e.type, e.node)) {
                  r = false;
                }
                return;
              }
            }
            const a = t < o.length ? o[t] : undefined;
            if (!Ln(e, {
              allowParamSpec: true,
              allowTypeArgList: a && H.isParamSpec(a)
            })) {
              r = false;
            }
          });
        }
        let m = [];
        const y = H.ClassType.getTypeParams(e);
        if (!(t = Wa(y, t, a))) {
          r = false;
        }
        const h = new k.ConstraintTracker();
        y.forEach((n, a) => {
          if (t && a < t.length) {
            if (H.isParamSpec(n)) {
              const e = t[a];
              const r = H.FunctionType.createSynthesizedInstance('', 65536);
              if (Z.isEllipsisType(e.type)) {
                H.FunctionType.addDefaultParams(r);
                r.shared.flags |= 32768;
                m.push(r);
                h.setBounds(n, r);
                return;
              }
              if (e.typeList) {
                e.typeList.forEach((e, t) => {
                  H.FunctionType.addParam(r, H.FunctionParam.create(0, Z.convertToInstance(e.type), H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${t}`));
                });
                if (e.typeList.length > 0) {
                  H.FunctionType.addPositionOnlyParamSeparator(r);
                }
                m.push(r);
                h.setBounds(n, r);
                return;
              }
              if (H.isInstantiableClass(e.type) && H.ClassType.isBuiltIn(e.type, 'Concatenate')) {
                const t = e.type.priv.typeArgs;
                if (t && t.length > 0) {
                  t.forEach((e, n) => {
                    if (n === t.length - 1) {
                      if (H.isParamSpec(e)) {
                        H.FunctionType.addParamSpecVariadics(r, e);
                      } else {
                        if (Z.isEllipsisType(e)) {
                          H.FunctionType.addDefaultParams(r);
                          r.shared.flags |= 32768;
                        }
                      }
                    } else {
                      H.FunctionType.addParam(r, H.FunctionParam.create(0, e, H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${n}`));
                    }
                  });
                }
                m.push(r);
                return;
              }
            }
            const e = Z.convertToInstance(t[a].type);
            m.push(e);
            h.setBounds(n, e);
            return;
          }
          const r = Xe(n, h, {
            replaceUnsolved: {
              scopeIds: Z.getTypeVarScopeIds(e),
              tupleClassType: ot()
            }
          });
          m.push(r);
          h.setBounds(n, r);
        });
        m = m.map((a, s) => {
          if (s < i) {
            const i = new p.DiagnosticAddendum();
            let c = function (e, t, n) {
              if (H.isAnyOrUnknown(t)) {
                return t;
              }
              let a = Z.transformPossibleRecursiveTypeAlias(t);
              if (H.isTypeVar(t)) {
                if (H.isTypeSame(t, e)) {
                  return t;
                }
                a = Pt(t);
              }
              if (H.isClass(a) && H.ClassType.isPartiallyEvaluated(a)) {
                return t;
              }
              if (e.shared.boundType && !Z.isTypeAliasPlaceholder(a) && !Ir(e.shared.boundType, a, n.createAddendum(), undefined)) {
                if (!e.shared.isSynthesized) {
                  n.addMessage(g.LocAddendum.typeBound().format({
                    sourceType: Yr(a),
                    destType: Yr(e.shared.boundType),
                    name: H.TypeVarType.getReadableName(e)
                  }));
                }
                return;
              }
              if (H.isParamSpec(e)) {
                if (H.isParamSpec(t) || H.isFunction(t) && H.FunctionType.isParamSpecValue(t) || H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'Concatenate')) {
                  return t;
                } else {
                  n.addMessage(g.LocAddendum.typeParamSpec().format({
                    type: Yr(t),
                    name: H.TypeVarType.getReadableName(e)
                  }));
                  return;
                }
              }
              if (H.isParamSpec(t)) {
                n.addMessage(g.LocMessage.paramSpecContext());
                return;
              }
              const r = e.shared.constraints;
              if (r.length === 0) {
                return t;
              }
              if (Z.isTypeAliasPlaceholder(t)) {
                return t;
              }
              if (H.isTypeVar(t) && H.TypeVarType.hasConstraints(t)) {
                if (t.shared.constraints.every(e => r.some(t => Ir(t, e)))) {
                  return t;
                }
              } else {
                let e;
                for (const t of r) {
                  if (Ir(t, a)) {
                    if ((!H.isNever(a) || !!H.isNever(t)) && (!e || !!Ir(e, t))) {
                      e = t;
                    }
                  }
                }
                if (e) {
                  return e;
                }
              }
              n.addMessage(g.LocAddendum.typeConstrainedTypeVar().format({
                type: Yr(t),
                name: H.TypeVarType.getReadableName(e)
              }));
              return;
            }(o[s], a, i);
            if (c && n & 16384) {
              const t = o[s].shared.declaredVariance;
              if (!Z.isVarianceOfTypeArgCompatible(c, t)) {
                i.addMessage(g.LocAddendum.varianceMismatchForClass().format({
                  typeVarName: Yr(c),
                  className: e.shared.name
                }));
                c = undefined;
              }
            }
            if (c) {
              a = c;
            } else {
              if (!H.isClassInstance(a) || !H.ClassType.isPartiallyEvaluated(a)) {
                l.assert(t !== undefined);
                r = false;
                kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeVarAssignmentMismatch().format({
                  type: Yr(a),
                  name: H.TypeVarType.getReadableName(o[s])
                }) + i.getString(), t[s].node);
              }
            }
          }
          return a;
        });
        if (t && e.shared.typeParams.length === 0 && H.ClassType.isPartiallyEvaluated(e)) {
          m = t.map(e => Z.convertToInstance(e.type));
        }
        let f = H.ClassType.specialize(e, m, t !== undefined);
        if (Zr(a)) {
          f = H.TypeBase.cloneWithTypeForm(f, r ? Z.convertToInstance(f) : undefined);
        }
        return {
          type: f
        };
      }
      function Wa(e, t, n) {
        if (e.length !== 1 || !H.isParamSpec(e[0]) || !t) {
          return t;
        }
        if (t.length > 1) {
          for (const e of t) {
            if (H.isParamSpec(e.type)) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.paramSpecContext(), e.node);
              return;
            }
            if (Z.isEllipsisType(e.type)) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisContext(), e.node);
              return;
            }
            if (H.isInstantiableClass(e.type) && H.ClassType.isBuiltIn(e.type, 'Concatenate')) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.concatenateContext(), e.node);
              return;
            }
            if (e.typeList) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgListNotAllowed(), e.node);
              return;
            }
          }
        }
        if (t.length === 1) {
          if (t[0].typeList) {
            return t;
          }
          const e = t[0].type;
          if (H.isParamSpec(e) || Z.isEllipsisType(e)) {
            return t;
          }
          if (H.isInstantiableClass(e) && H.ClassType.isBuiltIn(e, 'Concatenate')) {
            return t;
          }
        }
        return [{
          type: H.UnknownType.create(),
          node: t.length > 0 ? t[0].node : n,
          typeList: t
        }];
      }
      function Ka(e, t) {
        var n;
        var a;
        if (e.typeResult) {
          const t = e.typeResult.type;
          return {
            type: (a = (n = t == null ? undefined : t.props) === null || n === undefined ? undefined : n.specialForm) !== null && a !== undefined ? a : t,
            isIncomplete: e.typeResult.isIncomplete
          };
        }
        if (e.valueExpression) {
          return qe(e.valueExpression, undefined, t);
        } else {
          return {
            type: H.UnknownType.create()
          };
        }
      }
      function $a(e, t) {
        if (e.typeResult) {
          return {
            type: e.typeResult.type,
            isIncomplete: e.typeResult.isIncomplete
          };
        } else {
          l.assert(e.valueExpression !== undefined);
          return Ha(e.valueExpression, t);
        }
      }
      function Ha(e, t) {
        let n = 136;
        if (t == null ? undefined : t.allowTypeVarsWithoutScopeId) {
          n |= 4096;
        }
        if (t == null ? undefined : t.typeVarGetsCurScope) {
          n |= 8192;
        }
        if (t == null ? undefined : t.enforceClassTypeVarScope) {
          n |= -2147483648;
        }
        const a = v.getFileInfo(e);
        if (T.isAnnotationEvaluationPostponed(a) || (t == null ? undefined : t.forwardRefs)) {
          n |= 4;
        } else {
          if (t == null ? undefined : t.parsesStringLiteral) {
            n |= 16777216;
          }
        }
        if (!(t == null ? undefined : t.allowFinal)) {
          n |= 16;
        }
        if (t == null ? undefined : t.allowRequired) {
          n |= 1048832;
        }
        if (t == null ? undefined : t.allowReadOnly) {
          n |= 2097408;
        }
        if (t == null ? undefined : t.allowUnpackedTuple) {
          n |= 4194304;
        } else {
          n |= 64;
        }
        if (t == null ? undefined : t.allowUnpackedTypedDict) {
          n |= 8388608;
        }
        if (!(t == null ? undefined : t.allowParamSpec)) {
          n |= 32;
        }
        if (t == null ? undefined : t.typeExpression) {
          n |= 256;
        }
        if (t == null ? undefined : t.convertEllipsisToAny) {
          n |= 1;
        }
        if (t == null ? undefined : t.allowEllipsis) {
          n |= 65536;
        }
        if (t == null ? undefined : t.noNonTypeSpecialForms) {
          n |= 67108864;
        }
        if (!(t == null ? undefined : t.allowClassVar)) {
          n |= 131072;
        }
        if (t == null ? undefined : t.varTypeAnnotation) {
          n |= 32768;
        }
        if (t == null ? undefined : t.notParsed) {
          n |= 524288;
        }
        if (t == null ? undefined : t.typeFormArg) {
          n |= 1073741824;
        }
        return qe(e, n);
      }
      function Za(e, t) {
        const n = V.getScopeForNode(e);
        if (n) {
          const e = V.getBuiltInScope(n).lookUpSymbol(t);
          if (e) {
            return cr(e);
          }
        }
        return H.UnknownType.create();
      }
      function Ya(e, t, n) {
        const a = Za(e, t);
        if (H.isInstantiableClass(a)) {
          let e = a;
          if (n) {
            e = H.ClassType.specialize(e, n);
          }
          return H.ClassType.cloneAsInstance(e);
        }
        return a;
      }
      function Ja(e, t, n, a = false) {
        var r;
        const s = M.getEvaluationScopeNode(e);
        const i = v.getScope(s.node);
        let o = i == null ? undefined : i.lookUpSymbolRecursive(t, {
          useProxyScope: !!s.useProxyScope
        });
        const l = (r = i == null ? undefined : i.type) !== null && r !== undefined ? r : 4;
        let p = l !== 2 && l !== 1;
        if ((o == null ? undefined : o.scope.type) === 0) {
          p = false;
        }
        if (o && n && p) {
          if (!o.symbol.getDeclarations().find(n => {
            if (n.type !== 8 && n.type !== 0) {
              let a = M.getExecutionScopeNode(e);
              const r = n.type === 6 || n.type === 5 || n.type === 4 ? n.node.d.name : n.node;
              const s = M.getExecutionScopeNode(r);
              const i = v.getScope(a);
              if (i == null ? undefined : i.proxy) {
                const e = v.getScope(a);
                if (!(e == null ? undefined : e.symbolTable.has(t)) && a.parent) {
                  a = M.getExecutionScopeNode(a.parent);
                }
              }
              if (a === s && !vt(r, e)) {
                const t = v.getFlowNode(e);
                return !t || ts.getFlowNodeReachability(t, undefined, true) !== K.Reachability.Reachable;
              }
            }
            return true;
          })) {
            if (o.scope.type !== 2) {
              let e = o.scope.parent;
              const n = o.isOutsideCallerModule || o.scope.type === 4;
              let a = o.isBeyondExecutionScope || o.scope.isIndependentlyExecutable();
              if (o.scope.type === 3) {
                const t = o.scope.getGlobalScope();
                e = t.scope;
                if (t.isBeyondExecutionScope) {
                  a = true;
                }
              }
              o = e ? e.lookUpSymbolRecursive(t, {
                isOutsideCallerModule: n,
                isBeyondExecutionScope: a
              }) : undefined;
            } else {
              o = undefined;
            }
          }
        }
        if (o && a) {
          let e = o;
          while (e.scope.type !== 4 && e.scope.type !== 5 && e.scope.type !== 0 && e.scope.parent && (e = e.scope.parent.lookUpSymbolRecursive(t, {
            isOutsideCallerModule: e.isOutsideCallerModule,
            isBeyondExecutionScope: e.isBeyondExecutionScope || e.scope.isIndependentlyExecutable()
          }), e));
          if ((e == null ? undefined : e.scope.type) === 4 || (e == null ? undefined : e.scope.type) === 5) {
            o = e;
          }
        }
        return o;
      }
      function Qa(e, t, n) {
        me.push({
          node: e,
          suppressedDiags: n ? [] : undefined
        });
        try {
          const e = t();
          const a = me.pop();
          if (n && (a == null ? undefined : a.suppressedDiags)) {
            n(a.suppressedDiags);
          }
          return e;
        } catch (e) {
          me.pop();
          throw e;
        }
      }
      function Xa(e) {
        for (let t = Se.length - 1; t >= 0; t--) {
          const n = Se[t].rootNode;
          if (M.isNodeContainedWithin(e, n)) {
            return Se[t].tracker;
          }
        }
      }
      function er(e, t) {
        const n = Xa(e);
        try {
          if (!n) {
            Se.push({
              tracker: new Z.UniqueSignatureTracker(),
              rootNode: e
            });
          }
          const a = t();
          if (!n) {
            Se.pop();
          }
          return a;
        } catch (e) {
          if (!n) {
            Se.pop();
          }
          throw e;
        }
      }
      function tr(e, t) {
        const n = Xa(t);
        if (n && (H.isFunction(e) || H.isOverloaded(e))) {
          return Z.ensureSignaturesAreUnique(e, n, t.start);
        } else {
          return e;
        }
      }
      function nr(e, t, n) {
        if (!e) {
          return t();
        }
        ue.enterSpeculativeContext(e, n);
        try {
          const e = t();
          ue.leaveSpeculativeContext();
          return e;
        } catch (e) {
          ue.leaveSpeculativeContext();
          throw e;
        }
      }
      function ar(e) {
        return ue.isSpeculative(e);
      }
      function rr(e, t) {
        if (H.isFunction(e) && e.shared.declaration) {
          const n = e.shared.declaration;
          if (n.type === 5) {
            const a = n.node;
            const r = v.getScope(a);
            if (r) {
              const n = r.lookUpSymbol(t);
              if (n) {
                return n.getDeclarations().find(e => e.type === 2);
              }
              const a = E.getParamListDetails(e);
              if (a.unpackedKwargsTypedDictType) {
                const e = Z.lookUpClassMember(a.unpackedKwargsTypedDictType, t);
                if (e) {
                  return e.symbol.getDeclarations().find(e => e.type === 1);
                }
              }
            }
          }
        }
      }
      function sr(e) {
        if (e.parent && e.parent.nodeType === 26 && e.parent.d.alias && e === e.parent.d.name) {
          return e.parent.d.alias;
        }
      }
      function ir(e) {
        var t;
        var n;
        var a;
        switch (e.type) {
          case 0:
            {
              if (e.intrinsicType === 'Any') {
                return {
                  type: H.AnyType.create()
                };
              }
              if (e.intrinsicType === 'type[self]') {
                const t = ca(M.getEnclosingClass(e.node));
                return {
                  type: t ? Z.synthesizeTypeVarForSelfCls(t.classType, true) : H.UnknownType.create()
                };
              }
              const t = Ya(e.node, 'str');
              const n = Ya(e.node, 'int');
              if (H.isClassInstance(n) && H.isClassInstance(t)) {
                if (e.intrinsicType === 'str') {
                  return {
                    type: t
                  };
                }
                if (e.intrinsicType === 'str | None') {
                  return {
                    type: H.combineTypes([t, pt()])
                  };
                }
                if (e.intrinsicType === 'int') {
                  return {
                    type: n
                  };
                }
                if (e.intrinsicType === 'Iterable[str]') {
                  const n = Za(e.node, 'Iterable');
                  if (H.isInstantiableClass(n)) {
                    return {
                      type: H.ClassType.cloneAsInstance(H.ClassType.specialize(n, [t]))
                    };
                  }
                }
                if (e.intrinsicType === 'Dict[str, Any]') {
                  const n = Za(e.node, 'dict');
                  if (H.isInstantiableClass(n)) {
                    return {
                      type: H.ClassType.cloneAsInstance(H.ClassType.specialize(n, [t, H.AnyType.create()]))
                    };
                  }
                }
              }
              return {
                type: H.UnknownType.create()
              };
            }
          case 6:
            {
              const t = ca(e.node);
              return {
                type: t == null ? undefined : t.decoratedType
              };
            }
          case 7:
            return {
              type: Ze(e.node.d.annotation)
            };
          case 5:
            {
              const t = va(e.node);
              return {
                type: t == null ? undefined : t.decoratedType
              };
            }
          case 4:
            return {
              type: oa(e.node)
            };
          case 2:
            {
              let a = (t = e.node.d.annotation) !== null && t !== undefined ? t : e.node.d.annotationComment;
              if (!a && ((n = e.node.parent) === null || n === undefined ? undefined : n.nodeType) === 31) {
                const t = e.node.parent;
                if (t.d.funcAnnotationComment && !t.d.funcAnnotationComment.d.isEllipsis) {
                  const n = t.d.params.findIndex(t => t === e.node);
                  a = M.getTypeAnnotationForParam(t, n);
                }
              }
              if (a) {
                let t = He(a, e.node.d.category);
                const n = M.getTypeVarScopesForNode(e.node);
                t = Z.makeTypeVarsBound(t, n);
                return {
                  type: wa(e.node, e.node.d.category, Ca(e.node, t))
                };
              }
              return {
                type: undefined
              };
            }
          case 3:
            return {
              type: or(e.node)
            };
          case 1:
            {
              const t = e.typeAnnotationNode;
              if (t) {
                let n;
                if (e.isRuntimeTypeExpression) {
                  n = Z.convertToInstance(Ha(t, {
                    allowFinal: true,
                    allowRequired: true,
                    allowReadOnly: true
                  }).type);
                } else {
                  const r = e.isDefinedByMemberAccess && ((a = e.node.parent) === null || a === undefined ? undefined : a.nodeType) === 35 ? e.node.parent : e.node;
                  const s = M.isClassVarAllowedForAssignmentTarget(r);
                  const i = M.isFinalAllowedForAssignmentTarget(r);
                  const o = M.isRequiredAllowedForAssignmentTarget(r) || !!e.isInInlinedTypedDict;
                  n = Ze(t, {
                    varTypeAnnotation: true,
                    allowClassVar: s,
                    allowFinal: i,
                    allowRequired: o,
                    allowReadOnly: o,
                    enforceClassTypeVarScope: e.isDefinedByMemberAccess
                  });
                }
                if (n) {
                  if (e.isDefinedByMemberAccess) {
                    const t = M.getEnclosingClass(e.node);
                    if (t) {
                      n = Z.makeTypeVarsFree(n, [M.getScopeIdForNode(t)]);
                    }
                  }
                  if (H.isClassInstance(n) && H.ClassType.isBuiltIn(n, 'TypeAlias')) {
                    return {
                      type: undefined,
                      isTypeAlias: true
                    };
                  } else {
                    return {
                      type: n
                    };
                  }
                }
              }
              return {
                type: undefined
              };
            }
          case 8:
            return {
              type: undefined
            };
        }
      }
      function or(e) {
        const t = Ne(e.d.name, 0);
        if (t && H.isTypeVar(t)) {
          return t;
        }
        let n = 'TypeVar';
        let a = H.TypeVarKind.TypeVar;
        if (e.d.typeParamKind === h.TypeParamKind.TypeVarTuple) {
          n = 'TypeVarTuple';
          a = H.TypeVarKind.TypeVarTuple;
        } else {
          if (e.d.typeParamKind === h.TypeParamKind.ParamSpec) {
            n = 'ParamSpec';
            a = H.TypeVarKind.ParamSpec;
          }
        }
        const r = ct(e, n);
        const s = r && H.isInstantiableClass(r) ? r : undefined;
        let i = H.TypeVarType.createInstantiable(e.d.name.d.value, a);
        if (s) {
          i = H.TypeBase.cloneAsSpecialForm(i, H.ClassType.cloneAsInstance(s));
        }
        i.shared.isTypeParamSyntax = true;
        Fe(e, {
          type: i
        }, undefined);
        Fe(e.d.name, {
          type: i
        }, undefined);
        if (e.d.boundExpr) {
          if (e.d.boundExpr.nodeType === 52) {
            const t = e.d.boundExpr.d.items.map(e => {
              const t = Ha(e, {
                noNonTypeSpecialForms: true,
                forwardRefs: true,
                typeExpression: true
              }).type;
              if (Z.requiresSpecialization(t, {
                ignorePseudoGeneric: true,
                ignoreImplicitTypeArgs: true
              })) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarBoundGeneric(), e);
              }
              return Z.convertToInstance(t);
            });
            if (t.length < 2) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarSingleConstraint(), e.d.boundExpr);
            } else {
              if (e.d.typeParamKind === h.TypeParamKind.TypeVar) {
                i.shared.constraints = t;
              }
            }
          } else {
            const t = Ha(e.d.boundExpr, {
              noNonTypeSpecialForms: true,
              forwardRefs: true,
              typeExpression: true
            }).type;
            if (Z.requiresSpecialization(t, {
              ignorePseudoGeneric: true
            })) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarConstraintGeneric(), e.d.boundExpr);
            }
            if (e.d.typeParamKind === h.TypeParamKind.TypeVar) {
              i.shared.boundType = Z.convertToInstance(t);
            }
          }
        }
        if (e.d.typeParamKind === h.TypeParamKind.ParamSpec) {
          const t = e.d.defaultExpr ? wn(e.d.defaultExpr, true) : undefined;
          if (t) {
            i.shared.defaultType = t;
            i.shared.isDefaultExplicit = true;
          } else {
            i.shared.defaultType = H.ParamSpecType.getUnknown();
          }
        } else {
          if (e.d.typeParamKind === h.TypeParamKind.TypeVarTuple) {
            const t = e.d.defaultExpr ? In(e.d.defaultExpr, true) : undefined;
            if (t) {
              i.shared.defaultType = t;
              i.shared.isDefaultExplicit = true;
            } else {
              i.shared.defaultType = q.makeTupleObject(es, [{
                type: H.UnknownType.create(),
                isUnbounded: true
              }]);
            }
          } else {
            const t = e.d.defaultExpr ? Z.convertToInstance(Ha(e.d.defaultExpr, {
              forwardRefs: true,
              typeExpression: true
            }).type) : undefined;
            if (t) {
              i.shared.defaultType = t;
              i.shared.isDefaultExplicit = true;
            } else {
              i.shared.defaultType = H.UnknownType.create();
            }
          }
        }
        if (i.shared.isDefaultExplicit && e.d.defaultExpr) {
          _n(i, e.d.defaultExpr);
        }
        const o = M.getTypeVarScopeNode(e);
        if (o) {
          let e;
          if (o.nodeType === 10) {
            e = 0;
            i.shared.declaredVariance = H.isParamSpec(i) || H.isTypeVarTuple(i) ? 2 : 0;
          } else {
            if (o.nodeType === 31) {
              e = 1;
            } else {
              l.assert(o.nodeType === 77);
              e = 2;
              i.shared.declaredVariance = H.isParamSpec(i) || H.isTypeVarTuple(i) ? 2 : 0;
            }
          }
          i = H.TypeVarType.cloneForScopeId(i, M.getScopeIdForNode(o.nodeType === 77 ? o.d.name : o), o.d.name.d.value, e);
        }
        Fe(e, {
          type: i
        }, undefined);
        Fe(e.d.name, {
          type: i
        }, undefined);
        return i;
      }
      function lr(t, a) {
        var r;
        var s;
        var i;
        const o = pr(a, true, {
          allowExternallyHiddenAccess: v.getFileInfo(a.node).isStubFile
        });
        if (!o) {
          if (n.evaluateUnknownImportsAsAny) {
            return H.AnyType.create();
          } else {
            return H.UnknownType.create();
          }
        }
        function p(e, t, a) {
          if (!t.uri.isEmpty() && t.loadSymbolsFromPath) {
            const r = a(t.uri);
            if (r) {
              e.priv.fields = r.symbolTable;
              e.priv.docString = r.docString;
            } else {
              e.priv.notPresentFieldType = n.evaluateUnknownImportsAsAny ? H.AnyType.create() : H.UnknownType.create();
            }
          }
          if (t.implicitImports) {
            t.implicitImports.forEach((t, n) => {
              let r;
              if (t.isUnresolved) {
                r = H.UnknownType.create();
              } else {
                const s = e.priv.moduleName ? e.priv.moduleName + '.' + n : '';
                r = p(H.ModuleType.create(s, t.uri), t, a);
              }
              const s = L.Symbol.createWithType(0, r);
              e.priv.loaderFields.set(n, s);
            });
          }
          return e;
        }
        if (o.type === 8) {
          const t = H.ModuleType.create(o.moduleName, o.uri);
          if (o.symbolName && o.submoduleFallback) {
            return p(t, o.submoduleFallback, e);
          } else {
            return p(t, o, e);
          }
        }
        const d = ir(o);
        if (d.type) {
          return d.type;
        }
        const c = v.getFileInfo(o.node);
        let u = !c.isInPyTypedPackage || c.isStubFile;
        if (!u && o.type === 1) {
          const e = M.getEnclosingClass(o.node, true);
          if (e) {
            const t = ca(e);
            if (t && H.ClassType.isEnumClass(t.classType)) {
              u = true;
            }
          }
          if (Lr(o) || o.isConstant) {
            u = true;
          }
          if (((r = o.inferredTypeSource) === null || r === undefined ? undefined : r.nodeType) === 9) {
            const e = qe(o.inferredTypeSource.d.leftExpr, 2).type;
            const t = ['TypeVar', 'ParamSpec', 'TypeVarTuple', 'TypedDict', 'NamedTuple', 'NewType', 'TypeAliasType'];
            if (H.isInstantiableClass(e) && H.ClassType.isBuiltIn(e, t) || H.isFunction(e) && t.some(t => H.FunctionType.isBuiltIn(e, t))) {
              u = true;
            }
          }
        }
        if (o.type === 2) {
          l.assert(o.node.d.name !== undefined);
          if ((s = Ba(o.node.d.name, () => {
            Ra(o.node);
          })) === null || s === undefined) {
            return undefined;
          } else {
            return s.type;
          }
        }
        if (o.type === 1 && o.inferredTypeSource) {
          const e = Br(o) || Wr(o);
          const n = e && o.inferredTypeSource.parent ? o.inferredTypeSource.parent : o.inferredTypeSource;
          let r = (i = Ba(o.node, () => {
            La(n);
          })) === null || i === undefined ? undefined : i.type;
          if (r && e && o.typeAliasName && Gr(r)) {
            const e = ia(o.typeAliasName, false);
            r = aa(r, o.node, e, false);
            u = true;
          }
          if (r && c.isInPyTypedPackage && !c.isStubFile) {
            if (!u) {
              if (function (e, t, n) {
                var a;
                const r = e.getDeclarations().filter(e => e.type !== 1 || !e.isInferenceAllowedInPyTyped);
                if (r.length > 1) {
                  return false;
                }
                if (t.type !== 1) {
                  return false;
                }
                if (r.length === 0) {
                  return true;
                }
                if (H.isTypeVar(n)) {
                  return true;
                }
                let s;
                const i = t.node.parent;
                if (i) {
                  if (i.nodeType === 3) {
                    s = i;
                  } else {
                    if (i.nodeType === 35 && ((a = i.parent) === null || a === undefined ? undefined : a.nodeType) === 3) {
                      s = i.parent;
                    }
                  }
                }
                if (!s) {
                  return false;
                }
                const o = qe(s.d.rightExpr).type;
                if (H.isClassInstance(o) && Z.isLiteralType(o)) {
                  return true;
                }
                if (s.d.rightExpr.nodeType === 38 && !H.TypeBase.isAmbiguous(o)) {
                  return true;
                }
                return false;
              }(t, a, r)) {
                u = true;
              }
            }
            if (!u) {
              r = H.TypeBase.cloneForAmbiguousType(r);
            }
          }
          return r;
        }
      }
      function pr(t, n, a) {
        var r;
        var s;
        var i;
        if ((i = A.resolveAliasDeclaration(e, t, {
          resolveLocalNames: n,
          allowExternallyHiddenAccess: (r = a == null ? undefined : a.allowExternallyHiddenAccess) !== null && r !== undefined && r,
          skipFileNeededCheck: (s = a == null ? undefined : a.skipFileNeededCheck) !== null && s !== undefined && s
        })) === null || i === undefined) {
          return undefined;
        } else {
          return i.declaration;
        }
      }
      function dr(t, n, a) {
        var r;
        var s;
        return A.resolveAliasDeclaration(e, t, {
          resolveLocalNames: n,
          allowExternallyHiddenAccess: (r = a == null ? undefined : a.allowExternallyHiddenAccess) !== null && r !== undefined && r,
          skipFileNeededCheck: (s = a == null ? undefined : a.skipFileNeededCheck) !== null && s !== undefined && s
        });
      }
      function cr(e) {
        return ur(e).type;
      }
      function ur(e, t, n = false) {
        let a;
        if (e.hasTypedDeclarations()) {
          a = yr(e, t);
          const n = a == null ? undefined : a.type;
          let r = false;
          if (n && (H.isFunction(n) && H.FunctionType.isPartiallyEvaluated(n) || H.isClass(n) && H.ClassType.isPartiallyEvaluated(n))) {
            r = true;
          }
          if (n || !a.isTypeAlias) {
            const t = e.getTypedDeclarations();
            return {
              type: n ?? H.UnknownType.create(),
              isIncomplete: r,
              includesVariableDecl: mr(t),
              includesIllegalTypeAliasDecl: !t.every(e => jr(e)),
              includesSpeculativeResult: false,
              isRecursiveDefinition: !n && !ue.isSpeculative(undefined)
            };
          }
        }
        return function (e, t, n = false) {
          let a = ve.get(e.id);
          const r = t ? t.id : undefined;
          const s = `${r === undefined ? '.' : r.toString()}${n ? '*' : ''}`;
          const i = a == null ? undefined : a.get(s);
          if (i && !i.isIncomplete) {
            return i;
          }
          const o = e.getDeclarations();
          let l;
          if (o.length > re) {
            const e = {
              type: H.UnknownType.create(),
              isIncomplete: false,
              includesVariableDecl: false,
              includesIllegalTypeAliasDecl: !o.every(e => jr(e)),
              includesSpeculativeResult: false,
              isRecursiveDefinition: false
            };
            y(e);
            return e;
          }
          if (n) {
            o.forEach((e, t) => {
              if (!e.isInExceptSuite) {
                l = t;
              }
            });
          } else {
            if (o.length > 1 && o.every(e => e.type === 8)) {
              const e = o.filter(e => e.type === 8 && !e.isInExceptSuite);
              if (e.length === 1) {
                l = o.findIndex(t => t === e[0]);
              }
            }
          }
          const p = [];
          let d = false;
          let c = false;
          let u = false;
          o.forEach((n, a) => {
            var r;
            var s;
            var i;
            const o = (r = pr(n, true, {
              allowExternallyHiddenAccess: v.getFileInfo(n.node).isStubFile
            })) !== null && r !== undefined ? r : n;
            if (!jr(o) && !Br(o)) {
              c = true;
            }
            if (mr([o])) {
              d = true;
            }
            if (l !== undefined && l !== a) {
              return;
            }
            if (u) {
              return;
            }
            if (j.isEffectivelyClassVar(e, false) && n.type === 1 && n.isDefinedByMemberAccess) {
              return;
            }
            if (t !== undefined && n.type !== 8) {
              if (M.getExecutionScopeNode(t) === M.getExecutionScopeNode(n.node)) {
                return;
              }
            }
            const m = Br(o);
            const y = m || Wr(o);
            if (m) {
              u = true;
            }
            if (y && o.type === 1 && ((i = (s = o.inferredTypeSource) === null || s === undefined ? undefined : s.parent) === null || i === undefined ? undefined : i.nodeType) === 3) {
              sa(o.inferredTypeSource.parent);
            }
            p.push(o);
          });
          const m = function (e, t, n) {
            var a;
            var r;
            const s = [];
            let i = false;
            let o = false;
            let l = false;
            t.forEach(t => {
              if (ze(e, t)) {
                try {
                  let n = lr(e, t);
                  if (!Ue(e)) {
                    i = true;
                  }
                  if (n) {
                    if (t.type === 1) {
                      let e = false;
                      if (t.type === 1 && (t.isConstant || Lr(t))) {
                        e = true;
                      }
                      if (H.isClassInstance(n) && H.ClassType.isEnumClass(n) && P.isDeclInEnumClass(es, t)) {
                        e = true;
                      }
                      if (!!H.TypeBase.isInstance(n) && !e && !Br(t)) {
                        n = Z.stripTypeForm($e(n));
                      }
                    }
                    s.push(n);
                    if (ar(t.node)) {
                      l = true;
                    }
                  } else {
                    i = true;
                  }
                } catch (t) {
                  Ue(e);
                  throw t;
                }
              } else {
                if (t.type === 6) {
                  const e = ca(t.node);
                  if (e == null ? undefined : e.decoratedType) {
                    s.push(e.decoratedType);
                  }
                }
                i = true;
                o = true;
              }
            });
            const p = ve.get(e.id);
            const d = ((r = (a = p == null ? undefined : p.get(n)) === null || a === undefined ? undefined : a.evaluationAttempts) !== null && r !== undefined ? r : 0) + 1;
            let c;
            if (s.length > 0) {
              i = o && d < se;
              c = H.combineTypes(s);
            } else {
              c = H.UnboundType.create();
            }
            return {
              type: c,
              isIncomplete: i,
              includesSpeculativeResult: l,
              evaluationAttempts: d
            };
          }(e, p, s);
          m.includesVariableDecl = d;
          m.includesIllegalTypeAliasDecl = c;
          if (!m.includesSpeculativeResult) {
            y(m);
          }
          return m;
          function y(t) {
            if (!a) {
              a = new Map();
              ve.set(e.id, a);
            }
            a.set(s, t);
          }
        }(e, t, n);
      }
      function mr(e) {
        return e.some(e => {
          if (e.type === 1) {
            const t = v.getFileInfo(e.node);
            if (!t.isTypingStubFile && !t.isTypingExtensionsStubFile) {
              return true;
            }
          }
          return e.type === 2;
        });
      }
      function yr(e, t) {
        var n;
        const a = (n = e.getSynthesizedType()) === null || n === undefined ? undefined : n.type;
        if (a) {
          return {
            type: a
          };
        }
        let r = e.getTypedDeclarations();
        if (r.length === 0) {
          if (e.getDeclarations().length > re) {
            return {
              type: H.UnknownType.create()
            };
          } else {
            return {
              type: undefined
            };
          }
        }
        if (t && r.length > 1) {
          if (r.length > pe) {
            r = [r[r.length - 1]];
          } else {
            const e = r.filter(e => {
              if (e.type !== 8) {
                if (M.getExecutionScopeNode(t) === M.getExecutionScopeNode(e.node) && !vt(e.node, t, false)) {
                  return false;
                }
              }
              return true;
            });
            if (e.length === 0) {
              return {
                type: H.UnboundType.create()
              };
            }
            r = e;
          }
        }
        let s = r.length - 1;
        while (s >= 0) {
          const t = r[s];
          const n = Re(e, t);
          if (n) {
            return {
              type: n
            };
          }
          if (Oe(e, t) < 0 && ze(e, t)) {
            try {
              const n = ir(t);
              if (Ue(e) || t.type === 6) {
                return n;
              }
            } catch (t) {
              Ue(e);
              throw t;
            }
          }
          s--;
        }
        return {
          type: undefined
        };
      }
      function gr(e) {
        if (H.isFunction(e)) {
          hr(e);
        } else {
          if (H.isOverloaded(e)) {
            H.OverloadedType.getOverloads(e).forEach(e => {
              hr(e);
            });
            const t = H.OverloadedType.getImplementation(e);
            if (t && H.isFunction(t)) {
              hr(t);
            }
          }
        }
      }
      function hr(e, t) {
        const n = H.FunctionType.getEffectiveReturnType(e, false);
        if (n && !H.isUnknown(n)) {
          return n;
        } else {
          if (t == null ? undefined : t.skipInferReturnType) {
            return H.UnknownType.create();
          } else {
            return Xr(e, t == null ? undefined : t.callSiteInfo);
          }
        }
      }
      function fr(e) {
        const t = va(e);
        const n = t == null ? undefined : t.functionType.shared.declaredReturnType;
        if (n) {
          if (H.FunctionType.isGenerator(t.functionType)) {
            return Z.getDeclaredGeneratorReturnType(t.functionType);
          } else {
            return n;
          }
        }
      }
      function Tr(e) {
        if (H.isInstantiableClass(e.classType)) {
          return Z.partiallySpecializeType(cr(e.symbol), e.classType, dt(), undefined);
        } else {
          return H.UnknownType.create();
        }
      }
      function vr(e, t, n, a) {
        if (H.isAnyOrUnknown(t.classType)) {
          return {
            type: t.classType,
            isIncomplete: false
          };
        }
        if (!H.isInstantiableClass(t.classType)) {
          return;
        }
        const r = ur(t.symbol);
        if (r) {
          if (a & 2048 && e) {
            r.type = zt(e, r.type, !!r.includesVariableDecl);
          }
          gr(r.type);
          if (e && n && H.isClass(n) && t.isInstanceMember && H.isClass(t.unspecializedClassType) && a & 1024 && Z.requiresSpecialization(r.type, {
            ignoreSelf: true,
            ignoreImplicitTypeArgs: true
          })) {
            const a = Z.partiallySpecializeType(r.type, t.unspecializedClassType, dt(), Z.selfSpecializeClass(n, {
              overrideTypeArgs: true
            }));
            if (H.findSubtype(a, e => !H.isFunction(e) && !H.isOverloaded(e) && Z.requiresSpecialization(e, {
              ignoreSelf: true,
              ignoreImplicitTypeArgs: true
            }))) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.genericInstanceVariableAccess(), e);
            }
          }
          return {
            type: Z.partiallySpecializeType(r.type, t.classType, dt(), n),
            isIncomplete: !!r.isIncomplete
          };
        }
      }
      function br(e, t, n, a, r, s, i) {
        if (H.ClassType.isHierarchyPartiallyEvaluated(e) || H.ClassType.isHierarchyPartiallyEvaluated(t)) {
          return true;
        }
        if (H.ClassType.isTypedDictClass(t)) {
          if (H.ClassType.isTypedDictClass(e) && !H.ClassType.isSameGenericClass(e, t)) {
            return !!W.assignTypedDictToTypedDict(es, e, t, n, a, r, s) && (H.ClassType.isFinal(e) !== H.ClassType.isFinal(t) ? (n == null || n.addMessage(g.LocAddendum.typedDictFinalMismatch().format({
              sourceType: Yr(Z.convertToInstance(t)),
              destType: Yr(Z.convertToInstance(e))
            })), false) : !(r & 1) || W.assignTypedDictToTypedDict(es, t, e, undefined, undefined, r, s));
          }
          if (H.ClassType.isBuiltIn(e, 'Mapping')) {
            const e = W.getTypedDictMappingEquivalent(es, t);
            if (e && (Ae == null ? undefined : Ae.mappingClass) && H.isInstantiableClass(Ae.mappingClass) && (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass)) {
              t = H.ClassType.specialize(Ae.mappingClass, [H.ClassType.cloneAsInstance(Ae.strClass), e]);
            }
          } else {
            if (H.ClassType.isBuiltIn(e, ['dict', 'MutableMapping'])) {
              const e = W.getTypedDictDictEquivalent(es, t, s);
              if (e && (Ae == null ? undefined : Ae.dictClass) && H.isInstantiableClass(Ae.dictClass) && Ae.strClass && H.isInstantiableClass(Ae.strClass)) {
                t = H.ClassType.specialize(Ae.dictClass, [H.ClassType.cloneAsInstance(Ae.strClass), e]);
              }
            }
          }
        }
        if (e.priv.includePromotions) {
          const n = J.get(e.shared.fullName);
          if (n && n.some(e => t.shared.mro.some(t => H.isClass(t) && e === t.shared.fullName)) && !(r & 1)) {
            return true;
          }
        }
        const o = [];
        const p = H.ClassType.isDerivedFrom(t, e, o);
        if (H.ClassType.isProtocolClass(e) && !p) {
          return !!U.assignClassToProtocol(es, e, H.ClassType.cloneAsInstance(t), n == null ? undefined : n.createAddendum(), a, r, s) || (n == null || n.addMessage(g.LocAddendum.protocolIncompatible().format({
            sourceType: Yr(Z.convertToInstance(t)),
            destType: Yr(Z.convertToInstance(e))
          })), false);
        }
        if ((!(r & 1) || H.ClassType.isSameGenericClass(t, e)) && p && (l.assert(o.length > 0), function (e, t, n, a, r, s, i) {
          let o;
          let l = t;
          ya(e);
          if (s & 1) {
            if (Z.isLiteralLikeType(t) !== Z.isLiteralLikeType(e)) {
              return false;
            }
          }
          for (let t = n.length - 1; t >= 0; t--) {
            const a = n[t];
            if (H.isUnknown(a)) {
              return !Z.isNoneTypeClass(e);
            }
            if (t < n.length - 1) {
              let e = l;
              if (H.ClassType.isBuiltIn(l, 'NamedTuple') && H.ClassType.isBuiltIn(a, 'tuple') && o) {
                e = o;
              }
              l = Z.specializeForBaseClass(e, a);
            }
            if (H.ClassType.getTypeParams(a).length !== 0) {
              if (!a.priv.typeArgs) {
                return true;
              }
              o = l;
            }
          }
          if (e.priv.tupleTypeArgs && l.priv.tupleTypeArgs) {
            return q.assignTupleTypeArgs(es, e, l, a, r, s, i);
          }
          if (e.priv.typeArgs) {
            return Cr(e, l, s & 1 ? undefined : a, r, s, i);
          }
          if (r && l.priv.typeArgs) {
            const t = l.priv.typeArgs;
            for (let n = 0; n < e.shared.typeParams.length; n++) {
              let a;
              const s = e.shared.typeParams[n];
              const i = H.TypeVarType.getVariance(s);
              a = l.priv.tupleTypeArgs ? Z.convertToInstance(q.makeTupleObject(es, l.priv.tupleTypeArgs, true)) : n < t.length ? t[n] : H.UnknownType.create();
              r.setBounds(s, i !== 4 ? a : undefined, i !== 3 ? a : undefined, true);
            }
          }
          return true;
        }(e, t, o, n == null ? undefined : n.createAddendum(), a, r, s))) {
          return true;
        }
        if (H.ClassType.isBuiltIn(e, 'object') && !(r & 1)) {
          return true;
        }
        if (n) {
          const a = i ? H.ClassType.cloneAsInstance(e) : e;
          const r = i ? H.ClassType.cloneAsInstance(t) : t;
          let s = Yr(a);
          let o = Yr(r);
          if (s === o && e.shared.fullName && t.shared.fullName) {
            s = e.shared.fullName;
            o = t.shared.fullName;
          }
          if (n != null) {
            n.addMessage(g.LocAddendum.typeIncompatible().format({
              sourceType: o,
              destType: s
            }));
          }
          if (H.ClassType.isBuiltIn(e, 'bytes')) {
            const a = J.get(e.shared.fullName);
            if (a && a.some(e => e === t.shared.fullName)) {
              if (n != null) {
                n.addMessage(g.LocAddendum.bytesTypePromotions());
              }
            }
          }
        }
        return false;
      }
      function _r(e, t, n, a = true, r = 0) {
        l.assert(H.ClassType.isSameGenericClass(e, t));
        l.assert(e.shared.typeParams.length > 0);
        t = Z.makeTypeVarsBound(t, Z.getTypeVarScopeIds(t));
        e = Z.makeTypeVarsBound(e, Z.getTypeVarScopeIds(e));
        let s = true;
        try {
          ye.push({
            class: e,
            assumedVariance: n
          });
          H.ClassType.getSymbolTable(e).forEach((n, a) => {
            if (!s || n.isIgnoredForProtocolMatch()) {
              return;
            }
            if (a === '__new__' || a === '__init__') {
              return;
            }
            const i = Z.lookUpClassMember(t, a);
            l.assert(i !== undefined);
            let o = cr(n);
            const p = Tr(i);
            o = Z.partiallySpecializeType(o, e, dt());
            if (H.isClassInstance(o) && H.ClassType.isPropertyClass(o) && H.isClassInstance(p) && H.ClassType.isPropertyClass(p)) {
              if (!z.assignProperty(es, H.ClassType.cloneAsInstantiable(o), H.ClassType.cloneAsInstantiable(p), e, t, undefined, undefined, undefined, r)) {
                s = false;
              }
            } else {
              const t = n.getDeclarations()[0];
              let i = 0;
              if ((t == null ? undefined : t.type) === 1 && !Lr(t) && !Z.isMemberReadOnly(e, a) && !B.isPrivateOrProtectedName(a)) {
                i |= 1;
              }
              if (!Ir(o, p, undefined, undefined, i | 32768, r)) {
                s = false;
              }
            }
          });
          if (s) {
            e.shared.baseClasses.forEach(i => {
              if (!s || !H.isInstantiableClass(i) || H.ClassType.isBuiltIn(i, ['object', 'Protocol', 'Generic']) || i.shared.typeParams.length === 0) {
                return;
              }
              const o = Z.specializeForBaseClass(e, i);
              const l = Z.specializeForBaseClass(t, i);
              if (!a) {
                o.shared.typeParams.forEach((e, t) => {
                  if (H.isParamSpec(e) || H.isTypeVarTuple(e) || e.shared.isSynthesized) {
                    return;
                  }
                  if (!l.priv.typeArgs || t >= l.priv.typeArgs.length || !o.priv.typeArgs || t >= o.priv.typeArgs.length) {
                    return;
                  }
                  const n = e.shared.declaredVariance;
                  if (!!H.isTypeVar(l.priv.typeArgs[t]) && (n === 2 || n === 4) || !!H.isTypeVar(o.priv.typeArgs[t]) && (n === 2 || n === 3)) {
                    s = false;
                  }
                });
              }
              if (s) {
                if (!H.ClassType.isTupleClass(o) && !_r(o, l, n, a, r)) {
                  s = false;
                }
              }
            });
            return s;
          } else {
            return false;
          }
        } finally {
          ye.pop();
        }
      }
      function Cr(e, t, n, a, r, s) {
        var i;
        var o;
        var d;
        l.assert(H.ClassType.isSameGenericClass(e, t));
        ya(e);
        const c = H.ClassType.getTypeParams(e);
        let u;
        let m;
        const y = ye.find(t => H.ClassType.isSameGenericClass(t.class, e));
        const h = y == null ? undefined : y.assumedVariance;
        if (!e.priv.typeArgs || !t.priv.typeArgs) {
          return true;
        }
        if (H.ClassType.isTupleClass(e)) {
          u = (o = (i = e.priv.tupleTypeArgs) === null || i === undefined ? undefined : i.map(e => e.type)) !== null && o !== undefined ? o : [];
          m = (d = t.priv.tupleTypeArgs) === null || d === undefined ? undefined : d.map(e => e.type);
        } else {
          u = e.priv.typeArgs;
          m = t.priv.typeArgs;
        }
        let f = true;
        if (m != null) {
          m.forEach((i, o) => {
            const l = o >= u.length ? u.length - 1 : o;
            const d = l >= 0 ? u[l] : H.UnknownType.create();
            const m = l < c.length ? c[l] : undefined;
            const y = new p.DiagnosticAddendum();
            const T = h ?? (m ? H.TypeVarType.getVariance(m) : 3);
            let v;
            let b;
            let _ = true;
            if (T === 3) {
              v = r | 256;
              b = g.LocAddendum.typeVarIsCovariant;
            } else {
              if (T === 4) {
                v = r | 258;
                b = g.LocAddendum.typeVarIsContravariant;
              } else {
                v = r | 257;
                b = g.LocAddendum.typeVarIsInvariant;
                _ = false;
              }
            }
            if (H.ClassType.isBuiltIn(e, 'TypeForm')) {
              v |= 256;
            }
            if (!Ir(T === 4 ? i : d, T === 4 ? d : i, y, a, v, s) && !H.ClassType.isPseudoGenericClass(e)) {
              if (n) {
                if (m) {
                  const a = n.createAddendum();
                  a.addMessage(b().format({
                    name: H.TypeVarType.getReadableName(m),
                    ...Hr(i, d)
                  }));
                  if (_) {
                    a.addAddendum(y);
                  }
                  if (f && H.ClassType.isSameGenericClass(e, t)) {
                    if (H.ClassType.isBuiltIn(e, 'dict') && o === 1) {
                      a.addMessage(g.LocAddendum.invariantSuggestionDict());
                    } else {
                      if (H.ClassType.isBuiltIn(e, 'list')) {
                        a.addMessage(g.LocAddendum.invariantSuggestionList());
                      } else {
                        if (H.ClassType.isBuiltIn(e, 'set')) {
                          a.addMessage(g.LocAddendum.invariantSuggestionSet());
                        }
                      }
                    }
                  }
                } else {
                  n.addAddendum(y);
                }
              }
              f = false;
            }
          });
        }
        return f;
      }
      function Ir(e, t, n, a, r = 0, s = 0) {
        var i;
        var p;
        var d;
        var c;
        var u;
        var m;
        var y;
        var h;
        var f;
        var T;
        var v;
        var b;
        if (e === t && !Z.requiresSpecialization(e)) {
          return true;
        }
        const _ = (i = t.props) === null || i === undefined ? undefined : i.specialForm;
        if (_) {
          let e = false;
          if (r & 16384 && H.ClassType.isBuiltIn(_, ['Callable', 'UnionType', 'Generic'])) {
            e = true;
          }
          if (!e) {
            t = ((p = t.props) === null || p === undefined ? undefined : p.typeForm) && !((d = _.props) === null || d === undefined ? undefined : d.typeForm) ? H.TypeBase.cloneWithTypeForm(_, t.props.typeForm) : _;
          }
        }
        if (s > H.maxTypeRecursionCount) {
          return true;
        }
        s++;
        if (H.isTypeVar(e) && e.shared.recursiveAlias && H.isTypeVar(t) && t.shared.recursiveAlias) {
          const i = (c = e.props) === null || c === undefined ? undefined : c.typeAliasInfo;
          const o = (u = t.props) === null || u === undefined ? undefined : u.typeAliasInfo;
          if ((i == null ? undefined : i.typeArgs) && (o == null ? undefined : o.typeArgs) && e.shared.recursiveAlias.typeVarScopeId === t.shared.recursiveAlias.typeVarScopeId) {
            return function (e, t, n, a, r = 0, s = 0) {
              l.assert(e.typeArgs !== undefined);
              l.assert(t.typeArgs !== undefined);
              let i = true;
              const o = t.typeArgs;
              const p = e.shared.computedVariance;
              e.typeArgs.forEach((e, t) => {
                const l = t < o.length ? o[t] : H.UnknownType.create();
                let d = r;
                const c = p && t < p.length ? p[t] : 3;
                if (c === 2) {
                  d |= 1;
                } else {
                  if (c === 4) {
                    d ^= 2;
                  }
                }
                if (!Ir(e, l, n, a, d, s)) {
                  i = false;
                }
              });
              return i;
            }(i, o, n, a, r, s);
          }
          if (r & 4) {
            return true;
          }
          r |= 4;
        }
        if (H.TypeBase.isInstantiable(e) && H.TypeBase.isInstantiable(t) && (H.TypeBase.getInstantiableDepth(e) > 0 || H.TypeBase.getInstantiableDepth(t) > 0)) {
          return Ir(Z.convertToInstance(e), Z.convertToInstance(t), n, a, r, s);
        }
        const C = Z.transformPossibleRecursiveTypeAlias(e);
        const S = Z.transformPossibleRecursiveTypeAlias(t);
        if ((C !== e && H.isUnion(C) || S !== t && H.isUnion(S)) && s > le) {
          return !H.isClassInstance(t) || !H.ClassType.isBuiltIn(t, 'str') || !H.isUnion(C) || C.priv.subtypes.some(e => H.isClassInstance(e) && H.ClassType.isBuiltIn(e, ['object', 'str']));
        }
        e = C;
        t = S;
        if (H.isUnbound(e) || H.isUnbound(t)) {
          return true;
        }
        if (H.isTypeVar(e)) {
          if (Z.isTypeVarSame(e, t)) {
            return true;
          }
          if (function (e, t, n) {
            return !H.findSubtype(t, t => {
              if (H.isTypeSame(e, t, {
                ignorePseudoGeneric: true
              }, n)) {
                return false;
              }
              if (Z.isIncompleteUnknown(t)) {
                return false;
              }
              const r = H.TypeVarType.getNameWithScope(e);
              const s = (Z.getTypeCondition(t) ?? []).filter(e => e.typeVar.priv.nameWithScope === r);
              return s.length === 0 || !s.some(a => a.typeVar.priv.nameWithScope === H.TypeVarType.getNameWithScope(e) && (e.shared.boundType ? (l.assert(a.constraintIndex === 0, 'Expected constraint for bound TypeVar to have index of 0'), Ir(e.shared.boundType, t, undefined, undefined, 0, n)) : !H.TypeVarType.hasConstraints(e) || (l.assert(a.constraintIndex < e.shared.constraints.length, 'Constraint for constrained TypeVar is out of bounds'), Ir(e.shared.constraints[a.constraintIndex], t, undefined, undefined, 0, n))));
            });
          }(e, t, s)) {
            return true;
          }
          const i = e;
          if (H.TypeBase.isInstantiable(e) === H.TypeBase.isInstantiable(t) && ((m = t.props) === null || m === undefined ? undefined : m.condition) && t.props.condition.some(e => !H.TypeVarType.hasConstraints(e.typeVar) && e.typeVar.priv.nameWithScope === i.priv.nameWithScope)) {
            return true;
          }
          if (H.isUnion(t)) {
            const n = H.removeFromUnion(t, e => H.isAnyOrUnknown(e));
            if (H.isTypeSame(e, n)) {
              return true;
            }
          }
          if (H.isTypeVar(t) && H.TypeVarType.isSelf(t) && H.TypeVarType.hasBound(t) && H.TypeVarType.isSelf(e) && H.TypeVarType.hasBound(e) && H.TypeVarType.isBound(e) === H.TypeVarType.isBound(t) && H.TypeBase.isInstance(t) === H.TypeBase.isInstance(e)) {
            if (!(r & 2) && !!a) {
              I.assignTypeVar(es, e, t, n, a, r, s);
            }
            return true;
          }
          if (H.isTypeVarTuple(e) && H.isClassInstance(t) && Z.isTupleClass(t) && t.priv.tupleTypeArgs && t.priv.tupleTypeArgs.length === 1 && H.isTypeSame(e, t.priv.tupleTypeArgs[0].type, {}, s)) {
            return true;
          }
          if (!(r & 2) || !H.isTypeVar(t)) {
            return !!I.assignTypeVar(es, e, t, n, a, r, s) && (!H.isAnyOrUnknown(t) || !(r & 16));
          }
        }
        if (H.isTypeVar(t)) {
          if (r & 2) {
            if (H.TypeVarType.isBound(t)) {
              return Ir(Pt(e), Pt(t), n, undefined, r, s);
            }
            if (I.assignTypeVar(es, t, e, n, a, r, s)) {
              return true;
            }
            let i = false;
            if (H.isUnion(e)) {
              Z.doForEachSubtype(e, e => {
                if (I.assignTypeVar(es, t, e, n, a, r, s)) {
                  i = true;
                }
              });
            }
            return i;
          }
          if (r & 1) {
            if (H.isAnyOrUnknown(e)) {
              return true;
            }
            if (H.isParamSpec(t) && H.isFunction(e) && H.FunctionType.isGradualCallableForm(e) && e.shared.parameters.length <= 2) {
              return true;
            }
            if (H.isUnpackedTypeVarTuple(t) && H.isClassInstance(e) && H.isUnpackedClass(e) && e.priv.tupleTypeArgs && e.priv.tupleTypeArgs.length === 1 && e.priv.tupleTypeArgs[0].isUnbounded && H.isAnyOrUnknown(e.priv.tupleTypeArgs[0].type)) {
              return true;
            }
            if (!H.isUnion(e)) {
              if (n != null) {
                n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e)));
              }
              return false;
            }
          }
        }
        if (H.isAnyOrUnknown(e)) {
          return true;
        }
        if (H.isAnyOrUnknown(t) && !((y = t.props) === null || y === undefined ? undefined : y.specialForm)) {
          if (a) {
            const n = Z.isEllipsisType(t) ? H.AnyType.create() : t;
            Sr(e, n, a);
          }
          if (!(r & 16)) {
            return true;
          }
        }
        if (H.isNever(t)) {
          if (r & 1) {
            return !!H.isNever(e) || (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false);
          } else {
            if (a) {
              Sr(e, H.UnknownType.create(), a);
            }
            return true;
          }
        }
        if (H.isUnion(e)) {
          if (H.isUnion(t)) {
            return kr(e, t, n, a, r, s);
          }
          const i = a == null ? undefined : a.clone();
          if (Pr(e, t, undefined, i, r, s)) {
            if (a && i) {
              a.copyFromClone(i);
            }
            return true;
          }
        }
        const A = Pt(t);
        if (H.isUnion(A)) {
          return kr(e, A, n, a, r, s);
        }
        if (H.isUnion(e)) {
          return Pr(e, t, n, a, r, s);
        }
        if (H.isClassInstance(A) && H.ClassType.isBuiltIn(A, 'type')) {
          const i = A.priv.typeArgs;
          let o;
          o = i && i.length >= 1 ? i[0] : H.UnknownType.create();
          if (H.isAnyOrUnknown(o)) {
            if (Z.isEffectivelyInstantiable(e)) {
              return true;
            }
          } else {
            if (H.isClassInstance(o) || H.isTypeVar(o)) {
              return !!Ir(e, Z.convertToInstantiable(o), n == null ? undefined : n.createAddendum(), a, r, s) || (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false);
            }
          }
        }
        if (H.isInstantiableClass(e)) {
          if (H.isInstantiableClass(A)) {
            if (H.ClassType.isProtocolClass(e) && !(r & 65536) && H.ClassType.isProtocolClass(A) && H.isInstantiableClass(t) && !t.priv.includeSubclasses) {
              if (n != null) {
                n.addMessage(g.LocAddendum.protocolSourceIsNotConcrete().format({
                  sourceType: Yr(Z.convertToInstance(t)),
                  destType: Yr(e)
                }));
              }
              return false;
            }
            if (H.ClassType.isBuiltIn(e, 'type') && ((f = (h = t.props) === null || h === undefined ? undefined : h.instantiableDepth) !== null && f !== undefined ? f : 0) > 0) {
              return true;
            }
            if (wr(A, r)) {
              const t = (v = (T = e.props) === null || T === undefined ? undefined : T.specialForm) !== null && v !== undefined ? v : e;
              if (wr(t, r)) {
                return Ir(t, A, n, a, r, s);
              }
            } else {
              if (br(e, A, n, a, r, s, false)) {
                return true;
              }
            }
            if (n != null) {
              n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e)));
            }
            return false;
          }
          if (H.isClassInstance(A) && Z.isMetaclassInstance(A)) {
            const i = e.shared.effectiveMetaclass;
            if (i && H.isInstantiableClass(i)) {
              return !!br(i, H.ClassType.cloneAsInstantiable(A), n, a, r, s, false) || (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false);
            }
          }
        }
        if (H.isClassInstance(e)) {
          if (H.ClassType.isBuiltIn(e, 'type')) {
            if (H.isInstantiableClass(t) && wr(t, r) && H.TypeBase.getInstantiableDepth(t) === 0) {
              return false;
            }
            if (H.isAnyOrUnknown(t) && r & 16) {
              return false;
            }
            const i = e.priv.typeArgs;
            if (i && i.length >= 1 && H.TypeBase.isInstance(i[0]) && H.TypeBase.isInstantiable(t)) {
              return Ir(i[0], Z.convertToInstance(t), n, a, r, s);
            }
            if (H.TypeBase.isInstantiable(t)) {
              return !H.isClass(t) || t.priv.literalValue === undefined;
            }
          }
          let i = Pt(t);
          if (H.isClass(i) && H.TypeBase.isInstance(i)) {
            if (!e.priv.isUnpacked && i.priv.isUnpacked && i.priv.tupleTypeArgs) {
              return Ir(e, Z.combineTupleTypeArgs(i.priv.tupleTypeArgs), n, a, r, s);
            }
            if (H.ClassType.isEnumClass(i) && i.priv.literalValue instanceof H.EnumLiteral && i.shared.mro.some(e => H.isClass(e) && H.ClassType.isBuiltIn(e, ['int', 'str', 'bytes'])) && H.isClassInstance(i.priv.literalValue.itemType) && Z.isLiteralType(i.priv.literalValue.itemType) && Ir(e, i.priv.literalValue.itemType)) {
              return true;
            }
            if (e.priv.literalValue !== undefined && H.ClassType.isSameGenericClass(e, i)) {
              if (i.priv.literalValue === undefined || !H.ClassType.isLiteralValueSame(i, e)) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.literalAssignmentMismatch().format({
                    sourceType: Yr(t),
                    destType: Yr(e)
                  }));
                }
                return false;
              }
            }
            if (H.ClassType.isBuiltIn(e, 'LiteralString')) {
              if (H.ClassType.isBuiltIn(i, 'str') && i.priv.literalValue !== undefined) {
                return !(r & 1);
              }
              if (H.ClassType.isBuiltIn(i, 'LiteralString')) {
                return true;
              }
            } else {
              if (H.ClassType.isBuiltIn(i, 'LiteralString') && (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass) && !(r & 1)) {
                i = H.ClassType.cloneAsInstance(Ae.strClass);
              }
            }
            return !!br(H.ClassType.cloneAsInstantiable(e), H.ClassType.cloneAsInstantiable(i), n, a, r, s, true);
          }
          if (H.isFunction(i) || H.isOverloaded(i)) {
            const t = Dr(e, s);
            if (t) {
              return Ir(t, i, n, a, r, s);
            }
            if (Ae == null ? undefined : Ae.functionClass) {
              return Ir(e, Z.convertToInstance(Ae.functionClass), n, a, r, s);
            }
          } else {
            if (H.isModule(i)) {
              if (H.ClassType.isBuiltIn(e, 'ModuleType')) {
                return true;
              }
              if (H.ClassType.isProtocolClass(e)) {
                return U.assignModuleToProtocol(es, H.ClassType.cloneAsInstantiable(e), i, n, a, r, s);
              }
            } else {
              if (H.isInstantiableClass(i)) {
                const t = Dr(e, s);
                if (t) {
                  return Ir(t, i, n, a, r, s);
                }
                if (H.ClassType.isProtocolClass(e)) {
                  return U.assignClassToProtocol(es, H.ClassType.cloneAsInstantiable(e), i, n, a, r, s);
                }
                const o = i.shared.effectiveMetaclass;
                if (o) {
                  if (H.isAnyOrUnknown(o)) {
                    return true;
                  }
                  if (br(H.ClassType.cloneAsInstantiable(e), o, undefined, a, r, s, true)) {
                    return true;
                  }
                }
              } else {
                if (H.isAnyOrUnknown(i) && !((b = i.props) === null || b === undefined ? undefined : b.specialForm)) {
                  return !(r & 16);
                }
                if (H.isUnion(i)) {
                  return Ir(e, i, n, a, r, s);
                }
              }
            }
          }
        }
        if (H.isFunction(e)) {
          let i = Pt(t);
          if (H.isClassInstance(i)) {
            const e = tt(i, '__call__', undefined, undefined, s);
            if (e) {
              i = e;
            }
          }
          if (H.isInstantiableClass(i) && i.priv.literalValue === undefined) {
            const o = w.createFunctionFromConstructor(es, i, H.isTypeVar(t) ? Z.convertToInstance(t) : undefined, s);
            if (o && (i = o, H.isUnion(i))) {
              return Ir(e, i, n, a, r, s);
            }
          }
          if (H.isAnyOrUnknown(i)) {
            return !(r & 16);
          }
          if (H.isOverloaded(i)) {
            if (r & 8) {
              return true;
            }
            const t = H.OverloadedType.getOverloads(i);
            const l = [];
            const p = [];
            t.forEach(t => {
              var n;
              const i = (n = Z.getTypeVarScopeId(t)) !== null && n !== undefined ? n : '';
              const d = a == null ? undefined : a.cloneWithSignature(i);
              if (Ir(e, t, undefined, d, r, s)) {
                l.push(t);
                if (d) {
                  o.appendArray(p, d.getConstraintSets());
                }
              }
            });
            if (l.length === 0) {
              if (n != null) {
                n.addMessage(g.LocAddendum.noOverloadAssignable().format({
                  type: Yr(e)
                }));
              }
              return false;
            } else {
              if (l.length === 1 || !(r & 8)) {
                if (a) {
                  a.addConstraintSets(p);
                }
              }
              return true;
            }
          }
          if (H.isFunction(i) && function (e, t, n, a, r, s) {
            var i;
            var p;
            var d;
            var c;
            var u;
            var m;
            var y;
            var h;
            let f = true;
            const T = !(r & 64);
            const v = !!(r & 2);
            r &= -65;
            const b = H.FunctionType.getParamSpecFromArgsKwargs(e);
            if (b) {
              e = H.FunctionType.cloneRemoveParamSpecArgsKwargs(e);
            }
            const _ = H.FunctionType.getParamSpecFromArgsKwargs(t);
            if (_) {
              t = H.FunctionType.cloneRemoveParamSpecArgsKwargs(t);
            }
            const C = E.getParamListDetails(e);
            const I = E.getParamListDetails(t);
            (function (e, t) {
              var n;
              if (t.argsIndex === undefined) {
                return;
              }
              if (!H.isUnpacked(t.params[t.argsIndex].type)) {
                return;
              }
              if (e.params.length < t.argsIndex) {
                return;
              }
              let a = e.params.findIndex((e, n) => {
                l.assert(t.argsIndex !== undefined);
                return n >= t.argsIndex && e.kind === E.ParamKind.Keyword;
              });
              if (a < 0) {
                a = e.params.length;
              }
              if (e.argsIndex !== undefined && t.argsIndex > e.argsIndex) {
                return;
              }
              const r = (n = t.firstKeywordOnlyIndex) !== null && n !== undefined ? n : t.params.length;
              const s = r - t.argsIndex - 1;
              const i = e.params.slice(t.argsIndex, a - s);
              const p = [];
              i.forEach(e => {
                if (e.param.category === 1) {
                  if (H.isUnpackedTypeVarTuple(e.type)) {
                    p.push({
                      type: e.type,
                      isUnbounded: false
                    });
                  } else {
                    if (H.isUnpackedClass(e.type) && e.type.priv.tupleTypeArgs) {
                      o.appendArray(p, e.type.priv.tupleTypeArgs);
                    } else {
                      p.push({
                        type: e.type,
                        isUnbounded: true
                      });
                    }
                  }
                } else {
                  p.push({
                    type: e.type,
                    isUnbounded: false,
                    isOptional: !!e.defaultType
                  });
                }
              });
              if (p.length !== 1 || !H.isTypeVarTuple(p[0].type)) {
                const n = q.makeTupleObject(es, p, true);
                e.params = [...e.params.slice(0, t.argsIndex), {
                  param: H.FunctionParam.create(1, n, H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, '_arg_combined'),
                  type: n,
                  declaredType: n,
                  index: -1,
                  kind: E.ParamKind.Positional
                }, ...e.params.slice(t.argsIndex + i.length, e.params.length)];
                const a = e.params.findIndex(e => e.param.category === 1);
                e.argsIndex = a >= 0 ? a : undefined;
                const r = e.params.findIndex(e => e.param.category === 2);
                e.kwargsIndex = r >= 0 ? r : undefined;
                const s = e.params.findIndex(e => e.kind === E.ParamKind.Keyword);
                e.firstKeywordOnlyIndex = s >= 0 ? s : undefined;
                e.positionOnlyParamCount = Math.max(0, e.params.findIndex(e => e.kind !== E.ParamKind.Positional || e.param.category !== 0 || !!e.defaultType));
              }
            })(v ? C : I, v ? I : C);
            const k = v ? !!_ : !!b;
            const w = (i = C.firstKeywordOnlyIndex) !== null && i !== undefined ? i : C.params.length;
            const S = (p = I.firstKeywordOnlyIndex) !== null && p !== undefined ? p : I.params.length;
            const A = Math.min(w, S);
            for (let i = 0; i < A; i++) {
              if (i === 0 && e.shared.methodClass && r & 32768 && (H.FunctionType.isInstanceMethod(e) || H.FunctionType.isClassMethod(e))) {
                continue;
              }
              if (i === C.argsIndex) {
                continue;
              }
              const o = C.params[i];
              const l = I.params[i];
              const p = l.type;
              const m = o.type;
              const y = (d = o.param.name) !== null && d !== undefined ? d : '';
              const h = (c = l.param.name) !== null && c !== undefined ? c : '';
              if (y) {
                if (o.kind !== E.ParamKind.Positional && o.kind !== E.ParamKind.ExpandedArgs && o.param.category !== 1 && l.param.category !== 1) {
                  if (l.kind === E.ParamKind.Positional || l.kind === E.ParamKind.ExpandedArgs) {
                    if (n != null) {
                      n.createAddendum().addMessage(g.LocAddendum.functionParamPositionOnly().format({
                        name: y
                      }));
                    }
                    f = false;
                  } else {
                    if (y !== h) {
                      if (n != null) {
                        n.createAddendum().addMessage(g.LocAddendum.functionParamName().format({
                          srcName: h,
                          destName: y
                        }));
                      }
                      f = false;
                    }
                  }
                }
              }
              if (!o.defaultType || !(l.defaultType || i === I.argsIndex || (n == null || n.createAddendum().addMessage(g.LocAddendum.functionParamDefaultMissing().format({
                name: h
              })), f = false), r & 32 && l.defaultType)) {
                if (i !== 0 || t.shared.name !== '__init__' || !H.FunctionType.isInstanceMethod(t) || e.shared.name !== '__init__' || !H.FunctionType.isInstanceMethod(e) || !H.FunctionType.isOverloaded(e) || !H.FunctionParam.isTypeDeclared(o.param)) {
                  if (H.isUnpacked(p)) {
                    f = false;
                  } else {
                    if (Nr(m, p, i, n == null ? undefined : n.createAddendum(), a, r, s)) {
                      if (o.kind !== E.ParamKind.Positional && o.kind !== E.ParamKind.ExpandedArgs && l.kind === E.ParamKind.Positional && I.kwargsIndex === undefined && !I.params.some(e => e.kind === E.ParamKind.Keyword && e.param.category === 0 && e.param.name === o.param.name)) {
                        if (n != null) {
                          n.addMessage(g.LocAddendum.namedParamMissingInSource().format({
                            name: (u = o.param.name) !== null && u !== undefined ? u : ''
                          }));
                        }
                        f = false;
                      }
                    } else {
                      if (!(r & 512) || !H.isTypeVar(p) || !p.shared.isSynthesized) {
                        f = false;
                      }
                    }
                  }
                }
              }
            }
            if (!H.FunctionType.isGradualCallableForm(e) && C.firstPositionOrKeywordIndex < I.positionOnlyParamCount && !k) {
              if (n != null) {
                n.createAddendum().addMessage(g.LocAddendum.argsPositionOnly().format({
                  expected: I.positionOnlyParamCount,
                  received: C.firstPositionOrKeywordIndex
                }));
              }
              f = false;
            }
            if (w < S && !k) {
              for (let e = w; e < S; e++) {
                if (C.argsIndex !== undefined) {
                  if (!Nr(C.params[C.argsIndex].type, I.params[e].type, e, n == null ? undefined : n.createAddendum(), a, r, s)) {
                    f = false;
                  }
                  continue;
                }
                const t = I.params[e];
                if (t.defaultType) {
                  const t = I.params[e];
                  const i = (m = t.defaultType) !== null && m !== undefined ? m : t.defaultType;
                  if (i && !Ir(t.type, i, n == null ? undefined : n.createAddendum(), a, r, s)) {
                    if (!(r & 32)) {
                      f = false;
                    }
                  }
                  continue;
                }
                if (t.kind === E.ParamKind.Standard) {
                  continue;
                }
                if (t.param.category === 1) {
                  continue;
                }
                const i = I.params.filter(e => !!e.param.name && !e.defaultType && e.param.category === 0).length;
                if (n != null) {
                  n.createAddendum().addMessage(g.LocAddendum.functionTooFewParams().format({
                    expected: i,
                    received: w
                  }));
                }
                f = false;
                break;
              }
            } else {
              if (S < w) {
                if (I.argsIndex !== undefined) {
                  const e = I.params[I.argsIndex].type;
                  for (let t = S; t < w; t++) {
                    if (t === I.argsIndex) {
                      continue;
                    }
                    const i = C.params[t].type;
                    if (H.isTypeVarTuple(i) && !H.isTypeVarTuple(e)) {
                      if (n != null) {
                        n.addMessage(g.LocAddendum.typeVarTupleRequiresKnownLength());
                      }
                      f = false;
                    } else {
                      if (!Nr(i, e, t, n == null ? undefined : n.createAddendum(), a, r, s)) {
                        f = false;
                      }
                      const o = C.params[t].kind;
                      if (o !== E.ParamKind.Positional && o !== E.ParamKind.ExpandedArgs && I.kwargsIndex === undefined) {
                        if (n != null) {
                          n.addMessage(g.LocAddendum.namedParamMissingInSource().format({
                            name: (y = C.params[t].param.name) !== null && y !== undefined ? y : ''
                          }));
                        }
                        f = false;
                      }
                    }
                  }
                } else {
                  if (!I.paramSpec) {
                    let e = w;
                    if (C.argsIndex !== undefined && C.argsIndex < w) {
                      e--;
                    }
                    if (r & 32) {
                      while (e > 0 && C.params[e - 1].defaultType) {
                        e--;
                      }
                    }
                    if (S < e) {
                      if (n != null) {
                        n.addMessage(g.LocAddendum.functionTooManyParams().format({
                          expected: S,
                          received: w
                        }));
                      }
                      f = false;
                    }
                  }
                }
              }
            }
            if (I.argsIndex !== undefined && C.argsIndex !== undefined && !H.FunctionType.isGradualCallableForm(e)) {
              let e = C.params[C.argsIndex].type;
              let t = I.params[I.argsIndex].type;
              if (!H.isUnpacked(e)) {
                e = q.makeTupleObject(es, [{
                  type: e,
                  isUnbounded: true
                }], true);
              }
              if (!H.isUnpacked(t)) {
                t = q.makeTupleObject(es, [{
                  type: t,
                  isUnbounded: true
                }], true);
              }
              if (!Nr(e, t, C.params[C.argsIndex].index, n == null ? undefined : n.createAddendum(), a, r, s)) {
                f = false;
              }
            }
            if (!H.FunctionType.isGradualCallableForm(e) && I.argsIndex === undefined && _ === undefined && C.argsIndex !== undefined && !C.hasUnpackedTypeVarTuple) {
              if (n != null) {
                n.createAddendum().addMessage(g.LocAddendum.argsParamMissing().format({
                  paramName: (h = C.params[C.argsIndex].param.name) !== null && h !== undefined ? h : ''
                }));
              }
              f = false;
            }
            if (!k) {
              const t = new Map();
              if (C.firstKeywordOnlyIndex !== undefined) {
                C.params.forEach((e, n) => {
                  if (n >= C.firstKeywordOnlyIndex && e.param.name && e.param.category === 0 && e.kind !== E.ParamKind.Positional && e.kind !== E.ParamKind.ExpandedArgs) {
                    t.set(e.param.name, e);
                  }
                });
              }
              let i = I.firstKeywordOnlyIndex !== undefined ? I.firstKeywordOnlyIndex : I.params.length;
              if (w < S && C.argsIndex === undefined) {
                i = w;
              }
              if (i >= 0) {
                I.params.forEach((e, o) => {
                  var l;
                  if (o >= i && e.param.name && e.param.category === 0 && e.kind !== E.ParamKind.Positional) {
                    const i = t.get(e.param.name);
                    const o = n == null ? undefined : n.createAddendum();
                    const p = e.type;
                    if (i) {
                      const l = i.type;
                      const d = a ? Xe(l, a) : l;
                      if (!Nr(i.type, p, undefined, o == null ? undefined : o.createAddendum(), a, r, s)) {
                        if (o) {
                          o.addMessage(g.LocAddendum.namedParamTypeMismatch().format({
                            name: e.param.name,
                            sourceType: Yr(d),
                            destType: Yr(p)
                          }));
                        }
                        f = false;
                      }
                      if (i.defaultType && !e.defaultType) {
                        if (n != null) {
                          n.createAddendum().addMessage(g.LocAddendum.functionParamDefaultMissing().format({
                            name: e.param.name
                          }));
                        }
                        f = false;
                      }
                      t.delete(e.param.name);
                    } else {
                      if (C.kwargsIndex !== undefined || e.defaultType) {
                        if (C.kwargsIndex !== undefined) {
                          if (!Nr(C.params[C.kwargsIndex].type, p, C.params[C.kwargsIndex].index, n == null ? undefined : n.createAddendum(), a, r, s)) {
                            f = false;
                          }
                        } else {
                          if (e.defaultType) {
                            const t = (l = e.defaultType) !== null && l !== undefined ? l : e.defaultType;
                            if (t && !Ir(e.type, t, n == null ? undefined : n.createAddendum(), a, r, s)) {
                              if (!(r & 32)) {
                                f = false;
                              }
                            }
                          }
                        }
                      } else {
                        if (o) {
                          o.addMessage(g.LocAddendum.namedParamMissingInDest().format({
                            name: e.param.name
                          }));
                        }
                        f = false;
                      }
                    }
                  }
                });
              }
              t.forEach((e, i) => {
                if (I.kwargsIndex !== undefined && e.param.name) {
                  if (!Nr(e.type, I.params[I.kwargsIndex].type, e.index, n == null ? undefined : n.createAddendum(), a, r, s)) {
                    f = false;
                  }
                  t.delete(i);
                } else {
                  if (n != null) {
                    n.createAddendum().addMessage(g.LocAddendum.namedParamMissingInSource().format({
                      name: i
                    }));
                  }
                  f = false;
                }
              });
              if (I.kwargsIndex !== undefined && C.kwargsIndex !== undefined) {
                if (!Nr(C.params[C.kwargsIndex].type, I.params[I.kwargsIndex].type, C.params[C.kwargsIndex].index, n == null ? undefined : n.createAddendum(), a, r, s)) {
                  f = false;
                }
              }
              if (!H.FunctionType.isGradualCallableForm(e) && I.kwargsIndex === undefined && _ === undefined && C.kwargsIndex !== undefined) {
                if (n != null) {
                  n.createAddendum().addMessage(g.LocAddendum.kwargsParamMissing().format({
                    paramName: C.params[C.kwargsIndex].param.name
                  }));
                }
                f = false;
              }
            }
            if (k && (_ == null ? undefined : _.priv.nameWithScope) === (b == null ? undefined : b.priv.nameWithScope) && I.params.length !== C.params.length) {
              f = false;
            }
            if (k) {
              const n = v ? e : t;
              const s = v ? t : e;
              const i = v ? b : _;
              const o = v ? _ : b;
              if (o) {
                const e = s.shared.parameters.filter((e, t) => {
                  if (!e.name) {
                    return false;
                  }
                  const n = H.FunctionType.getParamType(s, t);
                  return e.category !== 0 || !H.isParamSpec(n);
                }).length;
                let t = 0;
                const l = [];
                n.shared.parameters.forEach((a, r) => {
                  if (t < e) {
                    if (a.name) {
                      t++;
                    }
                  } else {
                    if (!H.isPositionOnlySeparator(a) || l.length !== 0) {
                      l.push(H.FunctionParam.create(a.category, H.FunctionType.getParamType(n, r), a.flags, a.name, H.FunctionType.getParamDefaultType(n, r), a.defaultExpr));
                    }
                  }
                });
                if (l.length > 0 || !i || !H.isTypeSame(i, o, {
                  ignoreTypeFlags: true
                })) {
                  const e = H.FunctionType.createInstance('', '', '', n.shared.flags | 64, n.shared.docString);
                  e.shared.deprecatedMessage = n.shared.deprecatedMessage;
                  e.shared.typeVarScopeId = n.shared.typeVarScopeId;
                  e.priv.constructorTypeVarScopeId = n.priv.constructorTypeVarScopeId;
                  e.shared.methodClass = n.shared.methodClass;
                  l.forEach(t => {
                    H.FunctionType.addParam(e, t);
                  });
                  if (i) {
                    H.FunctionType.addParamSpecVariadics(e, Z.convertToInstance(i));
                  }
                  if (!Ir(o, e, undefined, a, r)) {
                    if (l.length > 0 || !i || !Ir(Z.convertToInstance(o), Z.convertToInstance(i), undefined, a, r)) {
                      f = false;
                    }
                  }
                }
              }
            }
            if (T) {
              const i = hr(e);
              if (!H.isAnyOrUnknown(i)) {
                const e = Xe(hr(t), a);
                const o = n == null ? undefined : n.createAddendum();
                let l = false;
                let p = r;
                if (t.shared.declaredReturnType && Z.containsLiteralType(t.shared.declaredReturnType, true)) {
                  p |= 256;
                }
                if (Ir(i, e, o == null ? undefined : o.createAddendum(), a, p, s) || H.isClassInstance(e) && H.ClassType.isBuiltIn(e, ['TypeGuard', 'TypeIs']) && (Ae == null ? undefined : Ae.boolClass) && H.isInstantiableClass(Ae.boolClass) && Ir(i, H.ClassType.cloneAsInstance(Ae.boolClass), o == null ? undefined : o.createAddendum(), a, r, s)) {
                  l = true;
                }
                if (!l) {
                  if (o) {
                    o.addMessage(g.LocAddendum.functionReturnTypeMismatch().format({
                      sourceType: Yr(e),
                      destType: Yr(i)
                    }));
                  }
                  f = false;
                }
              }
            }
            return f;
          }(e, i, n == null ? undefined : n.createAddendum(), a ?? new k.ConstraintTracker(), r, s)) {
            return true;
          }
        }
        if (H.isOverloaded(e)) {
          const i = n == null ? undefined : n.createAddendum();
          const o = H.OverloadedType.getOverloads(e);
          if (H.isOverloaded(t)) {
            const e = H.OverloadedType.getOverloads(t);
            if (o.length === e.length && o.every((t, n) => Ir(t, e[n], undefined, a, r, s))) {
              return true;
            }
          }
          if (!o.every(e => Ir(e, t, i == null ? undefined : i.createAddendum(), a, r, s))) {
            const t = H.OverloadedType.getOverloads(e);
            if (i && t.length > 0) {
              i.addMessage(g.LocAddendum.overloadNotAssignable().format({
                name: t[0].shared.name
              }));
            }
            return false;
          }
          return true;
        }
        return !!H.isClass(e) && !!H.ClassType.isBuiltIn(e, 'object') && (!!H.isInstantiableClass(e) && !!H.TypeBase.isInstantiable(t) || !!H.isClassInstance(e)) && !(r & 1) || (Z.isNoneInstance(t) && H.isClassInstance(e) && H.ClassType.isProtocolClass(e) && (Ae == null ? undefined : Ae.noneTypeClass) && H.isInstantiableClass(Ae.noneTypeClass) ? U.assignClassToProtocol(es, H.ClassType.cloneAsInstantiable(e), H.ClassType.cloneAsInstance(Ae.noneTypeClass), n, a, r, s) : Z.isNoneInstance(e) ? (n == null || n.addMessage(g.LocAddendum.assignToNone()), false) : (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false));
      }
      function kr(e, t, n, a, r, s) {
        if (H.isTypeSame(t, e, {}, s)) {
          return true;
        }
        let i = Z.sortTypes(t.priv.subtypes);
        let o = false;
        if (H.isUnion(e)) {
          const l = e.priv.subtypes.filter(e => !H.isAnyOrUnknown(e));
          if (l.length === 1 && H.isTypeVar(l[0])) {
            Ir(l[0], t, undefined, a, r, s);
            return true;
          }
          const p = [];
          let d = i;
          let c = true;
          Z.sortTypes(e.priv.subtypes).forEach(e => {
            if (Z.requiresSpecialization(e)) {
              p.push(e);
            } else {
              const t = d.findIndex(t => H.isTypeSame(t, e, {}, s));
              if (t >= 0) {
                d.splice(t, 1);
                o = true;
              } else {
                p.push(e);
              }
            }
          });
          d.forEach(e => {
            const t = p.findIndex(t => {
              if (H.isTypeSame(t, e)) {
                return true;
              }
              if (H.isClass(e) && H.isClass(t) && H.TypeBase.isInstance(e) === H.TypeBase.isInstance(t)) {
                if (H.ClassType.isSameGenericClass(e, t)) {
                  return true;
                }
                if (H.ClassType.isTypedDictClass(e) && H.ClassType.isTypedDictClass(t) && Ir(e, t, undefined, undefined, r, s)) {
                  return true;
                }
              }
              return (!!H.isFunction(e) || !!H.isOverloaded(e)) && (!!H.isFunction(t) || !!H.isOverloaded(t));
            });
            if (t >= 0) {
              if (Ir(p[t], e, undefined, a, r, s)) {
                o = true;
              } else {
                c = false;
              }
              p.splice(t, 1);
              d = d.filter(t => t !== e);
            }
          });
          if (c && (p.length !== 0 || d.length !== 0)) {
            if (r & 1 && d.length === 0) {
              return p.every(t => Ar(t, e, true, s));
            }
            const o = !!(r & 2);
            const l = o ? d : p;
            if (l.length === 0 || l.some(e => !H.isTypeVar(e))) {
              c = false;
              i = d;
            } else {
              if (p.length === d.length) {
                const e = [...p];
                for (let t = 0; t < d.length; t++) {
                  let i = false;
                  for (let o = 0; o < e.length; o++) {
                    if (Ir(e[o], d[t], n == null ? undefined : n.createAddendum(), a, r, s)) {
                      i = true;
                      e.push(...e.splice(o, 1));
                      break;
                    }
                  }
                  if (!i) {
                    c = false;
                    break;
                  }
                }
                i = d;
              } else {
                if (d.length === 0) {
                  if (r & 2048) {
                    p.forEach(e => {
                      Ir(e, t, undefined, a, r, s);
                    });
                  }
                } else {
                  if (!Ir(o ? e : p[0], o ? d[0] : H.combineTypes(d), n == null ? undefined : n.createAddendum(), a, r, s)) {
                    c = false;
                  }
                }
              }
            }
          }
          if (c) {
            return true;
          }
          if (r & 32 && o) {
            return true;
          }
        }
        let l = false;
        i.forEach(i => {
          if (!l) {
            if (Ir(e, i, undefined, a, r, s)) {
              o = true;
            } else {
              if (!Ar(i, t, false, s) && !Ir(e, i, n == null ? undefined : n.createAddendum(), a, r, s)) {
                l = true;
              }
            }
          }
        }, true);
        return !l || !!(r & 32) && !!o || (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false);
      }
      function wr(e, t) {
        return !(t & 16384) && H.ClassType.isSpecialFormClass(e);
      }
      function Sr(e, t, n) {
        Z.getTypeVarArgsRecursive(e).forEach(e => {
          if (!H.TypeVarType.isBound(e) && !n.getMainConstraintSet().getTypeVar(e) && !H.isParamSpec(t) && !H.isTypeVarTuple(t)) {
            n.setBounds(e, t);
          }
        });
      }
      function Ar(e, t, n, a = 0) {
        const r = Pt(e);
        const s = H.isUnion(t) ? t.priv.subtypes : [t];
        for (const t of s) {
          if (!H.isTypeSame(t, e)) {
            if (H.isAnyOrUnknown(t)) {
              if (n) {
                return true;
              }
            } else {
              if (xr(t, r, a)) {
                return true;
              }
            }
          }
        }
        return false;
      }
      function xr(e, t, n) {
        var a;
        return !((a = e.props) === null || a === undefined ? undefined : a.condition) && (!!H.isAnyOrUnknown(e) || !!H.isAnyOrUnknown(t) || !!H.isClass(e) && !!e.shared.mro.some(e => H.isAnyOrUnknown(e)) || !!H.isClass(t) && !!t.shared.mro.some(e => H.isAnyOrUnknown(e)) || Ir(e, t, undefined, undefined, 0, n) && !Ir(t, e, undefined, undefined, 0, n));
      }
      function Pr(e, t, n, a, r, s) {
        if (r & 1) {
          let i = false;
          Z.doForEachSubtype(e, (o, l) => {
            if (!i && !Ir(o, t, n == null ? undefined : n.createAddendum(), a, r, s)) {
              let t = false;
              if (!H.isAnyOrUnknown(o)) {
                const n = Z.makeTypeVarsBound(o, undefined);
                Z.doForEachSubtype(e, (e, a) => {
                  if (l !== a && !t) {
                    if (Ir(Z.makeTypeVarsBound(e, undefined), n, undefined, undefined, 0, s)) {
                      t = true;
                    }
                  }
                });
              }
              if (!t) {
                i = true;
              }
            }
          });
          return !i || (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false);
        }
        const i = n ? new p.DiagnosticAddendum() : undefined;
        let o = false;
        if (Z.requiresSpecialization(e)) {
          if (Z.isNoneInstance(t) && Z.isOptionalType(e)) {
            o = true;
          } else {
            let n;
            let l;
            let p = 0;
            if (H.isClassInstance(t) && Z.isLiteralType(t) && H.UnionType.containsType(e, t, undefined, undefined, s)) {
              return true;
            }
            Z.doForEachSubtype(e, e => {
              const d = a == null ? undefined : a.clone();
              if (Ir(e, t, i == null ? undefined : i.createAddendum(), d, r, s) && (o = true, d)) {
                let r = d.getScore();
                if (H.isTypeVar(e)) {
                  if (!(a == null ? undefined : a.getMainConstraintSet().getTypeVar(e))) {
                    p++;
                    r += 0.001;
                  }
                }
                if (H.isTypeSame(e, $e(t))) {
                  r = Number.POSITIVE_INFINITY;
                }
                if (l === undefined || l <= r) {
                  l = r;
                  n = d;
                }
              }
            }, true);
            if (p > 1 && r & 8) {
              n = undefined;
            }
            if (a && n) {
              a.copyFromClone(n);
            }
          }
        } else {
          for (const n of e.priv.subtypes) {
            if (Ir(n, t, i == null ? undefined : i.createAddendum(), a, r, s)) {
              o = true;
              break;
            }
          }
        }
        if (!o) {
          if (H.isTypeVar(t) && H.TypeVarType.hasConstraints(t)) {
            o = Ir(e, Pt(t), i == null ? undefined : i.createAddendum(), a, r, s);
          }
        }
        return !!o || (n && i && (n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), n.addAddendum(i)), false);
      }
      function Dr(e, t = 0) {
        if (!H.isClassInstance(e) || !H.ClassType.isProtocolClass(e)) {
          return;
        }
        for (const t of e.shared.mro) {
          if (H.isClass(t) && H.ClassType.isProtocolClass(t)) {
            for (const e of H.ClassType.getSymbolTable(t)) {
              if (e[0] !== '__call__' && !e[1].isIgnoredForProtocolMatch()) {
                let t = false;
                if ((Ae == null ? undefined : Ae.functionClass) && H.isClass(Ae.functionClass) && H.ClassType.getSymbolTable(Ae.functionClass).has(e[0])) {
                  t = true;
                }
                if (!t) {
                  return;
                }
              }
            }
          }
        }
        const n = tt(e, '__call__', undefined, undefined, t);
        if (n) {
          return Z.makeFunctionTypeVarsBound(n);
        } else {
          return undefined;
        }
      }
      function Nr(e, t, n, a, r, s, i) {
        if (H.isTypeVar(e) && e.shared.isSynthesized && e.shared.boundType && H.isClassInstance(e.shared.boundType) && H.ClassType.isProtocolClass(e.shared.boundType)) {
          return true;
        }
        if (H.isTypeVarTuple(e) && !H.isUnpacked(t)) {
          return false;
        }
        let o = t;
        let l = e;
        let p = false;
        if (!(s & 16)) {
          const n = !!(s & 8);
          if (s & 2) {
            if (!n) {
              o = Xe(t, r, undefined, {
                useLowerBoundOnly: true
              });
            }
            p = Z.requiresSpecialization(o);
          } else {
            if (!n) {
              l = Xe(e, r, undefined, {
                useLowerBoundOnly: true
              });
            }
            p = Z.requiresSpecialization(l);
          }
        }
        if (p && Ir(o, l, undefined, r, s ^ 2 | 256, i)) {
          l = Xe(e, r);
        }
        return !!Ir(o, l, a == null ? undefined : a.createAddendum(), r, s, i) || (a && n !== undefined && a.addMessage(g.LocAddendum.paramAssignment().format({
          index: n + 1,
          sourceType: Yr(e),
          destType: Yr(t)
        })), false);
      }
      function Fr(e, t, n, a = 0) {
        if (!(a > H.maxTypeRecursionCount)) {
          a++;
          if (n.shared.typeParams.length > 0 && n.priv.typeArgs && n.priv.typeArgs.length <= n.shared.typeParams.length && !n.priv.tupleTypeArgs) {
            const r = new k.ConstraintTracker();
            I.addConstraintsForExpectedType(es, H.ClassType.specialize(n, undefined), t, r, M.getTypeVarScopesForNode(e), e.start);
            let s = false;
            const i = I.solveConstraints(es, r).getMainSolutionSet();
            const o = n.priv.typeArgs.map((t, r) => {
              const o = n.shared.typeParams[r];
              const l = i.getType(o);
              if (l) {
                if (H.isAnyOrUnknown(l) || H.isAnyOrUnknown(t)) {
                  s = true;
                  return l;
                }
                if (H.isClassInstance(l) && H.isClassInstance(t)) {
                  const n = Fr(e, l, t, a);
                  if (n) {
                    s = true;
                    return n;
                  }
                } else {
                  if (Z.containsAnyRecursive(l)) {
                    const e = H.TypeVarType.getVariance(o);
                    const n = Ir(l, t);
                    const a = Ir(t, l);
                    if ((e === 4 || n) && (e === 3 || a)) {
                      s = true;
                      return l;
                    }
                  }
                }
              }
              return t;
            });
            if (s) {
              return H.ClassType.specialize(n, o);
            }
          }
          if (H.ClassType.isSameGenericClass(t, n) && Z.containsAnyRecursive(n) && !Z.containsAnyRecursive(t)) {
            return t;
          } else {
            return undefined;
          }
        }
      }
      function Er(e, t, n) {
        const a = Z.mapSubtypes(n.type, n => {
          if (H.isClass(n) && Z.isLiteralType(n) && H.isUnion(t) && H.UnionType.containsType(t, n)) {
            return n;
          }
          const a = Z.mapSubtypes(t, t => {
            if (H.isAnyOrUnknown(t)) {
              return t;
            }
            if (Ir(t, n)) {
              if (H.isAny(n)) {
                return t;
              }
              if (H.isClass(t) && H.isClass(n) && H.TypeBase.isInstance(t) === H.TypeBase.isInstance(n)) {
                const a = Fr(e, t, n);
                if (a) {
                  n = a;
                }
                return n;
              }
              if (H.isTypeVar(t) || !H.isTypeVar(n) || H.TypeVarType.isBound(n)) {
                if (Z.containsAnyRecursive(n, false) && !Z.containsAnyRecursive(t)) {
                  return t;
                } else {
                  return n;
                }
              } else {
                return t;
              }
            }
          });
          if (H.isNever(a)) {
            return n;
          } else {
            return a;
          }
        });
        if (Z.isIncompleteUnknown(a)) {
          return {
            type: a
          };
        } else {
          if (H.isUnknown(a)) {
            return {
              type: H.combineTypes([a, t])
            };
          } else {
            return {
              type: a
            };
          }
        }
      }
      function Mr(e, t) {
        if (!H.FunctionType.isInstanceMethod(e) && !H.FunctionType.isClassMethod(e) && !H.FunctionType.isConstructorMethod(e)) {
          return true;
        }
        const n = E.getParamListDetails(e);
        if (n.params.length === 0) {
          return true;
        }
        const a = n.params[0].param;
        if (a.category !== 0 || !H.FunctionParam.isTypeDeclared(a)) {
          return true;
        }
        const r = H.FunctionType.isInstanceMethod(e) ? H.ClassType.cloneAsInstance(t) : t;
        return Ir(n.params[0].type, r, undefined, undefined, 0);
      }
      function Or(e, t, n, a, r = true) {
        var s;
        var i;
        const o = E.getParamListDetails(e);
        const l = E.getParamListDetails(t);
        const p = new k.ConstraintTracker();
        let d = true;
        if (!H.FunctionType.isGradualCallableForm(e) && !H.FunctionType.isGradualCallableForm(t)) {
          if (H.FunctionType.isStaticMethod(e)) {
            if (!H.FunctionType.isStaticMethod(t)) {
              if (n != null) {
                n.addMessage(g.LocAddendum.overrideNotStaticMethod());
              }
              d = false;
            }
          } else {
            if (H.FunctionType.isClassMethod(e)) {
              if (!H.FunctionType.isClassMethod(t)) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.overrideNotClassMethod());
                }
                d = false;
              }
            } else {
              if (H.FunctionType.isInstanceMethod(e)) {
                if (!H.FunctionType.isInstanceMethod(t)) {
                  if (n != null) {
                    n.addMessage(g.LocAddendum.overrideNotInstanceMethod());
                  }
                  d = false;
                }
              }
            }
          }
          let c = false;
          if (l.positionParamCount < o.positionParamCount) {
            if (l.argsIndex === undefined) {
              c = true;
            } else {
              const e = l.params[l.argsIndex].type;
              for (let t = l.positionParamCount; t < o.positionParamCount; t++) {
                if (!Ir(e, o.params[t].type, n == null ? undefined : n.createAddendum(), p, 2)) {
                  g.LocAddendum.overrideParamType().format({
                    index: t + 1,
                    baseType: Yr(o.params[t].type),
                    overrideType: Yr(e)
                  });
                  d = false;
                }
              }
            }
          } else {
            if (l.positionParamCount > o.positionParamCount) {
              for (let e = o.positionParamCount; e < l.positionParamCount; e++) {
                const t = l.params[e].param;
                if (t.category === 0 && t.name && !l.params[e].defaultType) {
                  c = true;
                }
              }
            }
          }
          if (c) {
            if (n != null) {
              n.addMessage(g.LocAddendum.overridePositionalParamCount().format({
                baseCount: o.params.length,
                overrideCount: l.params.length
              }));
            }
            d = false;
          }
          const u = Math.min(o.positionParamCount, l.positionParamCount);
          for (let e = 0; e < u; e++) {
            if (e === 0 && r && (H.FunctionType.isInstanceMethod(t) || H.FunctionType.isClassMethod(t) || H.FunctionType.isConstructorMethod(t))) {
              continue;
            }
            const s = o.params[e].param;
            const i = l.params[e].param;
            if (e >= o.positionOnlyParamCount && !B.isPrivateOrProtectedName(s.name || '') && o.params[e].kind !== E.ParamKind.Positional && s.category === 0 && a && s.name !== i.name) {
              if (i.category === 0) {
                if (!H.FunctionParam.isNameSynthesized(s)) {
                  if (l.params[e].kind === E.ParamKind.Positional) {
                    if (n != null) {
                      n.addMessage(g.LocAddendum.overrideParamNamePositionOnly().format({
                        index: e + 1,
                        baseName: s.name || '*'
                      }));
                    }
                  } else {
                    if (n != null) {
                      n.addMessage(g.LocAddendum.overrideParamName().format({
                        index: e + 1,
                        baseName: s.name || '*',
                        overrideName: i.name || '*'
                      }));
                    }
                  }
                  d = false;
                }
              }
            } else {
              if (e < l.positionOnlyParamCount && e >= o.positionOnlyParamCount) {
                if (!H.FunctionParam.isNameSynthesized(s) && o.params[e].kind !== E.ParamKind.Positional && o.params[e].kind !== E.ParamKind.ExpandedArgs) {
                  if (n != null) {
                    n.addMessage(g.LocAddendum.overrideParamNamePositionOnly().format({
                      index: e + 1,
                      baseName: s.name || '*'
                    }));
                  }
                  d = false;
                }
              } else {
                const t = o.params[e].type;
                const a = l.params[e].type;
                const c = H.isTypeVar(t) && t.shared.isSynthesized;
                const u = H.isTypeVar(a) && a.shared.isSynthesized;
                if ((!r || !c && !u) && (s.category !== i.category || !Ir(a, t, n == null ? undefined : n.createAddendum(), p, 2))) {
                  if (n != null) {
                    n.addMessage(g.LocAddendum.overrideParamType().format({
                      index: e + 1,
                      baseType: Yr(t),
                      overrideType: Yr(a)
                    }));
                  }
                  d = false;
                }
                if (o.params[e].defaultType && !l.params[e].defaultType) {
                  if (n != null) {
                    n.addMessage(g.LocAddendum.overrideParamNoDefault().format({
                      index: e + 1
                    }));
                  }
                  d = false;
                }
              }
            }
          }
          if (a && l.kwargsIndex === undefined) {
            for (let e = u; e < o.positionParamCount; e++) {
              const t = o.params[e];
              if (t.kind === E.ParamKind.Standard && t.param.category === 0) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.overrideParamNamePositionOnly().format({
                    index: e + 1,
                    baseName: t.param.name || '*'
                  }));
                }
                d = false;
              }
            }
          }
          if (o.argsIndex !== undefined) {
            if (l.argsIndex === undefined) {
              if (n != null) {
                n.addMessage(g.LocAddendum.overrideParamNameMissing().format({
                  name: (s = o.params[o.argsIndex].param.name) !== null && s !== undefined ? s : '?'
                }));
              }
              d = false;
            } else {
              const e = l.params[l.argsIndex].type;
              const t = o.params[o.argsIndex].type;
              if (!Ir(e, t, n == null ? undefined : n.createAddendum(), p, 2)) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.overrideParamKeywordType().format({
                    name: (i = l.params[l.argsIndex].param.name) !== null && i !== undefined ? i : '?',
                    baseType: Yr(t),
                    overrideType: Yr(e)
                  }));
                }
                d = false;
              }
            }
          }
          const m = o.params.filter(e => e.kind === E.ParamKind.Keyword && e.param.category === 0);
          const y = l.params.filter(e => e.kind === E.ParamKind.Keyword && e.param.category === 0);
          m.forEach(e => {
            var t;
            var a;
            var r;
            const s = y.find(t => e.param.name === t.param.name);
            if (s || l.kwargsIndex !== undefined) {
              let t = s == null ? undefined : s.type;
              if (!t) {
                t = l.params[l.kwargsIndex].type;
              }
              if (!Ir(t, e.type, n == null ? undefined : n.createAddendum(), p, 2)) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.overrideParamKeywordType().format({
                    name: (a = e.param.name) !== null && a !== undefined ? a : '?',
                    baseType: Yr(e.type),
                    overrideType: Yr(t)
                  }));
                }
                d = false;
              }
              if (s && e.defaultType && !s.defaultType) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.overrideParamKeywordNoDefault().format({
                    name: (r = s.param.name) !== null && r !== undefined ? r : '?'
                  }));
                }
                d = false;
              }
            } else {
              if (n != null) {
                n.addMessage(g.LocAddendum.overrideParamNameMissing().format({
                  name: (t = e.param.name) !== null && t !== undefined ? t : '?'
                }));
              }
              d = false;
            }
          });
          y.forEach(e => {
            var t;
            if (!m.find(t => e.param.name === t.param.name)) {
              if (o.kwargsIndex === undefined) {
                if (!e.defaultType) {
                  if (n != null) {
                    n.addMessage(g.LocAddendum.overrideParamNameExtra().format({
                      name: (t = e.param.name) !== null && t !== undefined ? t : '?'
                    }));
                  }
                  d = false;
                }
              }
            }
          });
          if (o.kwargsIndex !== undefined && l.kwargsIndex === undefined) {
            if (n != null) {
              n.addMessage(g.LocAddendum.kwargsParamMissing().format({
                paramName: o.params[o.kwargsIndex].param.name
              }));
            }
            d = false;
          }
        }
        if (o.paramSpec && !l.paramSpec) {
          if (l.argsIndex === undefined || !H.isAnyOrUnknown(l.params[l.argsIndex].type) || l.kwargsIndex === undefined || !H.isAnyOrUnknown(l.params[l.kwargsIndex].type)) {
            if (n != null) {
              n.addMessage(g.LocAddendum.paramSpecMissingInOverride());
            }
            d = false;
          }
        }
        const c = hr(e);
        const u = Xe(hr(t), p);
        if (!Ir(c, u, n == null ? undefined : n.createAddendum(), p, 0)) {
          if (n != null) {
            n.addMessage(g.LocAddendum.overrideReturnType().format({
              baseType: Yr(c),
              overrideType: Yr(u)
            }));
          }
          d = false;
        }
        return d;
      }
      function zr(e) {
        const t = new Map();
        H.ClassType.getReverseMro(e).forEach(e => {
          if (H.isInstantiableClass(e)) {
            H.ClassType.getSymbolTable(e).forEach((n, a) => {
              const r = dn(e, a);
              if (r) {
                t.set(a, r);
              } else {
                t.delete(a);
              }
            });
          }
        });
        const n = [];
        t.forEach(e => {
          n.push(e);
        });
        return n;
      }
      function Ur(e, t, n, a = false, r, s, i = 0) {
        return Z.mapSignatures(t, t => {
          if (!e) {
            return H.FunctionType.clone(t, true);
          }
          if (H.FunctionType.isInstanceMethod(t)) {
            if (Z.isInstantiableMetaclass(e)) {
              return t;
            }
            const a = H.isClassInstance(e) ? e : H.ClassType.cloneAsInstance(Z.specializeWithDefaultTypeArgs(e));
            let o = false;
            if (H.isClassInstance(e) || n && Z.isInstantiableMetaclass(n)) {
              o = true;
            }
            return Vr(e, t, s, i, r ?? a, o);
          }
          if (H.FunctionType.isClassMethod(t) || a && H.FunctionType.isConstructorMethod(t)) {
            const n = H.isInstantiableClass(e) ? e : H.ClassType.cloneAsInstantiable(e);
            const a = r ? Z.convertToInstantiable(r) : undefined;
            return Vr(n, t, s, i, a ?? n, true);
          }
          if (H.FunctionType.isStaticMethod(t)) {
            return Vr(H.isInstantiableClass(e) ? e : H.ClassType.cloneAsInstantiable(e), t, s, i, undefined, false);
          }
          return t;
        });
      }
      function Vr(e, t, n, a, r, s = true) {
        const i = new k.ConstraintTracker();
        if (r && t.shared.parameters.length > 0) {
          const e = t.shared.parameters[0];
          const s = H.FunctionType.getParamType(t, 0);
          if (H.isTypeVar(s) && s.shared.boundType && H.isClassInstance(s.shared.boundType) && H.ClassType.isProtocolClass(s.shared.boundType)) {
            i.setBounds(s, H.TypeBase.isInstantiable(s) ? Z.convertToInstance(r) : r);
          } else {
            const o = n == null ? undefined : n.createAddendum();
            if (!Ir(s, r, o == null ? undefined : o.createAddendum(), i, 8192, a) && e.name && !H.FunctionParam.isNameSynthesized(e) && H.FunctionParam.isTypeDeclared(e)) {
              if (o) {
                o.addMessage(g.LocMessage.bindTypeMismatch().format({
                  type: Yr(r),
                  methodName: t.shared.name || '<anonymous>',
                  paramName: e.name
                }));
              }
              return;
            }
          }
        }
        hr(t);
        const o = Xe(t, i);
        if (H.isFunction(o)) {
          return H.FunctionType.clone(o, s, e);
        } else {
          if (H.isOverloaded(o)) {
            return H.FunctionType.clone(H.OverloadedType.getOverloads(o)[0], s, e);
          } else {
            return undefined;
          }
        }
      }
      function Rr(e) {
        return e.getDeclarations().some(e => Lr(e));
      }
      function Lr(e) {
        return e.type === 1 && !!e.isFinal;
      }
      function Br(e) {
        if (e.type !== 1 || !e.typeAnnotationNode) {
          return false;
        }
        if (e.typeAnnotationNode.nodeType !== 38 && e.typeAnnotationNode.nodeType !== 35 && e.typeAnnotationNode.nodeType !== 48) {
          return false;
        }
        const t = Ze(e.typeAnnotationNode, {
          varTypeAnnotation: true,
          allowClassVar: true
        });
        return H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'TypeAlias');
      }
      function jr(e) {
        var t;
        return e.type === 1 && !!e.typeAliasName && !e.typeAnnotationNode && ((t = e.node.parent) === null || t === undefined ? undefined : t.nodeType) === 3 && qr(e.node.parent.d.rightExpr, false);
      }
      function qr(e, t) {
        switch (e.nodeType) {
          case 0:
          case 55:
          case 4:
          case 54:
          case 6:
          case 51:
          case 56:
          case 52:
          case 9:
          case 11:
          case 46:
          case 60:
          case 61:
          case 33:
          case 40:
          case 18:
          case 34:
          case 45:
            return false;
          case 48:
          case 49:
            return t;
          case 14:
            return e.d.constType === 26;
          case 7:
            return e.d.operator === 6 && qr(e.d.leftExpr, true) && qr(e.d.rightExpr, true);
          case 27:
          case 35:
            return qr(e.d.leftExpr, t);
        }
        return true;
      }
      function Gr(e) {
        var t;
        if (Z.isEllipsisType(e)) {
          return false;
        }
        if (H.isUnknown(e)) {
          return !!((t = e.props) === null || t === undefined ? undefined : t.specialForm) && !!H.ClassType.isBuiltIn(e.props.specialForm, 'UnionType');
        }
        let n = true;
        Z.doForEachSubtype(e, e => {
          if (!H.TypeBase.isInstantiable(e) && !Z.isNoneInstance(e)) {
            n = false;
          }
        });
        return n;
      }
      function Wr(e) {
        return jr(e) || Kr(e);
      }
      function Kr(e) {
        var t;
        if (e.type !== 1 || !e.node.parent || e.node.parent.nodeType !== 3 || ((t = e.node.parent.d.rightExpr) === null || t === undefined ? undefined : t.nodeType) !== 9) {
          return false;
        }
        const n = e.node.parent.d.rightExpr.d.leftExpr;
        if ((n.nodeType === 38 && n.d.value) === 'TypedDict' || n.nodeType === 35 && n.d.member.d.value === 'TypedDict' && n.d.leftExpr.nodeType === 38) {
          const e = qe(n, 2).type;
          if (H.isInstantiableClass(e) && H.ClassType.isBuiltIn(e, 'TypedDict')) {
            return true;
          }
        }
        return false;
      }
      function $r(e) {
        return $.printObjectTypeForClass(e, n.printTypeFlags, hr);
      }
      function Hr(e, t, n) {
        const a = Yr(e, n);
        const r = Yr(t, n);
        if (a !== r) {
          return {
            sourceType: a,
            destType: r
          };
        }
        const s = Yr(e, {
          ...(n ?? {}),
          useFullyQualifiedNames: true
        });
        const i = Yr(t, {
          ...(n ?? {}),
          useFullyQualifiedNames: true
        });
        if (s !== i) {
          return {
            sourceType: s,
            destType: i
          };
        } else {
          return {
            sourceType: a,
            destType: r
          };
        }
      }
      function Zr(e) {
        return v.getFileInfo(e).diagnosticRuleSet.enableExperimentalFeatures;
      }
      function Yr(e, t) {
        let a = n.printTypeFlags;
        if (t == null ? undefined : t.expandTypeAlias) {
          a |= 32;
        }
        if (t == null ? undefined : t.enforcePythonSyntax) {
          a |= 256;
        }
        if (t == null ? undefined : t.useTypingUnpack) {
          a |= 512;
        }
        if (t == null ? undefined : t.printUnknownWithAny) {
          a |= 1;
        }
        if (t == null ? undefined : t.printTypeVarVariance) {
          a |= 2048;
        }
        if (t == null ? undefined : t.omitTypeArgsIfUnknown) {
          a |= 2;
        }
        if (t == null ? undefined : t.useFullyQualifiedNames) {
          a |= 4096;
        }
        return $.printType(e, a, hr);
      }
      function Jr() {
        return ' '.repeat(Ce);
      }
      function Qr(e) {
        const t = v.getFileInfo(e);
        return (c.convertOffsetsToRange(e.start, e.start + e.length, t.lines).start.line + 1).toString();
      }
      const Xr = a(function (e, t) {
        var n;
        var a;
        var r;
        let s;
        let i = false;
        if (H.FunctionType.isStubDefinition(e)) {
          return H.UnknownType.create();
        }
        if (H.FunctionType.isParamSpecValue(e)) {
          return H.UnknownType.create();
        }
        if (H.FunctionType.isOverloaded(e) && !H.FunctionType.isSynthesizedMethod(e)) {
          return H.UnknownType.create();
        }
        if (e.priv.inferredReturnType) {
          s = e.priv.inferredReturnType;
        } else {
          if (H.FunctionType.isInstanceMethod(e) && e.shared.name === '__init__') {
            s = pt();
          } else {
            if (e.shared.declaration) {
              const t = e.shared.declaration.node;
              if ((v.getFileInfo(t).diagnosticRuleSet.analyzeUnannotatedFunctions || !M.isUnannotatedFunction(t)) && !yt(t.d.suite)) {
                const n = v.getCodeFlowComplexity(t);
                if (e.shared.parameters.length <= 1 || e.shared.parameters.some(e => H.FunctionParam.isTypeDeclared(e)) || n < ee) {
                  let n;
                  (function (e) {
                    const t = ue.disableSpeculativeMode();
                    try {
                      e();
                      ue.enableSpeculativeMode(t);
                    } catch (e) {
                      ue.enableSpeculativeMode(t);
                      throw e;
                    }
                  })(() => {
                    n = Aa(t, H.FunctionType.isAbstractMethod(e));
                  });
                  s = n == null ? undefined : n.type;
                  if (n == null ? undefined : n.isIncomplete) {
                    i = true;
                  }
                }
              }
            }
          }
          if (!s) {
            s = H.UnknownType.create();
          }
          const t = [];
          if (e.shared.typeVarScopeId) {
            t.push(e.shared.typeVarScopeId);
          }
          if ((n = e.shared.methodClass) === null || n === undefined ? undefined : n.shared.typeVarScopeId) {
            t.push(e.shared.methodClass.shared.typeVarScopeId);
          }
          s = Z.makeTypeVarsFree(s, t);
          if (!i) {
            e.priv.inferredReturnType = s;
          }
        }
        if (!i && Z.isPartlyUnknown(s) && H.FunctionType.hasUnannotatedParams(e) && !H.FunctionType.isStubDefinition(e) && !H.FunctionType.isPyTypedDefinition(e) && t) {
          let n = false;
          let i = false;
          const o = (a = e.shared.declaration) === null || a === undefined ? undefined : a.node;
          if (o) {
            if (o.d.decorators.length > 0) {
              n = true;
            }
            if (o.d.isAsync) {
              i = true;
            }
          }
          if (!n && !i) {
            const n = function (e, t) {
              const n = t.args;
              let a;
              if (!e.shared.declaration) {
                return;
              }
              const r = e.shared.declaration.node;
              if (v.getCodeFlowComplexity(r) >= te) {
                return;
              }
              if (n.some(e => !e.paramName)) {
                return;
              }
              if (ke.some(e => e.functionNode === r)) {
                return;
              }
              const s = va(r);
              if (!s) {
                return;
              }
              if (n.length > X) {
                return;
              }
              if (ke.length >= Q) {
                return;
              }
              const i = [];
              let o = false;
              const l = M.isWithinLoop(t.errorNode);
              Qa(r, () => {
                var t;
                var p;
                const d = we;
                ke.push({
                  functionNode: r,
                  codeFlowAnalyzer: ts.createCodeFlowAnalyzer()
                });
                try {
                  we = new Map();
                  let d = true;
                  r.d.params.forEach((e, t) => {
                    if (e.d.name) {
                      let a;
                      const o = n.find(t => e.d.name.d.value === t.paramName);
                      if (o && o.argument.valueExpression) {
                        a = qe(o.argument.valueExpression).type;
                        if (!H.isUnknown(a)) {
                          d = false;
                        }
                      } else {
                        if (e.d.defaultValue) {
                          a = qe(e.d.defaultValue).type;
                          if (!H.isUnknown(a)) {
                            d = false;
                          }
                        } else {
                          if (t === 0 && (H.FunctionType.isInstanceMethod(s.functionType) || H.FunctionType.isClassMethod(s.functionType)) && s.functionType.shared.parameters.length > 0 && r.d.params[0].d.name) {
                            a = H.FunctionType.getParamType(s.functionType, 0);
                          }
                        }
                      }
                      if (!a) {
                        a = H.UnknownType.create();
                      }
                      if (l) {
                        a = Z.stripTypeForm(Ut($e(a), 0, true));
                      }
                      i.push(a);
                      Fe(e.d.name, {
                        type: a
                      }, 0);
                    }
                  });
                  if (!d) {
                    const n = (t = s.functionType.priv.callSiteReturnTypeCache) === null || t === undefined ? undefined : t.find(e => e.paramTypes.length === i.length && e.paramTypes.every((e, t) => H.isTypeSame(e, i[t])));
                    if (n) {
                      a = n.returnType;
                      o = true;
                    } else {
                      a = (p = Aa(r, H.FunctionType.isAbstractMethod(e))) === null || p === undefined ? undefined : p.type;
                    }
                  }
                } finally {
                  ke.pop();
                  we = d;
                }
              });
              if (a) {
                a = H.removeUnbound(a);
                if (!o) {
                  if (!s.functionType.priv.callSiteReturnTypeCache) {
                    s.functionType.priv.callSiteReturnTypeCache = [];
                  }
                  if (s.functionType.priv.callSiteReturnTypeCache.length >= ne) {
                    s.functionType.priv.callSiteReturnTypeCache = s.functionType.priv.callSiteReturnTypeCache.slice(1);
                  }
                  s.functionType.priv.callSiteReturnTypeCache.push({
                    paramTypes: i,
                    returnType: a
                  });
                }
                return a;
              } else {
                return undefined;
              }
            }(e, t);
            if (n && (s = n, (r = e.shared.declaration) === null || r === undefined ? undefined : r.node)) {
              const t = M.getTypeVarScopesForNode(e.shared.declaration.node);
              s = Z.makeTypeVarsFree(s, t);
            }
          }
        }
        return s;
      });
      const es = {
        runWithCancellationToken: function (e, t) {
          try {
            ge = e;
            return t();
          } finally {
            ge = undefined;
          }
        },
        getType: Le,
        getTypeResult: function (e) {
          return Ba(e, () => {
            Va(e);
          });
        },
        getTypeResultForDecorator: function (e) {
          return Ba(e, () => {
            Va(e.d.expr);
          });
        },
        getCachedType: function (e) {
          return Ne(e, 0);
        },
        getTypeOfExpression: qe,
        getTypeOfAnnotation: Ze,
        getTypeOfClass: ca,
        createSubclass: function (e, t, n) {
          var a;
          var r;
          l.assert(H.isInstantiableClass(t) && H.isInstantiableClass(n));
          let s = false;
          if (H.TypeBase.getInstantiableDepth(t) > 0 && H.TypeBase.getInstantiableDepth(n) > 0) {
            t = H.ClassType.cloneAsInstance(t);
            n = H.ClassType.cloneAsInstance(n);
            s = true;
          }
          const i = `<subclass of ${Yr(Z.convertToInstance(t), {
            omitTypeArgsIfUnknown: true
          })} and ${Yr(Z.convertToInstance(n), {
            omitTypeArgsIfUnknown: true
          })}>`;
          const o = v.getFileInfo(e);
          let p = t.shared.effectiveMetaclass;
          if (n.shared.effectiveMetaclass) {
            if (!p || !!Ir(p, n.shared.effectiveMetaclass)) {
              p = n.shared.effectiveMetaclass;
            }
          }
          let d = H.ClassType.createInstantiable(i, M.getClassFullName(e, o.moduleName, i), o.moduleName, o.fileUri, 0, M.getTypeSourceId(e), undefined, p, t.shared.docString);
          d.shared.baseClasses = [t, n];
          Z.computeMroLinearization(d);
          d = Z.addConditionToType(d, (a = t.props) === null || a === undefined ? undefined : a.condition);
          d = Z.addConditionToType(d, (r = n.props) === null || r === undefined ? undefined : r.condition);
          if (s) {
            d = H.ClassType.cloneAsInstantiable(d);
          }
          return d;
        },
        getTypeOfFunction: va,
        getTypeOfExpressionExpectingType: Ha,
        getExpectedType: Be,
        evaluateTypeForSubnode: Ba,
        evaluateTypesForStatement: La,
        evaluateTypesForMatchStatement: function (e) {
          if (De(e)) {
            return;
          }
          const t = qe(e.d.expr);
          let n = t.type;
          for (const t of e.d.cases) {
            if (!t.d.guardExpr) {
              n = O.narrowTypeBasedOnPattern(es, n, t.d.pattern, false);
            }
          }
          Fe(e, {
            type: n,
            isIncomplete: !!t.isIncomplete
          }, 0);
        },
        evaluateTypesForCaseStatement: Ma,
        evaluateTypeOfParam: Ra,
        canBeTruthy: Je,
        canBeFalsy: Ye,
        stripLiteralValue: $e,
        removeTruthinessFromType: function (e) {
          return Z.mapSubtypes(e, e => {
            const t = Pt(e);
            if (H.isClassInstance(t)) {
              if (t.priv.literalValue !== undefined) {
                let n;
                n = t.priv.literalValue instanceof H.EnumLiteral ? !Je(t) : !t.priv.literalValue;
                if (n) {
                  return e;
                } else {
                  return undefined;
                }
              }
              if (H.ClassType.isBuiltIn(t, 'bool')) {
                return H.ClassType.cloneWithLiteral(t, false);
              }
              if (H.ClassType.isBuiltIn(t, 'int')) {
                return H.ClassType.cloneWithLiteral(t, 0);
              }
              if (H.ClassType.isBuiltIn(t, ['str', 'bytes'])) {
                return H.ClassType.cloneWithLiteral(t, '');
              }
            }
            if (Ye(e)) {
              return e;
            }
          });
        },
        removeFalsinessFromType: function (e) {
          return Z.mapSubtypes(e, e => {
            const t = Pt(e);
            if (H.isClassInstance(t)) {
              if (t.priv.literalValue !== undefined) {
                let n;
                n = t.priv.literalValue instanceof H.EnumLiteral ? !Ye(t) : !!t.priv.literalValue;
                if (n) {
                  return e;
                } else {
                  return undefined;
                }
              }
              if (H.ClassType.isBuiltIn(t, 'bool')) {
                return H.ClassType.cloneWithLiteral(t, true);
              }
              if (Z.isNoneInstance(t)) {
                return;
              }
              if (H.ClassType.isBuiltIn(t, 'object')) {
                return e;
              }
            }
            if (Je(e)) {
              return e;
            }
          });
        },
        stripTypeGuard: Qe,
        solveAndApplyConstraints: Xe,
        verifyRaiseExceptionType: function (e, t) {
          const n = Za(e, 'BaseException');
          const a = qe(e).type;
          if (a && n && H.isInstantiableClass(n)) {
            const r = new p.DiagnosticAddendum();
            Z.doForEachSubtype(a, a => {
              const s = Pt(a);
              if (!H.isAnyOrUnknown(s) && !H.isNever(s) && (!t || !Z.isNoneInstance(s))) {
                if (H.isInstantiableClass(s) && s.priv.literalValue === undefined) {
                  if (Z.derivesFromClassRecursive(s, n, false)) {
                    let t;
                    Qa(e, () => {
                      t = w.validateConstructorArgs(es, e, [], s, false, undefined);
                    });
                    if (t && t.argumentErrors) {
                      r.addMessage(g.LocMessage.exceptionTypeNotInstantiable().format({
                        type: Yr(a)
                      }));
                    }
                  } else {
                    r.addMessage(g.LocMessage.exceptionTypeIncorrect().format({
                      type: Yr(a)
                    }));
                  }
                } else {
                  if (!H.isClassInstance(s) || !Z.derivesFromClassRecursive(H.ClassType.cloneAsInstantiable(s), n, false)) {
                    r.addMessage(g.LocMessage.exceptionTypeIncorrect().format({
                      type: Yr(a)
                    }));
                  }
                }
              }
            });
            if (!r.isEmpty()) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.expectedExceptionClass() + r.getString(), e);
            }
          }
        },
        verifyDeleteExpression: Ft,
        validateOverloadedArgTypes: on,
        validateInitSubclassArgs: Ta,
        isNodeReachable: gt,
        isAfterNodeReachable: ht,
        getNodeReachability: ft,
        getAfterNodeReachability: Tt,
        isAsymmetricAccessorAssignment: function (e) {
          return s.has(e.id);
        },
        suppressDiagnostics: Qa,
        isSpecialFormClass: wr,
        getDeclInfoForStringNode: function (e) {
          var t;
          const n = [];
          const a = [];
          const r = (t = Be(e)) === null || t === undefined ? undefined : t.type;
          if (r) {
            Z.doForEachSubtype(r, t => {
              var r;
              if (H.isClassInstance(t) && H.ClassType.isTypedDictClass(t) && ((r = t.shared.typedDictEntries) === null || r === undefined ? undefined : r.knownItems.get(e.d.value))) {
                const r = Z.lookUpObjectMember(t, e.d.value)?.symbol;
                if (r) {
                  o.appendArray(n, r.getDeclarations());
                  const e = r.getSynthesizedType();
                  if (e) {
                    a.push(e);
                  }
                }
              }
            });
          }
          if (n.length === 0) {
            return undefined;
          } else {
            return {
              decls: n,
              synthesizedTypes: a
            };
          }
        },
        getDeclInfoForNameNode: function (e, t = true) {
          var n;
          var a;
          var r;
          if (t && v.isCodeUnreachable(e)) {
            return;
          }
          const s = [];
          const i = [];
          const l = sr(e);
          if (l) {
            const t = V.getScopeForNode(e);
            if (t) {
              const n = t.lookUpSymbolRecursive(l.d.value);
              if (n) {
                const t = n.symbol.getDeclarations().filter(t => t.type === 8 && t.node === e.parent);
                o.appendArray(s, A.getDeclarationsWithUsesLocalNameRemoved(t));
              }
            }
          } else {
            if (e.parent && e.parent.nodeType === 35 && e === e.parent.d.member) {
              let t = Le(e.parent.d.leftExpr);
              if (t) {
                t = Pt(t);
                const n = e.parent.d.member.d.value;
                Z.doForEachSubtype(t, e => {
                  let t;
                  e = Pt(e);
                  if (H.isInstantiableClass(e)) {
                    let a = Z.lookUpClassMember(e, n, 64);
                    if (!a) {
                      a = Z.lookUpClassMember(e, n);
                    }
                    if (!a) {
                      const t = e.shared.effectiveMetaclass;
                      if (t && H.isInstantiableClass(t)) {
                        a = Z.lookUpClassMember(t, n);
                      }
                    }
                    if (a) {
                      t = a.symbol;
                    }
                  } else {
                    if (H.isClassInstance(e)) {
                      let a = Z.lookUpObjectMember(e, n, 64);
                      if (!a) {
                        a = Z.lookUpObjectMember(e, n);
                      }
                      if (a) {
                        t = a.symbol;
                      }
                    } else {
                      if (H.isModule(e)) {
                        t = H.ModuleType.getField(e, n);
                      }
                    }
                  }
                  if (t) {
                    const e = t.getTypedDeclarations();
                    if (e.length > 0) {
                      o.appendArray(s, e);
                    } else {
                      o.appendArray(s, t.getDeclarations());
                    }
                    const n = t.getSynthesizedType();
                    if (n) {
                      i.push(n);
                    }
                  }
                });
              }
            } else {
              if (e.parent && e.parent.nodeType === 37) {
                const t = e.parent.d.nameParts.findIndex(t => t === e);
                const n = v.getImportInfo(e.parent);
                if (t >= 0 && n && !n.isNativeLib && t < n.resolvedUris.length && n.resolvedUris[t]) {
                  La(e);
                  s.push(A.synthesizeAliasDeclaration(n.resolvedUris[t]));
                }
              } else {
                if (e.parent && e.parent.nodeType === 1 && e === e.parent.d.name) {
                  const t = e.parent;
                  const l = e.d.value;
                  if (((n = t.parent) === null || n === undefined ? undefined : n.nodeType) === 9) {
                    const e = Le(t.parent.d.leftExpr);
                    if (e) {
                      if (H.isFunction(e) && e.shared.declaration) {
                        const t = rr(e, l);
                        if (t) {
                          s.push(t);
                        }
                      } else {
                        if (H.isOverloaded(e)) {
                          H.OverloadedType.getOverloads(e).forEach(e => {
                            const t = rr(e, l);
                            if (t) {
                              s.push(t);
                            }
                          });
                        } else {
                          if (H.isInstantiableClass(e)) {
                            const n = (a = w.getBoundInitMethod(es, t.parent.d.leftExpr, H.ClassType.cloneAsInstance(e))) === null || a === undefined ? undefined : a.type;
                            if (n && H.isFunction(n)) {
                              const t = rr(n, l);
                              if (t) {
                                s.push(t);
                              } else {
                                if (H.ClassType.isDataClass(e) || H.ClassType.isTypedDictClass(e) || H.ClassType.hasNamedTupleEntry(e, l)) {
                                  const t = Z.lookUpClassMember(e, l);
                                  if (t) {
                                    o.appendArray(s, t.symbol.getDeclarations());
                                    const e = t.symbol.getSynthesizedType();
                                    if (e) {
                                      i.push(e);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (((r = t.parent) === null || r === undefined ? undefined : r.nodeType) === 10) {
                      const e = ca(t.parent);
                      if (e) {
                        Ta(t.parent, e.classType);
                      }
                    }
                  }
                } else {
                  const t = v.getFileInfo(e);
                  const n = M.isWithinTypeAnnotation(e, !T.isAnnotationEvaluationPostponed(v.getFileInfo(e)));
                  const a = !!M.getParentNodeOfType(e, 77);
                  const r = n || a || t.isStubFile;
                  const l = Ja(e, e.d.value, !r, n);
                  if (l) {
                    o.appendArray(s, l.symbol.getDeclarations());
                    const e = l.symbol.getSynthesizedType();
                    if (e) {
                      i.push(e);
                    }
                  }
                }
              }
            }
          }
          return {
            decls: s,
            synthesizedTypes: i
          };
        },
        getTypeForDeclaration: ir,
        resolveAliasDeclaration: pr,
        resolveAliasDeclarationWithInfo: dr,
        getTypeOfIterable: it,
        getTypeOfIterator: st,
        getGetterTypeFromProperty: function (e, t) {
          if (H.ClassType.isPropertyClass(e)) {
            if (e.priv.fgetInfo) {
              return hr(e.priv.fgetInfo.methodType);
            } else {
              return undefined;
            }
          }
        },
        getTypeOfArg: Ka,
        convertNodeToArg: en,
        buildTupleTypesList: function (e, t) {
          const n = [];
          for (const a of e) {
            let e;
            if (a.unpackedType) {
              e = a.unpackedType;
            } else {
              if (H.isUnpacked(a.type)) {
                e = a.type;
              }
            }
            if (e && H.isClassInstance(e) && e.priv.tupleTypeArgs) {
              const t = e.priv.tupleTypeArgs;
              if (t) {
                o.appendArray(n, t);
              } else {
                n.push({
                  type: H.UnknownType.create(),
                  isUnbounded: true
                });
              }
            } else {
              if (H.isNever(a.type) && a.isIncomplete && !a.unpackedType) {
                n.push({
                  type: H.UnknownType.create(true),
                  isUnbounded: false
                });
              } else {
                let e = Ut(a.type, 0, true);
                e = t ? Z.stripTypeForm($e(e)) : e;
                n.push({
                  type: e,
                  isUnbounded: !!a.unpackedType
                });
              }
            }
          }
          if (n.filter(e => e.isUnbounded).length > 1) {
            const e = n.findIndex(e => e.isUnbounded);
            const t = n.splice(e);
            n.push({
              type: H.combineTypes(t.map(e => e.type)),
              isUnbounded: true
            });
          }
          return n;
        },
        markNamesAccessed: function (e, t) {
          const n = v.getFileInfo(e);
          const a = V.getScopeForNode(e);
          if (a) {
            t.forEach(t => {
              const r = a.lookUpSymbolRecursive(t);
              if (r) {
                Et(n, r.symbol, e);
              }
            });
          }
        },
        expandPromotionTypes: function (e, t, n = false) {
          return Z.mapSubtypes(t, t => {
            if (!H.isClass(t) || !t.priv.includePromotions) {
              return t;
            }
            if (n && H.ClassType.isBuiltIn(t, 'bytes')) {
              return t;
            }
            const r = [H.ClassType.cloneRemoveTypePromotions(t)];
            const s = J.get(t.shared.fullName);
            if (s) {
              for (const n of s) {
                const s = n.split('.');
                let i = Za(e, s[s.length - 1]);
                if (i && H.isInstantiableClass(i)) {
                  i = H.ClassType.cloneRemoveTypePromotions(i);
                  if (H.isClassInstance(t)) {
                    i = H.ClassType.cloneAsInstance(i);
                  }
                  i = Z.addConditionToType(i, t.props?.condition);
                  r.push(i);
                }
              }
            }
            return H.combineTypes(r);
          });
        },
        makeTopLevelTypeVarsConcrete: Pt,
        mapSubtypesExpandTypeVars: Dt,
        isTypeSubsumedByOtherType: Ar,
        lookUpSymbolRecursive: Ja,
        getDeclaredTypeOfSymbol: yr,
        getEffectiveTypeOfSymbol: cr,
        getEffectiveTypeOfSymbolForUsage: ur,
        getInferredTypeOfDeclaration: lr,
        getDeclaredTypeForExpression: at,
        getDeclaredReturnType: fr,
        getInferredReturnType: Xr,
        getBestOverloadForArgs: function (e, t, n) {
          let a = 0;
          let r = [];
          const s = nn(e);
          let i;
          er(e, () => {
            H.OverloadedType.getOverloads(t.type).forEach(i => {
              nr(s, () => {
                const s = un(e, n, {
                  type: i,
                  isIncomplete: t.isIncomplete
                }, a);
                if (!s.argumentErrors) {
                  r.push(s);
                }
                a++;
              });
            });
          });
          r = sn(r);
          r.forEach((t, n) => {
            if (i === undefined) {
              nr(s, () => {
                const a = gn(e, t, new k.ConstraintTracker(), true);
                if (a && !a.argumentErrors) {
                  i = n;
                }
              });
            }
          });
          if (i === undefined) {
            return undefined;
          } else {
            return r[i].overload;
          }
        },
        getBuiltInType: Za,
        getTypeOfMember: Tr,
        getTypeOfBoundMember: et,
        getBoundMagicMethod: tt,
        getTypeOfMagicMethodCall: Pn,
        bindFunctionToClassOrObject: Ur,
        getCallbackProtocolType: Dr,
        getCallSignatureInfo: function (e, t, n) {
          const a = e.d.leftExpr;
          const r = Le(a);
          if (!r) {
            return;
          }
          const s = [];
          let i = 0;
          function o() {
            s.push({
              argCategory: i,
              typeResult: {
                type: H.UnknownType.create()
              },
              active: true
            });
          }
          e.d.args.forEach((e, a) => {
            let r = false;
            if (a === t) {
              if (n) {
                r = true;
              } else {
                o();
              }
            }
            i = e.d.argCategory;
            s.push({
              valueExpression: e.d.valueExpr,
              argCategory: e.d.argCategory,
              name: e.d.name,
              active: r
            });
          });
          if (e.d.args.length < t) {
            o();
          }
          let l = [];
          function p(t) {
            let n;
            nr(e, () => {
              n = fn(a, s, {
                type: t
              }, undefined, true, undefined);
            });
            l.push({
              type: nt(t),
              activeParam: n == null ? undefined : n.activeParam
            });
          }
          function d(e) {
            if (H.isFunction(e)) {
              p(e);
            } else {
              H.OverloadedType.getOverloads(e).forEach(e => {
                p(e);
              });
            }
          }
          Z.doForEachSubtype(r, e => {
            switch (e.category) {
              case 4:
              case 5:
                d(e);
                break;
              case 6:
                if (H.TypeBase.isInstantiable(e)) {
                  const t = w.createFunctionFromConstructor(es, e);
                  if (t) {
                    Z.doForEachSubtype(t, e => {
                      if (H.isFunction(e) || H.isOverloaded(e)) {
                        d(e);
                      }
                    });
                    const e = l.filter(e => !H.FunctionType.isGradualCallableForm(e.type) || e.type.shared.parameters.length > 2 || e.type.shared.docString || e.type.shared.deprecatedMessage);
                    if (e.length > 0) {
                      l = e;
                    }
                  }
                } else {
                  const t = tt(e, '__call__');
                  if (t) {
                    d(t);
                  }
                }
            }
          });
          if (l.length !== 0) {
            return {
              callNode: e,
              signatures: l
            };
          } else {
            return undefined;
          }
        },
        getAbstractSymbols: zr,
        narrowConstrainedTypeVar: function (e, t) {
          const n = v.getFlowNode(e);
          if (n) {
            return ts.narrowConstrainedTypeVar(n, t);
          }
        },
        assignType: Ir,
        validateOverrideMethod: function (e, t, n, a, r = true) {
          if (!H.isFunction(e) && !H.isOverloaded(e)) {
            a.addMessage(g.LocAddendum.overrideType().format({
              type: Yr(e)
            }));
            return false;
          }
          if (H.isFunction(e)) {
            if (H.isFunction(t)) {
              return Or(e, t, a, r);
            }
            const n = [...H.OverloadedType.getOverloads(t)];
            const s = H.OverloadedType.getImplementation(t);
            if (s && H.isFunction(s)) {
              n.push(s);
            }
            return !!n.some(t => Or(e, t, undefined, r)) || (a.addMessage(g.LocAddendum.overrideNoOverloadMatches()), false);
          }
          if (H.isFunction(t)) {
            return H.OverloadedType.getOverloads(e).every(e => !!n && !Mr(e, n) || Or(e, t, a == null ? undefined : a.createAddendum(), r));
          }
          let s = -1;
          const i = H.OverloadedType.getOverloads(e);
          for (const e of H.OverloadedType.getOverloads(t)) {
            let t;
            let o = i.findIndex((a, i) => {
              if (n && !Mr(a, n)) {
                return false;
              }
              const o = Or(a, e, undefined, r, false);
              if (o && i <= s && t === undefined) {
                t = i;
                return false;
              } else {
                return o;
              }
            });
            if (o < 0 && t !== undefined) {
              o = t;
            }
            if (o < 0) {
              break;
            }
            if (o < s) {
              a.addMessage(g.LocAddendum.overrideOverloadOrder());
              return false;
            }
            s = o;
          }
          if (s < i.length - 1) {
            const e = i.slice(s + 1);
            if (!n || e.some(e => Mr(e, n))) {
              a.addMessage(g.LocAddendum.overrideOverloadNoMatch());
              return false;
            }
          }
          return true;
        },
        validateCallArgs: pn,
        validateTypeArg: Ln,
        assignTypeToExpression: Nt,
        assignClassToSelf: _r,
        getTypedDictClassType: function () {
          if ((Ae == null ? undefined : Ae.typedDictPrivateClass) && H.isInstantiableClass(Ae.typedDictPrivateClass)) {
            return Ae.typedDictPrivateClass;
          } else {
            return undefined;
          }
        },
        getTupleClassType: ot,
        getDictClassType: function () {
          if ((Ae == null ? undefined : Ae.dictClass) && H.isInstantiableClass(Ae.dictClass)) {
            return Ae.dictClass;
          } else {
            return undefined;
          }
        },
        getStrClassType: function () {
          if ((Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass)) {
            return Ae.strClass;
          } else {
            return undefined;
          }
        },
        getObjectType: lt,
        getNoneType: pt,
        getUnionClassType: function () {
          var e;
          if ((e = Ae == null ? undefined : Ae.unionTypeClass) !== null && e !== undefined) {
            return e;
          } else {
            return H.UnknownType.create();
          }
        },
        getTypeClassType: dt,
        getBuiltInObject: Ya,
        getTypingType: ct,
        assignTypeArgs: Cr,
        reportMissingTypeArgs: Rt,
        inferReturnTypeIfNecessary: gr,
        inferVarianceForClass: ya,
        isFinalVariable: Rr,
        isFinalVariableDeclaration: Lr,
        isExplicitTypeAliasDeclaration: Br,
        addInformation: bt,
        addUnusedCode: function (e, t) {
          if (!Ct(e)) {
            v.getFileInfo(e).diagnosticSink.addUnusedCodeWithTextRange(g.LocMessage.unreachableCode(), t);
          }
        },
        addUnreachableCode: function (e, t, n) {
          if (t !== K.Reachability.Reachable && !Ct(e)) {
            const a = v.getFileInfo(e);
            const r = a.diagnosticRuleSet.enableReachabilityAnalysis;
            if (t === K.Reachability.UnreachableAlways || r) {
              a.diagnosticSink.addUnreachableCodeWithTextRange(t === K.Reachability.UnreachableAlways ? g.LocMessage.unreachableCode() : g.LocMessage.unreachableCodeType(), n);
            }
          }
        },
        addDeprecated: function (e, t) {
          if (!Ct(t)) {
            v.getFileInfo(t).diagnosticSink.addDeprecatedWithTextRange(e, t);
          }
        },
        addDiagnostic: kt,
        addDiagnosticForTextRange: wt,
        printType: Yr,
        printSrcDestTypes: Hr,
        printFunctionParts: function (e, t) {
          const a = t ? n.printTypeFlags | t : n.printTypeFlags;
          return $.printFunctionParts(e, a, hr);
        },
        getTypeCacheEntryCount: function () {
          return Te.size;
        },
        disposeEvaluator: function () {
          he = new Set();
          fe = new Map();
          Te = new Map();
          ve = new Map();
          be = new Map();
        },
        useSpeculativeMode: nr,
        isSpeculativeModeInUse: ar,
        setTypeResultForNode: Ee,
        checkForCancellation: xe,
        printControlFlowGraph: function (e, t, n, a) {
          return ts.printControlFlowGraph(e, t, n, a);
        }
      };
      const ts = b.getCodeFlowEngine(es, ue);
      return es;
    };
    const i = require(91426);
    const o = require(58147);
    const l = require(48281);
    const p = require(11479);
    const d = require(65880);
    const c = require(56814);
    const u = require(63808);
    const m = require(88754);
    const y = require(27113);
    const g = require(67703);
    const h = require(85114);
    const f = require(96941);
    const T = require(12673);
    const v = __importStar(require(26687));
    const b = require(19914);
    const _ = require(50299);
    const C = require(70617);
    const I = require(10081);
    const k = require(86672);
    const w = require(20516);
    const S = require(57373);
    const A = require(83760);
    const x = require(26163);
    const P = require(21451);
    const D = require(39245);
    const N = require(60055);
    const F = require(19327);
    const E = require(44321);
    const M = __importStar(require(41557));
    const O = require(69932);
    const z = require(89460);
    const U = require(54500);
    const V = __importStar(require(95952));
    const R = require(28676);
    const L = require(58253);
    const B = require(12097);
    const j = require(4064);
    const q = require(63278);
    const G = require(17486);
    const W = require(66308);
    const K = require(83055);
    const $ = __importStar(require(55501));
    const H = require(21024);
    const Z = require(92324);
    const Y = new Map([['asyncio.futures.Future', u.pythonVersion3_9], ['asyncio.tasks.Task', u.pythonVersion3_9], ['builtins.dict', u.pythonVersion3_9], ['builtins.frozenset', u.pythonVersion3_9], ['builtins.list', u.pythonVersion3_9], ['builtins._PathLike', u.pythonVersion3_9], ['builtins.set', u.pythonVersion3_9], ['builtins.tuple', u.pythonVersion3_9], ['collections.ChainMap', u.pythonVersion3_9], ['collections.Counter', u.pythonVersion3_9], ['collections.defaultdict', u.pythonVersion3_9], ['collections.DefaultDict', u.pythonVersion3_9], ['collections.deque', u.pythonVersion3_9], ['collections.OrderedDict', u.pythonVersion3_9], ['queue.Queue', u.pythonVersion3_9]]);
    const J = new Map([['builtins.float', ['builtins.int']], ['builtins.complex', ['builtins.float', 'builtins.int']], ['builtins.bytes', ['builtins.bytearray', 'builtins.memoryview']]]);
    const Q = 2;
    const X = 6;
    const ee = 32;
    const te = 8;
    const ne = 8;
    const ae = 64;
    const re = 64;
    const se = 16;
    const ie = 64;
    const oe = 12;
    const le = 10;
    const pe = 16;
    const de = false;
    const ce = false;
    exports.maxCodeComplexity = 768;
  },
  83055: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Reachability = exports.maxInferredContainerDepth = exports.maxSubtypesForInferredType = undefined;
    exports.maxSubtypesForInferredType = 64;
    exports.maxInferredContainerDepth = 8;
    (function (e) {
      e[e.Reachable = 0] = 'Reachable';
      e[e.UnreachableAlways = 1] = 'UnreachableAlways';
      e[e.UnreachableByAnalysis = 2] = 'UnreachableByAnalysis';
    })(n || (exports.Reachability = n = {}));
  },
  23274: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createTypeEvaluatorWithTracker = function (e, t, n, o) {
      function l(e) {
        if (t.logCalls && n.logLevel === a.LogLevel.Log) {
          return (...a) => n.log(e.name, t => {
            if (e.name === 'importLookup' && a.length > 0) {
              t.add(o == null ? undefined : o.printFileOrModuleName(a[0]));
            } else {
              a.forEach(e => {
                t.add(o == null ? undefined : o.print(e));
              });
            }
            return s.timingStats.typeEvaluationTime.timeOperation(e, ...a);
          }, t.minimumLoggingThreshold, true);
        } else {
          if (r.isDebugMode()) {
            return e;
          } else {
            return s.timingStats.typeEvaluationTime.timeOperation.bind(s.timingStats.typeEvaluationTime, e);
          }
        }
      }
      e = l(e);
      const p = i.createTypeEvaluator(e, t, l);
      Object.keys(p).forEach(e => {
        const t = p[e];
        if (typeof t == 'function' && t.name) {
          p[e] = l(t);
        }
      });
      return p;
    };
    const a = require(25075);
    const r = require(34455);
    const s = require(71582);
    const i = require(90080);
  },
  18891: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getTypeNarrowingCallback = T;
    exports.getIsInstanceClassTypes = w;
    exports.narrowTypeForInstanceOrSubclass = S;
    exports.getElementTypeForContainerNarrowing = F;
    exports.narrowTypeForContainerElementType = E;
    exports.narrowTypeForDiscriminatedDictEntryComparison = O;
    exports.narrowTypeForDiscriminatedTupleComparison = z;
    exports.narrowTypeForDiscriminatedLiteralFieldComparison = U;
    exports.enumerateLiteralsForType = j;
    const i = require(48281);
    const o = require(85114);
    const l = require(26687);
    const p = require(10081);
    const d = require(86672);
    const c = require(21451);
    const u = __importStar(require(41557));
    const m = require(95952);
    const y = require(58253);
    const g = require(66308);
    const h = require(21024);
    const f = require(92324);
    function T(e, t, n, a, r = 0) {
      if (r > h.maxTypeRecursionCount) {
        return;
      }
      r++;
      if (n.nodeType === 4) {
        return function (e, t, n, a, r) {
          var s;
          if ((s = T(e, t, n.d.rightExpr, a, r)) !== null && s !== undefined) {
            return s;
          } else {
            return T(e, t, n.d.name, a, r);
          }
        }(e, t, n, a, r);
      }
      if (n.nodeType === 7) {
        const r = n.d.operator === 39 || n.d.operator === 40;
        const s = n.d.operator === 12 || n.d.operator === 28;
        const i = s || n.d.operator === 20 || n.d.operator === 21 || n.d.operator === 15 || n.d.operator === 16;
        if (r || s) {
          const i = n.d.operator === 39 || n.d.operator === 12 ? a : !a;
          if (n.d.rightExpr.nodeType === 14 && n.d.rightExpr.d.constType === 26) {
            let a = n.d.leftExpr;
            if (a.nodeType === 4) {
              a = a.d.name;
            }
            if (u.isMatchingExpression(t, a)) {
              return t => ({
                type: I(e, t, i),
                isIncomplete: false
              });
            }
            if (a.nodeType === 27 && u.isMatchingExpression(t, a.d.leftExpr) && a.d.items.length === 1 && !a.d.trailingComma && a.d.items[0].d.argCategory === 0 && !a.d.items[0].d.name && a.d.items[0].d.valueExpr.nodeType === 40 && a.d.items[0].d.valueExpr.d.isInteger && !a.d.items[0].d.valueExpr.d.isImaginary) {
              const t = a.d.items[0].d.valueExpr.d.value;
              if (typeof t == 'number') {
                return n => ({
                  type: C(e, n, i, t),
                  isIncomplete: false
                });
              }
            }
          }
          if (n.d.rightExpr.nodeType === 21) {
            let a = n.d.leftExpr;
            if (a.nodeType === 4) {
              a = a.d.name;
            }
            if (u.isMatchingExpression(t, a)) {
              return t => ({
                type: k(e, n, t, i),
                isIncomplete: false
              });
            }
          }
          if (n.d.leftExpr.nodeType === 9 && n.d.leftExpr.d.args.length === 1 && n.d.leftExpr.d.args[0].d.argCategory === 0) {
            const a = n.d.leftExpr.d.args[0].d.valueExpr;
            if (u.isMatchingExpression(t, a)) {
              const t = e.getTypeOfExpression(n.d.leftExpr.d.leftExpr, 2).type;
              if (h.isInstantiableClass(t) && h.ClassType.isBuiltIn(t, 'type')) {
                const t = e.getTypeOfExpression(n.d.rightExpr);
                const a = e.makeTopLevelTypeVarsConcrete(t.type);
                if (h.isInstantiableClass(a)) {
                  return n => ({
                    type: R(e, n, a, i),
                    isIncomplete: !!t.isIncomplete
                  });
                }
              }
            }
          }
          if (r) {
            if (u.isMatchingExpression(t, n.d.leftExpr)) {
              const t = e.getTypeOfExpression(n.d.rightExpr);
              const a = t.type;
              if (h.isClassInstance(a) && (h.ClassType.isEnumClass(a) || h.ClassType.isBuiltIn(a, 'bool')) && a.priv.literalValue !== undefined) {
                return n => ({
                  type: B(e, n, a, i, true),
                  isIncomplete: !!t.isIncomplete
                });
              }
              if (h.isInstantiableClass(a)) {
                return n => ({
                  type: L(e, n, a, i),
                  isIncomplete: !!t.isIncomplete
                });
              }
            }
            if (n.d.leftExpr.nodeType === 27 && n.d.leftExpr.d.items.length === 1 && !n.d.leftExpr.d.trailingComma && n.d.leftExpr.d.items[0].d.argCategory === 0 && u.isMatchingExpression(t, n.d.leftExpr.d.leftExpr)) {
              const t = e.getTypeOfExpression(n.d.leftExpr.d.items[0].d.valueExpr);
              const a = t.type;
              if (h.isClassInstance(a) && f.isLiteralType(a)) {
                if (h.ClassType.isBuiltIn(a, 'str')) {
                  const r = e.getTypeOfExpression(n.d.rightExpr).type;
                  if (h.isClassInstance(r) && r.priv.literalValue !== undefined) {
                    return n => ({
                      type: O(e, n, a, r, i),
                      isIncomplete: !!t.isIncomplete
                    });
                  }
                } else {
                  if (h.ClassType.isBuiltIn(a, 'int')) {
                    const t = e.getTypeOfExpression(n.d.rightExpr);
                    const r = t.type;
                    if (h.isClassInstance(r) && r.priv.literalValue !== undefined) {
                      let n = false;
                      if (h.ClassType.isBuiltIn(r, 'bool') || r.priv.literalValue instanceof h.EnumLiteral) {
                        n = true;
                      }
                      if (n) {
                        return n => ({
                          type: z(e, n, a, r, i),
                          isIncomplete: !!t.isIncomplete
                        });
                      }
                    }
                  }
                }
              }
            }
          }
          if (s) {
            const r = n.d.operator === 12 ? a : !a;
            if (u.isMatchingExpression(t, n.d.leftExpr)) {
              const t = e.getTypeOfExpression(n.d.rightExpr);
              const a = t.type;
              if (h.isClassInstance(a) && a.priv.literalValue !== undefined) {
                return n => ({
                  type: B(e, n, a, r, false),
                  isIncomplete: !!t.isIncomplete
                });
              }
            }
            if (n.d.leftExpr.nodeType === 27 && n.d.leftExpr.d.items.length === 1 && !n.d.leftExpr.d.trailingComma && n.d.leftExpr.d.items[0].d.argCategory === 0 && u.isMatchingExpression(t, n.d.leftExpr.d.leftExpr)) {
              const t = e.getTypeOfExpression(n.d.leftExpr.d.items[0].d.valueExpr);
              const a = t.type;
              if (h.isClassInstance(a) && f.isLiteralType(a) && h.ClassType.isBuiltIn(a, ['str', 'int'])) {
                const s = e.getTypeOfExpression(n.d.rightExpr);
                const i = s.type;
                if (f.isLiteralTypeOrUnion(i)) {
                  return n => {
                    let o;
                    o = h.ClassType.isBuiltIn(a, 'str') ? O(e, n, a, i, r) : z(e, n, a, i, r);
                    return {
                      type: o,
                      isIncomplete: !!t.isIncomplete || !!s.isIncomplete
                    };
                  };
                }
              }
            }
          }
          if (s && n.d.leftExpr.nodeType === 35 && u.isMatchingExpression(t, n.d.leftExpr.d.leftExpr)) {
            const t = e.getTypeOfExpression(n.d.rightExpr);
            const a = t.type;
            const r = n.d.leftExpr.d.member;
            if (h.isClassInstance(a) && (a.priv.literalValue !== undefined || f.isNoneInstance(a))) {
              return n => ({
                type: U(e, n, r.d.value, a, i),
                isIncomplete: !!t.isIncomplete
              });
            }
          }
          if (n.d.leftExpr.nodeType === 35 && u.isMatchingExpression(t, n.d.leftExpr.d.leftExpr)) {
            const t = e.getTypeOfExpression(n.d.rightExpr);
            const a = t.type;
            const r = n.d.leftExpr.d.member;
            if (h.isClassInstance(a) && (h.ClassType.isEnumClass(a) || h.ClassType.isBuiltIn(a, 'bool')) && a.priv.literalValue !== undefined) {
              return n => ({
                type: U(e, n, r.d.value, a, i),
                isIncomplete: !!t.isIncomplete
              });
            }
          }
          if (n.d.leftExpr.nodeType === 35 && u.isMatchingExpression(t, n.d.leftExpr.d.leftExpr) && n.d.rightExpr.nodeType === 14 && n.d.rightExpr.d.constType === 26) {
            const t = n.d.leftExpr.d.member;
            return n => ({
              type: V(e, n, t.d.value, i),
              isIncomplete: false
            });
          }
        }
        if (i && n.d.leftExpr.nodeType === 9 && n.d.leftExpr.d.args.length === 1) {
          const r = n.d.leftExpr.d.args[0].d.valueExpr;
          if (u.isMatchingExpression(t, r)) {
            const t = e.getTypeOfExpression(n.d.leftExpr.d.leftExpr, 2);
            const r = t.type;
            if (h.isFunction(r) && r.shared.fullName === 'builtins.len') {
              const r = e.getTypeOfExpression(n.d.rightExpr);
              const s = r.type;
              if (h.isClassInstance(s) && typeof s.priv.literalValue == 'number' && s.priv.literalValue >= 0) {
                let i = s.priv.literalValue;
                const o = n.d.operator === 12 || n.d.operator === 20 || n.d.operator === 21 ? a : !a;
                if (n.d.operator === 21 || n.d.operator === 15) {
                  i++;
                }
                const l = n.d.operator === 12 || n.d.operator === 28;
                return n => ({
                  type: P(e, n, i, o, !l),
                  isIncomplete: !!t.isIncomplete || !!r.isIncomplete
                });
              }
            }
          }
        }
        if (n.d.operator === 41 || n.d.operator === 42) {
          if (u.isMatchingExpression(t, n.d.leftExpr)) {
            const t = e.getTypeOfExpression(n.d.rightExpr);
            const r = t.type;
            const s = n.d.operator === 41 ? a : !a;
            return n => ({
              type: N(e, n, r, s),
              isIncomplete: !!t.isIncomplete
            });
          }
          if (u.isMatchingExpression(t, n.d.rightExpr)) {
            const t = e.getTypeOfExpression(n.d.leftExpr);
            const r = t.type;
            if (h.isClassInstance(r) && h.ClassType.isBuiltIn(r, 'str') && f.isLiteralType(r)) {
              const s = n.d.operator === 41 ? a : !a;
              return n => ({
                type: M(e, n, h.ClassType.cloneAsInstantiable(r), s),
                isIncomplete: !!t.isIncomplete
              });
            }
          }
        }
      }
      if (n.nodeType === 9) {
        if (n.d.args.length === 2) {
          const r = n.d.args[0].d.valueExpr;
          const s = n.d.args[1].d.valueExpr;
          if (u.isMatchingExpression(t, r)) {
            const t = e.getTypeOfExpression(n.d.leftExpr, 2);
            const r = t.type;
            if (h.isFunction(r) && h.FunctionType.isBuiltIn(r, ['isinstance', 'issubclass'])) {
              const i = h.FunctionType.isBuiltIn(r, 'isinstance');
              const o = e.getTypeOfExpression(s, 536871546);
              const l = o.type;
              const p = w(e, l);
              const d = !!t.isIncomplete || !!o.isIncomplete;
              if (p) {
                return t => ({
                  type: S(e, t, p, i, false, a, n),
                  isIncomplete: d
                });
              }
              if (d) {
                return e => ({
                  type: e,
                  isIncomplete: true
                });
              }
            }
          }
        }
        if (n.d.args.length === 1 && !n.d.args[0].d.name && u.isMatchingExpression(t, n.d.args[0].d.valueExpr)) {
          const t = e.getTypeOfExpression(n.d.leftExpr, 2);
          const r = t.type;
          if (h.isInstantiableClass(r) && h.ClassType.isBuiltIn(r, 'bool')) {
            return n => ({
              type: _(e, n, a),
              isIncomplete: !!t.isIncomplete
            });
          }
        }
        if (n.d.args.length >= 1) {
          const r = n.d.args[0].d.valueExpr;
          if (u.isMatchingExpression(t, r)) {
            let t = false;
            const r = e => e.shared.declaredReturnType && h.isClassInstance(e.shared.declaredReturnType) && h.ClassType.isBuiltIn(e.shared.declaredReturnType, ['TypeGuard', 'TypeIs']);
            const s = e.getTypeOfExpression(n.d.leftExpr, 2);
            const i = s.type;
            if (h.isFunction(i) && r(i) || h.isOverloaded(i) && h.OverloadedType.getOverloads(i).some(e => r(e)) || h.isClassInstance(i)) {
              t = true;
            }
            if (t) {
              const t = e.getTypeOfExpression(n);
              const r = t.type;
              if (h.isClassInstance(r) && h.ClassType.isBuiltIn(r, ['TypeGuard', 'TypeIs']) && r.priv.typeArgs && r.priv.typeArgs.length > 0) {
                const i = h.ClassType.isBuiltIn(r, 'TypeIs');
                const o = r.priv.typeArgs[0];
                const l = !!s.isIncomplete || !!t.isIncomplete;
                return t => ({
                  type: b(e, t, o, a, i, n),
                  isIncomplete: l
                });
              }
            }
          }
        }
      }
      if (u.isMatchingExpression(t, n)) {
        return t => ({
          type: _(e, t, a),
          isIncomplete: false
        });
      }
      const s = function (e, t, n, a, r) {
        if (n.nodeType !== 38 || t.nodeType !== 38 || n === t) {
          return;
        }
        const s = v(e, n, n, true);
        if (!s || s.length !== 1 || s[0].type !== 1) {
          return;
        }
        const i = v(e, t, n, false);
        if (!i) {
          return;
        }
        let l = [];
        if (i.length > 1) {
          l = i.filter(t => e.isNodeReachable(n, t.node) && e.isNodeReachable(t.node, s[0].node));
        }
        if (l.length !== 0) {
          return;
        }
        const p = s[0].inferredTypeSource;
        if (!p || u.isNodeContainedWithin(n, p) || !o.isExpressionNode(p)) {
          return;
        }
        return T(e, t, p, a, r);
      }(e, t, n, a, r);
      return s || (t.nodeType === 38 && n.nodeType === 55 && n.d.operator === 38 ? T(e, t, n.d.expr, !a, r) : undefined);
    }
    function v(e, t, n, a) {
      const r = m.getScopeForNode(t);
      if ((r == null ? undefined : r.type) !== 2 && (r == null ? undefined : r.type) !== 4) {
        return;
      }
      const s = r.lookUpSymbol(t.d.value);
      if (!s) {
        return;
      }
      const i = s.getDeclarations();
      if (a && i.length > 1) {
        return;
      }
      if (i.length === 0 || i.some(e => e.type !== 1 && e.type !== 2)) {
        return;
      }
      let o;
      if (i.some(e => {
        const t = e.type === 2 ? e.node.d.name : e.node;
        const n = u.getExecutionScopeNode(t);
        return !!o && n !== o || (o = n, false);
      })) {
        return;
      }
      const l = i.filter(t => e.isNodeReachable(n, t.node));
      if (l.length > 0) {
        return l;
      } else {
        return undefined;
      }
    }
    function b(e, t, n, a, r, s) {
      if (!r) {
        let e = t;
        if (a) {
          e = n;
          if (!!h.isTypeVar(t) && !h.isParamSpec(t) && !h.TypeVarType.hasConstraints(t)) {
            e = f.addConditionToType(e, [{
              typeVar: t,
              constraintIndex: 0
            }]);
          }
          return e;
        } else {
          return e;
        }
      }
      const i = [];
      f.doForEachSubtype(n, e => {
        i.push(f.convertToInstantiable(e));
      });
      return S(e, t, i, true, true, a, s);
    }
    function _(e, t, n) {
      return f.mapSubtypes(t, t => {
        if (n) {
          if (e.canBeTruthy(t)) {
            return e.removeFalsinessFromType(t);
          }
        } else {
          if (e.canBeFalsy(t)) {
            return e.removeTruthinessFromType(t);
          }
        }
      });
    }
    function C(e, t, n, a) {
      return e.mapSubtypesExpandTypeVars(t, undefined, t => {
        const r = f.getSpecializedTupleType(t);
        if (!r || f.isUnboundedTupleClass(r) || !r.priv.tupleTypeArgs) {
          return t;
        }
        const s = r.priv.tupleTypeArgs.length;
        if (a < 0 || a >= s) {
          return t;
        }
        const i = e.makeTopLevelTypeVarsConcrete(r.priv.tupleTypeArgs[a].type);
        if (n) {
          if (!e.assignType(i, e.getNoneType())) {
            return;
          }
        } else {
          if (f.isNoneInstance(i)) {
            return;
          }
        }
        return t;
      });
    }
    function I(e, t, n) {
      const a = f.mapSubtypes(t, e => f.transformPossibleRecursiveTypeAlias(e));
      let r = false;
      const s = e.mapSubtypesExpandTypeVars(a, undefined, (t, a) => {
        var s;
        if (h.isAnyOrUnknown(t)) {
          return t;
        }
        let i = false;
        if (h.isTypeVar(a) && !h.TypeVarType.isSelf(a)) {
          if (a.shared.constraints.some(t => e.assignType(t, e.getNoneType()))) {
            i = true;
          }
          if (a.shared.boundType && e.assignType(a.shared.boundType, e.getNoneType())) {
            i = true;
          }
        }
        const o = i ? t : a;
        if (f.isNoneInstance(t)) {
          r = true;
          return n ? o : undefined;
        } else {
          if (e.assignType(t, e.getNoneType())) {
            r = true;
            return n ? f.addConditionToType(e.getNoneType(), (s = t.props) === null || s === undefined ? undefined : s.condition) : o;
          } else {
            if (n) {
              return undefined;
            } else {
              return o;
            }
          }
        }
      });
      if (n && r) {
        return f.mapSubtypes(s, e => f.isNoneInstance(e) ? e : undefined);
      } else {
        return s;
      }
    }
    function k(e, t, n, a) {
      var r;
      var s;
      const i = f.mapSubtypes(n, e => f.transformPossibleRecursiveTypeAlias(e));
      const o = (s = (r = e.getBuiltInObject(t, 'EllipsisType')) !== null && r !== undefined ? r : e.getBuiltInObject(t, 'ellipsis')) !== null && s !== undefined ? s : h.AnyType.create();
      return e.mapSubtypesExpandTypeVars(i, undefined, (e, t) => {
        var n;
        if (h.isAnyOrUnknown(e)) {
          return e;
        }
        const r = h.isTypeVar(t) && !h.TypeVarType.hasConstraints(t) ? t : e;
        if (h.isClassInstance(e) && h.ClassType.isBuiltIn(e, 'object')) {
          if (a) {
            return f.addConditionToType(o, (n = e.props) === null || n === undefined ? undefined : n.condition);
          } else {
            return r;
          }
        }
        if ((h.isClassInstance(e) && h.ClassType.isBuiltIn(e, ['EllipsisType', 'ellipsis'])) === a) {
          return e;
        } else {
          return undefined;
        }
      });
    }
    function w(e, t) {
      let n = false;
      const a = [];
      const r = (t, s = 0) => {
        if (!(s > h.maxTypeRecursionCount)) {
          if (h.isClass(t) && h.TypeBase.isInstance(t) && f.isTupleClass(t)) {
            if (t.priv.tupleTypeArgs) {
              t.priv.tupleTypeArgs.forEach(e => {
                r(e.type, s + 1);
              });
            }
          } else {
            f.doForEachSubtype(t, t => {
              [t].forEach(t => {
                if (h.isClass(t)) {
                  t = f.specializeWithUnknownTypeArgs(t, e.getTupleClassType());
                  if (h.isInstantiableClass(t) && h.ClassType.isBuiltIn(t, 'Callable')) {
                    t = f.convertToInstantiable(f.getUnknownTypeForCallable());
                  }
                }
                if (h.isInstantiableClass(t)) {
                  if (!t.priv.includeSubclasses && t.priv.includePromotions) {
                    t = h.ClassType.cloneRemoveTypePromotions(t);
                  }
                  a.push(t);
                } else {
                  if (h.isTypeVar(t) && h.TypeBase.isInstantiable(t)) {
                    a.push(t);
                  } else {
                    if (f.isNoneTypeClass(t)) {
                      i.assert(h.isInstantiableClass(t));
                      a.push(t);
                    } else {
                      if (h.isFunction(t) && t.shared.parameters.length === 2 && t.shared.parameters[0].category === 1 && t.shared.parameters[1].category === 2) {
                        a.push(t);
                      } else {
                        n = true;
                      }
                    }
                  }
                }
              });
            });
          }
        }
      };
      f.doForEachSubtype(t, e => {
        r(e);
      });
      if (n) {
        return undefined;
      } else {
        return a;
      }
    }
    function S(e, t, n, a, r, s, i) {
      const o = A(e, t, n, a, r, s, false, i);
      if (h.isNever(o)) {
        return A(e, t, n, a, r, s, true, i);
      } else {
        return o;
      }
    }
    function A(e, t, n, a, r, s, i, o) {
      const c = f.mapSubtypes(t, t => {
        let c = t;
        let m = false;
        let g = n;
        if (!a) {
          const a = h.isClassInstance(t) && h.ClassType.isBuiltIn(t, 'type');
          if (f.isMetaclassInstance(t) && !a) {
            g = n.map(e => f.convertToInstantiable(e));
          } else {
            const n = f.convertToInstance(t);
            c = h.isClassInstance(t) && h.ClassType.isBuiltIn(t, 'type') && h.isAnyOrUnknown(n) ? f.convertToInstance(e.getObjectType()) : n;
            m = true;
          }
        }
        const T = function (e, t, n, a, r, s, i) {
          let o = f.mapSubtypes(t, e => f.transformPossibleRecursiveTypeAlias(e));
          o = e.expandPromotionTypes(i, o);
          const c = e => a ? e : f.makeTypeVarsFree(e, u.getTypeVarScopesForNode(i));
          const m = (t, o, m, g) => {
            var T;
            var v;
            var b;
            var _;
            var C;
            const I = [];
            let k = false;
            let w = false;
            for (const g of n) {
              const n = e.makeTopLevelTypeVarsConcrete(g);
              if (h.isInstantiableClass(n)) {
                const l = n.shared.effectiveMetaclass;
                if (f.isInstantiableMetaclass(o) && h.TypeBase.getInstantiableDepth(n) > 0 && l && h.isInstantiableClass(l)) {
                  const t = f.convertToInstance(o);
                  let n = e.assignType(c(t), h.ClassType.cloneAsInstance(l));
                  if (h.ClassType.isBuiltIn(l, 'type') && !l.priv.isTypeArgExplicit) {
                    if (!h.isClass(t) || !h.ClassType.isBuiltIn(t, 'type')) {
                      n = false;
                    }
                  }
                  if (n) {
                    if (r) {
                      I.push(g);
                      k = true;
                    } else {
                      if (!h.isTypeSame(t, l) || !!l.priv.includeSubclasses) {
                        I.push(t);
                        w = true;
                      }
                    }
                    continue;
                  }
                }
                let y = o;
                if (!a) {
                  y = f.makeTypeVarsFree(y, u.getTypeVarScopesForNode(i));
                }
                if (h.isInstantiableClass(y) && h.ClassType.isTypedDictClass(y)) {
                  const t = e.getDictClassType();
                  const n = e.getStrClassType();
                  if (t && n) {
                    y = h.ClassType.specialize(t, [h.ClassType.cloneAsInstance(n), h.UnknownType.create()]);
                  }
                }
                const _ = e.assignType(g, y, undefined, undefined, 81920);
                let C = e.assignType(y, g, undefined, undefined, 81920);
                if (_) {
                  k = true;
                }
                if (h.ClassType.isBuiltIn(y, 'TypeForm')) {
                  w = true;
                  C = true;
                }
                if (_) {
                  if (!a && n.priv.includeSubclasses) {
                    w = true;
                  }
                  if (C && !h.ClassType.isSameGenericClass(y, n)) {
                    if (!h.ClassType.isBuiltIn(n, 'type') || h.TypeBase.getInstantiableDepth(y) === 0) {
                      w = true;
                    }
                  }
                }
                if (h.isTypeVar(t) && h.isTypeVar(g)) {
                  w = true;
                }
                if (r) {
                  if (_) {
                    if (h.isTypeVar(t) && h.TypeVarType.isSelf(t)) {
                      I.push(f.addConditionToType(t, m));
                    } else {
                      I.push(f.addConditionToType(o, m));
                    }
                  } else {
                    if (C) {
                      let t = g;
                      if (h.isClass(g) && (h.ClassType.isSpecialBuiltIn(g) || g.shared.typeParams.length > 0) && !g.priv.isTypeArgExplicit && !h.ClassType.isSameGenericClass(o, g)) {
                        const n = new d.ConstraintTracker();
                        const a = h.ClassType.specialize(g, undefined);
                        if (p.addConstraintsForExpectedType(e, h.ClassType.cloneAsInstance(a), h.ClassType.cloneAsInstance(o), n, undefined, i.start)) {
                          t = e.solveAndApplyConstraints(a, n, {
                            replaceUnsolved: {
                              scopeIds: f.getTypeVarScopeIds(g),
                              useUnknown: true,
                              tupleClassType: e.getTupleClassType()
                            }
                          });
                        }
                      }
                      I.push(f.addConditionToType(t, m));
                    } else {
                      if (h.ClassType.isSameGenericClass(h.ClassType.cloneAsInstance(o), h.ClassType.cloneAsInstance(n))) {
                        if (!a && ((T = o.priv) === null || T === undefined ? undefined : T.literalValue) === undefined && ((v = n.priv) === null || v === undefined ? undefined : v.literalValue) === undefined) {
                          const a = x(e, o, n);
                          I.push(a ?? t);
                        }
                      } else {
                        if (s && !h.ClassType.isFinal(o) && !h.ClassType.isFinal(n)) {
                          let a = e.createSubclass(i, o, n);
                          if (!!h.isTypeVar(t) && !h.isParamSpec(t) && !h.TypeVarType.hasConstraints(t)) {
                            a = f.addConditionToType(a, [{
                              typeVar: t,
                              constraintIndex: 0
                            }]);
                          }
                          I.push(f.addConditionToType(a, (b = o.props) === null || b === undefined ? undefined : b.condition));
                        }
                      }
                    }
                  }
                } else {
                  if (h.isAnyOrUnknown(t) || f.derivesFromAnyOrUnknown(t) && !h.isTypeSame(o, n)) {
                    I.push(f.addConditionToType(t, m));
                  }
                }
              } else {
                if (h.isTypeVar(g) && h.TypeBase.isInstantiable(g)) {
                  if (h.TypeBase.isInstance(t)) {
                    if (h.isTypeVar(t) && h.isTypeSame(f.convertToInstance(g), t)) {
                      if (r) {
                        I.push(t);
                      } else {
                        k = true;
                      }
                    } else {
                      if (r) {
                        I.push(f.convertToInstance(g));
                      } else {
                        I.push(t);
                        w = true;
                      }
                    }
                  }
                } else {
                  if (h.isFunction(g)) {
                    let n = false;
                    if (h.isClass(o)) {
                      n = !!h.TypeBase.isInstantiable(t) || !!f.lookUpClassMember(o, '__call__', 16);
                    }
                    if (n) {
                      if (r) {
                        I.push(f.convertToInstantiable(t));
                      } else {
                        k = true;
                      }
                    } else {
                      if (e.assignType(c(o), g, undefined, undefined, 16384)) {
                        if (r) {
                          I.push(f.addConditionToType(g, (_ = o.props) === null || _ === undefined ? undefined : _.condition));
                        }
                      } else {
                        if (s && r) {
                          const e = `<callable subtype of ${o.shared.name}>`;
                          const t = l.getFileInfo(i);
                          let n = h.ClassType.createInstantiable(e, u.getClassFullName(i, t.moduleName, e), t.moduleName, t.fileUri, 0, u.getTypeSourceId(i), undefined, o.shared.effectiveMetaclass, o.shared.docString);
                          n.shared.baseClasses = [o];
                          f.computeMroLinearization(n);
                          n = f.addConditionToType(n, (C = o.props) === null || C === undefined ? undefined : C.condition);
                          const a = h.FunctionType.createSynthesizedInstance('__call__');
                          const r = h.FunctionParam.create(0, h.ClassType.cloneAsInstance(n), h.FunctionParamFlags.TypeDeclared, 'self');
                          h.FunctionType.addParam(a, r);
                          h.FunctionType.addDefaultParams(a);
                          a.shared.declaredReturnType = h.UnknownType.create();
                          h.ClassType.getSymbolTable(n).set('__call__', y.Symbol.createWithType(4, a));
                          I.push(h.ClassType.cloneAsInstance(n));
                        }
                      }
                    }
                  }
                }
              }
            }
            if (!r && (!k || !!w)) {
              I.push(f.convertToInstantiable(g));
            }
            return I.map(e => f.convertToInstance(e));
          };
          const g = t => h.isInstantiableClass(t) && e.getCallbackProtocolType(h.ClassType.cloneAsInstance(t)) !== undefined;
          const T = (t, s) => {
            const i = [];
            if (r) {
              for (const r of n) {
                const n = e.makeTopLevelTypeVarsConcrete(r);
                if (!a && g(n)) {
                  i.push(f.convertToInstance(t));
                } else {
                  if (e.assignType(c(t), f.convertToInstance(n))) {
                    if (h.isFunction(r)) {
                      i.push(f.convertToInstance(s));
                    } else {
                      i.push(f.convertToInstance(r));
                    }
                  } else {
                    if (e.assignType(f.convertToInstance(c(n)), t)) {
                      i.push(f.convertToInstance(t));
                    }
                  }
                }
              }
            } else {
              if (n.every(n => {
                const r = e.makeTopLevelTypeVarsConcrete(n);
                if (!a && g(r)) {
                  return false;
                }
                if (h.isFunction(r) && h.FunctionType.isGradualCallableForm(r)) {
                  return false;
                }
                const s = e.assignType(f.convertToInstance(c(r)), t);
                const i = e.assignType(c(t), f.convertToInstance(r));
                return !s || i;
              })) {
                i.push(f.convertToInstance(t));
              }
            }
            return i;
          };
          const v = () => n.some(e => !!f.isNoneTypeClass(e) || h.isInstantiableClass(e) && h.ClassType.isBuiltIn(e, 'NoneType'));
          const b = [];
          const _ = [];
          const C = e.mapSubtypesExpandTypeVars(o, {
            expandCallback: t => e.expandPromotionTypes(i, t)
          }, (t, a) => {
            const s = f.getTypeCondition(t) ? t : a;
            if (r && h.isAnyOrUnknown(t)) {
              b.push(h.combineTypes(n.map(e => f.convertToInstance(e))));
              _.push(t);
              return;
            }
            if (f.isNoneInstance(t)) {
              if (v() === r) {
                return t;
              } else {
                return undefined;
              }
            }
            if ((h.isModule(t) || h.isClassInstance(t) && h.ClassType.isBuiltIn(t, 'ModuleType')) && r) {
              const t = n.filter(t => {
                const n = e.makeTopLevelTypeVarsConcrete(t);
                return h.isInstantiableClass(n) && h.ClassType.isProtocolClass(n);
              });
              if (t.length > 0) {
                return f.convertToInstance(h.combineTypes(t));
              }
            }
            if (h.isClass(t)) {
              return h.combineTypes(m(a, h.ClassType.cloneAsInstantiable(t), f.getTypeCondition(t), s));
            } else {
              if (h.isFunction(t) || h.isOverloaded(t)) {
                return h.combineTypes(T(t, a));
              } else {
                if (r) {
                  return undefined;
                } else {
                  return s;
                }
              }
            }
          });
          if (h.isNever(C) && b.length > 0) {
            return h.combineTypes(b);
          }
          if (h.isNever(C) && _.length > 0) {
            return h.combineTypes(_);
          }
          return C;
        }(e, c, g, r, s, i, o);
        if (m) {
          return f.convertToInstantiable(T);
        } else {
          return T;
        }
      });
      return c;
    }
    function x(e, t, n) {
      var a;
      var r;
      i.assert(h.isInstantiableClass(t) && h.isInstantiableClass(n));
      i.assert(h.ClassType.isSameGenericClass(t, n));
      i.assert(((a = t.priv) === null || a === undefined ? undefined : a.literalValue) === undefined);
      i.assert(((r = n.priv) === null || r === undefined ? undefined : r.literalValue) === undefined);
      if (h.ClassType.isBuiltIn(t, 'tuple')) {
        return function (e, t) {
          var n;
          var a;
          if (!t.priv.tupleTypeArgs || f.isTupleGradualForm(t)) {
            return f.addConditionToType(e, (n = t.props) === null || n === undefined ? undefined : n.condition);
          }
          if (!e.priv.tupleTypeArgs || f.isTupleGradualForm(e)) {
            return f.addConditionToType(t, (a = e.props) === null || a === undefined ? undefined : a.condition);
          }
          return;
        }(t, t);
      }
    }
    function P(e, t, n, a, r) {
      return f.mapSubtypes(t, t => {
        const s = e.makeTopLevelTypeVarsConcrete(t);
        if (!h.isClassInstance(s) || !f.isTupleClass(s) || !s.priv.tupleTypeArgs) {
          return t;
        }
        if (s.priv.tupleTypeArgs.some(e => h.isUnpackedTypeVarTuple(e.type))) {
          return t;
        }
        if (!s.priv.tupleTypeArgs.some(e => e.isUnbounded)) {
          if ((r ? s.priv.tupleTypeArgs.length < n : s.priv.tupleTypeArgs.length === n) === a) {
            return t;
          } else {
            return undefined;
          }
        }
        const i = n - s.priv.tupleTypeArgs.length + 1;
        if (!r) {
          if (i < 0) {
            if (a) {
              return undefined;
            } else {
              return t;
            }
          }
          if (!a) {
            const e = s.priv.tupleTypeArgs.length - 1;
            if (n === e) {
              return D(s, 1, true);
            } else {
              return t;
            }
          }
          return D(s, i, false);
        }
        if (h.isParamSpec(t) && t.priv.paramSpecAccess) {
          return t;
        }
        if (i > 32) {
          return t;
        }
        if (a) {
          if (i < 1) {
            return;
          }
          const e = [];
          for (let t = 0; t < i; t++) {
            e.push(D(s, t, false));
          }
          return h.combineTypes(e);
        }
        return D(s, i, true);
      });
    }
    function D(e, t, n) {
      const a = [];
      e.priv.tupleTypeArgs.forEach(e => {
        if (e.isUnbounded) {
          for (let n = 0; n < t; n++) {
            a.push({
              isUnbounded: false,
              type: e.type
            });
          }
          if (n) {
            a.push(e);
          }
        } else {
          a.push(e);
        }
      });
      return f.specializeTupleClass(e, a);
    }
    function N(e, t, n, a) {
      if (a) {
        const a = F(n);
        if (a) {
          return E(e, t, e.makeTopLevelTypeVarsConcrete(a));
        } else {
          return t;
        }
      }
      if (!h.isClassInstance(n) || !h.ClassType.isBuiltIn(n, 'tuple') || !n.priv.tupleTypeArgs) {
        return t;
      }
      const r = [];
      n.priv.tupleTypeArgs.forEach(e => {
        if (!e.isUnbounded) {
          if (f.isNoneInstance(e.type) || h.isClassInstance(e.type) && f.isLiteralType(e.type)) {
            r.push(e.type);
          }
        }
      });
      if (r.length === 0) {
        return t;
      } else {
        return f.mapSubtypes(t, t => {
          t = e.makeTopLevelTypeVarsConcrete(t);
          if (h.isClassInstance(t) && t.priv.literalValue === undefined) {
            const n = j(e, t);
            if (n && n.length > 0) {
              return h.combineTypes(n.filter(e => !r.some(t => h.isTypeSame(t, e))));
            }
          }
          if (!r.some(e => h.isTypeSame(e, t))) {
            return t;
          }
        });
      }
    }
    function F(e) {
      if (!h.isClassInstance(e) || !h.ClassType.isBuiltIn(e, ['list', 'set', 'frozenset', 'deque', 'tuple', 'dict', 'defaultdict', 'OrderedDict'])) {
        return;
      }
      if (!e.priv.typeArgs || e.priv.typeArgs.length < 1) {
        return;
      }
      let t = e.priv.typeArgs[0];
      if (f.isTupleClass(e) && e.priv.tupleTypeArgs) {
        t = h.combineTypes(e.priv.tupleTypeArgs.map(e => e.type));
      }
      return t;
    }
    function E(e, t, n) {
      return e.mapSubtypesExpandTypeVars(t, undefined, t => f.mapSubtypes(n, n => {
        if (h.isAnyOrUnknown(n)) {
          return t;
        } else {
          if (e.assignType(t, n)) {
            return f.stripTypeForm(f.addConditionToType(n, t.props?.condition));
          } else {
            if (e.assignType(n, t)) {
              return f.stripTypeForm(f.addConditionToType(t, n.props?.condition));
            } else {
              return undefined;
            }
          }
        }
      }));
    }
    function M(e, t, n, a) {
      return e.mapSubtypesExpandTypeVars(t, undefined, (t, r) => {
        var s;
        var i;
        if (h.isParamSpec(r)) {
          return r;
        }
        if (h.isClassInstance(t) && h.ClassType.isTypedDictClass(t)) {
          const r = g.getTypedDictMembersForClass(e, t, true);
          const o = (s = r.knownItems.get(n.priv.literalValue)) !== null && s !== undefined ? s : r.extraItems;
          if (a) {
            if (!o) {
              return;
            }
            if (o.isRequired || o.isProvided) {
              return t;
            }
            const e = new Map((i = t.priv.typedDictNarrowedEntries) !== null && i !== undefined ? i : []);
            e.set(n.priv.literalValue, {
              valueType: o.valueType,
              isReadOnly: o.isReadOnly,
              isRequired: false,
              isProvided: true
            });
            return h.ClassType.cloneAsInstance(h.ClassType.cloneForNarrowedTypedDictEntries(h.ClassType.cloneAsInstantiable(t), e));
          }
          if (o !== undefined && (o.isRequired || o.isProvided)) {
            return undefined;
          } else {
            return t;
          }
        }
        return t;
      });
    }
    function O(e, t, n, a, r) {
      let s = true;
      const i = f.mapSubtypes(t, t => {
        if (h.isClassInstance(t) && h.ClassType.isTypedDictClass(t)) {
          const s = g.getTypedDictMembersForClass(e, t).knownItems.get(n.priv.literalValue);
          if (s && f.isLiteralTypeOrUnion(s.valueType)) {
            if (r) {
              let n = false;
              f.doForEachSubtype(a, t => {
                if (e.assignType(s.valueType, t)) {
                  n = true;
                }
              });
              if (n) {
                return t;
              } else {
                return undefined;
              }
            }
            {
              let n = false;
              f.doForEachSubtype(a, t => {
                if (!e.assignType(t, s.valueType)) {
                  n = true;
                }
              });
              if (n) {
                return t;
              } else {
                return undefined;
              }
            }
          }
        }
        s = false;
        return t;
      });
      if (s) {
        return i;
      } else {
        return t;
      }
    }
    function z(e, t, n, a, r) {
      let s = true;
      const i = f.mapSubtypes(t, t => {
        if (h.isClassInstance(t) && h.ClassType.isTupleClass(t) && !f.isUnboundedTupleClass(t) && typeof n.priv.literalValue == 'number' && h.isClassInstance(a)) {
          const s = n.priv.literalValue;
          if (t.priv.tupleTypeArgs && s >= 0 && s < t.priv.tupleTypeArgs.length) {
            const n = t.priv.tupleTypeArgs[s]?.type;
            if (n && f.isLiteralTypeOrUnion(n)) {
              if (r) {
                if (e.assignType(n, a)) {
                  return t;
                } else {
                  return undefined;
                }
              } else {
                if (e.assignType(a, n)) {
                  return undefined;
                } else {
                  return t;
                }
              }
            }
          }
        }
        s = false;
        return t;
      });
      if (s) {
        return i;
      } else {
        return t;
      }
    }
    function U(e, t, n, a, r) {
      return f.mapSubtypes(t, t => {
        let i;
        if (h.isClassInstance(t)) {
          i = f.lookUpObjectMember(t, n);
        } else {
          if (h.isInstantiableClass(t)) {
            i = f.lookUpClassMember(t, n);
          }
        }
        if (i && i.isTypeDeclared) {
          let n = e.getTypeOfMember(i);
          if (h.isClassInstance(t) && h.isClassInstance(n) && f.isProperty(n)) {
            const e = n.priv.fgetInfo?.methodType;
            if (e && e.shared.declaredReturnType) {
              const t = h.FunctionType.getEffectiveReturnType(e);
              if (t) {
                n = t;
              }
            }
          }
          if (f.isLiteralTypeOrUnion(n, true)) {
            if (r) {
              if (e.assignType(n, a)) {
                return t;
              } else {
                return undefined;
              }
            } else {
              if (e.assignType(a, n)) {
                return undefined;
              } else {
                return t;
              }
            }
          }
        }
        return t;
      });
    }
    function V(e, t, n, a) {
      return f.mapSubtypes(t, t => {
        let r;
        if (h.isClassInstance(t)) {
          r = f.lookUpObjectMember(t, n);
        } else {
          if (h.isInstantiableClass(t)) {
            r = f.lookUpClassMember(t, n);
          }
        }
        if (r && r.isTypeDeclared) {
          const t = e.makeTopLevelTypeVarsConcrete(e.getTypeOfMember(r));
          let n = true;
          if (a) {
            f.doForEachSubtype(t, t => {
              t = e.makeTopLevelTypeVarsConcrete(t);
              if (f.isProperty(t) || f.isMaybeDescriptorInstance(t)) {
                n = false;
              }
              if (h.isAnyOrUnknown(t) || f.isNoneInstance(t) || h.isNever(t)) {
                n = false;
              }
            });
          } else {
            n = f.isNoneInstance(t);
          }
          if (n) {
            return;
          }
        }
        return t;
      });
    }
    function R(e, t, n, a) {
      return e.mapSubtypesExpandTypeVars(t, undefined, (e, t) => {
        var r;
        if (h.isClassInstance(e)) {
          const t = h.ClassType.isDerivedFrom(n, h.ClassType.cloneAsInstantiable(e));
          if (a) {
            if (t) {
              if (h.ClassType.isSameGenericClass(h.ClassType.cloneAsInstantiable(e), n)) {
                return f.addConditionToType(e, f.getTypeCondition(n));
              } else {
                return f.addConditionToType(h.ClassType.cloneAsInstance(n), (r = e.props) === null || r === undefined ? undefined : r.condition);
              }
            }
            if (!n.priv.includeSubclasses) {
              return;
            }
          } else {
            if (!n.priv.includeSubclasses) {
              if (t && h.ClassType.isFinal(e)) {
                return;
              }
              return e;
            }
          }
        } else {
          if (h.isAnyOrUnknown(e)) {
            if (a) {
              return h.ClassType.cloneAsInstance(f.addConditionToType(n, f.getTypeCondition(e)));
            } else {
              return e;
            }
          }
        }
        return t;
      });
    }
    function L(e, t, n, a) {
      return f.mapSubtypes(t, t => {
        let r = e.makeTopLevelTypeVarsConcrete(t);
        if (a) {
          if (h.isClassInstance(r) && h.TypeBase.isInstance(t) && h.ClassType.isBuiltIn(r, 'type')) {
            r = r.priv.typeArgs && r.priv.typeArgs.length > 0 ? f.convertToInstantiable(r.priv.typeArgs[0]) : h.UnknownType.create();
          }
          if (h.isAnyOrUnknown(r)) {
            return f.addConditionToType(n, f.getTypeCondition(r));
          }
          if (h.isClass(r)) {
            if (h.TypeBase.isInstance(r)) {
              if (h.ClassType.isBuiltIn(r, 'object')) {
                return n;
              } else {
                return undefined;
              }
            }
            const e = function (e, t, n, a) {
              if (h.isTypeVar(n) || a.priv.literalValue !== undefined) {
                return h.isTypeSame(f.convertToInstance(n), e);
              }
              if (a.priv.includeSubclasses) {
                return false;
              }
              if (h.ClassType.isDerivedFrom(t, a)) {
                return true;
              }
              if (h.ClassType.isBuiltIn(a, 'dict') && h.ClassType.isTypedDictClass(t)) {
                return true;
              }
              return false;
            }(t, r, n, n);
            if (!n.priv.includeSubclasses) {
              if (!r.priv.includeSubclasses) {
                if (h.ClassType.isSameGenericClass(r, n)) {
                  return n;
                } else {
                  return undefined;
                }
              }
              if (e) {
                return f.addConditionToType(n, f.getTypeCondition(r));
              }
              if (h.ClassType.isDerivedFrom(n, r)) {
                return f.addConditionToType(n, f.getTypeCondition(r));
              } else {
                return undefined;
              }
            }
            if (h.ClassType.isFinal(r) && !e) {
              return;
            }
          }
        } else {
          if (h.isInstantiableClass(r) && h.ClassType.isSameGenericClass(n, r) && h.ClassType.isFinal(n)) {
            return;
          }
        }
        return t;
      });
    }
    function B(e, t, n, a, r) {
      return e.mapSubtypesExpandTypeVars(t, undefined, t => {
        t = e.makeTopLevelTypeVarsConcrete(t);
        if (h.isAnyOrUnknown(t)) {
          if (a) {
            return n;
          } else {
            return t;
          }
        }
        if (h.isClassInstance(t) && h.ClassType.isSameGenericClass(n, t)) {
          if (t.priv.literalValue !== undefined) {
            const e = h.ClassType.isLiteralValueSame(t, n);
            if (e && !a || !e && a) {
              return;
            }
            return t;
          }
          if (a) {
            return n;
          }
          {
            const a = j(e, t);
            if (a && a.length > 0) {
              return h.combineTypes(a.filter(e => !h.ClassType.isLiteralValueSame(e, n)));
            }
          }
        } else {
          if (a && (r || f.isNoneInstance(t))) {
            if (e.assignType(t, n)) {
              return n;
            } else {
              return undefined;
            }
          }
        }
        return t;
      });
    }
    function j(e, t) {
      if (h.ClassType.isBuiltIn(t, 'bool')) {
        return [h.ClassType.cloneWithLiteral(t, true), h.ClassType.cloneWithLiteral(t, false)];
      }
      if (h.ClassType.isEnumClass(t)) {
        if (t.shared.baseClasses.some(e => h.isClass(e) && h.ClassType.isBuiltIn(e, 'Flag'))) {
          return;
        }
        const n = [];
        h.ClassType.getSymbolTable(t).forEach((a, r) => {
          var s;
          if (!a.isIgnoredForProtocolMatch()) {
            let i = e.getEffectiveTypeOfSymbol(a);
            i = (s = c.transformTypeForEnumMember(e, t, r)) !== null && s !== undefined ? s : i;
            if (h.isClassInstance(i) && h.ClassType.isSameGenericClass(t, i) && i.priv.literalValue !== undefined) {
              n.push(i);
            }
          }
        });
        return n;
      }
    }
  },
  55501: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.printType = function (e, t, n) {
      const a = new k(t, n);
      a.build(e);
      return f(e, t, n, a, [], 0);
    };
    exports.printFunctionParts = function (e, t, n) {
      const a = new k(t, n);
      a.build(e);
      return b(e, t, n, a, [], 0);
    };
    exports.printObjectTypeForClass = function (e, t, n) {
      const a = new k(t, n);
      a.build(e);
      return v(e, t, n, a, [], 0);
    };
    exports.isLiteralValueTruncated = y;
    exports.printLiteralValueTruncated = g;
    exports.printLiteralValue = h;
    const i = require(58147);
    const o = require(48281);
    const l = require(44321);
    const p = __importStar(require(41557));
    const d = require(14400);
    const c = require(21024);
    const u = require(92324);
    const m = 50;
    function y(e) {
      return typeof e.priv.literalValue == 'string' && e.priv.literalValue.length > m;
    }
    function g(e) {
      if (e.shared.name === 'bytes') {
        return 'bytes';
      } else {
        o.assert(e.shared.name === 'str');
        return 'LiteralString';
      }
    }
    function h(e, t = '\'') {
      const n = e.priv.literalValue;
      if (n === undefined) {
        return '';
      }
      let a;
      if (typeof n == 'string') {
        let r = n;
        if (n.length > m) {
          r = n.substring(0, m) + '…';
        }
        a = e.shared.name === 'bytes' ? d.printBytesLiteral(r) : d.printStringLiteral(r, t);
      } else {
        if (typeof n == 'boolean') {
          a = n ? 'True' : 'False';
        } else {
          if (n instanceof c.EnumLiteral) {
            a = `${n.className}.${n.itemName}`;
          } else {
            if (typeof n == 'bigint') {
              a = n.toString();
              if (a.endsWith('n')) {
                a = a.substring(0, a.length - 1);
              }
            } else {
              a = n.toString();
            }
          }
        }
      }
      return a;
    }
    function f(e, t, n, a, r, s) {
      var i;
      var o;
      var l;
      var p;
      if (s > c.maxTypeRecursionCount) {
        if (t & 256) {
          return 'Any';
        } else {
          return '<Recursive>';
        }
      }
      s++;
      const d = t;
      const m = !!(t & 16);
      t &= -145;
      const b = (i = e.props) === null || i === undefined ? undefined : i.typeAliasInfo;
      if (b) {
        let i = true;
        if (t & 32) {
          if (r.find(t => t === e)) {
            i = false;
          }
        } else {
          i = false;
        }
        if (!i) {
          try {
            r.push(e);
            let i = t & 4096 ? b.shared.fullName : b.shared.name;
            if (!a.isUnique(i)) {
              i = b.shared.fullName;
            }
            const o = b.shared.typeParams;
            if (o && o.length > 0) {
              let e;
              if (b.typeArgs) {
                if (!(t & 2) || !!b.typeArgs.some(e => !c.isUnknown(e))) {
                  e = [];
                  b.typeArgs.forEach((i, l) => {
                    const p = l < o.length ? o[l] : o[o.length - 1];
                    if (c.isTypeVarTuple(p) && c.isClassInstance(i) && u.isTupleClass(i) && i.priv.tupleTypeArgs && i.priv.tupleTypeArgs.every(e => !e.isUnbounded)) {
                      i.priv.tupleTypeArgs.forEach(i => {
                        e.push(f(i.type, t, n, a, r, s));
                      });
                    } else {
                      e.push(f(i, t, n, a, r, s));
                    }
                  });
                }
              } else {
                if (!(t & 2) || !!o.some(e => !c.isUnknown(e))) {
                  e = [];
                  o.forEach(i => {
                    e.push(f(i, t, n, a, r, s));
                  });
                }
              }
              if (e) {
                if (e.length === 0) {
                  i += '[()]';
                } else {
                  i += `[${e.join(', ')}]`;
                }
              }
            }
            if (e.category !== 9) {
              return i;
            }
          } finally {
            r.pop();
          }
        }
      }
      if (r.find(t => {
        var n;
        return t === e || !!((n = t.props) === null || n === undefined ? undefined : n.typeAliasInfo) && t.props.typeAliasInfo.shared.fullName === (b == null ? undefined : b.shared.fullName);
      }) || r.length > c.maxTypeRecursionCount) {
        if (c.isTypeVar(e) && e.shared.isSynthesized && e.shared.recursiveAlias) {
          return e.shared.recursiveAlias.name;
        }
        if (b) {
          if (!b.shared.typeParams) {
            let e = t & 4096 ? b.shared.fullName : b.shared.name;
            if (!a.isUnique(e)) {
              e = b.shared.fullName;
            }
            return e;
          }
          try {
            r.push(e);
            return f(e, t & -33, n, a, r, s);
          } finally {
            r.pop();
          }
        }
        return '...';
      }
      try {
        r.push(e);
        const i = !(t & 320);
        const b = e => {
          var t;
          if (((t = e.props) === null || t === undefined ? undefined : t.condition) && i) {
            return '*';
          } else {
            return '';
          }
        };
        const k = (e, t) => `${C(e, t)}${b(e)}`;
        switch (e.category) {
          case 0:
            if (t & 256) {
              return 'Any';
            } else {
              return 'Unbound';
            }
          case 1:
            if (t & 257) {
              return 'Any';
            } else {
              return 'Unknown';
            }
          case 7:
            if (t & 256) {
              return 'Any';
            } else {
              return `Module("${e.priv.moduleName}")`;
            }
          case 6:
            if (c.TypeBase.isInstance(e)) {
              if (e.priv.literalValue !== undefined) {
                if (y(e) && t & 256) {
                  return g(e);
                } else {
                  return `Literal[${h(e)}]`;
                }
              } else {
                return `${v(e, t, n, a, r, s)}${b(e)}`;
              }
            }
            {
              let i;
              if (e.priv.literalValue !== undefined) {
                i = y(e) && t & 256 ? g(e) : `Literal[${h(e)}]`;
                return k(e, i);
              }
              if ((o = e.props) === null || o === undefined ? undefined : o.specialForm) {
                return f(e.props.specialForm, t, n, a, r, s);
              }
              i = v(e, t, n, a, r, s);
              return k(e, i);
            }
          case 4:
            if (c.TypeBase.isInstantiable(e)) {
              return `type[${T(c.FunctionType.cloneAsInstance(e), t, n, a, r, s)}]`;
            }
            return T(e, d, n, a, r, s);
          case 5:
            {
              const i = c.OverloadedType.getOverloads(e).map(e => f(e, t, n, a, r, s));
              if (t & 256) {
                return 'Callable[..., Any]';
              } else {
                if (i.length === 1) {
                  return i[0];
                } else {
                  return `Overload[${i.join(', ')}]`;
                }
              }
            }
          case 8:
            if (c.TypeBase.isInstantiable(e) && ((l = e.props) === null || l === undefined ? undefined : l.specialForm) && !((p = e.props) === null || p === undefined ? undefined : p.typeAliasInfo)) {
              return f(e.props.specialForm, t, n, a, r, s);
            }
            return function (e, t, n, a, r, s, i) {
              const o = new Set();
              const l = new Set();
              if (!(t & 32) && e.priv.typeAliasSources) {
                for (const n of e.priv.typeAliasSources) {
                  let p = true;
                  let d = true;
                  const m = new Set();
                  for (const t of n.priv.subtypes) {
                    let n = 0;
                    let a = false;
                    const r = u.convertToInstance(t);
                    for (const t of e.priv.subtypes) {
                      if (c.isTypeSame(r, t)) {
                        if (!o.has(n)) {
                          d = false;
                        }
                        m.add(n);
                        a = true;
                        break;
                      }
                      n++;
                    }
                    if (!a) {
                      p = false;
                      break;
                    }
                  }
                  if (p && !d) {
                    l.add(f(n, t, a, r, s, i));
                    m.forEach(e => o.add(e));
                  }
                }
              }
              const p = e.priv.subtypes.findIndex(e => u.isNoneInstance(e));
              if (p >= 0 && !o.has(p)) {
                const o = u.removeNoneFromUnion(e);
                if (c.isNever(o)) {
                  return 'None';
                }
                const l = f(o, t, a, r, s, i);
                if (t & 8) {
                  const e = l + ' | None';
                  if (n) {
                    return `(${e})`;
                  } else {
                    return e;
                  }
                }
                return `Optional[${l}]`;
              }
              const d = new Set();
              const m = new Set();
              u.doForEachSubtype(e, (e, n) => {
                if (!o.has(n)) {
                  if (c.isClassInstance(e) && e.priv.literalValue !== undefined) {
                    if (y(e) && t & 256) {
                      l.add(g(e));
                    } else {
                      d.add(h(e));
                    }
                  } else {
                    if (c.isInstantiableClass(e) && e.priv.literalValue !== undefined) {
                      if (y(e) && t & 256) {
                        l.add(`type[${g(e)}]`);
                      } else {
                        m.add(h(e));
                      }
                    } else {
                      l.add(f(e, t, a, r, s, i));
                    }
                  }
                }
              });
              const T = [];
              l.forEach(e => T.push(e));
              if (d.size > 0) {
                const e = [];
                d.forEach(t => e.push(t));
                T.push(`Literal[${e.join(', ')}]`);
              }
              if (m.size > 0) {
                const e = [];
                m.forEach(t => e.push(t));
                T.push(`type[Literal[${e.join(', ')}]]`);
              }
              if (T.length === 1) {
                return T[0];
              }
              if (t & 8) {
                const e = T.join(' | ');
                if (n) {
                  return `(${e})`;
                } else {
                  return e;
                }
              }
              return `Union[${T.join(', ')}]`;
            }(e, t & 8 ? t | 128 : t, m, n, a, r, s);
          case 9:
            {
              if (e.shared.isSynthesized) {
                if (e.shared.recursiveAlias) {
                  if (t & 32 && e.shared.boundType) {
                    return f(c.TypeBase.isInstance(e) ? u.convertToInstance(e.shared.boundType) : e.shared.boundType, t, n, a, r, s);
                  } else {
                    return e.shared.recursiveAlias.name;
                  }
                }
                if (c.TypeVarType.isSelf(e) && e.shared.boundType) {
                  let i = f(e.shared.boundType, t & -33, n, a, r, s);
                  if (!c.isAnyOrUnknown(e.shared.boundType)) {
                    i = t & 256 || t & 8192 ? 'Self' : `Self@${i}`;
                  }
                  if (c.TypeBase.isInstantiable(e)) {
                    return `${C(e, i)}`;
                  } else {
                    return i;
                  }
                }
                if (t & 257) {
                  return 'Any';
                } else {
                  return 'Unknown';
                }
              }
              if (c.isParamSpec(e)) {
                const n = I(e, !(t & 256) && !(t & 8192));
                if (e.priv.paramSpecAccess) {
                  return `${n}.${e.priv.paramSpecAccess}`;
                } else {
                  return n;
                }
              }
              let i = I(e, !(t & 256) && !(t & 8192));
              if (e.priv.isUnpacked) {
                i = _(i, t);
              }
              if (c.isTypeVarTuple(e) && e.priv.isInUnion) {
                i = `Union[${i}]`;
              }
              if (c.TypeBase.isInstantiable(e)) {
                i = `${C(e, i)}`;
              }
              if (!c.isTypeVarTuple(e) && t & 2048) {
                const t = function (e) {
                  var t;
                  const n = (t = e.priv.computedVariance) !== null && t !== undefined ? t : e.shared.declaredVariance;
                  if (n === 2) {
                    return 'invariant';
                  }
                  if (n === 3) {
                    return 'covariant';
                  }
                  if (n === 4) {
                    return 'contravariant';
                  }
                  return '';
                }(e);
                if (t) {
                  i = `${i} (${t})`;
                }
              }
              return i;
            }
          case 3:
            if (e.priv.isNoReturn) {
              return 'NoReturn';
            } else {
              return 'Never';
            }
          case 2:
            if (e.priv.isEllipsis) {
              return '...';
            } else {
              return 'Any';
            }
        }
        return '';
      } finally {
        r.pop();
      }
    }
    function T(e, t, n, a, r, s) {
      if (t & 256) {
        const i = c.FunctionType.getParamSpecFromArgsKwargs(e);
        const o = i ? c.FunctionType.cloneRemoveParamSpecArgsKwargs(e) : e;
        let l = false;
        if (o.shared.parameters.length === 0) {
          l = true;
        } else {
          if (o.shared.parameters.every(e => e.category === 0)) {
            if (!o.shared.parameters[o.shared.parameters.length - 1].name) {
              l = true;
            }
          }
        }
        const p = n(o);
        let d = 'Any';
        if (p) {
          d = f(p, t, n, a, r, s);
        }
        if (l) {
          const e = [];
          o.shared.parameters.forEach((i, l) => {
            if (i.name) {
              const i = c.FunctionType.getParamType(o, l);
              if (r.length < c.maxTypeRecursionCount) {
                e.push(f(i, t, n, a, r, s));
              } else {
                e.push('Any');
              }
            }
          });
          if (i) {
            if (e.length > 0) {
              return `Callable[Concatenate[${e.join(', ')}, ${i.shared.name}], ${d}]`;
            } else {
              return `Callable[${i.shared.name}, ${d}]`;
            }
          } else {
            return `Callable[[${e.join(', ')}], ${d}]`;
          }
        }
        return `Callable[..., ${d}]`;
      }
      {
        const i = b(e, t, n, a, r, s);
        const o = `(${i[0].join(', ')})`;
        if (c.FunctionType.isParamSpecValue(e)) {
          if (i[0].length === 1 && i[0][0] === '...') {
            return i[0][0];
          } else {
            return o;
          }
        }
        const l = `${o} -> ${i[1]}`;
        if (t & 128) {
          return `(${l})`;
        } else {
          return l;
        }
      }
    }
    function v(e, t, n, a, r, s) {
      var o;
      var l;
      let p = e.priv.aliasName;
      if (!p) {
        p = t & 4096 ? e.shared.fullName : e.shared.name;
      }
      if (c.ClassType.isBuiltIn(e, 'NoneType')) {
        p = 'None';
      }
      if (!a.isUnique(p)) {
        p = e.shared.fullName;
      }
      if (!c.ClassType.isPseudoGenericClass(e)) {
        const d = c.ClassType.getTypeParams(e);
        const u = d.length > 0 ? d[d.length - 1] : undefined;
        const m = !!u && c.isTypeVarTuple(u);
        const y = (o = e.priv.tupleTypeArgs) !== null && o !== undefined ? o : (l = e.priv.typeArgs) === null || l === undefined ? undefined : l.map(e => ({
          type: e,
          isUnbounded: false
        }));
        if (y) {
          if (y.length > 0) {
            const o = [];
            let l = true;
            y.forEach((e, p) => {
              const u = p < d.length ? d[p] : undefined;
              if (u && c.isTypeVarTuple(u) && c.isClassInstance(e.type) && c.ClassType.isBuiltIn(e.type, 'tuple') && e.type.priv.tupleTypeArgs) {
                if (e.type.priv.tupleTypeArgs.length === 0) {
                  if (!c.isUnknown(e.type)) {
                    l = false;
                  }
                  if (p === 0) {
                    o.push(_('tuple[()]', t));
                  }
                } else {
                  i.appendArray(o, e.type.priv.tupleTypeArgs.map(e => {
                    if (!c.isUnknown(e.type)) {
                      l = false;
                    }
                    const i = f(e.type, t, n, a, r, s);
                    if (e.isUnbounded) {
                      return _(`tuple[${i}, ...]`, t);
                    } else {
                      return i;
                    }
                  }));
                }
              } else {
                if (!c.isUnknown(e.type)) {
                  l = false;
                }
                const i = f(e.type, t, n, a, r, s);
                if (e.isUnbounded) {
                  if (y.length === 1) {
                    o.push(i, '...');
                  } else {
                    o.push(_(`tuple[${i}, ...]`, t));
                  }
                } else {
                  o.push(i);
                }
              }
            });
            if (e.priv.isUnpacked) {
              p = _(p, t);
            }
            if (!(t & 2) || !l) {
              p += `[${o.join(', ')}]`;
            }
          } else {
            if (e.priv.isUnpacked) {
              p = _(p, t);
            }
            if (c.ClassType.isTupleClass(e) || m) {
              p += '[()]';
            }
          }
        } else {
          if (e.priv.isUnpacked) {
            p = _(p, t);
          }
          if (d.length > 0) {
            if (!(t & 2) || !!d.some(e => !c.isUnknown(e))) {
              p += `[${d.map(e => f(e, t, n, a, r, s)).join(', ')}]`;
            }
          }
        }
      }
      if (e.priv.isTypedDictPartial) {
        if (!(t & 256)) {
          p = `Partial[${p}]`;
        }
      }
      return p;
    }
    function b(e, t, n, a, r, s) {
      const i = [];
      let o = false;
      const d = c.FunctionType.getParamSpecFromArgsKwargs(e);
      if (d) {
        e = c.FunctionType.cloneRemoveParamSpecArgsKwargs(e);
      }
      e.shared.parameters.forEach((d, u) => {
        const m = c.FunctionType.getParamType(e, u);
        const y = c.FunctionType.getParamDefaultType(e, u);
        if (u === e.shared.parameters.length - 1 && d.category === 1 && c.isTypeVarTuple(m)) {
          const o = c.FunctionType.getParamType(e, u);
          if (c.isClassInstance(o) && c.ClassType.isBuiltIn(o, 'tuple') && o.priv.tupleTypeArgs) {
            o.priv.tupleTypeArgs.forEach(e => {
              const o = f(e.type, t, n, a, r, s);
              i.push(o);
            });
            return;
          }
        }
        if (l.isTypedKwargs(d, m) && t & 1024 && m.category === 6) {
          m.shared.typedDictEntries.knownItems.forEach((e, o) => {
            const l = f(e.valueType, t, n, a, r, s);
            i.push(`${o}: ${l}`);
          });
          return;
        }
        let g = '';
        if (d.category === 1) {
          if (!d.name || !c.FunctionParam.isNameSynthesized(d)) {
            g += '*';
          }
        } else {
          if (d.category === 2) {
            g += '**';
          }
        }
        let h = false;
        if (d.name && !c.FunctionParam.isNameSynthesized(d)) {
          g += d.name;
          o = true;
          h = true;
        } else {
          if (t & 256) {
            g += `__p${u}`;
            o = true;
            h = true;
          }
        }
        let T = '=';
        let v = false;
        if (d.name) {
          if (c.FunctionParam.isTypeDeclared(d) || c.FunctionParam.isTypeInferred(d)) {
            const i = c.FunctionType.getParamType(e, u);
            let o = r.length < c.maxTypeRecursionCount ? f(i, t, n, a, r, s) : '';
            if (h) {
              g += ': ';
            } else {
              if (d.category === 1 && !c.isUnpacked(i)) {
                g += '*';
              }
            }
            if (d.category === 2 && c.isUnpacked(i)) {
              o = t & 256 ? `Unpack[${o.substring(1)}]` : `*${o}`;
            }
            g += o;
            if (c.isParamSpec(i)) {
              if (d.category === 1 || d.category === 2) {
                v = true;
              }
            }
            T = ' = ';
          } else {
            if (!(t & 2)) {
              if (!c.FunctionParam.isNameSynthesized(d)) {
                g += ': ';
              }
              g += t & 257 ? 'Any' : 'Unknown';
              T = ' = ';
            }
          }
        } else {
          if (d.category === 0) {
            if (!o) {
              return;
            }
            g += '/';
          }
        }
        if (y) {
          if (d.defaultExpr) {
            g += T + p.printExpression(d.defaultExpr);
          } else {
            g += T + '...';
          }
        }
        if (c.FunctionType.isGradualCallableForm(e) && !v) {
          if (d.category === 1) {
            g = '...';
          } else {
            if (d.category === 2) {
              return;
            }
          }
        }
        i.push(g);
      });
      if (d) {
        if (t & 256) {
          i.push(`*args: ${d}.args`);
          i.push(`**kwargs: ${d}.kwargs`);
        } else {
          i.push(`**${f(d, t, n, a, r, s)}`);
        }
      }
      const u = n(e);
      const m = r.length < c.maxTypeRecursionCount ? f(u, t | 144, n, a, r, s) : '';
      return [i, m];
    }
    function _(e, t) {
      if (t & 512) {
        return `Unpack[${e}]`;
      } else {
        return `*${e}`;
      }
    }
    function C(e, t) {
      var n;
      var a;
      const r = ((a = (n = e.props) === null || n === undefined ? undefined : n.instantiableDepth) !== null && a !== undefined ? a : 0) + 1;
      for (let e = 0; e < r; e++) {
        t = `type[${t}]`;
      }
      return t;
    }
    function I(e, t) {
      return c.TypeVarType.getReadableName(e, t);
    }
    class k {
      constructor(e, t) {
        this._printTypeFlags = e;
        this._returnTypeCallback = t;
        this._map = new Map();
      }
      build(e, t = [], n = 0) {
        var a;
        var r;
        if (n > c.maxTypeRecursionCount) {
          return;
        }
        n++;
        const s = (a = e.props) === null || a === undefined ? undefined : a.typeAliasInfo;
        if (s) {
          let a = true;
          if (this._printTypeFlags & 32) {
            if (t.find(t => t === e)) {
              a = false;
            }
          } else {
            a = false;
          }
          if (!a) {
            const a = this._printTypeFlags & 4096 ? s.shared.fullName : s.shared.name;
            this._addIfUnique(a, e, true);
            if (s.typeArgs) {
              t.push(e);
              try {
                s.typeArgs.forEach(e => {
                  this.build(e, t, n);
                });
              } finally {
                t.pop();
              }
            }
            return;
          }
        }
        try {
          t.push(e);
          switch (e.category) {
            case 4:
              {
                e.shared.parameters.forEach((a, r) => {
                  const s = c.FunctionType.getParamType(e, r);
                  this.build(s, t, n);
                });
                const a = this._returnTypeCallback(e);
                this.build(a, t, n);
                break;
              }
            case 5:
              c.OverloadedType.getOverloads(e).forEach(e => {
                this.build(e, t, n);
              });
              break;
            case 6:
              {
                if (e.priv.literalValue !== undefined) {
                  break;
                }
                let a = e.priv.aliasName;
                if (!a) {
                  a = this._printTypeFlags & 4096 ? e.shared.fullName : e.shared.name;
                }
                this._addIfUnique(a, e);
                if (!c.ClassType.isPseudoGenericClass(e)) {
                  if (e.priv.tupleTypeArgs) {
                    e.priv.tupleTypeArgs.forEach(e => {
                      this.build(e.type, t, n);
                    });
                  } else {
                    if (e.priv.typeArgs) {
                      e.priv.typeArgs.forEach(e => {
                        this.build(e, t, n);
                      });
                    }
                  }
                }
                break;
              }
            case 8:
              u.doForEachSubtype(e, e => {
                this.build(e, t, n);
              });
              if ((r = e.priv.typeAliasSources) !== null && r !== undefined) {
                r.forEach(e => {
                  this.build(e, t, n);
                });
              }
          }
        } finally {
          t.pop();
        }
      }
      isUnique(e) {
        const t = this._map.get(e);
        return !t || t.length === 1;
      }
      _addIfUnique(e, t, n = false) {
        const a = this._map.get(e);
        if (a) {
          if (!a.some(e => this._isSameTypeName(e, t, n))) {
            a.push(t);
          }
        } else {
          this._map.set(e, [t]);
        }
      }
      _isSameTypeName(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        if (n) {
          return ((r = (a = e.props) === null || a === undefined ? undefined : a.typeAliasInfo) === null || r === undefined ? undefined : r.shared.fullName) === ((i = (s = t.props) === null || s === undefined ? undefined : s.typeAliasInfo) === null || i === undefined ? undefined : i.shared.fullName);
        }
        if (c.isClass(e) && c.isClass(t)) {
          while (c.TypeBase.isInstantiable(e)) {
            e = c.ClassType.cloneAsInstance(e);
          }
          while (c.TypeBase.isInstantiable(t)) {
            t = c.ClassType.cloneAsInstance(t);
          }
          return c.ClassType.isSameGenericClass(e, t);
        }
        return false;
      }
    }
  },
  14400: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.printStringLiteral = function (e, t = '"') {
      const n = /'/g;
      const a = /\\"/g;
      let r = JSON.stringify(e).toString();
      if (t !== '"') {
        r = `'${r.substring(1, r.length - 1).replace(a, '"').replace(n, '\\\'')}'`;
      }
      return r;
    };
    exports.printBytesLiteral = function (e) {
      let t = '';
      for (let n = 0; n < e.length; n++) {
        const a = e.substring(n, n + 1);
        const r = a.charCodeAt(0);
        t += r >= 20 && r <= 126 ? r === 34 ? `\\${a}` : a : `\\x${(r >> 4 & 15).toString(16)}${(r & 15).toString(16)}`;
      }
      return `b"${t}"`;
    };
  },
  70930: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeStubWriter = undefined;
    const i = require(85114);
    const o = __importStar(require(26687));
    const l = __importStar(require(41557));
    const p = require(88744);
    const d = require(95952);
    const c = __importStar(require(12097));
    const u = require(21024);
    class m {
      constructor(e) {
        this.importName = e;
        this.isAccessed = false;
      }
    }
    class y extends m {
      constructor(e, t, n) {
        super(e);
        this.alias = t;
        this.symbol = n;
      }
    }
    class g extends m {
      constructor(e, t, n) {
        super(e);
        this.isWildcardImport = t;
        this.node = n;
        this.symbols = [];
      }
      addSymbol(e, t, n, a = false) {
        if (!this.symbols.find(e => e.name === t)) {
          this.symbols.push({
            symbol: e,
            name: t,
            alias: n,
            isAccessed: a
          });
        }
      }
    }
    class h extends p.ParseTreeWalker {
      constructor(e, t) {
        super();
        this._accessedImportedSymbols = e;
        this._treatStringsAsSymbols = t;
      }
      analyze(e) {
        this.walk(e);
      }
      walk(e) {
        if (!o.isCodeUnreachable(e)) {
          super.walk(e);
        }
      }
      visitName(e) {
        this._accessedImportedSymbols.add(e.d.value);
        return true;
      }
      visitMemberAccess(e) {
        const t = this._getRecursiveModuleAccessExpression(e.d.leftExpr);
        if (t) {
          this._accessedImportedSymbols.add(`${t}.${e.d.member.d.value}`);
        }
        return true;
      }
      visitString(e) {
        if (this._treatStringsAsSymbols) {
          this._accessedImportedSymbols.add(e.d.value);
        }
        return true;
      }
      _getRecursiveModuleAccessExpression(e) {
        if (e.nodeType === 38) {
          return e.d.value;
        }
        if (e.nodeType === 35) {
          const t = this._getRecursiveModuleAccessExpression(e.d.leftExpr);
          if (!t) {
            return;
          }
          return `${t}.${e.d.member.d.value}`;
        }
      }
    }
    class f extends p.ParseTreeWalker {
      constructor(e, t, n) {
        super();
        this._stubPath = e;
        this._sourceFile = t;
        this._evaluator = n;
        this._indentAmount = 0;
        this._includeAllImports = false;
        this._typeStubText = '';
        this._lineEnd = '\n';
        this._tab = '    ';
        this._classNestCount = 0;
        this._functionNestCount = 0;
        this._ifNestCount = 0;
        this._emittedSuite = false;
        this._emitDocString = true;
        this._trackedImportAs = new Map();
        this._trackedImportFrom = new Map();
        this._accessedImportedSymbols = new Set();
        if (this._stubPath.fileName === '__init__.pyi') {
          this._includeAllImports = true;
        }
      }
      write() {
        const e = this._sourceFile.getParseResults();
        this._lineEnd = e.tokenizerOutput.predominantEndOfLineSequence;
        this._tab = e.tokenizerOutput.predominantTabSequence;
        this.walk(e.parserOutput.parseTree);
        this._writeFile();
      }
      walk(e) {
        if (!o.isCodeUnreachable(e)) {
          super.walk(e);
        }
      }
      visitClass(e) {
        const t = e.d.name.d.value;
        this._emittedSuite = true;
        this._emitDocString = true;
        this._emitDecorators(e.d.decorators);
        let n = `class ${t}`;
        if (e.d.typeParams) {
          n += this._printTypeParams(e.d.typeParams);
        }
        const a = e.d.arguments.filter(e => e.d.name !== undefined || e.d.argCategory !== 0 || e.d.valueExpr.nodeType !== 38 || e.d.valueExpr.d.value !== 'object');
        if (a.length > 0) {
          n += `(${a.map(e => {
            let t = '';
            if (e.d.name) {
              t = e.d.name.d.value + '=';
            }
            t += this._printExpression(e.d.valueExpr);
            return t;
          }).join(', ')})`;
        }
        n += ':';
        this._emitLine(n);
        this._emitSuite(() => {
          this._classNestCount++;
          this.walk(e.d.suite);
          this._classNestCount--;
        });
        this._emitLine('');
        this._emitLine('');
        return false;
      }
      visitFunction(e) {
        const t = e.d.name.d.value;
        if (this._functionNestCount === 0 && !c.isPrivateOrProtectedName(t)) {
          this._emittedSuite = true;
          this._emitDocString = true;
          this._emitDecorators(e.d.decorators);
          let n;
          let a = e.d.isAsync ? 'async ' : '';
          a += `def ${t}`;
          if (e.d.typeParams) {
            a += this._printTypeParams(e.d.typeParams);
          }
          a += `(${e.d.params.map((t, n) => this._printParam(t, e, n)).join(', ')})`;
          if (e.d.returnAnnotation) {
            n = this._printExpression(e.d.returnAnnotation, true);
          } else {
            if (e.d.funcAnnotationComment) {
              n = this._printExpression(e.d.funcAnnotationComment.d.returnAnnotation, true);
            } else {
              if (e.d.name.d.value === '__init__') {
                n = 'None';
              } else {
                if (e.d.name.d.value === '__str__') {
                  n = 'str';
                } else {
                  if (['__int__', '__hash__'].some(t => t === e.d.name.d.value)) {
                    n = 'int';
                  } else {
                    if (['__eq__', '__ne__', '__gt__', '__lt__', '__ge__', '__le__'].some(t => t === e.d.name.d.value)) {
                      n = 'bool';
                    }
                  }
                }
              }
            }
          }
          if (n) {
            a += ` -> ${n}`;
          }
          a += ':';
          if (!n) {
            const t = this._evaluator.getTypeOfFunction(e);
            if (t && u.isFunction(t.functionType)) {
              let e = this._evaluator.getInferredReturnType(t.functionType);
              e = u.removeUnknownFromUnion(e);
              if (!u.isNever(e) && !u.isUnknown(e)) {
                a += ` # -> ${this._evaluator.printType(e, {
                  enforcePythonSyntax: true
                })}:`;
              }
            }
          }
          this._emitLine(a);
          this._emitSuite(() => {
            this._functionNestCount++;
            this.walk(e.d.suite);
            this._functionNestCount--;
          });
          this._emitLine('');
        }
        return false;
      }
      visitWhile(e) {
        this._emitDocString = false;
        return false;
      }
      visitFor(e) {
        this._emitDocString = false;
        return false;
      }
      visitTry(e) {
        this._emitDocString = false;
        this.walk(e.d.trySuite);
        return false;
      }
      visitWith(e) {
        this._emitDocString = false;
        return false;
      }
      visitIf(e) {
        this._emitDocString = false;
        if (this._functionNestCount === 0 && this._ifNestCount === 0) {
          this._ifNestCount++;
          this._emittedSuite = true;
          this._emitLine(`if ${this._printExpression(e.d.testExpr)}:`);
          this._emitSuite(() => {
            this.walkMultiple(e.d.ifSuite.d.statements);
          });
          const t = e.d.elseSuite;
          if (t) {
            this._emitLine('else:');
            this._emitSuite(() => {
              if (t.nodeType === 22) {
                this.walkMultiple([t.d.testExpr, t.d.ifSuite, t.d.elseSuite]);
              } else {
                this.walkMultiple(t.d.statements);
              }
            });
          }
          this._ifNestCount--;
        }
        return false;
      }
      visitTypeAlias(e) {
        let t = '';
        t = this._printExpression(e.d.name);
        if (e.d.typeParams) {
          t += this._printTypeParams(e.d.typeParams);
        }
        t += ' = ';
        t += this._printExpression(e.d.expr);
        this._emitLine(t);
        return false;
      }
      visitAssignment(e) {
        var t;
        let n = false;
        let a = '';
        if (e.d.leftExpr.nodeType === 38) {
          if (e.d.leftExpr.d.value === '__all__') {
            if (this._functionNestCount === 0 && this._ifNestCount === 0) {
              this._emittedSuite = true;
              a = this._printExpression(e.d.leftExpr);
              a += ' = ';
              a += this._printExpression(e.d.rightExpr);
              this._emitLine(a);
            }
            return false;
          }
          if (this._functionNestCount === 0) {
            a = this._printExpression(e.d.leftExpr);
            if (e.d.annotationComment) {
              a += `: ${this._printExpression(e.d.annotationComment, true)}`;
            }
            const r = this._evaluator.getType(e.d.leftExpr);
            if ((t = r == null ? undefined : r.props) === null || t === undefined ? undefined : t.typeAliasInfo) {
              n = true;
            } else {
              if (e.d.rightExpr.nodeType === 9) {
                const t = this._evaluator.getType(e.d.rightExpr.d.leftExpr);
                if (t && u.isInstantiableClass(t) && u.ClassType.isBuiltIn(t, ['TypeVar', 'TypeVarTuple', 'ParamSpec', 'NewType'])) {
                  n = true;
                }
              }
            }
          }
        } else {
          if (e.d.leftExpr.nodeType === 54) {
            const t = e.d.leftExpr.d.valueExpr;
            const r = this._evaluator.getTypeOfAnnotation(e.d.leftExpr.d.annotation, {
              varTypeAnnotation: true,
              allowClassVar: true
            });
            if (u.isClassInstance(r) && u.ClassType.isBuiltIn(r, 'TypeAlias')) {
              n = true;
            }
            if (t.nodeType === 38 && this._functionNestCount === 0) {
              a = `${this._printExpression(t)}: ${this._printExpression(e.d.leftExpr.d.annotation, true)}`;
            }
          }
        }
        if (a) {
          this._emittedSuite = true;
          a += ' = ';
          a += n ? this._printExpression(e.d.rightExpr) : '...';
          this._emitLine(a);
        }
        return false;
      }
      visitAugmentedAssignment(e) {
        if (e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === '__all__' && e.d.operator === 1 && this._functionNestCount === 0 && this._ifNestCount === 0) {
          let t = this._printExpression(e.d.leftExpr);
          t += ' += ';
          t += this._printExpression(e.d.rightExpr);
          this._emitLine(t);
        }
        return false;
      }
      visitTypeAnnotation(e) {
        if (this._functionNestCount === 0) {
          let t = '';
          if (e.d.valueExpr.nodeType === 38) {
            t = this._printExpression(e.d.valueExpr);
          } else {
            if (e.d.valueExpr.nodeType === 35) {
              const n = e.d.valueExpr.d.leftExpr;
              if (n.nodeType === 38 && n.d.value === 'self') {
                const n = e.d.valueExpr.d.member.d.value;
                if (!c.isPrivateOrProtectedName(n)) {
                  t = this._printExpression(e.d.valueExpr);
                }
              }
            }
          }
          if (t) {
            t += `: ${this._printExpression(e.d.annotation, true)}`;
            this._emitLine(t);
          }
        }
        return false;
      }
      visitImport(e) {
        if (this._functionNestCount > 0 || this._classNestCount > 0) {
          return false;
        }
        const t = d.getScopeForNode(e);
        if (t) {
          e.d.list.forEach(e => {
            const n = this._printModuleName(e.d.module);
            if (!this._trackedImportAs.has(n)) {
              const a = e.d.alias ? e.d.alias.d.value : e.d.module.d.nameParts.length > 0 ? e.d.module.d.nameParts[0].d.value : '';
              const r = t.lookUpSymbolRecursive(a);
              if (r) {
                const t = new y(n, e.d.alias ? e.d.alias.d.value : undefined, r.symbol);
                this._trackedImportAs.set(n, t);
              }
            }
          });
        }
        return false;
      }
      visitImportFrom(e) {
        if (this._functionNestCount > 0 || this._classNestCount > 0) {
          return false;
        }
        const t = d.getScopeForNode(e);
        if (t) {
          const n = this._printModuleName(e.d.module);
          let a = this._trackedImportFrom.get(n);
          if (!a) {
            a = new g(n, e.d.isWildcardImport, e);
            this._trackedImportFrom.set(n, a);
          }
          e.d.imports.forEach(e => {
            const n = e.d.alias ? e.d.alias.d.value : e.d.name.d.value;
            const r = t.lookUpSymbolRecursive(n);
            if (r) {
              a.addSymbol(r.symbol, e.d.name.d.value, e.d.alias ? e.d.alias.d.value : undefined, false);
            }
          });
        }
        return false;
      }
      visitStatementList(e) {
        if (e.d.statements.length > 0 && e.d.statements[0].nodeType === 48 && !this._emittedSuite && this._emitDocString) {
          this._emitLine(this._printExpression(e.d.statements[0]));
        }
        this._emitDocString = false;
        this.walkMultiple(e.d.statements);
        return false;
      }
      _emitSuite(e) {
        this._increaseIndent(() => {
          const t = this._emittedSuite;
          this._emittedSuite = false;
          e();
          if (!this._emittedSuite) {
            this._emitLine('...');
          }
          this._emittedSuite = t;
        });
      }
      _increaseIndent(e) {
        this._indentAmount++;
        e();
        this._indentAmount--;
      }
      _emitDecorators(e) {
        e.forEach(e => {
          this._emitLine(`@${this._printExpression(e.d.expr)}`);
        });
      }
      _printHeaderDocString() {
        return `"""${this._lineEnd}This type stub file was generated by pyright.${this._lineEnd}"""${this._lineEnd}${this._lineEnd}`;
      }
      _emitLine(e) {
        for (let e = 0; e < this._indentAmount; e++) {
          this._typeStubText += this._tab;
        }
        this._typeStubText += e + this._lineEnd;
      }
      _printTypeParams(e) {
        return `[${e.d.params.map(e => this._printTypeParam(e)).join(',')}]`;
      }
      _printTypeParam(e) {
        let t = '';
        if (e.d.typeParamKind === i.TypeParamKind.TypeVarTuple) {
          t += '*';
        } else {
          if (e.d.typeParamKind === i.TypeParamKind.ParamSpec) {
            t += '**';
          }
        }
        t += e.d.name.d.value;
        if (e.d.boundExpr) {
          t += ': ';
          t += this._printExpression(e.d.boundExpr);
        }
        if (e.d.defaultExpr) {
          t += ' = ';
          t += this._printExpression(e.d.defaultExpr);
        }
        return t;
      }
      _printModuleName(e) {
        let t = '';
        for (let n = 0; n < e.d.leadingDots; n++) {
          t += '.';
        }
        t += e.d.nameParts.map(e => e.d.value).join('.');
        return t;
      }
      _printParam(e, t, n) {
        let a = '';
        if (e.d.category === 1) {
          a += '*';
        } else {
          if (e.d.category === 2) {
            a += '**';
          }
        }
        if (e.d.name) {
          a += e.d.name.d.value;
        } else {
          if (e.d.category === 0) {
            a += '/';
          }
        }
        const r = l.getTypeAnnotationForParam(t, n);
        let s = '';
        if (r) {
          s = this._printExpression(r, true);
        }
        if (s) {
          a += `: ${s}`;
        }
        if (e.d.defaultValue) {
          a += s ? ' = ...' : '=...';
        }
        return a;
      }
      _printExpression(e, t = false, n = false) {
        new h(this._accessedImportedSymbols, n).analyze(e);
        let a = t ? 1 : 0;
        a |= 2;
        return l.printExpression(e, a);
      }
      _printTrackedImports() {
        let e = '';
        let t = false;
        this._trackedImportAs.forEach(n => {
          if (this._accessedImportedSymbols.has(n.alias || n.importName)) {
            n.isAccessed = true;
          }
          if (n.isAccessed || this._includeAllImports) {
            e += `import ${n.importName}`;
            if (n.alias) {
              e += ` as ${n.alias}`;
            }
            e += this._lineEnd;
            t = true;
          }
        });
        this._trackedImportFrom.forEach(n => {
          n.symbols.forEach(e => {
            if (this._accessedImportedSymbols.has(e.alias || e.name)) {
              e.isAccessed = true;
            }
          });
          if (n.isWildcardImport) {
            e += `from ${n.importName} import *${this._lineEnd}`;
            t = true;
          }
          const a = n.symbols.filter(e => e.isAccessed || this._includeAllImports).sort((e, t) => e.name < t.name ? -1 : e.name > t.name ? 1 : 0);
          if (a.length > 0 && n.importName !== '__future__') {
            e += `from ${n.importName} import `;
            e += a.map(e => {
              let t = e.name;
              if (e.alias) {
                t += ` as ${e.alias}`;
              }
              return t;
            }).join(', ');
            e += this._lineEnd;
            t = true;
          }
        });
        if (t) {
          e += this._lineEnd;
        }
        return e;
      }
      _writeFile() {
        let e = this._printHeaderDocString();
        e += this._printTrackedImports();
        e += this._typeStubText;
        this._sourceFile.fileSystem.writeFileSync(this._stubPath, e, 'utf8');
      }
    }
    exports.TypeStubWriter = f;
  },
  92324: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeVarTransformer = exports.UniqueSignatureTracker = undefined;
    exports.isOptionalType = function (e) {
      if (l.isUnion(e)) {
        return l.findSubtype(e, e => d(e)) !== undefined;
      }
      return false;
    };
    exports.isNoneInstance = d;
    exports.isNoneTypeClass = function (e) {
      return l.isInstantiableClass(e) && l.ClassType.isBuiltIn(e, 'NoneType');
    };
    exports.removeNoneFromUnion = function (e) {
      return l.removeFromUnion(e, e => d(e));
    };
    exports.isIncompleteUnknown = function (e) {
      return l.isUnknown(e) && e.priv.isIncomplete;
    };
    exports.isTypeVarSame = function (e, t) {
      if (l.isTypeSame(e, t)) {
        return true;
      }
      if (l.isParamSpec(e) || l.isTypeVarTuple(e) || !l.TypeVarType.hasBound(e)) {
        return false;
      }
      if (!l.isUnion(t)) {
        return false;
      }
      let n = true;
      y(t, t => {
        if (n && !l.isTypeSame(e, t)) {
          const a = T(t);
          if (!a || !a.some(t => t.typeVar.priv.nameWithScope === e.priv.nameWithScope)) {
            n = false;
          }
        }
      });
      return n;
    };
    exports.makeInferenceContext = function (e, t, n) {
      if (!e) {
        return;
      }
      return {
        expectedType: e,
        isTypeIncomplete: t,
        returnTypeOverride: n
      };
    };
    exports.mapSubtypes = c;
    exports.mapSignatures = function (e, t) {
      if (l.isFunction(e)) {
        return t(e);
      }
      const n = [];
      let a = false;
      l.OverloadedType.getOverloads(e).forEach((e, r) => {
        const s = t(e);
        if (s !== e) {
          a = true;
        }
        if (s) {
          n.push(s);
        }
      });
      if (n.length === 0) {
        return;
      }
      const r = l.OverloadedType.getImplementation(e);
      let s = r;
      if (r && l.isFunction(r)) {
        s = t(r);
        if (s) {
          a = true;
        }
      }
      if (!a) {
        return e;
      }
      if (n.length === 1) {
        return n[0];
      }
      return l.OverloadedType.create(n, s);
    };
    exports.cleanIncompleteUnknown = function e(t, n = 0) {
      if (n >= l.maxTypeRecursionCount) {
        return t;
      }
      n++;
      const a = c(t, t => {
        if (!l.isUnknown(t) || !t.priv.isIncomplete) {
          if (l.isClass(t) && t.priv.typeArgs) {
            let a = false;
            if (t.priv.tupleTypeArgs) {
              const r = t.priv.tupleTypeArgs.map(t => {
                const r = e(t.type, n);
                if (r !== t.type) {
                  a = true;
                }
                return {
                  type: r,
                  isUnbounded: t.isUnbounded,
                  isOptional: t.isOptional
                };
              });
              if (a) {
                return H(t, r, !!t.priv.isTypeArgExplicit, !!t.priv.isUnpacked);
              }
            } else {
              const r = t.priv.typeArgs.map(t => {
                const r = e(t, n);
                if (r !== t) {
                  a = true;
                }
                return r;
              });
              if (a) {
                return l.ClassType.specialize(t, r, !!t.priv.isTypeArgExplicit);
              }
            }
          }
          return t;
        }
      });
      if (l.isNever(a)) {
        return t;
      } else {
        return a;
      }
    };
    exports.sortTypes = u;
    exports.doForEachSubtype = y;
    exports.someSubtypes = function (e, t) {
      if (l.isUnion(e)) {
        return e.priv.subtypes.some(e => t(e));
      } else {
        return t(e);
      }
    };
    exports.allSubtypes = function (e, t) {
      if (l.isUnion(e)) {
        return e.priv.subtypes.every(e => {
          t(e);
        });
      } else {
        return t(e);
      }
    };
    exports.doForEachSignature = g;
    exports.areTypesSame = function (e, t) {
      if (e.length < 2) {
        return true;
      }
      for (let n = 1; n < e.length; n++) {
        if (!l.isTypeSame(e[0], e[n], t)) {
          return false;
        }
      }
      return true;
    };
    exports.preserveUnknown = h;
    exports.isUnionableType = function (e) {
      if (e.every(e => {
        var t;
        return ((t = e.props) === null || t === undefined ? undefined : t.typeForm) !== undefined;
      })) {
        return true;
      }
      let t = 3;
      for (const n of e) {
        t &= n.flags;
      }
      return !!(t & 1) && !(t & 2);
    };
    exports.derivesFromAnyOrUnknown = function (e) {
      let t = false;
      y(e, n => {
        if (l.isAnyOrUnknown(e)) {
          t = true;
        } else {
          if (l.isInstantiableClass(n)) {
            if (l.ClassType.derivesFromAnyOrUnknown(n)) {
              t = true;
            }
          } else {
            if (l.isClassInstance(n) && l.ClassType.derivesFromAnyOrUnknown(n)) {
              t = true;
            }
          }
        }
      });
      return t;
    };
    exports.getFullNameOfType = function (e) {
      var t;
      var n;
      if ((n = (t = e.props) === null || t === undefined ? undefined : t.typeAliasInfo) === null || n === undefined ? undefined : n.shared.fullName) {
        return e.props.typeAliasInfo.shared.fullName;
      }
      switch (e.category) {
        case 2:
        case 1:
          return 'typing.Any';
        case 6:
        case 4:
          return e.shared.fullName;
        case 7:
          return e.priv.moduleName;
        case 5:
          {
            const t = l.OverloadedType.getOverloads(e);
            if (t.length > 0) {
              return t[0].shared.fullName;
            }
            const n = l.OverloadedType.getImplementation(e);
            if (n && l.isFunction(n)) {
              return n.shared.fullName;
            }
          }
      }
      return;
    };
    exports.addConditionToType = f;
    exports.getTypeCondition = T;
    exports.isTypeAliasPlaceholder = function (e) {
      return l.isTypeVar(e) && l.TypeVarType.isTypeAliasPlaceholder(e);
    };
    exports.isTypeAliasRecursive = function (e, t) {
      var n;
      var a;
      if (t.category !== 8) {
        return t === e || l.isUnbound(t) && ((n = t.props) === null || n === undefined ? undefined : n.typeAliasInfo) && t.props.typeAliasInfo.shared.name === ((a = e.shared.recursiveAlias) === null || a === undefined ? undefined : a.name);
      }
      return l.findSubtype(t, t => l.isTypeVar(t) && t.shared === e.shared) !== undefined;
    };
    exports.transformPossibleRecursiveTypeAlias = function e(t, n = 0) {
      var a;
      var r;
      if (n >= l.maxTypeRecursionCount) {
        return t;
      }
      n++;
      if (t) {
        const s = (a = t.props) === null || a === undefined ? undefined : a.typeAliasInfo;
        if (l.isTypeVar(t) && ((r = t.shared.recursiveAlias) === null || r === undefined ? undefined : r.name) && t.shared.boundType) {
          const a = l.TypeBase.isInstance(t) ? W(t.shared.boundType) : t.shared.boundType;
          if (!(s == null ? undefined : s.typeArgs) || !t.shared.recursiveAlias.typeParams) {
            return e(a, n);
          }
          const r = B(t.shared.recursiveAlias.typeParams, s.typeArgs);
          return e(N(a, r), n);
        }
        if (l.isUnion(t) && t.priv.includesRecursiveTypeAlias) {
          let a = c(t, t => e(t, n));
          if (a !== t && s) {
            a = l.TypeBase.cloneForTypeAlias(a, s);
          }
          return a;
        }
      }
      return t;
    };
    exports.getTypeVarScopeId = v;
    exports.getTypeVarScopeIds = function (e) {
      const t = [];
      const n = v(e);
      if (n) {
        t.push(n);
      }
      if (l.isFunction(e) && e.priv.constructorTypeVarScopeId) {
        t.push(e.priv.constructorTypeVarScopeId);
      }
      return t;
    };
    exports.specializeWithUnknownTypeArgs = b;
    exports.getUnknownForTypeVar = _;
    exports.getUnknownForTypeVarTuple = C;
    exports.getUnknownTypeForCallable = function () {
      const e = l.FunctionType.createSynthesizedInstance('', 32768);
      l.FunctionType.addDefaultParams(e);
      e.shared.declaredReturnType = l.UnknownType.create();
      return e;
    };
    exports.selfSpecializeClass = function (e, t) {
      if (e.shared.typeParams.length === 0) {
        return e;
      }
      if (e.priv.typeArgs && !(t == null ? undefined : t.overrideTypeArgs)) {
        return e;
      }
      const n = e.shared.typeParams.map(e => {
        if (l.isTypeVarTuple(e)) {
          e = l.TypeVarType.cloneForUnpacked(e);
        }
        if (t == null ? undefined : t.useBoundTypeVars) {
          return l.TypeVarType.cloneAsBound(e);
        } else {
          return e;
        }
      });
      return l.ClassType.specialize(e, n);
    };
    exports.getSpecializedTupleType = function (e) {
      let t;
      if (l.isInstantiableClass(e)) {
        t = e;
      } else {
        if (l.isClassInstance(e)) {
          t = l.ClassType.cloneAsInstantiable(e);
        }
      }
      if (!t) {
        return;
      }
      const n = t.shared.mro.find(e => l.isInstantiableClass(e) && S(e));
      if (!n || !l.isInstantiableClass(n)) {
        return;
      }
      if (l.ClassType.isSameGenericClass(t, n)) {
        return t;
      }
      const a = L(t);
      return N(n, a);
    };
    exports.isLiteralType = I;
    exports.isLiteralTypeOrUnion = function (e, t = false) {
      if (l.isClassInstance(e)) {
        return !!t && !!d(e) || e.priv.literalValue !== undefined;
      }
      if (l.isUnion(e)) {
        return !l.findSubtype(e, e => !l.isClassInstance(e) || (d(e) ? !t : e.priv.literalValue === undefined));
      }
      return false;
    };
    exports.isLiteralLikeType = k;
    exports.containsLiteralType = function (e, t = false) {
      class n extends p.TypeWalker {
        constructor(e) {
          super();
          this._includeTypeArgs = e;
          this.foundLiteral = false;
        }
        visitClass(e) {
          if (l.isClassInstance(e) && k(e)) {
            this.foundLiteral = true;
            this.cancelWalk();
          }
          if (this._includeTypeArgs) {
            super.visitClass(e);
          }
        }
      }
      const a = new n(t);
      a.walk(e);
      return a.foundLiteral;
    };
    exports.getLiteralTypeClassName = function e(t) {
      if (l.isClassInstance(t)) {
        if (t.priv.literalValue !== undefined && l.ClassType.isBuiltIn(t)) {
          return t.shared.name;
        } else {
          return undefined;
        }
      }
      if (l.isUnion(t)) {
        let n;
        let a = false;
        y(t, t => {
          const r = e(t);
          if (r) {
            if (!n) {
              n = r;
            }
          } else {
            a = true;
          }
        });
        if (a) {
          return undefined;
        } else {
          return n;
        }
      }
      return;
    };
    exports.stripTypeForm = function (e) {
      var t;
      if ((t = e.props) === null || t === undefined ? undefined : t.typeForm) {
        return l.TypeBase.cloneWithTypeForm(e, undefined);
      }
      return e;
    };
    exports.stripTypeFormRecursive = function e(t, n = 0) {
      var a;
      if (n > l.maxTypeRecursionCount) {
        return t;
      }
      n++;
      if ((a = t.props) === null || a === undefined ? undefined : a.typeForm) {
        t = l.TypeBase.cloneWithTypeForm(t, undefined);
      }
      return c(t, t => e(t, n));
    };
    exports.getUnionSubtypeCount = function (e) {
      if (l.isUnion(e)) {
        return e.priv.subtypes.length;
      }
      return 1;
    };
    exports.isEllipsisType = function (e) {
      return l.isAny(e) && e.priv.isEllipsis;
    };
    exports.isProperty = function (e) {
      return l.isClassInstance(e) && l.ClassType.isPropertyClass(e);
    };
    exports.isCallableType = function e(t) {
      if (l.isFunction(t) || l.isOverloaded(t) || l.isAnyOrUnknown(t)) {
        return true;
      }
      if (G(t)) {
        return true;
      }
      if (l.isClass(t)) {
        if (l.TypeBase.isInstantiable(t)) {
          return true;
        }
        return !!E(t, '__call__', 16);
      }
      if (l.isUnion(t)) {
        return t.priv.subtypes.every(t => e(t));
      }
      return false;
    };
    exports.isDescriptorInstance = function (e, t = false) {
      if (l.isUnion(e)) {
        return e.priv.subtypes.every(e => w(e, t));
      }
      return w(e, t);
    };
    exports.isMaybeDescriptorInstance = w;
    exports.isTupleGradualForm = function (e) {
      return l.isClassInstance(e) && S(e) && e.priv.tupleTypeArgs && e.priv.tupleTypeArgs.length === 1 && l.isAnyOrUnknown(e.priv.tupleTypeArgs[0].type) && e.priv.tupleTypeArgs[0].isUnbounded;
    };
    exports.isTupleClass = S;
    exports.isUnboundedTupleClass = A;
    exports.isTupleIndexUnambiguous = function (e, t) {
      if (!e.priv.tupleTypeArgs) {
        return false;
      }
      const n = e.priv.tupleTypeArgs.findIndex(e => e.isUnbounded || l.isUnpackedTypeVarTuple(e.type) || l.isUnpackedTypeVar(e.type));
      if (t < 0) {
        const a = n < 0 ? 0 : n;
        return (t += e.priv.tupleTypeArgs.length) >= a;
      }
      const a = n < 0 ? e.priv.tupleTypeArgs.length : n;
      return t < a;
    };
    exports.partiallySpecializeType = x;
    exports.addSolutionForSelfType = P;
    exports.ensureSignaturesAreUnique = function (e, t, n) {
      return new ae(t, n).apply(e, 0);
    };
    exports.makeFunctionTypeVarsBound = function (e) {
      const t = [];
      g(e, e => {
        const n = v(e);
        if (n) {
          t.push(n);
        }
      });
      return D(e, t);
    };
    exports.makeTypeVarsBound = D;
    exports.makeTypeVarsFree = function (e, t) {
      if (t.length === 0) {
        return e;
      }
      return new se(t).apply(e, 0);
    };
    exports.applySolvedTypeVars = N;
    exports.validateTypeVarDefault = function (e, t, n) {
      if (e.shared.isDefaultExplicit && J(e.shared.defaultType)) {
        new ne(t, n).apply(e.shared.defaultType, 0);
      }
    };
    exports.transformExpectedType = function (e, t, n) {
      return new oe(t, n).apply(e, 0);
    };
    exports.getProtocolSymbols = function (e) {
      const t = new Map();
      if (e.shared.flags & 512) {
        F(e, t, 512);
      }
      return t;
    };
    exports.getProtocolSymbolsRecursive = F;
    exports.getContainerDepth = function e(t, n = 0) {
      if (n > l.maxTypeRecursionCount) {
        return 1;
      }
      n++;
      if (!l.isClassInstance(t)) {
        return 0;
      }
      let a = 0;
      if (t.priv.tupleTypeArgs) {
        t.priv.tupleTypeArgs.forEach(t => {
          y(t.type, t => {
            const r = e(t, n);
            a = Math.max(r, a);
          });
        });
      } else {
        if (!t.priv.typeArgs) {
          return 0;
        }
        t.priv.typeArgs.forEach(t => {
          y(t, t => {
            const r = e(t, n);
            a = Math.max(r, a);
          });
        });
      }
      return 1 + a;
    };
    exports.lookUpObjectMember = E;
    exports.lookUpClassMember = M;
    exports.getClassMemberIterator = O;
    exports.isMemberReadOnly = z;
    exports.getClassIterator = U;
    exports.getClassFieldsRecursive = function (e) {
      const t = new Map();
      l.ClassType.getReverseMro(e).forEach(n => {
        const a = x(n, e, undefined);
        if (l.isClass(a)) {
          l.ClassType.getSymbolTable(a).forEach((e, r) => {
            if (!e.isIgnoredForProtocolMatch() && e.hasTypedDeclarations()) {
              t.set(r, {
                classType: a,
                unspecializedClassType: n,
                symbol: e,
                isInstanceMember: e.isInstanceMember(),
                isClassMember: e.isClassMember(),
                isClassVar: o.isEffectivelyClassVar(e, l.ClassType.isDataClass(a)),
                isReadOnly: z(a, r),
                isTypeDeclared: true,
                skippedUndeclaredType: false
              });
            }
          });
        } else {
          t.clear();
        }
      });
      return t;
    };
    exports.addTypeVarsToListIfUnique = V;
    exports.getTypeVarArgsRecursive = function e(t, n = 0) {
      var a;
      if (n > l.maxTypeRecursionCount) {
        return [];
      }
      n++;
      const r = (a = t.props) === null || a === undefined ? undefined : a.typeAliasInfo;
      if (r) {
        const t = [];
        if (r.typeArgs) {
          if (r != null) {
            r.typeArgs.forEach(a => {
              V(t, e(a, n));
            });
          }
          return t;
        }
        if (r.shared.typeParams) {
          r.shared.typeParams.forEach(e => {
            V(t, [e]);
          });
          return t;
        }
      }
      if (l.isTypeVar(t)) {
        if (t.shared.recursiveAlias || l.TypeVarType.isBound(t)) {
          return [];
        } else {
          if (l.isParamSpec(t) && t.priv.paramSpecAccess) {
            return [l.TypeVarType.cloneForParamSpecAccess(t, undefined)];
          } else {
            return [l.TypeBase.isInstantiable(t) ? l.TypeVarType.cloneAsInstance(t) : t];
          }
        }
      }
      if (l.isClass(t)) {
        const a = [];
        const r = t.priv.tupleTypeArgs ? t.priv.tupleTypeArgs.map(e => e.type) : t.priv.typeArgs;
        if (r) {
          r.forEach(t => {
            V(a, e(t, n));
          });
        }
        return a;
      }
      if (l.isUnion(t)) {
        const a = [];
        y(t, t => {
          V(a, e(t, n));
        });
        return a;
      }
      if (l.isFunction(t)) {
        const a = [];
        for (let r = 0; r < t.shared.parameters.length; r++) {
          V(a, e(l.FunctionType.getParamType(t, r), n));
        }
        const r = l.FunctionType.getEffectiveReturnType(t);
        if (r) {
          V(a, e(r, n));
        }
        return a;
      }
      return [];
    };
    exports.specializeWithDefaultTypeArgs = R;
    exports.buildSolutionFromSpecializedClass = L;
    exports.buildSolution = B;
    exports.specializeForBaseClass = function (e, t) {
      if (l.ClassType.getTypeParams(t).length === 0) {
        return t;
      }
      const n = L(e);
      const a = N(t, n);
      r.assert(l.isInstantiableClass(a));
      return a;
    };
    exports.derivesFromStdlibClass = function (e, t) {
      return e.shared.mro.some(e => l.isClass(e) && l.ClassType.isBuiltIn(e, t));
    };
    exports.derivesFromClassRecursive = function e(t, n, a) {
      if (l.ClassType.isSameGenericClass(t, n)) {
        return true;
      }
      for (const r of t.shared.baseClasses) {
        if (l.isInstantiableClass(r)) {
          if (e(r, n, a)) {
            return true;
          }
        } else {
          if (!a && l.isAnyOrUnknown(r)) {
            return true;
          }
        }
      }
      return false;
    };
    exports.synthesizeTypeVarForSelfCls = j;
    exports.getDeclaredGeneratorReturnType = function (e) {
      const t = l.FunctionType.getEffectiveReturnType(e);
      if (t) {
        const e = Y(t);
        if (e) {
          if (e.length >= 3) {
            return e[2];
          } else {
            return l.UnknownType.create();
          }
        }
      }
      return;
    };
    exports.getGeneratorYieldType = function (e, t) {
      let n = true;
      const a = c(e, e => {
        if (l.isAnyOrUnknown(e)) {
          return e;
        }
        if (l.isClassInstance(e)) {
          if ([['AsyncIterable', 'Iterable'], ['AsyncIterator', 'Iterator'], ['AsyncGenerator', 'Generator'], ['', 'AwaitableGenerator']].some(n => l.ClassType.isBuiltIn(e, t ? n[0] : n[1]))) {
            if (e.priv.typeArgs && e.priv.typeArgs.length >= 1) {
              return e.priv.typeArgs[0];
            } else {
              return l.UnknownType.create();
            }
          }
        }
        n = false;
      });
      if (n) {
        return a;
      } else {
        return undefined;
      }
    };
    exports.isInstantiableMetaclass = function (e) {
      return l.isInstantiableClass(e) && e.shared.mro.some(e => l.isClass(e) && l.ClassType.isBuiltIn(e, 'type'));
    };
    exports.isMetaclassInstance = q;
    exports.isEffectivelyInstantiable = G;
    exports.convertToInstance = W;
    exports.convertToInstantiable = K;
    exports.getMembersForClass = function (e, t, n) {
      e.shared.mro.forEach(e => {
        if (l.isInstantiableClass(e)) {
          const a = l.ClassType.isTypedDictClass(e);
          l.ClassType.getSymbolTable(e).forEach((e, r) => {
            if ((e.isClassMember() || n && e.isInstanceMember()) && (!a || !o.isTypedDictMemberAccessedThroughIndex(e)) && !e.isInitVar()) {
              const n = t.get(r);
              if (n) {
                if (!n.hasTypedDeclarations() && e.hasTypedDeclarations()) {
                  t.set(r, e);
                }
              } else {
                t.set(r, e);
              }
            }
          });
        }
      });
      if (!n) {
        const n = e.shared.effectiveMetaclass;
        if (n && l.isInstantiableClass(n)) {
          for (const e of n.shared.mro) {
            if (!l.isInstantiableClass(e)) {
              break;
            }
            l.ClassType.getSymbolTable(e).forEach((e, n) => {
              const a = t.get(n);
              if (a) {
                if (!a.hasTypedDeclarations() && e.hasTypedDeclarations()) {
                  t.set(n, e);
                }
              } else {
                t.set(n, e);
              }
            });
          }
        }
      }
    };
    exports.getMembersForModule = function (e, t) {
      if (e.priv.loaderFields) {
        e.priv.loaderFields.forEach((e, n) => {
          t.set(n, e);
        });
      }
      e.priv.fields.forEach((e, n) => {
        t.set(n, e);
      });
    };
    exports.containsAnyRecursive = function (e, t = true) {
      class n extends p.TypeWalker {
        constructor(e) {
          super();
          this._includeUnknown = e;
          this.foundAny = false;
        }
        visitAny(e) {
          this.foundAny = true;
          this.cancelWalk();
        }
        visitUnknown(e) {
          if (this._includeUnknown) {
            this.foundAny = true;
            this.cancelWalk();
          }
        }
      }
      const a = new n(t);
      a.walk(e);
      return a.foundAny;
    };
    exports.containsAnyOrUnknown = function (e, t) {
      class n extends p.TypeWalker {
        constructor(e) {
          super();
          this._recurse = e;
        }
        visitTypeAlias(e) {}
        visitUnknown(e) {
          this.anyOrUnknownType = this.anyOrUnknownType ? h(this.anyOrUnknownType, e) : e;
        }
        visitAny(e) {
          this.anyOrUnknownType = this.anyOrUnknownType ? h(this.anyOrUnknownType, e) : e;
        }
        visitClass(e) {
          if (this._recurse) {
            super.visitClass(e);
          }
        }
        visitFunction(e) {
          if (this._recurse) {
            if (l.FunctionType.isGradualCallableForm(e)) {
              this.anyOrUnknownType = this.anyOrUnknownType ? h(this.anyOrUnknownType, l.AnyType.create()) : l.AnyType.create();
            }
            super.visitFunction(e);
          }
        }
      }
      const a = new n(t);
      a.walk(e);
      return a.anyOrUnknownType;
    };
    exports.isPartlyUnknown = function e(t, n = 0) {
      var a;
      var r;
      if (n > l.maxTypeRecursionCount) {
        return false;
      }
      n++;
      if (l.isUnknown(t)) {
        return true;
      }
      const s = (a = t.props) === null || a === undefined ? undefined : a.typeAliasInfo;
      if ((s == null ? undefined : s.typeArgs) && s.typeArgs.some(t => e(t, n))) {
        return true;
      }
      if (l.isUnion(t)) {
        return l.findSubtype(t, t => e(t, n)) !== undefined;
      }
      if (l.isClass(t)) {
        if (!t.priv.includeSubclasses) {
          return false;
        }
        if (!l.ClassType.isPseudoGenericClass(t)) {
          const a = ((r = t.priv.tupleTypeArgs) === null || r === undefined ? undefined : r.map(e => e.type)) || t.priv.typeArgs;
          if (a) {
            for (const t of a) {
              if (e(t, n)) {
                return true;
              }
            }
          }
        }
        return false;
      }
      if (l.isOverloaded(t)) {
        return l.OverloadedType.getOverloads(t).some(t => e(t, n));
      }
      if (l.isFunction(t)) {
        for (let a = 0; a < t.shared.parameters.length; a++) {
          if (t.shared.parameters[a].name) {
            const r = l.FunctionType.getParamType(t, a);
            if (e(r, n)) {
              return true;
            }
          }
        }
        return !!t.shared.declaredReturnType && !l.FunctionType.isParamSpecValue(t) && !!e(t.shared.declaredReturnType, n);
      }
      return false;
    };
    exports.explodeGenericClass = function (e) {
      if (!e.priv.typeArgs || e.priv.typeArgs.length !== 1 || !l.isUnion(e.priv.typeArgs[0])) {
        return e;
      }
      return l.combineTypes(e.priv.typeArgs[0].priv.subtypes.map(t => l.ClassType.specialize(e, [t])));
    };
    exports.combineSameSizedTuples = function (e, t) {
      if (!t || !l.isInstantiableClass(t) || A(t)) {
        return e;
      }
      let n;
      let a = true;
      y(e, e => {
        if (l.isClassInstance(e)) {
          let t;
          if (l.isClass(e) && S(e) && !A(e)) {
            t = e;
          }
          if (!t) {
            t = e.shared.mro.find(e => l.isClass(e) && S(e) && !A(e));
          }
          if (t && l.isClass(t) && t.priv.tupleTypeArgs) {
            if (n) {
              if (n.length === t.priv.tupleTypeArgs.length) {
                t.priv.tupleTypeArgs.forEach((e, t) => {
                  n[t].push(e.type);
                });
              } else {
                a = false;
              }
            } else {
              n = t.priv.tupleTypeArgs.map(e => [e.type]);
            }
          } else {
            a = false;
          }
        } else {
          a = false;
        }
      });
      if (!a || !n) {
        return e;
      }
      return W(H(t, n.map(e => ({
        type: l.combineTypes(e),
        isUnbounded: false
      }))));
    };
    exports.combineTupleTypeArgs = $;
    exports.specializeTupleClass = H;
    exports.makePacked = function (e) {
      if (l.isUnpackedClass(e)) {
        return l.ClassType.cloneForPacked(e);
      }
      if (l.isUnpackedTypeVarTuple(e) && !e.priv.isInUnion) {
        return l.TypeVarType.cloneForPacked(e);
      }
      if (l.isUnpackedTypeVar(e)) {
        return l.TypeVarType.cloneForPacked(e);
      }
      return e;
    };
    exports.makeUnpacked = function (e) {
      if (l.isClass(e)) {
        return l.ClassType.cloneForUnpacked(e);
      }
      if (l.isTypeVarTuple(e) && !e.priv.isInUnion) {
        return l.TypeVarType.cloneForUnpacked(e);
      }
      if (l.isTypeVar(e)) {
        return l.TypeVarType.cloneForUnpacked(e);
      }
      return e;
    };
    exports.getGeneratorTypeArgs = Y;
    exports.requiresTypeArgs = function (e) {
      if (e.shared.typeParams.length > 0) {
        const t = e.shared.typeParams[0];
        return !t.shared.isSynthesized && !t.shared.isDefaultExplicit;
      }
      if (l.ClassType.isSpecialBuiltIn(e)) {
        if (['Tuple', 'Callable', 'Generic', 'Type', 'Optional', 'Union', 'Literal', 'Annotated', 'TypeGuard', 'TypeIs'].some(t => t === (e.priv.aliasName || e.shared.name))) {
          return true;
        }
      }
      return false;
    };
    exports.requiresSpecialization = J;
    exports.invertVariance = function (e) {
      if (e === 4) {
        return 3;
      }
      if (e === 3) {
        return 4;
      }
      return e;
    };
    exports.combineVariances = function (e, t) {
      if (e === 1) {
        return t;
      }
      if (t === 2 || t === 3 && e === 4 || t === 4 && e === 3) {
        return 2;
      }
      return e;
    };
    exports.isVarianceOfTypeArgCompatible = function e(t, n) {
      if (n === 1 || n === 0) {
        return true;
      }
      if (!l.isTypeVar(t) || l.isParamSpec(t) || l.isTypeVarTuple(t)) {
        if (l.isClassInstance(t) && t.shared.typeParams && t.shared.typeParams.length > 0) {
          return t.shared.typeParams.every((a, r) => {
            let s;
            if (l.isParamSpec(a) || l.isTypeVarTuple(a)) {
              return true;
            }
            if (t.priv.typeArgs && r < t.priv.typeArgs.length) {
              s = t.priv.typeArgs[r];
            }
            const i = a.shared.declaredVariance;
            if (i === 0) {
              return true;
            }
            let o = 2;
            if (i === 3) {
              o = n;
            } else {
              if (i === 4) {
                if (n === 3) {
                  o = 4;
                } else {
                  if (n === 4) {
                    o = 3;
                  }
                }
              }
            }
            return e(s ?? l.UnknownType.create(), o);
          });
        }
      } else {
        const e = t.shared.declaredVariance;
        if (e === 4 || e === 3) {
          return e === n;
        }
      }
      return true;
    };
    exports.computeMroLinearization = function (e) {
      let t = true;
      e.shared.mro = [];
      const n = e.shared.baseClasses.filter((t, n) => {
        if (l.isInstantiableClass(t) && l.ClassType.isBuiltIn(t, 'Generic')) {
          if (l.ClassType.isProtocolClass(e) || l.ClassType.isTypedDictClass(e)) {
            return false;
          }
          if (e.shared.baseClasses.some((e, t) => t > n && l.isInstantiableClass(e) && e.priv.typeArgs && e.priv.isTypeArgExplicit)) {
            return false;
          }
        }
        return true;
      });
      const a = [];
      n.forEach(e => {
        if (l.isInstantiableClass(e)) {
          const t = L(e);
          a.push(e.shared.mro.map(e => N(e, t)));
        } else {
          a.push([e]);
        }
      });
      a.push(n.map(t => N(t, L(e))));
      const r = L(e);
      let s = N(e, r);
      if (!l.isClass(s) && !l.isAnyOrUnknown(s)) {
        s = l.UnknownType.create();
      }
      function i(e, t) {
        return t.some(t => t.findIndex(t => l.isInstantiableClass(t) && l.ClassType.isSameGenericClass(t, e)) > 0);
      }
      function o(e, t) {
        for (let n = 0; n < t.length; n++) {
          t[n] = t[n].filter(t => !l.isInstantiableClass(t) || !l.ClassType.isSameGenericClass(t, e));
        }
      }
      e.shared.mro.push(s);
      while (true) {
        let n;
        let r = false;
        for (let t = 0; t < a.length; t++) {
          const s = a[t];
          if (s.length > 0) {
            if (n === undefined) {
              n = s;
            }
            if (!l.isInstantiableClass(s[0])) {
              r = true;
              let t = s[0];
              if (!l.isClass(t) && !l.isAnyOrUnknown(t)) {
                t = l.UnknownType.create();
              }
              e.shared.mro.push(t);
              s.shift();
              break;
            }
            if (!i(s[0], a)) {
              r = true;
              e.shared.mro.push(s[0]);
              o(s[0], a);
              break;
            }
          }
        }
        if (!n) {
          break;
        }
        if (!r) {
          t = false;
          if (l.isInstantiableClass(n[0])) {
            e.shared.mro.push(n[0]);
            o(n[0], a);
          } else {
            let t = n[0];
            if (!l.isClass(t) && !l.isAnyOrUnknown(t)) {
              t = l.UnknownType.create();
            }
            e.shared.mro.push(t);
            n.shift();
          }
        }
      }
      return t;
    };
    exports.getDeclaringModulesForType = function (e) {
      const t = [];
      Q(e, t);
      return t;
    };
    exports.convertTypeToParamSpecValue = X;
    exports.simplifyFunctionToParamSpec = ee;
    const a = require(58147);
    const r = require(48281);
    const s = require(70617);
    const i = require(58253);
    const o = require(4064);
    const l = require(21024);
    const p = require(8307);
    function d(e) {
      return l.isClassInstance(e) && l.ClassType.isBuiltIn(e, 'NoneType');
    }
    function c(e, t, n) {
      var a;
      if (l.isUnion(e)) {
        const r = (n == null ? undefined : n.sortSubtypes) ? u(e.priv.subtypes) : e.priv.subtypes;
        for (let s = 0; s < r.length; s++) {
          const i = r[s];
          const o = t(i);
          if (i !== o) {
            const i = r.slice(0, s);
            const p = t => {
              if (t) {
                i.push(f(t, T(e)));
              }
            };
            p(o);
            s++;
            for (; s < r.length; s++) {
              p(t(r[s]));
            }
            let d = l.combineTypes(i, {
              skipElideRedundantLiterals: n == null ? undefined : n.skipElideRedundantLiterals
            });
            if (n == null ? undefined : n.retainTypeAlias) {
              if ((a = e.props) === null || a === undefined ? undefined : a.typeAliasInfo) {
                d = l.TypeBase.cloneForTypeAlias(d, e.props.typeAliasInfo);
              }
            } else {
              if (l.isUnion(d)) {
                l.UnionType.addTypeAliasSource(d, e);
              }
            }
            return d;
          }
        }
        return e;
      }
      const r = t(e);
      return r || l.NeverType.createNever();
    }
    function u(e) {
      return e.slice(0).sort((e, t) => m(e, t));
    }
    function m(e, t, n = 0) {
      var a;
      var r;
      if (n > l.maxTypeRecursionCount) {
        return 0;
      }
      n++;
      if (e.category !== t.category) {
        return t.category - e.category;
      }
      switch (e.category) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 8:
          return 0;
        case 4:
          {
            const n = t;
            const s = e.shared.parameters.length;
            const i = n.shared.parameters.length;
            if (s !== i) {
              return i - s;
            }
            for (let t = 0; t < s; t++) {
              const a = e.shared.parameters[t];
              const r = n.shared.parameters[t];
              if (a.category !== r.category) {
                return r.category - a.category;
              }
              const s = m(l.FunctionType.getParamType(e, t), l.FunctionType.getParamType(n, t));
              if (s !== 0) {
                return s;
              }
            }
            const o = m((a = l.FunctionType.getEffectiveReturnType(e)) !== null && a !== undefined ? a : l.UnknownType.create(), (r = l.FunctionType.getEffectiveReturnType(n)) !== null && r !== undefined ? r : l.UnknownType.create());
            if (o !== 0) {
              return o;
            }
            const p = e.shared.name;
            const d = n.shared.name;
            if (p < d) {
              return -1;
            } else {
              if (p > d) {
                return 1;
              } else {
                return 0;
              }
            }
          }
        case 5:
          {
            const n = t;
            const a = l.OverloadedType.getOverloads(e);
            const r = l.OverloadedType.getOverloads(n);
            const s = a.length;
            const i = r.length;
            if (s !== i) {
              return i - s;
            }
            for (let e = 0; e < s; e++) {
              const t = m(a[e], r[e]);
              if (t !== 0) {
                return t;
              }
            }
            return 0;
          }
        case 6:
          {
            const a = t;
            if (l.isClassInstance(e) && l.isInstantiableClass(a)) {
              return -1;
            }
            if (l.isInstantiableClass(e) && l.isClassInstance(a)) {
              return 1;
            }
            if (I(e)) {
              if (!I(a)) {
                return -1;
              }
              if (l.ClassType.isSameGenericClass(e, a)) {
                const t = e.priv.literalValue;
                const n = a.priv.literalValue;
                if (typeof t == 'string' && typeof n == 'string' || typeof t == 'number' && typeof n == 'number') {
                  if (t < n) {
                    return -1;
                  }
                  if (t > n) {
                    return 1;
                  }
                }
              }
            } else {
              if (I(a)) {
                return 1;
              }
            }
            if (l.ClassType.isBuiltIn(e, 'NoneType')) {
              return 1;
            }
            if (l.ClassType.isBuiltIn(a, 'NoneType')) {
              return -1;
            }
            if (e.shared.typeParams.length > 0 || S(e)) {
              if (a.shared.typeParams.length === 0) {
                return 1;
              }
            } else {
              if (a.shared.typeParams.length > 0 || S(a)) {
                return -1;
              }
            }
            const r = e.shared.name;
            const s = t.shared.name;
            if (r < s) {
              return -1;
            }
            if (r > s) {
              return 1;
            }
            const i = e.priv.typeArgs ? e.priv.typeArgs.length : 0;
            const o = a.priv.typeArgs ? a.priv.typeArgs.length : 0;
            if (i < o) {
              return -1;
            }
            if (i > o) {
              return 1;
            }
            for (let t = 0; t < i; t++) {
              const r = m(e.priv.typeArgs[t], a.priv.typeArgs[t], n);
              if (r !== 0) {
                return r;
              }
            }
            return 0;
          }
        case 7:
          {
            const n = e.priv.moduleName;
            const a = t.priv.moduleName;
            if (n < a) {
              return -1;
            } else {
              if (n === a) {
                return 0;
              } else {
                return 1;
              }
            }
          }
        case 9:
          {
            const n = e.shared.name;
            const a = t.shared.name;
            if (n < a) {
              return -1;
            } else {
              if (n === a) {
                return 0;
              } else {
                return 1;
              }
            }
          }
      }
      return 1;
    }
    function y(e, t, n = false) {
      if (l.isUnion(e)) {
        const a = n ? u(e.priv.subtypes) : e.priv.subtypes;
        a.forEach((e, n) => {
          t(e, n, a);
        });
      } else {
        t(e, 0, [e]);
      }
    }
    function g(e, t) {
      if (l.isFunction(e)) {
        t(e, 0);
      } else {
        l.OverloadedType.getOverloads(e).forEach((e, n) => {
          t(e, n);
        });
      }
    }
    function h(e, t) {
      if (l.isUnknown(e) && e.priv.isIncomplete) {
        return e;
      } else {
        if (l.isUnknown(t) && t.priv.isIncomplete) {
          return t;
        } else {
          if (l.isUnknown(e) || l.isUnknown(t)) {
            return l.UnknownType.create();
          } else {
            return l.AnyType.create();
          }
        }
      }
    }
    function f(e, t, n) {
      var a;
      var r;
      if (!t) {
        return e;
      }
      if ((n == null ? undefined : n.skipSelfCondition) && (t = t.filter(e => !l.TypeVarType.isSelf(e.typeVar))).length === 0) {
        return e;
      }
      if ((n == null ? undefined : n.skipBoundTypeVars) && (t = t.filter(e => e.typeVar.shared.constraints.length > 0)).length === 0) {
        return e;
      }
      switch (e.category) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 7:
        case 9:
          return e;
        case 4:
          return l.TypeBase.cloneForCondition(e, l.TypeCondition.combine((a = e.props) === null || a === undefined ? undefined : a.condition, t));
        case 5:
          return l.OverloadedType.create(l.OverloadedType.getOverloads(e).map(e => f(e, t)));
        case 6:
          return l.TypeBase.cloneForCondition(e, l.TypeCondition.combine((r = e.props) === null || r === undefined ? undefined : r.condition, t));
        case 8:
          return l.combineTypes(e.priv.subtypes.map(e => f(e, t)));
      }
    }
    function T(e) {
      var t;
      switch (e.category) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 7:
        case 9:
        case 5:
        case 8:
          return;
        case 6:
        case 4:
          if ((t = e.props) === null || t === undefined) {
            return undefined;
          } else {
            return t.condition;
          }
      }
    }
    function v(e) {
      if (l.isClass(e) || l.isFunction(e)) {
        return e.shared.typeVarScopeId;
      } else {
        if (l.isTypeVar(e)) {
          return e.priv.scopeId;
        } else {
          return undefined;
        }
      }
    }
    function b(e, t) {
      if (e.shared.typeParams.length === 0) {
        return e;
      } else {
        if (S(e)) {
          return l.ClassType.cloneIncludeSubclasses(H(e, [{
            type: l.UnknownType.create(),
            isUnbounded: true
          }], false), !!e.priv.includeSubclasses);
        } else {
          return l.ClassType.specialize(e, e.shared.typeParams.map(e => _(e, t)), false, e.priv.includeSubclasses);
        }
      }
    }
    function _(e, t) {
      if (l.isParamSpec(e)) {
        return l.ParamSpecType.getUnknown();
      } else {
        if (l.isTypeVarTuple(e) && t) {
          return C(t);
        } else {
          return l.UnknownType.create();
        }
      }
    }
    function C(e) {
      r.assert(l.isInstantiableClass(e) && l.ClassType.isBuiltIn(e, 'tuple'));
      return l.ClassType.cloneAsInstance(H(e, [{
        type: l.UnknownType.create(),
        isUnbounded: true
      }], true, true));
    }
    function I(e) {
      return l.TypeBase.isInstance(e) && e.priv.literalValue !== undefined;
    }
    function k(e) {
      return e.priv.literalValue !== undefined || !!l.ClassType.isBuiltIn(e, 'LiteralString');
    }
    function w(e, t = false) {
      if (l.isUnion(e)) {
        return e.priv.subtypes.some(e => w(e, t));
      } else {
        return !!l.isClassInstance(e) && !!l.ClassType.getSymbolTable(e).has('__get__') && (!t || !!l.ClassType.getSymbolTable(e).has('__set__'));
      }
    }
    function S(e) {
      return l.ClassType.isBuiltIn(e, 'tuple');
    }
    function A(e) {
      var t;
      if ((t = e.priv.tupleTypeArgs) === null || t === undefined) {
        return undefined;
      } else {
        return t.some(e => e.isUnbounded || l.isUnpackedTypeVarTuple(e.type) || l.isUnpackedTypeVar(e.type));
      }
    }
    function x(e, t, n, a) {
      if (l.ClassType.isUnspecialized(t) && !a) {
        return e;
      }
      const r = L(t);
      if (a) {
        P(r, t, a);
      }
      let s = N(e, r, {
        typeClassType: n
      });
      if (l.isClass(s) && (s.priv.fgetInfo || s.priv.fsetInfo || s.priv.fdelInfo)) {
        function i(e) {
          if (e) {
            return {
              methodType: x(e.methodType, t, n, a),
              classType: e.classType
            };
          }
        }
        s = l.TypeBase.cloneType(s);
        s.priv.fgetInfo = i(s.priv.fgetInfo);
        s.priv.fsetInfo = i(s.priv.fsetInfo);
        s.priv.fdelInfo = i(s.priv.fdelInfo);
      }
      return s;
    }
    function P(e, t, n) {
      const a = j(t, false);
      const r = c(W(n), e => l.isClass(e) && e.priv.literalValue !== undefined ? l.ClassType.cloneWithLiteral(e, undefined) : e);
      e.setType(a, r);
    }
    function D(e, t) {
      if (t && t.length === 0) {
        return e;
      }
      return new re(t).apply(e, 0);
    }
    function N(e, t, n = {}) {
      if (t.isEmpty() && !n.replaceUnsolved) {
        return e;
      }
      return new ie(t, n).apply(e, 0);
    }
    function F(e, t, n = 512, a = 0) {
      if (!(a > l.maxTypeRecursionCount)) {
        e.shared.baseClasses.forEach(e => {
          if (l.isClass(e) && e.shared.flags & n) {
            F(e, t, n, a + 1);
          }
        });
        l.ClassType.getSymbolTable(e).forEach((n, a) => {
          if (!n.isIgnoredForProtocolMatch()) {
            t.set(a, {
              symbol: n,
              classType: e,
              unspecializedClassType: e,
              isInstanceMember: n.isInstanceMember(),
              isClassMember: n.isClassMember(),
              isClassVar: o.isEffectivelyClassVar(n, false),
              isReadOnly: false,
              isTypeDeclared: n.hasTypedDeclarations(),
              skippedUndeclaredType: false
            });
          }
        });
      }
    }
    function E(e, t, n = 0, a) {
      if (l.isClassInstance(e)) {
        return M(e, t, n, a);
      }
    }
    function M(e, t, n = 0, a) {
      var r;
      var s;
      const i = e.shared.effectiveMetaclass;
      if (i && l.isClass(i) && !l.ClassType.isBuiltIn(i, 'type')) {
        const e = (r = O(i, t, 32).next()) === null || r === undefined ? undefined : r.value;
        if (e && !l.isAnyOrUnknown(e.classType)) {
          e.isClassMember = true;
          return e;
        }
      }
      if ((s = O(e, t, n, a).next()) === null || s === undefined) {
        return undefined;
      } else {
        return s.value;
      }
    }
    function* O(e, t, n = 0, a) {
      const r = !!(n & 64);
      let s = false;
      if (l.isClass(e)) {
        let p = 0;
        if (n & 1 && l.isClass(e)) {
          a = l.isClassInstance(e) ? l.ClassType.cloneAsInstantiable(e) : e;
        }
        if (n & 2) {
          p |= 1;
        }
        if (n & 4) {
          p |= 2;
        }
        if (n & 8) {
          p |= 4;
        }
        const d = U(e, p, a);
        for (const [a, p] of d) {
          if (!l.isInstantiableClass(a)) {
            if (!r) {
              const e = l.isAnyOrUnknown(a) ? a : l.UnknownType.create();
              const t = {
                symbol: i.Symbol.createWithType(0, a),
                isInstanceMember: false,
                isClassMember: true,
                isClassVar: false,
                classType: e,
                unspecializedClassType: e,
                isReadOnly: false,
                isTypeDeclared: false,
                skippedUndeclaredType: false
              };
              yield t;
            }
            continue;
          }
          if (!l.isInstantiableClass(p)) {
            continue;
          }
          const d = l.ClassType.getSymbolTable(p);
          if (!(n & 16)) {
            const e = d.get(t);
            if (e && e.isInstanceMember()) {
              const n = e.hasTypedDeclarations();
              if (!r || n) {
                const r = {
                  symbol: e,
                  isInstanceMember: true,
                  isClassMember: e.isClassMember(),
                  isClassVar: o.isEffectivelyClassVar(e, l.ClassType.isDataClass(p)),
                  classType: p,
                  unspecializedClassType: a,
                  isReadOnly: z(p, t),
                  isTypeDeclared: n,
                  skippedUndeclaredType: s
                };
                yield r;
              } else {
                s = true;
              }
            }
          }
          if (!(n & 32)) {
            let n = d.get(t);
            if (n && n.isClassMember()) {
              const d = n.hasTypedDeclarations();
              if (!r || d) {
                let r = n.isInstanceMember();
                let c = true;
                const u = l.ClassType.isDataClass(p);
                const m = l.ClassType.isTypedDictClass(p);
                if (d && (u || m)) {
                  const e = n.getDeclarations();
                  if (e.length > 0 && e[0].type === 1) {
                    r = true;
                    c = u;
                  }
                }
                if (t === '__call__' && e.priv.partialCallType && l.ClassType.isSameGenericClass(l.TypeBase.isInstance(e) ? l.ClassType.cloneAsInstantiable(e) : e, p)) {
                  n = i.Symbol.createWithType(4, e.priv.partialCallType);
                }
                const y = {
                  symbol: n,
                  isInstanceMember: r,
                  isClassMember: c,
                  isClassVar: o.isEffectivelyClassVar(n, u),
                  classType: p,
                  unspecializedClassType: a,
                  isReadOnly: false,
                  isTypeDeclared: d,
                  skippedUndeclaredType: s
                };
                yield y;
              } else {
                s = true;
              }
            }
          }
        }
      } else {
        if (l.isAnyOrUnknown(e)) {
          const t = {
            symbol: i.Symbol.createWithType(0, e),
            isInstanceMember: false,
            isClassMember: true,
            isClassVar: false,
            classType: e,
            unspecializedClassType: e,
            isReadOnly: false,
            isTypeDeclared: false,
            skippedUndeclaredType: false
          };
          yield t;
        }
      }
    }
    function z(e, t) {
      var n;
      if (l.ClassType.hasNamedTupleEntry(e, t)) {
        return true;
      }
      if (l.ClassType.isDataClassFrozen(e)) {
        const a = (n = e.shared) === null || n === undefined ? undefined : n.dataClassEntries;
        if (a == null ? undefined : a.some(e => e.name === t)) {
          return true;
        }
      }
      return false;
    }
    function* U(e, t = 0, n) {
      if (l.isClass(e)) {
        let a = n === undefined;
        for (const r of e.shared.mro) {
          if (!a && n) {
            if (l.isClass(r)) {
              if (l.ClassType.isSameGenericClass(r, n)) {
                a = true;
                continue;
              }
              continue;
            }
            a = true;
          }
          const s = x(r, e, undefined);
          if (t & 2 && l.isInstantiableClass(s) && l.ClassType.isBuiltIn(s, 'object')) {
            break;
          }
          if (t & 4 && l.isInstantiableClass(s) && l.ClassType.isBuiltIn(s, 'type')) {
            break;
          }
          yield [r, s];
          if (t & 1) {
            break;
          }
        }
      }
    }
    function V(e, t, n) {
      for (const a of t) {
        if ((!n || a.priv.scopeId === n) && !e.find(e => l.isTypeSame(e, a))) {
          e.push(a);
        }
      }
    }
    function R(e) {
      if (e.shared.typeParams.length === 0 || e.priv.typeArgs || !e.shared.typeVarScopeId) {
        return e;
      }
      return N(e, new s.ConstraintSolution(), {
        replaceUnsolved: {
          scopeIds: [e.shared.typeVarScopeId],
          tupleClassType: undefined
        }
      });
    }
    function L(e) {
      const t = l.ClassType.getTypeParams(e);
      let n;
      n = e.priv.tupleTypeArgs ? [W(H(e, e.priv.tupleTypeArgs, e.priv.isTypeArgExplicit, true))] : e.priv.typeArgs;
      return B(t, n);
    }
    function B(e, t) {
      const n = new s.ConstraintSolution();
      if (t) {
        e.forEach((e, a) => {
          if (a < t.length) {
            n.setType(e, t[a]);
          }
        });
        return n;
      } else {
        return n;
      }
    }
    function j(e, t) {
      var n;
      const a = l.TypeVarType.createInstance('__type_of_self__');
      const r = (n = v(e)) !== null && n !== undefined ? n : '';
      a.shared.isSynthesized = true;
      a.shared.isSynthesizedSelf = true;
      a.priv.scopeId = r;
      a.priv.scopeName = '';
      a.priv.nameWithScope = l.TypeVarType.makeNameWithScope(a.shared.name, r, a.priv.scopeName);
      const s = l.ClassType.specialize(e, undefined, false, !!e.priv.includeSubclasses);
      a.shared.boundType = l.ClassType.cloneAsInstance(s);
      if (t) {
        return l.TypeVarType.cloneAsInstantiable(a);
      } else {
        return a;
      }
    }
    function q(e) {
      return l.isClassInstance(e) && e.shared.mro.some(e => l.isClass(e) && l.ClassType.isBuiltIn(e, 'type'));
    }
    function G(e, t, n = 0) {
      return !(n > l.maxTypeRecursionCount) && (n++, !!l.TypeBase.isInstantiable(e) || !!(t == null ? undefined : t.honorTypeVarBounds) && !!l.isTypeVar(e) && !!e.shared.boundType && !!G(e.shared.boundType, t, n) || !!q(e) || !!l.isUnion(e) && e.priv.subtypes.every(e => G(e, t, n)));
    }
    function W(e, t = true) {
      var n;
      var a;
      if (((n = e.cached) === null || n === undefined ? undefined : n.instanceType) && t) {
        return e.cached.instanceType;
      }
      let r = c(e, e => {
        switch (e.category) {
          case 6:
            if (l.ClassType.isBuiltIn(e, 'type')) {
              if (l.TypeBase.isInstance(e)) {
                if (!e.priv.typeArgs || e.priv.typeArgs.length < 1) {
                  return l.UnknownType.create();
                } else {
                  return e.priv.typeArgs[0];
                }
              }
              if (e.priv.typeArgs && e.priv.typeArgs.length > 0 && !l.isAnyOrUnknown(e.priv.typeArgs[0])) {
                return K(e.priv.typeArgs[0]);
              }
            }
            return l.ClassType.cloneAsInstance(e, t);
          case 4:
            if (l.TypeBase.isInstantiable(e)) {
              return l.FunctionType.cloneAsInstance(e);
            }
            break;
          case 9:
            if (l.TypeBase.isInstantiable(e)) {
              return l.TypeVarType.cloneAsInstance(e);
            }
            break;
          case 2:
            return l.AnyType.convertToInstance(e);
          case 1:
            return l.UnknownType.convertToInstance(e);
          case 3:
            return l.NeverType.convertToInstance(e);
          case 0:
            return l.UnboundType.convertToInstance(e);
        }
        return e;
      }, {
        skipElideRedundantLiterals: true
      });
      const s = (a = e.props) === null || a === undefined ? undefined : a.typeAliasInfo;
      if (s && e !== r) {
        r = l.TypeBase.cloneForTypeAlias(r, s);
      }
      if (e !== r && t) {
        if (!e.cached) {
          e.cached = {};
        }
        e.cached.instanceType = r;
      }
      return r;
    }
    function K(e, t = true) {
      var n;
      if ((n = e.cached) === null || n === undefined ? undefined : n.instantiableType) {
        return e.cached.instantiableType;
      }
      const a = c(e, e => {
        switch (e.category) {
          case 6:
            return l.ClassType.cloneAsInstantiable(e, t);
          case 4:
            return l.FunctionType.cloneAsInstantiable(e);
          case 9:
            return l.TypeVarType.cloneAsInstantiable(e);
        }
        return e;
      });
      if (e !== a) {
        if (!e.cached) {
          e.cached = {};
        }
        e.cached.instantiableType = a;
      }
      return a;
    }
    function $(e) {
      const t = [];
      e.forEach(e => {
        if (l.isTypeVar(e.type)) {
          if (l.isUnpackedTypeVarTuple(e.type)) {
            t.push(l.TypeVarType.cloneForUnpacked(e.type, true));
            return;
          }
          if (l.isUnpackedTypeVar(e.type)) {
            if (e.type.shared.boundType && l.isClassInstance(e.type.shared.boundType) && S(e.type.shared.boundType) && e.type.shared.boundType.priv.tupleTypeArgs) {
              t.push($(e.type.shared.boundType.priv.tupleTypeArgs));
            }
            return;
          }
        }
        t.push(e.type);
      });
      return l.combineTypes(t);
    }
    function H(e, t, n = true, a = false) {
      const r = l.ClassType.specialize(e, [$(t)], n, undefined, t);
      if (a) {
        r.priv.isUnpacked = true;
      }
      return r;
    }
    function Z(e) {
      if (l.isClassInstance(e) && S(e) && e.priv.tupleTypeArgs && e.priv.isUnpacked) {
        return l.combineTypes(e.priv.tupleTypeArgs.map(e => e.type));
      } else {
        return e;
      }
    }
    function Y(e) {
      var t;
      if (l.isClassInstance(e)) {
        if (l.ClassType.isBuiltIn(e, ['Generator', 'AsyncGenerator'])) {
          return e.priv.typeArgs;
        }
        if (l.ClassType.isBuiltIn(e, 'AwaitableGenerator')) {
          if ((t = e.priv.typeArgs) === null || t === undefined) {
            return undefined;
          } else {
            return t.slice(0, 3);
          }
        }
      }
    }
    function J(e, t, n = 0) {
      var a;
      if (n > l.maxTypeRecursionCount) {
        return false;
      }
      n++;
      const r = !(t == null ? undefined : t.ignorePseudoGeneric) && !(t == null ? undefined : t.ignoreSelf);
      if (r && ((a = e.cached) === null || a === undefined ? undefined : a.requiresSpecialization) !== undefined) {
        return e.cached.requiresSpecialization;
      }
      const s = function (e, t, n = 0) {
        var a;
        var r;
        if ((a = e.props) === null || a === undefined ? undefined : a.condition) {
          return true;
        }
        switch (e.category) {
          case 6:
            return (!l.ClassType.isPseudoGenericClass(e) || !(t == null ? undefined : t.ignorePseudoGeneric)) && (!!e.priv.isTypeArgExplicit || !(t == null ? undefined : t.ignoreImplicitTypeArgs)) && (!!e.priv.tupleTypeArgs && !!e.priv.tupleTypeArgs.some(e => J(e.type, t, n)) || (e.priv.typeArgs ? e.priv.typeArgs.some(e => J(e, t, n)) : l.ClassType.getTypeParams(e).length > 0));
          case 4:
            {
              for (let a = 0; a < e.shared.parameters.length; a++) {
                if (J(l.FunctionType.getParamType(e, a), t, n)) {
                  return true;
                }
              }
              const a = e.priv.specializedTypes && e.priv.specializedTypes.returnType ? e.priv.specializedTypes.returnType : e.shared.declaredReturnType;
              if (a) {
                if (J(a, t, n)) {
                  return true;
                }
              } else {
                if (e.priv.inferredReturnType && J(e.priv.inferredReturnType, t, n)) {
                  return true;
                }
              }
              return false;
            }
          case 5:
            {
              if (l.OverloadedType.getOverloads(e).some(e => J(e, t, n))) {
                return true;
              }
              const a = l.OverloadedType.getImplementation(e);
              return !!a && J(a, t, n);
            }
          case 8:
            return e.priv.subtypes.some(e => J(e, t, n));
          case 9:
            {
              if (!e.shared.recursiveAlias) {
                return !l.TypeVarType.isSelf(e) || !(t == null ? undefined : t.ignoreSelf);
              }
              const a = (r = e.props) === null || r === undefined ? undefined : r.typeAliasInfo;
              if (a == null ? undefined : a.typeArgs) {
                return a.typeArgs.some(e => J(e, t, n));
              }
            }
        }
        return false;
      }(e, t, n);
      if (r) {
        if (e.cached === undefined) {
          e.cached = {};
        }
        e.cached.requiresSpecialization = s;
      }
      return s;
    }
    function Q(e, t, n = 0) {
      if (n > l.maxTypeRecursionCount) {
        return;
      }
      n++;
      const a = e => {
        if (e && !t.some(t => t === e)) {
          t.push(e);
        }
      };
      switch (e.category) {
        case 6:
        case 4:
          a(e.shared.moduleName);
          break;
        case 5:
          {
            l.OverloadedType.getOverloads(e).forEach(e => {
              Q(e, t, n);
            });
            const a = l.OverloadedType.getImplementation(e);
            if (a) {
              Q(a, t, n);
            }
            break;
          }
        case 8:
          y(e, e => {
            Q(e, t, n);
          });
          break;
        case 7:
          a(e.priv.moduleName);
      }
    }
    function X(e) {
      if (l.isParamSpec(e)) {
        const t = l.FunctionType.createInstance('', '', '', 65536);
        l.FunctionType.addParamSpecVariadics(t, e);
        t.shared.typeVarScopeId = v(e);
        return t;
      }
      if (l.isFunction(e)) {
        if (l.FunctionType.isParamSpecValue(e)) {
          return e;
        }
        const t = l.FunctionType.createInstance('', '', '', e.shared.flags | 65536, e.shared.docString);
        t.shared.deprecatedMessage = e.shared.deprecatedMessage;
        e.shared.parameters.forEach((n, a) => {
          l.FunctionType.addParam(t, l.FunctionParam.create(n.category, l.FunctionType.getParamType(e, a), n.flags, n.name, l.FunctionType.getParamDefaultType(e, a), n.defaultExpr));
        });
        t.shared.typeVarScopeId = e.shared.typeVarScopeId;
        t.priv.constructorTypeVarScopeId = e.priv.constructorTypeVarScopeId;
        return t;
      }
      return l.ParamSpecType.getUnknown();
    }
    function ee(e) {
      const t = l.FunctionType.getParamSpecFromArgsKwargs(e);
      const n = l.FunctionType.cloneRemoveParamSpecArgsKwargs(e);
      let a = n.shared.parameters.length > 0;
      if (n.shared.parameters.length === 1) {
        const e = n.shared.parameters[0];
        if (l.isPositionOnlySeparator(e)) {
          a = false;
        }
      }
      if (!a && t) {
        return t;
      } else {
        return e;
      }
    }
    exports.UniqueSignatureTracker = class {
      constructor() {
        this._trackedSignatures = [];
      }
      getTrackedSignatures() {
        return this._trackedSignatures;
      }
      addTrackedSignatures(e) {
        e.forEach(e => {
          e.expressionOffsets.forEach(t => {
            this.addSignature(e.type, t);
          });
        });
      }
      findSignature(e) {
        let t = e;
        if (l.isFunction(e) && e.priv.overloaded) {
          t = e.priv.overloaded;
        }
        return this._trackedSignatures.find(e => l.isTypeSame(t, e.type));
      }
      addSignature(e, t) {
        var n;
        const a = l.isFunction(e) && (n = e.priv.overloaded) !== null && n !== undefined ? n : e;
        const r = this.findSignature(a);
        if (r) {
          if (!r.expressionOffsets.some(e => e === t)) {
            r.expressionOffsets.push(t);
          }
        } else {
          this._trackedSignatures.push({
            type: a,
            expressionOffsets: [t]
          });
        }
      }
    };
    class te {
      constructor() {
        this._pendingTypeVarTransformations = new Set();
        this._pendingFunctionTransformations = [];
      }
      get pendingTypeVarTransformations() {
        return this._pendingTypeVarTransformations;
      }
      apply(e, t) {
        var n;
        var r;
        var s;
        if (t > l.maxTypeRecursionCount) {
          return e;
        }
        t++;
        if ((n = (e = this.transformGenericTypeAlias(e, t)).props) === null || n === undefined ? undefined : n.condition) {
          e = this.transformConditionalType(e, t);
        }
        if (this.canSkipTransform(e)) {
          return e;
        }
        if (l.isAnyOrUnknown(e)) {
          return e;
        }
        if (d(e)) {
          return e;
        }
        if (l.isTypeVar(e)) {
          const n = (r = e.props) === null || r === undefined ? undefined : r.typeAliasInfo;
          if (e.shared.recursiveAlias) {
            if (!(n == null ? undefined : n.typeArgs)) {
              return e;
            }
            let a = false;
            const r = n.typeArgs.map(e => {
              const n = this.apply(e, t);
              if (n !== e) {
                a = true;
              }
              return n;
            });
            if (a) {
              return l.TypeBase.cloneForTypeAlias(e, {
                ...n,
                typeArgs: r
              });
            } else {
              return e;
            }
          }
          let a = e;
          if (!this._isTypeVarScopePending(e.priv.scopeId)) {
            let n;
            if (l.isParamSpec(e) && e.priv.paramSpecAccess) {
              n = e.priv.paramSpecAccess;
              e = l.TypeVarType.cloneForParamSpecAccess(e, undefined);
            }
            a = (s = this.transformTypeVar(e, t)) !== null && s !== undefined ? s : e;
            if (l.isParamSpec(e) && a !== e) {
              a = ee(X(a));
            }
            if (n) {
              a = l.isParamSpec(a) ? l.TypeVarType.cloneForParamSpecAccess(a, n) : l.UnknownType.create();
            }
            if (l.isTypeVarTuple(e) && e.priv.isInUnion) {
              a = Z(a);
            }
            if (e.priv.scopeId) {
              this._pendingTypeVarTransformations.add(e.priv.scopeId);
              a = this.apply(a, t);
              this._pendingTypeVarTransformations.delete(e.priv.scopeId);
            }
          }
          return a;
        }
        if (l.isUnion(e)) {
          const n = c(e, e => {
            let n = this.apply(e, t);
            if (l.isTypeVarTuple(e) && !l.isTypeVarTuple(n)) {
              const e = [];
              y(n, t => {
                e.push(Z(t));
              });
              n = l.combineTypes(e);
            }
            if (this.transformUnionSubtype) {
              return this.transformUnionSubtype(e, n, t);
            } else {
              return n;
            }
          }, {
            retainTypeAlias: true
          });
          if (l.isNever(n)) {
            return l.UnknownType.create();
          } else {
            return n;
          }
        }
        if (l.isClass(e)) {
          return this.transformTypeVarsInClassType(e, t);
        }
        if (l.isFunction(e)) {
          if (this._pendingFunctionTransformations.some(t => t === e)) {
            return e;
          }
          this._pendingFunctionTransformations.push(e);
          const n = this.transformTypeVarsInFunctionType(e, t);
          this._pendingFunctionTransformations.pop();
          return n;
        }
        if (l.isOverloaded(e)) {
          if (this._pendingFunctionTransformations.some(t => t === e)) {
            return e;
          }
          this._pendingFunctionTransformations.push(e);
          let n = false;
          const r = l.OverloadedType.getOverloads(e);
          const s = [];
          r.forEach(e => {
            const r = this.transformTypeVarsInFunctionType(e, t);
            if (l.isFunction(r)) {
              s.push(r);
            } else {
              a.appendArray(s, l.OverloadedType.getOverloads(r));
            }
            if (r !== e) {
              n = true;
            }
          });
          const i = l.OverloadedType.getImplementation(e);
          let o = i;
          if (i) {
            o = this.apply(i, t);
            if (o !== i) {
              n = true;
            }
          }
          this._pendingFunctionTransformations.pop();
          if (n) {
            return l.OverloadedType.create(s, o);
          } else {
            return e;
          }
        }
        return e;
      }
      canSkipTransform(e) {
        return !J(e);
      }
      transformTypeVar(e, t) {}
      transformTupleTypeVar(e, t) {}
      transformUnionSubtype(e, t, n) {
        return t;
      }
      doForEachConstraintSet(e) {
        return e();
      }
      transformGenericTypeAlias(e, t) {
        var n;
        const a = (n = e.props) === null || n === undefined ? undefined : n.typeAliasInfo;
        if (!a || !a.shared.typeParams || !a.typeArgs) {
          return e;
        }
        let r = false;
        const s = a.typeArgs.map(n => {
          const a = this.apply(n, t);
          if (e !== a) {
            r = true;
          }
          return a;
        });
        if (r) {
          return l.TypeBase.cloneForTypeAlias(e, {
            ...a,
            typeArgs: s
          });
        } else {
          return e;
        }
      }
      transformConditionalType(e, t) {
        return e;
      }
      transformTypeVarsInClassType(e, t) {
        var n;
        const r = l.ClassType.getTypeParams(e);
        if (r.length === 0 && !l.ClassType.isSpecialBuiltIn(e) && !l.ClassType.isBuiltIn(e, 'type')) {
          return e;
        }
        let s;
        let i;
        let o = false;
        let p = true;
        if (l.ClassType.isTupleClass(e)) {
          if (e.priv.tupleTypeArgs) {
            i = [];
            e.priv.tupleTypeArgs.forEach(n => {
              const r = this.apply(n.type, t);
              if (r !== n.type) {
                o = true;
              }
              if (l.isUnpackedTypeVarTuple(n.type) && l.isClassInstance(r) && S(r) && r.priv.tupleTypeArgs) {
                a.appendArray(i, r.priv.tupleTypeArgs);
              } else {
                if (l.isUnpackedClass(r) && r.priv.tupleTypeArgs) {
                  a.appendArray(i, r.priv.tupleTypeArgs);
                } else {
                  if (!n.isUnbounded || !l.isTypeVar(n.type) || !l.isNever(r) || e.priv.tupleTypeArgs.length !== 1) {
                    i.push({
                      type: r,
                      isUnbounded: n.isUnbounded,
                      isOptional: n.isOptional
                    });
                  }
                }
              }
            });
          } else {
            if (r.length > 0) {
              i = this.transformTupleTypeVar(r[0], t);
              if (i) {
                o = true;
              } else {
                const e = this.apply(r[0], t);
                i = [{
                  type: e,
                  isUnbounded: true
                }];
                o = true;
                p = false;
              }
            }
          }
          if (i && i.length > 0) {
            s = [$(i)];
          }
        }
        if (!s) {
          const a = (n = e.priv.typeArgs) !== null && n !== undefined ? n : r;
          if (!e.priv.typeArgs) {
            p = false;
          }
          s = a.map(e => {
            let n = this.apply(e, t);
            if (n !== e) {
              o = true;
              if (l.isTypeVar(e) && l.isTypeVarTuple(e) && e.priv.isInUnion) {
                n = Z(n);
              }
            }
            return n;
          });
        }
        if (o) {
          return l.ClassType.specialize(e, s, p, undefined, i);
        } else {
          return e;
        }
      }
      transformTypeVarsInFunctionType(e, t) {
        return this.doForEachConstraintSet(() => {
          let n = e;
          const a = l.FunctionType.getEffectiveReturnType(n);
          const r = a ? this.apply(a, t) : undefined;
          let s = a !== r;
          const i = {
            parameterTypes: [],
            parameterDefaultTypes: undefined,
            returnType: r
          };
          const o = l.FunctionType.getParamSpecFromArgsKwargs(n);
          if (o) {
            const e = this.transformTypeVar(o, t);
            if (e) {
              const t = X(e);
              const a = l.FunctionType.getParamSpecFromArgsKwargs(t);
              if (t.shared.parameters.length > 0 || !a || !l.isTypeSame(o, a)) {
                n = l.FunctionType.applyParamSpecValue(n, t);
              }
            }
          }
          let p;
          let d;
          const c = [];
          for (let e = 0; e < n.shared.parameters.length; e++) {
            const a = l.FunctionType.getParamType(n, e);
            const r = this.apply(a, t);
            i.parameterTypes.push(r);
            let o = l.FunctionType.getParamDefaultType(n, e);
            if (o) {
              const e = this.apply(o, t);
              if (e !== o) {
                o = e;
                s = true;
              }
            }
            c.push(o);
            if (p === undefined && l.isTypeVarTuple(a) && n.shared.parameters[e].category === 1) {
              p = e;
              if (l.isClassInstance(r) && S(r) && r.priv.isUnpacked) {
                d = r.priv.tupleTypeArgs;
              }
            }
            if (a !== r) {
              s = true;
            }
          }
          let u;
          if (n.priv.inferredReturnType) {
            u = this.apply(n.priv.inferredReturnType, t);
            if (u !== n.priv.inferredReturnType) {
              s = true;
            }
          }
          if (n.priv.boundToType) {
            const e = this.apply(n.priv.boundToType, t);
            if (e !== n.priv.boundToType && l.isClass(e)) {
              n = l.FunctionType.clone(n, false, e);
            }
          }
          if (n.priv.strippedFirstParamType) {
            const e = this.apply(n.priv.strippedFirstParamType, t);
            if (e !== n.priv.strippedFirstParamType) {
              n = l.TypeBase.cloneType(n);
              n.priv.strippedFirstParamType = e;
            }
          }
          if (!s) {
            return n;
          }
          if (c.some(e => e !== undefined)) {
            i.parameterDefaultTypes = c;
          }
          if (!d) {
            return l.FunctionType.specialize(n, i, u);
          }
          const m = l.TypeBase.isInstantiable(n) ? l.FunctionType.createInstantiable(n.shared.flags | 64) : l.FunctionType.createSynthesizedInstance('', n.shared.flags);
          let y = false;
          let g = false;
          i.parameterTypes.forEach((e, t) => {
            if (t === p) {
              let e = false;
              d.forEach(t => {
                l.FunctionType.addParam(m, l.FunctionParam.create(t.isUnbounded || l.isTypeVarTuple(t.type) ? 1 : 0, t.type, l.FunctionParamFlags.NameSynthesized | l.FunctionParamFlags.TypeDeclared, `__p${m.shared.parameters.length}`));
                if (t.isUnbounded) {
                  e = true;
                }
              });
              if (e) {
                g = true;
              } else {
                y = true;
              }
            } else {
              const a = n.shared.parameters[t];
              if (l.isKeywordOnlySeparator(a) || a.category === 2) {
                y = false;
              }
              if (a.category === 0 && a.name && y) {
                l.FunctionType.addKeywordOnlyParamSeparator(m);
                y = false;
              }
              if (a.category !== 0 || !!a.name || !g) {
                l.FunctionType.addParam(m, l.FunctionParam.create(a.category, e, a.flags, a.name && l.FunctionParam.isNameSynthesized(a) ? `__p${m.shared.parameters.length}` : a.name, l.FunctionType.getParamDefaultType(n, t), a.defaultExpr));
              }
            }
          });
          m.shared.declaredReturnType = i.returnType;
          return m;
        });
      }
      _isTypeVarScopePending(e) {
        return !!e && this._pendingTypeVarTransformations.has(e);
      }
    }
    exports.TypeVarTransformer = te;
    class ne extends te {
      constructor(e, t) {
        super();
        this._liveTypeParams = e;
        this._invalidTypeVars = t;
      }
      transformTypeVar(e) {
        const t = this._liveTypeParams.find(t => t.shared.name === e.shared.name);
        if (!t || l.isParamSpec(t) !== l.isParamSpec(e)) {
          this._invalidTypeVars.add(e.shared.name);
        }
        return l.UnknownType.create();
      }
    }
    class ae extends te {
      constructor(e, t) {
        super();
        this._signatureTracker = e;
        this._expressionOffset = t;
      }
      transformGenericTypeAlias(e, t) {
        return e;
      }
      transformTypeVarsInClassType(e, t) {
        return e;
      }
      transformTypeVarsInFunctionType(e, t) {
        if (e.shared.typeParams.length === 0) {
          return super.transformTypeVarsInFunctionType(e, t);
        }
        let n = e;
        const a = this._signatureTracker.findSignature(e);
        if (a) {
          let t = a.expressionOffsets.findIndex(e => e === this._expressionOffset);
          if (t < 0) {
            t = a.expressionOffsets.length;
          }
          if (t > 0) {
            const a = new s.ConstraintSolution();
            e.shared.typeParams.forEach(e => {
              if (e.priv.scopeType === 1) {
                const n = l.TypeVarType.cloneForNewName(e, `${e.shared.name}(${t})`);
                a.setType(e, n);
              }
            });
            n = N(e, a);
            r.assert(l.isFunction(n) || l.isOverloaded(n));
          }
        }
        this._signatureTracker.addSignature(e, this._expressionOffset);
        return n;
      }
    }
    class re extends te {
      constructor(e) {
        super();
        this._scopeIds = e;
      }
      transformTypeVar(e) {
        if (this._isTypeVarInScope(e)) {
          return this._replaceTypeVar(e);
        }
      }
      _isTypeVarInScope(e) {
        return !!e.priv.scopeId && (!this._scopeIds || this._scopeIds.includes(e.priv.scopeId));
      }
      _replaceTypeVar(e) {
        return l.TypeVarType.cloneAsBound(e);
      }
    }
    class se extends te {
      constructor(e) {
        super();
        this._scopeIds = e;
      }
      transformTypeVar(e) {
        if (e.priv.freeTypeVar && this._isTypeVarInScope(e.priv.freeTypeVar)) {
          return e.priv.freeTypeVar;
        }
      }
      _isTypeVarInScope(e) {
        return !!e.priv.scopeId && this._scopeIds.includes(e.priv.scopeId);
      }
    }
    class ie extends te {
      constructor(e, t) {
        super();
        this._solution = e;
        this._options = t;
        this._isSolvingDefaultType = false;
      }
      transformTypeVar(e, t) {
        var n;
        var a;
        var r;
        const s = this._solution.getSolutionSet((n = this._activeConstraintSetIndex) !== null && n !== undefined ? n : 0);
        if (this._isSolvingDefaultType && !e.priv.scopeId) {
          const n = this._getReplacementForDefaultByName(e, s);
          return n || (e.shared.isDefaultExplicit ? this.apply(e.shared.defaultType, t) : l.UnknownType.create());
        }
        if (!this._shouldReplaceTypeVar(e)) {
          return;
        }
        let i = s.getType(e);
        if (i) {
          if (l.isParamSpec(e)) {
            return i;
          }
          i = l.TypeBase.isInstantiable(e) ? l.isAnyOrUnknown(i) && this._options.typeClassType && l.isInstantiableClass(this._options.typeClassType) ? l.ClassType.specialize(l.ClassType.cloneAsInstance(this._options.typeClassType), [i]) : K(i, false) : c(i, e => l.isClassInstance(e) && (e.priv.includeSubclasses || (e = l.ClassType.cloneAsInstance(l.ClassType.cloneAsInstantiable(e))), e.shared.typeParams && !e.priv.typeArgs && this._options.replaceUnsolved) ? this._options.replaceUnsolved.useUnknown ? b(e, this._options.replaceUnsolved.tupleClassType) : R(e) : e);
          if (l.isTypeVarTuple(i) && l.isTypeVarTuple(e) && e.priv.isUnpacked) {
            return l.TypeVarType.cloneForUnpacked(i, e.priv.isInUnion);
          }
          if (!l.isTypeVarTuple(i) && l.isTypeVar(i) && l.isTypeVar(e) && e.priv.isUnpacked) {
            return l.TypeVarType.cloneForUnpacked(i);
          }
          if (!l.isTypeVarTuple(e) && l.isClassInstance(i) && i.priv.tupleTypeArgs && i.priv.isUnpacked) {
            i = $(i.priv.tupleTypeArgs);
          }
          if (l.isUnpackedTypeVar(e) && l.isClass(i)) {
            i = l.ClassType.cloneForUnpacked(i);
          }
          if (!l.isTypeVar(i) || !l.TypeVarType.isUnification(i) || !this._options.replaceUnsolved) {
            return i;
          }
        }
        if (this._shouldReplaceUnsolvedTypeVar(e)) {
          if (e.shared.isDefaultExplicit && !((a = this._options.replaceUnsolved) === null || a === undefined ? undefined : a.useUnknown)) {
            return this._solveDefaultType(e, t);
          } else {
            return _(e, (r = this._options.replaceUnsolved) === null || r === undefined ? undefined : r.tupleClassType);
          }
        } else {
          return undefined;
        }
      }
      transformUnionSubtype(e, t) {
        var n;
        var a;
        var r;
        if (!((n = this._options.replaceUnsolved) === null || n === undefined ? undefined : n.eliminateUnsolvedInUnions)) {
          return t;
        }
        const s = this._solution.getSolutionSet((a = this._activeConstraintSetIndex) !== null && a !== undefined ? a : 0);
        if (l.isTypeVar(e)) {
          if (!this._shouldReplaceTypeVar(e) || !this._shouldReplaceUnsolvedTypeVar(e)) {
            return t;
          }
          const n = s.getType(e);
          if (n && (!l.isTypeVar(n) || !l.TypeVarType.isUnification(n))) {
            return t;
          }
          if (e === t) {
            return;
          }
          if (this._options.replaceUnsolved && l.isUnknown(t)) {
            return;
          }
        } else {
          if ((r = e.props) === null || r === undefined ? undefined : r.condition) {
            for (const t of e.props.condition) {
              if (l.TypeVarType.isUnification(t.typeVar) && !s.getType(t.typeVar)) {
                return;
              }
            }
          }
        }
        return t;
      }
      transformTupleTypeVar(e) {
        var t;
        if (!this._shouldReplaceTypeVar(e)) {
          const t = e.shared.defaultType;
          if (e.shared.isDefaultExplicit && l.isClassInstance(t) && t.priv.tupleTypeArgs) {
            return t.priv.tupleTypeArgs;
          } else {
            return undefined;
          }
        }
        const n = this._solution.getSolutionSet((t = this._activeConstraintSetIndex) !== null && t !== undefined ? t : 0).getType(e);
        if (n && l.isClassInstance(n) && n.priv.tupleTypeArgs && l.isUnpackedClass(n)) {
          return n.priv.tupleTypeArgs;
        }
      }
      transformConditionalType(e, t) {
        var n;
        var a;
        var r;
        var s;
        if (!((n = e.props) === null || n === undefined ? undefined : n.condition)) {
          return e;
        }
        const i = this._solution.getSolutionSet((a = this._activeConstraintSetIndex) !== null && a !== undefined ? a : 0);
        for (const t of e.props.condition) {
          if (!l.TypeVarType.hasConstraints(t.typeVar)) {
            continue;
          }
          const e = (s = (r = t.typeVar.priv) === null || r === undefined ? undefined : r.freeTypeVar) !== null && s !== undefined ? s : t.typeVar;
          if (!i.getType(e) || t.constraintIndex >= e.shared.constraints.length) {
            continue;
          }
          const n = i.getType(e);
          if (!n) {
            continue;
          }
          const a = e.shared.constraints[t.constraintIndex];
          if (!l.isTypeSame(a, n)) {
            return l.NeverType.createNever();
          }
        }
        return e;
      }
      doForEachConstraintSet(e) {
        const t = this._solution.getSolutionSets();
        if (t.length <= 1) {
          return e();
        }
        if (this._activeConstraintSetIndex !== undefined) {
          return e();
        }
        const n = t.map((t, n) => {
          this._activeConstraintSetIndex = n;
          return e();
        });
        this._activeConstraintSetIndex = undefined;
        const a = [];
        y(l.combineTypes(n), e => {
          r.assert(l.isFunction(e));
          e = l.FunctionType.cloneWithNewFlags(e, e.shared.flags | 256);
          a.push(e);
        });
        if (a.length === 1) {
          return a[0];
        } else {
          return l.OverloadedType.create(a);
        }
      }
      _getReplacementForDefaultByName(e, t) {
        let n;
        const a = `${e.shared.name}.`;
        t.doForEachTypeVar((e, t) => {
          if (t.startsWith(a)) {
            n = e;
          }
        });
        return n;
      }
      _shouldReplaceTypeVar(e) {
        return !!e.priv.scopeId && !l.TypeVarType.isBound(e);
      }
      _shouldReplaceUnsolvedTypeVar(e) {
        var t;
        if (this.pendingTypeVarTransformations.size > 0) {
          return false;
        }
        if (!e.priv.scopeId) {
          return false;
        }
        if (!this._options.replaceUnsolved) {
          return false;
        }
        if (!this._options.replaceUnsolved.scopeIds.includes(e.priv.scopeId)) {
          return false;
        }
        const n = (t = this._options.replaceUnsolved) === null || t === undefined ? undefined : t.unsolvedExemptTypeVars;
        return !n || !n.some(t => l.isTypeSame(t, e, {
          ignoreTypeFlags: true
        }));
      }
      _solveDefaultType(e, t) {
        const n = e.shared.defaultType;
        const a = this._isSolvingDefaultType;
        this._isSolvingDefaultType = true;
        const r = this.apply(n, t);
        this._isSolvingDefaultType = a;
        return r;
      }
    }
    class oe extends te {
      constructor(e, t) {
        super();
        this._liveTypeVarScopes = e;
        this._usageOffset = t;
      }
      transformTypeVar(e) {
        if (!this._isTypeVarLive(e)) {
          return l.TypeVarType.cloneAsUnificationVar(e, this._usageOffset);
        }
      }
      _isTypeVarLive(e) {
        return this._liveTypeVarScopes.some(t => {
          var n;
          return e.priv.scopeId === t || ((n = e.priv.freeTypeVar) === null || n === undefined ? undefined : n.priv.scopeId) === t;
        });
      }
    }
  },
  8307: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeWalker = undefined;
    const a = require(48281);
    const r = require(21024);
    exports.TypeWalker = class {
      constructor() {
        this._recursionCount = 0;
        this._isWalkCanceled = false;
        this._hitRecursionLimit = false;
      }
      get isRecursionLimitHit() {
        return this._hitRecursionLimit;
      }
      get isWalkCanceled() {
        return this._isWalkCanceled;
      }
      walk(e) {
        var t;
        if (this._recursionCount > r.maxTypeRecursionCount) {
          this._hitRecursionLimit = true;
        } else {
          if (!this._isWalkCanceled) {
            this._recursionCount++;
            if ((t = e.props) === null || t === undefined ? undefined : t.typeAliasInfo) {
              this.visitTypeAlias(e);
            }
            switch (e.category) {
              case 0:
                this.visitUnbound(e);
                break;
              case 2:
                this.visitAny(e);
                break;
              case 1:
                this.visitUnknown(e);
                break;
              case 3:
                this.visitNever(e);
                break;
              case 4:
                this.visitFunction(e);
                break;
              case 5:
                this.visitOverloaded(e);
                break;
              case 6:
                this.visitClass(e);
                break;
              case 7:
                this.visitModule(e);
                break;
              case 8:
                this.visitUnion(e);
                break;
              case 9:
                this.visitTypeVar(e);
                break;
              default:
                a.assertNever(e);
            }
            this._recursionCount--;
          }
        }
      }
      cancelWalk() {
        this._isWalkCanceled = true;
      }
      visitTypeAlias(e) {
        var t;
        const n = (t = e.props) === null || t === undefined ? undefined : t.typeAliasInfo;
        a.assert(n !== undefined);
        if (n.typeArgs) {
          for (const e of n.typeArgs) {
            this.walk(e);
            if (this._isWalkCanceled) {
              break;
            }
          }
        }
      }
      visitUnbound(e) {}
      visitAny(e) {}
      visitUnknown(e) {}
      visitNever(e) {}
      visitFunction(e) {
        var t;
        for (let t = 0; t < e.shared.parameters.length; t++) {
          if (e.shared.parameters[t].name) {
            const n = r.FunctionType.getParamType(e, t);
            this.walk(n);
            if (this._isWalkCanceled) {
              break;
            }
          }
        }
        if (!this._isWalkCanceled && !r.FunctionType.isParamSpecValue(e) && !r.FunctionType.isParamSpecValue(e)) {
          const n = (t = e.shared.declaredReturnType) !== null && t !== undefined ? t : e.priv.inferredReturnType;
          if (n) {
            this.walk(n);
          }
        }
      }
      visitOverloaded(e) {
        const t = r.OverloadedType.getOverloads(e);
        for (const e of t) {
          this.walk(e);
          if (this._isWalkCanceled) {
            break;
          }
        }
        const n = r.OverloadedType.getImplementation(e);
        if (n) {
          this.walk(n);
        }
      }
      visitClass(e) {
        var t;
        if (!r.ClassType.isPseudoGenericClass(e)) {
          const n = ((t = e.priv.tupleTypeArgs) === null || t === undefined ? undefined : t.map(e => e.type)) || e.priv.typeArgs;
          if (n) {
            for (const e of n) {
              this.walk(e);
              if (this._isWalkCanceled) {
                break;
              }
            }
          }
        }
      }
      visitModule(e) {}
      visitUnion(e) {
        for (const t of e.priv.subtypes) {
          this.walk(t);
          if (this._isWalkCanceled) {
            break;
          }
        }
      }
      visitTypeVar(e) {}
    };
  },
  66308: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createTypedDictType = function (e, t, n, a) {
      var r;
      var s;
      var i;
      var o;
      var l;
      const y = m.getFileInfo(t);
      let f;
      if (a.length === 0) {
        e.addDiagnostic(p.DiagnosticRule.reportCallIssue, u.LocMessage.typedDictFirstArg(), t);
      } else {
        const n = a[0];
        if (n.argCategory === 0 && n.valueExpression && n.valueExpression.nodeType === 48) {
          f = n.valueExpression.d.strings.map(e => e.d.value).join('');
        } else {
          e.addDiagnostic(p.DiagnosticRule.reportArgumentType, u.LocMessage.typedDictFirstArg(), a[0].valueExpression || t);
        }
      }
      const _ = f || 'TypedDict';
      const C = T.ClassType.createInstantiable(_, g.getClassFullName(t, y.moduleName, _), y.moduleName, y.fileUri, 4194308, g.getTypeSourceId(t), undefined, n.shared.effectiveMetaclass);
      C.shared.baseClasses.push(n);
      v.computeMroLinearization(C);
      const I = T.ClassType.getSymbolTable(C);
      I.set('__class__', h.Symbol.createWithType(68, C));
      let w = false;
      if (a.length < 2) {
        e.addDiagnostic(p.DiagnosticRule.reportCallIssue, u.LocMessage.typedDictSecondArgDict(), t);
      } else {
        const n = a[1];
        if (n.argCategory === 0 && n.valueExpression && n.valueExpression.nodeType === 18) {
          w = true;
          k(e, n.valueExpression, I, false);
        } else {
          if (n.name) {
            const t = new Set();
            for (let n = 1; n < a.length; n++) {
              const r = a[n];
              if (!r.name || !r.valueExpression) {
                continue;
              }
              if (t.has(r.name.d.value)) {
                e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictEntryUnique(), r.valueExpression);
                continue;
              }
              t.add(r.name.d.value);
              const s = new h.Symbol(8);
              const i = {
                type: 1,
                node: r.name,
                uri: y.fileUri,
                typeAnnotationNode: r.valueExpression,
                isRuntimeTypeExpression: true,
                range: d.convertOffsetsToRange(r.name.start, c.TextRange.getEnd(r.valueExpression), y.lines),
                moduleName: y.moduleName,
                isInExceptSuite: false
              };
              s.addDeclaration(i);
              I.set(r.name.d.value, s);
            }
          } else {
            e.addDiagnostic(p.DiagnosticRule.reportArgumentType, u.LocMessage.typedDictSecondArgDict(), t);
          }
        }
      }
      if (w) {
        const n = a.slice(2);
        for (const a of n) {
          if (((r = a.name) === null || r === undefined ? undefined : r.d.value) === 'total' || ((s = a.name) === null || s === undefined ? undefined : s.d.value) === 'closed') {
            if (!a.valueExpression || a.valueExpression.nodeType !== 14 || a.valueExpression.d.constType !== 15 && a.valueExpression.d.constType !== 33) {
              e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictBoolParam().format({
                name: a.name.d.value
              }), a.valueExpression || t);
            } else {
              if (a.name.d.value === 'total' && a.valueExpression.d.constType === 15) {
                C.shared.flags |= 32;
              } else {
                if (a.name.d.value === 'closed' && a.valueExpression.d.constType === 33 && m.getFileInfo(t).diagnosticRuleSet.enableExperimentalFeatures) {
                  C.shared.flags |= 24;
                }
              }
            }
          } else {
            if (((i = a.name) === null || i === undefined ? undefined : i.d.value) === 'extra_items') {
              C.shared.typedDictExtraItemsExpr = a.valueExpression;
              C.shared.flags |= 16;
            } else {
              e.addDiagnostic(p.DiagnosticRule.reportCallIssue, u.LocMessage.typedDictExtraArgs(), a.valueExpression || t);
            }
          }
        }
        if (T.ClassType.isTypedDictMarkedClosed(C) && C.shared.typedDictExtraItemsExpr) {
          const a = n.find(e => {
            var t;
            return ((t = e.name) === null || t === undefined ? undefined : t.d.value) === 'extra_items';
          });
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictExtraItemsClosed(), (o = a == null ? undefined : a.valueExpression) !== null && o !== undefined ? o : t);
        }
      }
      b(e, t, C);
      if (((l = t.parent) === null || l === undefined ? undefined : l.nodeType) === 3 && f) {
        const n = t.parent.d.leftExpr;
        const a = n.nodeType === 54 ? n.d.valueExpr : n;
        if (a.nodeType === 38 && a.d.value !== f) {
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictAssignedName().format({
            name: f
          }), a);
        }
      }
      return C;
    };
    exports.createTypedDictTypeInlined = function (e, t, n) {
      const a = m.getFileInfo(t);
      const r = '<TypedDict>';
      const s = T.ClassType.createInstantiable(r, g.getClassFullName(t, a.moduleName, r), a.moduleName, a.fileUri, 4, g.getTypeSourceId(t), undefined, n.shared.effectiveMetaclass);
      s.shared.baseClasses.push(n);
      v.computeMroLinearization(s);
      k(e, t, T.ClassType.getSymbolTable(s), true);
      b(e, t, s);
      return s;
    };
    exports.synthesizeTypedDictClassMethods = b;
    exports.getTypedDictMembersForClass = _;
    exports.getTypedDictMappingEquivalent = C;
    exports.getTypedDictDictEquivalent = I;
    exports.getEffectiveExtraItemsEntryType = S;
    exports.assignTypedDictToTypedDict = function (e, t, n, a, r, s, i = 0) {
      var o;
      var l;
      let p = true;
      const d = _(e, t);
      const c = _(e, n, true);
      const m = (o = c.extraItems) !== null && o !== undefined ? o : S(e, n);
      d.knownItems.forEach((o, l) => {
        if (!p && !a) {
          return;
        }
        const d = c.knownItems.get(l);
        if (d) {
          if (o.isRequired !== d.isRequired && !o.isReadOnly) {
            const n = o.isRequired ? u.LocAddendum.typedDictFieldRequired() : u.LocAddendum.typedDictFieldNotRequired();
            if (a != null) {
              a.createAddendum().addMessage(n.format({
                name: l,
                type: e.printType(T.ClassType.cloneAsInstance(t))
              }));
            }
            p = false;
          }
          if (!o.isReadOnly && d.isReadOnly) {
            if (a != null) {
              a.createAddendum().addMessage(u.LocAddendum.typedDictFieldNotReadOnly().format({
                name: l,
                type: e.printType(T.ClassType.cloneAsInstance(t))
              }));
            }
            p = false;
          }
          const n = a == null ? undefined : a.createAddendum();
          if (!e.assignType(o.valueType, d.valueType, n == null ? undefined : n.createAddendum(), r, o.isReadOnly ? s : s | 1, i)) {
            if (n != null) {
              n.addMessage(u.LocAddendum.memberTypeMismatch().format({
                name: l
              }));
            }
            p = false;
          }
        } else {
          if (o.isRequired || !o.isReadOnly) {
            if (a != null) {
              a.createAddendum().addMessage(u.LocAddendum.typedDictFieldMissing().format({
                name: l,
                type: e.printType(T.ClassType.cloneAsInstance(n))
              }));
            }
            p = false;
          } else {
            if (T.isClassInstance(m.valueType)) {
              const t = a == null ? undefined : a.createAddendum();
              if (!e.assignType(o.valueType, m.valueType, t == null ? undefined : t.createAddendum(), r, s, i)) {
                if (t != null) {
                  t.addMessage(u.LocAddendum.memberTypeMismatch().format({
                    name: l
                  }));
                }
                p = false;
              }
            }
          }
        }
      });
      if (!p && !a) {
        return false;
      }
      if (T.ClassType.isTypedDictEffectivelyClosed(t)) {
        const o = (l = d.extraItems) !== null && l !== undefined ? l : S(e, t);
        c.knownItems.forEach((o, l) => {
          if (!d.knownItems.has(l)) {
            if (d.extraItems) {
              if (o.isRequired && !d.extraItems.isReadOnly) {
                if (a != null) {
                  a.createAddendum().addMessage(u.LocAddendum.typedDictFieldNotRequired().format({
                    name: l,
                    type: e.printType(T.ClassType.cloneAsInstance(t))
                  }));
                }
                p = false;
              }
              const c = a == null ? undefined : a.createAddendum();
              if (e.assignType(d.extraItems.valueType, o.valueType, c == null ? undefined : c.createAddendum(), r, d.extraItems.isReadOnly ? s : s | 1, i)) {
                if (!d.extraItems.isReadOnly && o.isReadOnly) {
                  if (a != null) {
                    a.createAddendum().addMessage(u.LocAddendum.typedDictFieldNotReadOnly().format({
                      name: l,
                      type: e.printType(T.ClassType.cloneAsInstance(n))
                    }));
                  }
                  p = false;
                }
              } else {
                if (c != null) {
                  c.addMessage(u.LocAddendum.typedDictExtraFieldTypeMismatch().format({
                    name: l,
                    type: e.printType(T.ClassType.cloneAsInstance(t))
                  }));
                }
                p = false;
              }
            } else {
              const n = a == null ? undefined : a.createAddendum();
              if (n != null) {
                n.addMessage(u.LocAddendum.typedDictExtraFieldNotAllowed().format({
                  name: l,
                  type: e.printType(T.ClassType.cloneAsInstance(t))
                }));
              }
              p = false;
            }
          }
        });
        const y = a == null ? undefined : a.createAddendum();
        if (e.assignType(o.valueType, m.valueType, y == null ? undefined : y.createAddendum(), r, o.isReadOnly ? s : s | 1, i)) {
          if (!o.isReadOnly && m.isReadOnly) {
            if (a != null) {
              a.createAddendum().addMessage(u.LocAddendum.typedDictFieldNotReadOnly().format({
                name: 'extra_items',
                type: e.printType(T.ClassType.cloneAsInstance(t))
              }));
            }
            p = false;
          }
        } else {
          if (y != null) {
            y.addMessage(u.LocAddendum.typedDictExtraFieldTypeMismatch().format({
              name: 'extra_items',
              type: e.printType(T.ClassType.cloneAsInstance(n))
            }));
          }
          p = false;
        }
      }
      return p;
    };
    exports.assignToTypedDict = function (e, t, n, a, r) {
      o.assert(T.isClassInstance(t));
      o.assert(T.ClassType.isTypedDictClass(t));
      o.assert(n.length === a.length);
      let s = true;
      const i = new Map();
      let l;
      let p = t;
      if (t.shared.typeParams.length > 0) {
        l = new y.ConstraintTracker();
        if (t.priv.typeArgs) {
          p = T.ClassType.specialize(t, undefined);
        }
      }
      const d = _(e, p);
      n.forEach((n, o) => {
        const p = n.type;
        if (T.isClassInstance(p) && T.ClassType.isBuiltIn(p, 'str') && v.isLiteralType(p)) {
          const c = p.priv.literalValue;
          const m = d.knownItems.get(c);
          if (m) {
            const t = r == null ? undefined : r.createAddendum();
            if (!e.assignType(m.valueType, a[o].type, t == null ? undefined : t.createAddendum(), l, 256)) {
              if (t) {
                t.addMessage(u.LocAddendum.typedDictFieldTypeMismatch().format({
                  name: p.priv.literalValue,
                  type: e.printType(a[o].type)
                }));
                t.addTextRange(n.node);
              }
              s = false;
            }
            if (!m.isRequired) {
              i.set(c, {
                valueType: a[o].type,
                isReadOnly: !!a[o].isReadOnly,
                isRequired: false,
                isProvided: true
              });
            }
            m.isProvided = true;
          } else {
            if (d.extraItems) {
              const t = r == null ? undefined : r.createAddendum();
              if (!e.assignType(d.extraItems.valueType, a[o].type, t == null ? undefined : t.createAddendum(), l, 256)) {
                if (t) {
                  t.addMessage(u.LocAddendum.typedDictFieldTypeMismatch().format({
                    name: 'extra_items',
                    type: e.printType(a[o].type)
                  }));
                  t.addTextRange(n.node);
                }
                s = false;
              }
            } else {
              s = false;
              if (r) {
                const a = r == null ? undefined : r.createAddendum();
                a.addMessage(u.LocAddendum.typedDictFieldUndefined().format({
                  name: p.priv.literalValue,
                  type: e.printType(T.ClassType.cloneAsInstance(t))
                }));
                a.addTextRange(n.node);
              }
            }
          }
        } else {
          s = false;
        }
      });
      if (!s) {
        return;
      }
      d.knownItems.forEach((n, a) => {
        if (n.isRequired && !n.isProvided) {
          if (r) {
            r.addMessage(u.LocAddendum.typedDictFieldRequired().format({
              name: a,
              type: e.printType(t)
            }));
          }
          s = false;
        }
      });
      if (!s) {
        return;
      }
      const c = l ? e.solveAndApplyConstraints(p, l) : t;
      if (i.size === 0) {
        return c;
      } else {
        return T.ClassType.cloneForNarrowedTypedDictEntries(c, i);
      }
    };
    exports.getTypeOfIndexedTypedDict = function (e, t, n, a) {
      if (t.d.items.length !== 1) {
        e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typeArgsMismatchOne().format({
          received: t.d.items.length
        }), t);
        return {
          type: T.UnknownType.create()
        };
      }
      if (t.d.trailingComma || t.d.items[0].d.name || t.d.items[0].d.argCategory !== 0) {
        return;
      }
      const r = _(e, n, a.method === 'get');
      const s = e.getTypeOfExpression(t.d.items[0].d.valueExpr);
      const i = s.type;
      let o = new l.DiagnosticAddendum();
      let d = true;
      const c = v.mapSubtypes(i, t => {
        if (T.isAnyOrUnknown(t)) {
          return t;
        }
        if (T.isClassInstance(t) && T.ClassType.isBuiltIn(t, 'str')) {
          if (t.priv.literalValue === undefined) {
            return T.UnknownType.create();
          }
          const p = t.priv.literalValue;
          const c = r.knownItems.get(p) ?? r.extraItems;
          if (c) {
            if (c.isRequired || c.isProvided || a.method !== 'get') {
              if (c.isReadOnly && a.method !== 'get') {
                o.addMessage(u.LocAddendum.keyReadOnly().format({
                  name: p,
                  type: e.printType(n)
                }));
              }
            } else {
              o.addMessage(u.LocAddendum.keyNotRequired().format({
                name: p,
                type: e.printType(n)
              }));
            }
            if (a.method === 'set') {
              if (!e.assignType(c.valueType, a.setType?.type ?? T.AnyType.create(), o)) {
                d = false;
              }
            } else {
              if (a.method === 'del' && c.isRequired) {
                o.addMessage(u.LocAddendum.keyRequiredDeleted().format({
                  name: p
                }));
                d = false;
              }
            }
            return c.valueType;
          } else {
            o.addMessage(u.LocAddendum.keyUndefined().format({
              name: p,
              type: e.printType(n)
            }));
            d = false;
            return T.UnknownType.create();
          }
        }
        o.addMessage(u.LocAddendum.typeNotStringLiteral().format({
          type: e.printType(t)
        }));
        d = false;
        return T.UnknownType.create();
      });
      if (!!a.setExpectedTypeDiag && !o.isEmpty() && !a.setExpectedTypeDiag.isEmpty()) {
        o = a.setExpectedTypeDiag;
      }
      if (!o.isEmpty()) {
        let n;
        n = a.method === 'set' ? u.LocMessage.typedDictSet() : a.method === 'del' ? u.LocMessage.typedDictDelete() : u.LocMessage.typedDictAccess();
        e.addDiagnostic(d ? p.DiagnosticRule.reportTypedDictNotRequiredAccess : p.DiagnosticRule.reportGeneralTypeIssues, n + o.getString(), t);
      }
      return {
        type: c,
        isIncomplete: !!s.isIncomplete
      };
    };
    exports.narrowForKeyAssignment = function (e, t) {
      var n;
      if (!T.ClassType.isTypedDictClass(e) || !e.shared.typedDictEntries) {
        return e;
      }
      const a = e.shared.typedDictEntries.knownItems.get(t);
      if (!a || a.isRequired) {
        return e;
      }
      const r = (n = e.priv.typedDictNarrowedEntries) === null || n === undefined ? undefined : n.get(t);
      if (r == null ? undefined : r.isProvided) {
        return e;
      }
      const s = e.priv.typedDictNarrowedEntries ? new Map(e.priv.typedDictNarrowedEntries) : new Map();
      s.set(t, {
        isProvided: true,
        isRequired: false,
        isReadOnly: a.isReadOnly,
        valueType: a.valueType
      });
      return T.ClassType.cloneForNarrowedTypedDictEntries(e, s);
    };
    const i = require(58147);
    const o = require(48281);
    const l = require(11479);
    const p = require(65880);
    const d = require(56814);
    const c = require(88754);
    const u = require(67703);
    const m = __importStar(require(26687));
    const y = require(86672);
    const g = __importStar(require(41557));
    const h = require(58253);
    const f = require(4064);
    const T = require(21024);
    const v = require(92324);
    function b(e, t, n) {
      var a;
      o.assert(T.ClassType.isTypedDictClass(n));
      const r = T.FunctionType.createSynthesizedInstance('__new__', 1);
      T.FunctionType.addParam(r, T.FunctionParam.create(0, n, T.FunctionParamFlags.TypeDeclared, 'cls'));
      T.FunctionType.addDefaultParams(r);
      r.shared.declaredReturnType = T.ClassType.cloneAsInstance(n);
      r.priv.constructorTypeVarScopeId = v.getTypeVarScopeId(n);
      const s = T.FunctionType.createSynthesizedInstance('__init__', 256);
      T.FunctionType.addParam(s, T.FunctionParam.create(0, T.ClassType.cloneAsInstance(n), T.FunctionParamFlags.TypeDeclared, 'self'));
      s.shared.declaredReturnType = e.getNoneType();
      s.priv.constructorTypeVarScopeId = v.getTypeVarScopeId(n);
      T.FunctionType.addParam(s, T.FunctionParam.create(0, T.ClassType.cloneAsInstance(n), T.FunctionParamFlags.TypeDeclared, '__map'));
      const l = _(e, n);
      const p = (a = l.extraItems) !== null && a !== undefined ? a : S(e, n);
      let d = l.knownItems.size > 0;
      if (l.knownItems.size > 0) {
        T.FunctionType.addPositionOnlyParamSeparator(s);
        T.FunctionType.addKeywordOnlyParamSeparator(s);
      }
      const c = T.FunctionType.createSynthesizedInstance('__init__', 256);
      T.FunctionType.addParam(c, T.FunctionParam.create(0, T.ClassType.cloneAsInstance(n), T.FunctionParamFlags.TypeDeclared, 'self'));
      c.shared.declaredReturnType = e.getNoneType();
      c.priv.constructorTypeVarScopeId = v.getTypeVarScopeId(n);
      if (l.knownItems.size > 0) {
        T.FunctionType.addKeywordOnlyParamSeparator(c);
      }
      l.knownItems.forEach((e, t) => {
        T.FunctionType.addParam(s, T.FunctionParam.create(0, e.valueType, T.FunctionParamFlags.TypeDeclared, t, e.valueType));
        T.FunctionType.addParam(c, T.FunctionParam.create(0, e.valueType, T.FunctionParamFlags.TypeDeclared, t, e.isRequired ? undefined : e.valueType));
        if (!e.isReadOnly) {
          d = false;
        }
      });
      if (l.extraItems && !T.isNever(l.extraItems.valueType)) {
        T.FunctionType.addParam(s, T.FunctionParam.create(2, l.extraItems.valueType, T.FunctionParamFlags.TypeDeclared, 'kwargs'));
        T.FunctionType.addParam(c, T.FunctionParam.create(2, l.extraItems.valueType, T.FunctionParamFlags.TypeDeclared, 'kwargs'));
      }
      const u = T.ClassType.getSymbolTable(n);
      const m = T.OverloadedType.create([s, c]);
      u.set('__init__', h.Symbol.createWithType(4, m));
      u.set('__new__', h.Symbol.createWithType(4, r));
      const y = e.getBuiltInType(t, 'str');
      if (T.isInstantiableClass(y)) {
        const f = T.FunctionParam.create(0, T.ClassType.cloneAsInstance(n), T.FunctionParamFlags.TypeDeclared, 'self');
        function b(e) {
          let t = T.TypeVarType.createInstance('__TDefault');
          t = T.TypeVarType.cloneForScopeId(t, e.shared.typeVarScopeId, n.shared.name, 1);
          return t;
        }
        function k(n, a, r, s = false, i = false) {
          const o = T.FunctionType.createSynthesizedInstance('get', 256);
          T.FunctionType.addParam(o, f);
          o.shared.typeVarScopeId = g.getScopeIdForNode(t);
          T.FunctionType.addParam(o, T.FunctionParam.create(0, n, T.FunctionParamFlags.TypeDeclared, 'k'));
          if (r) {
            const e = b(o);
            let t;
            let n;
            if (s) {
              t = T.AnyType.create();
              n = a;
            } else {
              t = i ? a : T.combineTypes([a, e]);
              n = t;
            }
            T.FunctionType.addParam(o, T.FunctionParam.create(0, t, T.FunctionParamFlags.TypeDeclared, 'default'));
            o.shared.declaredReturnType = n;
          } else {
            o.shared.declaredReturnType = s ? a : T.combineTypes([a, e.getNoneType()]);
          }
          return o;
        }
        function w(e, n, a) {
          const r = T.FunctionParam.create(0, e, T.FunctionParamFlags.TypeDeclared, 'k');
          const s = T.FunctionType.createSynthesizedInstance('pop', 256);
          T.FunctionType.addParam(s, f);
          T.FunctionType.addParam(s, r);
          s.shared.declaredReturnType = n;
          const i = T.FunctionType.createSynthesizedInstance('pop', 256);
          T.FunctionType.addParam(i, f);
          T.FunctionType.addParam(i, r);
          i.shared.typeVarScopeId = g.getScopeIdForNode(t);
          const o = b(i);
          let l;
          let p;
          if (a) {
            l = T.AnyType.create();
            p = n;
          } else {
            l = T.combineTypes([n, o]);
            p = l;
          }
          T.FunctionType.addParam(i, T.FunctionParam.create(0, l, T.FunctionParamFlags.TypeDeclared, 'default', l));
          i.shared.declaredReturnType = p;
          return [s, i];
        }
        function A(e, t) {
          const n = T.FunctionType.createSynthesizedInstance('setdefault', 256);
          T.FunctionType.addParam(n, f);
          T.FunctionType.addParam(n, T.FunctionParam.create(0, e, T.FunctionParamFlags.TypeDeclared, 'k'));
          T.FunctionType.addParam(n, T.FunctionParam.create(0, t, T.FunctionParamFlags.TypeDeclared, 'default'));
          n.shared.declaredReturnType = t;
          return n;
        }
        function x(t) {
          const n = T.FunctionType.createSynthesizedInstance('delitem', 256);
          T.FunctionType.addParam(n, f);
          T.FunctionType.addParam(n, T.FunctionParam.create(0, t, T.FunctionParamFlags.TypeDeclared, 'k'));
          n.shared.declaredReturnType = e.getNoneType();
          return n;
        }
        function P() {
          const a = T.FunctionType.createSynthesizedInstance('update', 256);
          T.FunctionType.addParam(a, f);
          const r = T.FunctionType.createSynthesizedInstance('update', 256);
          T.FunctionType.addParam(r, f);
          const s = T.FunctionType.createSynthesizedInstance('update', 256);
          T.FunctionType.addParam(s, f);
          T.FunctionType.addParam(a, T.FunctionParam.create(0, d ? T.NeverType.createNever() : T.ClassType.cloneAsInstance(T.ClassType.cloneForPartialTypedDict(n)), T.FunctionParamFlags.TypeDeclared, '__m'));
          if (l.knownItems.size > 0) {
            T.FunctionType.addPositionOnlyParamSeparator(a);
            T.FunctionType.addKeywordOnlyParamSeparator(s);
          }
          a.shared.declaredReturnType = e.getNoneType();
          r.shared.declaredReturnType = e.getNoneType();
          s.shared.declaredReturnType = e.getNoneType();
          const i = [];
          const o = e.getBuiltInType(t, 'tuple');
          l.knownItems.forEach((e, t) => {
            if (!e.isReadOnly) {
              if (o && T.isInstantiableClass(o) && y && T.isInstantiableClass(y)) {
                const n = v.specializeTupleClass(T.ClassType.cloneAsInstance(o), [{
                  type: T.ClassType.cloneWithLiteral(T.ClassType.cloneAsInstance(y), t),
                  isUnbounded: false
                }, {
                  type: e.valueType,
                  isUnbounded: false
                }]);
                i.push(n);
              }
              T.FunctionType.addParam(s, T.FunctionParam.create(0, e.valueType, T.FunctionParamFlags.TypeDeclared, t, T.AnyType.create(true)));
            }
          });
          const p = e.getTypingType(t, 'Iterable');
          if (p && T.isInstantiableClass(p)) {
            const e = T.ClassType.cloneAsInstance(p);
            T.FunctionType.addParam(r, T.FunctionParam.create(0, T.ClassType.specialize(e, [T.combineTypes(i)]), T.FunctionParamFlags.TypeDeclared, '__m'));
          }
          if (l.knownItems.size > 0) {
            T.FunctionType.addPositionOnlyParamSeparator(r);
          }
          return T.OverloadedType.create([r, a, s]);
        }
        const D = [];
        const N = [];
        const F = [];
        l.knownItems.forEach((e, t) => {
          const n = T.ClassType.cloneAsInstance(T.ClassType.cloneWithLiteral(y, t));
          D.push(k(n, e.valueType, false, e.isRequired));
          D.push(k(n, e.valueType, true, e.isRequired, e.isRequired));
          if (!e.isRequired && !e.isReadOnly) {
            i.appendArray(N, w(n, e.valueType, e.isRequired));
          }
          if (!e.isReadOnly) {
            F.push(A(n, e.valueType));
          }
        });
        const E = T.ClassType.cloneAsInstance(y);
        if (T.ClassType.isTypedDictEffectivelyClosed(n)) {
          D.push(k(E, T.combineTypes([p.valueType, e.getNoneType()]), false, true));
          D.push(k(E, p.valueType, true));
        } else {
          D.push(k(E, T.AnyType.create(), false));
          D.push(k(E, T.AnyType.create(), true));
        }
        u.set('get', h.Symbol.createWithType(4, T.OverloadedType.create(D)));
        if (N.length > 0) {
          u.set('pop', h.Symbol.createWithType(4, T.OverloadedType.create(N)));
        }
        if (F.length > 0) {
          u.set('setdefault', h.Symbol.createWithType(4, T.OverloadedType.create(F)));
        }
        if (!d) {
          u.set('__delitem__', h.Symbol.createWithType(4, x(E)));
        }
        u.set('update', h.Symbol.createWithType(4, P()));
        const M = I(e, n);
        if (M) {
          const z = T.FunctionType.createSynthesizedInstance('clear');
          T.FunctionType.addParam(z, f);
          z.shared.declaredReturnType = e.getNoneType();
          u.set('clear', h.Symbol.createWithType(4, z));
          const U = T.FunctionType.createSynthesizedInstance('popitem');
          T.FunctionType.addParam(U, f);
          let V = e.getTupleClassType();
          V = V && T.isInstantiableClass(V) ? v.specializeTupleClass(T.ClassType.cloneAsInstance(V), [{
            type: E,
            isUnbounded: false
          }, {
            type: M,
            isUnbounded: false
          }], true) : T.UnknownType.create();
          U.shared.declaredReturnType = V;
          u.set('popitem', h.Symbol.createWithType(4, U));
        }
        const O = C(e, n);
        if (O) {
          let R = E;
          if (l.extraItems && T.isNever(l.extraItems.valueType)) {
            R = T.combineTypes(Array.from(l.knownItems.keys()).map(e => T.ClassType.cloneWithLiteral(E, e)));
          }
          ['items', 'keys', 'values'].forEach(n => {
            const a = T.FunctionType.createSynthesizedInstance(n);
            T.FunctionType.addParam(a, f);
            const r = e.getTypingType(t, `dict_${n}`);
            if (r && T.isInstantiableClass(r) && r.shared.typeParams.length === 2) {
              a.shared.declaredReturnType = T.ClassType.specialize(T.ClassType.cloneAsInstance(r), [R, O]);
              u.set(n, h.Symbol.createWithType(4, a));
            }
          });
        }
      }
    }
    function _(e, t, n = false) {
      var a;
      if (!t.shared.typedDictEntries) {
        const n = {
          knownItems: new Map(),
          extraItems: undefined
        };
        w(e, t, n);
        if (T.ClassType.isTypedDictMarkedClosed(t) && !n.extraItems) {
          n.extraItems = {
            valueType: T.NeverType.createNever(),
            isReadOnly: false,
            isRequired: false,
            isProvided: false
          };
        }
        t.shared.typedDictEntries = n;
      }
      const r = v.buildSolutionFromSpecializedClass(t);
      const s = new Map();
      t.shared.typedDictEntries.knownItems.forEach((e, n) => {
        const a = {
          ...e
        };
        a.valueType = v.applySolvedTypeVars(a.valueType, r);
        if (t.priv.isTypedDictPartial) {
          a.isRequired = false;
          if (a.isReadOnly) {
            a.valueType = T.NeverType.createNever();
          } else {
            a.isReadOnly = true;
          }
        }
        s.set(n, a);
      });
      if (n && t.priv.typedDictNarrowedEntries) {
        t.priv.typedDictNarrowedEntries.forEach((e, t) => {
          const n = {
            ...e
          };
          n.valueType = v.applySolvedTypeVars(n.valueType, r);
          s.set(t, n);
        });
      }
      return {
        knownItems: s,
        extraItems: (a = t.shared.typedDictEntries) === null || a === undefined ? undefined : a.extraItems
      };
    }
    function C(e, t) {
      o.assert(T.isInstantiableClass(t));
      o.assert(T.ClassType.isTypedDictClass(t));
      if (!T.ClassType.isTypedDictEffectivelyClosed(t)) {
        return;
      }
      const n = _(e, t);
      const a = [];
      n.knownItems.forEach(e => {
        a.push(e.valueType);
      });
      if (n.extraItems) {
        a.push(n.extraItems.valueType);
      }
      const r = T.combineTypes(a);
      if (T.isClassInstance(r) && T.ClassType.isBuiltIn(r, 'object')) {
        return undefined;
      } else {
        return r;
      }
    }
    function I(e, t, n = 0) {
      o.assert(T.isInstantiableClass(t));
      o.assert(T.ClassType.isTypedDictClass(t));
      if (!T.ClassType.isTypedDictEffectivelyClosed(t)) {
        return;
      }
      const a = _(e, t);
      if (!a.extraItems || a.extraItems.isReadOnly) {
        return;
      }
      let r = a.extraItems.valueType;
      let s = true;
      a.knownItems.forEach(t => {
        if (t.isReadOnly || t.isRequired) {
          s = false;
        }
        r = T.combineTypes([r, t.valueType]);
        if (!e.assignType(r, t.valueType, undefined, undefined, 1, n + 1)) {
          s = false;
        }
      });
      if (s) {
        return r;
      } else {
        return undefined;
      }
    }
    function k(e, t, n, a) {
      const r = new Set();
      const s = m.getFileInfo(t);
      t.d.items.forEach(t => {
        if (t.nodeType !== 20) {
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictSecondArgDictEntry(), t);
          return;
        }
        if (t.d.keyExpr.nodeType !== 48) {
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictEntryName(), t.d.keyExpr);
          return;
        }
        const i = t.d.keyExpr.d.strings.map(e => e.d.value).join('');
        if (!i) {
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictEmptyName(), t.d.keyExpr);
          return;
        }
        if (r.has(i)) {
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictEntryUnique(), t.d.keyExpr);
          return;
        }
        r.add(i);
        const o = new h.Symbol(8);
        const l = {
          type: 1,
          node: t.d.keyExpr,
          uri: s.fileUri,
          typeAnnotationNode: t.d.valueExpr,
          isRuntimeTypeExpression: !a,
          range: d.convertOffsetsToRange(t.d.keyExpr.start, c.TextRange.getEnd(t.d.keyExpr), s.lines),
          moduleName: s.moduleName,
          isInExceptSuite: false,
          isInInlinedTypedDict: true
        };
        o.addDeclaration(l);
        n.set(i, o);
      });
      e.setTypeResultForNode(t, {
        type: T.UnknownType.create()
      });
    }
    function w(e, t, n, a = 0) {
      o.assert(T.ClassType.isTypedDictClass(t));
      if (a > T.maxTypeRecursionCount) {
        return;
      }
      a++;
      t.shared.baseClasses.forEach(r => {
        if (T.isInstantiableClass(r) && T.ClassType.isTypedDictClass(r)) {
          const s = v.partiallySpecializeType(r, t, e.getTypeClassType());
          o.assert(T.isClass(s));
          w(e, s, n, a);
        }
      });
      const r = v.buildSolutionFromSpecializedClass(t);
      if (T.ClassType.isTypedDictMarkedClosed(t)) {
        n.extraItems = {
          valueType: T.NeverType.createNever(),
          isReadOnly: false,
          isRequired: false,
          isProvided: false
        };
      } else {
        if (t.shared.typedDictExtraItemsExpr) {
          const a = e.getTypeOfExpressionExpectingType(t.shared.typedDictExtraItemsExpr, {
            allowReadOnly: true
          });
          n.extraItems = {
            valueType: v.convertToInstance(a.type),
            isReadOnly: !!a.isReadOnly,
            isRequired: false,
            isProvided: true
          };
        }
      }
      T.ClassType.getSymbolTable(t).forEach((a, s) => {
        if (!a.isIgnoredForProtocolMatch()) {
          const i = f.getLastTypedDeclarationForSymbol(a);
          if (i && i.type === 1) {
            let i = e.getEffectiveTypeOfSymbol(a);
            i = v.applySolvedTypeVars(i, r);
            let o = !T.ClassType.isCanOmitDictValues(t);
            let l = false;
            if (!function (e, t) {
              return t.getDeclarations().some(t => {
                if (t.type !== 1 || !t.typeAnnotationNode) {
                  return false;
                }
                return !!e.getTypeOfExpressionExpectingType(t.typeAnnotationNode, {
                  allowFinal: true,
                  allowRequired: true,
                  allowReadOnly: true
                }).isRequired;
              });
            }(e, a)) {
              if (function (e, t) {
                return t.getDeclarations().some(t => {
                  if (t.type !== 1 || !t.typeAnnotationNode) {
                    return false;
                  }
                  return !!e.getTypeOfExpressionExpectingType(t.typeAnnotationNode, {
                    allowFinal: true,
                    allowRequired: true,
                    allowReadOnly: true
                  }).isNotRequired;
                });
              }(e, a)) {
                o = false;
              }
            } else {
              o = true;
            }
            if (function (e, t) {
              return t.getDeclarations().some(t => {
                if (t.type !== 1 || !t.typeAnnotationNode) {
                  return false;
                }
                return !!e.getTypeOfExpressionExpectingType(t.typeAnnotationNode, {
                  allowFinal: true,
                  allowRequired: true,
                  allowReadOnly: true
                }).isReadOnly;
              });
            }(e, a)) {
              l = true;
            }
            const p = {
              valueType: i,
              isReadOnly: l,
              isRequired: o,
              isProvided: false
            };
            n.knownItems.set(s, p);
          }
        }
      });
    }
    function S(e, t) {
      var n;
      o.assert(T.ClassType.isTypedDictClass(t));
      if (T.ClassType.isTypedDictMarkedClosed(t)) {
        if ((n = t.shared.typedDictEntries) === null || n === undefined ? undefined : n.extraItems) {
          return t.shared.typedDictEntries.extraItems;
        } else {
          return {
            valueType: T.NeverType.createNever(),
            isReadOnly: true,
            isRequired: false,
            isProvided: false
          };
        }
      } else {
        return {
          valueType: e.getObjectType(),
          isReadOnly: true,
          isRequired: false,
          isProvided: false
        };
      }
    }
  },
  21024: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeVarType = exports.ParamSpecType = exports.TypeVarKind = exports.UnionType = exports.TypeCondition = exports.AnyType = exports.NeverType = exports.OverloadedType = exports.FunctionType = exports.FunctionParam = exports.FunctionParamFlags = exports.ClassType = exports.ModuleType = exports.UnknownType = exports.UnboundType = exports.TypeBase = exports.maxTypeRecursionCount = exports.EnumLiteral = exports.UnificationScopeId = undefined;
    exports.isPositionOnlySeparator = C;
    exports.isKeywordOnlySeparator = I;
    exports.isNever = k;
    exports.isAny = function (e) {
      return e.category === 2;
    };
    exports.isUnknown = w;
    exports.isAnyOrUnknown = S;
    exports.isUnbound = A;
    exports.isUnion = x;
    exports.isPossiblyUnbound = function e(t) {
      if (A(t)) {
        return true;
      }
      if (x(t)) {
        return t.priv.subtypes.find(t => e(t)) !== undefined;
      }
      return false;
    };
    exports.isClass = P;
    exports.isInstantiableClass = D;
    exports.isClassInstance = N;
    exports.isModule = function (e) {
      return e.category === 7;
    };
    exports.isTypeVar = F;
    exports.isParamSpec = E;
    exports.isTypeVarTuple = M;
    exports.isUnpackedTypeVarTuple = O;
    exports.isUnpackedTypeVar = z;
    exports.isUnpackedClass = U;
    exports.isUnpacked = function (e) {
      return O(e) || z(e) || U(e);
    };
    exports.isFunction = V;
    exports.isOverloaded = function (e) {
      return e.category === 5;
    };
    exports.getTypeAliasInfo = function (e) {
      var t;
      var n;
      if ((t = e.props) === null || t === undefined ? undefined : t.typeAliasInfo) {
        return e.props.typeAliasInfo;
      }
      if (F(e) && e.shared.recursiveAlias && e.shared.boundType && ((n = e.shared.boundType.props) === null || n === undefined ? undefined : n.typeAliasInfo)) {
        return e.shared.boundType.props.typeAliasInfo;
      }
      return;
    };
    exports.isTypeSame = R;
    exports.removeUnknownFromUnion = function (e) {
      return L(e, e => w(e));
    };
    exports.removeUnbound = function (e) {
      if (x(e)) {
        return L(e, e => A(e));
      }
      if (A(e)) {
        return l.create();
      }
      return e;
    };
    exports.removeFromUnion = L;
    exports.findSubtype = B;
    exports.combineTypes = j;
    exports.isSameWithoutLiteralValue = q;
    const a = require(58147);
    const r = require(48281);
    exports.UnificationScopeId = '-';
    class s {
      constructor(e, t, n, a, r) {
        this.classFullName = e;
        this.className = t;
        this.itemName = n;
        this.itemType = a;
        this.isReprEnum = r;
      }
      getName() {
        return `${this.classFullName}.${this.itemName}`;
      }
    }
    var i;
    var o;
    var l;
    var p;
    var d;
    var c;
    var u;
    var m;
    var y;
    var g;
    var h;
    var f;
    var T;
    var v;
    var b;
    var _;
    function C(e) {
      return e.category === 0 && !e.name;
    }
    function I(e) {
      return e.category === 1 && !e.name;
    }
    function k(e) {
      return e.category === 3;
    }
    function w(e) {
      return e.category === 1;
    }
    function S(e) {
      return e.category === 2 || e.category === 1 || !!x(e) && e.priv.subtypes.find(e => !S(e)) === undefined;
    }
    function A(e) {
      return e.category === 0;
    }
    function x(e) {
      return e.category === 8;
    }
    function P(e) {
      return e.category === 6;
    }
    function D(e) {
      return e.category === 6 && i.isInstantiable(e);
    }
    function N(e) {
      return e.category === 6 && i.isInstance(e);
    }
    function F(e) {
      return e.category === 9;
    }
    function E(e) {
      return e.category === 9 && e.shared.kind === v.ParamSpec;
    }
    function M(e) {
      return e.category === 9 && e.shared.kind === v.TypeVarTuple;
    }
    function O(e) {
      return M(e) && !!e.priv.isUnpacked && !e.priv.isInUnion;
    }
    function z(e) {
      return F(e) && !M(e) && !!e.priv.isUnpacked;
    }
    function U(e) {
      return !!P(e) && !!e.priv.isUnpacked;
    }
    function V(e) {
      return e.category === 4;
    }
    function R(e, n, a = {}, r = 0) {
      var s;
      var i;
      var o;
      var p;
      var c;
      var u;
      var y;
      var g;
      if (e === n) {
        return true;
      }
      if (e.category !== n.category) {
        if (a.treatAnySameAsUnknown) {
          if (e.category === 2 && n.category === 1) {
            return true;
          }
          if (e.category === 1 && n.category === 2) {
            return true;
          }
        }
        return false;
      }
      if (!a.ignoreTypeFlags && (e.flags & 3) != (n.flags & 3)) {
        return false;
      }
      if (r > exports.maxTypeRecursionCount) {
        return true;
      }
      r++;
      if (a.honorTypeForm) {
        const t = (s = e.props) === null || s === undefined ? undefined : s.typeForm;
        const o = (i = n.props) === null || i === undefined ? undefined : i.typeForm;
        if (t) {
          if (!o) {
            return false;
          }
          if (!R(t, o, a, r)) {
            return false;
          }
        } else {
          if (o) {
            return false;
          }
        }
      }
      switch (e.category) {
        case 6:
          {
            const t = n;
            if (!d.isSameGenericClass(e, t, r)) {
              return false;
            }
            if (!a.ignoreConditions && !f.isSame((o = e.props) === null || o === undefined ? undefined : o.condition, (p = n.props) === null || p === undefined ? undefined : p.condition)) {
              return false;
            }
            if (!a.ignorePseudoGeneric || !d.isPseudoGenericClass(e)) {
              if (e.priv.tupleTypeArgs && t.priv.tupleTypeArgs) {
                const n = e.priv.tupleTypeArgs || [];
                const s = t.priv.tupleTypeArgs || [];
                if (n.length !== s.length) {
                  return false;
                }
                for (let e = 0; e < n.length; e++) {
                  if (!R(n[e].type, s[e].type, {
                    ...a,
                    ignoreTypeFlags: false
                  }, r)) {
                    return false;
                  }
                  if (n[e].isUnbounded !== s[e].isUnbounded) {
                    return false;
                  }
                }
              } else {
                const n = e.priv.typeArgs || [];
                const s = t.priv.typeArgs || [];
                const i = Math.max(n.length, s.length);
                for (let e = 0; e < i; e++) {
                  if (!R(e < n.length ? n[e] : l.create(), e < s.length ? s[e] : l.create(), {
                    ...a,
                    ignoreTypeFlags: false
                  }, r)) {
                    return false;
                  }
                }
              }
            }
            return !!d.isLiteralValueSame(e, t) && !e.priv.isUnpacked == !t.priv.isUnpacked && !e.priv.isTypedDictPartial == !t.priv.isTypedDictPartial && (!a.honorIsTypeArgExplicit || !!e.priv.isTypeArgExplicit == !!t.priv.isTypeArgExplicit) && (!!a.ignoreTypedDictNarrowEntries || !!d.isTypedDictNarrowedEntriesSame(e, t));
          }
        case 4:
          {
            const t = n;
            const s = e.shared.parameters;
            const i = t.shared.parameters;
            if (s.length !== i.length) {
              return false;
            }
            if (m.isGradualCallableForm(e) !== m.isGradualCallableForm(t)) {
              return false;
            }
            const o = s.findIndex(e => C(e));
            const l = i.findIndex(e => C(e));
            for (let n = 0; n < s.length; n++) {
              const p = s[n];
              const d = i[n];
              if (p.category !== d.category) {
                return false;
              }
              const c = o !== undefined && n > o;
              if (c !== (l !== undefined && n > l)) {
                return false;
              }
              if (c) {
                if (p.name !== d.name) {
                  return false;
                }
              } else {
                if (C(p) && C(d)) {
                  continue;
                }
                if (I(p) && I(d)) {
                  continue;
                }
              }
              if (!R(m.getParamType(e, n), m.getParamType(t, n), {
                ...a,
                ignoreTypeFlags: false
              }, r)) {
                return false;
              }
            }
            let p = e.shared.declaredReturnType;
            if (e.priv.specializedTypes && e.priv.specializedTypes.returnType) {
              p = e.priv.specializedTypes.returnType;
            }
            if (!p && e.priv.inferredReturnType) {
              p = e.priv.inferredReturnType;
            }
            let d = t.shared.declaredReturnType;
            if (t.priv.specializedTypes && t.priv.specializedTypes.returnType) {
              d = t.priv.specializedTypes.returnType;
            }
            if (!d && t.priv.inferredReturnType) {
              d = t.priv.inferredReturnType;
            }
            return !p && !d || !!p && !!d && !!R(p, d, {
              ...a,
              ignoreTypeFlags: false
            }, r);
          }
        case 5:
          {
            const t = n;
            if (e.priv._overloads.length !== t.priv._overloads.length) {
              return false;
            }
            for (let n = 0; n < e.priv._overloads.length; n++) {
              if (!R(e.priv._overloads[n], t.priv._overloads[n], a, r)) {
                return false;
              }
            }
            return true;
          }
        case 8:
          {
            const t = n;
            const s = e.priv.subtypes;
            const i = t.priv.subtypes;
            if (s.length !== i.length) {
              return false;
            }
            const o = new Set();
            return B(e, e => !T.containsType(t, e, a, o, r)) === undefined;
          }
        case 9:
          {
            const t = n;
            if (e.priv.scopeId !== t.priv.scopeId) {
              return false;
            }
            if (e.priv.nameWithScope !== t.priv.nameWithScope) {
              return false;
            }
            if (e.shared.recursiveAlias && t.shared.recursiveAlias) {
              const t = ((u = (c = e == null ? undefined : e.props) === null || c === undefined ? undefined : c.typeAliasInfo) === null || u === undefined ? undefined : u.typeArgs) || [];
              const s = ((g = (y = n == null ? undefined : n.props) === null || y === undefined ? undefined : y.typeAliasInfo) === null || g === undefined ? undefined : g.typeArgs) || [];
              const i = Math.max(t.length, s.length);
              for (let e = 0; e < i; e++) {
                if (!R(e < t.length ? t[e] : h.create(), e < s.length ? s[e] : h.create(), {
                  ...a,
                  ignoreTypeFlags: false
                }, r)) {
                  return false;
                }
              }
            }
            if (M(e) && M(t) && !e.priv.isInUnion != !t.priv.isInUnion) {
              return false;
            }
            if (e.shared === t.shared) {
              return true;
            }
            if (E(e) !== E(t)) {
              return false;
            }
            if (M(e) !== M(t)) {
              return false;
            }
            if (e.shared.name !== t.shared.name || e.shared.isSynthesized !== t.shared.isSynthesized || e.shared.declaredVariance !== t.shared.declaredVariance || e.priv.scopeId !== t.priv.scopeId) {
              return false;
            }
            const s = e.shared.boundType;
            const i = t.shared.boundType;
            if (s) {
              if (!i || !R(s, i, {
                ...a,
                ignoreTypeFlags: false
              }, r)) {
                return false;
              }
            } else {
              if (i) {
                return false;
              }
            }
            const o = e.shared.constraints;
            const l = t.shared.constraints;
            if (o.length !== l.length) {
              return false;
            }
            for (let e = 0; e < o.length; e++) {
              if (!R(o[e], l[e], {
                ...a,
                ignoreTypeFlags: false
              }, r)) {
                return false;
              }
            }
            return true;
          }
        case 7:
          {
            const t = n;
            return e.priv.fields === t.priv.fields || e.priv.fields.size === 0 && t.priv.fields.size === 0;
          }
        case 1:
          {
            const t = n;
            return e.priv.isIncomplete === t.priv.isIncomplete;
          }
      }
      return true;
    }
    function L(e, t) {
      if (x(e)) {
        const n = e.priv.subtypes.filter(e => !t(e));
        if (n.length < e.priv.subtypes.length) {
          const t = j(n);
          if (x(t)) {
            T.addTypeAliasSource(t, e);
          }
          return t;
        }
      }
      return e;
    }
    function B(e, t) {
      if (x(e)) {
        return e.priv.subtypes.find(e => t(e));
      } else {
        if (t(e)) {
          return e;
        } else {
          return undefined;
        }
      }
    }
    function j(e, t) {
      var n;
      var r;
      let s;
      [s, e] = a.partition(e, k);
      if (e.length === 0) {
        if (s.length > 0) {
          if ((n = s.find(e => e.priv.isNoReturn)) !== null && n !== undefined) {
            return n;
          } else {
            return s[0];
          }
        } else {
          return g.createNever();
        }
      }
      let i;
      let o = true;
      if (e.length > 1) {
        for (let t = 1; t < e.length; t++) {
          if (e[t] !== e[0]) {
            o = false;
            break;
          }
        }
      }
      if (o) {
        return e[0];
      }
      const p = new Set();
      for (let t = 0; t < e.length; t++) {
        const n = e[t];
        if (x(n)) {
          if (!i) {
            i = e.slice(0, t);
          }
          i = i.concat(n.priv.subtypes);
          if ((r = n.props) === null || r === undefined ? undefined : r.typeAliasInfo) {
            p.add(n);
          } else {
            if (n.priv.typeAliasSources) {
              n.priv.typeAliasSources.forEach(e => {
                p.add(e);
              });
            }
          }
        } else {
          if (i) {
            i.push(n);
          }
        }
      }
      i = i ?? e;
      i = i.sort((e, t) => P(e) && e.priv.literalValue !== undefined ? 1 : P(t) && t.priv.literalValue !== undefined ? -1 : N(e) && e.priv.isEmptyContainer ? 1 : N(t) && t.priv.isEmptyContainer ? -1 : 0);
      if (i.length === 0) {
        return l.create();
      }
      const c = T.create();
      if (p.size > 0) {
        c.priv.typeAliasSources = p;
      }
      let u = false;
      i.forEach((e, n) => {
        if (n === 0) {
          T.addType(c, e);
        } else {
          if ((t == null ? undefined : t.maxSubtypeCount) === undefined || c.priv.subtypes.length < t.maxSubtypeCount) {
            (function (e, t, n) {
              var a;
              var r;
              var s;
              if (P(t) && !((a = t.props) === null || a === undefined ? undefined : a.condition)) {
                const n = N(t) ? e.priv.literalInstances : e.priv.literalClasses;
                if (d.isBuiltIn(t, 'str') && t.priv.literalValue !== undefined && n.literalStrMap !== undefined) {
                  if (!n.literalStrMap.has(t.priv.literalValue)) {
                    T.addType(e, t);
                  }
                  return;
                }
                if (d.isBuiltIn(t, 'int') && t.priv.literalValue !== undefined && n.literalIntMap !== undefined) {
                  if (!n.literalIntMap.has(t.priv.literalValue)) {
                    T.addType(e, t);
                  }
                  return;
                }
                if (d.isEnumClass(t) && t.priv.literalValue !== undefined && n.literalEnumMap !== undefined) {
                  const a = t.priv.literalValue;
                  if (!n.literalEnumMap.has(a.getName())) {
                    T.addType(e, t);
                  }
                  return;
                }
              }
              const i = P(t) && d.isPseudoGenericClass(t);
              for (let a = 0; a < e.priv.subtypes.length; a++) {
                const o = e.priv.subtypes[a];
                if (R(o, t, {
                  honorTypeForm: true
                })) {
                  return;
                }
                if (i && R(o, t, {
                  ignorePseudoGeneric: true,
                  honorTypeForm: true
                })) {
                  e.priv.subtypes[a] = d.specialize(t, t.shared.typeParams.map(() => l.create()));
                  return;
                }
                if (N(o) && N(t)) {
                  if (n && q(o, t) && o.priv.literalValue === undefined) {
                    return;
                  }
                  if (d.isBuiltIn(o, 'bool') && !((r = o.props) === null || r === undefined ? undefined : r.condition) && d.isBuiltIn(t, 'bool') && !((s = t.props) === null || s === undefined ? undefined : s.condition) && t.priv.literalValue !== undefined && !t.priv.literalValue === o.priv.literalValue) {
                    e.priv.subtypes[a] = d.cloneWithLiteral(o, undefined);
                    return;
                  }
                  if (d.isTypedDictClass(o) && d.isSameGenericClass(o, t) && !o.priv.typeArgs && !t.priv.typeArgs) {
                    if (d.isTypedDictNarrower(t, o)) {
                      return;
                    }
                    if (d.isTypedDictNarrower(o, t)) {
                      e.priv.subtypes[a] = t;
                      return;
                    }
                  }
                }
                if (N(t) && t.priv.isEmptyContainer && N(o) && d.isSameGenericClass(o, t)) {
                  return;
                }
              }
              T.addType(e, t);
            })(c, e, !(t == null ? undefined : t.skipElideRedundantLiterals));
          } else {
            u = true;
          }
        }
      });
      if (u) {
        return h.create();
      } else {
        if (c.priv.subtypes.length === 1) {
          return c.priv.subtypes[0];
        } else {
          return c;
        }
      }
    }
    function q(e, t) {
      return !!R(e, t) || (D(t) && t.priv.literalValue !== undefined ? R(e, t = d.cloneWithLiteral(t, undefined)) : !!N(t) && t.priv.literalValue !== undefined && R(e, t = d.cloneWithLiteral(t, undefined), {
        ignoreConditions: true
      }));
    }
    exports.EnumLiteral = s;
    exports.maxTypeRecursionCount = 20;
    (function (e) {
      function t(e) {
        const t = {
          ...e
        };
        if (e.props) {
          t.props = {
            ...e.props
          };
        }
        if (e.priv) {
          t.priv = {
            ...e.priv
          };
        }
        t.cached = undefined;
        return t;
      }
      e.isInstantiable = function (e) {
        return !!(e.flags & 1);
      };
      e.isInstance = function (e) {
        return !!(e.flags & 2);
      };
      e.isAmbiguous = function (e) {
        return !!(e.flags & 4);
      };
      e.addProps = function (e) {
        if (!e.props) {
          e.props = {
            instantiableDepth: undefined,
            specialForm: undefined,
            typeForm: undefined,
            typeAliasInfo: undefined,
            condition: undefined
          };
        }
        return e.props;
      };
      e.getInstantiableDepth = function (e) {
        var t;
        var n;
        if ((n = (t = e.props) === null || t === undefined ? undefined : t.instantiableDepth) !== null && n !== undefined) {
          return n;
        } else {
          return 0;
        }
      };
      e.setSpecialForm = function (t, n) {
        e.addProps(t).specialForm = n;
      };
      e.setInstantiableDepth = function (t, n) {
        e.addProps(t).instantiableDepth = n;
      };
      e.setTypeAliasInfo = function (t, n) {
        e.addProps(t).typeAliasInfo = n;
      };
      e.setTypeForm = function (t, n) {
        e.addProps(t).typeForm = n;
      };
      e.setCondition = function (t, n) {
        e.addProps(t).condition = n;
      };
      e.cloneType = t;
      e.cloneAsSpecialForm = function (t, n) {
        const a = e.cloneType(t);
        e.setSpecialForm(a, n);
        return a;
      };
      e.cloneTypeAsInstance = function (t, n) {
        var a;
        var s;
        r.assert(e.isInstantiable(t));
        const i = e.cloneType(t);
        if ((a = i.props) === null || a === undefined ? undefined : a.typeForm) {
          e.setTypeForm(i, undefined);
        }
        const o = (s = i.props) === null || s === undefined ? undefined : s.instantiableDepth;
        if (o === undefined) {
          i.flags &= -2;
          i.flags |= 2;
        } else {
          if (o <= 1) {
            e.setInstantiableDepth(i, undefined);
          } else {
            e.setInstantiableDepth(i, o - 1);
          }
        }
        if (n) {
          if (!t.cached) {
            t.cached = {};
          }
          t.cached.typeBaseInstanceType = i;
        }
        return i;
      };
      e.cloneTypeAsInstantiable = function (t, n) {
        var a;
        var r;
        var s;
        const i = e.cloneType(t);
        if (e.isInstance(t)) {
          i.flags &= -3;
          i.flags |= 1;
        } else {
          const n = (a = t.props) === null || a === undefined ? undefined : a.instantiableDepth;
          e.setInstantiableDepth(i, n === undefined ? 1 : n + 1);
        }
        if ((r = i.props) === null || r === undefined ? undefined : r.typeAliasInfo) {
          e.setTypeAliasInfo(i, undefined);
        }
        if ((s = i.props) === null || s === undefined ? undefined : s.typeForm) {
          e.setTypeForm(i, undefined);
        }
        if (n) {
          if (!t.cached) {
            t.cached = {};
          }
          t.cached.typeBaseInstantiableType = i;
        }
        return i;
      };
      e.cloneForTypeAlias = function (n, a) {
        const r = t(n);
        e.setTypeAliasInfo(r, a);
        return r;
      };
      e.cloneWithTypeForm = function (n, a) {
        const r = t(n);
        e.setTypeForm(r, a);
        return r;
      };
      e.cloneForCondition = function (n, a) {
        var r;
        if (((r = n.props) === null || r === undefined ? undefined : r.condition) === undefined && a === undefined) {
          return n;
        }
        const s = t(n);
        e.setCondition(s, a);
        return s;
      };
      e.cloneForAmbiguousType = function (n) {
        if (e.isAmbiguous(n)) {
          return n;
        }
        const a = t(n);
        a.flags |= 4;
        return a;
      };
    })(i || (exports.TypeBase = i = {}));
    (function (e) {
      const t = {
        category: 0,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: undefined
      };
      e.create = function () {
        return t;
      };
      e.convertToInstance = function (t) {
        var n;
        if ((n = t.props) === null || n === undefined ? undefined : n.specialForm) {
          return e.create();
        } else {
          return t;
        }
      };
    })(o || (exports.UnboundType = o = {}));
    (function (e) {
      const t = {
        category: 1,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isIncomplete: false,
          possibleType: undefined
        }
      };
      const n = {
        category: 1,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isIncomplete: true,
          possibleType: undefined
        }
      };
      e.create = function (e = false) {
        if (e) {
          return n;
        } else {
          return t;
        }
      };
      e.createPossibleType = function (e, t) {
        return {
          category: 1,
          flags: 3,
          props: undefined,
          cached: undefined,
          shared: undefined,
          priv: {
            isIncomplete: t,
            possibleType: e
          }
        };
      };
      e.convertToInstance = function (t) {
        var n;
        if ((n = t.props) === null || n === undefined ? undefined : n.specialForm) {
          return e.create(t.priv.isIncomplete);
        } else {
          return t;
        }
      };
    })(l || (exports.UnknownType = l = {}));
    (function (e) {
      e.create = function (e, t, n) {
        return {
          category: 7,
          flags: 1,
          props: undefined,
          cached: undefined,
          shared: undefined,
          priv: {
            fields: n || new Map(),
            docString: undefined,
            notPresentFieldType: undefined,
            loaderFields: new Map(),
            moduleName: e,
            fileUri: t
          }
        };
      };
      e.getField = function (e, t) {
        let n = e.priv.fields.get(t);
        if (e.priv.loaderFields) {
          if (n) {
            if (n.getDeclarations().length === 1) {
              const a = e.priv.loaderFields.get(t);
              if (a && !a.isExternallyHidden()) {
                n = a;
              }
            }
          } else {
            n = e.priv.loaderFields.get(t);
          }
        }
        return n;
      };
    })(p || (exports.ModuleType = p = {}));
    (function (e) {
      function n(e, t) {
        if (!(e.shared.flags & 1)) {
          return false;
        }
        if (t !== undefined) {
          return (Array.isArray(t) ? t : [t]).some(t => t === e.shared.name || t === e.shared.fullName || t === e.priv.aliasName);
        }
        return true;
      }
      function a(n, a, r = 0) {
        if (!n.priv.isTypedDictPartial != !a.priv.isTypedDictPartial) {
          return false;
        }
        if (i.isInstance(n) !== i.isInstance(a)) {
          return false;
        }
        if (i.getInstantiableDepth(n) !== i.getInstantiableDepth(a)) {
          return false;
        }
        const s = n.shared;
        const o = a.shared;
        if (s === o) {
          return true;
        }
        if (s.fullName !== o.fullName || s.flags !== o.flags || s.typeSourceId !== o.typeSourceId || s.baseClasses.length !== o.baseClasses.length || s.typeParams.length !== o.typeParams.length) {
          return false;
        }
        if (r > exports.maxTypeRecursionCount) {
          return true;
        }
        r++;
        if (e.isBuiltIn(n, 'NamedTuple') && e.isBuiltIn(a, 'NamedTuple')) {
          return true;
        }
        if (e.isBuiltIn(n, 'tuple') && e.isBuiltIn(a, 'tuple')) {
          return true;
        }
        for (let e = 0; e < s.baseClasses.length; e++) {
          if (!R(s.baseClasses[e], o.baseClasses[e], {
            ignorePseudoGeneric: true
          }, r)) {
            return false;
          }
        }
        if ((s.declaredMetaclass || o.declaredMetaclass) && (!s.declaredMetaclass || !o.declaredMetaclass || !R(s.declaredMetaclass, o.declaredMetaclass, {
          ignorePseudoGeneric: true
        }, r))) {
          return false;
        }
        for (let e = 0; e < s.typeParams.length; e++) {
          if (!R(s.typeParams[e], o.typeParams[e], {
            ignorePseudoGeneric: true
          }, r)) {
            return false;
          }
        }
        return true;
      }
      e.createInstantiable = function (e, t, n, a, r, s, i, o, l) {
        return {
          category: 6,
          flags: 1,
          props: undefined,
          cached: undefined,
          shared: {
            name: e,
            fullName: t,
            moduleName: n,
            fileUri: a,
            flags: r,
            typeSourceId: s,
            baseClasses: [],
            declaredMetaclass: i,
            effectiveMetaclass: o,
            mro: [],
            fields: new Map(),
            typeParams: [],
            docString: l
          },
          priv: {}
        };
      };
      e.cloneAsInstance = function (e, t = true) {
        var n;
        var a;
        if (i.isInstance(e)) {
          return e;
        }
        if (t && ((n = e.cached) === null || n === undefined ? undefined : n.typeBaseInstanceType)) {
          return e.cached.typeBaseInstanceType;
        }
        const r = i.cloneTypeAsInstance(e, t);
        if ((a = r.props) === null || a === undefined ? undefined : a.specialForm) {
          i.setSpecialForm(r, undefined);
        }
        if (t) {
          r.priv.includeSubclasses = true;
        }
        return r;
      };
      e.cloneAsInstantiable = function (e, t = true) {
        var n;
        if (t && ((n = e.cached) === null || n === undefined ? undefined : n.typeBaseInstantiableType)) {
          return e.cached.typeBaseInstantiableType;
        }
        const a = i.cloneTypeAsInstantiable(e, t);
        if (t) {
          a.priv.includeSubclasses = true;
        }
        return a;
      };
      e.specialize = function (e, t, n, a = false, r, s) {
        const o = i.cloneType(e);
        o.priv.typeArgs = (t == null ? undefined : t.length) === 0 ? undefined : t;
        if (n === undefined) {
          n = !!t;
        }
        o.priv.isTypeArgExplicit = n;
        if (a) {
          o.priv.includeSubclasses = true;
        }
        o.priv.tupleTypeArgs = r ? [...r] : undefined;
        if (s !== undefined) {
          o.priv.isEmptyContainer = s;
        }
        return o;
      };
      e.cloneIncludeSubclasses = function (e, t = true) {
        if (!!e.priv.includeSubclasses === t) {
          return e;
        }
        const n = i.cloneType(e);
        n.priv.includeSubclasses = t;
        return n;
      };
      e.cloneWithLiteral = function (e, t) {
        var n;
        const a = i.cloneType(e);
        a.priv.literalValue = t;
        if ((n = a.props) === null || n === undefined ? undefined : n.typeAliasInfo) {
          i.setTypeAliasInfo(a, undefined);
        }
        return a;
      };
      e.cloneForDeprecatedInstance = function (e, t) {
        const n = i.cloneType(e);
        n.priv.deprecatedInstanceMessage = t;
        return n;
      };
      e.cloneForTypingAlias = function (e, t) {
        const n = i.cloneType(e);
        n.priv.aliasName = t;
        return n;
      };
      e.cloneForNarrowedTypedDictEntries = function (e, t) {
        const n = i.cloneType(e);
        n.priv.typedDictNarrowedEntries = t;
        return n;
      };
      e.cloneForPartialTypedDict = function (e) {
        const t = i.cloneType(e);
        t.priv.isTypedDictPartial = true;
        return t;
      };
      e.cloneRemoveTypePromotions = function (e) {
        if (!e.priv.includePromotions) {
          return e;
        }
        const t = i.cloneType(e);
        if (t.priv.includePromotions !== undefined) {
          t.priv.includePromotions = undefined;
        }
        return t;
      };
      e.cloneForPartial = function (e, t) {
        const n = i.cloneType(e);
        n.priv.partialCallType = t;
        return n;
      };
      e.cloneForUnpacked = function (e) {
        if (e.priv.isUnpacked) {
          return e;
        }
        const t = i.cloneType(e);
        t.priv.isUnpacked = true;
        return t;
      };
      e.cloneForPacked = function (e) {
        if (!e.priv.isUnpacked) {
          return e;
        }
        const t = i.cloneType(e);
        t.priv.isUnpacked = false;
        return t;
      };
      e.cloneWithNewFlags = function (e, t) {
        const n = i.cloneType(e);
        n.shared = {
          ...n.shared
        };
        n.shared.flags = t;
        return n;
      };
      e.isLiteralValueSame = function (e, t) {
        if (e.priv.literalValue === undefined) {
          return t.priv.literalValue === undefined;
        } else {
          return t.priv.literalValue !== undefined && (e.priv.literalValue instanceof s ? t.priv.literalValue instanceof s && e.priv.literalValue.itemName === t.priv.literalValue.itemName : e.priv.literalValue === t.priv.literalValue);
        }
      };
      e.isTypedDictNarrowedEntriesSame = function (e, t) {
        if (e.priv.typedDictNarrowedEntries) {
          if (!t.priv.typedDictNarrowedEntries) {
            return false;
          }
          const n = e.priv.typedDictNarrowedEntries;
          const a = t.priv.typedDictNarrowedEntries;
          if (n.size !== a.size) {
            return false;
          }
          let r;
          let s;
          for ([r, s] of n.entries()) {
            const e = a.get(r);
            if (!e) {
              return false;
            }
            if (s.isProvided !== e.isProvided) {
              return false;
            }
          }
        } else {
          if (t.priv.typedDictNarrowedEntries) {
            return false;
          }
        }
        return true;
      };
      e.isTypedDictNarrower = function (e, t) {
        var n;
        const a = t.priv.typedDictNarrowedEntries;
        if (!a) {
          return true;
        }
        const r = (n = e.priv.typedDictNarrowedEntries) !== null && n !== undefined ? n : new Map();
        let s;
        let i;
        for ([s, i] of a.entries()) {
          if (i.isProvided) {
            const e = r.get(s);
            if (!(e == null ? undefined : e.isProvided)) {
              return false;
            }
          }
        }
        return true;
      };
      e.isUnspecialized = function (e) {
        return e.shared.typeParams.length > 0 && e.priv.typeArgs === undefined;
      };
      e.isSpecialBuiltIn = function (e, t) {
        return (!!(e.shared.flags & 2) || !!e.priv.aliasName) && (t === undefined || e.shared.name === t);
      };
      e.isBuiltIn = n;
      e.supportsAbstractMethods = function (e) {
        return !!(e.shared.flags & 64);
      };
      e.isDataClass = function (e) {
        return !!e.shared.dataClassBehaviors;
      };
      e.isDataClassSkipGenerateInit = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.skipGenerateInit);
      };
      e.isDataClassSkipGenerateEq = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.skipGenerateEq);
      };
      e.isDataClassFrozen = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.frozen);
      };
      e.isDataClassGenerateOrder = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.generateOrder);
      };
      e.isDataClassKeywordOnly = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.keywordOnly);
      };
      e.isDataClassGenerateSlots = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.generateSlots);
      };
      e.isDataClassGenerateHash = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.generateHash);
      };
      e.isTypeCheckOnly = function (e) {
        return !!(e.shared.flags & 1048576);
      };
      e.isNewTypeClass = function (e) {
        return !!(e.shared.flags & 2097152);
      };
      e.isValidTypeAliasClass = function (e) {
        return !!(e.shared.flags & 4194304);
      };
      e.isSpecialFormClass = function (e) {
        return !!(e.shared.flags & 8388608);
      };
      e.isIllegalIsinstanceClass = function (e) {
        return !!(e.shared.flags & 16777216);
      };
      e.isTypedDictClass = function (e) {
        return !!(e.shared.flags & 4);
      };
      e.isCanOmitDictValues = function (e) {
        return !!(e.shared.flags & 32);
      };
      e.isTypedDictMarkedClosed = function (e) {
        return !!(e.shared.flags & 8);
      };
      e.isTypedDictEffectivelyClosed = function (e) {
        return !!(e.shared.flags & 16);
      };
      e.isEnumClass = function (e) {
        return !!(e.shared.flags & 65536);
      };
      e.isPropertyClass = function (e) {
        return !!(e.shared.flags & 128);
      };
      e.isClassProperty = function (e) {
        return !!(e.shared.flags & 131072);
      };
      e.isFinal = function (e) {
        return !!(e.shared.flags & 256);
      };
      e.isProtocolClass = function (e) {
        return !!(e.shared.flags & 512);
      };
      e.isDefinedInStub = function (e) {
        return !!(e.shared.flags & 262144);
      };
      e.isPseudoGenericClass = function (e) {
        return !!(e.shared.flags & 1024);
      };
      e.getDataClassEntries = function (e) {
        var t;
        var n;
        if ((n = (t = e.shared).synthesizeMethodsDeferred) !== null && n !== undefined) {
          n.call(t);
        }
        return e.shared.dataClassEntries || [];
      };
      e.isRuntimeCheckable = function (e) {
        return !!(e.shared.flags & 2048);
      };
      e.isTypingExtensionClass = function (e) {
        return !!(e.shared.flags & 4096);
      };
      e.isPartiallyEvaluated = function (e) {
        return !!(e.shared.flags & 8192);
      };
      e.hasCustomClassGetItem = function (e) {
        return !!(e.shared.flags & 16384);
      };
      e.isTupleClass = function (e) {
        return !!(e.shared.flags & 32768);
      };
      e.getTypeParams = function (e) {
        return e.shared.typeParams;
      };
      e.derivesFromAnyOrUnknown = function (e) {
        return e.shared.mro.some(e => S(e));
      };
      e.getSymbolTable = function (e) {
        var t;
        var n;
        if ((n = (t = e.shared).synthesizeMethodsDeferred) !== null && n !== undefined) {
          n.call(t);
        }
        return e.shared.fields;
      };
      e.getInheritedSlotsNames = function (e) {
        var t;
        var n;
        var a;
        var r;
        if ((n = (t = e.shared).synthesizeMethodsDeferred) !== null && n !== undefined) {
          n.call(t);
        }
        if ((r = (a = e.shared).calculateInheritedSlotsNamesDeferred) !== null && r !== undefined) {
          r.call(a);
        }
        return e.shared.inheritedSlotsNamesCached;
      };
      e.isHierarchyPartiallyEvaluated = function (t) {
        return e.isPartiallyEvaluated(t) || t.shared.mro.some(t => P(t) && e.isPartiallyEvaluated(t));
      };
      e.hasNamedTupleEntry = function (e, t) {
        return !!e.shared.namedTupleEntries && e.shared.namedTupleEntries.has(t);
      };
      e.isSameGenericClass = a;
      e.isDerivedFrom = function t(r, s, i) {
        if (a(r, s)) {
          return (s.priv.literalValue === undefined || r.priv.literalValue !== undefined && !!e.isLiteralValueSame(s, r)) && (i && i.push(r), true);
        }
        if (n(r) && n(s, 'object')) {
          if (i) {
            i.push(s);
          }
          return true;
        }
        if (e.isBuiltIn(r, 'property') && e.isBuiltIn(s, 'property')) {
          if (i) {
            i.push(r);
          }
          return true;
        }
        for (const e of r.shared.baseClasses) {
          if (D(e)) {
            if (t(e, s, i)) {
              if (i) {
                i.push(r);
              }
              return true;
            }
          } else {
            if (S(e)) {
              if (i) {
                i.push(l.create());
              }
              return true;
            }
          }
        }
        return false;
      };
      e.getReverseMro = function (e) {
        return e.shared.mro.slice(0).reverse();
      };
    })(d || (exports.ClassType = d = {}));
    (function (e) {
      e[e.None = 0] = 'None';
      e[e.NameSynthesized = 1] = 'NameSynthesized';
      e[e.TypeDeclared = 2] = 'TypeDeclared';
      e[e.TypeInferred = 4] = 'TypeInferred';
    })(c || (exports.FunctionParamFlags = c = {}));
    (function (e) {
      e.create = function (e, t, n = c.None, a, r, s) {
        return {
          category: e,
          flags: n,
          name: a,
          _type: t,
          _defaultType: r,
          defaultExpr: s
        };
      };
      e.isNameSynthesized = function (e) {
        return !!(e.flags & c.NameSynthesized);
      };
      e.isTypeDeclared = function (e) {
        return !!(e.flags & c.TypeDeclared);
      };
      e.isTypeInferred = function (e) {
        return !!(e.flags & c.TypeInferred);
      };
    })(u || (exports.FunctionParam = u = {}));
    (function (e) {
      function t(e, t, n, a, r, s) {
        return {
          category: 4,
          flags: r,
          props: undefined,
          cached: undefined,
          shared: {
            name: e,
            fullName: t,
            moduleName: n,
            flags: a,
            typeParams: [],
            parameters: [],
            declaredReturnType: undefined,
            declaration: undefined,
            typeVarScopeId: undefined,
            docString: s,
            deprecatedMessage: undefined,
            methodClass: undefined,
            decoratorDataClassBehaviors: undefined
          },
          priv: {}
        };
      }
      function n(e = false) {
        return [u.create(1, e ? l.create() : h.create(), e ? c.None : c.TypeDeclared, 'args'), u.create(2, e ? l.create() : h.create(), e ? c.None : c.TypeDeclared, 'kwargs')];
      }
      function a(e, t) {
        r.assert(t < e.shared.parameters.length, 'Parameter types array overflow');
        if (e.priv.specializedTypes && t < e.priv.specializedTypes.parameterTypes.length) {
          return e.priv.specializedTypes.parameterTypes[t];
        } else {
          return e.shared.parameters[t]._type;
        }
      }
      function s(e, t) {
        e.shared.parameters.push(t);
        if (e.priv.specializedTypes) {
          e.priv.specializedTypes.parameterTypes.push(t._type);
        }
      }
      e.createInstance = function (e, n, a, r, s) {
        return t(e, n, a, r, 2, s);
      };
      e.createInstantiable = function (e, n) {
        return t('', '', '', e, 1, n);
      };
      e.createSynthesizedInstance = function (e, n = 0) {
        return t(e, '', '', n | 64, 2);
      };
      e.clone = function (e, t = false, n) {
        var r;
        var s;
        const o = i.cloneType(e);
        o.shared = {
          ...e.shared
        };
        o.priv.preBoundFlags = o.shared.flags;
        o.priv.boundToType = n;
        if (n) {
          if (e.shared.name === '__new__' || e.shared.name === '__init__') {
            o.priv.constructorTypeVarScopeId = n.shared.typeVarScopeId;
          }
        }
        if (t) {
          if (e.shared.parameters.length > 0) {
            if (e.shared.parameters[0].category === 0) {
              if (e.shared.parameters.length > 0 && !u.isTypeInferred(e.shared.parameters[0])) {
                o.priv.strippedFirstParamType = a(e, 0);
              }
              o.shared.parameters = e.shared.parameters.slice(1);
            }
          } else {
            t = false;
          }
          o.shared.flags &= -4;
          o.shared.flags |= 4;
        }
        if ((r = e.props) === null || r === undefined ? undefined : r.typeAliasInfo) {
          i.setTypeAliasInfo(o, e.props.typeAliasInfo);
        }
        if (e.priv.specializedTypes) {
          o.priv.specializedTypes = {
            parameterTypes: t ? e.priv.specializedTypes.parameterTypes.slice(1) : e.priv.specializedTypes.parameterTypes,
            parameterDefaultTypes: t ? (s = e.priv.specializedTypes.parameterDefaultTypes) === null || s === undefined ? undefined : s.slice(1) : e.priv.specializedTypes.parameterDefaultTypes,
            returnType: e.priv.specializedTypes.returnType
          };
        }
        o.priv.inferredReturnType = e.priv.inferredReturnType;
        return o;
      };
      e.cloneAsInstance = function (e) {
        var t;
        var n;
        if ((t = e.cached) === null || t === undefined ? undefined : t.typeBaseInstanceType) {
          return e.cached.typeBaseInstanceType;
        }
        const a = i.cloneTypeAsInstance(e, true);
        if ((n = a.props) === null || n === undefined ? undefined : n.specialForm) {
          i.setSpecialForm(a, undefined);
        }
        return a;
      };
      e.cloneAsInstantiable = function (e) {
        var t;
        if ((t = e.cached) === null || t === undefined ? undefined : t.typeBaseInstantiableType) {
          return e.cached.typeBaseInstantiableType;
        } else {
          return i.cloneTypeAsInstantiable(e, true);
        }
      };
      e.specialize = function (e, t, n) {
        const a = i.cloneType(e);
        r.assert(t.parameterTypes.length === e.shared.parameters.length);
        if (t.parameterDefaultTypes) {
          r.assert(t.parameterDefaultTypes.length === e.shared.parameters.length);
        }
        a.priv.specializedTypes = t;
        a.priv.inferredReturnType = n;
        return a;
      };
      e.applyParamSpecValue = function (t, n) {
        const a = n.shared.parameters.some(e => C(e));
        const s = e.cloneRemoveParamSpecArgsKwargs(i.cloneType(t), a);
        const o = e.getParamSpecFromArgsKwargs(t);
        r.assert(o !== undefined);
        s.shared = {
          ...s.shared
        };
        s.shared.typeParams = s.shared.typeParams.filter(e => !R(e, o));
        const l = Array.from(s.shared.parameters);
        s.shared.parameters = [...l, ...n.shared.parameters.map((t, a) => u.create(t.category, e.getParamType(n, a), t.flags & c.NameSynthesized | c.TypeDeclared, t.name, e.getParamDefaultType(n, a), t.defaultExpr))];
        if (s.shared.docString === undefined) {
          s.shared.docString = n.shared.docString;
        }
        if (s.shared.deprecatedMessage === undefined) {
          s.shared.deprecatedMessage = n.shared.deprecatedMessage;
        }
        s.shared.flags = t.shared.flags & 65792;
        if (t.shared.methodClass) {
          s.shared.flags |= t.shared.flags & 7;
        } else {
          s.shared.flags |= n.shared.flags & 7;
        }
        s.shared.flags |= n.shared.flags & 32768;
        s.shared.flags |= 64;
        if (s.shared.declaration) {
          s.shared.declaration = undefined;
        }
        const p = s.priv.specializedTypes;
        if (p) {
          n.shared.parameters.forEach((t, a) => {
            var r;
            p.parameterTypes.push(e.getParamType(n, a));
            if (p.parameterDefaultTypes) {
              if ((r = p.parameterDefaultTypes) !== null && r !== undefined) {
                r.push(e.getParamDefaultType(n, a));
              }
            }
          });
        }
        s.priv.constructorTypeVarScopeId = n.priv.constructorTypeVarScopeId;
        if (!s.shared.methodClass && n.shared.methodClass) {
          s.shared.methodClass = n.shared.methodClass;
        }
        return s;
      };
      e.cloneWithNewFlags = function (e, t) {
        const n = i.cloneType(e);
        n.shared = {
          ...e.shared
        };
        n.shared.flags = t;
        return n;
      };
      e.cloneWithNewTypeVarScopeId = function (e, t, n, a) {
        const r = i.cloneType(e);
        r.shared = {
          ...e.shared
        };
        r.shared.typeVarScopeId = t;
        r.priv.constructorTypeVarScopeId = n;
        r.shared.typeParams = a;
        return r;
      };
      e.cloneWithDocString = function (e, t) {
        const n = i.cloneType(e);
        n.shared = {
          ...e.shared
        };
        n.shared.docString = t;
        return n;
      };
      e.cloneWithDeprecatedMessage = function (e, t) {
        const n = i.cloneType(e);
        n.shared = {
          ...e.shared
        };
        n.shared.deprecatedMessage = t;
        return n;
      };
      e.cloneRemoveParamSpecArgsKwargs = function (t, n = false) {
        const a = t.shared.parameters.length;
        if (a < 2) {
          return t;
        }
        const r = t.shared.parameters[a - 2];
        const s = t.shared.parameters[a - 1];
        if (r.category !== 1 || s.category !== 2) {
          return t;
        }
        const o = e.getParamType(t, a - 2);
        const l = e.getParamType(t, a - 1);
        if (!E(o) || !E(l) || !R(o, l)) {
          return t;
        }
        const p = i.cloneType(t);
        p.shared = {
          ...t.shared
        };
        const d = p.shared;
        let c = 2;
        if (a >= 3 && C(d.parameters[a - 3]) && (a === 3 || n)) {
          c = 3;
        }
        d.parameters = d.parameters.slice(0, d.parameters.length - c);
        if (t.priv.specializedTypes) {
          p.priv.specializedTypes = {
            ...t.priv.specializedTypes
          };
          p.priv.specializedTypes.parameterTypes = p.priv.specializedTypes.parameterTypes.slice(0, p.priv.specializedTypes.parameterTypes.length - c);
          if (p.priv.specializedTypes.parameterDefaultTypes) {
            p.priv.specializedTypes.parameterDefaultTypes = p.priv.specializedTypes.parameterDefaultTypes.slice(0, p.priv.specializedTypes.parameterDefaultTypes.length - c);
          }
        }
        if (t.priv.inferredReturnType) {
          p.priv.inferredReturnType = t.priv.inferredReturnType;
        }
        return p;
      };
      e.getParamSpecFromArgsKwargs = function (t) {
        const n = t.shared.parameters;
        if (n.length < 2) {
          return;
        }
        const a = n[n.length - 2];
        const r = e.getParamType(t, n.length - 2);
        const s = n[n.length - 1];
        const i = e.getParamType(t, n.length - 1);
        if (a.category === 1 && E(r) && r.priv.paramSpecAccess === 'args' && s.category === 2 && E(i) && i.priv.paramSpecAccess === 'kwargs') {
          return _.cloneForParamSpecAccess(r, undefined);
        } else {
          return undefined;
        }
      };
      e.addParamSpecVariadics = function (t, n) {
        e.addParam(t, u.create(1, _.cloneForParamSpecAccess(n, 'args'), c.TypeDeclared, 'args'));
        e.addParam(t, u.create(2, _.cloneForParamSpecAccess(n, 'kwargs'), c.TypeDeclared, 'kwargs'));
      };
      e.addDefaultParams = function (t, a = false) {
        n(a).forEach(n => {
          e.addParam(t, n);
        });
      };
      e.getDefaultParams = n;
      e.hasDefaultParams = function (t) {
        let n = false;
        let a = false;
        for (let r = 0; r < t.shared.parameters.length; r++) {
          const s = t.shared.parameters[r];
          if (s.name) {
            if (s.category === 0) {
              return false;
            }
            if (s.category === 1) {
              n = true;
            } else {
              if (s.category === 2) {
                a = true;
              }
            }
            if (!S(e.getParamType(t, r))) {
              return false;
            }
          }
        }
        return n && a;
      };
      e.isInstanceMethod = function (e) {
        return !(e.shared.flags & 7);
      };
      e.isConstructorMethod = function (e) {
        return !!(e.shared.flags & 1);
      };
      e.isStaticMethod = function (e) {
        return !!(e.shared.flags & 4);
      };
      e.isClassMethod = function (e) {
        return !!(e.shared.flags & 2);
      };
      e.isAbstractMethod = function (e) {
        return !!(e.shared.flags & 8);
      };
      e.isGenerator = function (e) {
        return !!(e.shared.flags & 16);
      };
      e.isSynthesizedMethod = function (e) {
        return !!(e.shared.flags & 64);
      };
      e.isTypeCheckOnly = function (e) {
        return !!(e.shared.flags & 128);
      };
      e.isOverloaded = function (e) {
        return !!(e.shared.flags & 256);
      };
      e.isDefaultParamCheckDisabled = function (e) {
        return !!(e.shared.flags & 32);
      };
      e.isAsync = function (e) {
        return !!(e.shared.flags & 512);
      };
      e.isStubDefinition = function (e) {
        return !!(e.shared.flags & 2048);
      };
      e.isPyTypedDefinition = function (e) {
        return !!(e.shared.flags & 4096);
      };
      e.isFinal = function (e) {
        return !!(e.shared.flags & 8192);
      };
      e.hasUnannotatedParams = function (e) {
        return !!(e.shared.flags & 16384);
      };
      e.isGradualCallableForm = function (e) {
        return !!(e.shared.flags & 32768);
      };
      e.isParamSpecValue = function (e) {
        return !!(e.shared.flags & 65536);
      };
      e.isPartiallyEvaluated = function (e) {
        return !!(e.shared.flags & 131072);
      };
      e.isOverridden = function (e) {
        return !!(e.shared.flags & 262144);
      };
      e.isBuiltIn = function (e, t) {
        if (!(e.shared.flags & 1048576)) {
          return false;
        }
        if (t !== undefined) {
          return (Array.isArray(t) ? t : [t]).some(t => t === e.shared.name || t === e.shared.fullName);
        }
        return true;
      };
      e.getDeclaredParamType = function (e, t) {
        return e.shared.parameters[t]._type;
      };
      e.getParamType = a;
      e.getParamDefaultType = function (e, t) {
        var n;
        r.assert(t < e.shared.parameters.length, 'Parameter types array overflow');
        if (((n = e.priv.specializedTypes) === null || n === undefined ? undefined : n.parameterDefaultTypes) && t < e.priv.specializedTypes.parameterDefaultTypes.length) {
          const n = e.priv.specializedTypes.parameterDefaultTypes[t];
          if (n) {
            return n;
          }
        }
        return e.shared.parameters[t]._defaultType;
      };
      e.addParam = s;
      e.addPositionOnlyParamSeparator = function (e) {
        s(e, u.create(0, h.create()));
      };
      e.addKeywordOnlyParamSeparator = function (e) {
        s(e, u.create(1, h.create()));
      };
      e.getEffectiveReturnType = function (e, t = true) {
        var n;
        if ((n = e.priv.specializedTypes) === null || n === undefined ? undefined : n.returnType) {
          return e.priv.specializedTypes.returnType;
        } else {
          if (e.shared.declaredReturnType) {
            return e.shared.declaredReturnType;
          } else {
            if (t) {
              return e.priv.inferredReturnType;
            } else {
              return undefined;
            }
          }
        }
      };
    })(m || (exports.FunctionType = m = {}));
    (function (e) {
      e.create = function (t, n) {
        const a = {
          category: 5,
          flags: 2,
          props: undefined,
          cached: undefined,
          shared: undefined,
          priv: {
            _overloads: [],
            _implementation: n
          }
        };
        t.forEach(t => {
          e.addOverload(a, t);
        });
        if (n && V(n)) {
          n.priv.overloaded = a;
        }
        return a;
      };
      e.addOverload = function (e, t) {
        t.priv.overloaded = e;
        e.priv._overloads.push(t);
      };
      e.getOverloads = function (e) {
        return e.priv._overloads;
      };
      e.getImplementation = function (e) {
        return e.priv._implementation;
      };
    })(y || (exports.OverloadedType = y = {}));
    (function (e) {
      const t = {
        category: 3,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isNoReturn: false
        }
      };
      const n = {
        category: 3,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isNoReturn: true
        }
      };
      e.createNever = function () {
        return t;
      };
      e.createNoReturn = function () {
        return n;
      };
      e.convertToInstance = function (t) {
        var n;
        var a;
        if (((n = t.props) === null || n === undefined ? undefined : n.specialForm) || ((a = t.props) === null || a === undefined ? undefined : a.typeForm)) {
          if (t.priv.isNoReturn) {
            return e.createNoReturn();
          } else {
            return e.createNever();
          }
        } else {
          return t;
        }
      };
    })(g || (exports.NeverType = g = {}));
    (function (e) {
      const t = {
        category: 2,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isEllipsis: false
        }
      };
      const n = {
        category: 2,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isEllipsis: false
        }
      };
      const a = {
        category: 2,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isEllipsis: true
        }
      };
      e.create = function (e = false) {
        if (e) {
          return a;
        } else {
          return n;
        }
      };
      e.createSpecialForm = function () {
        return t;
      };
    })(h || (exports.AnyType = h = {}));
    (function (e) {
      e.convertToInstance = function (t) {
        var n;
        if ((n = t.props) === null || n === undefined ? undefined : n.specialForm) {
          return e.create();
        } else {
          return t;
        }
      };
    })(h || (exports.AnyType = h = {}));
    (function (e) {
      function t(e, t) {
        if (e.typeVar.shared.name < t.typeVar.shared.name) {
          return -1;
        } else {
          if (e.typeVar.shared.name > t.typeVar.shared.name) {
            return 1;
          } else {
            if (e.constraintIndex < t.constraintIndex) {
              return -1;
            } else {
              if (e.constraintIndex > t.constraintIndex) {
                return 1;
              } else {
                return 0;
              }
            }
          }
        }
      }
      e.combine = function (e, n) {
        if (!e) {
          return n;
        }
        if (!n) {
          return e;
        }
        const a = Array.from(e);
        n.forEach(e => {
          if (!a.some(n => t(e, n) === 0)) {
            a.push(e);
          }
        });
        return a.sort(t);
      };
      e.isSame = function (e, t) {
        if (e) {
          return !!t && e.length === t.length && e.find((e, n) => e.typeVar.priv.nameWithScope !== t[n].typeVar.priv.nameWithScope || e.constraintIndex !== t[n].constraintIndex) === undefined;
        } else {
          return !t;
        }
      };
      e.isCompatible = function (e, t) {
        if (!e || !t) {
          return true;
        }
        for (const n of e) {
          let e = false;
          const a = t.find(t => n.typeVar.priv.nameWithScope === t.typeVar.priv.nameWithScope && (e = true, n.constraintIndex === t.constraintIndex));
          if (e && !a) {
            return false;
          }
        }
        return true;
      };
    })(f || (exports.TypeCondition = f = {}));
    (function (e) {
      e.create = function () {
        return {
          category: 8,
          flags: 3,
          props: undefined,
          cached: undefined,
          shared: undefined,
          priv: {
            subtypes: [],
            literalInstances: {
              literalStrMap: undefined,
              literalIntMap: undefined,
              literalEnumMap: undefined
            },
            literalClasses: {
              literalStrMap: undefined,
              literalIntMap: undefined,
              literalEnumMap: undefined
            },
            typeAliasSources: undefined,
            includesRecursiveTypeAlias: false
          }
        };
      };
      e.addType = function (e, t) {
        var n;
        var a;
        if (P(t) && t.priv.literalValue !== undefined && !((n = t.props) === null || n === undefined ? undefined : n.condition)) {
          const n = N(t) ? e.priv.literalInstances : e.priv.literalClasses;
          if (d.isBuiltIn(t, 'str')) {
            if (n.literalStrMap === undefined) {
              n.literalStrMap = new Map();
            }
            n.literalStrMap.set(t.priv.literalValue, t);
          } else {
            if (d.isBuiltIn(t, 'int')) {
              if (n.literalIntMap === undefined) {
                n.literalIntMap = new Map();
              }
              n.literalIntMap.set(t.priv.literalValue, t);
            } else {
              if (d.isEnumClass(t)) {
                if (n.literalEnumMap === undefined) {
                  n.literalEnumMap = new Map();
                }
                const e = t.priv.literalValue;
                n.literalEnumMap.set(e.getName(), t);
              }
            }
          }
        }
        e.flags &= t.flags;
        e.priv.subtypes.push(t);
        if (F(t) && ((a = t.shared.recursiveAlias) === null || a === undefined ? undefined : a.name)) {
          e.priv.includesRecursiveTypeAlias = true;
        }
      };
      e.containsType = function (e, t, n = {}, a, r = 0) {
        var s;
        if (P(t) && ((s = t.props) === null || s === undefined ? undefined : s.condition) === undefined && t.priv.literalValue !== undefined) {
          const n = N(t) ? e.priv.literalInstances : e.priv.literalClasses;
          if (d.isBuiltIn(t, 'str') && n.literalStrMap !== undefined) {
            return n.literalStrMap.has(t.priv.literalValue);
          }
          if (d.isBuiltIn(t, 'int') && n.literalIntMap !== undefined) {
            return n.literalIntMap.has(t.priv.literalValue);
          }
          if (d.isEnumClass(t) && n.literalEnumMap !== undefined) {
            const e = t.priv.literalValue;
            return n.literalEnumMap.has(e.getName());
          }
        }
        const i = e.priv.subtypes.findIndex((e, s) => !(a == null ? undefined : a.has(s)) && R(e, t, n, r));
        return !(i < 0) && (a == null || a.add(i), true);
      };
      e.addTypeAliasSource = function (e, t) {
        var n;
        if (t.category === 8) {
          const a = ((n = t.props) === null || n === undefined ? undefined : n.typeAliasInfo) ? [t] : t.priv.typeAliasSources;
          if (a) {
            if (!e.priv.typeAliasSources) {
              e.priv.typeAliasSources = new Set();
            }
            a.forEach(t => {
              e.priv.typeAliasSources.add(t);
            });
          }
        }
      };
    })(T || (exports.UnionType = T = {}));
    (function (e) {
      e[e.TypeVar = 0] = 'TypeVar';
      e[e.TypeVarTuple = 1] = 'TypeVarTuple';
      e[e.ParamSpec = 2] = 'ParamSpec';
    })(v || (exports.TypeVarKind = v = {}));
    (function (e) {
      e.getUnknown = function () {
        const e = m.createInstance('', '', '', 98304);
        m.addDefaultParams(e);
        return e;
      };
    })(b || (exports.ParamSpecType = b = {}));
    (function (e) {
      function n(e, t, n) {
        return `${e}.${t}.${n}`;
      }
      function a(e, t, n) {
        return {
          category: 9,
          flags: n,
          props: undefined,
          cached: undefined,
          shared: {
            kind: t,
            name: e,
            constraints: [],
            boundType: undefined,
            isDefaultExplicit: false,
            defaultType: l.create(),
            declaredVariance: 2,
            isSynthesized: false,
            isSynthesizedSelf: false,
            synthesizedIndex: undefined,
            isExemptFromBoundCheck: false,
            isTypeParamSyntax: false,
            recursiveAlias: undefined
          },
          priv: {}
        };
      }
      e.createInstance = function (e, t = v.TypeVar) {
        return a(e, t, 2);
      };
      e.createInstantiable = function (e, t = v.TypeVar) {
        return a(e, t, 1);
      };
      e.cloneAsInstance = function (t) {
        var n;
        var a;
        r.assert(i.isInstantiable(t));
        if ((n = t.cached) === null || n === undefined ? undefined : n.typeBaseInstanceType) {
          return t.cached.typeBaseInstanceType;
        }
        const s = i.cloneTypeAsInstance(t, true);
        if ((a = s.props) === null || a === undefined ? undefined : a.specialForm) {
          i.setSpecialForm(s, undefined);
        }
        if (s.priv.freeTypeVar) {
          s.priv.freeTypeVar = e.cloneAsInstance(s.priv.freeTypeVar);
        }
        return s;
      };
      e.cloneAsInstantiable = function (t) {
        var n;
        if ((n = t.cached) === null || n === undefined ? undefined : n.typeBaseInstantiableType) {
          return t.cached.typeBaseInstantiableType;
        }
        const a = i.cloneTypeAsInstantiable(t, true);
        if (a.priv.freeTypeVar) {
          a.priv.freeTypeVar = e.cloneAsInstantiable(a.priv.freeTypeVar);
        }
        return a;
      };
      e.cloneForNewName = function (e, t) {
        var a;
        const r = i.cloneType(e);
        r.shared = {
          ...e.shared
        };
        r.shared.name = t;
        if (r.priv.scopeId) {
          r.priv.nameWithScope = n(t, r.priv.scopeId, (a = r.priv.scopeName) !== null && a !== undefined ? a : '');
        }
        return r;
      };
      e.cloneForScopeId = function (e, t, a, r) {
        const s = i.cloneType(e);
        s.priv.nameWithScope = n(e.shared.name, t, a ?? '');
        s.priv.scopeId = t;
        s.priv.scopeName = a;
        s.priv.scopeType = r;
        return s;
      };
      e.cloneForUnpacked = function (t, n = false) {
        const a = i.cloneType(t);
        a.priv.isUnpacked = true;
        if (M(a) && n) {
          a.priv.isInUnion = n;
        }
        if (a.priv.freeTypeVar) {
          a.priv.freeTypeVar = e.cloneForUnpacked(a.priv.freeTypeVar, n);
        }
        return a;
      };
      e.cloneForPacked = function (t) {
        const n = i.cloneType(t);
        n.priv.isUnpacked = false;
        if (M(n)) {
          n.priv.isInUnion = false;
        }
        if (n.priv.freeTypeVar) {
          n.priv.freeTypeVar = e.cloneForPacked(n.priv.freeTypeVar);
        }
        return n;
      };
      e.cloneAsInvariant = function (t) {
        if (E(t) || M(t)) {
          return t;
        }
        if (t.shared.declaredVariance === 0) {
          return t;
        }
        if (t.shared.declaredVariance === 2 && !e.hasBound(t) && !e.hasConstraints(t)) {
          return t;
        }
        const n = i.cloneType(t);
        n.shared = {
          ...n.shared
        };
        n.shared.declaredVariance = 2;
        n.shared.boundType = undefined;
        n.shared.constraints = [];
        return n;
      };
      e.cloneForParamSpecAccess = function (e, t) {
        const n = i.cloneType(e);
        n.priv.paramSpecAccess = t;
        return n;
      };
      e.cloneAsSpecializedSelf = function (t, n) {
        r.assert(e.isSelf(t));
        const a = i.cloneType(t);
        a.shared = {
          ...a.shared
        };
        a.shared.boundType = n;
        return a;
      };
      e.cloneAsUnificationVar = function (n, a) {
        if (e.isUnification(n)) {
          return n;
        }
        let r = n.priv.nameWithScope;
        if (a) {
          r = `${n.priv.nameWithScope}-${a}`;
        }
        const s = i.cloneType(n);
        s.priv.isUnificationVar = true;
        s.priv.scopeId = exports.UnificationScopeId;
        s.priv.nameWithScope = r;
        return s;
      };
      e.cloneWithComputedVariance = function (e, t) {
        const n = i.cloneType(e);
        n.priv.computedVariance = t;
        return n;
      };
      e.makeNameWithScope = n;
      e.makeBoundScopeId = function (e) {
        if (e) {
          return `${e}*`;
        }
      };
      e.cloneAsBound = function (t) {
        if (t.priv.scopeId === undefined || t.priv.freeTypeVar) {
          return t;
        }
        const n = e.cloneForScopeId(t, e.makeBoundScopeId(t.priv.scopeId), t.priv.scopeName, t.priv.scopeType);
        n.priv.freeTypeVar = t;
        return n;
      };
      e.isBound = function (e) {
        return !!e.priv.freeTypeVar;
      };
      e.isUnification = function (e) {
        return e.priv.isUnificationVar;
      };
      e.addConstraint = function (e, t) {
        e.shared.constraints.push(t);
      };
      e.getNameWithScope = function (e) {
        return e.priv.nameWithScope || e.shared.name;
      };
      e.getReadableName = function (e, t = true) {
        if (e.priv.scopeName && t) {
          return `${e.shared.name}@${e.priv.scopeName}`;
        } else {
          return e.shared.name;
        }
      };
      e.getVariance = function (e) {
        var t;
        const n = (t = e.priv.computedVariance) !== null && t !== undefined ? t : e.shared.declaredVariance;
        r.assert(n !== 0, 'Expected variance to be inferred');
        if (n === 1) {
          return 3;
        } else {
          return n;
        }
      };
      e.isTypeAliasPlaceholder = function (e) {
        return !!e.shared.recursiveAlias && !e.shared.boundType;
      };
      e.isSelf = function (e) {
        return !!e.shared.isSynthesizedSelf;
      };
      e.hasConstraints = function (e) {
        return e.shared.constraints.length > 0;
      };
      e.hasBound = function (e) {
        return !!e.shared.boundType;
      };
    })(_ || (exports.TypeVarType = _ = {}));
  },
  1371: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.BackgroundAnalysisRunnerBase = exports.BackgroundAnalysisBase = undefined;
    const i = require(56911);
    const o = require(28167);
    const l = require(1811);
    const p = require(79253);
    const d = require(94953);
    const c = require(91426);
    const u = require(12522);
    const m = require(25075);
    const y = __importStar(require(48281));
    const g = require(11479);
    const h = require(34487);
    const f = require(51862);
    const T = require(27113);
    exports.BackgroundAnalysisBase = class {
      constructor(e) {
        this.console = e;
        this._onAnalysisCompletion = l.nullCallback;
        this._analysisCancellationToken = undefined;
        this._messageChannel = new o.MessageChannel();
        this._messageChannel.port1.on('message', e => this.handleBackgroundResponse(e));
      }
      dispose() {
        if (this._messageChannel) {
          this._messageChannel.port1.close();
          this._messageChannel.port2.close();
        }
        if (this._worker) {
          this._worker.terminate();
        }
      }
      setProgramView(e) {
        this.program = e;
      }
      setCompletionCallback(e) {
        this._onAnalysisCompletion = e ?? l.nullCallback;
      }
      setImportResolver(e) {
        this.enqueueRequest({
          requestType: 'setImportResolver',
          data: d.serialize(e.host.kind)
        });
      }
      setConfigOptions(e) {
        this.enqueueRequest({
          requestType: 'setConfigOptions',
          data: d.serialize(e)
        });
      }
      setTrackedFiles(e) {
        this.enqueueRequest({
          requestType: 'setTrackedFiles',
          data: d.serialize(e)
        });
      }
      setAllowedThirdPartyImports(e) {
        this.enqueueRequest({
          requestType: 'setAllowedThirdPartyImports',
          data: d.serialize(e)
        });
      }
      ensurePartialStubPackages(e) {
        this.enqueueRequest({
          requestType: 'ensurePartialStubPackages',
          data: d.serialize({
            executionRoot: e
          })
        });
      }
      setFileOpened(e, t, n, a) {
        this.enqueueRequest({
          requestType: 'setFileOpened',
          data: d.serialize({
            fileUri: e,
            version: t,
            contents: n,
            options: a
          })
        });
      }
      updateChainedUri(e, t) {
        this.enqueueRequest({
          requestType: 'updateChainedFileUri',
          data: d.serialize({
            fileUri: e,
            chainedUri: t
          })
        });
      }
      setFileClosed(e, t) {
        this.enqueueRequest({
          requestType: 'setFileClosed',
          data: d.serialize({
            fileUri: e,
            isTracked: t
          })
        });
      }
      addInterimFile(e) {
        this.enqueueRequest({
          requestType: 'addInterimFile',
          data: d.serialize({
            fileUri: e
          })
        });
      }
      markAllFilesDirty(e) {
        this.enqueueRequest({
          requestType: 'markAllFilesDirty',
          data: d.serialize({
            evenIfContentsAreSame: e
          })
        });
      }
      markFilesDirty(e, t) {
        this.enqueueRequest({
          requestType: 'markFilesDirty',
          data: d.serialize({
            fileUris: e,
            evenIfContentsAreSame: t
          })
        });
      }
      startAnalysis(e) {
        this._analysisCancellationToken = e;
        this.enqueueRequest({
          requestType: 'analyze',
          data: d.serialize(e)
        });
      }
      async analyzeFile(e, t) {
        c.throwIfCancellationRequested(t);
        const {
          port1: n,
          port2: a
        } = new o.MessageChannel();
        const r = d.getBackgroundWaiter(n);
        const s = c.getCancellationTokenId(t);
        this.enqueueRequest({
          requestType: 'analyzeFile',
          data: d.serialize({
            fileUri: e,
            cancellationId: s
          }),
          port: a
        });
        const i = await r;
        a.close();
        n.close();
        return i;
      }
      async getDiagnosticsForRange(e, t, n) {
        c.throwIfCancellationRequested(n);
        const {
          port1: a,
          port2: r
        } = new o.MessageChannel();
        const s = d.getBackgroundWaiter(a);
        const i = c.getCancellationTokenId(n);
        this.enqueueRequest({
          requestType: 'getDiagnosticsForRange',
          data: d.serialize({
            fileUri: e,
            range: t,
            cancellationId: i
          }),
          port: r
        });
        const l = await s;
        r.close();
        a.close();
        return _(l);
      }
      async writeTypeStub(e, t, n, a) {
        c.throwIfCancellationRequested(a);
        const {
          port1: r,
          port2: s
        } = new o.MessageChannel();
        const i = d.getBackgroundWaiter(r);
        const l = c.getCancellationTokenId(a);
        this.enqueueRequest({
          requestType: 'writeTypeStub',
          data: d.serialize({
            targetImportPath: e,
            targetIsSingleFile: t,
            stubPath: n,
            cancellationId: l
          }),
          port: s
        });
        await i;
        s.close();
        r.close();
      }
      invalidateAndForceReanalysis(e) {
        this.enqueueRequest({
          requestType: 'invalidateAndForceReanalysis',
          data: d.serialize({
            reason: e
          })
        });
      }
      restart() {
        this.enqueueRequest({
          requestType: 'restart',
          data: null
        });
      }
      shutdown() {
        if (this._worker) {
          this.enqueueRequest({
            requestType: 'shutdown',
            data: null
          });
        }
      }
      setup(e) {
        this._worker = e;
        e.on('message', e => this.onMessage(e));
        e.on('error', e => {
          this.log(m.LogLevel.Error, `Error occurred on background thread: ${JSON.stringify(e)}`);
        });
        this.enqueueRequest({
          requestType: 'start',
          data: '',
          port: this._messageChannel.port2
        });
      }
      onMessage(e) {
        switch (e.requestType) {
          case 'log':
            {
              const t = d.deserialize(e.data);
              this.log(t.level, t.message);
              break;
            }
          case 'analysisResult':
            this._onAnalysisCompletion(b(d.deserialize(e.data)));
            break;
          default:
            y.fail(`${e.requestType} is not expected. Message structure: ${JSON.stringify(e)}`);
        }
      }
      enqueueRequest(e) {
        if (this._worker) {
          this._worker.postMessage(e, e.port ? [e.port] : undefined);
        }
      }
      log(e, t) {
        m.log(this.console, e, t);
      }
      handleBackgroundResponse(e) {
        switch (e.requestType) {
          case 'analysisResult':
            this._onAnalysisCompletion(b(d.deserialize(e.data)));
            break;
          case 'analysisPaused':
            this.enqueueRequest({
              requestType: 'resumeAnalysis',
              data: d.serialize(this._analysisCancellationToken || i.CancellationToken.None)
            });
            break;
          case 'analysisDone':
            if (this._analysisCancellationToken) {
              h.disposeCancellationToken(this._analysisCancellationToken);
            }
            this._analysisCancellationToken = undefined;
            break;
          default:
            y.fail(`${e.requestType} is not expected. Message structure: ${JSON.stringify(e)}`);
        }
      }
    };
    class v extends d.BackgroundThreadBase {
      constructor(e) {
        super(o.workerData, e);
        this.serviceProvider = e;
        this.isCaseSensitive = true;
        const t = o.workerData;
        this.log(m.LogLevel.Info, `Background analysis(${o.threadId}) root directory: ${t.rootUri}`);
        this._configOptions = new u.ConfigOptions(T.Uri.parse(t.rootUri, e));
        this.importResolver = this.createImportResolver(e, this._configOptions, this.createHost());
        const n = this.getConsole();
        this.logTracker = new f.LogTracker(n, `BG(${o.threadId})`);
        this._program = new p.Program(this.importResolver, this._configOptions, e, this.logTracker, undefined, t.serviceId);
      }
      get program() {
        return this._program;
      }
      get responsePort() {
        y.assert(this._responsePort !== undefined, 'BG thread was not started properly. No response port');
        return this._responsePort;
      }
      start() {
        this.log(m.LogLevel.Info, `Background analysis(${o.threadId}) started`);
        if (o.parentPort !== null && o.parentPort !== undefined) {
          o.parentPort.on('message', this._onMessageWrapper.bind(this));
        }
        if (o.parentPort !== null && o.parentPort !== undefined) {
          o.parentPort.on('error', e => y.fail(`failed ${e}`));
        }
        if (o.parentPort !== null && o.parentPort !== undefined) {
          o.parentPort.on('exit', e => {
            if (e !== 0) {
              y.fail(`worker stopped with exit code ${e}`);
            }
          });
        }
      }
      onMessage(e) {
        var t;
        switch (e.requestType) {
          case 'start':
            this._responsePort = e.port;
            break;
          case 'cacheUsageBuffer':
            if ((t = this.serviceProvider.cacheManager()) !== null && t !== undefined) {
              t.handleCachedUsageBufferMessage(e);
            }
            break;
          case 'analyze':
            {
              const t = d.deserialize(e.data);
              this.handleAnalyze(this.responsePort, t);
              break;
            }
          case 'resumeAnalysis':
            {
              const t = d.deserialize(e.data);
              this.handleResumeAnalysis(this.responsePort, t);
              break;
            }
          case 'analyzeFile':
            d.run(() => {
              const {
                fileUri: t,
                cancellationId: n
              } = d.deserialize(e.data);
              const a = h.getCancellationTokenFromId(n);
              return this.handleAnalyzeFile(t, a);
            }, e.port);
            break;
          case 'getDiagnosticsForRange':
            d.run(() => {
              const {
                fileUri: t,
                range: n,
                cancellationId: a
              } = d.deserialize(e.data);
              const r = h.getCancellationTokenFromId(a);
              return this.handleGetDiagnosticsForRange(t, n, r);
            }, e.port);
            break;
          case 'writeTypeStub':
            d.run(() => {
              const {
                targetImportPath: t,
                targetIsSingleFile: n,
                stubPath: a,
                cancellationId: r
              } = d.deserialize(e.data);
              const s = h.getCancellationTokenFromId(r);
              this.handleWriteTypeStub(t, n, a, s);
            }, e.port);
            break;
          case 'setImportResolver':
            this.handleSetImportResolver(d.deserialize(e.data));
            break;
          case 'setConfigOptions':
            this.handleSetConfigOptions(d.deserialize(e.data));
            break;
          case 'setTrackedFiles':
            this.handleSetTrackedFiles(d.deserialize(e.data));
            break;
          case 'setAllowedThirdPartyImports':
            this.handleSetAllowedThirdPartyImports(d.deserialize(e.data));
            break;
          case 'ensurePartialStubPackages':
            {
              const {
                executionRoot: t
              } = d.deserialize(e.data);
              this.handleEnsurePartialStubPackages(t);
              break;
            }
          case 'setFileOpened':
            {
              const {
                fileUri: t,
                version: n,
                contents: a,
                options: r
              } = d.deserialize(e.data);
              this.handleSetFileOpened(t, n, a, r);
              break;
            }
          case 'updateChainedFileUri':
            {
              const {
                fileUri: t,
                chainedUri: n
              } = d.deserialize(e.data);
              this.handleUpdateChainedFileUri(t, n);
              break;
            }
          case 'setFileClosed':
            {
              const {
                fileUri: t,
                isTracked: n
              } = d.deserialize(e.data);
              this.handleSetFileClosed(t, n);
              break;
            }
          case 'addInterimFile':
            {
              const {
                fileUri: t
              } = d.deserialize(e.data);
              this.handleAddInterimFile(t);
              break;
            }
          case 'markAllFilesDirty':
            {
              const {
                evenIfContentsAreSame: t
              } = d.deserialize(e.data);
              this.handleMarkAllFilesDirty(t);
              break;
            }
          case 'markFilesDirty':
            {
              const {
                fileUris: t,
                evenIfContentsAreSame: n
              } = d.deserialize(e.data);
              this.handleMarkFilesDirty(t, n);
              break;
            }
          case 'invalidateAndForceReanalysis':
            {
              const {
                reason: t
              } = d.deserialize(e.data);
              this.handleInvalidateAndForceReanalysis(t);
              break;
            }
          case 'restart':
            this.handleRestart();
            break;
          case 'shutdown':
            this.handleShutdown();
            break;
          default:
            y.fail(`${e.requestType} is not expected. Message structure: ${JSON.stringify(e)}`);
        }
      }
      handleAnalyze(e, t) {
        const n = this.program.getFilesToAnalyzeCount();
        this.onAnalysisCompletion(e, {
          diagnostics: [],
          filesInProgram: this.program.getFileCount(),
          requiringAnalysisCount: n,
          checkingOnlyOpenFiles: this.program.isCheckingOnlyOpenFiles(),
          fatalErrorOccurred: false,
          configParseErrorOccurred: false,
          elapsedTime: 0,
          reason: 'analysis'
        });
        this.handleResumeAnalysis(e, t);
      }
      handleResumeAnalysis(e, t) {
        if (l.analyzeProgram(this.program, {
          openFilesTimeInMs: 50,
          noOpenFilesTimeInMs: 200
        }, this._configOptions, t => this.onAnalysisCompletion(e, t), this.getConsole(), t)) {
          this._analysisPaused(e, t);
        } else {
          this.analysisDone(e, t);
        }
      }
      handleAnalyzeFile(e, t) {
        c.throwIfCancellationRequested(t);
        return this.program.analyzeFile(e, t);
      }
      handleGetDiagnosticsForRange(e, t, n) {
        c.throwIfCancellationRequested(n);
        return this.program.getDiagnosticsForRange(e, t);
      }
      handleWriteTypeStub(e, t, n, a) {
        l.analyzeProgram(this.program, undefined, this._configOptions, l.nullCallback, this.getConsole(), a);
        this.program.writeTypeStub(e, t, n, a);
      }
      handleSetImportResolver(e) {
        this.importResolver = this.createImportResolver(this.getServiceProvider(), this._configOptions, this.createHost());
        this.program.setImportResolver(this.importResolver);
      }
      handleSetConfigOptions(e) {
        this._configOptions = e;
        this.importResolver = this.createImportResolver(this.getServiceProvider(), this._configOptions, this.importResolver.host);
        this.program.setConfigOptions(this._configOptions);
        this.program.setImportResolver(this.importResolver);
      }
      handleSetTrackedFiles(e) {
        const t = this.program.setTrackedFiles(e);
        this._reportDiagnostics(t, this.program.getFilesToAnalyzeCount(), 0);
      }
      handleSetAllowedThirdPartyImports(e) {
        this.program.setAllowedThirdPartyImports(e);
      }
      handleEnsurePartialStubPackages(e) {
        const t = this._configOptions.getExecutionEnvironments().find(t => {
          var n;
          return ((n = t.root) === null || n === undefined ? undefined : n.toString()) === e;
        });
        if (t) {
          this.importResolver.ensurePartialStubPackages(t);
        }
      }
      handleSetFileOpened(e, t, n, a) {
        this.program.setFileOpened(e, t, n, a ? {
          ...a,
          chainedFileUri: T.Uri.fromJsonObj(a == null ? undefined : a.chainedFileUri)
        } : undefined);
      }
      handleUpdateChainedFileUri(e, t) {
        this.program.updateChainedUri(e, t);
      }
      handleSetFileClosed(e, t) {
        const n = this.program.setFileClosed(e, t);
        this._reportDiagnostics(n, this.program.getFilesToAnalyzeCount(), 0);
      }
      handleAddInterimFile(e) {
        this.program.addInterimFile(e);
      }
      handleMarkFilesDirty(e, t) {
        this.program.markFilesDirty(e, t);
      }
      handleMarkAllFilesDirty(e) {
        this.program.markAllFilesDirty(e);
      }
      handleInvalidateAndForceReanalysis(e) {
        this.importResolver.invalidateCache();
        this.program.markAllFilesDirty(true);
      }
      handleRestart() {
        this.importResolver = this.createImportResolver(this.getServiceProvider(), this._configOptions, this.importResolver.host);
        this.program.setImportResolver(this.importResolver);
      }
      handleShutdown() {
        this._program.dispose();
        super.handleShutdown();
      }
      analysisDone(e, t) {
        e.postMessage({
          requestType: 'analysisDone',
          data: d.serialize(t)
        });
      }
      onAnalysisCompletion(e, t) {
        e.postMessage({
          requestType: 'analysisResult',
          data: d.serialize(t)
        });
      }
      _onMessageWrapper(e) {
        try {
          return this.onMessage(e);
        } catch (t) {
          this.log(m.LogLevel.Log, `Background analysis exception leak: ${t}`);
          if (c.OperationCanceledException.is(t)) {
            if (o.parentPort !== null && o.parentPort !== undefined) {
              o.parentPort.postMessage({
                kind: 'cancelled',
                data: t.message
              });
            }
            return;
          }
          if (o.parentPort !== null && o.parentPort !== undefined) {
            o.parentPort.postMessage({
              kind: 'failed',
              data: `Exception: for msg ${e.requestType}: ${t.message} in ${t.stack}`
            });
          }
        }
      }
      _reportDiagnostics(e, t, n) {
        if (o.parentPort) {
          this.onAnalysisCompletion(o.parentPort, {
            diagnostics: e,
            filesInProgram: this.program.getFileCount(),
            requiringAnalysisCount: t,
            checkingOnlyOpenFiles: this.program.isCheckingOnlyOpenFiles(),
            fatalErrorOccurred: false,
            configParseErrorOccurred: false,
            elapsedTime: n,
            reason: 'tracking'
          });
        }
      }
      _analysisPaused(e, t) {
        e.postMessage({
          requestType: 'analysisPaused',
          data: d.serialize(t)
        });
      }
    }
    function b(e) {
      e.diagnostics = e.diagnostics.map(e => ({
        fileUri: T.Uri.fromJsonObj(e.fileUri),
        version: e.version,
        diagnostics: _(e.diagnostics)
      }));
      return e;
    }
    function _(e) {
      return e.map(e => {
        const t = new g.Diagnostic(e.category, e.message, e.range, e.priority);
        if (e._actions) {
          for (const n of e._actions) {
            t.addAction(n);
          }
        }
        if (e._rule) {
          t.setRule(e._rule);
        }
        if (e._relatedInfo) {
          for (const n of e._relatedInfo) {
            t.addRelatedInfo(n.message, n.uri, n.range);
          }
        }
        return t;
      });
    }
    exports.BackgroundAnalysisRunnerBase = v;
  },
  94953: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.BackgroundThreadBase = exports.BackgroundConsole = undefined;
    exports.serializeReplacer = b;
    exports.serialize = _;
    exports.deserializeReviver = C;
    exports.deserialize = I;
    exports.run = function (e, t, n = _) {
      try {
        const a = e();
        if (c.isThenable(a)) {
          return a.then(e => {
            t.postMessage({
              kind: 'ok',
              data: n(e)
            });
          }, e => {
            if (l.OperationCanceledException.is(e)) {
              t.postMessage({
                kind: 'cancelled',
                data: e.message
              });
            } else {
              t.postMessage({
                kind: 'failed',
                data: `Exception: ${e.message} in ${e.stack}`
              });
            }
          });
        } else {
          t.postMessage({
            kind: 'ok',
            data: n(a)
          });
          return;
        }
      } catch (e) {
        if (l.OperationCanceledException.is(e)) {
          t.postMessage({
            kind: 'cancelled',
            data: e.message
          });
          return;
        }
        t.postMessage({
          kind: 'failed',
          data: `Exception: ${e.message} in ${e.stack}`
        });
      }
    };
    exports.getBackgroundWaiter = function (e, t = I) {
      return new Promise((n, a) => {
        e.on('message', e => {
          switch (e.kind) {
            case 'ok':
              n(t(e.data));
              break;
            case 'cancelled':
              a(new l.OperationCanceledException());
              break;
            case 'failed':
              a(e.data);
              break;
            default:
              u.fail(`unknown kind ${e.kind}`);
          }
        });
      });
    };
    const i = require(28167);
    const o = require(32720);
    const l = require(91426);
    const p = require(12522);
    const d = require(25075);
    const c = require(34455);
    const u = __importStar(require(48281));
    const m = require(27643);
    const y = require(71745);
    const g = require(42856);
    require(23070);
    const h = require(27113);
    const f = require(90355);
    const T = require(34487);
    class v {
      constructor() {
        this._level = d.LogLevel.Log;
      }
      get level() {
        return this._level;
      }
      set level(e) {
        this._level = e;
      }
      log(e) {
        this.post(d.LogLevel.Log, e);
      }
      info(e) {
        this.post(d.LogLevel.Info, e);
      }
      warn(e) {
        this.post(d.LogLevel.Warn, e);
      }
      error(e) {
        this.post(d.LogLevel.Error, e);
      }
      post(e, t) {
        if (i.parentPort !== null && i.parentPort !== undefined) {
          i.parentPort.postMessage({
            requestType: 'log',
            data: _({
              level: e,
              message: t
            })
          });
        }
      }
    }
    exports.BackgroundConsole = v;
    function b(e) {
      var t;
      if (h.Uri.is(e) && e.toJsonObj !== undefined) {
        return {
          __serialized_uri_val: e.toJsonObj()
        };
      }
      if (e instanceof Map) {
        return {
          __serialized_map_val: [...e]
        };
      }
      if (e instanceof Set) {
        return {
          __serialized_set_val: [...e]
        };
      }
      if (e instanceof RegExp) {
        return {
          __serialized_regexp_val: {
            source: e.source,
            flags: e.flags
          }
        };
      }
      if (e instanceof p.ConfigOptions) {
        return {
          __serialized_config_options: Object.entries(e).reduce((e, t, n) => ({
            ...e,
            [t[0]]: t[1]
          }), {})
        };
      }
      if (f.CancellationToken.is(e)) {
        return {
          cancellation_token_val: (t = l.getCancellationTokenId(e)) !== null && t !== undefined ? t : null
        };
      } else {
        return e;
      }
    }
    function _(e) {
      return JSON.stringify(e, (e, t) => b(t));
    }
    function C(e) {
      if (e && typeof e == 'object') {
        if (e.__serialized_uri_val !== undefined) {
          return h.Uri.fromJsonObj(e.__serialized_uri_val);
        }
        if (e.__serialized_map_val) {
          return new Map(e.__serialized_map_val);
        }
        if (e.__serialized_set_val) {
          return new Set(e.__serialized_set_val);
        }
        if (e.__serialized_regexp_val) {
          return new RegExp(e.__serialized_regexp_val.source, e.__serialized_regexp_val.flags);
        }
        if (e.__serialized_config_options) {
          const t = new p.ConfigOptions(e.__serialized_config_options.projectRoot);
          Object.assign(t, e.__serialized_config_options);
          return t;
        }
        if (Object.keys(e).includes('cancellation_token_val')) {
          return T.getCancellationTokenFromId(e.cancellation_token_val);
        }
      }
      return e;
    }
    function I(e) {
      if (e) {
        return JSON.parse(e, (e, t) => C(t));
      }
    }
    exports.BackgroundThreadBase = class {
      constructor(e, t) {
        let n;
        l.setCancellationFolderName(e.cancellationFolderName);
        this._serviceProvider = t ?? new g.ServiceProvider();
        if (!this._serviceProvider.tryGet(y.ServiceKeys.console)) {
          this._serviceProvider.add(y.ServiceKeys.console, new v());
        }
        if (!this._serviceProvider.tryGet(y.ServiceKeys.tempFile)) {
          n = new m.RealTempFile();
          this._serviceProvider.add(y.ServiceKeys.tempFile, n);
        }
        if (!this._serviceProvider.tryGet(y.ServiceKeys.caseSensitivityDetector)) {
          this._serviceProvider.add(y.ServiceKeys.caseSensitivityDetector, n ?? new m.RealTempFile());
        }
        if (!this._serviceProvider.tryGet(y.ServiceKeys.fs)) {
          this._serviceProvider.add(y.ServiceKeys.fs, m.createFromRealFileSystem(this._serviceProvider.get(y.ServiceKeys.caseSensitivityDetector), this.getConsole()));
        }
        if (!this._serviceProvider.tryGet(y.ServiceKeys.cacheManager)) {
          this._serviceProvider.add(y.ServiceKeys.cacheManager, new o.CacheManager());
        }
        global.__rootDirectory = h.Uri.parse(e.rootUri, this._serviceProvider).getFilePath();
      }
      get fs() {
        return this._serviceProvider.fs();
      }
      log(e, t) {
        if (i.parentPort !== null && i.parentPort !== undefined) {
          i.parentPort.postMessage({
            requestType: 'log',
            data: _({
              level: e,
              message: t
            })
          });
        }
      }
      getConsole() {
        return this._serviceProvider.console();
      }
      getServiceProvider() {
        return this._serviceProvider;
      }
      handleShutdown() {
        const e = this._serviceProvider.tryGet(y.ServiceKeys.tempFile);
        if (c.Disposable.is(e)) {
          e.dispose();
        }
        if (i.parentPort !== null && i.parentPort !== undefined) {
          i.parentPort.close();
        }
      }
    };
  },
  18177: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CommandResult = undefined;
    const a = require(38659);
    var r;
    (function (e) {
      e.is = function (e) {
        return e && e.label !== undefined && e.edits && a.WorkspaceEdit.is(e.edits);
      };
    })(r || (exports.CommandResult = r = {}));
  },
  76737: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeStubCreator = exports.CreateTypeStubCommand = undefined;
    const a = require(91426);
    const r = require(92196);
    const s = require(27113);
    exports.CreateTypeStubCommand = class {
      constructor(e) {
        this._ls = e;
      }
      async execute(e, t) {
        if (!e.arguments || e.arguments.length < 2) {
          return;
        }
        const n = s.Uri.parse(e.arguments[0], this._ls.serviceProvider);
        const a = e.arguments[1];
        const r = s.Uri.parse(e.arguments[2], this._ls.serviceProvider);
        const o = await this._ls.getWorkspaceForFile(r ?? n);
        return await new i(this._ls).create(o, a, t);
      }
    };
    class i {
      constructor(e) {
        this._ls = e;
      }
      async create(e, t, n) {
        const s = await r.AnalyzerServiceExecutor.cloneService(this._ls, e, {
          typeStubTargetImportName: t,
          useBackgroundAnalysis: true
        });
        try {
          await s.writeTypeStubInBackground(n);
          s.dispose();
          const e = `Type stub was successfully created for '${t}'.`;
          this._ls.window.showInformationMessage(e);
          this._ls.reanalyze();
        } catch (e) {
          if (a.OperationCanceledException.is(e)) {
            const e = `Type stub creation for '${t}' was canceled`;
            this._ls.console.error(e);
          } else {
            let n = '';
            if (e instanceof Error) {
              n = `: ${e.message}`;
            }
            n = `An error occurred when creating type stub for '${t}'${n}`;
            this._ls.console.error(n);
            this._ls.window.showErrorMessage(n);
          }
        }
      }
    }
    exports.TypeStubCreator = i;
  },
  89577: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DumpFileDebugInfo = exports.DumpFileDebugInfoCommand = undefined;
    const a = require(26687);
    const r = require(41557);
    const s = require(88744);
    const i = require(21024);
    const o = require(91426);
    const l = require(34455);
    const p = require(56814);
    const d = require(88754);
    const c = require(27113);
    const u = require(85114);
    exports.DumpFileDebugInfoCommand = class {
      constructor(e) {
        this._ls = e;
      }
      async execute(e, t) {
        o.throwIfCancellationRequested(t);
        if (!e.arguments || e.arguments.length < 2) {
          return [];
        }
        const n = c.Uri.parse(e.arguments[0], this._ls.serviceProvider);
        const a = await this._ls.getWorkspaceForFile(n);
        return new m().dump(a, n, e.arguments, t);
      }
    };
    class m {
      dump(e, t, n, s) {
        return e.service.run(s => {
          const i = n[1];
          const o = e.service.getParseResults(e.service.fs.realCasePath(t));
          if (!o) {
            return [];
          }
          const l = [];
          const p = {
            info: e => {
              l.push(e);
            },
            log: e => {
              l.push(e);
            },
            error: e => {
              l.push(e);
            },
            warn: e => {
              l.push(e);
            }
          };
          p.info(`* Dump debug info for '${t.toUserVisibleString()}'`);
          switch (i) {
            case 'tokens':
              p.info(`* Token info (${o.tokenizerOutput.tokens.count} tokens)`);
              for (let e = 0; e < o.tokenizerOutput.tokens.count; e++) {
                const n = o.tokenizerOutput.tokens.getItemAt(e);
                p.info(`[${e}] ${_(t, n, o.tokenizerOutput.lines)}`);
              }
              break;
            case 'nodes':
              {
                p.info('* Node info');
                const e = new v(t, o.tokenizerOutput.lines);
                e.walk(o.parserOutput.parseTree);
                p.info(e.output);
                break;
              }
            case 'types':
              {
                const e = s.evaluator;
                const a = n[2];
                const r = n[3];
                if (!e || !a || !r) {
                  return [];
                }
                p.info('* Type info');
                p.info(`${g(t, e, o, a, r)}`);
                break;
              }
            case 'cachedtypes':
              {
                const e = s.evaluator;
                const a = n[2];
                const r = n[3];
                if (!e || !a || !r) {
                  return [];
                }
                p.info('* Cached Type info');
                p.info(`${g(t, e, o, a, r, true)}`);
                break;
              }
            case 'codeflowgraph':
              {
                const e = s.evaluator;
                const t = n[2];
                if (!e || t === undefined) {
                  return [];
                }
                const i = r.findNodeByOffset(o.parserOutput.parseTree, t);
                if (!i) {
                  return [];
                }
                const l = a.getFlowNode(i);
                if (!l) {
                  return [];
                }
                p.info('* CodeFlow Graph');
                e.printControlFlowGraph(l, undefined, 'Dump CodeFlowGraph', p);
              }
          }
          e.service.serviceProvider.console().info(l.join('\n'));
          return [];
        }, s);
      }
    }
    function y(e, t) {
      return JSON.stringify(e, t, 2).replace(/\\\\/g, '\\');
    }
    function g(e, t, n, a, s, o) {
      var p;
      var c;
      const m = new v(e, n.tokenizerOutput.lines);
      const g = (p = r.findNodeByOffset(n.parserOutput.parseTree, a)) !== null && p !== undefined ? p : r.findNodeByOffset(n.parserOutput.parseTree, s);
      if (!g) {
        return 'N/A';
      }
      const _ = new Set();
      if (g.nodeType === 38) {
        switch ((c = g.parent) === null || c === undefined ? undefined : c.nodeType) {
          case 10:
            {
              const e = o ? t.getCachedType(g.parent.d.name) : t.getTypeOfClass(g.parent);
              if (e) {
                return y(e, A);
              } else {
                return 'N/A';
              }
            }
          case 31:
            {
              const e = o ? t.getCachedType(g.parent.d.name) : t.getTypeOfFunction(g.parent);
              if (e) {
                return y(e, A);
              } else {
                return 'N/A';
              }
            }
        }
      }
      const I = d.TextRange.fromBounds(a, s);
      const k = function (e, t) {
        let n = e;
        while (n && !d.TextRange.containsRange(n, t)) {
          n = n.parent;
        }
        if (!n) {
          return;
        }
        while (!u.isExpressionNode(n)) {
          n = n.parent;
        }
        return n;
      }(g, I);
      if (!k) {
        return 'N/A';
      }
      const w = `Expression node found at ${C(k, n.tokenizerOutput.lines)} from the given span ${C(I, n.tokenizerOutput.lines)}\r\n`;
      const S = o ? t.getCachedType(k) : t.getType(k);
      if (S) {
        return w + y(S, A);
      } else {
        return w + 'No result';
      }
      function A(e, t) {
        if (t !== undefined) {
          if (!l.isNumber(t) && !l.isString(t)) {
            if (_.has(t)) {
              if (x(n = t) && n.details && P(n.details)) {
                return `<cycle> class '${t.shared.fullName}' typeSourceId:${t.shared.typeSourceId}`;
              } else {
                if (function (e) {
                  return x(e) && e.details && D(e.details);
                }(t)) {
                  return `<cycle> function '${t.shared.fullName}' parameter count:${t.shared.parameters.length}`;
                } else {
                  if (function (e) {
                    return x(e) && e.details && N(e.details);
                  }(t)) {
                    return `<cycle> function '${t.shared.name}' scope id:${t.priv.nameWithScope}`;
                  } else {
                    return undefined;
                  }
                }
              }
            }
            _.add(t);
          }
          var n;
          if (x(this) && e === 'category') {
            return function (e, t) {
              switch (e) {
                case 0:
                  return 'Unbound';
                case 1:
                  return 'Unknown';
                case 2:
                  return 'Any';
                case 3:
                  return 'Never';
                case 4:
                  return 'Function';
                case 5:
                  return 'Overloaded';
                case 6:
                  if (i.TypeBase.isInstantiable(t)) {
                    return 'Class';
                  } else {
                    return 'Object';
                  }
                case 7:
                  return 'Module';
                case 8:
                  return 'Union';
                case 9:
                  return 'TypeVar';
                default:
                  return `Unknown Value!! (${e})`;
              }
            }(t, this);
          }
          if (x(this) && e === 'flags') {
            return function (e) {
              const t = [];
              if (e & 1) {
                t.push('Instantiable');
              }
              if (e & 2) {
                t.push('Instance');
              }
              if (t.length === 0) {
                return 'None';
              } else {
                return t.join(',');
              }
            }(t);
          }
          if (P(this) && e === 'flags') {
            return h(T, t);
          }
          if (D(this) && e === 'flags') {
            return function (e) {
              return h(f, e);
            }(t);
          }
          if (N(this) && e === 'variance') {
            return function (e) {
              switch (e) {
                case 2:
                  return 'Invariant';
                case 3:
                  return 'Covariant';
                case 4:
                  return 'Contravariant';
                default:
                  return `Unknown Value!! (${e})`;
              }
            }(t);
          }
          if (function (e) {
            return e.category && e.type;
          }(this) && e === 'category') {
            return b(t);
          }
          if (t.nodeType && t.id) {
            m.visitNode(t);
            const e = m.output;
            m.reset();
            return e;
          }
          return t;
        }
      }
      function x(e) {
        return e.category && e.flags;
      }
      function P(e) {
        return e.name !== undefined && e.fullName !== undefined && e.moduleName !== undefined && e.baseClasses;
      }
      function D(e) {
        return e.name !== undefined && e.fullName !== undefined && e.moduleName !== undefined && e.parameters;
      }
      function N(e) {
        return e.name !== undefined && e.constraints && e.variance !== undefined;
      }
    }
    function h(e, t) {
      const n = [];
      e.forEach(e => {
        if (t & e[0]) {
          n.push(e[1]);
        }
      });
      if (n.length === 0) {
        if (t === 0) {
          return 'None';
        } else {
          return '<Unknown>';
        }
      } else {
        return n.join(',');
      }
    }
    exports.DumpFileDebugInfo = m;
    const f = [[8, 'AbstractMethod'], [512, 'Async'], [2, 'ClassMethod'], [1, 'ConstructorMethod'], [32, 'DisableDefaultChecks'], [8192, 'Final'], [16, 'Generator'], [256, 'Overloaded'], [65536, 'ParamSpecValue'], [131072, 'PartiallyEvaluated'], [4096, 'PyTypedDefinition'], [32768, 'SkipArgsKwargsCompatibilityCheck'], [4, 'StaticMethod'], [2048, 'StubDefinition'], [64, 'SynthesizedMethod'], [16384, 'UnannotatedParams']];
    const T = [[1, 'BuiltIn'], [32, 'CanOmitDictValues'], [131072, 'ClassProperty'], [262144, 'DefinedInStub'], [65536, 'EnumClass'], [256, 'Final'], [16384, 'HasCustomClassGetItem'], [8192, 'PartiallyEvaluated'], [128, 'PropertyClass'], [512, 'ProtocolClass'], [1024, 'PseudoGenericClass'], [2048, 'RuntimeCheckable'], [2, 'SpecialBuiltIn'], [64, 'SupportsAbstractMethods'], [32768, 'TupleClass'], [4, 'TypedDictClass'], [4096, 'TypingExtensionClass']];
    class v extends s.ParseTreeWalker {
      constructor(e, t) {
        super();
        this._uri = e;
        this._lines = t;
        this._indentation = '';
        this._output = '';
      }
      get output() {
        return this._output;
      }
      walk(e) {
        const t = this.visitNode(e);
        if (t.length > 0) {
          this._indentation += '  ';
          this.walkMultiple(t);
          this._indentation = this._indentation.substr(0, this._indentation.length - 2);
        }
      }
      reset() {
        this._indentation = '';
        this._output = '';
      }
      visitArgument(e) {
        this._log(`${this._getPrefix(e)} ${function (e) {
          switch (e) {
            case 0:
              return 'Simple';
            case 1:
              return 'UnpackedList';
            case 2:
              return 'UnpackedDictionary';
            default:
              return `Unknown Value!! (${e})`;
          }
        }(e.d.argCategory)}`);
        return true;
      }
      visitAssert(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitAssignment(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitAssignmentExpression(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitAugmentedAssignment(e) {
        this._log(`${this._getPrefix(e)} ${I(e.d.operator)}`);
        return true;
      }
      visitAwait(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitBinaryOperation(e) {
        this._log(`${this._getPrefix(e)} ${_(this._uri, e.d.operatorToken, this._lines)} ${I(e.d.operator)}} parenthesized:(${e.d.hasParens})`);
        return true;
      }
      visitBreak(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitCall(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitClass(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitComprehension(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitComprehensionFor(e) {
        this._log(`${this._getPrefix(e)} async:(${e.d.isAsync})`);
        return true;
      }
      visitComprehensionIf(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitContinue(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitConstant(e) {
        this._log(`${this._getPrefix(e)} ${k(e.d.constType)}`);
        return true;
      }
      visitDecorator(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitDel(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitDictionary(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitDictionaryKeyEntry(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitDictionaryExpandEntry(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitError(e) {
        this._log(`${this._getPrefix(e)} ${function (e) {
          switch (e) {
            case 0:
              return 'MissingIn';
            case 1:
              return 'MissingElse';
            case 2:
              return 'MissingExpression';
            case 3:
              return 'MissingIndexOrSlice';
            case 4:
              return 'MissingDecoratorCallName';
            case 5:
              return 'MissingCallCloseParen';
            case 6:
              return 'MissingIndexCloseBracket';
            case 7:
              return 'MissingMemberAccessName';
            case 8:
              return 'MissingTupleCloseParen';
            case 9:
              return 'MissingListCloseBracket';
            case 10:
              return 'MissingFunctionParameterList';
            case 11:
              return 'MissingPattern';
            case 12:
              return 'MissingPatternSubject';
            case 13:
              return 'MissingDictValue';
            case 15:
              return 'MaxDepthExceeded';
            default:
              return `Unknown Value!! (${e})`;
          }
        }(e.d.category)}`);
        return true;
      }
      visitEllipsis(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitIf(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitImport(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitImportAs(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitImportFrom(e) {
        this._log(`${this._getPrefix(e)} wildcard import:(${e.d.isWildcardImport}) paren:(${e.d.usesParens}) wildcard token:(${e.d.wildcardToken ? _(this._uri, e.d.wildcardToken, this._lines) : 'N/A'}) missing import keyword:(${e.d.missingImport})`);
        return true;
      }
      visitImportFromAs(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitIndex(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitExcept(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitFor(e) {
        this._log(`${this._getPrefix(e)} async:(${e.d.isAsync})`);
        return true;
      }
      visitFormatString(e) {
        this._log(`${this._getPrefix(e)} f-string`);
        return true;
      }
      visitFunction(e) {
        this._log(`${this._getPrefix(e)} async:(${e.d.isAsync})`);
        return true;
      }
      visitFunctionAnnotation(e) {
        this._log(`${this._getPrefix(e)} ellipsis:(${e.d.isEllipsis})`);
        return true;
      }
      visitGlobal(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitLambda(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitList(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitMemberAccess(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitModule(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitModuleName(e) {
        this._log(`${this._getPrefix(e)} leading dots:(${e.d.leadingDots}) trailing dot:(${e.d.hasTrailingDot})`);
        return true;
      }
      visitName(e) {
        this._log(`${this._getPrefix(e)} ${_(this._uri, e.d.token, this._lines)} ${e.d.value}`);
        return true;
      }
      visitNonlocal(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitNumber(e) {
        this._log(`${this._getPrefix(e)} ${e.d.value} int:(${e.d.isInteger}) imaginary:(${e.d.isImaginary})`);
        return true;
      }
      visitParameter(e) {
        this._log(`${this._getPrefix(e)} ${b(e.d.category)}`);
        return true;
      }
      visitPass(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitRaise(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitReturn(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitSet(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitSlice(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitStatementList(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitString(e) {
        this._log(`${this._getPrefix(e)} ${_(this._uri, e.d.token, this._lines)} ${e.d.value}`);
        return true;
      }
      visitStringList(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitSuite(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitTernary(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitTuple(e) {
        this._log(`${this._getPrefix(e)} paren:(${e.d.hasParens})`);
        return true;
      }
      visitTry(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitTypeAnnotation(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitUnaryOperation(e) {
        this._log(`${this._getPrefix(e)} ${_(this._uri, e.d.operatorToken, this._lines)} ${I(e.d.operator)}`);
        return true;
      }
      visitUnpack(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitWhile(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitWith(e) {
        this._log(`${this._getPrefix(e)} async:(${e.d.isAsync})`);
        return true;
      }
      visitWithItem(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitYield(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitYieldFrom(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitCase(e) {
        this._log(`${this._getPrefix(e)} isIrrefutable: ${e.d.isIrrefutable}`);
        return true;
      }
      visitMatch(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternAs(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternCapture(e) {
        this._log(`${this._getPrefix(e)} isStar:${e.d.isStar} isWildcard:${e.d.isWildcard}`);
        return true;
      }
      visitPatternClass(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternClassArgument(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternLiteral(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternMapping(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternMappingExpandEntry(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternMappingKeyEntry(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternSequence(e) {
        this._log(`${this._getPrefix(e)} starEntryIndex: ${e.d.starEntryIndex}`);
        return true;
      }
      visitPatternValue(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitTypeAlias(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitTypeParameter(e) {
        this._log(`${this._getPrefix(e)} typeParamCategory:${function (e) {
          switch (e) {
            case u.TypeParamKind.TypeVar:
              return 'TypeVar';
            case u.TypeParamKind.TypeVarTuple:
              return 'TypeVarTuple';
            case u.TypeParamKind.ParamSpec:
              return 'ParamSpec';
          }
        }(e.d.typeParamKind)}`);
        return true;
      }
      visitTypeParameterList(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      _log(e) {
        this._output += `${this._indentation}${e}\r\n`;
      }
      _getPrefix(e) {
        const t = p.convertOffsetToPosition(e.start, this._lines);
        return `[${e.id}] '${this._uri.toString()}:${t.line + 1}:${t.character + 1}' => ${r.printParseNodeType(e.nodeType)} ${C(e, this._lines)} =>`;
      }
    }
    function b(e) {
      switch (e) {
        case 0:
          return 'Simple';
        case 1:
          return 'ArgsList';
        case 2:
          return 'KwargsDict';
      }
    }
    function _(e, t, n) {
      const a = p.convertOffsetToPosition(t.start, n);
      let r = `'${e.toUserVisibleString()}:${a.line + 1}:${a.character + 1}' (`;
      var s;
      r += function (e) {
        switch (e) {
          case 0:
            return 'Invalid';
          case 1:
            return 'EndOfStream';
          case 2:
            return 'NewLine';
          case 3:
            return 'Indent';
          case 4:
            return 'Dedent';
          case 5:
            return 'String';
          case 6:
            return 'Number';
          case 7:
            return 'Identifier';
          case 8:
            return 'Keyword';
          case 9:
            return 'Operator';
          case 10:
            return 'Colon';
          case 11:
            return 'Semicolon';
          case 12:
            return 'Comma';
          case 13:
            return 'OpenParenthesis';
          case 14:
            return 'CloseParenthesis';
          case 15:
            return 'OpenBracket';
          case 16:
            return 'CloseBracket';
          case 17:
            return 'OpenCurlyBrace';
          case 18:
            return 'CloseCurlyBrace';
          case 19:
            return 'Ellipsis';
          case 20:
            return 'Dot';
          case 21:
            return 'Arrow';
          case 22:
            return 'Backtick';
          default:
            return `Unknown Value!! (${e})`;
        }
      }(t.type);
      r += (s = t).newLineType ? `, ${function (e) {
        switch (e) {
          case 0:
            return 'CarriageReturn';
          case 1:
            return 'LineFeed';
          case 2:
            return 'CarriageReturnLineFeed';
          case 3:
            return 'Implied';
          default:
            return `Unknown Value!! (${e})`;
        }
      }(s.newLineType)}` : '';
      r += function (e) {
        if (e.operatorType) {
          return `, ${I(e.operatorType)}`;
        } else {
          return '';
        }
      }(t);
      r += function (e) {
        if (e.keywordType) {
          return `, ${k(e.keywordType)}`;
        } else {
          return '';
        }
      }(t);
      r += function (e) {
        if (e.flags) {
          return `, [${(t = e.flags, h(w, t))}]`;
        } else {
          return '';
        }
        var t;
      }(t);
      r += `, ${C(t, n)}`;
      r += ') ';
      r += JSON.stringify(t);
      return r;
    }
    function C(e, t) {
      const n = p.convertOffsetsToRange(e.start, d.TextRange.getEnd(e), t);
      return `(${n.start.line},${n.start.character})-(${n.end.line},${n.end.character})`;
    }
    function I(e) {
      switch (e) {
        case 0:
          return 'Add';
        case 1:
          return 'AddEqual';
        case 2:
          return 'Assign';
        case 3:
          return 'BitwiseAnd';
        case 4:
          return 'BitwiseAndEqual';
        case 5:
          return 'BitwiseInvert';
        case 6:
          return 'BitwiseOr';
        case 7:
          return 'BitwiseOrEqual';
        case 8:
          return 'BitwiseXor';
        case 9:
          return 'BitwiseXorEqual';
        case 10:
          return 'Divide';
        case 11:
          return 'DivideEqual';
        case 12:
          return 'Equals';
        case 13:
          return 'FloorDivide';
        case 14:
          return 'FloorDivideEqual';
        case 15:
          return 'GreaterThan';
        case 16:
          return 'GreaterThanOrEqual';
        case 17:
          return 'LeftShift';
        case 18:
          return 'LeftShiftEqual';
        case 19:
          return 'LessOrGreaterThan';
        case 20:
          return 'LessThan';
        case 21:
          return 'LessThanOrEqual';
        case 22:
          return 'MatrixMultiply';
        case 23:
          return 'MatrixMultiplyEqual';
        case 24:
          return 'Mod';
        case 25:
          return 'ModEqual';
        case 26:
          return 'Multiply';
        case 27:
          return 'MultiplyEqual';
        case 28:
          return 'NotEquals';
        case 29:
          return 'Power';
        case 30:
          return 'PowerEqual';
        case 31:
          return 'RightShift';
        case 32:
          return 'RightShiftEqual';
        case 33:
          return 'Subtract';
        case 34:
          return 'SubtractEqual';
        case 35:
          return 'Walrus';
        case 36:
          return 'And';
        case 37:
          return 'Or';
        case 38:
          return 'Not';
        case 39:
          return 'Is';
        case 40:
          return 'IsNot';
        case 41:
          return 'In';
        case 42:
          return 'NotIn';
        default:
          return `Unknown Value!! (${e})`;
      }
    }
    function k(e) {
      switch (e) {
        case 0:
          return 'And';
        case 1:
          return 'As';
        case 2:
          return 'Assert';
        case 3:
          return 'Async';
        case 4:
          return 'Await';
        case 5:
          return 'Break';
        case 7:
          return 'Class';
        case 8:
          return 'Continue';
        case 9:
          return 'Debug';
        case 10:
          return 'Def';
        case 11:
          return 'Del';
        case 12:
          return 'Elif';
        case 13:
          return 'Else';
        case 14:
          return 'Except';
        case 15:
          return 'False';
        case 16:
          return 'Finally';
        case 17:
          return 'For';
        case 18:
          return 'From';
        case 19:
          return 'Global';
        case 20:
          return 'If';
        case 21:
          return 'Import';
        case 22:
          return 'In';
        case 23:
          return 'Is';
        case 24:
          return 'Lambda';
        case 26:
          return 'None';
        case 27:
          return 'Nonlocal';
        case 28:
          return 'Not';
        case 29:
          return 'Or';
        case 30:
          return 'Pass';
        case 31:
          return 'Raise';
        case 32:
          return 'Return';
        case 33:
          return 'True';
        case 34:
          return 'Try';
        case 36:
          return 'While';
        case 37:
          return 'With';
        case 38:
          return 'Yield';
        default:
          return `Unknown Value!! (${e})`;
      }
    }
    const w = [[32, 'Bytes'], [2, 'DoubleQuote'], [64, 'Format'], [8, 'Raw'], [1, 'SingleQuote'], [4, 'Triplicate'], [16, 'Unicode'], [65536, 'Unterminated']];
  },
  64330: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.initializeDependencies = async function () {
      await a.ensureTomlModuleLoaded();
      require(73527).install();
    };
    const a = require(33351);
  },
  91426: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CancellationThrottle = exports.FileBasedToken = exports.DefaultCancellationProvider = exports.OperationCanceledException = undefined;
    exports.getCancellationFolderName = function () {
      return o;
    };
    exports.setCancellationFolderName = function (e) {
      o = e;
    };
    exports.invalidateTypeCacheIfCanceled = function (e) {
      try {
        return e();
      } catch (e) {
        if (l.is(e)) {
          e.isTypeCacheInvalid = true;
        }
        throw e;
      }
    };
    exports.throwIfCancellationRequested = function (e) {
      if (!s.isDebugMode() && e.isCancellationRequested) {
        throw new l();
      }
    };
    exports.onCancellationRequested = d;
    exports.CancelAfter = function (e, ...t) {
      const n = e.createCancellationTokenSource();
      const a = [];
      for (const e of t) {
        a.push(d(e, () => {
          n.cancel();
        }));
      }
      a.push(d(n.token, () => {
        a.forEach(e => e.dispose());
      }));
      return n;
    };
    exports.getCancellationTokenId = function (e) {
      if (e instanceof c) {
        return e.id;
      } else {
        return undefined;
      }
    };
    exports.raceCancellation = async function (e, ...t) {
      if (!e) {
        return Promise.race(t);
      }
      if (e.isCancellationRequested) {
        throw new l();
      }
      return new Promise((n, a) => {
        if (e.isCancellationRequested) {
          return a(new l());
        }
        const r = d(e, () => {
          r.dispose();
          a(new l());
        });
        Promise.race(t).then(n, a).finally(() => r.dispose());
      });
    };
    const a = require(90355);
    const r = require(56911);
    const s = require(34455);
    const i = require(5884);
    let o;
    class l extends r.ResponseError {
      constructor() {
        super(r.LSPErrorCodes.RequestCancelled, 'request cancelled');
        this.isTypeCacheInvalid = false;
      }
      static is(e) {
        return e.code === r.LSPErrorCodes.RequestCancelled;
      }
    }
    exports.OperationCanceledException = l;
    const p = r.Disposable.create(() => {});
    function d(e, t) {
      try {
        return e.onCancellationRequested(t);
      } catch {
        return p;
      }
    }
    exports.DefaultCancellationProvider = class {
      createCancellationTokenSource() {
        return new a.CancellationTokenSource();
      }
    };
    class c {
      constructor(e, t) {
        this._fs = t;
        this.isCancelled = false;
        this.cancellationFilePath = i.UriEx.file(e);
      }
      get id() {
        return this.cancellationFilePath.toString();
      }
      get isCancellationRequested() {
        return !!this.isCancelled || (u.shouldCheck() && this._pipeExists() && this.cancel(), this.isCancelled);
      }
      get onCancellationRequested() {
        if (!this._emitter) {
          this._emitter = new a.Emitter();
        }
        return this._emitter.event;
      }
      cancel() {
        if (!this.isCancelled) {
          this.isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(undefined);
            this._disposeEmitter();
          }
        }
      }
      dispose() {
        this._disposeEmitter();
      }
      _disposeEmitter() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = undefined;
        }
      }
      _pipeExists() {
        try {
          this._fs.statSync(this.cancellationFilePath);
          return true;
        } catch (e) {
          return false;
        }
      }
    }
    exports.FileBasedToken = c;
    class u {
      static shouldCheck() {
        const e = Date.now().valueOf();
        return e - this._lastCheckTimestamp >= 5 && (this._lastCheckTimestamp = e, true);
      }
    }
    exports.CancellationThrottle = u;
    u._lastCheckTimestamp = 0;
  },
  7095: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CaseSensitivityDetector = undefined;
    (function (e) {
      e.is = function (e) {
        return !!e.isCaseSensitive;
      };
    })(n || (exports.CaseSensitivityDetector = n = {}));
  },
  58147: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.emptyArray = undefined;
    exports.contains = r;
    exports.append = function (e, t) {
      if (t === undefined) {
        return e;
      }
      if (e === undefined) {
        return [t];
      }
      e.push(t);
      return e;
    };
    exports.appendArray = function (e, t) {
      if (t.length < 256) {
        e.push(...t);
        return;
      }
      for (const n of t) {
        e.push(n);
      }
    };
    exports.partition = function (e, t) {
      const n = [];
      const a = [];
      for (const r of e) {
        if (t(r)) {
          n.push(r);
        } else {
          a.push(r);
        }
      }
      return [n, a];
    };
    exports.find = function (e, t) {
      for (let n = 0; n < e.length; n++) {
        const a = e[n];
        if (t(a, n)) {
          return a;
        }
      }
      return;
    };
    exports.addRange = i;
    exports.insertAt = function (e, t, n) {
      if (t === 0) {
        e.unshift(n);
      } else {
        if (t === e.length) {
          e.push(n);
        } else {
          for (let n = e.length; n > t; n--) {
            e[n] = e[n - 1];
          }
          e[t] = n;
        }
      }
      return e;
    };
    exports.cloneAndSort = function (e, t) {
      if (e.length === 0) {
        return e;
      } else {
        return e.slice().sort(t);
      }
    };
    exports.stableSort = function (e, t) {
      const n = function (e) {
        return e.map(o);
      }(e);
      (function (e, t, n) {
        t.sort((t, r) => n(e[t], e[r]) || a.compareValues(t, r));
      })(e, n, t);
      return n.map(t => e[t]);
    };
    exports.map = function (e, t) {
      if (e) {
        return e.map(t);
      }
      return;
    };
    exports.some = l;
    exports.every = function (e, t) {
      if (e) {
        return e.every(t);
      }
      return true;
    };
    exports.binarySearch = function (e, t, n, a, r) {
      return p(e, n(t), n, a, r);
    };
    exports.binarySearchKey = p;
    exports.flatten = function (e) {
      const t = [];
      for (const n of e) {
        if (n) {
          if (a.isArray(n)) {
            i(t, n);
          } else {
            t.push(n);
          }
        }
      }
      return t;
    };
    exports.getNestedProperty = function (e, t) {
      return t.split('.').reduce((e, t) => e && e[t], e);
    };
    exports.getOrAdd = function (e, t, n) {
      const a = e.get(t);
      if (a !== undefined) {
        return a;
      }
      const r = n();
      e.set(t, r);
      return r;
    };
    exports.removeArrayElements = function (e, t) {
      for (let n = 0; n < e.length; n++) {
        if (t(e[n])) {
          e.splice(n, 1);
          n--;
        }
      }
      return e;
    };
    exports.createMapFromItems = function (e, t) {
      return e.map(e => t(e)).reduce((t, n, a) => {
        t.set(n, (t.get(n) || []).concat(e[a]));
        return t;
      }, new Map());
    };
    exports.addIfUnique = function (e, t, n = a.equateValues) {
      if (r(e, t, n)) {
        return e;
      }
      e.push(t);
      return e;
    };
    exports.getMapValues = function (e, t) {
      const n = [];
      e.forEach((e, a) => {
        if (t(a, e)) {
          n.push(e);
        }
      });
      return n;
    };
    exports.addIfNotNull = function (e, t) {
      if (t === undefined) {
        return e;
      }
      e.push(t);
      return e;
    };
    exports.arrayEquals = function (e, t, n) {
      if (e.length !== t.length) {
        return false;
      }
      return e.every((e, a) => n(e, t[a]));
    };
    const a = require(34455);
    function r(e, t, n = a.equateValues) {
      if (e) {
        for (const a of e) {
          if (n(a, t)) {
            return true;
          }
        }
      }
      return false;
    }
    function s(e, t) {
      if (t < 0) {
        return e.length + t;
      } else {
        return t;
      }
    }
    function i(e, t, n, a) {
      if (t === undefined || t.length === 0) {
        return e;
      }
      if (e === undefined) {
        return t.slice(n, a);
      }
      n = n === undefined ? 0 : s(t, n);
      a = a === undefined ? t.length : s(t, a);
      for (let r = n; r < a && r < t.length; r++) {
        if (t[r] !== undefined) {
          e.push(t[r]);
        }
      }
      return e;
    }
    function o(e, t) {
      return t;
    }
    function l(e, t) {
      return !!e && (t ? e.some(t) : e.length > 0);
    }
    function p(e, t, n, a, r) {
      if (!l(e)) {
        return -1;
      }
      let s = r || 0;
      let i = e.length - 1;
      while (s <= i) {
        const r = s + (i - s >> 1);
        switch (a(n(e[r]), t)) {
          case -1:
            s = r + 1;
            break;
          case 0:
            return r;
          case 1:
            i = r - 1;
        }
      }
      return ~s;
    }
    exports.emptyArray = [];
  },
  25463: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CommandLineOptions = exports.CommandLineLanguageServerOptions = exports.CommandLineConfigOptions = undefined;
    exports.getDiagnosticSeverityOverrides = function () {
      return ['error', 'warning', 'information', 'none'];
    };
    class n {
      constructor() {
        this.includeFileSpecs = [];
        this.excludeFileSpecs = [];
        this.ignoreFileSpecs = [];
      }
    }
    exports.CommandLineConfigOptions = n;
    class a {
      constructor() {
        this.logTypeEvaluationTime = false;
        this.typeEvaluationTimeThreshold = 50;
        this.enableAmbientAnalysis = true;
      }
    }
    exports.CommandLineLanguageServerOptions = a;
    exports.CommandLineOptions = class {
      constructor(e, t) {
        this.configSettings = new n();
        this.languageServerSettings = new a();
        this.executionRoot = e;
        this.fromLanguageServer = t;
      }
    };
  },
  23574: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createCommand = function (e, t, ...n) {
      const s = n.map(e => r.Uri.is(e) ? e.toString() : e);
      return a.Command.create(e, t, ...s);
    };
    const a = require(38659);
    const r = require(27113);
  },
  12522: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ConfigOptions = exports.SignatureDisplayType = exports.ExecutionEnvironment = exports.PythonPlatform = undefined;
    exports.cloneDiagnosticRuleSet = function (e) {
      return Object.assign({}, e);
    };
    exports.getBooleanDiagnosticRules = _;
    exports.getDiagLevelDiagnosticRules = C;
    exports.getStrictModeNotOverriddenRules = function () {
      return [m.DiagnosticRule.reportMissingModuleSource];
    };
    exports.getOffDiagnosticRuleSet = I;
    exports.getBasicDiagnosticRuleSet = k;
    exports.getStandardDiagnosticRuleSet = w;
    exports.getStrictDiagnosticRuleSet = S;
    exports.matchFileSpecs = function (e, t, n = true) {
      for (const a of e.include) {
        if (f.FileSpec.matchIncludeFileSpec(a.regExp, e.exclude, t, n)) {
          return true;
        }
      }
      return false;
    };
    exports.parseDiagLevel = function (e) {
      switch (e) {
        case false:
        case 'none':
          return 'none';
        case true:
        case 'error':
          return 'error';
        case 'warning':
          return 'warning';
        case 'information':
          return 'information';
        default:
          return;
      }
    };
    const i = require(16928);
    const o = require(16259);
    const l = __importStar(require(4883));
    const p = require(58147);
    const d = require(25463);
    const c = require(25075);
    const u = require(34455);
    const m = require(65880);
    const y = require(63808);
    const g = require(71745);
    const h = require(27113);
    const f = require(5884);
    var T;
    var v;
    (function (e) {
      e.Darwin = 'Darwin';
      e.Windows = 'Windows';
      e.Linux = 'Linux';
    })(T || (exports.PythonPlatform = T = {}));
    class b {
      constructor(e, t, n, a, r, s, i = false) {
        this.extraPaths = [];
        this.name = e;
        this.root = t;
        this.pythonVersion = a ?? y.latestStablePythonVersion;
        this.pythonPlatform = r;
        this.extraPaths = Array.from(s ?? []);
        this.diagnosticRuleSet = {
          ...n
        };
        this.skipNativeLibraries = i;
      }
    }
    function _(e = false) {
      const t = [m.DiagnosticRule.strictListInference, m.DiagnosticRule.strictSetInference, m.DiagnosticRule.strictDictionaryInference, m.DiagnosticRule.analyzeUnannotatedFunctions, m.DiagnosticRule.strictParameterNoneValue, m.DiagnosticRule.enableExperimentalFeatures, m.DiagnosticRule.deprecateTypingAliases, m.DiagnosticRule.disableBytesTypePromotions];
      if (e) {
        t.push(m.DiagnosticRule.enableTypeIgnoreComments);
        t.push(m.DiagnosticRule.enableReachabilityAnalysis);
      }
      return t;
    }
    function C() {
      return [m.DiagnosticRule.reportGeneralTypeIssues, m.DiagnosticRule.reportPropertyTypeMismatch, m.DiagnosticRule.reportFunctionMemberAccess, m.DiagnosticRule.reportMissingImports, m.DiagnosticRule.reportMissingModuleSource, m.DiagnosticRule.reportInvalidTypeForm, m.DiagnosticRule.reportMissingTypeStubs, m.DiagnosticRule.reportImportCycles, m.DiagnosticRule.reportUnusedImport, m.DiagnosticRule.reportUnusedClass, m.DiagnosticRule.reportUnusedFunction, m.DiagnosticRule.reportUnusedVariable, m.DiagnosticRule.reportDuplicateImport, m.DiagnosticRule.reportWildcardImportFromLibrary, m.DiagnosticRule.reportAbstractUsage, m.DiagnosticRule.reportArgumentType, m.DiagnosticRule.reportAssertTypeFailure, m.DiagnosticRule.reportAssignmentType, m.DiagnosticRule.reportAttributeAccessIssue, m.DiagnosticRule.reportCallIssue, m.DiagnosticRule.reportInconsistentOverload, m.DiagnosticRule.reportIndexIssue, m.DiagnosticRule.reportInvalidTypeArguments, m.DiagnosticRule.reportNoOverloadImplementation, m.DiagnosticRule.reportOperatorIssue, m.DiagnosticRule.reportOptionalSubscript, m.DiagnosticRule.reportOptionalMemberAccess, m.DiagnosticRule.reportOptionalCall, m.DiagnosticRule.reportOptionalIterable, m.DiagnosticRule.reportOptionalContextManager, m.DiagnosticRule.reportOptionalOperand, m.DiagnosticRule.reportRedeclaration, m.DiagnosticRule.reportReturnType, m.DiagnosticRule.reportTypedDictNotRequiredAccess, m.DiagnosticRule.reportUntypedFunctionDecorator, m.DiagnosticRule.reportUntypedClassDecorator, m.DiagnosticRule.reportUntypedBaseClass, m.DiagnosticRule.reportUntypedNamedTuple, m.DiagnosticRule.reportPrivateUsage, m.DiagnosticRule.reportTypeCommentUsage, m.DiagnosticRule.reportPrivateImportUsage, m.DiagnosticRule.reportConstantRedefinition, m.DiagnosticRule.reportDeprecated, m.DiagnosticRule.reportIncompatibleMethodOverride, m.DiagnosticRule.reportIncompatibleVariableOverride, m.DiagnosticRule.reportInconsistentConstructor, m.DiagnosticRule.reportOverlappingOverload, m.DiagnosticRule.reportPossiblyUnboundVariable, m.DiagnosticRule.reportMissingSuperCall, m.DiagnosticRule.reportUninitializedInstanceVariable, m.DiagnosticRule.reportInvalidStringEscapeSequence, m.DiagnosticRule.reportUnknownParameterType, m.DiagnosticRule.reportUnknownArgumentType, m.DiagnosticRule.reportUnknownLambdaType, m.DiagnosticRule.reportUnknownVariableType, m.DiagnosticRule.reportUnknownMemberType, m.DiagnosticRule.reportMissingParameterType, m.DiagnosticRule.reportMissingTypeArgument, m.DiagnosticRule.reportInvalidTypeVarUse, m.DiagnosticRule.reportCallInDefaultInitializer, m.DiagnosticRule.reportUnnecessaryIsInstance, m.DiagnosticRule.reportUnnecessaryCast, m.DiagnosticRule.reportUnnecessaryComparison, m.DiagnosticRule.reportUnnecessaryContains, m.DiagnosticRule.reportAssertAlwaysTrue, m.DiagnosticRule.reportSelfClsParameterName, m.DiagnosticRule.reportImplicitStringConcatenation, m.DiagnosticRule.reportUndefinedVariable, m.DiagnosticRule.reportUnhashable, m.DiagnosticRule.reportUnboundVariable, m.DiagnosticRule.reportInvalidStubStatement, m.DiagnosticRule.reportIncompleteStub, m.DiagnosticRule.reportUnsupportedDunderAll, m.DiagnosticRule.reportUnusedCallResult, m.DiagnosticRule.reportUnusedCoroutine, m.DiagnosticRule.reportUnusedExcept, m.DiagnosticRule.reportUnusedExpression, m.DiagnosticRule.reportUnnecessaryTypeIgnoreComment, m.DiagnosticRule.reportMatchNotExhaustive, m.DiagnosticRule.reportShadowedImports, m.DiagnosticRule.reportImplicitOverride];
    }
    function I() {
      return {
        printUnknownAsAny: true,
        omitTypeArgsIfUnknown: true,
        omitUnannotatedParamType: true,
        omitConditionalConstraint: true,
        pep604Printing: true,
        strictListInference: false,
        strictSetInference: false,
        strictDictionaryInference: false,
        analyzeUnannotatedFunctions: true,
        strictParameterNoneValue: true,
        enableExperimentalFeatures: false,
        enableTypeIgnoreComments: true,
        enableReachabilityAnalysis: false,
        deprecateTypingAliases: false,
        disableBytesTypePromotions: true,
        reportGeneralTypeIssues: 'none',
        reportPropertyTypeMismatch: 'none',
        reportFunctionMemberAccess: 'none',
        reportMissingImports: 'warning',
        reportMissingModuleSource: 'warning',
        reportInvalidTypeForm: 'warning',
        reportMissingTypeStubs: 'none',
        reportImportCycles: 'none',
        reportUnusedImport: 'none',
        reportUnusedClass: 'none',
        reportUnusedFunction: 'none',
        reportUnusedVariable: 'none',
        reportDuplicateImport: 'none',
        reportWildcardImportFromLibrary: 'none',
        reportAbstractUsage: 'none',
        reportArgumentType: 'none',
        reportAssertTypeFailure: 'none',
        reportAssignmentType: 'none',
        reportAttributeAccessIssue: 'none',
        reportCallIssue: 'none',
        reportInconsistentOverload: 'none',
        reportIndexIssue: 'none',
        reportInvalidTypeArguments: 'none',
        reportNoOverloadImplementation: 'none',
        reportOperatorIssue: 'none',
        reportOptionalSubscript: 'none',
        reportOptionalMemberAccess: 'none',
        reportOptionalCall: 'none',
        reportOptionalIterable: 'none',
        reportOptionalContextManager: 'none',
        reportOptionalOperand: 'none',
        reportRedeclaration: 'none',
        reportReturnType: 'none',
        reportTypedDictNotRequiredAccess: 'none',
        reportUntypedFunctionDecorator: 'none',
        reportUntypedClassDecorator: 'none',
        reportUntypedBaseClass: 'none',
        reportUntypedNamedTuple: 'none',
        reportPrivateUsage: 'none',
        reportTypeCommentUsage: 'none',
        reportPrivateImportUsage: 'none',
        reportConstantRedefinition: 'none',
        reportDeprecated: 'none',
        reportIncompatibleMethodOverride: 'none',
        reportIncompatibleVariableOverride: 'none',
        reportInconsistentConstructor: 'none',
        reportOverlappingOverload: 'none',
        reportPossiblyUnboundVariable: 'none',
        reportMissingSuperCall: 'none',
        reportUninitializedInstanceVariable: 'none',
        reportInvalidStringEscapeSequence: 'none',
        reportUnknownParameterType: 'none',
        reportUnknownArgumentType: 'none',
        reportUnknownLambdaType: 'none',
        reportUnknownVariableType: 'none',
        reportUnknownMemberType: 'none',
        reportMissingParameterType: 'none',
        reportMissingTypeArgument: 'none',
        reportInvalidTypeVarUse: 'none',
        reportCallInDefaultInitializer: 'none',
        reportUnnecessaryIsInstance: 'none',
        reportUnnecessaryCast: 'none',
        reportUnnecessaryComparison: 'none',
        reportUnnecessaryContains: 'none',
        reportAssertAlwaysTrue: 'none',
        reportSelfClsParameterName: 'none',
        reportImplicitStringConcatenation: 'none',
        reportUnboundVariable: 'none',
        reportUnhashable: 'none',
        reportUndefinedVariable: 'warning',
        reportInvalidStubStatement: 'none',
        reportIncompleteStub: 'none',
        reportUnsupportedDunderAll: 'none',
        reportUnusedCallResult: 'none',
        reportUnusedCoroutine: 'none',
        reportUnusedExcept: 'none',
        reportUnusedExpression: 'none',
        reportUnnecessaryTypeIgnoreComment: 'none',
        reportMatchNotExhaustive: 'none',
        reportShadowedImports: 'none',
        reportImplicitOverride: 'none'
      };
    }
    function k() {
      return {
        printUnknownAsAny: false,
        omitTypeArgsIfUnknown: false,
        omitUnannotatedParamType: true,
        omitConditionalConstraint: false,
        pep604Printing: true,
        strictListInference: false,
        strictSetInference: false,
        strictDictionaryInference: false,
        analyzeUnannotatedFunctions: true,
        strictParameterNoneValue: true,
        enableExperimentalFeatures: false,
        enableTypeIgnoreComments: true,
        enableReachabilityAnalysis: true,
        deprecateTypingAliases: false,
        disableBytesTypePromotions: true,
        reportGeneralTypeIssues: 'error',
        reportPropertyTypeMismatch: 'none',
        reportFunctionMemberAccess: 'none',
        reportMissingImports: 'error',
        reportMissingModuleSource: 'warning',
        reportInvalidTypeForm: 'error',
        reportMissingTypeStubs: 'none',
        reportImportCycles: 'none',
        reportUnusedImport: 'none',
        reportUnusedClass: 'none',
        reportUnusedFunction: 'none',
        reportUnusedVariable: 'none',
        reportDuplicateImport: 'none',
        reportWildcardImportFromLibrary: 'warning',
        reportAbstractUsage: 'error',
        reportArgumentType: 'error',
        reportAssertTypeFailure: 'error',
        reportAssignmentType: 'error',
        reportAttributeAccessIssue: 'error',
        reportCallIssue: 'error',
        reportInconsistentOverload: 'error',
        reportIndexIssue: 'error',
        reportInvalidTypeArguments: 'error',
        reportNoOverloadImplementation: 'error',
        reportOperatorIssue: 'error',
        reportOptionalSubscript: 'error',
        reportOptionalMemberAccess: 'error',
        reportOptionalCall: 'error',
        reportOptionalIterable: 'error',
        reportOptionalContextManager: 'error',
        reportOptionalOperand: 'error',
        reportRedeclaration: 'error',
        reportReturnType: 'error',
        reportTypedDictNotRequiredAccess: 'error',
        reportUntypedFunctionDecorator: 'none',
        reportUntypedClassDecorator: 'none',
        reportUntypedBaseClass: 'none',
        reportUntypedNamedTuple: 'none',
        reportPrivateUsage: 'none',
        reportTypeCommentUsage: 'none',
        reportPrivateImportUsage: 'error',
        reportConstantRedefinition: 'none',
        reportDeprecated: 'none',
        reportIncompatibleMethodOverride: 'none',
        reportIncompatibleVariableOverride: 'none',
        reportInconsistentConstructor: 'none',
        reportOverlappingOverload: 'none',
        reportPossiblyUnboundVariable: 'none',
        reportMissingSuperCall: 'none',
        reportUninitializedInstanceVariable: 'none',
        reportInvalidStringEscapeSequence: 'warning',
        reportUnknownParameterType: 'none',
        reportUnknownArgumentType: 'none',
        reportUnknownLambdaType: 'none',
        reportUnknownVariableType: 'none',
        reportUnknownMemberType: 'none',
        reportMissingParameterType: 'none',
        reportMissingTypeArgument: 'none',
        reportInvalidTypeVarUse: 'warning',
        reportCallInDefaultInitializer: 'none',
        reportUnnecessaryIsInstance: 'none',
        reportUnnecessaryCast: 'none',
        reportUnnecessaryComparison: 'none',
        reportUnnecessaryContains: 'none',
        reportAssertAlwaysTrue: 'warning',
        reportSelfClsParameterName: 'warning',
        reportImplicitStringConcatenation: 'none',
        reportUnboundVariable: 'error',
        reportUnhashable: 'error',
        reportUndefinedVariable: 'error',
        reportInvalidStubStatement: 'none',
        reportIncompleteStub: 'none',
        reportUnsupportedDunderAll: 'warning',
        reportUnusedCallResult: 'none',
        reportUnusedCoroutine: 'error',
        reportUnusedExcept: 'error',
        reportUnusedExpression: 'warning',
        reportUnnecessaryTypeIgnoreComment: 'none',
        reportMatchNotExhaustive: 'none',
        reportShadowedImports: 'none',
        reportImplicitOverride: 'none'
      };
    }
    function w() {
      return {
        printUnknownAsAny: false,
        omitTypeArgsIfUnknown: false,
        omitUnannotatedParamType: true,
        omitConditionalConstraint: false,
        pep604Printing: true,
        strictListInference: false,
        strictSetInference: false,
        strictDictionaryInference: false,
        analyzeUnannotatedFunctions: true,
        strictParameterNoneValue: true,
        enableExperimentalFeatures: false,
        enableTypeIgnoreComments: true,
        enableReachabilityAnalysis: true,
        deprecateTypingAliases: false,
        disableBytesTypePromotions: true,
        reportGeneralTypeIssues: 'error',
        reportPropertyTypeMismatch: 'none',
        reportFunctionMemberAccess: 'error',
        reportMissingImports: 'error',
        reportMissingModuleSource: 'warning',
        reportInvalidTypeForm: 'error',
        reportMissingTypeStubs: 'none',
        reportImportCycles: 'none',
        reportUnusedImport: 'none',
        reportUnusedClass: 'none',
        reportUnusedFunction: 'none',
        reportUnusedVariable: 'none',
        reportDuplicateImport: 'none',
        reportWildcardImportFromLibrary: 'warning',
        reportAbstractUsage: 'error',
        reportArgumentType: 'error',
        reportAssertTypeFailure: 'error',
        reportAssignmentType: 'error',
        reportAttributeAccessIssue: 'error',
        reportCallIssue: 'error',
        reportInconsistentOverload: 'error',
        reportIndexIssue: 'error',
        reportInvalidTypeArguments: 'error',
        reportNoOverloadImplementation: 'error',
        reportOperatorIssue: 'error',
        reportOptionalSubscript: 'error',
        reportOptionalMemberAccess: 'error',
        reportOptionalCall: 'error',
        reportOptionalIterable: 'error',
        reportOptionalContextManager: 'error',
        reportOptionalOperand: 'error',
        reportRedeclaration: 'error',
        reportReturnType: 'error',
        reportTypedDictNotRequiredAccess: 'error',
        reportUntypedFunctionDecorator: 'none',
        reportUntypedClassDecorator: 'none',
        reportUntypedBaseClass: 'none',
        reportUntypedNamedTuple: 'none',
        reportPrivateUsage: 'none',
        reportTypeCommentUsage: 'none',
        reportPrivateImportUsage: 'error',
        reportConstantRedefinition: 'none',
        reportDeprecated: 'none',
        reportIncompatibleMethodOverride: 'error',
        reportIncompatibleVariableOverride: 'error',
        reportInconsistentConstructor: 'none',
        reportOverlappingOverload: 'error',
        reportPossiblyUnboundVariable: 'error',
        reportMissingSuperCall: 'none',
        reportUninitializedInstanceVariable: 'none',
        reportInvalidStringEscapeSequence: 'warning',
        reportUnknownParameterType: 'none',
        reportUnknownArgumentType: 'none',
        reportUnknownLambdaType: 'none',
        reportUnknownVariableType: 'none',
        reportUnknownMemberType: 'none',
        reportMissingParameterType: 'none',
        reportMissingTypeArgument: 'none',
        reportInvalidTypeVarUse: 'warning',
        reportCallInDefaultInitializer: 'none',
        reportUnnecessaryIsInstance: 'none',
        reportUnnecessaryCast: 'none',
        reportUnnecessaryComparison: 'none',
        reportUnnecessaryContains: 'none',
        reportAssertAlwaysTrue: 'warning',
        reportSelfClsParameterName: 'warning',
        reportImplicitStringConcatenation: 'none',
        reportUnboundVariable: 'error',
        reportUnhashable: 'error',
        reportUndefinedVariable: 'error',
        reportInvalidStubStatement: 'none',
        reportIncompleteStub: 'none',
        reportUnsupportedDunderAll: 'warning',
        reportUnusedCallResult: 'none',
        reportUnusedCoroutine: 'error',
        reportUnusedExcept: 'error',
        reportUnusedExpression: 'warning',
        reportUnnecessaryTypeIgnoreComment: 'none',
        reportMatchNotExhaustive: 'none',
        reportShadowedImports: 'none',
        reportImplicitOverride: 'none'
      };
    }
    function S() {
      return {
        printUnknownAsAny: false,
        omitTypeArgsIfUnknown: false,
        omitUnannotatedParamType: false,
        omitConditionalConstraint: false,
        pep604Printing: true,
        strictListInference: true,
        strictSetInference: true,
        strictDictionaryInference: true,
        analyzeUnannotatedFunctions: true,
        strictParameterNoneValue: true,
        enableExperimentalFeatures: false,
        enableTypeIgnoreComments: true,
        enableReachabilityAnalysis: true,
        deprecateTypingAliases: false,
        disableBytesTypePromotions: true,
        reportGeneralTypeIssues: 'error',
        reportPropertyTypeMismatch: 'none',
        reportFunctionMemberAccess: 'error',
        reportMissingImports: 'error',
        reportMissingModuleSource: 'warning',
        reportInvalidTypeForm: 'error',
        reportMissingTypeStubs: 'error',
        reportImportCycles: 'none',
        reportUnusedImport: 'error',
        reportUnusedClass: 'error',
        reportUnusedFunction: 'error',
        reportUnusedVariable: 'error',
        reportDuplicateImport: 'error',
        reportWildcardImportFromLibrary: 'error',
        reportAbstractUsage: 'error',
        reportArgumentType: 'error',
        reportAssertTypeFailure: 'error',
        reportAssignmentType: 'error',
        reportAttributeAccessIssue: 'error',
        reportCallIssue: 'error',
        reportInconsistentOverload: 'error',
        reportIndexIssue: 'error',
        reportInvalidTypeArguments: 'error',
        reportNoOverloadImplementation: 'error',
        reportOperatorIssue: 'error',
        reportOptionalSubscript: 'error',
        reportOptionalMemberAccess: 'error',
        reportOptionalCall: 'error',
        reportOptionalIterable: 'error',
        reportOptionalContextManager: 'error',
        reportOptionalOperand: 'error',
        reportRedeclaration: 'error',
        reportReturnType: 'error',
        reportTypedDictNotRequiredAccess: 'error',
        reportUntypedFunctionDecorator: 'error',
        reportUntypedClassDecorator: 'error',
        reportUntypedBaseClass: 'error',
        reportUntypedNamedTuple: 'error',
        reportPrivateUsage: 'error',
        reportTypeCommentUsage: 'error',
        reportPrivateImportUsage: 'error',
        reportConstantRedefinition: 'error',
        reportDeprecated: 'error',
        reportIncompatibleMethodOverride: 'error',
        reportIncompatibleVariableOverride: 'error',
        reportInconsistentConstructor: 'error',
        reportOverlappingOverload: 'error',
        reportPossiblyUnboundVariable: 'error',
        reportMissingSuperCall: 'none',
        reportUninitializedInstanceVariable: 'none',
        reportInvalidStringEscapeSequence: 'error',
        reportUnknownParameterType: 'error',
        reportUnknownArgumentType: 'error',
        reportUnknownLambdaType: 'error',
        reportUnknownVariableType: 'error',
        reportUnknownMemberType: 'error',
        reportMissingParameterType: 'error',
        reportMissingTypeArgument: 'error',
        reportInvalidTypeVarUse: 'error',
        reportCallInDefaultInitializer: 'none',
        reportUnnecessaryIsInstance: 'error',
        reportUnnecessaryCast: 'error',
        reportUnnecessaryComparison: 'error',
        reportUnnecessaryContains: 'error',
        reportAssertAlwaysTrue: 'error',
        reportSelfClsParameterName: 'error',
        reportImplicitStringConcatenation: 'none',
        reportUnboundVariable: 'error',
        reportUnhashable: 'error',
        reportUndefinedVariable: 'error',
        reportInvalidStubStatement: 'error',
        reportIncompleteStub: 'error',
        reportUnsupportedDunderAll: 'error',
        reportUnusedCallResult: 'none',
        reportUnusedCoroutine: 'error',
        reportUnusedExcept: 'error',
        reportUnusedExpression: 'error',
        reportUnnecessaryTypeIgnoreComment: 'none',
        reportMatchNotExhaustive: 'error',
        reportShadowedImports: 'none',
        reportImplicitOverride: 'none'
      };
    }
    exports.ExecutionEnvironment = b;
    (function (e) {
      e.compact = 'compact';
      e.formatted = 'formatted';
    })(v || (exports.SignatureDisplayType = v = {}));
    class A {
      constructor(e) {
        this.include = [];
        this.exclude = [];
        this.ignore = [];
        this.strict = [];
        this.defineConstant = new Map();
        this.autoImportCompletions = true;
        this.indexing = false;
        this.logTypeEvaluationTime = false;
        this.typeEvaluationTimeThreshold = 50;
        this.initializedFromJson = false;
        this.disableTaggedHints = false;
        this.executionEnvironments = [];
        this.effectiveTypeCheckingMode = 'standard';
        this.projectRoot = e;
        this.diagnosticRuleSet = A.getDiagnosticRuleSet();
        this.functionSignatureDisplay = v.formatted;
      }
      static getDiagnosticRuleSet(e) {
        if (e === 'strict') {
          return {
            printUnknownAsAny: false,
            omitTypeArgsIfUnknown: false,
            omitUnannotatedParamType: false,
            omitConditionalConstraint: false,
            pep604Printing: true,
            strictListInference: true,
            strictSetInference: true,
            strictDictionaryInference: true,
            analyzeUnannotatedFunctions: true,
            strictParameterNoneValue: true,
            enableExperimentalFeatures: false,
            enableTypeIgnoreComments: true,
            enableReachabilityAnalysis: true,
            deprecateTypingAliases: false,
            disableBytesTypePromotions: true,
            reportGeneralTypeIssues: 'error',
            reportPropertyTypeMismatch: 'none',
            reportFunctionMemberAccess: 'error',
            reportMissingImports: 'error',
            reportMissingModuleSource: 'warning',
            reportInvalidTypeForm: 'error',
            reportMissingTypeStubs: 'error',
            reportImportCycles: 'none',
            reportUnusedImport: 'error',
            reportUnusedClass: 'error',
            reportUnusedFunction: 'error',
            reportUnusedVariable: 'error',
            reportDuplicateImport: 'error',
            reportWildcardImportFromLibrary: 'error',
            reportAbstractUsage: 'error',
            reportArgumentType: 'error',
            reportAssertTypeFailure: 'error',
            reportAssignmentType: 'error',
            reportAttributeAccessIssue: 'error',
            reportCallIssue: 'error',
            reportInconsistentOverload: 'error',
            reportIndexIssue: 'error',
            reportInvalidTypeArguments: 'error',
            reportNoOverloadImplementation: 'error',
            reportOperatorIssue: 'error',
            reportOptionalSubscript: 'error',
            reportOptionalMemberAccess: 'error',
            reportOptionalCall: 'error',
            reportOptionalIterable: 'error',
            reportOptionalContextManager: 'error',
            reportOptionalOperand: 'error',
            reportRedeclaration: 'error',
            reportReturnType: 'error',
            reportTypedDictNotRequiredAccess: 'error',
            reportUntypedFunctionDecorator: 'error',
            reportUntypedClassDecorator: 'error',
            reportUntypedBaseClass: 'error',
            reportUntypedNamedTuple: 'error',
            reportPrivateUsage: 'error',
            reportTypeCommentUsage: 'error',
            reportPrivateImportUsage: 'error',
            reportConstantRedefinition: 'error',
            reportDeprecated: 'error',
            reportIncompatibleMethodOverride: 'error',
            reportIncompatibleVariableOverride: 'error',
            reportInconsistentConstructor: 'error',
            reportOverlappingOverload: 'error',
            reportPossiblyUnboundVariable: 'error',
            reportMissingSuperCall: 'none',
            reportUninitializedInstanceVariable: 'none',
            reportInvalidStringEscapeSequence: 'error',
            reportUnknownParameterType: 'error',
            reportUnknownArgumentType: 'error',
            reportUnknownLambdaType: 'error',
            reportUnknownVariableType: 'error',
            reportUnknownMemberType: 'error',
            reportMissingParameterType: 'error',
            reportMissingTypeArgument: 'error',
            reportInvalidTypeVarUse: 'error',
            reportCallInDefaultInitializer: 'none',
            reportUnnecessaryIsInstance: 'error',
            reportUnnecessaryCast: 'error',
            reportUnnecessaryComparison: 'error',
            reportUnnecessaryContains: 'error',
            reportAssertAlwaysTrue: 'error',
            reportSelfClsParameterName: 'error',
            reportImplicitStringConcatenation: 'none',
            reportUnboundVariable: 'error',
            reportUnhashable: 'error',
            reportUndefinedVariable: 'error',
            reportInvalidStubStatement: 'error',
            reportIncompleteStub: 'error',
            reportUnsupportedDunderAll: 'error',
            reportUnusedCallResult: 'none',
            reportUnusedCoroutine: 'error',
            reportUnusedExcept: 'error',
            reportUnusedExpression: 'error',
            reportUnnecessaryTypeIgnoreComment: 'none',
            reportMatchNotExhaustive: 'error',
            reportShadowedImports: 'none',
            reportImplicitOverride: 'none'
          };
        } else {
          if (e === 'basic') {
            return {
              printUnknownAsAny: false,
              omitTypeArgsIfUnknown: false,
              omitUnannotatedParamType: true,
              omitConditionalConstraint: false,
              pep604Printing: true,
              strictListInference: false,
              strictSetInference: false,
              strictDictionaryInference: false,
              analyzeUnannotatedFunctions: true,
              strictParameterNoneValue: true,
              enableExperimentalFeatures: false,
              enableTypeIgnoreComments: true,
              enableReachabilityAnalysis: true,
              deprecateTypingAliases: false,
              disableBytesTypePromotions: true,
              reportGeneralTypeIssues: 'error',
              reportPropertyTypeMismatch: 'none',
              reportFunctionMemberAccess: 'none',
              reportMissingImports: 'error',
              reportMissingModuleSource: 'warning',
              reportInvalidTypeForm: 'error',
              reportMissingTypeStubs: 'none',
              reportImportCycles: 'none',
              reportUnusedImport: 'none',
              reportUnusedClass: 'none',
              reportUnusedFunction: 'none',
              reportUnusedVariable: 'none',
              reportDuplicateImport: 'none',
              reportWildcardImportFromLibrary: 'warning',
              reportAbstractUsage: 'error',
              reportArgumentType: 'error',
              reportAssertTypeFailure: 'error',
              reportAssignmentType: 'error',
              reportAttributeAccessIssue: 'error',
              reportCallIssue: 'error',
              reportInconsistentOverload: 'error',
              reportIndexIssue: 'error',
              reportInvalidTypeArguments: 'error',
              reportNoOverloadImplementation: 'error',
              reportOperatorIssue: 'error',
              reportOptionalSubscript: 'error',
              reportOptionalMemberAccess: 'error',
              reportOptionalCall: 'error',
              reportOptionalIterable: 'error',
              reportOptionalContextManager: 'error',
              reportOptionalOperand: 'error',
              reportRedeclaration: 'error',
              reportReturnType: 'error',
              reportTypedDictNotRequiredAccess: 'error',
              reportUntypedFunctionDecorator: 'none',
              reportUntypedClassDecorator: 'none',
              reportUntypedBaseClass: 'none',
              reportUntypedNamedTuple: 'none',
              reportPrivateUsage: 'none',
              reportTypeCommentUsage: 'none',
              reportPrivateImportUsage: 'error',
              reportConstantRedefinition: 'none',
              reportDeprecated: 'none',
              reportIncompatibleMethodOverride: 'none',
              reportIncompatibleVariableOverride: 'none',
              reportInconsistentConstructor: 'none',
              reportOverlappingOverload: 'none',
              reportPossiblyUnboundVariable: 'none',
              reportMissingSuperCall: 'none',
              reportUninitializedInstanceVariable: 'none',
              reportInvalidStringEscapeSequence: 'warning',
              reportUnknownParameterType: 'none',
              reportUnknownArgumentType: 'none',
              reportUnknownLambdaType: 'none',
              reportUnknownVariableType: 'none',
              reportUnknownMemberType: 'none',
              reportMissingParameterType: 'none',
              reportMissingTypeArgument: 'none',
              reportInvalidTypeVarUse: 'warning',
              reportCallInDefaultInitializer: 'none',
              reportUnnecessaryIsInstance: 'none',
              reportUnnecessaryCast: 'none',
              reportUnnecessaryComparison: 'none',
              reportUnnecessaryContains: 'none',
              reportAssertAlwaysTrue: 'warning',
              reportSelfClsParameterName: 'warning',
              reportImplicitStringConcatenation: 'none',
              reportUnboundVariable: 'error',
              reportUnhashable: 'error',
              reportUndefinedVariable: 'error',
              reportInvalidStubStatement: 'none',
              reportIncompleteStub: 'none',
              reportUnsupportedDunderAll: 'warning',
              reportUnusedCallResult: 'none',
              reportUnusedCoroutine: 'error',
              reportUnusedExcept: 'error',
              reportUnusedExpression: 'warning',
              reportUnnecessaryTypeIgnoreComment: 'none',
              reportMatchNotExhaustive: 'none',
              reportShadowedImports: 'none',
              reportImplicitOverride: 'none'
            };
          } else {
            if (e === 'off') {
              return {
                printUnknownAsAny: true,
                omitTypeArgsIfUnknown: true,
                omitUnannotatedParamType: true,
                omitConditionalConstraint: true,
                pep604Printing: true,
                strictListInference: false,
                strictSetInference: false,
                strictDictionaryInference: false,
                analyzeUnannotatedFunctions: true,
                strictParameterNoneValue: true,
                enableExperimentalFeatures: false,
                enableTypeIgnoreComments: true,
                enableReachabilityAnalysis: false,
                deprecateTypingAliases: false,
                disableBytesTypePromotions: true,
                reportGeneralTypeIssues: 'none',
                reportPropertyTypeMismatch: 'none',
                reportFunctionMemberAccess: 'none',
                reportMissingImports: 'warning',
                reportMissingModuleSource: 'warning',
                reportInvalidTypeForm: 'warning',
                reportMissingTypeStubs: 'none',
                reportImportCycles: 'none',
                reportUnusedImport: 'none',
                reportUnusedClass: 'none',
                reportUnusedFunction: 'none',
                reportUnusedVariable: 'none',
                reportDuplicateImport: 'none',
                reportWildcardImportFromLibrary: 'none',
                reportAbstractUsage: 'none',
                reportArgumentType: 'none',
                reportAssertTypeFailure: 'none',
                reportAssignmentType: 'none',
                reportAttributeAccessIssue: 'none',
                reportCallIssue: 'none',
                reportInconsistentOverload: 'none',
                reportIndexIssue: 'none',
                reportInvalidTypeArguments: 'none',
                reportNoOverloadImplementation: 'none',
                reportOperatorIssue: 'none',
                reportOptionalSubscript: 'none',
                reportOptionalMemberAccess: 'none',
                reportOptionalCall: 'none',
                reportOptionalIterable: 'none',
                reportOptionalContextManager: 'none',
                reportOptionalOperand: 'none',
                reportRedeclaration: 'none',
                reportReturnType: 'none',
                reportTypedDictNotRequiredAccess: 'none',
                reportUntypedFunctionDecorator: 'none',
                reportUntypedClassDecorator: 'none',
                reportUntypedBaseClass: 'none',
                reportUntypedNamedTuple: 'none',
                reportPrivateUsage: 'none',
                reportTypeCommentUsage: 'none',
                reportPrivateImportUsage: 'none',
                reportConstantRedefinition: 'none',
                reportDeprecated: 'none',
                reportIncompatibleMethodOverride: 'none',
                reportIncompatibleVariableOverride: 'none',
                reportInconsistentConstructor: 'none',
                reportOverlappingOverload: 'none',
                reportPossiblyUnboundVariable: 'none',
                reportMissingSuperCall: 'none',
                reportUninitializedInstanceVariable: 'none',
                reportInvalidStringEscapeSequence: 'none',
                reportUnknownParameterType: 'none',
                reportUnknownArgumentType: 'none',
                reportUnknownLambdaType: 'none',
                reportUnknownVariableType: 'none',
                reportUnknownMemberType: 'none',
                reportMissingParameterType: 'none',
                reportMissingTypeArgument: 'none',
                reportInvalidTypeVarUse: 'none',
                reportCallInDefaultInitializer: 'none',
                reportUnnecessaryIsInstance: 'none',
                reportUnnecessaryCast: 'none',
                reportUnnecessaryComparison: 'none',
                reportUnnecessaryContains: 'none',
                reportAssertAlwaysTrue: 'none',
                reportSelfClsParameterName: 'none',
                reportImplicitStringConcatenation: 'none',
                reportUnboundVariable: 'none',
                reportUnhashable: 'none',
                reportUndefinedVariable: 'warning',
                reportInvalidStubStatement: 'none',
                reportIncompleteStub: 'none',
                reportUnsupportedDunderAll: 'none',
                reportUnusedCallResult: 'none',
                reportUnusedCoroutine: 'none',
                reportUnusedExcept: 'none',
                reportUnusedExpression: 'none',
                reportUnnecessaryTypeIgnoreComment: 'none',
                reportMatchNotExhaustive: 'none',
                reportShadowedImports: 'none',
                reportImplicitOverride: 'none'
              };
            } else {
              return {
                printUnknownAsAny: false,
                omitTypeArgsIfUnknown: false,
                omitUnannotatedParamType: true,
                omitConditionalConstraint: false,
                pep604Printing: true,
                strictListInference: false,
                strictSetInference: false,
                strictDictionaryInference: false,
                analyzeUnannotatedFunctions: true,
                strictParameterNoneValue: true,
                enableExperimentalFeatures: false,
                enableTypeIgnoreComments: true,
                enableReachabilityAnalysis: true,
                deprecateTypingAliases: false,
                disableBytesTypePromotions: true,
                reportGeneralTypeIssues: 'error',
                reportPropertyTypeMismatch: 'none',
                reportFunctionMemberAccess: 'error',
                reportMissingImports: 'error',
                reportMissingModuleSource: 'warning',
                reportInvalidTypeForm: 'error',
                reportMissingTypeStubs: 'none',
                reportImportCycles: 'none',
                reportUnusedImport: 'none',
                reportUnusedClass: 'none',
                reportUnusedFunction: 'none',
                reportUnusedVariable: 'none',
                reportDuplicateImport: 'none',
                reportWildcardImportFromLibrary: 'warning',
                reportAbstractUsage: 'error',
                reportArgumentType: 'error',
                reportAssertTypeFailure: 'error',
                reportAssignmentType: 'error',
                reportAttributeAccessIssue: 'error',
                reportCallIssue: 'error',
                reportInconsistentOverload: 'error',
                reportIndexIssue: 'error',
                reportInvalidTypeArguments: 'error',
                reportNoOverloadImplementation: 'error',
                reportOperatorIssue: 'error',
                reportOptionalSubscript: 'error',
                reportOptionalMemberAccess: 'error',
                reportOptionalCall: 'error',
                reportOptionalIterable: 'error',
                reportOptionalContextManager: 'error',
                reportOptionalOperand: 'error',
                reportRedeclaration: 'error',
                reportReturnType: 'error',
                reportTypedDictNotRequiredAccess: 'error',
                reportUntypedFunctionDecorator: 'none',
                reportUntypedClassDecorator: 'none',
                reportUntypedBaseClass: 'none',
                reportUntypedNamedTuple: 'none',
                reportPrivateUsage: 'none',
                reportTypeCommentUsage: 'none',
                reportPrivateImportUsage: 'error',
                reportConstantRedefinition: 'none',
                reportDeprecated: 'none',
                reportIncompatibleMethodOverride: 'error',
                reportIncompatibleVariableOverride: 'error',
                reportInconsistentConstructor: 'none',
                reportOverlappingOverload: 'error',
                reportPossiblyUnboundVariable: 'error',
                reportMissingSuperCall: 'none',
                reportUninitializedInstanceVariable: 'none',
                reportInvalidStringEscapeSequence: 'warning',
                reportUnknownParameterType: 'none',
                reportUnknownArgumentType: 'none',
                reportUnknownLambdaType: 'none',
                reportUnknownVariableType: 'none',
                reportUnknownMemberType: 'none',
                reportMissingParameterType: 'none',
                reportMissingTypeArgument: 'none',
                reportInvalidTypeVarUse: 'warning',
                reportCallInDefaultInitializer: 'none',
                reportUnnecessaryIsInstance: 'none',
                reportUnnecessaryCast: 'none',
                reportUnnecessaryComparison: 'none',
                reportUnnecessaryContains: 'none',
                reportAssertAlwaysTrue: 'warning',
                reportSelfClsParameterName: 'warning',
                reportImplicitStringConcatenation: 'none',
                reportUnboundVariable: 'error',
                reportUnhashable: 'error',
                reportUndefinedVariable: 'error',
                reportInvalidStubStatement: 'none',
                reportIncompleteStub: 'none',
                reportUnsupportedDunderAll: 'warning',
                reportUnusedCallResult: 'none',
                reportUnusedCoroutine: 'error',
                reportUnusedExcept: 'error',
                reportUnusedExpression: 'warning',
                reportUnnecessaryTypeIgnoreComment: 'none',
                reportMatchNotExhaustive: 'none',
                reportShadowedImports: 'none',
                reportImplicitOverride: 'none'
              };
            }
          }
        }
      }
      getDefaultExecEnvironment() {
        return new b(this._getEnvironmentName(), this.projectRoot, this.diagnosticRuleSet, this.defaultPythonVersion, this.defaultPythonPlatform, this.defaultExtraPaths, this.skipNativeLibraries);
      }
      findExecEnvironment(e) {
        var t;
        if ((t = this.executionEnvironments.find(t => {
          const n = h.Uri.is(t.root) ? t.root : this.projectRoot.resolvePaths(t.root || '');
          return e.startsWith(n);
        })) !== null && t !== undefined) {
          return t;
        } else {
          return this.getDefaultExecEnvironment();
        }
      }
      getExecutionEnvironments() {
        if (this.executionEnvironments.length > 0) {
          return this.executionEnvironments;
        } else {
          return [this.getDefaultExecEnvironment()];
        }
      }
      initializeTypeCheckingMode(e, t) {
        this.diagnosticRuleSet = A.getDiagnosticRuleSet(e);
        this.effectiveTypeCheckingMode = e;
        if (t) {
          this.applyDiagnosticOverrides(t);
        }
      }
      initializeFromJson(e, t, n, a) {
        var r;
        this.initializedFromJson = true;
        const s = (r = n.tryGet(g.ServiceKeys.console)) !== null && r !== undefined ? r : new c.NullConsole();
        if (e.include !== undefined) {
          if (Array.isArray(e.include)) {
            this.include = [];
            e.include.forEach((e, n) => {
              if (typeof e != 'string') {
                s.error(`Index ${n} of "include" array should be a string.`);
              } else {
                if (i.isAbsolute(e)) {
                  s.error(`Ignoring path "${e}" in "include" array because it is not relative.`);
                } else {
                  this.include.push(f.getFileSpec(t, e));
                }
              }
            });
          } else {
            s.error('Config "include" entry must contain an array.');
          }
        }
        if (e.exclude !== undefined) {
          if (Array.isArray(e.exclude)) {
            this.exclude = [];
            e.exclude.forEach((e, n) => {
              if (typeof e != 'string') {
                s.error(`Index ${n} of "exclude" array should be a string.`);
              } else {
                if (i.isAbsolute(e)) {
                  s.error(`Ignoring path "${e}" in "exclude" array because it is not relative.`);
                } else {
                  this.exclude.push(f.getFileSpec(t, e));
                }
              }
            });
          } else {
            s.error('Config "exclude" entry must contain an array.');
          }
        }
        if (e.ignore !== undefined) {
          if (Array.isArray(e.ignore)) {
            this.ignore = [];
            e.ignore.forEach((e, n) => {
              if (typeof e != 'string') {
                s.error(`Index ${n} of "ignore" array should be a string.`);
              } else {
                this.ignore.push(f.getFileSpec(t, e));
              }
            });
          } else {
            s.error('Config "ignore" entry must contain an array.');
          }
        }
        if (e.strict !== undefined) {
          if (Array.isArray(e.strict)) {
            this.strict = [];
            e.strict.forEach((e, n) => {
              if (typeof e != 'string') {
                s.error(`Index ${n} of "strict" array should be a string.`);
              } else {
                if (i.isAbsolute(e)) {
                  s.error(`Ignoring path "${e}" in "strict" array because it is not relative.`);
                } else {
                  this.strict.push(f.getFileSpec(t, e));
                }
              }
            });
          } else {
            s.error('Config "strict" entry must contain an array.');
          }
        }
        if (e.typeCheckingMode !== undefined) {
          if (e.typeCheckingMode === 'off' || e.typeCheckingMode === 'basic' || e.typeCheckingMode === 'standard' || e.typeCheckingMode === 'strict') {
            this.initializeTypeCheckingMode(e.typeCheckingMode);
          } else {
            s.error('Config "typeCheckingMode" entry must contain "off", "basic", "standard", or "strict".');
          }
        }
        if (e.useLibraryCodeForTypes !== undefined) {
          if (typeof e.useLibraryCodeForTypes == 'boolean') {
            this.useLibraryCodeForTypes = e.useLibraryCodeForTypes;
          } else {
            s.error('Config "useLibraryCodeForTypes" entry must be true or false.');
          }
        }
        const o = {
          ...this.diagnosticRuleSet
        };
        _(true).forEach(t => {
          o[t] = this._convertBoolean(e[t], t, o[t]);
        });
        C().forEach(t => {
          o[t] = this._convertDiagnosticLevel(e[t], t, o[t]);
        });
        this.diagnosticRuleSet = {
          ...o
        };
        if (e.venvPath !== undefined) {
          if (typeof e.venvPath != 'string') {
            s.error('Config "venvPath" field must contain a string.');
          } else {
            this.venvPath = t.resolvePaths(e.venvPath);
          }
        }
        if (e.venv !== undefined) {
          if (typeof e.venv != 'string') {
            s.error('Config "venv" field must contain a string.');
          } else {
            this.venv = e.venv;
          }
        }
        const l = [];
        if (e.extraPaths !== undefined) {
          if (Array.isArray(e.extraPaths)) {
            e.extraPaths.forEach((e, n) => {
              if (typeof e != 'string') {
                s.error(`Config "extraPaths" field ${n} must be a string.`);
              } else {
                l.push(t.resolvePaths(e));
              }
            });
            this.defaultExtraPaths = [...l];
          } else {
            s.error('Config "extraPaths" field must contain an array.');
          }
        }
        if (e.pythonVersion !== undefined) {
          if (typeof e.pythonVersion == 'string') {
            const t = y.PythonVersion.fromString(e.pythonVersion);
            if (t) {
              this.defaultPythonVersion = t;
            } else {
              s.error('Config "pythonVersion" field contains unsupported version.');
            }
          } else {
            s.error('Config "pythonVersion" field must contain a string.');
          }
        }
        if (e.pythonPlatform !== undefined) {
          if (typeof e.pythonPlatform != 'string') {
            s.error('Config "pythonPlatform" field must contain a string.');
          } else {
            this.defaultPythonPlatform = e.pythonPlatform;
          }
        }
        if (e.skipNativeLibraries) {
          if (typeof e.skipNativeLibraries == 'boolean') {
            this.skipNativeLibraries = e.skipNativeLibraries;
          } else {
            s.error('Config "skipNativeLibraries" field must contain a boolean.');
          }
        }
        if (e.typeshedPath !== undefined) {
          if (typeof e.typeshedPath != 'string') {
            s.error('Config "typeshedPath" field must contain a string.');
          } else {
            this.typeshedPath = e.typeshedPath ? t.resolvePaths(e.typeshedPath) : undefined;
          }
        }
        if (e.typingsPath !== undefined) {
          if (typeof e.typingsPath != 'string') {
            s.error('Config "typingsPath" field must contain a string.');
          } else {
            s.error('Config "typingsPath" is now deprecated. Please, use stubPath instead.');
            this.stubPath = t.resolvePaths(e.typingsPath);
          }
        }
        if (e.stubPath !== undefined) {
          if (typeof e.stubPath != 'string') {
            s.error('Config "stubPath" field must contain a string.');
          } else {
            this.stubPath = t.resolvePaths(e.stubPath);
          }
        }
        if (e.verboseOutput !== undefined) {
          if (typeof e.verboseOutput != 'boolean') {
            s.error('Config "verboseOutput" field must be true or false.');
          } else {
            this.verboseOutput = e.verboseOutput;
          }
        }
        if (e.defineConstant !== undefined) {
          if (typeof e.defineConstant != 'object' || Array.isArray(e.defineConstant)) {
            s.error('Config "defineConstant" field must contain a map indexed by constant names.');
          } else {
            Object.getOwnPropertyNames(e.defineConstant).forEach(t => {
              const n = e.defineConstant[t];
              const a = typeof n;
              if (a !== 'boolean' && a !== 'string') {
                s.error(`Defined constant "${t}" must be associated with a boolean or string value.`);
              } else {
                this.defineConstant.set(t, n);
              }
            });
          }
        }
        if (e.useLibraryCodeForTypes !== undefined) {
          if (typeof e.useLibraryCodeForTypes != 'boolean') {
            s.error('Config "useLibraryCodeForTypes" field must be true or false.');
          } else {
            this.useLibraryCodeForTypes = e.useLibraryCodeForTypes;
          }
        }
        if (e.autoImportCompletions !== undefined) {
          if (typeof e.autoImportCompletions != 'boolean') {
            s.error('Config "autoImportCompletions" field must be true or false.');
          } else {
            this.autoImportCompletions = e.autoImportCompletions;
          }
        }
        if (e.indexing !== undefined) {
          if (typeof e.indexing != 'boolean') {
            s.error('Config "indexing" field must be true or false.');
          } else {
            this.indexing = e.indexing;
          }
        }
        if (e.logTypeEvaluationTime !== undefined) {
          if (typeof e.logTypeEvaluationTime != 'boolean') {
            s.error('Config "logTypeEvaluationTime" field must be true or false.');
          } else {
            this.logTypeEvaluationTime = e.logTypeEvaluationTime;
          }
        }
        if (e.typeEvaluationTimeThreshold !== undefined) {
          if (typeof e.typeEvaluationTimeThreshold != 'number') {
            s.error('Config "typeEvaluationTimeThreshold" field must be a number.');
          } else {
            this.typeEvaluationTimeThreshold = e.typeEvaluationTimeThreshold;
          }
        }
        if (e.functionSignatureDisplay !== undefined) {
          if (typeof e.functionSignatureDisplay != 'string') {
            s.error('Config "functionSignatureDisplay" field must be true or false.');
          } else {
            if (e.functionSignatureDisplay === 'compact' || e.functionSignatureDisplay === 'formatted') {
              this.functionSignatureDisplay = e.functionSignatureDisplay;
            }
          }
        }
      }
      static resolveExtends(e, t) {
        if (e.extends !== undefined) {
          if (typeof e.extends == 'string') {
            return t.resolvePaths(e.extends);
          }
          console.error('Config "extends" field must contain a string.');
        }
      }
      ensureDefaultPythonPlatform(e, t) {
        if (this.defaultPythonPlatform === undefined) {
          this.defaultPythonPlatform = e.getPythonPlatform();
          if (this.defaultPythonPlatform !== undefined) {
            t.log(`Assuming Python platform ${this.defaultPythonPlatform}`);
          }
        }
      }
      ensureDefaultPythonVersion(e, t) {
        if (this.defaultPythonVersion !== undefined) {
          return;
        }
        const n = [];
        this.defaultPythonVersion = e.getPythonVersion(this.pythonPath, n);
        if (this.defaultPythonVersion !== undefined) {
          t.info(`Assuming Python version ${y.PythonVersion.toString(this.defaultPythonVersion)}`);
        }
        for (const e of n) {
          t.info(e);
        }
      }
      ensureDefaultExtraPaths(e, t, n) {
        const a = [];
        if (t) {
          const t = this.projectRoot.resolvePaths(l.src);
          if (e.existsSync(t) && !e.existsSync(t.resolvePaths('__init__.py'))) {
            a.push(e.realCasePath(t));
          }
        }
        if (n && n.length > 0) {
          for (const t of n) {
            const n = this.projectRoot.resolvePaths(t);
            a.push(e.realCasePath(n));
            if (f.isDirectory(e, n)) {
              p.appendArray(a, o.getPathsFromPthFiles(e, n));
            }
          }
        }
        if (a.length > 0) {
          this.defaultExtraPaths = a;
        }
      }
      applyDiagnosticOverrides(e) {
        if (e) {
          for (const t of C()) {
            const n = e[t];
            if (n !== undefined && !u.isBoolean(n) && d.getDiagnosticSeverityOverrides().includes(n)) {
              this.diagnosticRuleSet[t] = n;
            }
          }
          for (const t of _(true)) {
            const n = e[t];
            if (n !== undefined && u.isBoolean(n)) {
              this.diagnosticRuleSet[t] = n;
            }
          }
        }
      }
      setupExecutionEnvironments(e, t, n) {
        if (e.executionEnvironments !== undefined) {
          if (Array.isArray(e.executionEnvironments)) {
            this.executionEnvironments = [];
            e.executionEnvironments.forEach((e, a) => {
              const r = this._initExecutionEnvironmentFromJson(e, t, a, n, this.diagnosticRuleSet, this.defaultPythonVersion, this.defaultPythonPlatform, this.defaultExtraPaths || []);
              if (r) {
                this.executionEnvironments.push(r);
              }
            });
          } else {
            n.error('Config "executionEnvironments" field must contain an array.');
          }
        }
      }
      _getEnvironmentName() {
        var e;
        return this.pythonEnvironmentName || ((e = this.pythonPath) === null || e === undefined ? undefined : e.toString()) || 'python';
      }
      _convertBoolean(e, t, n) {
        if (e === undefined) {
          return n;
        } else {
          if (typeof e == 'boolean') {
            return !!e;
          } else {
            console.log(`Config "${t}" entry must be true or false.`);
            return n;
          }
        }
      }
      _convertDiagnosticLevel(e, t, n) {
        if (e === undefined) {
          return n;
        } else {
          if (typeof e == 'boolean') {
            if (e) {
              return 'error';
            } else {
              return 'none';
            }
          } else {
            if (typeof e != 'string' || e !== 'error' && e !== 'warning' && e !== 'information' && e !== 'none') {
              console.log(`Config "${t}" entry must be true, false, "error", "warning", "information" or "none".`);
              return n;
            } else {
              return e;
            }
          }
        }
      }
      _initExecutionEnvironmentFromJson(e, t, n, a, r, s, i, o) {
        try {
          const l = new b(this._getEnvironmentName(), t, r, s, i, o);
          if (e.root && typeof e.root == 'string') {
            l.root = t.resolvePaths(e.root);
          } else {
            a.error(`Config executionEnvironments index ${n}: missing root value.`);
          }
          if (e.extraPaths) {
            if (Array.isArray(e.extraPaths)) {
              e.extraPaths.forEach((e, r) => {
                if (typeof e != 'string') {
                  a.error(`Config executionEnvironments index ${n}: extraPaths field ${r} must be a string.`);
                } else {
                  l.extraPaths.push(t.resolvePaths(e));
                }
              });
            } else {
              a.error(`Config executionEnvironments index ${n}: extraPaths field must contain an array.`);
            }
          }
          if (e.pythonVersion) {
            if (typeof e.pythonVersion == 'string') {
              const t = y.PythonVersion.fromString(e.pythonVersion);
              if (t) {
                l.pythonVersion = t;
              } else {
                a.warn(`Config executionEnvironments index ${n} contains unsupported pythonVersion.`);
              }
            } else {
              a.error(`Config executionEnvironments index ${n} pythonVersion must be a string.`);
            }
          }
          if (e.pythonPlatform) {
            if (typeof e.pythonPlatform == 'string') {
              l.pythonPlatform = e.pythonPlatform;
            } else {
              a.error(`Config executionEnvironments index ${n} pythonPlatform must be a string.`);
            }
          }
          if (e.name) {
            if (typeof e.name == 'string') {
              l.name = e.name;
            } else {
              a.error(`Config executionEnvironments index ${n} name must be a string.`);
            }
          }
          _(true).forEach(t => {
            l.diagnosticRuleSet[t] = this._convertBoolean(e[t], t, l.diagnosticRuleSet[t]);
          });
          C().forEach(t => {
            l.diagnosticRuleSet[t] = this._convertDiagnosticLevel(e[t], t, l.diagnosticRuleSet[t]);
          });
          return l;
        } catch {
          a.error(`Config executionEnvironments index ${n} is not accessible.`);
        }
      }
    }
    exports.ConfigOptions = A;
  },
  25075: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ConsoleWithLogLevel = exports.Chainable = exports.StderrConsole = exports.StandardConsole = exports.NullConsole = exports.ConsoleInterface = exports.LogLevel = undefined;
    exports.getLevelNumber = c;
    exports.log = m;
    exports.convertLogLevel = function (e) {
      if (!e) {
        return l.Info;
      }
      switch (e.toLowerCase()) {
        case 'error':
          return l.Error;
        case 'warning':
          return l.Warn;
        case 'information':
        default:
          return l.Info;
        case 'trace':
          return l.Log;
      }
    };
    const i = __importStar(require(48281));
    const o = require(58147);
    var l;
    var p;
    (function (e) {
      e.Error = 'error';
      e.Warn = 'warn';
      e.Info = 'info';
      e.Log = 'log';
    })(l || (exports.LogLevel = l = {}));
    (function (e) {
      function t(e) {
        return e.error !== undefined && e.warn !== undefined && e.info !== undefined && e.log !== undefined;
      }
      e.is = t;
      e.hasLevel = function (e) {
        return t(e) && 'level' in e;
      };
    })(p || (exports.ConsoleInterface = p = {}));
    const d = new Map([[l.Error, 0], [l.Warn, 1], [l.Info, 2], [l.Log, 3]]);
    function c(e) {
      var t;
      if ((t = d.get(e)) !== null && t !== undefined) {
        return t;
      } else {
        return 3;
      }
    }
    exports.NullConsole = class {
      constructor() {
        this.logCount = 0;
        this.infoCount = 0;
        this.warnCount = 0;
        this.errorCount = 0;
      }
      log(e) {
        this.logCount++;
      }
      info(e) {
        this.infoCount++;
      }
      warn(e) {
        this.warnCount++;
      }
      error(e) {
        this.errorCount++;
      }
    };
    exports.StandardConsole = class {
      constructor(e = l.Log) {
        this._maxLevel = e;
      }
      get level() {
        return this._maxLevel;
      }
      log(e) {
        if (c(this._maxLevel) >= c(l.Log)) {
          console.log(e);
        }
      }
      info(e) {
        if (c(this._maxLevel) >= c(l.Info)) {
          console.info(e);
        }
      }
      warn(e) {
        if (c(this._maxLevel) >= c(l.Warn)) {
          console.warn(e);
        }
      }
      error(e) {
        if (c(this._maxLevel) >= c(l.Error)) {
          console.error(e);
        }
      }
    };
    var u;
    exports.StderrConsole = class {
      constructor(e = l.Log) {
        this._maxLevel = e;
      }
      get level() {
        return this._maxLevel;
      }
      log(e) {
        if (c(this._maxLevel) >= c(l.Log)) {
          console.error(e);
        }
      }
      info(e) {
        if (c(this._maxLevel) >= c(l.Info)) {
          console.error(e);
        }
      }
      warn(e) {
        if (c(this._maxLevel) >= c(l.Warn)) {
          console.error(e);
        }
      }
      error(e) {
        if (c(this._maxLevel) >= c(l.Error)) {
          console.error(e);
        }
      }
    };
    (function (e) {
      e.is = function (e) {
        return e && e.addChain && e.removeChain;
      };
    })(u || (exports.Chainable = u = {}));
    function m(e, t, n) {
      switch (t) {
        case l.Log:
          e.log(n);
          break;
        case l.Info:
          e.info(n);
          break;
        case l.Warn:
          e.warn(n);
          break;
        case l.Error:
          e.error(n);
          break;
        default:
          i.fail(`${t} is not expected`);
      }
    }
    exports.ConsoleWithLogLevel = class {
      constructor(e, t = '') {
        this._console = e;
        this._name = t;
        this._chains = [];
        this._maxLevel = 2;
        this._disposed = false;
      }
      get level() {
        switch (this._maxLevel) {
          case 0:
            return l.Error;
          case 1:
            return l.Warn;
          case 2:
            return l.Info;
        }
        return l.Log;
      }
      set level(e) {
        let t = c(e);
        if (t === undefined) {
          t = c(l.Info);
        }
        this._maxLevel = t;
      }
      dispose() {
        this._disposed = true;
      }
      error(e) {
        this._log(l.Error, `${this._prefix}${e}`);
      }
      warn(e) {
        this._log(l.Warn, `${this._prefix}${e}`);
      }
      info(e) {
        this._log(l.Info, `${this._prefix}${e}`);
      }
      log(e) {
        this._log(l.Log, `${this._prefix}${e}`);
      }
      addChain(e) {
        o.addIfUnique(this._chains, e);
      }
      removeChain(e) {
        o.removeArrayElements(this._chains, t => t === e);
      }
      get _prefix() {
        if (this._name) {
          return `(${this._name}) `;
        } else {
          return '';
        }
      }
      _log(e, t) {
        if (!this._disposed) {
          this._processChains(e, t);
          if (!(this._getNumericalLevel(e) > this._maxLevel)) {
            m(this._console, e, t);
          }
        }
      }
      _getNumericalLevel(e) {
        const t = c(e);
        i.assert(t !== undefined, 'Logger: unknown log level.');
        if (t !== undefined) {
          return t;
        } else {
          return 2;
        }
      }
      _processChains(e, t) {
        this._chains.forEach(n => m(n, e, t));
      }
    };
  },
  34455: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Disposable = undefined;
    exports.returnFalse = function () {
      return false;
    };
    exports.returnTrue = function () {
      return true;
    };
    exports.returnUndefined = function () {
      return;
    };
    exports.identity = function (e) {
      return e;
    };
    exports.toLowerCase = function (e) {
      return e.toLowerCase();
    };
    exports.equateValues = function (e, t) {
      return e === t;
    };
    exports.compareComparableValues = r;
    exports.compareValues = function (e, t) {
      return r(e, t);
    };
    exports.isArray = function (e) {
      if (Array.isArray) {
        return Array.isArray(e);
      } else {
        return e instanceof Array;
      }
    };
    exports.isString = function (e) {
      return typeof e == 'string';
    };
    exports.isNumber = function (e) {
      return typeof e == 'number';
    };
    exports.isBoolean = function (e) {
      return typeof e == 'boolean';
    };
    exports.hasProperty = function (e, t) {
      return s.call(e, t);
    };
    exports.toBoolean = function (e) {
      if ((e == null ? undefined : e.trim().toUpperCase()) === 'TRUE') {
        return true;
      }
      return false;
    };
    exports.test_setDebugMode = function (e) {
      const t = i;
      i = e;
      return t;
    };
    exports.isDebugMode = function () {
      if (i === undefined) {
        const e = process.execArgv.join();
        i = e.includes('inspect') || e.includes('debug');
      }
      return i;
    };
    exports.isThenable = function (e) {
      return typeof (e == null ? undefined : e.then) == 'function';
    };
    exports.isDefined = function (e) {
      return e !== undefined;
    };
    exports.getEnumNames = function (e) {
      const t = [];
      for (const n in e) {
        if (isNaN(Number(n))) {
          t.push(n);
        }
      }
      return t;
    };
    exports.containsOnlyWhitespace = function (e, t) {
      if (t) {
        e = e.substring(t.start, a.TextRange.getEnd(t));
      }
      return /^\s*$/.test(e);
    };
    const a = require(88754);
    function r(e, t) {
      if (e === t) {
        return 0;
      } else {
        if (e === undefined) {
          return -1;
        } else {
          if (t === undefined) {
            return 1;
          } else {
            if (e < t) {
              return -1;
            } else {
              return 1;
            }
          }
        }
      }
    }
    const s = Object.prototype.hasOwnProperty;
    let i;
    var o;
    (function (e) {
      e.is = function (e) {
        return e && typeof e.dispose == 'function';
      };
    })(o || (exports.Disposable = o = {}));
  },
  77313: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.randomBytesHex = function (e) {
      if (r) {
        return r.randomBytes(e).toString('hex');
      }
      if (crypto) {
        const n = crypto.getRandomValues(new Uint8Array(e));
        t = n;
        return [...t].map(e => e.toString(16).padStart(2, '0')).join('');
      }
      var t;
      a.fail('crypto library not found');
    };
    const a = require(48281);
    let r;
    try {
      r = require(76982);
      if (!(r == null ? undefined : r.randomBytes)) {
        r = undefined;
      }
    } catch {}
  },
  48281: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.assert = function e(t, n, a, r) {
      if (!t) {
        if (a) {
          n += `\r
Verbose Debug Information: ${typeof a == 'string' ? a : a()}`;
        }
        s(n ? `False expression: ${n}` : 'False expression.', r || e);
      }
    };
    exports.fail = s;
    exports.assertDefined = i;
    exports.assertEachDefined = function e(t, n, a) {
      for (const r of t) {
        i(r, n, a || e);
      }
    };
    exports.assertNever = function e(t, n = 'Illegal value:', a) {
      let r = '';
      try {
        r = JSON.stringify(t);
      } catch {}
      s(`${n} ${r}`, a || e);
    };
    exports.getFunctionName = function (e) {
      if (typeof e != 'function') {
        return '';
      }
      if (r.hasProperty(e, 'name')) {
        return e.name;
      }
      {
        const t = Function.prototype.toString.call(e);
        const n = /^function\s+([\w$]+)\s*\(/.exec(t);
        if (n) {
          return n[1];
        } else {
          return '';
        }
      }
    };
    exports.formatEnum = function (e = 0, t, n) {
      const s = function (e) {
        const t = [];
        for (const n of Object.keys(e)) {
          const a = e[n];
          if (typeof a == 'number') {
            t.push([a, n]);
          }
        }
        return a.stableSort(t, (e, t) => r.compareValues(e[0], t[0]));
      }(t);
      if (e === 0) {
        if (s.length > 0 && s[0][0] === 0) {
          return s[0][1];
        } else {
          return '0';
        }
      }
      if (n) {
        let t = '';
        let n = e;
        for (const [a, r] of s) {
          if (a > e) {
            break;
          }
          if (a !== 0 && a & e) {
            t = `${t}${t ? '|' : ''}${r}`;
            n &= ~a;
          }
        }
        if (n === 0) {
          return t;
        }
      } else {
        for (const [t, n] of s) {
          if (t === e) {
            return n;
          }
        }
      }
      return e.toString();
    };
    exports.getErrorString = function (e) {
      return (e.stack ? e.stack.toString() : undefined) || (typeof e.message == 'string' ? e.message : undefined) || JSON.stringify(e);
    };
    exports.getSerializableError = function (e) {
      if (!e) {
        return;
      }
      if (JSON.stringify(e).length > 2) {
        return e;
      }
      const t = e.name && r.isString(e.name) ? e.name : 'noname';
      const n = e.message && r.isString(e.message) ? e.message : 'nomessage';
      const a = e.stack && r.isString(e.stack) ? e.stack : undefined;
      return {
        name: t,
        message: n,
        stack: a
      };
    };
    const a = require(58147);
    const r = require(34455);
    function s(e, t) {
      const n = new Error(e ? `Debug Failure. ${e}` : 'Debug Failure.');
      if (Error.captureStackTrace) {
        Error.captureStackTrace(n, t || s);
      }
      throw n;
    }
    function i(e, t, n) {
      if (e == null) {
        s(t, n || i);
      }
    }
  },
  51507: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createDeferred = a;
    exports.createDeferredFrom = function (...e) {
      const t = a();
      Promise.all(e).then(t.resolve.bind(t)).catch(t.reject.bind(t));
      return t;
    };
    exports.createDeferredFromPromise = function (e) {
      const t = a();
      e.then(t.resolve.bind(t)).catch(t.reject.bind(t));
      return t;
    };
    class n {
      constructor(e = null) {
        this._scope = e;
        this._resolved = false;
        this._rejected = false;
        this._promise = new Promise((e, t) => {
          this._resolve = e;
          this._reject = t;
        });
      }
      get promise() {
        return this._promise;
      }
      get resolved() {
        return this._resolved;
      }
      get rejected() {
        return this._rejected;
      }
      get completed() {
        return this._rejected || this._resolved;
      }
      resolve(e) {
        this._resolve.apply(this._scope ? this._scope : this, arguments);
        this._resolved = true;
      }
      reject(e) {
        this._reject.apply(this._scope ? this._scope : this, arguments);
        this._rejected = true;
      }
    }
    function a(e = null) {
      return new n(e);
    }
  },
  11479: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DiagnosticAddendum = exports.Diagnostic = exports.DiagnosticRelatedInfo = exports.TaskListPriority = exports.defaultMaxDiagnosticLineCount = exports.defaultMaxDiagnosticDepth = undefined;
    exports.convertLevelToCategory = function (e) {
      switch (e) {
        case 'error':
          return 0;
        case 'warning':
          return 1;
        case 'information':
          return 2;
        default:
          throw new Error(`${e} is not expected`);
      }
    };
    exports.compareDiagnostics = function (e, t) {
      if (e.range.start.line < t.range.start.line) {
        return -1;
      }
      if (e.range.start.line > t.range.start.line) {
        return 1;
      }
      if (e.range.start.character < t.range.start.character) {
        return -1;
      }
      if (e.range.start.character > t.range.start.character) {
        return 1;
      }
      return 0;
    };
    const a = require(58147);
    const r = require(27113);
    exports.defaultMaxDiagnosticDepth = 5;
    exports.defaultMaxDiagnosticLineCount = 8;
    var s;
    var i;
    (function (e) {
      e.High = 'High';
      e.Normal = 'Normal';
      e.Low = 'Low';
    })(s || (exports.TaskListPriority = s = {}));
    (function (e) {
      e.toJsonObj = function (e) {
        return {
          message: e.message,
          uri: e.uri.toJsonObj(),
          range: e.range,
          priority: e.priority
        };
      };
      e.fromJsonObj = function (e) {
        return {
          message: e.message,
          uri: r.Uri.fromJsonObj(e.uri),
          range: e.range,
          priority: e.priority
        };
      };
    })(i || (exports.DiagnosticRelatedInfo = i = {}));
    class o {
      constructor(e, t, n, a = s.Normal) {
        this.category = e;
        this.message = t;
        this.range = n;
        this.priority = a;
        this._relatedInfo = [];
      }
      toJsonObj() {
        return {
          category: this.category,
          message: this.message,
          range: this.range,
          priority: this.priority,
          actions: this._actions,
          rule: this._rule,
          relatedInfo: this._relatedInfo.map(e => i.toJsonObj(e))
        };
      }
      static fromJsonObj(e) {
        const t = new o(e.category, e.message, e.range, e.priority);
        t._actions = e.actions;
        t._rule = e.rule;
        t._relatedInfo = e.relatedInfo.map(e => i.fromJsonObj(e));
        return t;
      }
      addAction(e) {
        if (this._actions === undefined) {
          this._actions = [e];
        } else {
          this._actions.push(e);
        }
      }
      getActions() {
        return this._actions;
      }
      setRule(e) {
        this._rule = e;
      }
      getRule() {
        return this._rule;
      }
      addRelatedInfo(e, t, n, a = s.Normal) {
        this._relatedInfo.push({
          uri: t,
          message: e,
          range: n,
          priority: a
        });
      }
      getRelatedInfo() {
        return this._relatedInfo;
      }
    }
    exports.Diagnostic = o;
    class l {
      constructor() {
        this._messages = [];
        this._childAddenda = [];
      }
      addMessage(e) {
        this._messages.push(e);
      }
      addMessageMultiline(e) {
        e.split('\n').forEach(e => {
          this._messages.push(e);
        });
      }
      addTextRange(e) {
        this._range = e;
      }
      createAddendum() {
        var e;
        const t = new l();
        t._nestLevel = ((e = this._nestLevel) !== null && e !== undefined ? e : 0) + 1;
        this.addAddendum(t);
        return t;
      }
      getString(e = exports.defaultMaxDiagnosticDepth, n = exports.defaultMaxDiagnosticLineCount) {
        let a = this._getLinesRecursive(e, n);
        if (a.length > n) {
          a = a.slice(0, n);
          a.push('  ...');
        }
        const r = a.join('\n');
        if (r.length > 0) {
          return `
${r}`;
        } else {
          return '';
        }
      }
      isEmpty() {
        return this._getMessageCount() === 0;
      }
      addAddendum(e) {
        this._childAddenda.push(e);
      }
      getChildren() {
        return this._childAddenda;
      }
      getMessages() {
        return this._messages;
      }
      getNestLevel() {
        var e;
        if ((e = this._nestLevel) !== null && e !== undefined) {
          return e;
        } else {
          return 0;
        }
      }
      getEffectiveTextRange() {
        const e = this._getTextRangeRecursive();
        if ((e == null ? undefined : e.length) !== 0) {
          return e;
        }
      }
      _getTextRangeRecursive(e = 0) {
        if (e > 64) {
          return;
        }
        e++;
        const t = this._childAddenda.map(t => t._getTextRangeRecursive(e)).filter(e => !!e);
        if (t.length > 1) {
          return {
            start: 0,
            length: 0
          };
        } else {
          if (t.length === 1) {
            return t[0];
          } else {
            if (this._range) {
              return this._range;
            } else {
              return undefined;
            }
          }
        }
      }
      _getMessageCount(e = 0) {
        if (e > 64) {
          return 0;
        }
        let t = this._messages.length;
        for (const n of this._childAddenda) {
          t += n._getMessageCount(e + 1);
        }
        return t;
      }
      _getLinesRecursive(e, t, n = 0) {
        if (e <= 0 || n > 64) {
          return [];
        }
        let r = [];
        for (const s of this._childAddenda) {
          const i = this._messages.length > 0 ? e - 1 : e;
          a.appendArray(r, s._getLinesRecursive(i, t, n + 1));
          if (r.length >= t) {
            r = r.slice(0, t);
            break;
          }
        }
        const s = this._messages.length > 0 ? '  ' : '';
        return this._messages.concat(r).map(e => s + e);
      }
    }
    exports.DiagnosticAddendum = l;
  },
  65880: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DiagnosticRule = undefined;
    (function (e) {
      e.strictListInference = 'strictListInference';
      e.strictSetInference = 'strictSetInference';
      e.strictDictionaryInference = 'strictDictionaryInference';
      e.analyzeUnannotatedFunctions = 'analyzeUnannotatedFunctions';
      e.strictParameterNoneValue = 'strictParameterNoneValue';
      e.enableExperimentalFeatures = 'enableExperimentalFeatures';
      e.enableTypeIgnoreComments = 'enableTypeIgnoreComments';
      e.enableReachabilityAnalysis = 'enableReachabilityAnalysis';
      e.deprecateTypingAliases = 'deprecateTypingAliases';
      e.disableBytesTypePromotions = 'disableBytesTypePromotions';
      e.reportGeneralTypeIssues = 'reportGeneralTypeIssues';
      e.reportPropertyTypeMismatch = 'reportPropertyTypeMismatch';
      e.reportFunctionMemberAccess = 'reportFunctionMemberAccess';
      e.reportMissingImports = 'reportMissingImports';
      e.reportMissingModuleSource = 'reportMissingModuleSource';
      e.reportInvalidTypeForm = 'reportInvalidTypeForm';
      e.reportMissingTypeStubs = 'reportMissingTypeStubs';
      e.reportImportCycles = 'reportImportCycles';
      e.reportUnusedImport = 'reportUnusedImport';
      e.reportUnusedClass = 'reportUnusedClass';
      e.reportUnusedFunction = 'reportUnusedFunction';
      e.reportUnusedVariable = 'reportUnusedVariable';
      e.reportDuplicateImport = 'reportDuplicateImport';
      e.reportWildcardImportFromLibrary = 'reportWildcardImportFromLibrary';
      e.reportAbstractUsage = 'reportAbstractUsage';
      e.reportArgumentType = 'reportArgumentType';
      e.reportAssertTypeFailure = 'reportAssertTypeFailure';
      e.reportAssignmentType = 'reportAssignmentType';
      e.reportAttributeAccessIssue = 'reportAttributeAccessIssue';
      e.reportCallIssue = 'reportCallIssue';
      e.reportInconsistentOverload = 'reportInconsistentOverload';
      e.reportIndexIssue = 'reportIndexIssue';
      e.reportInvalidTypeArguments = 'reportInvalidTypeArguments';
      e.reportNoOverloadImplementation = 'reportNoOverloadImplementation';
      e.reportOperatorIssue = 'reportOperatorIssue';
      e.reportOptionalSubscript = 'reportOptionalSubscript';
      e.reportOptionalMemberAccess = 'reportOptionalMemberAccess';
      e.reportOptionalCall = 'reportOptionalCall';
      e.reportOptionalIterable = 'reportOptionalIterable';
      e.reportOptionalContextManager = 'reportOptionalContextManager';
      e.reportOptionalOperand = 'reportOptionalOperand';
      e.reportRedeclaration = 'reportRedeclaration';
      e.reportReturnType = 'reportReturnType';
      e.reportTypedDictNotRequiredAccess = 'reportTypedDictNotRequiredAccess';
      e.reportUntypedFunctionDecorator = 'reportUntypedFunctionDecorator';
      e.reportUntypedClassDecorator = 'reportUntypedClassDecorator';
      e.reportUntypedBaseClass = 'reportUntypedBaseClass';
      e.reportUntypedNamedTuple = 'reportUntypedNamedTuple';
      e.reportPrivateUsage = 'reportPrivateUsage';
      e.reportTypeCommentUsage = 'reportTypeCommentUsage';
      e.reportPrivateImportUsage = 'reportPrivateImportUsage';
      e.reportConstantRedefinition = 'reportConstantRedefinition';
      e.reportDeprecated = 'reportDeprecated';
      e.reportIncompatibleMethodOverride = 'reportIncompatibleMethodOverride';
      e.reportIncompatibleVariableOverride = 'reportIncompatibleVariableOverride';
      e.reportInconsistentConstructor = 'reportInconsistentConstructor';
      e.reportOverlappingOverload = 'reportOverlappingOverload';
      e.reportPossiblyUnboundVariable = 'reportPossiblyUnboundVariable';
      e.reportMissingSuperCall = 'reportMissingSuperCall';
      e.reportUninitializedInstanceVariable = 'reportUninitializedInstanceVariable';
      e.reportInvalidStringEscapeSequence = 'reportInvalidStringEscapeSequence';
      e.reportUnknownParameterType = 'reportUnknownParameterType';
      e.reportUnknownArgumentType = 'reportUnknownArgumentType';
      e.reportUnknownLambdaType = 'reportUnknownLambdaType';
      e.reportUnknownVariableType = 'reportUnknownVariableType';
      e.reportUnknownMemberType = 'reportUnknownMemberType';
      e.reportMissingParameterType = 'reportMissingParameterType';
      e.reportMissingTypeArgument = 'reportMissingTypeArgument';
      e.reportInvalidTypeVarUse = 'reportInvalidTypeVarUse';
      e.reportCallInDefaultInitializer = 'reportCallInDefaultInitializer';
      e.reportUnnecessaryIsInstance = 'reportUnnecessaryIsInstance';
      e.reportUnnecessaryCast = 'reportUnnecessaryCast';
      e.reportUnnecessaryComparison = 'reportUnnecessaryComparison';
      e.reportUnnecessaryContains = 'reportUnnecessaryContains';
      e.reportAssertAlwaysTrue = 'reportAssertAlwaysTrue';
      e.reportSelfClsParameterName = 'reportSelfClsParameterName';
      e.reportImplicitStringConcatenation = 'reportImplicitStringConcatenation';
      e.reportUndefinedVariable = 'reportUndefinedVariable';
      e.reportUnboundVariable = 'reportUnboundVariable';
      e.reportUnhashable = 'reportUnhashable';
      e.reportInvalidStubStatement = 'reportInvalidStubStatement';
      e.reportIncompleteStub = 'reportIncompleteStub';
      e.reportUnsupportedDunderAll = 'reportUnsupportedDunderAll';
      e.reportUnusedCallResult = 'reportUnusedCallResult';
      e.reportUnusedCoroutine = 'reportUnusedCoroutine';
      e.reportUnusedExcept = 'reportUnusedExcept';
      e.reportUnusedExpression = 'reportUnusedExpression';
      e.reportUnnecessaryTypeIgnoreComment = 'reportUnnecessaryTypeIgnoreComment';
      e.reportMatchNotExhaustive = 'reportMatchNotExhaustive';
      e.reportShadowedImports = 'reportShadowedImports';
      e.reportImplicitOverride = 'reportImplicitOverride';
    })(n || (exports.DiagnosticRule = n = {}));
  },
  36316: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TextRangeDiagnosticSink = exports.DiagnosticSink = exports.FileDiagnostics = undefined;
    const a = require(58147);
    const r = require(11479);
    const s = require(56814);
    const i = require(89740);
    const o = require(27113);
    var l;
    (function (e) {
      e.toJsonObj = function (e) {
        return {
          fileUri: e.fileUri.toJsonObj(),
          version: e.version,
          diagnostics: e.diagnostics.map(e => e.toJsonObj())
        };
      };
      e.fromJsonObj = function (e) {
        return {
          fileUri: o.Uri.fromJsonObj(e.fileUri),
          version: e.version,
          diagnostics: e.diagnostics.map(e => r.Diagnostic.fromJsonObj(e))
        };
      };
    })(l || (exports.FileDiagnostics = l = {}));
    class p {
      constructor(e) {
        this._diagnosticList = e || [];
        this._diagnosticMap = new Map();
      }
      fetchAndClear() {
        const e = this._diagnosticList;
        this._diagnosticList = [];
        this._diagnosticMap.clear();
        return e;
      }
      addError(e, t) {
        return this.addDiagnostic(new r.Diagnostic(0, e, t));
      }
      addWarning(e, t) {
        return this.addDiagnostic(new r.Diagnostic(1, e, t));
      }
      addInformation(e, t) {
        return this.addDiagnostic(new r.Diagnostic(2, e, t));
      }
      addUnusedCode(e, t, n) {
        const a = new r.Diagnostic(3, e, t);
        if (n) {
          a.addAction(n);
        }
        return this.addDiagnostic(a);
      }
      addUnreachableCode(e, t, n) {
        const a = new r.Diagnostic(4, e, t);
        if (n) {
          a.addAction(n);
        }
        return this.addDiagnostic(a);
      }
      addDeprecated(e, t, n) {
        const a = new r.Diagnostic(5, e, t);
        if (n) {
          a.addAction(n);
        }
        return this.addDiagnostic(a);
      }
      addDiagnostic(e) {
        const t = `${e.range.start.line},${e.range.start.character}-${e.range.end.line}-${e.range.end.character}:${i.hashString(e.message)}}`;
        if (!this._diagnosticMap.has(t)) {
          this._diagnosticList.push(e);
          this._diagnosticMap.set(t, e);
        }
        return e;
      }
      addDiagnostics(e) {
        a.appendArray(this._diagnosticList, e);
      }
      getErrors() {
        return this._diagnosticList.filter(e => e.category === 0);
      }
      getWarnings() {
        return this._diagnosticList.filter(e => e.category === 1);
      }
      getInformation() {
        return this._diagnosticList.filter(e => e.category === 2);
      }
      getUnusedCode() {
        return this._diagnosticList.filter(e => e.category === 3);
      }
      getUnreachableCode() {
        return this._diagnosticList.filter(e => e.category === 4);
      }
      getDeprecated() {
        return this._diagnosticList.filter(e => e.category === 5);
      }
    }
    exports.DiagnosticSink = p;
    exports.TextRangeDiagnosticSink = class extends p {
      constructor(e, t) {
        super(t);
        this._lines = e;
      }
      addDiagnosticWithTextRange(e, t, n) {
        const a = s.convertOffsetsToRange(n.start, n.start + n.length, this._lines);
        switch (e) {
          case 'error':
            return this.addError(t, a);
          case 'warning':
            return this.addWarning(t, a);
          case 'information':
            return this.addInformation(t, a);
          default:
            throw new Error(`${e} is not expected value`);
        }
      }
      addUnusedCodeWithTextRange(e, t, n) {
        return this.addUnusedCode(e, s.convertOffsetsToRange(t.start, t.start + t.length, this._lines), n);
      }
      addUnreachableCodeWithTextRange(e, t, n) {
        return this.addUnreachableCode(e, s.convertOffsetsToRange(t.start, t.start + t.length, this._lines), n);
      }
      addDeprecatedWithTextRange(e, t, n) {
        return this.addDeprecated(e, s.convertOffsetsToRange(t.start, t.start + t.length, this._lines), n);
      }
    };
  },
  71458: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.PyrightDocStringService = exports.DocStringService = undefined;
    const a = require(12670);
    const r = require(81073);
    var s;
    (function (e) {
      e.is = function (e) {
        return !!e.convertDocStringToMarkdown && !!e.convertDocStringToPlainText && !!e.extractParameterDocumentation;
      };
    })(s || (exports.DocStringService = s = {}));
    exports.PyrightDocStringService = class {
      convertDocStringToPlainText(e) {
        return a.convertDocStringToPlainText(e);
      }
      convertDocStringToMarkdown(e) {
        return a.convertDocStringToMarkdown(e);
      }
      extractParameterDocumentation(e, t) {
        return r.extractParameterDocumentation(e, t);
      }
      clone() {
        return this;
      }
    };
  },
  90010: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FileEditAction = exports.TextEditAction = undefined;
    const a = require(88754);
    var r;
    var s;
    (function (e) {
      e.is = function (e) {
        return !!e.range && e.replacementText !== undefined;
      };
    })(r || (exports.TextEditAction = r = {}));
    (function (e) {
      e.is = function (e) {
        return e.fileUri !== undefined && r.is(e);
      };
      e.areEqual = function (e, t) {
        return e === t || e.fileUri.equals(t.fileUri) && a.rangesAreEqual(e.range, t.range) && e.replacementText === t.replacementText;
      };
    })(s || (exports.FileEditAction = s = {}));
  },
  10775: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.resolvePathWithEnvVariables = function (e, t, n) {
      const a = e.rootUri;
      const r = c(t, a ?? o.Uri.empty(), n);
      const s = e.service.serviceProvider.get(p.ServiceKeys.caseSensitivityDetector);
      if (function (e) {
        const t = /^[a-zA-Z]:\\?/;
        return /^[a-zA-Z][a-zA-Z0-9+.-]*:\/?\/?/.test(e) && !t.test(e);
      }(r)) {
        return o.Uri.parse(l.normalizeSlashes(r, '/'), s);
      }
      if (a) {
        return a.resolvePaths(l.normalizeSlashes(r, '/'));
      }
      if (t.includes('${workspaceFolder')) {
        return;
      }
      if (!l.isRootedDiskPath(l.normalizeSlashes(r))) {
        return;
      }
      return o.Uri.file(r, s);
    };
    exports.expandPathVariables = c;
    const i = __importStar(require(70857));
    const o = require(27113);
    const l = require(54010);
    const p = require(71745);
    const d = require(89740);
    function c(e, t, n) {
      const a = (t, n) => {
        e = e.replace(t, n);
      };
      e = e.replace(/\$\{workspaceFolder\}/g, t.getPath());
      for (const t of n) {
        if (!t.rootUri) {
          continue;
        }
        const n = d.escapeRegExp(t.workspaceName);
        const a = RegExp(`\\$\\{workspaceFolder:${n}\\}`, 'g');
        e = e.replace(a, t.rootUri.getPath());
      }
      if (process.env.HOME !== undefined) {
        a(/\$\{env:HOME\}/g, process.env.HOME || '');
      }
      if (process.env.USERNAME !== undefined) {
        a(/\$\{env:USERNAME\}/g, process.env.USERNAME || '');
      }
      if (process.env.VIRTUAL_ENV !== undefined) {
        a(/\$\{env:VIRTUAL_ENV\}/g, process.env.VIRTUAL_ENV || '');
      }
      if (i.homedir) {
        a(/(?:^|\/)~(?=\/)/g, i.homedir() || process.env.HOME || process.env.USERPROFILE || '~');
      }
      return e;
    }
  },
  56507: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ReferenceUseCase = undefined;
    (function (e) {
      e[e.Rename = 0] = 'Rename';
      e[e.References = 1] = 'References';
    })(n || (exports.ReferenceUseCase = n = {}));
  },
  44562: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    Promise.prototype.ignoreErrors = function () {
      this.catch(e => {
        console.log(e);
      });
    };
  },
  34487: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FileBasedCancellationProvider = undefined;
    exports.getCancellationStrategyFromArgv = function (e) {
      let t;
      for (let a = 0; a < e.length; a++) {
        const r = e[a];
        if (r === '--cancellationReceive') {
          t = n(e[a + 1]);
        } else {
          const e = r.split('=');
          if (e[0] === '--cancellationReceive') {
            t = n(e[1]);
          }
        }
      }
      if (t && !c.getCancellationFolderName()) {
        c.setCancellationFolderName(t.folderName);
      }
      t = t || d.CancellationReceiverStrategy.Message;
      return {
        receiver: t,
        sender: d.CancellationSenderStrategy.Message
      };
      function n(e) {
        const t = function (e) {
          const t = /^file:(.+)$/;
          const n = e.match(t);
          if (n) {
            return n[1];
          } else {
            return undefined;
          }
        }(e);
        if (t) {
          return new f(t);
        } else {
          return undefined;
        }
      }
    };
    exports.disposeCancellationToken = function (e) {
      if (e instanceof c.FileBasedToken) {
        e.dispose();
      }
    };
    exports.getCancellationTokenFromId = function (e) {
      if (!e) {
        return d.CancellationToken.None;
      }
      return new c.FileBasedToken(e, new m());
    };
    const i = __importStar(require(79896));
    const o = __importStar(require(70857));
    const l = __importStar(require(16928));
    const p = require(90355);
    const d = require(56911);
    const c = require(91426);
    const u = require(5884);
    class m {
      statSync(e) {
        return i.statSync(e.getFilePath());
      }
    }
    class y extends c.FileBasedToken {
      constructor(e) {
        super(e, new m());
        this._disposed = false;
      }
      get isCancellationRequested() {
        return this.isCancelled;
      }
      cancel() {
        if (!this._disposed && !this.isCancelled) {
          this._createPipe();
          super.cancel();
        }
      }
      dispose() {
        this._disposed = true;
        super.dispose();
        this._removePipe();
      }
      _createPipe() {
        try {
          i.writeFileSync(this.cancellationFilePath.getFilePath(), '', {
            flag: 'w'
          });
        } catch {}
      }
      _removePipe() {
        try {
          i.unlinkSync(this.cancellationFilePath.getFilePath());
        } catch {}
      }
    }
    class g {
      constructor(e, t = false) {
        this._cancellationId = e;
        this._ownFile = t;
      }
      get token() {
        if (!this._token) {
          this._token = this._ownFile ? new y(this._cancellationId) : new c.FileBasedToken(this._cancellationId, new m());
        }
        return this._token;
      }
      cancel() {
        if (this._token) {
          if (this._token.isCancellationRequested) {
            return;
          }
          this._token.cancel();
        } else {
          this._token = d.CancellationToken.Cancelled;
        }
      }
      dispose() {
        if (this._token) {
          if (this._token instanceof c.FileBasedToken) {
            this._token.dispose();
          }
        } else {
          this._token = d.CancellationToken.None;
        }
      }
    }
    function h(e, t) {
      return u.UriEx.file(l.join(function (e) {
        return l.join(o.tmpdir(), 'python-languageserver-cancellation', e);
      }(e), `cancellation-${String(t)}.tmp`)).toString();
    }
    class f {
      constructor(e) {
        this.folderName = e;
      }
      createCancellationTokenSource(e) {
        return new g(h(this.folderName, e));
      }
    }
    let T = 0;
    exports.FileBasedCancellationProvider = class {
      constructor(e) {
        this._prefix = e;
      }
      createCancellationTokenSource() {
        const e = c.getCancellationFolderName();
        if (e) {
          return new g(h(e, `${this._prefix}-${String(T++)}`), true);
        } else {
          return new p.CancellationTokenSource();
        }
      }
    };
  },
  66643: (module, exports) => {
    var n;
    var a;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.VirtualDirent = exports.TempFile = exports.FileSystem = undefined;
    (function (e) {
      e.is = function (e) {
        return e.createFileSystemWatcher && e.createReadStream && e.createWriteStream && e.copyFileSync;
      };
    })(n || (exports.FileSystem = n = {}));
    (function (e) {
      e.is = function (e) {
        return e.tmpdir && e.tmpfile;
      };
    })(a || (exports.TempFile = a = {}));
    exports.VirtualDirent = class {
      constructor(e, t, n) {
        this.name = e;
        this._file = t;
        this.parentPath = n;
      }
      get path() {
        return this.parentPath;
      }
      isFile() {
        return this._file;
      }
      isDirectory() {
        return !this._file;
      }
      isBlockDevice() {
        return false;
      }
      isCharacterDevice() {
        return false;
      }
      isSymbolicLink() {
        return false;
      }
      isFIFO() {
        return false;
      }
      isSocket() {
        return false;
      }
    };
  },
  12060: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.nullFileWatcherProvider = exports.nullFileWatcherHandler = undefined;
    exports.ignoredWatchEventFunction = function (e) {
      const t = e.map(e => e.toLowerCase());
      return e => {
        if (!e || e.indexOf('__pycache__') >= 0) {
          return true;
        }
        const n = e.toLowerCase();
        return t.every(e => n.indexOf(e) < 0);
      };
    };
    exports.nullFileWatcherHandler = {
      onFileChange(e, t) {}
    };
    exports.nullFileWatcherProvider = {
      createFileWatcher: (e, t) => n
    };
    const n = {
      close() {}
    };
  },
  12913: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FullAccessHost = exports.LimitedAccessHost = undefined;
    const i = __importStar(require(35317));
    const o = require(91426);
    const l = require(12522);
    const p = require(48281);
    const d = require(50918);
    const c = require(54010);
    const u = require(63808);
    const m = require(71745);
    const y = require(27113);
    const g = require(5884);
    const h = ['import os, os.path, sys', 'normalize = lambda p: os.path.normcase(os.path.normpath(p))', 'cwd = normalize(os.getcwd())', 'orig_sys_path = [p for p in sys.path if p != ""]', 'sys.path[:] = [p for p in sys.path if p != "" and normalize(p) != cwd]'];
    const f = [...h, 'import sys, json', 'json.dump(dict(path=orig_sys_path, prefix=sys.prefix), sys.stdout)'].join('; ');
    const T = [...h, 'import sys, json', 'json.dump(tuple(sys.version_info), sys.stdout)'].join('; ');
    class v extends d.NoAccessHost {
      get kind() {
        return 1;
      }
      getPythonPlatform(e) {
        if (process.platform === 'darwin') {
          return l.PythonPlatform.Darwin;
        } else {
          if (process.platform === 'linux') {
            return l.PythonPlatform.Linux;
          } else {
            if (process.platform === 'win32') {
              return l.PythonPlatform.Windows;
            } else {
              return undefined;
            }
          }
        }
      }
    }
    exports.LimitedAccessHost = v;
    class b extends v {
      constructor(e) {
        super();
        this.serviceProvider = e;
      }
      get kind() {
        return 0;
      }
      static createHost(e, t) {
        switch (e) {
          case 2:
            return new d.NoAccessHost();
          case 1:
            return new v();
          case 0:
            return new b(t);
          default:
            p.assertNever(e);
        }
      }
      getPythonSearchPaths(e, t) {
        const n = t ?? [];
        let a = this._executePythonInterpreter(e == null ? undefined : e.getFilePath(), e => this._getSearchPathResultFromInterpreter(e, n));
        if (!a) {
          a = {
            paths: [],
            prefix: undefined
          };
        }
        n.push(`Received ${a.paths.length} paths from interpreter`);
        a.paths.forEach(e => {
          n.push(`  ${e}`);
        });
        return a;
      }
      getPythonVersion(e, t) {
        const n = t ?? [];
        try {
          const t = this._executePythonInterpreter(e == null ? undefined : e.getFilePath(), e => this._executeCodeInInterpreter(e, ['-I'], T));
          const a = JSON.parse(t);
          if (!Array.isArray(a) || a.length < 5) {
            n.push(`Python version ${t} from interpreter is unexpected format`);
            return;
          }
          const r = u.PythonVersion.create(a[0], a[1], a[2], a[3], a[4]);
          if (r === undefined) {
            n.push(`Python version ${t} from interpreter is unsupported`);
            return;
          } else {
            return r;
          }
        } catch {
          n.push('Unable to get Python version from interpreter');
          return;
        }
      }
      runScript(e, t, n, a, r) {
        o.throwIfCancellationRequested(r);
        return new Promise((s, l) => {
          let p = '';
          let d = '';
          const c = ['-I', t.getFilePath(), ...n];
          const u = this._executePythonInterpreter(e == null ? undefined : e.getFilePath(), e => i.spawn(e, c, {
            cwd: a.getFilePath(),
            shell: this.shouldUseShellToRunInterpreter(e)
          }));
          const m = o.onCancellationRequested(r, () => {
            if (u) {
              try {
                if (u.pid && u.exitCode === null) {
                  if (process.platform === 'win32') {
                    i.execSync(`taskkill /pid ${u.pid} /T /F > NUL 2>&1`);
                  } else {
                    process.kill(u.pid);
                  }
                }
              } catch {}
            }
            l(new o.OperationCanceledException());
          });
          if (u) {
            u.stdout.on('data', e => p = p.concat(e));
            u.stderr.on('data', e => d = d.concat(e));
            u.on('error', e => {
              m.dispose();
              l(e);
            });
            u.on('exit', () => {
              m.dispose();
              s({
                stdout: p,
                stderr: d
              });
            });
          } else {
            m.dispose();
            l(new Error(`Cannot start python interpreter with script ${t}`));
          }
        });
      }
      shouldUseShellToRunInterpreter(e) {
        return process.platform === 'win32' && !!c.getAnyExtensionFromPath(e, ['.bat', '.cmd'], true);
      }
      _executePythonInterpreter(e, t) {
        if (e) {
          return t(e);
        }
        {
          let e;
          try {
            if (process.platform !== 'win32') {
              e = t('python3');
            }
          } catch {}
          if (e !== undefined) {
            return e;
          } else {
            return t('python');
          }
        }
      }
      _executeCodeInInterpreter(e, t, n) {
        const a = this.shouldUseShellToRunInterpreter(e);
        if (a) {
          n = `"${n}"`;
        }
        t.push('-c', n);
        return i.execFileSync(e, t, {
          encoding: 'utf8',
          shell: a
        });
      }
      _getSearchPathResultFromInterpreter(e, t) {
        const n = {
          paths: [],
          prefix: undefined
        };
        try {
          t.push(`Executing interpreter: '${e}'`);
          const a = this._executeCodeInInterpreter(e, [], f);
          const r = this.serviceProvider.get(m.ServiceKeys.caseSensitivityDetector);
          try {
            const e = JSON.parse(a);
            for (let a of e.path) {
              a = a.trim();
              if (a) {
                const e = c.normalizePath(a);
                const s = y.Uri.file(e, r);
                if (this.serviceProvider.fs().existsSync(s) && g.isDirectory(this.serviceProvider.fs(), s)) {
                  n.paths.push(s);
                } else {
                  t.push(`Skipping '${e}' because it is not a valid directory`);
                }
              }
            }
            n.prefix = y.Uri.file(e.prefix, r);
            if (n.paths.length === 0) {
              t.push('Found no valid directories');
            }
          } catch (e) {
            t.push(`Could not parse output: '${a}'`);
            throw e;
          }
        } catch {
          return;
        }
        return n;
      }
    }
    exports.FullAccessHost = b;
  },
  50918: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.NoAccessHost = undefined;
    exports.NoAccessHost = class {
      get kind() {
        return 2;
      }
      getPythonSearchPaths(e, t) {
        if (t != null) {
          t.push('No access to python executable.');
        }
        return {
          paths: [],
          prefix: undefined
        };
      }
      getPythonVersion(e, t) {}
      getPythonPlatform(e) {}
      async runScript(e, t, n, a, r) {
        return {
          stdout: '',
          stderr: ''
        };
      }
    };
  },
  1394: (module, exports) => {
    var n;
    var a;
    var r;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CommandService = exports.WindowService = exports.WindowInterface = undefined;
    (function (e) {
      e.is = function (e) {
        return !!e && e.showErrorMessage !== undefined && e.showWarningMessage !== undefined && e.showInformationMessage !== undefined;
      };
    })(n || (exports.WindowInterface = n = {}));
    (function (e) {
      e.is = function (e) {
        return e.createGoToOutputAction !== undefined && n.is(e);
      };
    })(a || (exports.WindowService = a = {}));
    (function (e) {
      e.is = function (e) {
        return !!e && e.sendCommand !== undefined;
      };
    })(r || (exports.CommandService = r = {}));
  },
  51862: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.LogTracker = undefined;
    exports.getPathForLogging = function (e, t) {
      if (e.isMappedUri(t)) {
        return e.getOriginalUri(t);
      }
      return t;
    };
    const a = require(25075);
    const r = require(71582);
    exports.LogTracker = class {
      constructor(e, t) {
        this._console = e;
        this.prefix = t;
        this._dummyState = new s();
        this._previousTitles = [];
        this._indentation = '';
      }
      get logLevel() {
        const e = this._console.level;
        if (e != null) {
          return e;
        } else {
          return a.LogLevel.Error;
        }
      }
      log(e, t, n = -1, r = false) {
        if (this._console === undefined) {
          return t(this._dummyState);
        }
        const i = this._console.level;
        if (i === undefined || i !== a.LogLevel.Log && i !== a.LogLevel.Info) {
          return t(this._dummyState);
        }
        const o = this._indentation;
        this._previousTitles.push(`${o}${e} ...`);
        this._indentation += '  ';
        const l = new s();
        try {
          return t(l);
        } finally {
          const t = l.duration;
          this._indentation = o;
          if (this._previousTitles.length > 0 && (l.isSuppressed() || t <= n)) {
            this._previousTitles.pop();
          } else {
            this._printPreviousTitles();
            let n = `[${this.prefix}] ${this._indentation}${e}${l.get()} (${t}ms)`;
            if (r && l.fileReadTotal + l.tokenizeTotal + l.parsingTotal + l.resolveImportsTotal + l.bindingTotal > 0) {
              n += ` [f:${l.fileReadTotal}, t:${l.tokenizeTotal}, p:${l.parsingTotal}, i:${l.resolveImportsTotal}, b:${l.bindingTotal}]`;
            }
            this._console.log(n);
            if (t >= 2000) {
              this._console.info(`[${this.prefix}] Long operation: ${e} (${t}ms)`);
            }
          }
        }
      }
      _printPreviousTitles() {
        this._previousTitles.pop();
        if (!(this._previousTitles.length <= 0)) {
          for (const e of this._previousTitles) {
            this._console.log(`[${this.prefix}] ${e}`);
          }
          this._previousTitles.length = 0;
        }
      }
    };
    class s {
      constructor() {
        this._start = new r.Duration();
        this._startFile = r.timingStats.readFileTime.totalTime;
        this._startToken = r.timingStats.tokenizeFileTime.totalTime;
        this._startParse = r.timingStats.parseFileTime.totalTime;
        this._startImport = r.timingStats.resolveImportsTime.totalTime;
        this._startBind = r.timingStats.bindTime.totalTime;
      }
      get duration() {
        return this._start.getDurationInMilliseconds();
      }
      get fileReadTotal() {
        return r.timingStats.readFileTime.totalTime - this._startFile;
      }
      get tokenizeTotal() {
        return r.timingStats.tokenizeFileTime.totalTime - this._startToken;
      }
      get parsingTotal() {
        return r.timingStats.parseFileTime.totalTime - this._startParse;
      }
      get resolveImportsTotal() {
        return r.timingStats.resolveImportsTime.totalTime - this._startImport;
      }
      get bindingTotal() {
        return r.timingStats.bindTime.totalTime - this._startBind;
      }
      add(e) {
        if (e) {
          this._addendum = e;
        }
      }
      get() {
        if (this._addendum) {
          return ` [${this._addendum}]`;
        } else {
          return '';
        }
      }
      suppress() {
        this._suppress = true;
      }
      isSuppressed() {
        return !!this._suppress;
      }
    }
  },
  56412: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.toLSPAny = function (e) {
      return e;
    };
    exports.fromLSPAny = function (e) {
      return e;
    };
    exports.getSymbolKind = function (e, t, n = '') {
      var s;
      switch (e.type) {
        case 6:
        case 7:
          return a.SymbolKind.Class;
        case 5:
          {
            if (!e.isMethod) {
              return a.SymbolKind.Function;
            }
            const n = (s = t == null ? undefined : t.getTypeForDeclaration(e)) === null || s === undefined ? undefined : s.type;
            if (n && r.isMaybeDescriptorInstance(n, false)) {
              return a.SymbolKind.Property;
            } else {
              return a.SymbolKind.Method;
            }
          }
        case 8:
          return a.SymbolKind.Module;
        case 2:
          if (n === 'self' || n === 'cls' || n === '_') {
            return;
          }
          return a.SymbolKind.Variable;
        case 3:
          return a.SymbolKind.TypeParameter;
        case 1:
          if (n === '_') {
            return;
          }
          if (e.isConstant || e.isFinal) {
            return a.SymbolKind.Constant;
          } else {
            return a.SymbolKind.Variable;
          }
        default:
          return a.SymbolKind.Variable;
      }
    };
    exports.isNullProgressReporter = function (e) {
      const t = e.begin.toString();
      return t.substring(t.indexOf('{') + 1, t.lastIndexOf('}')).trim() === '';
    };
    const a = require(56911);
    const r = require(92324);
  },
  16066: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getHeapStatistics = undefined;
    exports.getSystemMemoryInfo = function () {
      if (!i.totalmem || !i.freemem) {
        return {
          total: 0,
          free: 0
        };
      }
      return {
        total: i.totalmem(),
        free: i.freemem()
      };
    };
    const i = __importStar(require(70857));
    exports.getHeapStatistics = function () {
      try {
        const e = require(11493).getHeapStatistics;
        if (e) {
          return e;
        }
      } catch {}
      return () => ({
        total_heap_size: 0,
        total_heap_size_executable: 0,
        total_physical_size: 0,
        total_available_size: 0,
        used_heap_size: 0,
        heap_size_limit: 0,
        malloced_memory: 0,
        peak_malloced_memory: 0,
        does_zap_garbage: 0,
        number_of_native_contexts: 0,
        number_of_detached_contexts: 0,
        total_global_handles_size: 0,
        used_global_handles_size: 0,
        external_memory: 0
      });
    }();
  },
  4883: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.configFileName = exports.pyprojectTomlName = exports.requirementsFileName = exports.defaultStubsDirectory = exports.stubsSuffix = exports.src = exports.distPackages = exports.sitePackages = exports.lib64 = exports.libAlternate = exports.lib = exports.typeshedFallback = undefined;
    exports.typeshedFallback = 'typeshed-fallback';
    exports.lib = 'lib';
    exports.libAlternate = 'Lib';
    exports.lib64 = 'lib64';
    exports.sitePackages = 'site-packages';
    exports.distPackages = 'dist-packages';
    exports.src = 'src';
    exports.stubsSuffix = '-stubs';
    exports.defaultStubsDirectory = 'typings';
    exports.requirementsFileName = 'requirements.txt';
    exports.pyprojectTomlName = 'pyproject.toml';
    exports.configFileName = 'pyrightconfig.json';
  },
  54010: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FileSpec = undefined;
    exports.getDirectoryPath = m;
    exports.getRootLength = y;
    exports.getPathSeparator = g;
    exports.getPathComponents = h;
    exports.reducePathComponents = f;
    exports.combinePathComponents = T;
    exports.getRelativePath = function (e, t) {
      if (!e.startsWith(w(t))) {
        return;
      }
      const n = h(e);
      const a = h(t);
      const r = g(e);
      let s = '.';
      for (let e = a.length; e < n.length; e++) {
        s += r + n[e];
      }
      return s;
    };
    exports.normalizeSlashes = b;
    exports.resolvePaths = function (e, ...t) {
      return D(o.some(t) ? _(e, ...t) : b(e));
    };
    exports.combinePaths = _;
    exports.containsPath = function (e, t, n, a) {
      if (typeof n == 'string') {
        e = _(n, e);
        t = _(n, t);
      } else {
        if (typeof n == 'boolean') {
          a = n;
        }
      }
      if (e === undefined || t === undefined) {
        return false;
      }
      if (e === t) {
        return true;
      }
      const r = h(e);
      const s = h(t);
      if (s.length < r.length) {
        return false;
      }
      const i = a ? d.equateStringsCaseInsensitive : d.equateStringsCaseSensitive;
      for (let e = 0; e < r.length; e++) {
        if (!(e === 0 ? d.equateStringsCaseInsensitive : i)(r[e], s[e])) {
          return false;
        }
      }
      return true;
    };
    exports.changeAnyExtension = function (e, t, n, a) {
      const r = n !== undefined && a !== undefined ? C(e, n, a) : C(e);
      if (r) {
        return e.slice(0, e.length - r.length) + (t.startsWith('.') ? t : `.${t}`);
      } else {
        return e;
      }
    };
    exports.getAnyExtensionFromPath = C;
    exports.getBaseFileName = I;
    exports.getRelativePathFromDirectory = function (e, t, n) {
      return T(k(e, t, n));
    };
    exports.getRelativePathComponentsFromDirectory = k;
    exports.ensureTrailingDirectorySeparator = w;
    exports.hasTrailingDirectorySeparator = S;
    exports.stripTrailingDirectorySeparator = A;
    exports.getFileExtension = x;
    exports.getFileName = P;
    exports.getShortenedFileName = function (e, t = 15) {
      const n = P(e);
      const a = m(e);
      if (a.length > t) {
        return `...${a.slice(a.length - t)}${i.sep}${n}`;
      }
      return e;
    };
    exports.stripFileExtension = function (e, t = false) {
      const n = x(e, t);
      return e.substr(0, e.length - n.length);
    };
    exports.normalizePath = D;
    exports.getWildcardRegexPattern = function (e, t) {
      let n = D(_(e, t));
      if (!N(n)) {
        n = w(n);
      }
      const a = h(n);
      const r = F(g(e));
      const s = `(${r}[^${r}][^${r}]*)*?`;
      const i = new RegExp(`[^\\w\\s${r}]`, 'g');
      if (a.length > 0) {
        a[0] = A(a[0]);
        if (a[0].startsWith('\\\\')) {
          a[0] = `\\\\${a[0]}`;
        }
      }
      let o = '';
      let l = true;
      for (let e of a) {
        if (e === '**') {
          o += s;
        } else {
          if (!l) {
            e = r + e;
          }
          o += e.replace(i, e => e === '*' ? `[^${r}]*` : e === '?' ? `[^${r}]` : `\\${e}`);
          l = false;
        }
      }
      return o;
    };
    exports.isDirectoryWildcardPatternPresent = function (e) {
      const t = D(e);
      const n = h(t);
      for (const e of n) {
        if (e === '**') {
          return true;
        }
      }
      return false;
    };
    exports.getWildcardRoot = function (e, t) {
      let n = D(_(e, t));
      if (!N(n)) {
        n = w(n);
      }
      const a = h(n);
      const r = g(n);
      if (a.length > 0) {
        a[0] = A(a[0]);
      }
      if (a.length === 1 && !a[0]) {
        return r;
      }
      let s = '';
      let i = true;
      for (let e of a) {
        if (e === '**') {
          break;
        }
        if (e.match(/[*?]/)) {
          break;
        }
        if (!i) {
          e = r + e;
        }
        s += e;
        i = false;
      }
      return s;
    };
    exports.hasPythonExtension = N;
    exports.getRegexEscapedSeparator = F;
    exports.isRootedDiskPath = function (e) {
      return y(e) > 0;
    };
    exports.isDiskPathRoot = function (e) {
      const t = y(e);
      return t > 0 && t === e.length;
    };
    const i = __importStar(require(16928));
    const o = require(58147);
    const l = require(34455);
    const p = __importStar(require(48281));
    const d = require(89740);
    const c = /\.pyi?$/;
    var u;
    function m(e) {
      return e.substr(0, Math.max(y(e), e.lastIndexOf(i.sep)));
    }
    function y(e, t = i.sep) {
      if (e.charAt(0) === t) {
        if (e.charAt(1) !== t) {
          return 1;
        }
        const n = e.indexOf(t, 2);
        if (n < 0) {
          return e.length;
        } else {
          return n + 1;
        }
      }
      if (e.charAt(1) === ':') {
        if (e.charAt(2) === t) {
          return 3;
        }
        if (e.length === 2) {
          return 2;
        }
      }
      return 0;
    }
    function g(e) {
      return i.sep;
    }
    function h(e) {
      const t = b(e);
      const n = y(t);
      const a = t.substring(0, n);
      const r = g();
      const s = t.substring(n).split(r);
      if (s.length > 0 && !s[s.length - 1]) {
        s.pop();
      }
      return f([a, ...s]);
    }
    function f(e) {
      if (!o.some(e)) {
        return [];
      }
      const t = [e[0]];
      for (let n = 1; n < e.length; n++) {
        const a = e[n];
        if (a && a !== '.') {
          if (a === '..') {
            if (t.length > 1) {
              if (t[t.length - 1] !== '..') {
                t.pop();
                continue;
              }
            } else {
              if (t[0]) {
                continue;
              }
            }
          }
          t.push(a);
        }
      }
      return t;
    }
    function T(e) {
      if (e.length === 0) {
        return '';
      }
      const t = e[0] && w(e[0]);
      const n = g();
      return b(t + e.slice(1).join(n));
    }
    (function (e) {
      e.is = function (e) {
        const t = e;
        return t && !!t.wildcardRoot && !!t.regExp;
      };
      e.isInPath = function (e, t) {
        return !!t.find(t => t.regExp.test(e));
      };
      e.matchesIncludeFileRegex = function (e, t = true) {
        return !t || c.test(e);
      };
      e.matchIncludeFileSpec = function (t, n, a, r = true) {
        return !!t.test(a) && !e.isInPath(a, n) && !!e.matchesIncludeFileRegex(a, r);
      };
    })(u || (exports.FileSpec = u = {}));
    const v = e => e === '/' ? '\\' : '/';
    function b(e, t = i.sep) {
      if (e.includes(v(t))) {
        const n = /[\\/]/g;
        return e.replace(n, t);
      }
      return e;
    }
    function _(e, ...t) {
      if (e) {
        e = b(e);
      }
      for (let n of t) {
        if (n) {
          n = b(n);
          e = e && y(n) === 0 ? w(e) + n : n;
        }
      }
      return e;
    }
    function C(e, t, n) {
      if (t) {
        return function (e, t, n) {
          if (typeof t == 'string') {
            return E(e, t, n) || '';
          }
          for (const a of t) {
            const t = E(e, a, n);
            if (t) {
              return t;
            }
          }
          return '';
        }(A(e), t, n ? d.equateStringsCaseInsensitive : d.equateStringsCaseSensitive);
      }
      const a = I(e);
      const r = a.lastIndexOf('.');
      if (r >= 0) {
        return a.substring(r);
      } else {
        return '';
      }
    }
    function I(e, t, n) {
      if (y(e = b(e)) === e.length) {
        return '';
      }
      const a = (e = A(e)).slice(Math.max(y(e), e.lastIndexOf(i.sep) + 1));
      const r = t !== undefined && n !== undefined ? C(a, t, n) : undefined;
      if (r) {
        return a.slice(0, a.length - r.length);
      } else {
        return a;
      }
    }
    function k(e, t, n) {
      p.assert(y(e) > 0 == y(t) > 0, 'Paths must either both be absolute or both be relative');
      const a = typeof n == 'function' ? n : l.identity;
      const r = function (e, t, n, a) {
        const r = h(e);
        const s = h(t);
        let i;
        for (i = 0; i < r.length && i < s.length; i++) {
          const e = a(r[i]);
          const t = a(s[i]);
          if (!(i === 0 ? d.equateStringsCaseInsensitive : n)(e, t)) {
            break;
          }
        }
        if (i === 0) {
          return s;
        }
        const o = s.slice(i);
        const l = [];
        for (; i < r.length; i++) {
          l.push('..');
        }
        return ['', ...l, ...o];
      }(e, t, typeof n == 'boolean' && n ? d.equateStringsCaseInsensitive : d.equateStringsCaseSensitive, a);
      return r;
    }
    function w(e) {
      const t = g();
      if (S(e)) {
        return e;
      } else {
        return e + t;
      }
    }
    function S(e) {
      if (e.length === 0) {
        return false;
      }
      const t = e.charCodeAt(e.length - 1);
      return t === 47 || t === 92;
    }
    function A(e) {
      if (S(e)) {
        return e.slice(0, e.length - 1);
      } else {
        return e;
      }
    }
    function x(e, t = false) {
      if (!t) {
        return i.extname(e);
      }
      const n = (e = P(e)).indexOf('.');
      return e.slice(n);
    }
    function P(e) {
      return i.basename(e);
    }
    function D(e) {
      return b(i.normalize(e));
    }
    function N(e) {
      return e.endsWith('.py') || e.endsWith('.pyi');
    }
    function F(e = i.sep) {
      if (e === '/') {
        return '/';
      } else {
        return '\\\\';
      }
    }
    function E(e, t, n) {
      if (!t.startsWith('.')) {
        t = `.${t}`;
      }
      if (e.length >= t.length && e.charCodeAt(e.length - t.length) === 46) {
        const a = e.slice(e.length - t.length);
        if (n(a, t)) {
          return a;
        }
      }
    }
  },
  56814: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.convertOffsetToPosition = s;
    exports.convertOffsetsToRange = i;
    exports.convertPositionToOffset = o;
    exports.convertRangeToTextRange = function (e, t) {
      const n = o(e.start, t);
      if (n === undefined) {
        return;
      }
      const a = o(e.end, t);
      if (a === undefined) {
        return;
      }
      return r.TextRange.fromBounds(n, a);
    };
    exports.convertTextRangeToRange = function (e, t) {
      return i(e.start, r.TextRange.getEnd(e), t);
    };
    exports.getLineEndPosition = function (e, t, n) {
      return s(l(e, t, n), e.lines);
    };
    exports.getLineEndOffset = l;
    const a = require(48281);
    const r = require(88754);
    function s(e, t) {
      if (t.end === 0) {
        return {
          line: 0,
          character: 0
        };
      }
      const n = e >= t.end ? t.count - 1 : t.getItemContaining(e);
      a.assert(n >= 0 && n <= t.count);
      const r = t.getItemAt(n);
      a.assert(r !== undefined);
      return {
        line: n,
        character: Math.max(0, Math.min(r.length, e - r.start))
      };
    }
    function i(e, t, n) {
      return {
        start: s(e, n),
        end: s(t, n)
      };
    }
    function o(e, t) {
      if (!(e.line >= t.count)) {
        return t.getItemAt(e.line).start + e.character;
      }
    }
    function l(e, t, n) {
      const a = e.lines.getItemAt(n);
      const s = r.TextRange.getEnd(a);
      let i = 0;
      for (let e = s - 1; e >= a.start; e--) {
        const n = t[e];
        if (n !== '\r' && n !== '\n') {
          break;
        }
        i++;
      }
      return s - i;
    }
  },
  30442: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ProgressReportTracker = undefined;
    exports.ProgressReportTracker = class {
      constructor(e) {
        this._reporter = e;
        this._isDisplayingProgress = false;
      }
      isEnabled(e) {
        var t;
        return !!this._isDisplayingProgress || (t = this._reporter.isEnabled(e)) !== null && t !== undefined && t;
      }
      begin() {
        if (!this._isDisplayingProgress) {
          this._isDisplayingProgress = true;
          this._reporter.begin();
        }
      }
      report(e) {
        if (this._isDisplayingProgress) {
          this._reporter.report(e);
        }
      }
      end() {
        if (this._isDisplayingProgress) {
          this._isDisplayingProgress = false;
          this._reporter.end();
        }
      }
    };
  },
  63808: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.latestStablePythonVersion = exports.pythonVersion3_14 = exports.pythonVersion3_13 = exports.pythonVersion3_12 = exports.pythonVersion3_11 = exports.pythonVersion3_10 = exports.pythonVersion3_9 = exports.pythonVersion3_8 = exports.pythonVersion3_7 = exports.pythonVersion3_6 = exports.pythonVersion3_5 = exports.pythonVersion3_4 = exports.pythonVersion3_3 = exports.pythonVersion3_2 = exports.pythonVersion3_1 = exports.pythonVersion3_0 = exports.PythonVersion = undefined;
    (function (e) {
      function t(e, t, n, a, r) {
        return {
          major: e,
          minor: t,
          micro: n,
          releaseLevel: a,
          serial: r
        };
      }
      function n(e, t) {
        return e.major === t.major && e.minor === t.minor && (e.micro === undefined || t.micro === undefined || e.micro === t.micro && (e.releaseLevel === undefined || t.releaseLevel === undefined || e.releaseLevel === t.releaseLevel && (e.serial === undefined || t.serial === undefined || e.serial === t.serial)));
      }
      function a(e, t) {
        return e.major > t.major || !(e.major < t.major) && (e.minor > t.minor || !(e.minor < t.minor) && e.micro !== undefined && t.micro !== undefined && !(e.micro < t.micro) && (e.micro > t.micro || e.releaseLevel !== undefined && t.releaseLevel !== undefined && !(e.releaseLevel < t.releaseLevel) && (e.releaseLevel > t.releaseLevel || e.serial !== undefined && t.serial !== undefined && !(e.serial < t.serial) && e.serial > t.serial)));
      }
      function r(e, t) {
        return n(e, t) || a(e, t);
      }
      function s(e) {
        return `${e.major}.${e.minor}`;
      }
      e.is = function (e) {
        return !!e && typeof e.major == 'number' && typeof e.minor == 'number' && (e.micro === undefined || typeof e.micro == 'number') && (e.releaseLevel === undefined || typeof e.releaseLevel == 'string') && (e.serial === undefined || typeof e.serial == 'number');
      };
      e.create = t;
      e.isEqualTo = n;
      e.isGreaterThan = a;
      e.isGreaterOrEqualTo = r;
      e.isLessThan = function (e, t) {
        return !r(e, t);
      };
      e.isLessOrEqualTo = function (e, t) {
        return !a(e, t);
      };
      e.toMajorMinorString = s;
      e.toString = function (e) {
        let t = s(e);
        if (e.micro === undefined) {
          return t;
        } else {
          t += `.${e.micro}`;
          return e.releaseLevel === undefined ? t : (t += `.${e.releaseLevel}`, e.serial === undefined || (t += `.${e.serial}`), t);
        }
      };
      e.fromString = function (e) {
        const n = e.split('.');
        if (n.length < 2) {
          return;
        }
        const a = parseInt(n[0], 10);
        const r = parseInt(n[1], 10);
        if (isNaN(a) || isNaN(r)) {
          return;
        }
        let s;
        let i;
        let o;
        if (n.length >= 3) {
          s = parseInt(n[2], 10);
          if (isNaN(s)) {
            s = undefined;
          }
        }
        if (n.length >= 4) {
          if (['alpha', 'beta', 'candidate', 'final'].some(e => e === n[3])) {
            i = n[3];
          }
        }
        if (n.length >= 5) {
          o = parseInt(n[4], 10);
          if (isNaN(o)) {
            o = undefined;
          }
        }
        return t(a, r, s, i, o);
      };
    })(n || (exports.PythonVersion = n = {}));
    exports.pythonVersion3_0 = n.create(3, 0);
    exports.pythonVersion3_1 = n.create(3, 1);
    exports.pythonVersion3_2 = n.create(3, 2);
    exports.pythonVersion3_3 = n.create(3, 3);
    exports.pythonVersion3_4 = n.create(3, 4);
    exports.pythonVersion3_5 = n.create(3, 5);
    exports.pythonVersion3_6 = n.create(3, 6);
    exports.pythonVersion3_7 = n.create(3, 7);
    exports.pythonVersion3_8 = n.create(3, 8);
    exports.pythonVersion3_9 = n.create(3, 9);
    exports.pythonVersion3_10 = n.create(3, 10);
    exports.pythonVersion3_11 = n.create(3, 11);
    exports.pythonVersion3_12 = n.create(3, 12);
    exports.pythonVersion3_13 = n.create(3, 13);
    exports.pythonVersion3_14 = n.create(3, 14);
    exports.latestStablePythonVersion = exports.pythonVersion3_13;
  },
  27643: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.RealTempFile = exports.WorkspaceFileWatcherProvider = exports.RealFileSystem = undefined;
    exports.createFromRealFileSystem = function (e, t, n) {
      return new x(e, t ?? new c.NullConsole(), n ?? m.nullFileWatcherProvider);
    };
    const i = require(49054);
    const o = require(21859);
    const l = __importStar(require(79896));
    const p = __importStar(require(57417));
    const d = require(28167);
    const c = require(25075);
    const u = require(77313);
    const m = require(12060);
    const y = require(54010);
    const g = require(16867);
    const h = require(27113);
    const f = require(5884);
    p.setGracefulCleanup();
    const T = '.zip';
    const v = '.egg';
    const b = '.jar';
    function _(e) {
      let t = e.indexOf(T);
      if (t <= 0 && (t = e.indexOf(v), t <= 0 && (t = e.indexOf(b), t <= 0))) {
        return null;
      }
      if (e[t - 1] === i.ppath.sep) {
        return null;
      }
      const n = t + 4;
      if (e.length > n && e[n] !== i.ppath.sep) {
        return null;
      } else {
        return e.slice(0, n);
      }
    }
    function C(e) {
      return e.endsWith(T) || e.endsWith(v) || e.endsWith(b);
    }
    const I = [Buffer.from([80, 75, 3, 4]), Buffer.from([80, 75, 5, 6]), Buffer.from([80, 75, 7, 8])];
    function k(e, t) {
      let n;
      try {
        n = e.openSync(t, 'r');
        const a = Buffer.alloc(4);
        if (e.readSync(n, a, 0, 4, 0) < 4) {
          return false;
        }
        for (const e of I) {
          if (a.compare(e) === 0) {
            return true;
          }
        }
        return false;
      } catch {
        return false;
      } finally {
        if (n !== undefined) {
          e.closeSync(n);
        }
      }
    }
    class w extends i.ZipOpenFS {
      findZip(e) {
        if (this.filter && !this.filter.test(e)) {
          return null;
        }
        let t = '';
        while (true) {
          const n = _(e.substr(t.length));
          if (!n) {
            return null;
          }
          t = this.pathUtils.join(t, n);
          if (this.isZip.has(t) === false) {
            if (this.notZip.has(t)) {
              continue;
            }
            try {
              if (!this.baseFs.lstatSync(t).isFile()) {
                this.notZip.add(t);
                continue;
              }
              if (!k(this.baseFs, t)) {
                this.notZip.add(t);
                continue;
              }
              try {
                this.getZipSync(t, () => {});
              } catch {
                this.notZip.add(t);
                continue;
              }
            } catch {
              return null;
            }
            this.isZip.add(t);
          }
          return {
            archivePath: t,
            subPath: this.pathUtils.join(i.PortablePath.root, e.substr(t.length))
          };
        }
      }
      getZipSync(e, t) {
        return super.getZipSync(e, t);
      }
    }
    class S extends i.PosixFS {
      constructor() {
        const e = new w({
          libzip: () => o.getLibzipSync(),
          useCache: true,
          maxOpenFiles: 80,
          readOnlyArchives: true
        });
        super(new i.VirtualFS({
          baseFs: e
        }));
        this._eggZipOpenFS = e;
      }
      isZip(e) {
        return !!this._eggZipOpenFS.findZip(this.mapToBase(e));
      }
    }
    const A = new S();
    class x {
      constructor(e, t, n) {
        this._caseSensitiveDetector = e;
        this._console = t;
        this._fileWatcherProvider = n;
      }
      existsSync(e) {
        if (e.isEmpty() || !g.FileUri.isFileUri(e)) {
          return false;
        }
        const t = e.getFilePath();
        try {
          return A.existsSync(t);
        } catch {
          return false;
        }
      }
      mkdirSync(e, t) {
        const n = e.getFilePath();
        A.mkdirSync(n, t);
      }
      chdir(e) {
        const t = e.getFilePath();
        if (d.isMainThread) {
          process.chdir(t);
        }
      }
      readdirSync(e) {
        const t = e.getFilePath();
        return A.readdirSync(t);
      }
      readdirEntriesSync(e) {
        const t = e.getFilePath();
        return A.readdirSync(t, {
          withFileTypes: true
        }).map(e => C(e.name) && e.isFile() && A.isZip(t) ? {
          name: e.name,
          parentPath: t,
          path: t,
          isFile: () => false,
          isDirectory: () => true,
          isBlockDevice: () => false,
          isCharacterDevice: () => false,
          isSymbolicLink: () => false,
          isFIFO: () => false,
          isSocket: () => false
        } : e);
      }
      readFileSync(e, t = null) {
        const n = e.getFilePath();
        if (t === 'utf8' || t === 'utf-8') {
          return A.readFileSync(n, 'utf8');
        } else {
          return A.readFileSync(n);
        }
      }
      writeFileSync(e, t, n) {
        const a = e.getFilePath();
        A.writeFileSync(a, t, n || undefined);
      }
      statSync(e) {
        if (g.FileUri.isFileUri(e)) {
          const t = e.getFilePath();
          const n = A.statSync(t);
          if (C(t) && n.isFile() && A.isZip(t)) {
            n.isFile = () => false;
            n.isDirectory = () => true;
            n.isZipDirectory = () => true;
            return n;
          } else {
            return n;
          }
        }
        return {
          isFile: () => false,
          isDirectory: () => false,
          isBlockDevice: () => false,
          isCharacterDevice: () => false,
          isSymbolicLink: () => false,
          isFIFO: () => false,
          isSocket: () => false,
          dev: 0,
          atimeMs: 0,
          mtimeMs: 0,
          ctimeMs: 0,
          birthtimeMs: 0,
          size: 0,
          blksize: 0,
          blocks: 0,
          ino: 0,
          mode: 0,
          nlink: 0,
          uid: 0,
          gid: 0,
          rdev: 0,
          atime: new Date(),
          mtime: new Date(),
          ctime: new Date(),
          birthtime: new Date()
        };
      }
      rmdirSync(e) {
        const t = e.getFilePath();
        A.rmdirSync(t);
      }
      unlinkSync(e) {
        const t = e.getFilePath();
        A.unlinkSync(t);
      }
      realpathSync(e) {
        try {
          const t = e.getFilePath();
          return h.Uri.file(A.realpathSync(t), this._caseSensitiveDetector);
        } catch (t) {
          return e;
        }
      }
      getModulePath() {
        return f.getRootUri(this._caseSensitiveDetector) || h.Uri.empty();
      }
      createFileSystemWatcher(e, t) {
        return this._fileWatcherProvider.createFileWatcher(e.map(e => e.getFilePath()), t);
      }
      createReadStream(e) {
        const t = e.getFilePath();
        return A.createReadStream(t);
      }
      createWriteStream(e) {
        const t = e.getFilePath();
        return A.createWriteStream(t);
      }
      copyFileSync(e, t) {
        const n = e.getFilePath();
        const a = t.getFilePath();
        A.copyFileSync(n, a);
      }
      readFile(e) {
        const t = e.getFilePath();
        return A.readFilePromise(t);
      }
      async readFileText(e, t) {
        const n = e.getFilePath();
        if (t === 'utf8' || t === 'utf-8') {
          return A.readFilePromise(n, 'utf8');
        }
        return (await A.readFilePromise(n)).toString(t);
      }
      realCasePath(e) {
        try {
          if (!this.existsSync(e)) {
            return e;
          }
          const t = l.realpathSync.native(e.getFilePath());
          if (e.getFilePath().toLowerCase() !== t.toLowerCase() || y.getRootLength(t) !== y.getRootLength(e.getFilePath())) {
            return e;
          } else {
            return h.Uri.file(t, this._caseSensitiveDetector);
          }
        } catch (t) {
          this._console.log(`Failed to get real file system casing for ${e}: ${t}`);
          return e;
        }
      }
      isMappedUri(e) {
        return false;
      }
      getOriginalUri(e) {
        return e;
      }
      getMappedUri(e) {
        return e;
      }
      isInZip(e) {
        const t = e.getFilePath();
        return /[^\\/]\.(?:egg|zip|jar)[\\/]/.test(t) && A.isZip(t);
      }
    }
    exports.RealFileSystem = x;
    exports.WorkspaceFileWatcherProvider = class {
      constructor() {
        this._fileWatchers = [];
      }
      createFileWatcher(e, t) {
        const n = this;
        const a = {
          close() {
            n._fileWatchers = n._fileWatchers.filter(e => e !== a);
          },
          workspacePaths: e,
          eventHandler: t
        };
        n._fileWatchers.push(a);
        return a;
      }
      onFileChange(e, t) {
        this._fileWatchers.forEach(n => {
          if (n.workspacePaths.some(e => t.getFilePath().startsWith(e))) {
            n.eventHandler(e, t.getFilePath());
          }
        });
      }
    };
    exports.RealTempFile = class {
      constructor() {}
      tmpdir() {
        return h.Uri.file(this._getTmpDir().name, this);
      }
      tmpfile(e) {
        const t = p.fileSync({
          dir: this._getTmpDir().name,
          discardDescriptor: true,
          ...e
        });
        return h.Uri.file(t.name, this);
      }
      mktmpdir() {
        const e = p.dirSync();
        return h.Uri.file(e.name, this);
      }
      dispose() {
        var e;
        try {
          if ((e = this._tmpdir) !== null && e !== undefined) {
            e.removeCallback();
          }
          this._tmpdir = undefined;
        } catch {}
      }
      isCaseSensitive(e) {
        return !e.startsWith(g.FileUriSchema) || this._isLocalFileSystemCaseSensitive();
      }
      _isLocalFileSystemCaseSensitive() {
        if (this._caseSensitivity === undefined) {
          this._caseSensitivity = this._isFileSystemCaseSensitiveInternal();
        }
        return this._caseSensitivity;
      }
      _getTmpDir() {
        if (!this._tmpdir) {
          this._tmpdir = p.dirSync({
            prefix: 'pyright'
          });
        }
        return this._tmpdir;
      }
      _isFileSystemCaseSensitiveInternal() {
        let e;
        try {
          let t;
          let n;
          do {
            t = `${u.randomBytesHex(21)}-a`;
            e = y.combinePaths(this._getTmpDir().name, t);
            n = y.combinePaths(this._getTmpDir().name, t.toUpperCase());
          } while (l.existsSync(e) || l.existsSync(n));
          l.writeFileSync(e, '', 'utf8');
          return !l.existsSync(n);
        } catch (e) {
          return false;
        } finally {
          if (e) {
            try {
              l.unlinkSync(e);
            } catch (e) {}
          }
        }
      }
    };
  },
  71745: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ServiceKeys = undefined;
    const a = require(42856);
    var r;
    (function (e) {
      e.fs = new a.ServiceKey();
      e.console = new a.ServiceKey();
      e.sourceFileFactory = new a.ServiceKey();
      e.partialStubs = new a.ServiceKey();
      e.symbolDefinitionProvider = new a.GroupServiceKey();
      e.symbolUsageProviderFactory = new a.GroupServiceKey();
      e.stateMutationListeners = new a.GroupServiceKey();
      e.tempFile = new a.ServiceKey();
      e.cacheManager = new a.ServiceKey();
      e.debugInfoInspector = new a.ServiceKey();
      e.caseSensitivityDetector = new a.ServiceKey();
      e.docStringService = new a.ServiceKey();
      e.windowService = new a.ServiceKey();
      e.commandService = new a.ServiceKey();
    })(r || (exports.ServiceKeys = r = {}));
  },
  42856: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ServiceProvider = exports.GroupServiceKey = exports.ServiceKey = undefined;
    const i = require(58147);
    const o = __importStar(require(48281));
    class l {}
    exports.ServiceKey = class extends l {
      constructor() {
        super(...arguments);
        this.kind = 'singleton';
      }
    };
    exports.GroupServiceKey = class extends l {
      constructor() {
        super(...arguments);
        this.kind = 'group';
      }
    };
    class p {
      constructor() {
        this._container = new Map();
      }
      add(e, t) {
        if (e.kind !== 'group') {
          if (e.kind !== 'singleton') {
            o.assertNever(e, `Unknown key type ${typeof e}`);
          } else {
            if (t !== undefined) {
              this._container.set(e, t);
            } else {
              this.remove(e);
            }
          }
        } else {
          this._addGroupService(e, t);
        }
      }
      remove(e, t) {
        if (e.kind !== 'group') {
          if (e.kind !== 'singleton') {
            o.assertNever(e, `Unknown key type ${typeof e}`);
          } else {
            this._container.delete(e);
          }
        } else {
          this._removeGroupService(e, t);
        }
      }
      tryGet(e) {
        return this._container.get(e);
      }
      get(e) {
        e.kind;
        const t = this.tryGet(e);
        if (t === undefined) {
          throw new Error(`Global service provider not initialized for ${e.toString()}`);
        }
        return t;
      }
      clone() {
        const e = new p();
        this._container.forEach((t, n) => {
          if (n.kind === 'group') {
            e._container.set(n, [...(t ?? [])]);
          } else {
            if (t.clone !== undefined) {
              e._container.set(n, t.clone());
            } else {
              e._container.set(n, t);
            }
          }
        });
        return e;
      }
      _addGroupService(e, t) {
        const n = this.tryGet(e);
        if (n !== undefined) {
          if (t !== undefined) {
            i.addIfUnique(n, t);
          }
        } else {
          this._container.set(e, [t]);
        }
      }
      _removeGroupService(e, t) {
        const n = this.tryGet(e);
        if (n !== undefined) {
          i.removeArrayElements(n, e => e === t);
        }
      }
    }
    exports.ServiceProvider = p;
  },
  23070: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createServiceProvider = function (...e) {
      const t = new c.ServiceProvider();
      e.forEach(e => {
        if (d.FileSystem.is(e)) {
          t.add(o.ServiceKeys.fs, e);
        }
        if (p.ConsoleInterface.is(e)) {
          t.add(o.ServiceKeys.console, e);
        }
        if (r.ISourceFileFactory.is(e)) {
          t.add(o.ServiceKeys.sourceFileFactory, e);
        }
        if (i.SupportPartialStubs.is(e)) {
          t.add(o.ServiceKeys.partialStubs, e);
        }
        if (d.TempFile.is(e)) {
          t.add(o.ServiceKeys.tempFile, e);
        }
        if (l.CaseSensitivityDetector.is(e)) {
          t.add(o.ServiceKeys.caseSensitivityDetector, e);
        }
        if (a.CacheManager.is(e)) {
          t.add(o.ServiceKeys.cacheManager, e);
        }
        if (u.DocStringService.is(e)) {
          t.add(o.ServiceKeys.docStringService, e);
        }
        if (m.WindowService.is(e)) {
          t.add(o.ServiceKeys.windowService, e);
        }
        if (m.CommandService.is(e)) {
          t.add(o.ServiceKeys.commandService, e);
        }
      });
      return t;
    };
    const a = require(32720);
    const r = require(60356);
    const s = require(53266);
    const i = require(62226);
    const o = require(71745);
    const l = require(7095);
    const p = require(25075);
    const d = require(66643);
    const c = require(42856);
    const u = require(71458);
    const m = require(1394);
    c.ServiceProvider.prototype.fs = function () {
      return this.get(o.ServiceKeys.fs);
    };
    c.ServiceProvider.prototype.console = function () {
      return this.get(o.ServiceKeys.console);
    };
    c.ServiceProvider.prototype.partialStubs = function () {
      return this.get(o.ServiceKeys.partialStubs);
    };
    c.ServiceProvider.prototype.tmp = function () {
      return this.tryGet(o.ServiceKeys.tempFile);
    };
    c.ServiceProvider.prototype.sourceFileFactory = function () {
      return this.tryGet(o.ServiceKeys.sourceFileFactory) || y;
    };
    c.ServiceProvider.prototype.docStringService = function () {
      return this.tryGet(o.ServiceKeys.docStringService) || new u.PyrightDocStringService();
    };
    c.ServiceProvider.prototype.cacheManager = function () {
      return this.tryGet(o.ServiceKeys.cacheManager);
    };
    const y = {
      createSourceFile: (e, t, n, a, r, i, o, l, p) => new s.SourceFile(e, t, n, a, r, i, o, l, p)
    };
  },
  89740: function (module, exports, require) {
    var __importDefault = this && this.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.computeCompletionSimilarity = function (e, t) {
      if (t.startsWith(e)) {
        return 1;
      }
      const n = t.toLocaleLowerCase();
      const a = e.toLocaleLowerCase();
      if (n.startsWith(a)) {
        return 0.75;
      }
      let s = n.length;
      let i = Number.MAX_VALUE;
      while (s > 0) {
        const e = r.default(n.substr(0, s), a);
        if (e < i) {
          i = e;
        }
        s--;
      }
      if (i >= e.length) {
        return 0;
      }
      return (e.length - i) / e.length * 0.5;
    };
    exports.isPatternInSymbol = function (e, t) {
      const n = e.toLocaleLowerCase();
      const a = t.toLocaleLowerCase();
      const r = n.length;
      const s = a.length;
      let i = 0;
      let o = 0;
      while (i < r && o < s) {
        if (n[i] === a[o]) {
          i += 1;
        }
        o += 1;
      }
      return i === r;
    };
    exports.hashString = function (e) {
      let t = 0;
      for (let n = 0; n < e.length; n++) {
        t = (t << 5) - t + e.charCodeAt(n) | 0;
      }
      return t;
    };
    exports.compareStringsCaseInsensitive = i;
    exports.compareStringsCaseSensitive = o;
    exports.getStringComparer = function (e) {
      if (e) {
        return i;
      } else {
        return o;
      }
    };
    exports.equateStringsCaseInsensitive = function (e, t) {
      return i(e, t) === 0;
    };
    exports.equateStringsCaseSensitive = function (e, t) {
      return o(e, t) === 0;
    };
    exports.getCharacterCount = function (e, t) {
      let n = 0;
      for (let a = 0; a < e.length; a++) {
        if (e[a] === t) {
          n++;
        }
      }
      return n;
    };
    exports.getLastDottedString = function (e) {
      const t = e.lastIndexOf('.');
      if (t > 0) {
        return e.substring(t + 1);
      } else {
        return e;
      }
    };
    exports.truncate = function (e, t) {
      if (e.length > t) {
        return e.substring(0, t - 3) + '...';
      }
      return e;
    };
    exports.escapeRegExp = function (e) {
      return e.replace(/[\\^$.*+?()[\]{}|]/g, '\\$&');
    };
    const r = __importDefault(require(44653));
    const s = require(34455);
    function i(e, t) {
      if (e === t) {
        return 0;
      } else {
        if (e === undefined) {
          return -1;
        } else {
          if (t === undefined) {
            return 1;
          } else {
            return s.compareComparableValues(e.toUpperCase(), t.toUpperCase());
          }
        }
      }
    }
    function o(e, t) {
      return s.compareComparableValues(e, t);
    }
  },
  93779: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TextEditTracker = undefined;
    const i = require(26687);
    const o = require(47610);
    const l = __importStar(require(41557));
    const p = require(58147);
    const d = __importStar(require(48281));
    const c = require(90010);
    const u = require(56814);
    const m = require(88754);
    const y = require(27113);
    exports.TextEditTracker = class {
      constructor(e = true) {
        this._mergeOnlyDuplications = e;
        this._nodesRemoved = new Map();
        this._results = new Map();
        this._pendingNodeToRemove = [];
      }
      addEdits(...e) {
        e.forEach(e => this.addEdit(e.fileUri, e.range, e.replacementText));
      }
      addEdit(e, t, n) {
        const a = p.getOrAdd(this._results, e.key, () => []);
        const r = this._getEditsToMerge(a, t, n);
        if (r.length > 0) {
          this._removeEdits(a, r);
          m.extendRange(t, r.map(e => e.range));
        }
        a.push({
          fileUri: e,
          range: t,
          replacementText: n
        });
      }
      addEditWithTextRange(e, t, n) {
        const a = i.getFileInfo(e.parserOutput.parseTree).fileUri;
        if (e.text.substr(t.start, t.length) !== n) {
          this.addEdit(a, u.convertTextRangeToRange(t, e.tokenizerOutput.lines), n);
        }
      }
      deleteImportName(e, t) {
        const n = t.nodeType === 24 ? t.parent.d.list : t.parent.d.imports;
        const a = i.getFileInfo(e.parserOutput.parseTree).fileUri;
        o.getTextRangeForImportNameDeletion(e, n, n.findIndex(e => e === t)).forEach(t => this.addEditWithTextRange(e, t, ''));
        this._markNodeRemoved(t, e);
        let r = 0;
        for (r = n.length - 1; r >= 0 && this._nodesRemoved.has(n[r]); r--);
        if (r === -1) {
          const n = t.parent;
          if (n) {
            this.addEdit(a, l.getFullStatementRange(n, e), '');
          }
        } else {
          if (r >= 0 && r < n.length - 2) {
            const t = m.TextRange.getEnd(n[r]);
            const a = m.TextRange.getEnd(n[r + 1]) - t;
            this.addEditWithTextRange(e, {
              start: t,
              length: a
            }, '');
          }
        }
      }
      addOrUpdateImport(e, t, n, a, r, s) {
        if (!r || !this._tryUpdateImport(e, t, n, r, s)) {
          this._addImport(e, t, n, a, r);
        }
      }
      removeNodes(...e) {
        this._pendingNodeToRemove.push(...e);
      }
      isNodeRemoved(e) {
        return this._nodesRemoved.has(e);
      }
      getEdits(e) {
        this._processNodeRemoved(e);
        const t = [];
        this._results.forEach(e => p.appendArray(t, e));
        return t;
      }
      _addImport(e, t, n, a, r) {
        const s = i.getFileInfo(e.parserOutput.parseTree).fileUri;
        this.addEdits(...o.getTextEditsForAutoImportInsertion(r ?? [], n, t, a, e, u.convertOffsetToPosition(e.parserOutput.parseTree.length, e.tokenizerOutput.lines)).map(e => ({
          fileUri: s,
          range: e.range,
          replacementText: e.replacementText
        })));
      }
      _tryUpdateImport(e, t, n, a, r) {
        if (!r) {
          return false;
        }
        const s = t.orderedImports.find(e => e.node.nodeType === 25 && (e.moduleName === n.nameForImportFrom || e.moduleName === n.name));
        if (!s || s.node.nodeType !== 25 || s.node.d.isWildcardImport) {
          return false;
        }
        const l = i.getFileInfo(e.parserOutput.parseTree).fileUri;
        const p = o.getTextEditsForAutoImportSymbolAddition(a, s, e);
        if (s.node !== r.currentFromImport) {
          this.addEdits(...p.map(e => ({
            fileUri: l,
            range: e.range,
            replacementText: e.replacementText
          })));
          return true;
        }
        const d = r.originalModuleName.split('.');
        const c = n.name.split('.');
        if (!o.haveSameParentModule(d, c)) {
          return false;
        }
        if (a.length !== 1 || p.length !== 1) {
          return false;
        }
        const m = this._getDeletionsForSpan(l, p[0].range);
        if (m.length === 0) {
          this.addEdit(l, p[0].range, p[0].replacementText);
          return true;
        }
        const y = d[d.length - 1];
        const g = c[c.length - 1];
        const h = a[0].alias === g ? y : a[0].alias;
        const f = r.currentFromImport.d.imports.find(e => {
          var t;
          return e.d.name.d.value === y && ((t = e.d.alias) === null || t === undefined ? undefined : t.d.value) === h;
        });
        return !!f && (this._removeEdits(l, m), f.d.alias && this._nodesRemoved.delete(f.d.alias), this.addEdit(l, u.convertTextRangeToRange(f.d.name, e.tokenizerOutput.lines), g), true);
      }
      _getDeletionsForSpan(e, t) {
        return this._getOverlappingForSpan(e, t).filter(e => e.replacementText === '');
      }
      _removeEdits(e, t) {
        var n;
        if (y.Uri.is(e)) {
          e = (n = this._results.get(e.key)) !== null && n !== undefined ? n : [];
        }
        p.removeArrayElements(e, e => t.some(t => c.FileEditAction.areEqual(e, t)));
      }
      _getEditsToMerge(e, t, n) {
        const a = this._getOverlappingForSpan(e, t);
        if (this._mergeOnlyDuplications && a.length > 0) {
          if (n === '') {
            return a.filter(e => e.replacementText === '');
          } else {
            return a.filter(e => e.replacementText === n && (m.doesRangeContain(t, e.range) || m.doesRangeContain(e.range, t)));
          }
        } else {
          return a.filter(e => e.replacementText === '' || e.replacementText === n && (m.doesRangeContain(t, e.range) || m.doesRangeContain(e.range, t)));
        }
      }
      _getOverlappingForSpan(e, t) {
        var n;
        if (y.Uri.is(e)) {
          e = (n = this._results.get(e.key)) !== null && n !== undefined ? n : [];
        }
        return e.filter(e => m.doRangesIntersect(e.range, t));
      }
      _processNodeRemoved(e) {
        while (this._pendingNodeToRemove.length > 0) {
          const t = this._pendingNodeToRemove.length;
          const n = this._pendingNodeToRemove[this._pendingNodeToRemove.length - 1];
          this._handleImportNameNode(n, e);
          if (this._pendingNodeToRemove.length === t) {
            d.assert(`please add handler for ${n.node.nodeType}`);
            this._pendingNodeToRemove.pop();
            const e = i.getFileInfo(n.parseFileResults.parserOutput.parseTree);
            this.addEdit(e.fileUri, u.convertTextRangeToRange(n.node, e.lines), '');
          }
        }
      }
      _handleImportNameNode(e, t) {
        const n = e.node;
        if (n.nodeType !== 38) {
          return false;
        }
        const a = e.parseFileResults.parserOutput.parseTree;
        const r = i.getFileInfo(a);
        const s = o.getContainingImportStatement(l.findNodeByOffset(a, n.start), t);
        if (!s) {
          return false;
        }
        const p = o.getAllImportNames(s);
        const d = this._pendingNodeToRemove.filter(e => p.some(t => m.TextRange.overlapsRange(e.node, t)));
        if (p.length === d.length) {
          this.addEdit(r.fileUri, l.getFullStatementRange(s, e.parseFileResults), '');
          this._removeNodesHandled(d);
          return true;
        }
        const c = [];
        for (let e = 0; e < p.length; e++) {
          const t = p[e];
          if (d.some(e => m.TextRange.overlapsRange(e.node, t))) {
            c.push(e);
          }
        }
        if (c.length === 0) {
          return false;
        }
        o.getTextRangeForImportNameDeletion(e.parseFileResults, p, ...c).forEach(e => this.addEdit(r.fileUri, u.convertTextRangeToRange(e, r.lines), ''));
        this._removeNodesHandled(d);
        return true;
      }
      _removeNodesHandled(e) {
        e.forEach(e => this._markNodeRemoved(e.node, e.parseFileResults));
        p.removeArrayElements(this._pendingNodeToRemove, e => this._nodesRemoved.has(e.node));
      }
      _markNodeRemoved(e, t) {
        this._nodesRemoved.set(e, t);
        if (e.nodeType === 24) {
          this._nodesRemoved.set(e.d.module, t);
          e.d.module.d.nameParts.forEach(e => this._nodesRemoved.set(e, t));
          if (e.d.alias) {
            this._nodesRemoved.set(e.d.alias, t);
          }
        } else {
          if (e.nodeType === 26) {
            this._nodesRemoved.set(e.d.name, t);
            if (e.d.alias) {
              this._nodesRemoved.set(e.d.alias, t);
            }
          }
        }
      }
    };
  },
  88754: (module, exports) => {
    var n;
    var a;
    var r;
    function s(e, t) {
      if (e.line < t.line) {
        return -1;
      } else {
        if (e.line > t.line) {
          return 1;
        } else {
          if (e.character < t.character) {
            return -1;
          } else {
            if (e.character > t.character) {
              return 1;
            } else {
              return 0;
            }
          }
        }
      }
    }
    function i() {
      return {
        line: 0,
        character: 0
      };
    }
    function o(e, t) {
      return s(e, t) === 0;
    }
    function l(e) {
      return e.character === 0 && e.line === 0;
    }
    function p(e, t) {
      if (t) {
        if (Array.isArray(t)) {
          t.forEach(t => {
            p(e, t);
          });
        } else {
          if (s(t.start, e.start) < 0) {
            e.start = t.start;
          }
          if (s(t.end, e.end) > 0) {
            e.end = t.end;
          }
        }
      }
    }
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Range = exports.Position = exports.TextRange = undefined;
    exports.comparePositions = s;
    exports.getEmptyPosition = i;
    exports.doRangesOverlap = function (e, t) {
      if (s(t.start, e.end) >= 0) {
        return false;
      }
      if (s(e.start, t.end) >= 0) {
        return false;
      }
      return true;
    };
    exports.doRangesIntersect = function (e, t) {
      if (s(t.start, e.end) > 0) {
        return false;
      }
      if (s(e.start, t.end) > 0) {
        return false;
      }
      return true;
    };
    exports.doesRangeContain = function e(t, n) {
      if (a.is(n)) {
        return s(t.start, n) <= 0 && s(t.end, n) >= 0;
      }
      return e(t, n.start) && e(t, n.end);
    };
    exports.positionsAreEqual = o;
    exports.rangesAreEqual = function (e, t) {
      return o(e.start, t.start) && o(e.end, t.end);
    };
    exports.getEmptyRange = function () {
      return {
        start: {
          line: 0,
          character: 0
        },
        end: {
          line: 0,
          character: 0
        }
      };
    };
    exports.isEmptyPosition = l;
    exports.isEmptyRange = function (e) {
      return l(e.start) && l(e.end);
    };
    exports.extendRange = p;
    exports.combineRange = function (e) {
      if (e.length === 0) {
        return;
      }
      const t = e[0];
      for (let n = 1; n < e.length; n++) {
        p(t, e[n]);
      }
      return t;
    };
    (function (e) {
      function t(e, t) {
        if (e < 0) {
          throw new Error('start must be non-negative');
        }
        if (t < 0) {
          throw new Error('length must be non-negative');
        }
        return {
          start: e,
          length: t
        };
      }
      function n(e) {
        return e.start + e.length;
      }
      function a(e, t) {
        return t >= e.start && t <= n(e);
      }
      function r(e, t) {
        let a = e;
        if (t) {
          if (Array.isArray(t)) {
            t.forEach(e => {
              a = r(a, e);
            });
          } else {
            if (t.start < a.start) {
              a = {
                start: t.start,
                length: a.length + a.start - t.start
              };
            }
            const e = n(t);
            const r = n(a);
            if (e > r) {
              a = {
                start: a.start,
                length: a.length + e - r
              };
            }
          }
        }
        return a;
      }
      e.create = t;
      e.fromBounds = function (e, n) {
        if (e < 0) {
          throw new Error('start must be non-negative');
        }
        if (e > n) {
          throw new Error('end must be greater than or equal to start');
        }
        return t(e, n - e);
      };
      e.getEnd = n;
      e.contains = function (e, t) {
        return t >= e.start && t < n(e);
      };
      e.containsRange = function (e, t) {
        return t.start >= e.start && n(t) <= n(e);
      };
      e.overlaps = a;
      e.overlapsRange = function (e, t) {
        return a(e, t.start) || a(t, e.start);
      };
      e.extend = r;
      e.combine = function (e) {
        if (e.length === 0) {
          return;
        }
        let t = {
          start: e[0].start,
          length: e[0].length
        };
        for (let n = 1; n < e.length; n++) {
          t = r(t, e[n]);
        }
        return t;
      };
    })(n || (exports.TextRange = n = {}));
    (function (e) {
      e.is = function (e) {
        const t = e;
        return t && t.line !== undefined && t.character !== undefined;
      };
      e.print = function (e) {
        return `(${e.line}:${e.character})`;
      };
    })(a || (exports.Position = a = {}));
    (function (e) {
      e.is = function (e) {
        const t = e;
        return t && t.start !== undefined && t.end !== undefined;
      };
      e.print = function (e) {
        return `${a.print(e.start)}-${a.print(e.end)}`;
      };
    })(r || (exports.Range = r = {}));
  },
  95418: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TextRangeCollection = undefined;
    exports.getIndexContaining = r;
    const a = require(88754);
    function r(e, t, n = a.TextRange.contains) {
      if (e.length === 0) {
        return -1;
      }
      let r = 0;
      let i = e.length - 1;
      while (r <= i) {
        const o = Math.floor(r + (i - r) / 2);
        const l = s(e, o, r, i);
        if (l === undefined) {
          return -1;
        }
        if (n(l.item, t)) {
          return l.index;
        }
        const p = s(e, o + 1, o + 1, i);
        if (p === undefined) {
          return -1;
        }
        if (o < e.length - 1 && a.TextRange.getEnd(l.item) <= t && t < p.item.start) {
          return -1;
        }
        if (t < l.item.start) {
          i = o - 1;
        } else {
          r = o + 1;
        }
      }
      return -1;
    }
    function s(e, t, n, a) {
      const r = e[t];
      if (r) {
        return {
          index: t,
          item: r
        };
      }
      for (let n = t + 1; n <= a; n++) {
        const t = e[n];
        if (t) {
          return {
            index: n,
            item: t
          };
        }
      }
      for (let a = t - 1; a >= n; a--) {
        const t = e[a];
        if (t) {
          return {
            index: a,
            item: t
          };
        }
      }
    }
    exports.TextRangeCollection = class {
      constructor(e) {
        this._items = e;
      }
      get start() {
        if (this._items.length > 0) {
          return this._items[0].start;
        } else {
          return 0;
        }
      }
      get end() {
        const e = this._items[this._items.length - 1];
        if (this._items.length > 0) {
          return e.start + e.length;
        } else {
          return 0;
        }
      }
      get length() {
        return this.end - this.start;
      }
      get count() {
        return this._items.length;
      }
      contains(e) {
        return e >= this.start && e < this.end;
      }
      getItemAt(e) {
        if (e < 0 || e >= this._items.length) {
          throw new Error('index is out of range');
        }
        return this._items[e];
      }
      getItemAtPosition(e) {
        if (this.count === 0) {
          return -1;
        }
        if (e < this.start) {
          return -1;
        }
        if (e > this.end) {
          return -1;
        }
        let t = 0;
        let n = this.count - 1;
        while (t < n) {
          const a = Math.floor(t + (n - t) / 2);
          const r = this._items[a];
          if (e >= r.start && (a >= this.count - 1 || e < this._items[a + 1].start)) {
            return a;
          }
          if (e < r.start) {
            n = a - 1;
          } else {
            t = a + 1;
          }
        }
        return t;
      }
      getItemContaining(e) {
        if (this.count === 0 || e < this.start || e > this.end) {
          return -1;
        } else {
          return r(this._items, e);
        }
      }
    };
  },
  71582: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.timingStats = exports.TimingStats = exports.TimingStat = exports.Duration = undefined;
    class n {
      constructor() {
        this._startTime = Date.now();
      }
      getDurationInMilliseconds() {
        return Date.now() - this._startTime;
      }
      getDurationInSeconds() {
        return this.getDurationInMilliseconds() / 1000;
      }
    }
    exports.Duration = n;
    class a {
      constructor() {
        this.totalTime = 0;
        this.callCount = 0;
        this.isTiming = false;
      }
      timeOperation(e, ...t) {
        this.callCount++;
        if (this.isTiming) {
          return e(...t);
        }
        {
          this.isTiming = true;
          const a = new n();
          const r = e(...t);
          this.totalTime += a.getDurationInMilliseconds();
          this.isTiming = false;
          return r;
        }
      }
      subtractFromTime(e) {
        if (this.isTiming) {
          this.isTiming = false;
          const t = new n();
          e();
          this.totalTime -= t.getDurationInMilliseconds();
          this.isTiming = true;
        } else {
          e();
        }
      }
      printTime() {
        const e = this.totalTime / 1000;
        return (Math.round(e * 100) / 100).toString() + 'sec';
      }
    }
    exports.TimingStat = a;
    class r {
      constructor() {
        this.totalDuration = new n();
        this.findFilesTime = new a();
        this.readFileTime = new a();
        this.tokenizeFileTime = new a();
        this.parseFileTime = new a();
        this.resolveImportsTime = new a();
        this.cycleDetectionTime = new a();
        this.bindTime = new a();
        this.typeCheckerTime = new a();
        this.typeEvaluationTime = new a();
      }
      printSummary(e) {
        e.info(`Completed in ${this.totalDuration.getDurationInSeconds()}sec`);
      }
      printDetails(e) {
        e.info('');
        e.info('Timing stats');
        e.info(`Find Source Files:    ${this.findFilesTime.printTime()}`);
        e.info(`Read Source Files:    ${this.readFileTime.printTime()}`);
        e.info(`Tokenize:             ${this.tokenizeFileTime.printTime()}`);
        e.info(`Parse:                ${this.parseFileTime.printTime()}`);
        e.info(`Resolve Imports:      ${this.resolveImportsTime.printTime()}`);
        e.info(`Bind:                 ${this.bindTime.printTime()}`);
        e.info(`Check:                ${this.typeCheckerTime.printTime()}`);
        e.info(`Detect Cycles:        ${this.cycleDetectionTime.printTime()}`);
      }
      getTotalDuration() {
        return this.totalDuration.getDurationInSeconds();
      }
    }
    exports.TimingStats = r;
    exports.timingStats = new r();
  },
  33351: (module, exports, require) => {
    let a;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.parse = undefined;
    exports.ensureTomlModuleLoaded = async function () {
      await r;
    };
    const r = (async () => {
      a = await Promise.resolve().then(require.bind(require, 69214));
    })();
    exports.parse = e => {
      if (!a) {
        throw new Error('TOML module not loaded');
      }
      return a.parse(e);
    };
  },
  56426: function (module, exports, require) {
    var a = this && this.__decorate || function (e, t, n, a) {
      var r;
      var s = arguments.length;
      var i = s < 3 ? t : a === null ? a = Object.getOwnPropertyDescriptor(t, n) : a;
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') {
        i = Reflect.decorate(e, t, n, a);
      } else {
        for (var o = e.length - 1; o >= 0; o--) {
          if (r = e[o]) {
            i = (s < 3 ? r(i) : s > 3 ? r(t, n, i) : r(t, n)) || i;
          }
        }
      }
      if (s > 3 && i) {
        Object.defineProperty(t, n, i);
      }
      return i;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.BaseUri = undefined;
    const r = require(58147);
    const s = require(54010);
    const i = require(12365);
    class o {
      constructor(e) {
        this._key = e;
      }
      get key() {
        return this._key;
      }
      get fileNameWithoutExtensions() {
        const e = this.fileName;
        const t = e.lastIndexOf('.');
        if (t > 0) {
          return e.slice(0, t);
        } else {
          return e;
        }
      }
      get packageUri() {
        return this.addExtension('.py');
      }
      get packageStubUri() {
        return this.addExtension('.pyi');
      }
      get initPyUri() {
        return this.combinePathsUnsafe('__init__.py');
      }
      get initPyiUri() {
        return this.combinePathsUnsafe('__init__.pyi');
      }
      get pytypedUri() {
        return this.combinePathsUnsafe('py.typed');
      }
      isEmpty() {
        return false;
      }
      replaceExtension(e) {
        const t = this.getDirectory();
        const n = this.fileName;
        const a = n.slice(0, n.length - this.lastExtension.length) + e;
        return t.combinePathsUnsafe(a);
      }
      addExtension(e) {
        return this.addPath(e);
      }
      hasExtension(e) {
        if (this.isCaseSensitive) {
          return this.lastExtension === e;
        } else {
          return this.lastExtension.toLowerCase() === e.toLowerCase();
        }
      }
      containsExtension(e) {
        return this.fileName.split(/(?=\.)/g).some(t => this.isCaseSensitive ? t === e : t.toLowerCase() === e.toLowerCase());
      }
      getRootPathLength() {
        return this.getRootPath().length;
      }
      isUntitled() {
        return this.scheme === 'untitled';
      }
      equals(e) {
        return this.key === (e == null ? undefined : e.key);
      }
      pathStartsWith(e) {
        return this.getComparablePath().startsWith(e);
      }
      pathEndsWith(e) {
        return this.getComparablePath().endsWith(e);
      }
      pathIncludes(e) {
        return this.getComparablePath().includes(e);
      }
      getRelativePath(e) {
        if (this.scheme === e.scheme && e.isChild(this)) {
          const t = this.getRelativePathComponents(e);
          if (t.length > 0) {
            return ['.', ...t].join('/');
          }
        }
      }
      getPathComponents() {
        return Object.freeze(this.getPathComponentsImpl());
      }
      getRelativePathComponents(e) {
        const t = this.getPathComponents();
        const n = e.getPathComponents();
        let a;
        for (a = 0; a < t.length && a < n.length; a++) {
          const e = t[a];
          const r = n[a];
          if (!(this.isCaseSensitive ? e === r : e.toLowerCase() === r.toLowerCase())) {
            break;
          }
        }
        if (a === 0) {
          return n;
        }
        const r = n.slice(a);
        const s = [];
        for (; a < t.length; a++) {
          s.push('..');
        }
        return [...s, ...r];
      }
      getShortenedFileName(e = 15) {
        return s.getShortenedFileName(this.getPath(), e);
      }
      normalizeSlashes(e) {
        if (e.includes('\\')) {
          return e.replace(/\\/g, '/');
        } else {
          return e;
        }
      }
      static combinePathElements(e, t, ...n) {
        for (const a of n) {
          if (a) {
            if (e && s.getRootLength(a) === 0) {
              if (e.endsWith(t)) {
                e += a;
              } else {
                e += t + a;
              }
            } else {
              e = a;
            }
          }
        }
        return e;
      }
      reducePathComponents(e) {
        if (!r.some(e)) {
          return [];
        }
        const t = [e[0]];
        for (let n = 1; n < e.length; n++) {
          const a = e[n];
          if (a && a !== '.') {
            if (a === '..') {
              if (t.length > 1) {
                if (t[t.length - 1] !== '..') {
                  t.pop();
                  continue;
                }
              } else {
                if (t[0]) {
                  continue;
                }
              }
            }
            t.push(a);
          }
        }
        return t;
      }
    }
    exports.BaseUri = o;
    a([i.cacheProperty()], o.prototype, 'packageUri', null);
    a([i.cacheProperty()], o.prototype, 'packageStubUri', null);
    a([i.cacheProperty()], o.prototype, 'initPyUri', null);
    a([i.cacheProperty()], o.prototype, 'initPyiUri', null);
    a([i.cacheProperty()], o.prototype, 'pytypedUri', null);
  },
  1969: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ConstantUri = undefined;
    const a = require(56426);
    class r extends a.BaseUri {
      constructor(e) {
        super(e);
      }
      get scheme() {
        return '';
      }
      get isCaseSensitive() {
        return true;
      }
      get fileName() {
        return '';
      }
      get lastExtension() {
        return '';
      }
      get root() {
        return this;
      }
      get fragment() {
        return '';
      }
      get query() {
        return '';
      }
      equals(e) {
        return this === e;
      }
      toJsonObj() {
        throw new Error('constant uri can\'t be serialized');
      }
      toString() {
        return this.key;
      }
      toUserVisibleString() {
        return '';
      }
      matchesRegex(e) {
        return false;
      }
      withFragment(e) {
        return this;
      }
      withQuery(e) {
        return this;
      }
      addPath(e) {
        return this;
      }
      getDirectory() {
        return this;
      }
      isRoot() {
        return false;
      }
      isChild(e, t) {
        return false;
      }
      isLocal() {
        return false;
      }
      startsWith(e, t) {
        return false;
      }
      getPathLength() {
        return 0;
      }
      resolvePaths(...e) {
        return this;
      }
      combinePaths(...e) {
        return this;
      }
      combinePathsUnsafe(...e) {
        return this;
      }
      getPath() {
        return '';
      }
      getFilePath() {
        return '';
      }
      stripExtension() {
        return this;
      }
      stripAllExtensions() {
        return this;
      }
      getRootPath() {
        return '';
      }
      getComparablePath() {
        return '';
      }
      getPathComponentsImpl() {
        return [];
      }
    }
    exports.ConstantUri = r;
  },
  27594: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.EmptyUri = undefined;
    const a = require(1969);
    const r = '<empty>';
    class s extends a.ConstantUri {
      constructor() {
        super(r);
      }
      static get instance() {
        return s._instance;
      }
      toJsonObj() {
        return {
          _key: r
        };
      }
      static isEmptyUri(e) {
        return (e == null ? undefined : e._key) === r;
      }
      isEmpty() {
        return true;
      }
      toString() {
        return '';
      }
    }
    exports.EmptyUri = s;
    s._instance = new s();
  },
  16867: function (module, exports, require) {
    var a = this && this.__decorate || function (e, t, n, a) {
      var r;
      var s = arguments.length;
      var i = s < 3 ? t : a === null ? a = Object.getOwnPropertyDescriptor(t, n) : a;
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') {
        i = Reflect.decorate(e, t, n, a);
      } else {
        for (var o = e.length - 1; o >= 0; o--) {
          if (r = e[o]) {
            i = (s < 3 ? r(i) : s > 3 ? r(t, n, i) : r(t, n)) || i;
          }
        }
      }
      if (s > 3 && i) {
        Object.defineProperty(t, n, i);
      }
      return i;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FileUri = exports.FileUriSchema = undefined;
    const r = require(75559);
    const s = require(34455);
    const i = require(54010);
    const o = require(56426);
    const l = require(12365);
    exports.FileUriSchema = 'file';
    class p extends o.BaseUri {
      constructor(e, t, n, a, r, s) {
        super(s ? e : e.toLowerCase());
        this._filePath = t;
        this._query = n;
        this._fragment = a;
        this._originalString = r;
        this._isCaseSensitive = s;
      }
      get scheme() {
        return exports.FileUriSchema;
      }
      get fragment() {
        return this._fragment;
      }
      get query() {
        return this._query;
      }
      get fileName() {
        return i.getFileName(this._filePath);
      }
      get lastExtension() {
        return i.getFileExtension(this._filePath);
      }
      get root() {
        const e = this.getRootPath();
        if (e !== this._filePath) {
          return p.createFileUri(e, '', '', undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      get isCaseSensitive() {
        return this._isCaseSensitive;
      }
      static createFileUri(e, t, n, a, r) {
        e = i.isDiskPathRoot(e) ? i.ensureTrailingDirectorySeparator(e) : e;
        const s = p._createKey(e, t, n);
        return new p(s, e, t, n, a, r);
      }
      static isFileUri(e) {
        return (e == null ? undefined : e._filePath) !== undefined && (e == null ? undefined : e._key) !== undefined;
      }
      static fromJsonObj(e) {
        if (s.isArray(e)) {
          const t = e;
          return p.createFileUri(t[1], t[2], t[3], t[4], t[5] === 1);
        }
        return p.createFileUri(e._filePath, e._query, e._fragment, e._originalString, e._isCaseSensitive);
      }
      toJsonObj() {
        return [0, this._filePath, this._query, this._fragment, this._originalString, this._isCaseSensitive ? 1 : 0];
      }
      matchesRegex(e) {
        return e.test(this._getNormalizedPath());
      }
      toString() {
        if (!this._formattedString) {
          this._formattedString = this._originalString || r.URI.file(this._filePath).with({
            query: this._query,
            fragment: this._fragment
          }).toString();
        }
        return this._formattedString;
      }
      toUserVisibleString() {
        return this._filePath;
      }
      addPath(e) {
        return p.createFileUri(this._filePath + e, '', '', undefined, this._isCaseSensitive);
      }
      isRoot() {
        return i.isDiskPathRoot(this._filePath);
      }
      isChild(e) {
        return !!p.isFileUri(e) && e._filePath.length < this._filePath.length && this.startsWith(e);
      }
      isLocal() {
        return true;
      }
      startsWith(e) {
        if ((e == null ? undefined : e.scheme) !== this.scheme) {
          return false;
        }
        const t = e;
        if (this._filePath.length >= t._filePath.length) {
          const e = this._filePath.length > t._filePath.length && !i.hasTrailingDirectorySeparator(t._filePath) ? i.ensureTrailingDirectorySeparator(t._filePath) : t._filePath;
          if (this.isCaseSensitive) {
            return this._filePath.startsWith(e);
          } else {
            return this._filePath.toLowerCase().startsWith(e.toLowerCase());
          }
        }
        return false;
      }
      getPathLength() {
        return this._filePath.length;
      }
      getPath() {
        return this._getNormalizedPath();
      }
      getFilePath() {
        return this._filePath;
      }
      resolvePaths(...e) {
        let t = i.resolvePaths(this._filePath, ...e);
        if (i.hasTrailingDirectorySeparator(t) && t.length > 1) {
          t = t.slice(0, t.length - 1);
        }
        if (t !== this._filePath) {
          return p.createFileUri(t, '', '', undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      combinePaths(...e) {
        if (e.some(e => e.includes('..') || e.includes(p._separator) || e.includes('/') || e === '.')) {
          return this.resolvePaths(...e);
        } else {
          return this.combinePathsUnsafe(...e);
        }
      }
      combinePathsUnsafe(...e) {
        const t = o.BaseUri.combinePathElements(this._filePath, p._separator, ...e);
        if (t !== this._filePath) {
          return p.createFileUri(t, '', '', undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      getDirectory() {
        const e = this._filePath;
        let t = i.getDirectoryPath(e);
        if (i.hasTrailingDirectorySeparator(t) && t.length > 1) {
          t = t.slice(0, -1);
        }
        if (t !== e) {
          return p.createFileUri(t, '', '', undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      withFragment(e) {
        return p.createFileUri(this._filePath, this._query, e, undefined, this._isCaseSensitive);
      }
      withQuery(e) {
        return p.createFileUri(this._filePath, e, this._fragment, undefined, this._isCaseSensitive);
      }
      stripExtension() {
        const e = i.stripFileExtension(this._filePath);
        if (e !== this._filePath) {
          return p.createFileUri(e, this._query, this._fragment, undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      stripAllExtensions() {
        const e = i.stripFileExtension(this._filePath, true);
        if (e !== this._filePath) {
          return p.createFileUri(e, this._query, this._fragment, undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      getPathComponentsImpl() {
        const e = i.getPathComponents(this._filePath);
        if (e.length > 0 && e[0] === '') {
          e.shift();
        }
        return e.map(e => this.normalizeSlashes(e));
      }
      getRootPath() {
        return this._filePath.slice(0, i.getRootLength(this._filePath));
      }
      getComparablePath() {
        return this._getNormalizedPath();
      }
      static _createKey(e, t, n) {
        return `${e}${t ? `?${t}` : ''}${n ? `#${n}` : ''}`;
      }
      _getNormalizedPath() {
        if (this._normalizedPath === undefined) {
          this._normalizedPath = this.normalizeSlashes(this._filePath);
        }
        return this._normalizedPath;
      }
    }
    exports.FileUri = p;
    p._separator = i.getPathSeparator('');
    a([l.cacheProperty()], p.prototype, 'fileName', null);
    a([l.cacheProperty()], p.prototype, 'lastExtension', null);
    a([l.cacheProperty()], p.prototype, 'root', null);
    a([l.cacheMethodWithNoArgs()], p.prototype, 'getDirectory', null);
    a([l.cacheStaticFunc()], p, 'createFileUri', null);
  },
  12365: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.cacheProperty = function () {
      return function (e, t, n) {
        const a = n.get;
        n.get = function (...e) {
          const n = a.apply(this, e);
          Object.defineProperty(this, t, {
            get: () => n
          });
          return n;
        };
        return n;
      };
    };
    exports.cacheMethodWithNoArgs = function () {
      return function (e, t, n) {
        const a = n.value;
        n.value = function (...e) {
          const n = a.apply(this, e);
          this[t] = () => n;
          return n;
        };
        return n;
      };
    };
    exports.cacheStaticFunc = function () {
      return function (e, t, a) {
        const r = a.value;
        a.value = function (...e) {
          const a = `${t}+${e == null ? undefined : e.map(e => e == null ? undefined : e.toString()).join(',')}`;
          let s;
          if (n.has(a)) {
            s = n.get(a);
          } else {
            s = r.apply(this, e);
            n.set(a, s);
          }
          return s;
        };
        return a;
      };
    };
    const n = new Map();
  },
  27113: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Uri = undefined;
    const a = require(75559);
    const r = require(7095);
    const s = require(34455);
    const i = require(54010);
    const o = require(71745);
    const l = require(1969);
    const p = require(27594);
    const d = require(16867);
    const c = require(25747);
    function u(e) {
      let t;
      t = e.authority && e.path[0] === '/' && e.path.length === 1 ? `//${e.authority}${e.path}` : e.fsPath;
      if (t.match(/^\/[a-zA-Z]:\//)) {
        t = t.slice(1);
      }
      if (process?.platform === 'win32') {
        t = t.replace(/\//g, '\\');
      }
      return t;
    }
    function m(e) {
      const t = a.URI.isUri(e) ? e : a.URI.parse(e);
      const n = t.path.length > 0 ? a.Utils.resolvePath(t) : t;
      const r = n.toString();
      return {
        uri: n,
        str: r
      };
    }
    var y;
    (function (e) {
      e.file = function (e, t, n = false) {
        t = r.CaseSensitivityDetector.is(t) ? t : t.get(o.ServiceKeys.caseSensitivityDetector);
        const s = (e = n && !i.isRootedDiskPath(e) ? i.combinePaths(process.cwd(), e) : e).startsWith('file:') ? m(e) : m(a.URI.file(i.normalizeSlashes(e)));
        return d.FileUri.createFileUri(u(s.uri), s.uri.query, s.uri.fragment, s.str, t.isCaseSensitive(s.str));
      };
      e.parse = function (t, n) {
        if (!t) {
          return e.empty();
        }
        n = r.CaseSensitivityDetector.is(n) ? n : n.get(o.ServiceKeys.caseSensitivityDetector);
        const a = m(t);
        if (a.uri.scheme === d.FileUriSchema) {
          return d.FileUri.createFileUri(u(a.uri), a.uri.query, a.uri.fragment, a.str, n.isCaseSensitive(a.str));
        } else {
          return c.WebUri.createWebUri(a.uri.scheme, a.uri.authority, a.uri.path, a.uri.query, a.uri.fragment, a.str);
        }
      };
      e.constant = function (e) {
        return new l.ConstantUri(e);
      };
      e.empty = function () {
        return p.EmptyUri.instance;
      };
      e.DefaultWorkspaceRootComponent = '<default workspace root>';
      e.DefaultWorkspaceRootPath = `/${e.DefaultWorkspaceRootComponent}`;
      e.defaultWorkspace = function (t) {
        t = r.CaseSensitivityDetector.is(t) ? t : t.get(o.ServiceKeys.caseSensitivityDetector);
        return e.file(e.DefaultWorkspaceRootPath, t);
      };
      e.fromJsonObj = function (e) {
        if (s.isArray(e) && e[0] === 0 || d.FileUri.isFileUri(e)) {
          return d.FileUri.fromJsonObj(e);
        } else {
          if (c.WebUri.isWebUri(e)) {
            return c.WebUri.fromJsonObj(e);
          } else {
            if (p.EmptyUri.isEmptyUri(e)) {
              return p.EmptyUri.instance;
            } else {
              return e;
            }
          }
        }
      };
      e.is = function (e) {
        return !!e && typeof e._key == 'string';
      };
      e.isEmpty = function (e) {
        return !e || e.isEmpty();
      };
      e.equals = function (e, t) {
        var n;
        return e === t || (n = e == null ? undefined : e.equals(t)) !== null && n !== undefined && n;
      };
      e.isDefaultWorkspace = function (t) {
        return t.fileName.includes(e.DefaultWorkspaceRootComponent);
      };
    })(y || (exports.Uri = y = {}));
  },
  5884: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.UriEx = exports.FileSpec = undefined;
    exports.forEachAncestorDirectory = function (e, t) {
      while (true) {
        const n = t(e);
        if (n !== undefined) {
          return n;
        }
        const a = e.getDirectory();
        if (a.equals(e)) {
          return;
        }
        e = a;
      }
    };
    exports.makeDirectories = function (e, t, n) {
      if (!t.startsWith(n)) {
        return;
      }
      const a = t.getPathComponents();
      const r = n.getPathComponents();
      let s = n;
      for (let t = r.length; t < a.length; t++) {
        s = s.combinePaths(a[t]);
        if (!e.existsSync(s)) {
          e.mkdirSync(s);
        }
      }
    };
    exports.getFileSize = function (e, t) {
      const n = d(e, t);
      if (n == null ? undefined : n.isFile()) {
        return n.size;
      }
      return 0;
    };
    exports.fileExists = function (e, t) {
      return y(e, t, 0);
    };
    exports.directoryExists = function (e, t) {
      return y(e, t, 1);
    };
    exports.isDirectory = function (e, t) {
      var n;
      var a;
      return (a = (n = d(e, t)) === null || n === undefined ? undefined : n.isDirectory()) !== null && a !== undefined && a;
    };
    exports.isFile = function (e, t, n = false) {
      var a;
      var r;
      const s = d(e, t);
      if (s == null ? undefined : s.isFile()) {
        return true;
      }
      if (!n) {
        return false;
      }
      return (r = (a = s == null ? undefined : s.isZipDirectory) === null || a === undefined ? undefined : a.call(s)) !== null && r !== undefined && r;
    };
    exports.tryStat = d;
    exports.tryRealpath = function (e, t) {
      try {
        return e.realpathSync(t);
      } catch (e) {
        return;
      }
    };
    exports.getFileSystemEntries = function (e, t) {
      try {
        return c(e.readdirEntriesSync(t), e, t);
      } catch (e) {
        return {
          files: [],
          directories: []
        };
      }
    };
    exports.getFileSystemEntriesFromDirEntries = c;
    exports.getWildcardRegexPattern = u;
    exports.getWildcardRoot = m;
    exports.hasPythonExtension = function (e) {
      return e.hasExtension('.py') || e.hasExtension('.pyi');
    };
    exports.getFileSpec = function (e, t) {
      let n = u(e, t);
      const r = a.getRegexEscapedSeparator('/');
      n = `^(${n})($|${r})`;
      const s = new RegExp(n, e.isCaseSensitive ? undefined : 'i');
      const i = m(e, t);
      const o = a.isDirectoryWildcardPatternPresent(t);
      return {
        wildcardRoot: i,
        regExp: s,
        hasDirectoryWildcard: o
      };
    };
    exports.getDirectoryChangeKind = function (e, t, n) {
      if (t.equals(n)) {
        return 'Same';
      }
      const a = t.getRelativePathComponents(n);
      if (a.length === 2 && a[0] === '..' && a[1] !== '..') {
        return 'Renamed';
      }
      return 'Moved';
    };
    exports.deduplicateFolders = function (e, t = []) {
      const n = new Map();
      e.forEach(e => {
        e.forEach(e => {
          if (!n.has(e.key)) {
            for (const n of t) {
              if (e.startsWith(n)) {
                return;
              }
            }
            for (const t of n) {
              if (e.startsWith(t[1])) {
                return;
              }
              if (t[1].startsWith(e)) {
                n.delete(t[0]);
                n.set(e.key, e);
                return;
              }
            }
            n.set(e.key, e);
          }
        });
      });
      return [...n.values()];
    };
    exports.getRootUri = function (e) {
      e = i.CaseSensitivityDetector.is(e) ? e : e.get(s.ServiceKeys.caseSensitivityDetector);
      if (global.__rootDirectory) {
        return r.Uri.file(global.__rootDirectory, e);
      }
      return;
    };
    exports.convertUriToLspUriString = function (e, t) {
      return e.getOriginalUri(t).toString();
    };
    const a = require(54010);
    const r = require(27113);
    const s = require(71745);
    const i = require(7095);
    const o = /\.pyi?$/;
    var l;
    var p;
    function d(e, t) {
      try {
        if (e.existsSync(t)) {
          return e.statSync(t);
        }
      } catch (e) {
        return;
      }
    }
    function c(e, t, n) {
      const a = e.sort((e, t) => e.name < t.name ? -1 : e.name > t.name ? 1 : 0);
      const r = [];
      const s = [];
      for (const e of a) {
        if (e.name === '.' || e.name === '..') {
          continue;
        }
        const a = n.combinePaths(e.name);
        if (e.isFile()) {
          r.push(a);
        } else {
          if (e.isDirectory()) {
            s.push(a);
          } else {
            if (e.isSymbolicLink()) {
              const e = d(t, a);
              if (e == null ? undefined : e.isFile()) {
                r.push(a);
              } else {
                if (e == null ? undefined : e.isDirectory()) {
                  s.push(a);
                }
              }
            }
          }
        }
      }
      return {
        files: r,
        directories: s
      };
    }
    function u(e, t) {
      const n = e.resolvePaths(t);
      const r = Array.from(n.getPathComponents());
      const s = a.getRegexEscapedSeparator('/');
      const i = `(${s}[^${s}][^${s}]*)*?`;
      const o = new RegExp(`[^\\w\\s${s}]`, 'g');
      if (r.length > 0) {
        r[0] = a.stripTrailingDirectorySeparator(r[0]);
      }
      let l = '';
      let p = true;
      for (let e of r) {
        if (e === '**') {
          l += i;
        } else {
          if (!p) {
            e = s + e;
          }
          l += e.replace(o, e => e === '*' ? `[^${s}]*` : e === '?' ? `[^${s}]` : `\\${e}`);
          p = false;
        }
      }
      return l;
    }
    function m(e, t) {
      const n = e.resolvePaths(t);
      const a = Array.from(n.getPathComponents());
      let r = n.root;
      if (a.length > 0) {
        a.shift();
      }
      for (const e of a) {
        if (e === '**') {
          break;
        }
        if (/[*?]/.test(e)) {
          break;
        }
        r = r.resolvePaths(e);
      }
      return r;
    }
    function y(e, t, n) {
      try {
        const a = e.statSync(t);
        switch (n) {
          case 0:
            return a.isFile();
          case 1:
            return a.isDirectory();
          default:
            return false;
        }
      } catch (e) {
        return false;
      }
    }
    (function (e) {
      e.is = function (e) {
        const t = e;
        return t && !!t.wildcardRoot && !!t.regExp;
      };
      e.isInPath = function (e, t) {
        return !!t.find(t => e.matchesRegex(t.regExp));
      };
      e.matchesIncludeFileRegex = function (e, t = true) {
        return !t || e.matchesRegex(o);
      };
      e.matchIncludeFileSpec = function (t, n, a, r = true) {
        return !!a.matchesRegex(t) && !e.isInPath(a, n) && !!e.matchesIncludeFileRegex(a, r);
      };
    })(l || (exports.FileSpec = l = {}));
    (function (e) {
      e.file = function (e, t, n) {
        const s = a(t);
        return r.Uri.file(e, s, n);
      };
      e.parse = function (e, t) {
        const n = a(t);
        return r.Uri.parse(e, n);
      };
      const t = {
        isCaseSensitive: () => true
      };
      const n = {
        isCaseSensitive: () => false
      };
      function a(e) {
        if (e === undefined || e) {
          return t;
        } else {
          return n;
        }
      }
    })(p || (exports.UriEx = p = {}));
  },
  25747: function (module, exports, require) {
    var a = this && this.__decorate || function (e, t, n, a) {
      var r;
      var s = arguments.length;
      var i = s < 3 ? t : a === null ? a = Object.getOwnPropertyDescriptor(t, n) : a;
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') {
        i = Reflect.decorate(e, t, n, a);
      } else {
        for (var o = e.length - 1; o >= 0; o--) {
          if (r = e[o]) {
            i = (s < 3 ? r(i) : s > 3 ? r(t, n, i) : r(t, n)) || i;
          }
        }
      }
      if (s > 3 && i) {
        Object.defineProperty(t, n, i);
      }
      return i;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.WebUri = undefined;
    const r = require(54010);
    const s = require(56426);
    const i = require(12365);
    const o = require(75559);
    class l extends s.BaseUri {
      constructor(e, t, n, a, r, s, i) {
        super(e);
        this._scheme = t;
        this._authority = n;
        this._path = a;
        this._query = r;
        this._fragment = s;
        this._originalString = i;
      }
      get scheme() {
        return this._scheme;
      }
      get isCaseSensitive() {
        return true;
      }
      get fragment() {
        return this._fragment;
      }
      get query() {
        return this._query;
      }
      get root() {
        const e = this.getRootPath();
        if (e !== this._path) {
          return l.createWebUri(this._scheme, this._authority, e, '', '', undefined);
        } else {
          return this;
        }
      }
      get fileName() {
        const e = this._path.split('/');
        return e[e.length - 1];
      }
      get lastExtension() {
        const e = this.fileName;
        const t = e.lastIndexOf('.');
        if (t >= 0) {
          return e.slice(t);
        } else {
          return '';
        }
      }
      static createWebUri(e, t, n, a, r, s) {
        const i = l._createKey(e, t, n, a, r);
        return new l(i, e, t, n, a, r, s);
      }
      toString() {
        if (!this._originalString) {
          const e = o.URI.revive({
            scheme: this._scheme,
            authority: this._authority,
            path: this._path,
            query: this._query,
            fragment: this._fragment
          });
          this._originalString = e.toString();
        }
        return this._originalString;
      }
      toUserVisibleString() {
        return this.toString();
      }
      static isWebUri(e) {
        return (e == null ? undefined : e._scheme) !== undefined && (e == null ? undefined : e._key) !== undefined;
      }
      static fromJsonObj(e) {
        return l.createWebUri(e._scheme, e._authority, e._path, e._query, e._fragment, e._originalString);
      }
      toJsonObj() {
        return {
          _scheme: this._scheme,
          _authority: this._authority,
          _path: this._path,
          _query: this._query,
          _fragment: this._fragment,
          _originalString: this._originalString,
          _key: this.key
        };
      }
      matchesRegex(e) {
        return e.test(this._path);
      }
      addPath(e) {
        const t = this._path + e;
        return l.createWebUri(this._scheme, this._authority, t, this._query, this._fragment, undefined);
      }
      isRoot() {
        return this._path === this.getRootPath() && this._path.length > 0;
      }
      isChild(e) {
        return !!l.isWebUri(e) && e._path.length < this._path.length && this.startsWith(e);
      }
      isLocal() {
        return false;
      }
      startsWith(e) {
        if ((e == null ? undefined : e.scheme) !== this.scheme) {
          return false;
        }
        const t = e;
        if (this._path.length >= t._path.length) {
          const e = this._path.length > t._path.length && !r.hasTrailingDirectorySeparator(t._path) ? `${t._path}/` : t._path;
          return this._path.startsWith(e);
        }
        return false;
      }
      getPathLength() {
        return this._path.length;
      }
      getPath() {
        return this._path;
      }
      getFilePath() {
        return '';
      }
      resolvePaths(...e) {
        let t = this.normalizeSlashes(r.resolvePaths(this._path, ...e));
        if (r.hasTrailingDirectorySeparator(t) && t.length > 1) {
          t = t.slice(0, t.length - 1);
        }
        if (t !== this._path) {
          return l.createWebUri(this._scheme, this._authority, t, '', '', undefined);
        } else {
          return this;
        }
      }
      combinePaths(...e) {
        if (e.some(e => e.includes('..') || e.includes('/') || e === '.')) {
          return this.resolvePaths(...e);
        } else {
          return this.combinePathsUnsafe(...e);
        }
      }
      combinePathsUnsafe(...e) {
        const t = s.BaseUri.combinePathElements(this._path, '/', ...e);
        if (t !== this._path) {
          return l.createWebUri(this._scheme, this._authority, t, '', '', undefined);
        } else {
          return this;
        }
      }
      getDirectory() {
        if (this._path.length === 0) {
          return this;
        }
        const e = this._path.lastIndexOf('/');
        const t = e > 0 ? this._path.slice(0, e) : e === 0 ? '/' : '';
        return l.createWebUri(this._scheme, this._authority, t, this._query, this._fragment, undefined);
      }
      withFragment(e) {
        return l.createWebUri(this._scheme, this._authority, this._path, this._query, e, undefined);
      }
      withQuery(e) {
        return l.createWebUri(this._scheme, this._authority, this._path, e, this._fragment, undefined);
      }
      stripExtension() {
        const e = this._path;
        const t = e.lastIndexOf('.');
        if (t > 0) {
          return l.createWebUri(this._scheme, this._authority, e.slice(0, t), this._query, this._fragment, undefined);
        } else {
          return this;
        }
      }
      stripAllExtensions() {
        const e = this._path;
        const t = e.lastIndexOf('/');
        const n = e.indexOf('.', t > 0 ? t : 0);
        if (n > 0) {
          return l.createWebUri(this._scheme, this._authority, e.slice(0, n), this._query, this._fragment, undefined);
        } else {
          return this;
        }
      }
      getPathComponentsImpl() {
        const e = this.getRootPath();
        const t = this._path.slice(e.length).split('/');
        return this.reducePathComponents([e, ...t]).map(e => this.normalizeSlashes(e));
      }
      getRootPath() {
        const e = r.getRootLength(this._path, '/');
        return this._path.slice(0, e);
      }
      getComparablePath() {
        return this._path;
      }
      static _createKey(e, t, n, a, r) {
        return `${e}:${t}${n}${a ? `?${a}` : ''}${r ? `#${r}` : ''}`;
      }
    }
    exports.WebUri = l;
    a([i.cacheProperty()], l.prototype, 'root', null);
    a([i.cacheProperty()], l.prototype, 'fileName', null);
    a([i.cacheProperty()], l.prototype, 'lastExtension', null);
    a([i.cacheMethodWithNoArgs()], l.prototype, 'getDirectory', null);
    a([i.cacheStaticFunc()], l, 'createWebUri', null);
  },
  74382: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.convertToTextEdits = function (e) {
      return e.map(e => ({
        range: e.range,
        newText: e.replacementText
      }));
    };
    exports.convertToFileTextEdits = function (e, t) {
      return t.map(t => ({
        fileUri: e,
        ...t
      }));
    };
    exports.convertToWorkspaceEdit = function (e, t, n, r = 'default') {
      if (i.isArray(t)) {
        return function (e, t) {
          const n = {
            changes: {}
          };
          u(e, t, n);
          return n;
        }(e, t);
      }
      return function (e, t, n, r = 'default') {
        const i = {
          documentChanges: [],
          changeAnnotations: n
        };
        for (const n of t.fileOperations) {
          switch (n.kind) {
            case 'create':
              i.documentChanges.push(a.CreateFile.create(c.convertUriToLspUriString(e, n.fileUri), undefined, r));
              break;
            case 'rename':
            case 'delete':
              break;
            default:
              o.assertNever(n);
          }
        }
        const l = s.createMapFromItems(t.edits, t => c.convertUriToLspUriString(e, t.fileUri));
        for (const [e, t] of l) {
          i.documentChanges.push(a.TextDocumentEdit.create({
            uri: e,
            version: null
          }, Array.from(t.map(e => ({
            range: e.range,
            newText: e.replacementText,
            annotationId: r
          })))));
        }
        for (const n of t.fileOperations) {
          switch (n.kind) {
            case 'create':
              break;
            case 'rename':
              i.documentChanges.push(a.RenameFile.create(c.convertUriToLspUriString(e, n.oldFileUri), c.convertUriToLspUriString(e, n.newFileUri), undefined, r));
              break;
            case 'delete':
              i.documentChanges.push(a.DeleteFile.create(c.convertUriToLspUriString(e, n.fileUri), undefined, r));
              break;
            default:
              o.assertNever(n);
          }
        }
        return i;
      }(e, t, n, r);
    };
    exports.appendToWorkspaceEdit = u;
    exports.applyTextEditsToString = function (e, t, n) {
      const a = e.map(e => {
        var a;
        return {
          range: (a = l.convertRangeToTextRange(e.range, t)) !== null && a !== undefined ? a : {
            start: n.length,
            length: 0
          },
          text: e.replacementText
        };
      }).sort((e, t) => {
        const n = t.range.start - e.range.start;
        if (n !== 0) {
          return n;
        } else {
          return p.TextRange.getEnd(t.range) - p.TextRange.getEnd(e.range);
        }
      });
      let r = n;
      for (const e of a) {
        r = r.substr(0, e.range.start) + e.text + r.substr(p.TextRange.getEnd(e.range));
      }
      return r;
    };
    exports.applyWorkspaceEdit = function (e, t, n) {
      if (t.changes) {
        for (const a of Object.entries(t.changes)) {
          const t = d.Uri.parse(a[0], e.serviceProvider);
          const r = e.getSourceFileInfo(t);
          if (r && r.isTracked) {
            m(e, r, a[1]);
            n.set(t.key, t);
          }
        }
      }
      if (t.documentChanges) {
        for (const r of t.documentChanges) {
          if (a.TextDocumentEdit.is(r)) {
            const t = d.Uri.parse(r.textDocument.uri, e.serviceProvider);
            const s = e.getSourceFileInfo(t);
            if (!s || !s.isTracked) {
              continue;
            }
            m(e, s, r.edits.filter(e => a.TextEdit.is(e)));
            n.set(t.key, t);
          }
        }
      }
    };
    exports.applyDocumentChanges = m;
    exports.generateWorkspaceEdit = function (e, t, n, a) {
      var r;
      const s = {
        changes: {}
      };
      for (const i of a.values()) {
        const a = t.backgroundAnalysisProgram.program.getBoundSourceFile(i);
        const o = n.backgroundAnalysisProgram.program.getBoundSourceFile(i);
        if (!a || !o) {
          continue;
        }
        const p = a.getParseResults();
        if (p) {
          s.changes[c.convertUriToLspUriString(e, i)] = [{
            range: l.convertTextRangeToRange(p.parserOutput.parseTree, p.tokenizerOutput.lines),
            newText: (r = o.getFileContent()) !== null && r !== undefined ? r : ''
          }];
        }
      }
      return s;
    };
    const a = require(56911);
    const r = require(55890);
    const s = require(58147);
    const i = require(34455);
    const o = require(48281);
    const l = require(56814);
    const p = require(88754);
    const d = require(27113);
    const c = require(5884);
    function u(e, t, n) {
      t.forEach(t => {
        const a = c.convertUriToLspUriString(e, t.fileUri);
        n.changes[a] = n.changes[a] || [];
        n.changes[a].push({
          range: t.range,
          newText: t.replacementText
        });
      });
    }
    function m(e, t, n) {
      var a;
      var s;
      var i;
      var o;
      if (!t.isOpenByClient) {
        const n = t.sourceFile.getFileContent();
        e.setFileOpened(t.sourceFile.getUri(), 0, n ?? '', {
          isTracked: t.isTracked,
          ipythonMode: t.sourceFile.getIPythonMode(),
          chainedFileUri: (a = t.chainedSourceFile) === null || a === undefined ? undefined : a.sourceFile.getUri()
        });
      }
      const l = (s = t.sourceFile.getClientVersion()) !== null && s !== undefined ? s : 0;
      const p = t.sourceFile.getUri();
      const d = p.getFilePath();
      const c = r.TextDocument.create(d, 'python', l, (i = t.sourceFile.getOpenFileContents()) !== null && i !== undefined ? i : '');
      e.setFileOpened(p, l + 1, r.TextDocument.applyEdits(c, n), {
        isTracked: t.isTracked,
        ipythonMode: t.sourceFile.getIPythonMode(),
        chainedFileUri: (o = t.chainedSourceFile) === null || o === undefined ? undefined : o.sourceFile.getUri()
      });
    }
  },
  92196: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.AnalyzerServiceExecutor = undefined;
    const a = require(16259);
    const r = require(33970);
    const s = require(25463);
    const i = require(25075);
    const o = require(30741);
    class l {
      static runWithOptions(e, t, n) {
        var r;
        const o = function (e, t, n, r, o) {
          var l;
          var p;
          var d;
          var c;
          var u;
          var m;
          var y;
          const g = new s.CommandLineOptions(e, true);
          g.languageServerSettings.checkOnlyOpenFiles = t.openFilesOnly;
          g.configSettings.useLibraryCodeForTypes = t.useLibraryCodeForTypes;
          g.configSettings.typeCheckingMode = t.typeCheckingMode;
          g.languageServerSettings.autoImportCompletions = t.autoImportCompletions;
          g.languageServerSettings.indexing = t.indexing;
          g.languageServerSettings.taskListTokens = t.taskListTokens;
          g.languageServerSettings.logTypeEvaluationTime = (l = t.logTypeEvaluationTime) !== null && l !== undefined && l;
          g.languageServerSettings.typeEvaluationTimeThreshold = (p = t.typeEvaluationTimeThreshold) !== null && p !== undefined ? p : 50;
          g.languageServerSettings.enableAmbientAnalysis = n;
          g.configSettings.pythonEnvironmentName = o;
          g.languageServerSettings.disableTaggedHints = t.disableTaggedHints;
          if (n) {
            g.languageServerSettings.watchForSourceChanges = t.watchForSourceChanges;
            g.languageServerSettings.watchForLibraryChanges = t.watchForLibraryChanges;
            g.languageServerSettings.watchForConfigChanges = t.watchForConfigChanges;
          } else {
            g.languageServerSettings.watchForSourceChanges = false;
            g.languageServerSettings.watchForLibraryChanges = false;
            g.languageServerSettings.watchForConfigChanges = false;
          }
          if (t.venvPath) {
            g.languageServerSettings.venvPath = t.venvPath.getFilePath();
          }
          if (t.pythonPath) {
            if (!a.isPythonBinary(t.pythonPath.getFilePath())) {
              g.languageServerSettings.pythonPath = t.pythonPath.getFilePath();
            }
          }
          if (t.typeshedPath) {
            g.configSettings.typeshedPath = t.typeshedPath.getFilePath();
          }
          if (t.stubPath) {
            g.configSettings.stubPath = t.stubPath.getFilePath();
          }
          if (t.logLevel === i.LogLevel.Log) {
            g.configSettings.verboseOutput = true;
          }
          if (r) {
            g.languageServerSettings.typeStubTargetImportName = r;
          }
          g.configSettings.autoSearchPaths = t.autoSearchPaths;
          g.configSettings.extraPaths = (c = (d = t.extraPaths) === null || d === undefined ? undefined : d.map(e => e.getFilePath())) !== null && c !== undefined ? c : [];
          g.configSettings.diagnosticSeverityOverrides = t.diagnosticSeverityOverrides;
          g.configSettings.diagnosticBooleanOverrides = t.diagnosticBooleanOverrides;
          g.configSettings.includeFileSpecs = (u = t.includeFileSpecs) !== null && u !== undefined ? u : [];
          g.configSettings.excludeFileSpecs = (m = t.excludeFileSpecs) !== null && m !== undefined ? m : [];
          g.configSettings.ignoreFileSpecs = (y = t.ignoreFileSpecs) !== null && y !== undefined ? y : [];
          return g;
        }(e.rootUri, t, (r = n == null ? undefined : n.trackFiles) === null || r === undefined || r, n == null ? undefined : n.typeStubTargetImportName, n == null ? undefined : n.pythonEnvironmentName);
        e.service.setOptions(o);
      }
      static async cloneService(e, t, n) {
        const a = 'cloned service';
        const s = r.getNextServiceId(a);
        n = n ?? {};
        const i = {
          ...t,
          workspaceName: 'temp workspace for cloned service',
          rootUri: t.rootUri,
          kinds: [...t.kinds, o.WellKnownWorkspaceKinds.Cloned],
          service: t.service.clone(a, s, n.useBackgroundAnalysis ? e.createBackgroundAnalysis(s) : undefined, n.fileSystem),
          disableLanguageServices: true,
          disableTaggedHints: true,
          disableOrganizeImports: true,
          disableWorkspaceSymbol: true,
          isInitialized: o.createInitStatus(),
          searchPathsToWatch: []
        };
        const p = await e.getSettings(t);
        l.runWithOptions(i, p, {
          typeStubTargetImportName: n.typeStubTargetImportName,
          trackFiles: false
        });
        return i.service;
      }
    }
    exports.AnalyzerServiceExecutor = l;
  },
  16835: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.AutoImporter = undefined;
    exports.buildModuleSymbolsMap = function (e) {
      const t = new Map();
      e.forEach(e => {
        if (e.shadows.length > 0) {
          return;
        }
        const n = e.sourceFile.getUri();
        const a = e.sourceFile.getModuleSymbolTable();
        if (!a) {
          return;
        }
        const r = m.stripFileExtension(n.fileName);
        if (!p.isPrivateOrProtectedName(r) || !!l.isUserCode(e)) {
          t.set(n.key, {
            uri: n,
            *getSymbols() {
              for (const [t, n] of a) {
                if (!d.isVisibleExternally(n)) {
                  continue;
                }
                const a = n.getDeclarations();
                if (!a || a.length === 0) {
                  continue;
                }
                const r = a[0];
                if (!r) {
                  continue;
                }
                if (r.type === 8 && l.isUserCode(e)) {
                  continue;
                }
                const s = r.type !== 1 || r.isConstant || r.isFinal ? undefined : i.SymbolKind.Variable;
                yield {
                  symbol: {
                    symbol: n,
                    kind: s
                  },
                  name: t,
                  library: !l.isUserCode(e)
                };
              }
            }
          });
        }
      });
      return t;
    };
    exports.convertSymbolKindToCompletionItemKind = f;
    const i = require(56911);
    const o = require(47610);
    const l = require(3433);
    const p = __importStar(require(12097));
    const d = require(4064);
    const c = require(91426);
    const u = require(58147);
    const m = require(54010);
    const y = __importStar(require(89740));
    const g = require(5737);
    const h = require(56412);
    function f(e) {
      switch (e) {
        case i.SymbolKind.File:
          return i.CompletionItemKind.File;
        case i.SymbolKind.Module:
        case i.SymbolKind.Namespace:
          return i.CompletionItemKind.Module;
        case i.SymbolKind.Package:
          return i.CompletionItemKind.Folder;
        case i.SymbolKind.Class:
          return i.CompletionItemKind.Class;
        case i.SymbolKind.Method:
          return i.CompletionItemKind.Method;
        case i.SymbolKind.Property:
          return i.CompletionItemKind.Property;
        case i.SymbolKind.Field:
          return i.CompletionItemKind.Field;
        case i.SymbolKind.Constructor:
          return i.CompletionItemKind.Constructor;
        case i.SymbolKind.Enum:
          return i.CompletionItemKind.Enum;
        case i.SymbolKind.Interface:
          return i.CompletionItemKind.Interface;
        case i.SymbolKind.Function:
          return i.CompletionItemKind.Function;
        case i.SymbolKind.Variable:
        case i.SymbolKind.Array:
          return i.CompletionItemKind.Variable;
        case i.SymbolKind.String:
          return i.CompletionItemKind.Constant;
        case i.SymbolKind.Number:
        case i.SymbolKind.Boolean:
          return i.CompletionItemKind.Value;
        case i.SymbolKind.Constant:
        case i.SymbolKind.Null:
          return i.CompletionItemKind.Constant;
        case i.SymbolKind.Object:
        case i.SymbolKind.Key:
          return i.CompletionItemKind.Value;
        case i.SymbolKind.EnumMember:
          return i.CompletionItemKind.EnumMember;
        case i.SymbolKind.Struct:
          return i.CompletionItemKind.Struct;
        case i.SymbolKind.Event:
          return i.CompletionItemKind.Event;
        case i.SymbolKind.Operator:
          return i.CompletionItemKind.Operator;
        case i.SymbolKind.TypeParameter:
          return i.CompletionItemKind.TypeParameter;
        default:
          return;
      }
    }
    exports.AutoImporter = class {
      constructor(e, t, n, a, r, s, i) {
        this.program = e;
        this.execEnvironment = t;
        this.parseResults = n;
        this._invocationPosition = a;
        this._excludes = r;
        this.moduleSymbolMap = s;
        this.options = i;
        this._importStatements = o.getTopLevelImports(this.parseResults.parserOutput.parseTree, true);
      }
      getAutoImportCandidates(e, t, n, a) {
        const r = [];
        this.getCandidates(e, t, n, a).forEach(e => u.appendArray(r, e));
        return r;
      }
      get importResolver() {
        return this.program.importResolver;
      }
      getCompletionItemData(e) {
        return h.fromLSPAny(e.data);
      }
      getCandidates(e, t, n, a) {
        const r = new Map();
        const s = new Map();
        this.addImportsFromModuleMap(e, t, n, s, r, a);
        this.addImportsFromImportAliasMap(s, n, r, a);
        return r;
      }
      addImportsFromModuleMap(e, t, n, a, r, s) {
        this.moduleSymbolMap.forEach((i, o) => {
          const l = this.getUriProperties(this.moduleSymbolMap, i.uri);
          this.processModuleSymbolTable(i, i.uri, e, t, l, n, a, r, s);
        });
      }
      addImportsFromImportAliasMap(e, t, n, a) {
        c.throwIfCancellationRequested(a);
        e.forEach(e => {
          e.forEach((e, a) => {
            var r;
            var s;
            if (t) {
              if (this._importStatements.mapByFilePath.has(e.importParts.fileUri.key)) {
                return;
              }
              if (e.importParts.importFrom) {
                const t = this._importStatements.orderedImports.find(t => t.moduleName === e.importParts.importFrom);
                if (t && t.node.nodeType === 25 && t.node.d.imports.some(t => t.d.name.d.value === e.importParts.symbolName)) {
                  return;
                }
              }
            }
            if (this._containsName(e.importParts.importName, e.importParts.importFrom, n)) {
              return;
            }
            const i = this._getTextEditsForAutoImportByFilePath({
              name: e.importParts.symbolName,
              alias: t
            }, {
              name: (r = e.importParts.importFrom) !== null && r !== undefined ? r : e.importParts.importName
            }, e.importParts.importName, e.importGroup, e.importParts.fileUri);
            this._addResult(n, {
              name: e.importParts.importName,
              alias: t,
              symbol: e.symbol,
              kind: (s = e.itemKind) !== null && s !== undefined ? s : f(e.kind),
              source: e.importParts.importFrom,
              insertionText: i.insertionText,
              edits: i.edits,
              declUri: e.importParts.fileUri,
              originalName: a,
              originalDeclUri: e.fileUri
            });
          });
        });
      }
      processModuleSymbolTable(e, t, n, a, r, s, o, l, p) {
        var d;
        c.throwIfCancellationRequested(p);
        const [u, m, g] = this._getImportPartsForSymbols(t);
        if (!u) {
          return;
        }
        const h = y.getCharacterCount(u, '.');
        for (const {
          symbol: i,
          name: p
        } of e.getSymbols()) {
          if (!this.shouldIncludeVariable(i, p, r.isStub)) {
            continue;
          }
          if (!this._isSimilar(n, p, a)) {
            continue;
          }
          if (this._containsName(p, u, l)) {
            continue;
          }
          if (i.importAlias) {
            this._addToImportAliasMap(i.importAlias, {
              importParts: {
                symbolName: p,
                importName: p,
                importFrom: u,
                fileUri: t,
                dotCount: h,
                moduleNameAndType: g
              },
              importGroup: m,
              symbol: i.symbol,
              kind: i.importAlias.kind,
              itemKind: i.importAlias.itemKind,
              inDunderAll: i.inDunderAll,
              hasRedundantAlias: i.hasRedundantAlias,
              fileUri: i.importAlias.moduleUri
            }, o);
            continue;
          }
          const e = this.getNameForImportFrom(!r.isUserCode, t);
          const c = this._getTextEditsForAutoImportByFilePath({
            name: p,
            alias: s
          }, {
            name: u,
            nameForImportFrom: e
          }, p, m, t);
          this._addResult(l, {
            name: p,
            alias: s,
            symbol: i.symbol,
            source: u,
            kind: (d = i.itemKind) !== null && d !== undefined ? d : f(i.kind),
            insertionText: c.insertionText,
            edits: c.edits,
            declUri: t,
            originalName: p,
            originalDeclUri: t
          });
        }
        if (!r.isStub && !r.hasInit && !r.isUserCode) {
          return;
        }
        const T = this._getImportParts(t);
        if (!T) {
          return;
        }
        if (!this._isSimilar(n, T.importName, a)) {
          return;
        }
        if (!this._containsName(T.importName, T.importFrom, l)) {
          this._addToImportAliasMap({
            moduleUri: t,
            originalName: T.importName,
            kind: i.SymbolKind.Module,
            itemKind: i.CompletionItemKind.Module
          }, {
            importParts: T,
            importGroup: m,
            kind: i.SymbolKind.Module,
            itemKind: i.CompletionItemKind.Module,
            fileUri: t
          }, o);
        }
      }
      getNameForImportFrom(e, t) {}
      getUriProperties(e, t) {
        const n = t.getDirectory();
        const a = n.initPyUri;
        const r = n.initPyiUri;
        const s = t.hasExtension('.pyi');
        const i = e.has(a.key) || e.has(r.key);
        const o = this.program.getSourceFileInfo(t);
        return {
          isStub: s,
          hasInit: i,
          isUserCode: l.isUserCode(o)
        };
      }
      compareImportAliasData(e, t) {
        const n = e.importGroup - t.importGroup;
        if (n !== 0) {
          return n;
        }
        const a = e.importParts.dotCount - t.importParts.dotCount;
        if (a !== 0) {
          return a;
        } else {
          if (e.symbol && !t.symbol) {
            return -1;
          } else {
            if (!e.symbol && t.symbol) {
              return 1;
            } else {
              return y.getStringComparer()(e.importParts.importName, t.importParts.importName);
            }
          }
        }
      }
      shouldIncludeVariable(e, t, n) {
        return !!n || e.kind !== i.SymbolKind.Variable || p.isPublicConstantOrTypeAlias(t);
      }
      _addToImportAliasMap(e, t, n) {
        if (!n.has(e.moduleUri.key)) {
          const a = new Map();
          a.set(e.originalName, t);
          n.set(e.moduleUri.key, a);
          return;
        }
        const a = n.get(e.moduleUri.key);
        if (!a.has(e.originalName)) {
          a.set(e.originalName, t);
          return;
        }
        const r = a.get(e.originalName);
        if (!(this.compareImportAliasData(r, t) <= 0)) {
          a.set(e.originalName, t);
        }
      }
      _getImportPartsForSymbols(e) {
        const t = this._importStatements.mapByFilePath.get(e.key);
        if (t) {
          return [t.moduleName, o.getImportGroup(t), {
            importType: 2,
            isLocalTypingsFile: false,
            moduleName: t.moduleName
          }];
        }
        {
          const t = this._getModuleNameAndTypeFromFilePath(e);
          return [t.moduleName, o.getImportGroupFromModuleNameAndType(t), t];
        }
      }
      _getImportParts(e) {
        return t(m.stripFileExtension(e.fileName) === '__init__' ? this._getModuleNameAndTypeFromFilePath(e.getDirectory()) : this._getModuleNameAndTypeFromFilePath(e));
        function t(t) {
          const n = t.moduleName;
          if (!n) {
            return;
          }
          const a = n.lastIndexOf('.');
          const r = a > 0 ? n.substring(a + 1) : undefined;
          const s = a > 0 ? n.substring(0, a) : undefined;
          return {
            symbolName: r,
            importName: r ?? n,
            importFrom: s,
            fileUri: e,
            dotCount: y.getCharacterCount(n, '.'),
            moduleNameAndType: t
          };
        }
      }
      _isSimilar(e, t, n) {
        if (n === 1) {
          return e === t;
        }
        if (e.length <= 0 || t.length <= 0) {
          return false;
        }
        if (!this.options.patternMatcher) {
          const n = e[0] !== '_' && t[0] === '_' && t.length > 1 ? 1 : 0;
          return e[0].toLocaleLowerCase() === t[n].toLocaleLowerCase() && y.isPatternInSymbol(e, t);
        }
        return this.options.patternMatcher(e, t);
      }
      _shouldExclude(e) {
        return this._excludes.has(e, e => g.CompletionMap.labelOnlyIgnoringAutoImports(e, this.getCompletionItemData.bind(this)));
      }
      _containsName(e, t, n) {
        if (this._shouldExclude(e)) {
          return true;
        }
        const a = n.get(e);
        return !!(a == null ? undefined : a.some(e => e.source === t));
      }
      _getModuleNameAndTypeFromFilePath(e) {
        return this.importResolver.getModuleNameForImport(e, this.execEnvironment);
      }
      _getTextEditsForAutoImportByFilePath(e, t, n, a, r) {
        var s;
        var i;
        var l;
        var p;
        var d;
        var c;
        var u;
        var m;
        var y;
        const g = this._importStatements.mapByFilePath.get(r.key);
        if (g) {
          if (g.node.nodeType === 23) {
            const t = (i = (s = g.subnode) === null || s === undefined ? undefined : s.d.alias) === null || i === undefined ? undefined : i.d.value;
            if (e.name) {
              return {
                insertionText: `${t ?? g.moduleName}.${e.name}`,
                edits: []
              };
            }
            if (t) {
              return {
                insertionText: `${t}`,
                edits: []
              };
            }
          }
          if (e.name && g.node.nodeType === 25 && !g.node.d.isWildcardImport) {
            const a = g.node.d.imports.find(t => t.d.name.d.value === e.name);
            if (a) {
              const t = (l = a.d.alias) === null || l === undefined ? undefined : l.d.value;
              return {
                insertionText: `${t ?? e.name}`,
                edits: []
              };
            }
            if (t.name === g.moduleName) {
              return {
                insertionText: (p = e.alias) !== null && p !== undefined ? p : n,
                edits: this.options.lazyEdit ? undefined : o.getTextEditsForAutoImportSymbolAddition(e, g, this.parseResults)
              };
            }
          }
        } else {
          if (e.name) {
            const a = this._importStatements.orderedImports.find(e => e.moduleName === t.name);
            if (a && a.node.nodeType === 25 && !a.node.d.isWildcardImport) {
              const t = a.node.d.imports.find(t => t.d.name.d.value === e.name);
              if (!t) {
                return {
                  insertionText: (c = e.alias) !== null && c !== undefined ? c : n,
                  edits: this.options.lazyEdit ? undefined : o.getTextEditsForAutoImportSymbolAddition(e, a, this.parseResults)
                };
              }
              {
                const e = (d = t.d.alias) === null || d === undefined ? undefined : d.d.value;
                if (e) {
                  return {
                    insertionText: `${e}`,
                    edits: []
                  };
                }
              }
            }
            const s = (u = this._importStatements.implicitImports) === null || u === undefined ? undefined : u.get(r.key);
            if (s) {
              const t = (m = s.d.alias) === null || m === undefined ? undefined : m.d.value;
              return {
                insertionText: `${t ?? s.d.name.d.value}.${e.name}`,
                edits: []
              };
            }
          }
        }
        return {
          insertionText: (y = e.alias) !== null && y !== undefined ? y : n,
          edits: this.options.lazyEdit ? undefined : o.getTextEditsForAutoImportInsertion(e, t, this._importStatements, a, this.parseResults, this._invocationPosition)
        };
      }
      _addResult(e, t) {
        let n = e.get(t.name);
        if (!n) {
          n = [];
          e.set(t.name, n);
        }
        n.push(t);
      }
    };
  },
  10518: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CallHierarchyProvider = undefined;
    const i = require(56911);
    const o = __importStar(require(83760));
    const l = __importStar(require(41557));
    const p = require(88744);
    const d = require(3433);
    const c = require(92324);
    const u = require(21024);
    const m = require(91426);
    const y = require(58147);
    const g = require(34455);
    const h = require(56507);
    const f = require(56412);
    const T = require(56814);
    const v = require(71745);
    const b = require(88754);
    const _ = require(27113);
    const C = require(5884);
    const I = require(26005);
    const k = require(67032);
    const w = require(47091);
    exports.CallHierarchyProvider = class {
      constructor(e, t, n, a) {
        this._program = e;
        this._fileUri = t;
        this._position = n;
        this._token = a;
        this._parseResults = this._program.getParseResults(this._fileUri);
      }
      onPrepare() {
        var e;
        m.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const t = this._getDeclaration();
        if (!t || t.declarations.length === 0) {
          return null;
        }
        const {
          targetDecl: n,
          callItemUri: a,
          symbolName: r
        } = this._getTargetDeclaration(t);
        if (n.type !== 5 && n.type !== 6 && n.type !== 8) {
          return null;
        }
        if (n.type === 8) {
          const e = this._evaluator.resolveAliasDeclaration(n, true);
          if (!e) {
            return null;
          }
          if (e.type !== 5 && e.type !== 6) {
            return null;
          }
        }
        const s = {
          name: r,
          kind: (e = f.getSymbolKind(n, this._evaluator, r)) !== null && e !== undefined ? e : i.SymbolKind.Module,
          uri: C.convertUriToLspUriString(this._program.fileSystem, a),
          range: n.range,
          selectionRange: n.range
        };
        if (w.canNavigateToFile(this._program.fileSystem, _.Uri.parse(s.uri, this._program.serviceProvider))) {
          return [s];
        } else {
          return null;
        }
      }
      getIncomingCalls() {
        m.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const e = this._getDeclaration();
        if (!e || e.declarations.length === 0) {
          return null;
        }
        const {
          targetDecl: t,
          symbolName: n
        } = this._getTargetDeclaration(e);
        const a = [];
        const r = t.type === 8 ? [this._program.getSourceFileInfo(this._fileUri)] : this._program.getSourceFileInfoList();
        for (const e of r) {
          if (d.isUserCode(e) || e.isOpenByClient) {
            const r = e.sourceFile.getUri();
            const s = this._getIncomingCallsForDeclaration(r, n, t);
            if (s) {
              y.appendArray(a, s);
            }
            this._program.handleMemoryHighUsage();
          }
        }
        if (a.length === 0) {
          return null;
        } else {
          return a.filter(e => w.canNavigateToFile(this._program.fileSystem, _.Uri.parse(e.from.uri, this._program.serviceProvider)));
        }
      }
      getOutgoingCalls() {
        var e;
        m.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const t = this._getDeclaration();
        if (!t || t.declarations.length === 0) {
          return null;
        }
        const {
          targetDecl: n
        } = this._getTargetDeclaration(t);
        let a;
        const r = this._evaluator.resolveAliasDeclaration(n, true);
        if (!r) {
          return null;
        }
        if (r.type === 5) {
          a = r.node;
        } else {
          if (r.type === 6) {
            const t = (e = this._evaluator.getTypeForDeclaration(r)) === null || e === undefined ? undefined : e.type;
            if (t && u.isInstantiableClass(t)) {
              const e = c.lookUpClassMember(t, '__init__', 22);
              if (e) {
                const t = this._evaluator.getTypeOfMember(e);
                if (t && u.isFunction(t)) {
                  const t = e.symbol.getDeclarations();
                  if (t && t.length > 0) {
                    const e = t[0];
                    if (e.type === 5) {
                      a = e.node;
                    }
                  }
                }
              }
            }
          }
        }
        if (!a) {
          return null;
        }
        const s = new S(this._program.fileSystem, a, this._parseResults, this._evaluator, this._token).findCalls();
        if (s.length === 0) {
          return null;
        } else {
          return s.filter(e => w.canNavigateToFile(this._program.fileSystem, _.Uri.parse(e.to.uri, this._program.serviceProvider)));
        }
      }
      get _evaluator() {
        return this._program.evaluator;
      }
      _getTargetDeclaration(e) {
        const t = e.declarations;
        const n = e.nodeAtOffset;
        let a;
        let r;
        let s = t[0];
        for (const e of t) {
          if ((o.hasTypeForDeclaration(e) || !o.hasTypeForDeclaration(s)) && (e.type === 5 || e.type === 6) && (s = e, e.node === n)) {
            break;
          }
        }
        if (s.type === 8) {
          a = e.nodeAtOffset.d.value;
          r = this._fileUri;
        } else {
          a = o.getNameFromDeclaration(s) || e.symbolNames[0];
          r = s.uri;
        }
        return {
          targetDecl: s,
          callItemUri: r,
          symbolName: a
        };
      }
      _getIncomingCallsForDeclaration(e, t, n) {
        m.throwIfCancellationRequested(this._token);
        const a = new A(this._program, e, t, n, this._token).findCalls();
        if (a.length > 0) {
          return a;
        } else {
          return undefined;
        }
      }
      _getDeclaration() {
        return I.ReferencesProvider.getDeclarationForPosition(this._program, this._fileUri, this._position, undefined, h.ReferenceUseCase.References, this._token);
      }
    };
    class S extends p.ParseTreeWalker {
      constructor(e, t, n, a, r) {
        super();
        this._fs = e;
        this._parseRoot = t;
        this._parseResults = n;
        this._evaluator = a;
        this._cancellationToken = r;
        this._outgoingCalls = [];
      }
      findCalls() {
        this.walk(this._parseRoot);
        return this._outgoingCalls;
      }
      visitCall(e) {
        var t;
        let n;
        m.throwIfCancellationRequested(this._cancellationToken);
        if (e.d.leftExpr.nodeType === 38) {
          n = e.d.leftExpr;
        } else {
          if (e.d.leftExpr.nodeType === 35) {
            n = e.d.leftExpr.d.member;
          }
        }
        if (n) {
          const e = (t = this._evaluator.getDeclInfoForNameNode(n)) === null || t === undefined ? undefined : t.decls;
          if (e) {
            e.forEach(e => {
              this._addOutgoingCallForDeclaration(n, e);
            });
          }
        }
        return true;
      }
      visitMemberAccess(e) {
        m.throwIfCancellationRequested(this._cancellationToken);
        const t = this._evaluator.getType(e.d.leftExpr);
        if (t) {
          c.doForEachSubtype(t, t => {
            let n = t;
            n = this._evaluator.makeTopLevelTypeVarsConcrete(n);
            if (!u.isClassInstance(n)) {
              return;
            }
            const a = c.lookUpObjectMember(n, e.d.member.d.value);
            if (!a) {
              return;
            }
            const r = this._evaluator.getTypeOfMember(a);
            const s = a.symbol.getDeclarations();
            if (r && u.isClassInstance(r) && u.ClassType.isPropertyClass(r)) {
              s.forEach(t => {
                this._addOutgoingCallForDeclaration(e.d.member, t);
              });
            }
          });
        }
        return true;
      }
      _addOutgoingCallForDeclaration(e, t) {
        var n;
        var a;
        const r = this._evaluator.resolveAliasDeclaration(t, true);
        if (!r) {
          return;
        }
        if (r.type !== 5 && r.type !== 6) {
          return;
        }
        const s = {
          name: e.d.value,
          kind: (n = f.getSymbolKind(r, this._evaluator, e.d.value)) !== null && n !== undefined ? n : i.SymbolKind.Module,
          uri: C.convertUriToLspUriString(this._fs, r.uri),
          range: r.range,
          selectionRange: r.range
        };
        let l = this._outgoingCalls.find(e => e.to.uri === s.uri && b.rangesAreEqual(e.to.range, s.range));
        if (!l) {
          l = {
            to: s,
            fromRanges: []
          };
          this._outgoingCalls.push(l);
        }
        if (l && l.to.name !== e.d.value) {
          l.to.name = (a = o.getNameFromDeclaration(r)) !== null && a !== undefined ? a : e.d.value;
        }
        const p = T.convertOffsetsToRange(e.start, e.start + e.length, this._parseResults.tokenizerOutput.lines);
        l.fromRanges.push(p);
      }
    }
    class A extends p.ParseTreeWalker {
      constructor(e, t, n, a, r) {
        var s;
        super();
        this._program = e;
        this._fileUri = t;
        this._symbolName = n;
        this._targetDeclaration = a;
        this._cancellationToken = r;
        this._incomingCalls = [];
        this._declarations = [];
        this._parseResults = this._program.getParseResults(this._fileUri);
        this._usageProviders = ((s = this._program.serviceProvider.tryGet(v.ServiceKeys.symbolUsageProviderFactory)) !== null && s !== undefined ? s : []).map(e => e.tryCreateProvider(h.ReferenceUseCase.References, [this._targetDeclaration], this._cancellationToken)).filter(g.isDefined);
        this._declarations.push(this._targetDeclaration);
        this._usageProviders.forEach(e => e.appendDeclarationsTo(this._declarations));
      }
      findCalls() {
        this.walk(this._parseResults.parserOutput.parseTree);
        return this._incomingCalls;
      }
      visitCall(e) {
        let t;
        m.throwIfCancellationRequested(this._cancellationToken);
        if (e.d.leftExpr.nodeType === 38) {
          t = e.d.leftExpr;
        } else {
          if (e.d.leftExpr.nodeType === 35) {
            t = e.d.leftExpr.d.member;
          }
        }
        if (t && t.d.value === this._symbolName) {
          const e = this._getDeclarations(t);
          if (e) {
            if (this._targetDeclaration.type === 8) {
              const n = this._evaluator.resolveAliasDeclaration(this._targetDeclaration, true);
              if (n && e.some(e => o.areDeclarationsSame(e, n))) {
                this._addIncomingCallForDeclaration(t);
              }
            } else {
              if (e.some(e => this._declarations.some(t => o.areDeclarationsSame(e, t)))) {
                this._addIncomingCallForDeclaration(t);
              }
            }
          }
        }
        return true;
      }
      visitMemberAccess(e) {
        m.throwIfCancellationRequested(this._cancellationToken);
        if (e.d.member.d.value === this._symbolName) {
          const t = this._evaluator.getType(e.d.leftExpr);
          if (t) {
            c.doForEachSubtype(t, t => {
              let n = t;
              n = this._evaluator.makeTopLevelTypeVarsConcrete(n);
              if (!u.isClassInstance(n)) {
                return;
              }
              const a = c.lookUpObjectMember(n, e.d.member.d.value);
              if (!a) {
                return;
              }
              const r = this._evaluator.getTypeOfMember(a);
              const s = a.symbol.getDeclarations();
              if (r && s.some(e => o.areDeclarationsSame(e, this._targetDeclaration))) {
                this._addIncomingCallForDeclaration(e.d.member);
              }
            });
          }
        }
        return true;
      }
      get _evaluator() {
        return this._program.evaluator;
      }
      _getDeclarations(e) {
        const t = k.DocumentSymbolCollector.getDeclarationsForNode(this._program, e, true, this._cancellationToken);
        const n = [...t];
        this._usageProviders.forEach(a => a.appendDeclarationsAt(e, t, n));
        return n;
      }
      _addIncomingCallForDeclaration(e) {
        let t;
        let n = l.getExecutionScopeNode(e);
        while (n && n.nodeType === 76) {
          n = l.getExecutionScopeNode(n);
        }
        if (!n) {
          return;
        }
        if (n.nodeType === 36) {
          const e = T.convertOffsetsToRange(0, 0, this._parseResults.tokenizerOutput.lines);
          const n = this._program.fileSystem.getOriginalUri(this._fileUri).fileName;
          t = {
            name: `(module) ${n}`,
            kind: i.SymbolKind.Module,
            uri: C.convertUriToLspUriString(this._program.fileSystem, this._fileUri),
            range: e,
            selectionRange: e
          };
        } else {
          if (n.nodeType === 33) {
            const e = T.convertOffsetsToRange(n.start, n.start + n.length, this._parseResults.tokenizerOutput.lines);
            t = {
              name: '(lambda)',
              kind: i.SymbolKind.Function,
              uri: C.convertUriToLspUriString(this._program.fileSystem, this._fileUri),
              range: e,
              selectionRange: e
            };
          } else {
            const e = T.convertOffsetsToRange(n.d.name.start, n.d.name.start + n.d.name.length, this._parseResults.tokenizerOutput.lines);
            t = {
              name: n.d.name.d.value,
              kind: i.SymbolKind.Function,
              uri: C.convertUriToLspUriString(this._program.fileSystem, this._fileUri),
              range: e,
              selectionRange: e
            };
          }
        }
        let a = this._incomingCalls.find(e => e.from.uri === t.uri && b.rangesAreEqual(e.from.range, t.range));
        if (!a) {
          a = {
            from: t,
            fromRanges: []
          };
          this._incomingCalls.push(a);
        }
        const r = T.convertOffsetsToRange(e.start, e.start + e.length, this._parseResults.tokenizerOutput.lines);
        a.fromRanges.push(r);
      }
    }
  },
  29512: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CodeActionProvider = undefined;
    const a = require(56911);
    const r = require(91426);
    const s = require(23574);
    const i = require(74382);
    const o = require(67703);
    exports.CodeActionProvider = class {
      static mightSupport(e) {
        return !e || e.length === 0 || e.some(e => e.startsWith(a.CodeActionKind.QuickFix));
      }
      static async getCodeActionsForPosition(e, t, n, l, p) {
        r.throwIfCancellationRequested(p);
        const d = [];
        if (!e.rootUri || e.disableLanguageServices) {
          return d;
        }
        if (!this.mightSupport(l)) {
          return d;
        }
        const c = await e.service.getDiagnosticsForRange(t, n, p);
        const u = c.find(e => {
          const t = e.getActions();
          return t && t.find(e => e.action === 'pyright.createtypestub');
        });
        if (u) {
          const n = u.getActions().find(e => e.action === 'pyright.createtypestub');
          if (n) {
            const r = a.CodeAction.create(o.Localizer.CodeAction.createTypeStubFor().format({
              moduleName: n.moduleName
            }), s.createCommand(o.Localizer.CodeAction.createTypeStub(), 'pyright.createtypestub', e.rootUri.toString(), n.moduleName, t.toString()), a.CodeActionKind.QuickFix);
            d.push(r);
          }
        }
        const m = c.find(e => {
          const t = e.getActions();
          return t && t.find(e => e.action === 'renameShadowedFile');
        });
        if (m) {
          const t = m.getActions().find(e => e.action === 'renameShadowedFile');
          if (t) {
            const n = o.Localizer.CodeAction.renameShadowedFile().format({
              oldFile: t.oldUri.getShortenedFileName(),
              newFile: t.newUri.getShortenedFileName()
            });
            const r = {
              edits: [],
              fileOperations: [{
                kind: 'rename',
                oldFileUri: t.oldUri,
                newFileUri: t.newUri
              }]
            };
            const s = i.convertToWorkspaceEdit(e.service.fs, r);
            const l = a.CodeAction.create(n, s, a.CodeActionKind.QuickFix);
            d.push(l);
          }
        }
        return d;
      }
    };
  },
  5737: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CompletionMap = exports.CompletionProvider = exports.indexValueDetail = exports.autoImportDetail = undefined;
    const i = require(56911);
    const o = __importStar(require(26687));
    const l = require(28445);
    const p = require(83760);
    const d = require(21451);
    const c = require(75130);
    const u = require(44321);
    const m = __importStar(require(41557));
    const y = require(41557);
    const g = require(95952);
    const h = require(3113);
    const f = __importStar(require(12097));
    const T = require(4064);
    const v = require(66308);
    const b = require(30889);
    const _ = require(55501);
    const C = require(21024);
    const I = require(92324);
    const k = require(91426);
    const w = require(58147);
    const S = __importStar(require(48281));
    const A = require(48281);
    const x = require(56412);
    const P = require(56814);
    const D = require(63808);
    require(23070);
    const N = __importStar(require(89740));
    const F = require(88754);
    const E = require(27113);
    const M = require(74382);
    const O = require(67703);
    const z = require(85114);
    const U = require(49969);
    const V = require(16835);
    const R = require(51868);
    const L = require(67032);
    const B = require(39426);
    var j;
    var q;
    (function (e) {
      const t = ['True', 'False', 'None', 'and', 'or', 'not', 'is', 'lambda', 'yield', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'nonlocal', 'pass', 'raise', 'return', 'try', 'type', 'while', 'with'];
      const n = [...t, 'async', 'await'];
      const a = [...n, 'case', 'match'];
      e.forVersion = function (e) {
        if (D.PythonVersion.isGreaterOrEqualTo(e, D.pythonVersion3_10)) {
          return a;
        } else {
          if (D.PythonVersion.isGreaterOrEqualTo(e, D.pythonVersion3_5)) {
            return n;
          } else {
            return t;
          }
        }
      };
    })(j ||= {});
    (function (e) {
      e[e.LikelyKeyword = 0] = 'LikelyKeyword';
      e[e.RecentImportModuleName = 1] = 'RecentImportModuleName';
      e[e.ImportModuleName = 2] = 'ImportModuleName';
      e[e.LiteralValue = 3] = 'LiteralValue';
      e[e.NamedParameter = 4] = 'NamedParameter';
      e[e.RecentKeywordOrSymbol = 5] = 'RecentKeywordOrSymbol';
      e[e.RecentAutoImport = 6] = 'RecentAutoImport';
      e[e.Keyword = 7] = 'Keyword';
      e[e.EnumMember = 8] = 'EnumMember';
      e[e.NormalSymbol = 9] = 'NormalSymbol';
      e[e.PrivateSymbol = 10] = 'PrivateSymbol';
      e[e.DunderSymbol = 11] = 'DunderSymbol';
      e[e.AutoImport = 12] = 'AutoImport';
    })(q ||= {});
    exports.autoImportDetail = O.Localizer.Completion.autoImportDetail();
    exports.indexValueDetail = O.Localizer.Completion.indexValueDetail();
    class G {
      constructor(e, t, n, a, r) {
        this.program = e;
        this.fileUri = t;
        this.position = n;
        this.options = a;
        this.cancellationToken = r;
        this._stringLiteralContainer = undefined;
        this.execEnv = this.configOptions.findExecEnvironment(this.fileUri);
        this.parseResults = this.program.getParseResults(this.fileUri);
        this.sourceMapper = this.program.getSourceMapper(this.fileUri, this.cancellationToken, true);
      }
      getCompletions() {
        if (!this.program.getSourceFileInfo(this.fileUri)) {
          return null;
        }
        const e = this._getCompletions();
        return i.CompletionList.create(e == null ? undefined : e.toArray());
      }
      resolveCompletionItem(e) {
        k.throwIfCancellationRequested(this.cancellationToken);
        const t = this.getCompletionItemData(e);
        const n = e.label;
        let a = '';
        if (t.autoImportText) {
          a = t.autoImportText;
        }
        const r = G._mostRecentCompletions.findIndex(e => e.label === n && e.autoImportText === a);
        if (r > 0) {
          G._mostRecentCompletions = G._mostRecentCompletions.splice(r, 1);
        }
        if (r !== 0) {
          G._mostRecentCompletions.unshift({
            label: n,
            autoImportText: a
          });
        }
        if (G._mostRecentCompletions.length > 128) {
          G._mostRecentCompletions.pop();
        }
        if (t.symbolLabel) {
          if (t.moduleUri && c.ImportResolver.isSupportedImportSourceFile(E.Uri.parse(t.moduleUri, this.program.serviceProvider))) {
            const n = E.Uri.parse(t.moduleUri, this.program.serviceProvider);
            const a = b.getModuleDocStringFromUris([n], this.sourceMapper);
            if (!a) {
              return;
            }
            if (this.options.format === i.MarkupKind.Markdown) {
              const t = this.program.serviceProvider.docStringService().convertDocStringToMarkdown(a, b.isBuiltInModule(n));
              e.documentation = {
                kind: i.MarkupKind.Markdown,
                value: t
              };
            } else {
              if (this.options.format === i.MarkupKind.PlainText) {
                const t = this.program.serviceProvider.docStringService().convertDocStringToPlainText(a);
                e.documentation = {
                  kind: i.MarkupKind.PlainText,
                  value: t
                };
              }
            }
          } else {
            this.itemToResolve = e;
            if (t.autoImportText) {
              if (!e.additionalTextEdits) {
                const e = new W();
                this.addAutoImportCompletions(t.symbolLabel, 1, false, e);
              }
            } else {
              this.getCompletions();
            }
          }
        }
      }
      get evaluator() {
        return this.program.evaluator;
      }
      get importResolver() {
        return this.program.importResolver;
      }
      get configOptions() {
        return this.program.configOptions;
      }
      getCompletionItemData(e) {
        return x.fromLSPAny(e.data);
      }
      getMethodOverrideCompletions(e, t, n) {
        var a;
        var r;
        const s = m.getEnclosingClass(t, true);
        if (!s) {
          return;
        }
        const o = this.evaluator.getTypeOfClass(s);
        if (!o) {
          return;
        }
        const l = new Map();
        for (let e = 1; e < o.classType.shared.mro.length; e++) {
          const t = o.classType.shared.mro[e];
          if (C.isInstantiableClass(t)) {
            I.getMembersForClass(t, l, false);
          }
        }
        const p = (a = n == null ? undefined : n.some(e => m.checkDecorator(e, 'staticmethod'))) !== null && a !== undefined && a;
        const d = (r = n == null ? undefined : n.some(e => m.checkDecorator(e, 'classmethod'))) !== null && r !== undefined && r;
        const c = new W();
        l.forEach((n, a) => {
          var r;
          let s = T.getLastTypedDeclarationForSymbol(n);
          if (s && s.type === 5 && N.isPatternInSymbol(t.d.value, a)) {
            const l = (r = this.evaluator.getTypeForDeclaration(s)) === null || r === undefined ? undefined : r.type;
            if (!l) {
              return;
            }
            let u = C.isClassInstance(l) && C.ClassType.isPropertyClass(l);
            if (f.isDunderName(a)) {
              u = false;
            }
            if (!C.isFunction(l) && !u) {
              return;
            }
            if (u) {
              const e = n.getTypedDeclarations();
              if (e.length > 0 && e[0].type === 5) {
                s = e[0];
              }
            }
            const m = C.isFunction(l) && C.FunctionType.isStaticMethod(l);
            const y = C.isFunction(l) && C.FunctionType.isClassMethod(l) && a !== '__init_subclass__';
            if (p !== m || d !== y) {
              return;
            }
            const g = this._printMethodSignature(o.classType, s);
            let T;
            if (h.isStubFile(this.fileUri)) {
              T = `${g}: ...`;
            } else {
              T = `${g}:\n${this.printOverriddenMethodBody(o.classType, m, u, s, s.node.d.isAsync)}`;
            }
            const v = this.createReplaceEdits(e, t, T);
            this.addSymbol(a, n, t.d.value, c, {
              funcParensDisabled: true,
              edits: {
                format: this.options.snippet ? i.InsertTextFormat.Snippet : undefined,
                textEdit: v
              }
            });
          }
        });
        return c;
      }
      printOverriddenMethodBody(e, t, n, a, r) {
        let s = this.parseResults.tokenizerOutput.predominantTabSequence;
        if (e.shared.baseClasses.length === 1 && C.isClass(e.shared.baseClasses[0]) && e.shared.baseClasses[0].shared.fullName === 'builtins.object') {
          s += this.options.snippet ? '${0:pass}' : 'pass';
          return s;
        }
        if (a.node.d.params.length === 0) {
          s += this.options.snippet ? '${0:pass}' : 'pass';
          return s;
        }
        const i = function (e) {
          const t = [];
          let n = false;
          for (const a of e) {
            if (a.d.name) {
              t.push([a, a.d.category === 0 && !!a.d.name && n]);
            }
            if (a.d.category === 1) {
              n = true;
            }
          }
          return t;
        }(t ? a.node.d.params : a.node.d.params.slice(1));
        if (a.node.d.name.d.value !== '__init__') {
          s += 'return ';
        }
        if (r) {
          s += 'await ';
        }
        if (n) {
          return `${s}super().${a.node.d.name.d.value}`;
        } else {
          return `${s}super().${a.node.d.name.d.value}(${i.map(function (e) {
            var t;
            const n = (t = e[0].d.name) === null || t === undefined ? undefined : t.d.value;
            if (e[0].d.category === 1) {
              return `*${n}`;
            }
            if (e[0].d.category === 2) {
              return `**${n}`;
            }
            if (e[1]) {
              return `${n}=${n}`;
            } else {
              return n;
            }
          }).join(', ')})`;
        }
      }
      createReplaceEdits(e, t, n) {
        const a = (t == null ? undefined : t.nodeType) === 38 ? this.position.character - e.length + t.d.value.length : this.position.character;
        const r = {
          start: {
            line: this.position.line,
            character: this.position.character - e.length
          },
          end: {
            line: this.position.line,
            character: a
          }
        };
        return i.TextEdit.replace(r, n);
      }
      shouldProcessDeclaration(e) {
        return true;
      }
      addSymbol(e, t, n, a, r) {
        var s;
        var o;
        var l;
        var p;
        this.program.handleMemoryHighUsage();
        let d = T.getLastTypedDeclarationForSymbol(t);
        if (!d) {
          const e = t.getDeclarations();
          if (e.length > 0) {
            d = e[e.length - 1];
          }
        }
        if (!this.shouldProcessDeclaration(d)) {
          return;
        }
        d = d ? (s = this.evaluator.resolveAliasDeclaration(d, true)) !== null && s !== undefined ? s : d : undefined;
        const c = r.autoImportSource ? this.getAutoImportText(e, r.autoImportSource, r.autoImportAlias) : undefined;
        if (this.itemToResolve) {
          const n = this.getCompletionItemData(this.itemToResolve);
          if (n.symbolLabel !== e) {
            return;
          }
          if (this.itemToResolve.additionalTextEdits === undefined && ((o = r.edits) === null || o === undefined ? undefined : o.additionalTextEdits) !== undefined) {
            this.itemToResolve.additionalTextEdits = M.convertToTextEdits(r.edits.additionalTextEdits);
          }
          if (n.autoImportText) {
            return;
          }
          const a = this.evaluator.getEffectiveTypeOfSymbol(t);
          if (!a) {
            return;
          }
          const s = R.getTypeDetail(this.evaluator, a, d, e, r, this.configOptions.functionSignatureDisplay);
          const l = B.getDocumentationPartsForTypeAndDecl(this.sourceMapper, a, d, this.evaluator, {
            name: e,
            symbol: t,
            boundObjectOrClass: r.boundObjectOrClass
          });
          if (this.options.format === i.MarkupKind.Markdown || this.options.format === i.MarkupKind.PlainText) {
            this.itemToResolve.documentation = R.getCompletionItemDocumentation(this.program.serviceProvider, s, l, this.options.format, d);
          } else {
            A.fail(`Unsupported markup type: ${this.options.format}`);
          }
        } else {
          if (d) {
            let t = this._convertDeclarationTypeToItemKind(d);
            if (this._isEnumMember(r.boundObjectOrClass, e)) {
              t = i.CompletionItemKind.EnumMember;
            }
            this.addNameToCompletions((l = r.autoImportAlias) !== null && l !== undefined ? l : e, t, n, a, {
              autoImportText: c,
              extraCommitChars: r.extraCommitChars,
              funcParensDisabled: r.funcParensDisabled,
              edits: r.edits
            });
          } else {
            const s = (p = t.getSynthesizedType()) === null || p === undefined ? undefined : p.type;
            if (s) {
              const t = this._convertTypeToItemKind(s);
              this.addNameToCompletions(e, t, n, a, {
                extraCommitChars: r.extraCommitChars,
                funcParensDisabled: r.funcParensDisabled,
                edits: r.edits
              });
            }
          }
        }
      }
      getMemberAccessCompletions(e, t) {
        const n = new Map();
        const a = new W();
        let r = this.evaluator.getType(e);
        if (r) {
          r = this.evaluator.makeTopLevelTypeVarsConcrete(r);
          if (C.isUnknown(r) && r.priv.possibleType) {
            r = this.evaluator.makeTopLevelTypeVarsConcrete(r.priv.possibleType);
          }
          I.doForEachSubtype(r, r => {
            r = this.evaluator.makeTopLevelTypeVarsConcrete(r);
            if (C.isClass(r)) {
              const e = C.TypeBase.isInstance(r);
              I.getMembersForClass(r, n, e);
              if (C.ClassType.isEnumClass(r) && e) {
                for (const e of n.keys()) {
                  if (this._isEnumMember(r, e)) {
                    n.delete(e);
                  }
                }
              }
            } else {
              if (C.isModule(r)) {
                I.getMembersForModule(r, n);
              } else {
                if (C.isFunction(r) || C.isOverloaded(r)) {
                  const t = this.evaluator.getBuiltInType(e, 'function');
                  if (t && C.isInstantiableClass(t)) {
                    I.getMembersForClass(t, n, true);
                  }
                } else {
                  if (I.isNoneInstance(r)) {
                    const t = this.evaluator.getBuiltInType(e, 'object');
                    if (t && C.isInstantiableClass(t)) {
                      I.getMembersForClass(t, n, C.TypeBase.isInstance(r));
                    }
                  }
                }
              }
            }
            this._addSymbolsForSymbolTable(n, () => true, t, e, false, C.isClass(r) ? r : undefined, a);
          });
          return a;
        } else {
          return a;
        }
      }
      createAutoImporter(e, t) {
        const n = this.program.getSourceFileInfo(this.fileUri);
        const a = V.buildModuleSymbolsMap(this.program.getSourceFileInfoList().filter(e => e !== n));
        return new V.AutoImporter(this.program, this.execEnv, this.parseResults, this.position, e, a, {
          lazyEdit: t
        });
      }
      addAutoImportCompletions(e, t, n, a, r) {
        if (!this.configOptions.autoImportCompletions) {
          return;
        }
        const s = this.createAutoImporter(a, n);
        const i = [];
        w.appendArray(i, s.getAutoImportCandidates(e, t, undefined, this.cancellationToken));
        this.addImportResults(i, e, a, r);
      }
      addImportResults(e, t, n, a) {
        var r;
        var s;
        for (const o of e) {
          if (o.symbol) {
            this.addSymbol(o.name, o.symbol, t, n, {
              extraCommitChars: true,
              autoImportSource: o.source,
              autoImportAlias: o.alias,
              edits: {
                textEdit: this.createReplaceEdits(t, undefined, o.insertionText),
                additionalTextEdits: o.edits
              },
              funcParensDisabled: a
            });
          } else {
            this.addNameToCompletions((r = o.alias) !== null && r !== undefined ? r : o.name, (s = o.kind) !== null && s !== undefined ? s : i.CompletionItemKind.Module, t, n, {
              extraCommitChars: true,
              autoImportText: this.getAutoImportText(o.name, o.source, o.alias),
              edits: {
                textEdit: this.createReplaceEdits(t, undefined, o.insertionText),
                additionalTextEdits: o.edits
              },
              funcParensDisabled: a
            });
          }
        }
      }
      addExtraCommitChar(e) {}
      addNameToCompletions(e, n, a, r, s) {
        var o;
        var l;
        var p;
        var d;
        if (!(s == null ? undefined : s.autoImportText) && !N.isPatternInSymbol(a, e)) {
          return;
        }
        if (r.has(e, e => W.matchKindAndImportText(e, this.getCompletionItemData.bind(this)), n, (o = s == null ? undefined : s.autoImportText) === null || o === undefined ? undefined : o.importText)) {
          return;
        }
        const c = i.CompletionItem.create(e);
        c.kind = n;
        if (s == null ? undefined : s.extraCommitChars) {
          this.addExtraCommitChar(c);
        }
        const u = {
          uri: this.fileUri.toString(),
          position: this.position
        };
        if (!!(s == null ? undefined : s.funcParensDisabled) || !this.options.snippet) {
          u.funcParensDisabled = true;
        }
        if (s == null ? undefined : s.moduleUri) {
          u.moduleUri = s.moduleUri.toString();
        }
        c.data = x.toLSPAny(u);
        if ((s == null ? undefined : s.sortText) || (s == null ? undefined : s.itemDetail)) {
          c.sortText = s.sortText;
          c.detail = s.itemDetail;
        } else {
          if (s == null ? undefined : s.autoImportText) {
            c.sortText = this._makeSortText(q.AutoImport, `${e}.${this._formatInteger(s.autoImportText.source.length, 2)}.${s.autoImportText.source}`, s.autoImportText.importText);
            u.autoImportText = s.autoImportText.importText;
            c.detail = exports.autoImportDetail;
            if (s.autoImportText.source) {
              c.labelDetails = {
                description: s.autoImportText.source
              };
            }
          } else {
            if (n === i.CompletionItemKind.EnumMember) {
              c.sortText = this._makeSortText(q.EnumMember, e);
            } else {
              if (f.isDunderName(e)) {
                c.sortText = this._makeSortText(q.DunderSymbol, e);
              } else {
                if (a === '' && f.isPrivateOrProtectedName(e)) {
                  c.sortText = this._makeSortText(q.PrivateSymbol, e);
                } else {
                  c.sortText = this._makeSortText(q.NormalSymbol, e);
                }
              }
            }
          }
        }
        u.symbolLabel = e;
        if (this.options.format === i.MarkupKind.Markdown) {
          let e = '';
          if (s == null ? undefined : s.autoImportText) {
            e += s.autoImportText.importText;
            if (s.typeDetail || s.documentation) {
              e += '\n\n';
            }
          }
          if (s == null ? undefined : s.typeDetail) {
            e += `\`\`\`python
${s.typeDetail}
\`\`\`
`;
          }
          if (s == null ? undefined : s.documentation) {
            e += '---\n';
            e += this.program.serviceProvider.docStringService().convertDocStringToMarkdown(s.documentation, b.isBuiltInModule(s.moduleUri));
          }
          e = e.trimEnd();
          if (e) {
            c.documentation = {
              kind: i.MarkupKind.Markdown,
              value: e
            };
          }
        } else {
          if (this.options.format === i.MarkupKind.PlainText) {
            let e = '';
            if (s == null ? undefined : s.autoImportText) {
              e += s.autoImportText.importText;
              if (s.typeDetail || s.documentation) {
                e += '\n\n';
              }
            }
            if (s == null ? undefined : s.typeDetail) {
              e += s.typeDetail + '\n';
            }
            if (s == null ? undefined : s.documentation) {
              e += `
${this.program.serviceProvider.docStringService().convertDocStringToPlainText(s.documentation)}`;
            }
            e = e.trimEnd();
            if (e) {
              c.documentation = {
                kind: i.MarkupKind.PlainText,
                value: e
              };
            }
          } else {
            A.fail(`Unsupported markup type: ${this.options.format}`);
          }
        }
        if ((l = s == null ? undefined : s.edits) === null || l === undefined ? undefined : l.format) {
          c.insertTextFormat = s.edits.format;
        }
        if ((p = s == null ? undefined : s.edits) === null || p === undefined ? undefined : p.textEdit) {
          c.textEdit = s.edits.textEdit;
        }
        if (((d = s == null ? undefined : s.edits) === null || d === undefined ? undefined : d.additionalTextEdits) && (c.additionalTextEdits = M.convertToTextEdits(s.edits.additionalTextEdits), this.itemToResolve)) {
          if (this.getCompletionItemData(this.itemToResolve).autoImportText === u.autoImportText) {
            this.itemToResolve.additionalTextEdits = c.additionalTextEdits;
          }
        }
        r.set(c);
      }
      getAutoImportText(e, t, n) {
        const a = B.getAutoImportText(e, t, n);
        let r = '';
        if (this.options.format === i.MarkupKind.Markdown) {
          r = `\`\`\`\n${a}\n\`\`\``;
        } else {
          if (this.options.format === i.MarkupKind.PlainText) {
            r = a;
          } else {
            A.fail(`Unsupported markup type: ${this.options.format}`);
          }
        }
        return {
          source: t ?? '',
          importText: r
        };
      }
      get _fileContents() {
        var e;
        var t;
        if ((t = (e = this.parseResults) === null || e === undefined ? undefined : e.text) !== null && t !== undefined) {
          return t;
        } else {
          return '';
        }
      }
      _getCompletions() {
        var e;
        var t;
        const n = P.convertPositionToOffset(this.position, this.parseResults.tokenizerOutput.lines);
        if (n === undefined) {
          return;
        }
        let a = m.findNodeByOffset(this.parseResults.parserOutput.parseTree, n);
        const r = m.getTokenOverlapping(this.parseResults.tokenizerOutput.tokens, n);
        if ((r == null ? undefined : r.type) === 5) {
          const e = r;
          this._stringLiteralContainer = F.TextRange.contains(e, n) || e.flags & 65536 ? e : undefined;
        } else {
          if (a) {
            const e = m.getParentNodeOfType(a, 30);
            if (e) {
              this._stringLiteralContainer = e.d.token;
            }
          }
        }
        const s = a;
        const i = a ? m.getNodeDepth(a) : 0;
        if (!s || s.nodeType !== 38) {
          let t = n;
          let r = false;
          while (t >= 0) {
            t--;
            const n = this._fileContents.substr(t, 1);
            if (n === '(' || n === '\n' || n === '}') {
              break;
            }
            if (n === ',') {
              r = true;
            }
            const o = m.findNodeByOffset(this.parseResults.parserOutput.parseTree, t);
            if (o && o !== s) {
              if (m.getNodeDepth(o) > i) {
                a = o;
                if (r && ((e = a.parent) === null || e === undefined ? undefined : e.nodeType) === 26) {
                  a = a.parent;
                }
              }
              break;
            }
          }
        }
        if (a === undefined) {
          return;
        }
        const o = this.parseResults.tokenizerOutput.lines.getItemAt(this.position.line);
        const l = this._fileContents.substr(o.start, o.length);
        const p = l.substr(0, this.position.character);
        const d = l.substr(this.position.character);
        const c = p.search(/\w+$/);
        const u = c >= 0 ? p.substr(c) : '';
        if (this._isWithinComment(n)) {
          return;
        }
        let y = a;
        while (y && y.nodeType !== 0) {
          y = y.parent;
        }
        let g = y || a;
        while (true) {
          k.throwIfCancellationRequested(this.cancellationToken);
          if (g.nodeType === 49) {
            return this._getLiteralCompletions(g, n, u, p, d);
          }
          if (g.nodeType === 48 || g.nodeType === 30) {
            return;
          }
          if (g.nodeType === 37) {
            return this._getImportModuleCompletions(g);
          }
          if (g.nodeType === 0) {
            return this._getExpressionErrorCompletions(g, n, u, p, d);
          }
          if (g.nodeType === 35) {
            return this.getMemberAccessCompletions(g.d.leftExpr, u);
          }
          if (g.nodeType === 18) {
            const e = new W();
            if (this._tryAddTypedDictKeysFromDictionary(g, undefined, u, p, d, e)) {
              return e;
            }
          }
          const e = m.getFirstAncestorOrSelfOfKind(g, 20);
          if (e && ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 18) {
            const t = e.parent;
            if (t.d.trailingCommaToken && t.d.trailingCommaToken.start < n) {
              const e = new W();
              if (this._tryAddTypedDictKeysFromDictionary(t, undefined, u, p, d, e)) {
                return e;
              }
            }
          }
          if (g.nodeType === 38) {
            const e = this._tryGetNameCompletions(g, n, u, p, d);
            if (e || e === undefined) {
              return e;
            }
          }
          if (g.nodeType === 34 && this.options.triggerCharacter === '[') {
            return;
          }
          if (g.nodeType === 25) {
            return this._getImportFromCompletions(g, n, u);
          }
          if (z.isExpressionNode(g)) {
            return this._getExpressionCompletions(g, u, p, d);
          }
          if (g.nodeType === 50) {
            if (g.parent && g.parent.nodeType === 28 && !g.parent.d.name && g.parent.d.typeExpr && F.TextRange.getEnd(g.parent.d.typeExpr) < n && n <= g.parent.d.exceptSuite.start) {
              return;
            }
            if (g.parent && g.parent.nodeType === 10 && (!g.parent.d.name || !g.parent.d.name.d.value) && g.parent.d.arguments.length === 0 && n <= g.parent.d.suite.start) {
              return;
            }
            return this._getStatementCompletions(g, u, p, d);
          }
          if (g.nodeType === 36) {
            return this._getStatementCompletions(g, u, p, d);
          }
          if (g.nodeType === 41 && g.length === 0 && g.parent && g.parent.nodeType === 33) {
            return;
          }
          if (!g.parent) {
            break;
          }
          g = g.parent;
        }
      }
      _tryGetNameCompletions(e, t, n, a, r) {
        var s;
        var i;
        var o;
        var p;
        if (!e.parent) {
          return false;
        }
        if (e.parent.nodeType !== 24 || e.parent.d.alias !== e) {
          if (e.parent.nodeType === 37) {
            if (e.parent.parent && e.parent.parent.nodeType === 24 && !e.parent.parent.d.alias && F.TextRange.getEnd(e.parent.parent) < t) {
              return;
            }
            return this._getImportModuleCompletions(e.parent);
          }
          if (e.parent.nodeType === 26) {
            if (e.parent.d.alias === e) {
              return;
            }
            const a = e.parent.parent;
            if (a && a.nodeType === 25) {
              if (!e.parent.d.alias && F.TextRange.getEnd(e.parent) < t) {
                return;
              }
              if (e.parent.d.name === e) {
                return this._getImportFromCompletions(a, t, n);
              } else {
                return this._getImportFromCompletions(a, t, '');
              }
            }
            return false;
          }
          if (e.parent.nodeType === 35 && e === e.parent.d.member) {
            return this.getMemberAccessCompletions(e.parent.d.leftExpr, n);
          }
          if (e.parent.nodeType !== 28 || e !== e.parent.d.name) {
            if (e.parent.nodeType === 31 && e === e.parent.d.name) {
              if ((s = e.parent.d.decorators) === null || s === undefined ? undefined : s.some(e => this._isOverload(e))) {
                return this._getMethodOverloadsCompletions(n, e);
              } else {
                return undefined;
              }
            }
            if ((e.parent.nodeType !== 41 || e !== e.parent.d.name) && (e.parent.nodeType !== 10 || e !== e.parent.d.name) && (e.parent.nodeType !== 29 || !F.TextRange.contains(e.parent.d.targetExpr, e.start)) && (e.parent.nodeType !== 12 || !F.TextRange.contains(e.parent.d.targetExpr, e.start))) {
              if (e.parent.nodeType === 3 || e.parent.nodeType === 4) {
                if ((e.parent.nodeType === 4 ? e.parent.d.name : e.parent.d.leftExpr) !== e || n.length === 0) {
                  return false;
                }
                const t = (i = this.evaluator.getDeclInfoForNameNode(e)) === null || i === undefined ? undefined : i.decls;
                if ((t == null ? undefined : t.length) !== 1 || !l.isVariableDeclaration(t[0]) || t[0].node !== e) {
                  return false;
                }
                const s = this._getExpressionCompletions(e, n, a, r);
                if (s) {
                  s.delete(e.d.value);
                }
                return s;
              }
              if (e.parent.nodeType === 47 && ((o = e.parent.parent) === null || o === undefined ? undefined : o.nodeType) === 50 && ((p = e.parent.parent.parent) === null || p === undefined ? undefined : p.nodeType) === 10) {
                const t = this._getClassVariableCompletions(e);
                if (t) {
                  return t;
                }
              }
              return false;
            }
          }
        }
      }
      _isWithinComment(e) {
        var t;
        var n;
        const a = function (e, t) {
          const n = t.getItemAtPosition(e);
          if (n < 0) {
            return;
          }
          let a = t.getItemAt(n);
          if (e > a.start && e < a.start + a.length) {
            return;
          }
          for (let e = n - 1; e >= 0; e--) {
            const n = t.getItemAt(e);
            if (a.start !== n.start) {
              break;
            }
            a = n;
          }
          if (e <= a.start) {
            return a;
          }
          S.assert(n + 1 < t.length);
          return t.getItemAt(n + 1);
        }(e, this.parseResults.tokenizerOutput.tokens);
        return !!a && (n = (t = a.comments) === null || t === undefined ? undefined : t.some(t => F.TextRange.overlaps(t, e))) !== null && n !== undefined && n;
      }
      _getExpressionErrorCompletions(e, t, n, a, r) {
        var s;
        switch (e.d.category) {
          case 0:
            return this._createSingleKeywordCompletion('in');
          case 1:
            return this._createSingleKeywordCompletion('else');
          case 7:
          case 2:
            {
              const t = this.parseResults.tokenizerOutput;
              const s = P.convertPositionToOffset(this.position, t.lines);
              const i = m.getTokenIndexAtLeft(t.tokens, s);
              const o = m.getTokenAtIndex(t.tokens, i);
              const l = m.getTokenAtIndex(t.tokens, i - 1);
              if (e.d.category === 2) {
                if ((o == null ? undefined : o.type) === 20 || (o == null ? undefined : o.type) === 19) {
                  break;
                }
                if ((o == null ? undefined : o.type) !== 8 || F.TextRange.getEnd(o) !== s) {
                  return this._getExpressionCompletions(e, n, a, r);
                }
                if ((l == null ? undefined : l.type) !== 20) {
                  return this._getExpressionCompletions(e, n, a, r);
                }
                const t = F.TextRange.getEnd(l);
                const i = m.findNodeByOffset(this.parseResults.parserOutput.parseTree, t);
                if ((i == null ? undefined : i.nodeType) !== 0 || i.d.category !== 7) {
                  return this._getExpressionCompletions(e, n, a, r);
                }
                e = i;
              } else {
                if (e.d.category === 7 && ((o == null ? undefined : o.type) === 20 || (o == null ? undefined : o.type) === 19) && ((l == null ? undefined : l.type) === 20 || (l == null ? undefined : l.type) === 19)) {
                  return;
                }
              }
              return this._getMissingMemberAccessNameCompletions(e, n);
            }
          case 4:
          case 8:
            return this._getExpressionCompletions(e, n, a, r);
          case 11:
          case 3:
            {
              let s = this._getLiteralCompletions(e, t, n, a, r);
              if (!s) {
                s = this._getExpressionCompletions(e, n, a, r);
              }
              return s;
            }
          case 10:
            if (e.d.child && e.d.child.nodeType === 38) {
              if ((s = e.d.decorators) === null || s === undefined ? undefined : s.some(e => this._isOverload(e))) {
                return this._getMethodOverloadsCompletions(n, e.d.child);
              } else {
                return this.getMethodOverrideCompletions(n, e.d.child, e.d.decorators);
              }
            }
        }
      }
      _getMissingMemberAccessNameCompletions(e, t) {
        if (e.d.child && z.isExpressionNode(e.d.child)) {
          return this.getMemberAccessCompletions(e.d.child, t);
        }
      }
      _isOverload(e) {
        return m.checkDecorator(e, 'overload');
      }
      _createSingleKeywordCompletion(e) {
        const t = i.CompletionItem.create(e);
        t.kind = i.CompletionItemKind.Keyword;
        t.sortText = this._makeSortText(q.LikelyKeyword, e);
        const n = new W();
        n.set(t);
        return n;
      }
      _addClassVariableTypeAnnotationCompletions(e, t, n) {
        var a;
        var r;
        var s;
        var o;
        if (((a = t.parent) === null || a === undefined ? undefined : a.nodeType) !== 54 || t.parent.d.valueExpr.nodeType !== 38 || t.parent.d.annotation !== t || ((r = t.parent.parent) === null || r === undefined ? undefined : r.nodeType) !== 47 || ((s = t.parent.parent.parent) === null || s === undefined ? undefined : s.nodeType) !== 50 || ((o = t.parent.parent.parent.parent) === null || o === undefined ? undefined : o.nodeType) !== 10) {
          return;
        }
        const p = m.getEnclosingClass(t, false);
        if (!p) {
          return;
        }
        const d = this.evaluator.getTypeOfClass(p);
        if (!d) {
          return;
        }
        const c = t.parent.d.valueExpr.d.value;
        const u = I.lookUpClassMember(d.classType, c, 17);
        if (u) {
          const t = this.evaluator.getTypeOfMember(u);
          const a = this.evaluator.printType(t, {
            enforcePythonSyntax: true,
            expandTypeAlias: false
          });
          this.addNameToCompletions(a, i.CompletionItemKind.Reference, e, n, {
            sortText: this._makeSortText(q.LikelyKeyword, a)
          });
          return;
        }
        const y = new Map();
        for (const e of d.classType.shared.mro) {
          if (e !== d.classType && C.isInstantiableClass(e)) {
            I.getMembersForClass(e, y, false);
          }
        }
        const g = y.get(c);
        if (!g) {
          return;
        }
        const f = g.getDeclarations().filter(e => l.isVariableDeclaration(e) && e.moduleName !== 'builtins');
        if (f.length === 0 || f.some(e => e.node && m.getEnclosingClass(e.node, false) === p)) {
          return;
        }
        const T = f.filter(e => e.typeAnnotationNode);
        if (T.length === 0) {
          return;
        }
        const v = h.isStubFile(this.fileUri) ? 3 : 2;
        const b = `${m.printExpression(T[T.length - 1].typeAnnotationNode, v)}`;
        this.addNameToCompletions(b, i.CompletionItemKind.Reference, e, n, {
          sortText: this._makeSortText(q.LikelyKeyword, b)
        });
      }
      _getClassVariableCompletions(e) {
        const t = m.getEnclosingClass(e, false);
        if (!t) {
          return;
        }
        const n = this.evaluator.getTypeOfClass(t);
        if (!n) {
          return;
        }
        const a = new Map();
        for (const e of n.classType.shared.mro) {
          if (C.isInstantiableClass(e)) {
            I.getMembersForClass(e, a, false);
          }
        }
        const r = new W();
        a.forEach((n, a) => {
          if (f.isPrivateName(a) || n.isPrivateMember() || n.isExternallyHidden() || !N.isPatternInSymbol(e.d.value, a)) {
            return;
          }
          const s = n.getDeclarations().filter(e => l.isVariableDeclaration(e) && e.moduleName !== 'builtins');
          if (s.length !== 0 && !s.some(e => e.node && m.getEnclosingClass(e.node, false) === t)) {
            this.addSymbol(a, n, e.d.value, r, {});
          }
        });
        if (r.size > 0) {
          return r;
        } else {
          return undefined;
        }
      }
      _getMethodOverloadsCompletions(e, t) {
        var n;
        const a = function (e, t) {
          const n = m.getEnclosingClass(t, false);
          if (n) {
            const t = e.getTypeOfClass(n);
            if (!t) {
              return;
            }
            const a = new Map();
            for (const e of t.classType.shared.mro) {
              if (C.isInstantiableClass(e)) {
                I.getMembersForClass(e, a, false);
              }
            }
            return a;
          }
          const a = m.getEnclosingModule(t);
          if (a) {
            const e = o.getScope(a);
            if (e == null) {
              return undefined;
            } else {
              return e.symbolTable;
            }
          }
          return;
        }(this.evaluator, t);
        if (!a) {
          return;
        }
        const r = ((n = t.parent) === null || n === undefined ? undefined : n.nodeType) === 31 || undefined;
        const s = new W();
        const i = m.getEnclosingFunction(t);
        a.forEach((n, a) => {
          const o = T.getLastTypedDeclarationForSymbol(n);
          if (!o || o.type !== 5) {
            return;
          }
          if (!o.node.d.decorators.some(e => this._isOverload(e))) {
            return;
          }
          const l = n.getDeclarations();
          if ((l.length !== 1 || !l.some(e => e.node === i)) && N.isPatternInSymbol(t.d.value, a)) {
            const i = this.createReplaceEdits(e, t, o.node.d.name.d.value);
            this.addSymbol(a, n, t.d.value, s, {
              funcParensDisabled: r,
              edits: {
                textEdit: i
              }
            });
          }
        });
        return s;
      }
      _printMethodSignature(e, t) {
        const n = t.node;
        let a;
        if (h.isStubFile(this.fileUri)) {
          a = true;
        } else {
          if (e.shared.moduleName === t.moduleName) {
            a = false;
          }
        }
        const r = h.isStubFile(this.fileUri) ? 3 : 2;
        const s = n.d.params.map((e, t) => {
          let s = '';
          if (e.d.category === 1) {
            s += '*';
          } else {
            if (e.d.category === 2) {
              s += '**';
            }
          }
          if (e.d.name) {
            s += e.d.name.d.value;
          }
          const i = m.getTypeAnnotationForParam(n, t);
          if (i) {
            s += `: ${m.printExpression(i, r)}`;
          }
          if (e.d.defaultValue) {
            s += i ? ' = ' : '=';
            s += a ?? !m.isSimpleDefault(e.d.defaultValue) ? '...' : m.printExpression(e.d.defaultValue, r);
          }
          if (s || e.d.name || e.d.category !== 0) {
            return s;
          } else {
            return '/';
          }
        }).join(', ');
        let i = n.d.name.d.value + '(' + s + ')';
        if (n.d.returnAnnotation) {
          i += ` -> ${m.printExpression(n.d.returnAnnotation, r)}`;
        } else {
          if (n.d.funcAnnotationComment) {
            i += ` -> ${m.printExpression(n.d.funcAnnotationComment.d.returnAnnotation, r)}`;
          }
        }
        return i;
      }
      _getStatementCompletions(e, t, n, a) {
        return this._getExpressionCompletions(e, t, n, a);
      }
      _getExpressionCompletions(e, t, n, a) {
        var r;
        var s;
        var o;
        if (!this._isIndexArgument(e) && e.nodeType === 40) {
          return;
        }
        if (((r = e.parent) === null || r === undefined ? undefined : r.nodeType) === 59 && e.parent === ((s = e.parent.d.target) === null || s === undefined ? undefined : s.parent)) {
          return;
        }
        const l = new W();
        if (n.slice(-2) === '..') {
          return l;
        }
        this._addClassVariableTypeAnnotationCompletions(t, e, l);
        this._addCallArgumentCompletions(e, t, n, a, false, l);
        this._addSymbols(e, t, l);
        this._findMatchingKeywords(j.forVersion(this.execEnv.pythonVersion), t).map(e => {
          if (l.has(e)) {
            return;
          }
          const t = i.CompletionItem.create(e);
          t.kind = i.CompletionItemKind.Keyword;
          t.sortText = this._makeSortText(q.Keyword, e);
          l.set(t);
        });
        if (!t.startsWith('_') && !this.itemToResolve) {
          const n = ((o = e.parent) === null || o === undefined ? undefined : o.nodeType) === 16;
          this.addAutoImportCompletions(t, 0.25, this.options.lazyEdit, l, n);
        }
        this._tryAddLiterals(e, t, n, a, l);
        return l;
      }
      _isIndexArgument(e) {
        const t = e.parent;
        return t && t.nodeType === 1 && t.d.argCategory === 0 && t.parent && t.parent.nodeType === 27 && t.parent.d.leftExpr && t.parent.d.leftExpr.nodeType === 38;
      }
      _addCallArgumentCompletions(e, t, n, a, r, s) {
        const i = P.convertPositionToOffset(this.position, this.parseResults.tokenizerOutput.lines);
        const o = y.getCallNodeAndActiveParamIndex(e, i, this.parseResults.tokenizerOutput.tokens);
        if (!o) {
          return;
        }
        const l = this.evaluator.getCallSignatureInfo(o.callNode, o.activeIndex, o.activeOrFake);
        if (l) {
          const e = P.convertOffsetToPosition(l.callNode.d.leftExpr.start + l.callNode.d.leftExpr.length, this.parseResults.tokenizerOutput.lines);
          if (F.comparePositions(this.position, e) > 0) {
            if (!r) {
              this._addNamedParameters(l, t, s);
            }
            this._addLiteralValuesForArgument(l, t, n, a, s);
          }
        }
      }
      _addLiteralValuesForArgument(e, t, n, a, r) {
        e.signatures.forEach(e => {
          if (!e.activeParam) {
            return;
          }
          const s = e.type;
          const i = s.shared.parameters.indexOf(e.activeParam);
          if (i < 0) {
            return;
          }
          const o = C.FunctionType.getParamType(s, i);
          this._addLiteralValuesForTargetType(o, t, n, a, r);
        });
      }
      _addLiteralValuesForTargetType(e, t, n, a, r) {
        const s = this._getQuoteInfo(t, n);
        this._getSubTypesWithLiteralValues(e).forEach(e => {
          if (C.ClassType.isBuiltIn(e, 'str')) {
            const n = _.printLiteralValue(e, s.quoteCharacter);
            if (s.stringValue === undefined) {
              this.addNameToCompletions(n, i.CompletionItemKind.Constant, t, r, {
                sortText: this._makeSortText(q.LiteralValue, e.priv.literalValue)
              });
            } else {
              this._addStringLiteralToCompletions(n.substr(1, n.length - 2), s, a, r);
            }
          }
        });
      }
      _getDictExpressionStringKeys(e, t) {
        const n = function (e) {
          if (e.nodeType === 18) {
            return e;
          }
          let t = e;
          while (t && t.nodeType !== 18 && t.nodeType !== 45) {
            t = t.parent;
            if (!t) {
              return;
            }
          }
          return t;
        }(e);
        if (n) {
          return n.d.items.flatMap(e => e.nodeType !== 20 || (t == null ? undefined : t.has(e.d.keyExpr.id)) ? [] : e.d.keyExpr.nodeType === 48 ? [e.d.keyExpr.d.strings.map(e => e.d.value).join('')] : []);
        } else {
          return [];
        }
      }
      _getSubTypesWithLiteralValues(e) {
        const t = [];
        I.doForEachSubtype(e, e => {
          if (C.isClassInstance(e) && I.isLiteralType(e)) {
            t.push(e);
          }
        });
        return t;
      }
      _getIndexKeyType(e) {
        const t = this.evaluator.getBoundMagicMethod(e, '__getitem__');
        if (t) {
          const e = [];
          I.doForEachSignature(t, t => {
            if (t.shared.parameters.length >= 1 && t.shared.parameters[0].category === 0) {
              e.push(C.FunctionType.getParamType(t, 0));
            }
          });
          if (e.length > 0) {
            return C.combineTypes(e);
          }
        }
      }
      _getIndexKeys(e, t) {
        var n;
        var a;
        var r;
        var s;
        var i;
        var o;
        var l;
        var p;
        var d;
        var c;
        const u = this.evaluator.getType(e.d.leftExpr);
        if (!u || !C.isClassInstance(u)) {
          return [];
        }
        const y = this._getIndexKeyType(u);
        if (y) {
          const e = [];
          this._getSubTypesWithLiteralValues(y).forEach(t => {
            if (C.ClassType.isBuiltIn(t, 'str') || C.ClassType.isBuiltIn(t, 'int') || C.ClassType.isBuiltIn(t, 'bool') || C.ClassType.isBuiltIn(t, 'bytes') || C.ClassType.isEnumClass(t)) {
              e.push(_.printLiteralValue(t, this.parseResults.tokenizerOutput.predominantSingleQuoteCharacter));
            }
          });
          if (e.length > 0) {
            return e;
          }
        }
        if (e.d.leftExpr.nodeType !== 38) {
          return [];
        }
        const g = (a = (n = this.evaluator.getDeclInfoForNameNode(e.d.leftExpr)) === null || n === undefined ? undefined : n.decls) !== null && a !== undefined ? a : [];
        const h = g.length > 0 ? g[0] : undefined;
        if (!h || h.type !== 1 && h.type !== 2) {
          return [];
        }
        if (!h.uri.equals(this.fileUri)) {
          return [];
        }
        let f = e.d.leftExpr;
        if (h.node) {
          const e = m.getEvaluationScopeNode(h.node).node;
          if ((r = m.getFileInfoFromNode(f)) === null || r === undefined ? undefined : r.fileUri.equals((s = m.getFileInfoFromNode(e)) === null || s === undefined ? undefined : s.fileUri)) {
            f = e;
          }
        }
        const T = L.DocumentSymbolCollector.collectFromNode(this.program, e.d.leftExpr, this.cancellationToken, f);
        const v = new Set();
        for (const e of T) {
          const n = ((i = e.node.parent) === null || i === undefined ? undefined : i.nodeType) === 54 ? e.node.parent : e.node;
          if (((o = n.parent) === null || o === undefined ? undefined : o.nodeType) === 3 || ((l = n.parent) === null || l === undefined ? undefined : l.nodeType) === 4) {
            if (n.parent.d.rightExpr.nodeType === 18) {
              const e = n.parent.d.rightExpr;
              for (const t of e.d.items.filter(e => e.nodeType === 20)) {
                const e = this.parseResults.text.substr(t.d.keyExpr.start, t.d.keyExpr.length).trim();
                if (e.length > 0) {
                  v.add(e);
                }
              }
            }
            if (n.parent.d.rightExpr.nodeType === 9) {
              const e = n.parent.d.rightExpr;
              const t = this.evaluator.getType(e.d.leftExpr);
              if (!t || !C.isInstantiableClass(t) || !C.ClassType.isBuiltIn(t, 'dict')) {
                continue;
              }
              for (const t of e.d.args) {
                const e = (d = (p = t.d.name) === null || p === undefined ? undefined : p.d.value.trim()) !== null && d !== undefined ? d : '';
                const n = this.parseResults.tokenizerOutput.predominantSingleQuoteCharacter;
                if (e.length > 0) {
                  v.add(`${n}${e}${n}`);
                }
              }
            }
          }
          if (((c = n.parent) === null || c === undefined ? undefined : c.nodeType) === 27 && n.parent.d.items.length === 1 && n.parent.d.items[0].d.valueExpr.nodeType !== 0 && !F.TextRange.containsRange(n.parent, t)) {
            const e = n.parent.d.items[0];
            const t = this.parseResults.text.substr(e.d.valueExpr.start, e.d.valueExpr.length).trim();
            if (t.length > 0) {
              v.add(t);
            }
          }
        }
        return Array.from(v);
      }
      _getLiteralCompletions(e, t, n, a, r) {
        if ((this.options.triggerCharacter === '"' || this.options.triggerCharacter === '\'') && e.start !== t - 1) {
          return;
        }
        const s = new W();
        if (this._tryAddLiterals(e, n, a, r, s)) {
          return s;
        } else {
          return undefined;
        }
      }
      _tryAddLiterals(e, n, a, r, s) {
        var o;
        var l;
        var p;
        var d;
        var c;
        var u;
        const m = function (e) {
          var t;
          if (!e.parent) {
            return;
          }
          if (e.nodeType !== 49) {
            return {
              parent: e.parent,
              child: e
            };
          }
          if (!e.parent.parent) {
            return;
          }
          if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 48 || e.parent.d.strings.length > 1) {
            return;
          }
          return {
            parent: e.parent.parent,
            child: e.parent
          };
        }(e);
        if (!m) {
          return false;
        }
        const y = m.parent.nodeType === 3 ? m.parent.d.rightExpr === m.child ? m.child : undefined : z.isExpressionNode(m.child) ? m.child : undefined;
        if (y) {
          const e = this.evaluator.getExpectedType(y);
          if (e && I.containsLiteralType(e.type)) {
            this._addLiteralValuesForTargetType(e.type, n, a, r, s);
            return true;
          }
        }
        const g = m.parent;
        if (g) {
          let t;
          if (g.nodeType === 20 && g.d.keyExpr === m.child && ((o = g.parent) === null || o === undefined ? undefined : o.nodeType) === 18) {
            t = g.parent;
          } else {
            if ((g == null ? undefined : g.nodeType) === 45) {
              t = g;
            }
          }
          if (t && this._tryAddTypedDictKeysFromDictionary(t, e.nodeType === 49 ? e : undefined, n, a, r, s)) {
            return true;
          }
        }
        const h = m.parent;
        if (h.nodeType === 1 && ((l = h.parent) === null || l === undefined ? undefined : l.nodeType) === 27) {
          const o = e.nodeType === 49 ? a : '';
          if (this._tryAddTypedDictKeysFromIndexer(h.parent, n, o, r, s)) {
            return true;
          }
          const l = this._getQuoteInfo(n, o);
          const p = this._getIndexKeys(h.parent, e);
          let d = false;
          for (const a of p) {
            if (s.has(a)) {
              continue;
            }
            const o = /^["|'].*["|']$/.test(a);
            if (e.nodeType !== 49 || o) {
              d = true;
              if (o) {
                const e = a.substr(1, a.length - 2);
                this._addStringLiteralToCompletions(e, l, r, s, exports.indexValueDetail);
              } else {
                this.addNameToCompletions(a, i.CompletionItemKind.Constant, n, s, {
                  sortText: this._makeSortText(q.LiteralValue, a),
                  itemDetail: exports.indexValueDetail
                });
              }
            }
          }
          if (d) {
            return true;
          }
        }
        const f = m.parent;
        if (f.nodeType === 7 && [2, 12, 28].includes(f.d.operator)) {
          const e = this.evaluator.getType(f.d.leftExpr);
          if (e && I.containsLiteralType(e)) {
            this._addLiteralValuesForTargetType(e, n, a, r, s);
            return true;
          }
        }
        const T = m.parent;
        if (T.nodeType === 4 && T.d.rightExpr === m.child) {
          const e = this.evaluator.getType(T.d.name);
          if (e && I.containsLiteralType(e)) {
            this._addLiteralValuesForTargetType(e, n, a, r, s);
            return true;
          }
        }
        const v = m.parent;
        if (v.nodeType === 64 && v.d.pattern.nodeType === 0 && v.d.pattern.d.category === 11 && v.d.suite === m.child && ((p = v.parent) === null || p === undefined ? undefined : p.nodeType) === 63) {
          const e = this.evaluator.getType(v.parent.d.expr);
          if (e && I.containsLiteralType(e)) {
            this._addLiteralValuesForTargetType(e, n, a, r, s);
            return true;
          }
        }
        const b = m.parent;
        if ((b.nodeType === 67 || b.nodeType === 69) && ((d = b.parent) === null || d === undefined ? undefined : d.nodeType) === 66 && ((c = b.parent.parent) === null || c === undefined ? undefined : c.nodeType) === 64 && ((u = b.parent.parent.parent) === null || u === undefined ? undefined : u.nodeType) === 63) {
          const e = this.evaluator.getType(b.parent.parent.parent.d.expr);
          if (e && I.containsLiteralType(e)) {
            this._addLiteralValuesForTargetType(e, n, a, r, s);
            return true;
          }
        }
        if (e.nodeType === 49) {
          const t = P.convertPositionToOffset(this.position, this.parseResults.tokenizerOutput.lines);
          const i = e.parent.start < t && t < F.TextRange.getEnd(e);
          this._addCallArgumentCompletions(e, n, a, r, i, s);
          return true;
        }
        return false;
      }
      _tryAddTypedDictKeys(e, t, n, a, r, s) {
        let i = [];
        I.doForEachSubtype(e, e => {
          if (C.isClassInstance(e) && C.ClassType.isTypedDictClass(e)) {
            i.push(e);
          }
        });
        if (i.length === 0) {
          return false;
        }
        i = this._tryNarrowTypedDicts(i, t);
        const o = this._getQuoteInfo(n, a);
        const l = new Set(t);
        i.forEach(e => {
          v.getTypedDictMembersForClass(this.evaluator, e, true).knownItems.forEach((e, t) => {
            if (!l.has(t) && !s.has(t)) {
              l.add(t);
              this._addStringLiteralToCompletions(t, o, r, s);
            }
          });
        });
        return true;
      }
      _tryAddTypedDictKeysFromDictionary(e, t, n, a, r, s) {
        var i;
        const o = this.evaluator.getExpectedType(e);
        if (!o) {
          return false;
        }
        if (m.getNodeDepth(o.node) < m.getNodeDepth(e)) {
          return false;
        }
        const l = this._getDictExpressionStringKeys(e, t ? new Set([(i = t.parent) === null || i === undefined ? undefined : i.id]) : undefined);
        return this._tryAddTypedDictKeys(o.type, l, n, a, r, s);
      }
      _tryNarrowTypedDicts(e, t) {
        const n = e.flatMap(e => {
          const n = v.getTypedDictMembersForClass(this.evaluator, e, true);
          for (let e = 0; e < t.length; e++) {
            if (!n.knownItems.has(t[e])) {
              return [];
            }
          }
          return [e];
        });
        if (n.length === 0) {
          return e;
        } else {
          return n;
        }
      }
      _getQuoteInfo(e, t) {
        let n;
        let a = e;
        let r = this.parseResults.tokenizerOutput.predominantSingleQuoteCharacter;
        if (!this._stringLiteralContainer) {
          return {
            priorWord: e,
            priorText: t,
            filterText: a,
            stringValue: n,
            quoteCharacter: r
          };
        }
        if (t !== undefined) {
          const e = t.lastIndexOf('\'');
          const a = t.lastIndexOf('"');
          if (e > a) {
            n = t.substr(e + 1);
            r = '\'';
          } else {
            if (a > e) {
              n = t.substr(a + 1);
              r = '"';
            }
          }
        }
        if (this._stringLiteralContainer.flags & 64) {
          r = this._stringLiteralContainer.flags & 1 ? '"' : '\'';
        }
        if (n) {
          a = n;
        }
        return {
          priorWord: e,
          priorText: t,
          filterText: a,
          stringValue: n,
          quoteCharacter: r
        };
      }
      _tryAddTypedDictKeysFromIndexer(e, t, n, a, r) {
        if (!e) {
          return false;
        }
        const s = this.evaluator.getType(e.d.leftExpr);
        return !!s && this._tryAddTypedDictKeys(s, [], t, n, a, r);
      }
      _addStringLiteralToCompletions(e, t, n, a, r) {
        if (!N.isPatternInSymbol(t.filterText || '', e)) {
          return;
        }
        const s = `${t.quoteCharacter}${e}${t.quoteCharacter}`;
        if (a.has(s)) {
          return;
        }
        const o = i.CompletionItem.create(s);
        o.kind = i.CompletionItemKind.Constant;
        o.sortText = this._makeSortText(q.LiteralValue, s);
        let l = this.position.character;
        if (t.stringValue !== undefined) {
          l -= t.stringValue.length + 1;
        } else {
          if (t.priorWord) {
            l -= t.priorWord.length;
          }
        }
        let p = this.position.character;
        if (n !== undefined && n.startsWith(t.quoteCharacter)) {
          p++;
        }
        const d = {
          start: {
            line: this.position.line,
            character: l
          },
          end: {
            line: this.position.line,
            character: p
          }
        };
        o.textEdit = i.TextEdit.replace(d, s);
        o.detail = r;
        a.set(o);
      }
      _getImportFromCompletions(e, t, n) {
        var a;
        if (e.d.isWildcardImport) {
          return;
        }
        const r = o.getImportInfo(e.d.module);
        if (!r) {
          return;
        }
        const s = new W();
        const i = r.resolvedUris.length > 0 ? r.resolvedUris[r.resolvedUris.length - 1] : E.Uri.empty();
        const p = this.program.getParseResults(i);
        if (!p) {
          this._addImplicitImportsToCompletion(r, e, n, s);
          return s;
        }
        const d = (a = o.getScope(p.parserOutput.parseTree)) === null || a === undefined ? undefined : a.symbolTable;
        if (d) {
          this._addSymbolsForSymbolTable(d, (n, a) => n.getDeclarations().some(e => !l.isIntrinsicDeclaration(e)) && !e.d.imports.find(e => e.d.name.d.value === a && !F.TextRange.contains(e, t) && F.TextRange.getEnd(e) !== t), n, e, true, undefined, s);
          this._addImplicitImportsToCompletion(r, e, n, s);
          return s;
        } else {
          return s;
        }
      }
      _addImplicitImportsToCompletion(e, t, n, a) {
        e.implicitImports.forEach(e => {
          if (!t.d.imports.find(t => t.d.name.d.value === e.name)) {
            this.addNameToCompletions(e.name, i.CompletionItemKind.Module, n, a, {
              moduleUri: e.uri
            });
          }
        });
      }
      _findMatchingKeywords(e, t) {
        return e.filter(e => !t || N.isPatternInSymbol(t, e));
      }
      _addNamedParameters(e, t, n) {
        const a = new Set();
        e.signatures.forEach(e => {
          this._addNamedParametersToMap(e.type, a);
        });
        e.signatures.forEach(e => {
          var t;
          if (e.type.priv.boundToType) {
            Array.from(((t = e.type.priv.boundToType.shared.typedDictEntries) === null || t === undefined ? undefined : t.knownItems.keys()) || []).forEach(e => a.add(e));
          }
        });
        e.callNode.d.args.forEach(e => {
          if (e.d.name) {
            a.delete(e.d.name.d.value);
          }
        });
        a.forEach(e => {
          if (N.isPatternInSymbol(t, e)) {
            const t = e + '=';
            if (n.has(t)) {
              return;
            }
            const a = i.CompletionItem.create(t);
            a.kind = i.CompletionItemKind.Variable;
            const r = {
              uri: this.fileUri.toString(),
              position: this.position
            };
            a.data = x.toLSPAny(r);
            a.sortText = this._makeSortText(q.NamedParameter, e);
            a.filterText = e;
            n.set(a);
          }
        });
      }
      _addNamedParametersToMap(e, t) {
        u.getParamListDetails(e).params.forEach(e => {
          if (e.param.name && e.kind !== u.ParamKind.Positional && e.kind !== u.ParamKind.ExpandedArgs && !f.isPrivateOrProtectedName(e.param.name) && U.Tokenizer.isPythonIdentifier(e.param.name)) {
            t.add(e.param.name);
          }
        });
      }
      _addSymbols(e, t, n) {
        let a = e;
        while (a) {
          let r = g.getScopeForNode(a);
          if (r) {
            while (r) {
              this._addSymbolsForSymbolTable(r.symbolTable, () => true, t, e, false, undefined, n);
              r = r.parent;
            }
            if (a.nodeType === 10) {
              const r = this.evaluator.getTypeOfClass(a);
              if (r && C.isInstantiableClass(r.classType)) {
                r.classType.shared.mro.forEach((a, r) => {
                  if (C.isInstantiableClass(a)) {
                    this._addSymbolsForSymbolTable(C.ClassType.getSymbolTable(a), e => !!e.isClassMember() && e.getDeclarations().some(e => e.type === 1), t, e, false, undefined, n);
                  }
                });
              }
            }
            break;
          }
          a = a.parent;
        }
      }
      _addSymbolsForSymbolTable(e, t, n, a, r, s, i) {
        const o = m.isWithinAnnotationComment(a) || m.isWithinTypeAnnotation(a, false);
        e.forEach((e, l) => {
          var d;
          if ((!!T.isVisibleExternally(e) || !!e.getDeclarations().some(e => p.isDefinedInFile(e, this.fileUri))) && t(e, l) && !i.has(l)) {
            const t = !this._shouldShowAutoParensForClass(e, a);
            const p = ((d = a.parent) === null || d === undefined ? undefined : d.nodeType) === 16;
            this.addSymbol(l, e, n, i, {
              boundObjectOrClass: s,
              funcParensDisabled: r || o || t || p,
              extraCommitChars: !r && !!n
            });
          }
        });
      }
      _shouldShowAutoParensForClass(e, t) {
        var n;
        var a;
        if (e.getDeclarations().every(e => e.type !== 6)) {
          return true;
        }
        if (((n = t.parent) === null || n === undefined ? undefined : n.nodeType) === 1 && ((a = t.parent.parent) === null || a === undefined ? undefined : a.nodeType) !== 10) {
          return true;
        }
        const r = m.getTokenIndexAtLeft(this.parseResults.tokenizerOutput.tokens, t.start);
        const s = m.getTokenAtIndex(this.parseResults.tokenizerOutput.tokens, r);
        return s && s.type === 9 && s.operatorType === 2;
      }
      _getRecentListIndex(e, t) {
        return G._mostRecentCompletions.findIndex(n => n.label === e && n.autoImportText === t);
      }
      _makeSortText(e, t, n = '') {
        const a = this._getRecentListIndex(t, n);
        if (a >= 0) {
          if (e === q.AutoImport) {
            e = q.RecentAutoImport;
          } else {
            if (e === q.ImportModuleName) {
              e = q.RecentImportModuleName;
            } else {
              if (e === q.Keyword || e === q.NormalSymbol || e === q.PrivateSymbol || e === q.DunderSymbol) {
                e = q.RecentKeywordOrSymbol;
              }
            }
          }
        }
        return this._formatInteger(e, 2) + '.' + this._formatInteger(a, 4) + '.' + t;
      }
      _formatInteger(e, t) {
        const n = '0'.charCodeAt(0);
        let a = '';
        for (let r = 0; r < t; r++) {
          let t = Math.floor(e % 10);
          if (t < 0) {
            t = 9;
          }
          a = String.fromCharCode(t + n) + a;
          e = Math.floor(e / 10);
        }
        return a;
      }
      _convertDeclarationTypeToItemKind(e) {
        const t = this.evaluator.resolveAliasDeclaration(e, true);
        if (!t) {
          return i.CompletionItemKind.Variable;
        }
        switch (t.type) {
          case 0:
            if (t.intrinsicType === 'type[self]') {
              return i.CompletionItemKind.Class;
            } else {
              return i.CompletionItemKind.Variable;
            }
          case 2:
          case 4:
            return i.CompletionItemKind.Variable;
          case 3:
            return i.CompletionItemKind.TypeParameter;
          case 1:
            if (t.isConstant || t.isFinal) {
              return i.CompletionItemKind.Constant;
            } else {
              return i.CompletionItemKind.Variable;
            }
          case 5:
            if (this._isPossiblePropertyDeclaration(t)) {
              const e = this.evaluator.getTypeOfFunction(t.node);
              if (e && I.isMaybeDescriptorInstance(e.decoratedType, false)) {
                return i.CompletionItemKind.Property;
              }
            }
            if (t.isMethod) {
              return i.CompletionItemKind.Method;
            } else {
              return i.CompletionItemKind.Function;
            }
          case 6:
          case 7:
            return i.CompletionItemKind.Class;
          case 8:
            return i.CompletionItemKind.Module;
        }
      }
      _convertTypeToItemKind(e) {
        switch (e.category) {
          case 7:
            return i.CompletionItemKind.Module;
          case 6:
            return i.CompletionItemKind.Class;
          case 4:
          case 5:
            if (I.isMaybeDescriptorInstance(e, false)) {
              return i.CompletionItemKind.Property;
            } else {
              return i.CompletionItemKind.Function;
            }
          case 9:
            return i.CompletionItemKind.TypeParameter;
          default:
            return i.CompletionItemKind.Variable;
        }
      }
      _getImportModuleCompletions(e) {
        const t = {
          leadingDots: e.d.leadingDots,
          hasTrailingDot: e.d.hasTrailingDot || false,
          nameParts: e.d.nameParts.map(e => e.d.value),
          importedSymbols: new Set()
        };
        const n = this.importResolver.getCompletionSuggestions(this.fileUri, this.execEnv, t);
        const a = new W();
        if (!e.d.hasTrailingDot && e.parent && e.parent.nodeType === 25 && e.parent.d.missingImport) {
          const e = 'import';
          const t = i.CompletionItem.create(e);
          t.kind = i.CompletionItemKind.Keyword;
          t.sortText = this._makeSortText(q.Keyword, e);
          a.set(t);
        }
        n.forEach((e, t) => {
          this.addNameToCompletions(t, i.CompletionItemKind.Module, '', a, {
            sortText: this._makeSortText(q.ImportModuleName, t),
            moduleUri: e
          });
        });
        return a;
      }
      _isPossiblePropertyDeclaration(e) {
        return e.isMethod && e.node.d.decorators.length > 0;
      }
      _isEnumMember(e, t) {
        if (!e || !C.ClassType.isEnumClass(e)) {
          return false;
        }
        const n = d.transformTypeForEnumMember(this.evaluator, e, t);
        return n && C.isClassInstance(n) && C.ClassType.isSameGenericClass(n, C.TypeBase.isInstance(e) ? e : C.ClassType.cloneAsInstance(e)) && n.priv.literalValue instanceof C.EnumLiteral;
      }
    }
    exports.CompletionProvider = G;
    G._mostRecentCompletions = [];
    class W {
      constructor() {
        this._completions = new Map();
      }
      get size() {
        return this._completions.size;
      }
      set(e) {
        const t = this._completions.get(e.label);
        if (t) {
          if (Array.isArray(t)) {
            t.push(e);
          } else {
            this._completions.set(e.label, [t, e]);
          }
        } else {
          this._completions.set(e.label, e);
        }
      }
      get(e) {
        return this._completions.get(e);
      }
      has(e, t, n, a) {
        const r = this._completions.get(e);
        return !!r && (!t || t(r, n, a));
      }
      clear() {
        this._completions.clear();
      }
      delete(e) {
        return this._completions.delete(e);
      }
      toArray() {
        var e;
        const t = [];
        if ((e = this._completions) !== null && e !== undefined) {
          e.forEach(e => {
            if (Array.isArray(e)) {
              e.forEach(e => {
                t.push(e);
              });
            } else {
              t.push(e);
            }
          });
        }
        return t;
      }
      static matchKindAndImportText(e, t, n, a) {
        var r;
        if (Array.isArray(e)) {
          return !!e.find(e => {
            var r;
            return e.kind === n && ((r = t(e)) === null || r === undefined ? undefined : r.autoImportText) === a;
          });
        } else {
          return e.kind === n && ((r = t(e)) === null || r === undefined ? undefined : r.autoImportText) === a;
        }
      }
      static labelOnlyIgnoringAutoImports(e, t) {
        var n;
        if (Array.isArray(e)) {
          if (e.find(e => {
            var n;
            return !((n = t(e)) === null || n === undefined ? undefined : n.autoImportText);
          })) {
            return true;
          }
        } else {
          if (!((n = t(e)) === null || n === undefined ? undefined : n.autoImportText)) {
            return true;
          }
        }
        return false;
      }
    }
    exports.CompletionMap = W;
  },
  51868: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getTypeDetail = function (e, t, n, a, r, l) {
      if (!n) {
        if (i.isModule(t)) {
          return a;
        } else {
          return undefined;
        }
      }
      switch (n.type) {
        case 0:
        case 1:
        case 2:
        case 3:
          {
            let n = false;
            if (t && i.TypeBase.isInstantiable(t)) {
              const e = i.getTypeAliasInfo(t);
              if (e && e.shared.name === a) {
                n = true;
              }
            }
            if (t.category === 5 || t.category === 4) {
              return o.getToolTipForType(t, '', a, e, false, l);
            } else {
              return a + ': ' + e.printType(t, {
                expandTypeAlias: n
              });
            }
          }
        case 5:
          {
            const n = (r == null ? undefined : r.boundObjectOrClass) && (i.isFunction(t) || i.isOverloaded(t)) ? e.bindFunctionToClassOrObject(r.boundObjectOrClass, t) : t;
            if (!n) {
              return;
            }
            if (s.isProperty(n) && (r == null ? undefined : r.boundObjectOrClass) && i.isClassInstance(r.boundObjectOrClass)) {
              const t = e.getGetterTypeFromProperty(n, true) || i.UnknownType.create();
              return a + ': ' + e.printType(t) + ' (property)';
            }
            return o.getToolTipForType(n, '', a, e, false, l);
          }
        case 6:
        case 7:
          return `class ${a}()`;
        default:
          return a;
      }
    };
    exports.getCompletionItemDocumentation = function (e, t, n, s, i) {
      if (s === a.MarkupKind.Markdown) {
        let s = `\`\`\`python
${t}
\`\`\`
`;
        if (n) {
          s += '---\n';
          s += e.docStringService().convertDocStringToMarkdown(n, r.isBuiltInModule(i == null ? undefined : i.uri));
        }
        s = s.trimEnd();
        return {
          kind: a.MarkupKind.Markdown,
          value: s
        };
      }
      if (s === a.MarkupKind.PlainText) {
        let r = t + '\n';
        if (n) {
          r += '\n';
          r += e.docStringService().convertDocStringToPlainText(n);
        }
        r = r.trimEnd();
        return {
          kind: a.MarkupKind.PlainText,
          value: r
        };
      }
      return;
    };
    const a = require(38659);
    const r = require(30889);
    const s = require(92324);
    const i = require(21024);
    const o = require(39426);
  },
  65574: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeDefinitionProvider = exports.DefinitionProvider = exports.DefinitionFilter = undefined;
    exports.addDeclarationsToDefinitions = v;
    exports.filterDefinitions = b;
    const i = require(26687);
    const o = require(28445);
    const l = __importStar(require(41557));
    const p = require(3113);
    const d = require(92324);
    const c = require(21024);
    const u = require(91426);
    const m = require(58147);
    const y = require(34455);
    const g = require(56814);
    const h = require(71745);
    const f = require(88754);
    var T;
    function v(e, t, n, a) {
      if (n) {
        n.forEach(n => {
          var r;
          let s = e.resolveAliasDeclaration(n, true, {
            allowExternallyHiddenAccess: true
          });
          if (!s || s.uri.isEmpty()) {
            return;
          }
          if (s.type === 8 && (s.isUnresolved || o.isUnresolvedAliasDeclaration(s))) {
            return;
          }
          if (s.type === 8 && s.symbolName && s.submoduleFallback && !s.submoduleFallback.uri.isEmpty()) {
            s = s.submoduleFallback;
          }
          I(a, {
            uri: s.uri,
            range: s.range
          });
          if (o.isFunctionDeclaration(s)) {
            const t = (r = e.getTypeForDeclaration(s)) === null || r === undefined ? undefined : r.type;
            if (t && c.isOverloaded(t)) {
              for (const e of c.OverloadedType.getOverloads(t).map(e => e.shared.declaration).filter(y.isDefined)) {
                I(a, {
                  uri: e.uri,
                  range: e.range
                });
              }
            }
          }
          if (!p.isStubFile(s.uri)) {
            return;
          }
          if (s.type === 8) {
            t.findModules(s.uri).map(e => {
              var t;
              if ((t = i.getFileInfo(e)) === null || t === undefined) {
                return undefined;
              } else {
                return t.fileUri;
              }
            }).filter(y.isDefined).forEach(e => I(a, {
              uri: e,
              range: {
                start: {
                  line: 0,
                  character: 0
                },
                end: {
                  line: 0,
                  character: 0
                }
              }
            }));
            return;
          }
          const l = t.findDeclarations(s);
          for (const e of l) {
            if (e && !e.uri.isEmpty()) {
              I(a, {
                uri: e.uri,
                range: e.range
              });
            }
          }
        });
      }
    }
    function b(e, t) {
      if (e === T.All) {
        return t;
      }
      const n = e === T.PreferStubs;
      const a = e => n === p.isStubFile(e.uri);
      if (t.find(a)) {
        return t.filter(a);
      } else {
        return t;
      }
    }
    (function (e) {
      e.All = 'all';
      e.PreferSource = 'preferSource';
      e.PreferStubs = 'preferStubs';
    })(T || (exports.DefinitionFilter = T = {}));
    class _ {
      constructor(e, t, n, a, r, s, i) {
        this.sourceMapper = e;
        this.evaluator = t;
        this._serviceProvider = n;
        this.node = a;
        this.offset = r;
        this._filter = s;
        this.token = i;
      }
      getDefinitionsForNode(e, t) {
        var n;
        u.throwIfCancellationRequested(this.token);
        const a = [];
        const r = (n = this._serviceProvider) === null || n === undefined ? undefined : n.tryGet(h.ServiceKeys.symbolDefinitionProvider);
        if (r) {
          r.forEach(n => {
            const r = n.tryGetDeclarations(e, t, this.token);
            this.resolveDeclarations(r, a);
          });
        }
        if (a.length === 0) {
          if (e.nodeType === 38) {
            const t = this.evaluator.getDeclInfoForNameNode(e);
            if (t) {
              this.resolveDeclarations(t.decls, a);
              this.addSynthesizedTypes(t.synthesizedTypes, a);
            }
          } else {
            if (e.nodeType === 49) {
              const t = this.evaluator.getDeclInfoForStringNode(e);
              if (t) {
                this.resolveDeclarations(t.decls, a);
                this.addSynthesizedTypes(t.synthesizedTypes, a);
              }
            }
          }
        }
        if (a.length !== 0) {
          return b(this._filter, a);
        }
      }
      resolveDeclarations(e, t) {
        v(this.evaluator, this.sourceMapper, e, t);
      }
      addSynthesizedTypes(e, t) {
        for (const n of e) {
          if (!n.node) {
            continue;
          }
          const e = i.getFileInfo(n.node);
          const a = g.convertOffsetsToRange(n.node.start, n.node.start + n.node.length, e.lines);
          t.push({
            uri: e.fileUri,
            range: a
          });
        }
      }
    }
    exports.DefinitionProvider = class extends _ {
      constructor(e, t, n, a, r) {
        const s = e.getSourceMapper(t, r);
        const i = e.getParseResults(t);
        const {
          node: o,
          offset: l
        } = C(i, n);
        super(s, e.evaluator, e.serviceProvider, o, l, a, r);
      }
      static getDefinitionsForNode(e, t, n, a, r) {
        return new _(e, t, undefined, n, a, T.All, r).getDefinitionsForNode(n, a);
      }
      getDefinitions() {
        if (this.node !== undefined) {
          return this.getDefinitionsForNode(this.node, this.offset);
        }
      }
    };
    function C(e, t) {
      if (!e) {
        return {
          node: undefined,
          offset: 0
        };
      }
      const n = g.convertPositionToOffset(t, e.tokenizerOutput.lines);
      if (n === undefined) {
        return {
          node: undefined,
          offset: 0
        };
      } else {
        return {
          node: l.findNodeByOffset(e.parserOutput.parseTree, n),
          offset: n
        };
      }
    }
    function I(e, t) {
      for (const n of e) {
        if (n.uri.equals(t.uri) && f.rangesAreEqual(n.range, t.range)) {
          return;
        }
      }
      e.push(t);
    }
    exports.TypeDefinitionProvider = class extends _ {
      constructor(e, t, n, a) {
        const r = e.getSourceMapper(t, a, false, true);
        const s = e.getParseResults(t);
        const {
          node: i,
          offset: o
        } = C(s, n);
        super(r, e.evaluator, e.serviceProvider, i, o, T.All, a);
        this._fileUri = t;
      }
      getDefinitions() {
        var e;
        var t;
        var n;
        u.throwIfCancellationRequested(this.token);
        if (this.node === undefined) {
          return;
        }
        const a = [];
        if (this.node.nodeType === 38) {
          const n = this.evaluator.getType(this.node);
          if (n) {
            let r = [];
            d.doForEachSubtype(n, e => {
              if ((e == null ? undefined : e.category) === 6) {
                m.appendArray(r, this.sourceMapper.findClassDeclarationsByType(this._fileUri, e));
              }
            });
            if (r.length === 0) {
              r = (t = (e = this.evaluator.getDeclInfoForNameNode(this.node)) === null || e === undefined ? undefined : e.decls) !== null && t !== undefined ? t : [];
            }
            this.resolveDeclarations(r, a);
          }
        } else {
          if (this.node.nodeType === 49) {
            const e = (n = this.evaluator.getDeclInfoForStringNode(this.node)) === null || n === undefined ? undefined : n.decls;
            this.resolveDeclarations(e, a);
          }
        }
        if (a.length !== 0) {
          return a;
        } else {
          return undefined;
        }
      }
    };
  },
  42634: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DocumentHighlightProvider = undefined;
    const i = require(56911);
    const o = __importStar(require(41557));
    const l = require(91426);
    const p = require(56507);
    const d = require(56814);
    const c = require(88754);
    const u = require(67032);
    exports.DocumentHighlightProvider = class {
      constructor(e, t, n, a) {
        this._program = e;
        this._fileUri = t;
        this._position = n;
        this._token = a;
        this._parseResults = this._program.getParseResults(this._fileUri);
      }
      getDocumentHighlight() {
        l.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return;
        }
        const e = d.convertPositionToOffset(this._position, this._parseResults.tokenizerOutput.lines);
        if (e === undefined) {
          return;
        }
        const t = o.findNodeByOffset(this._parseResults.parserOutput.parseTree, e);
        if (t === undefined) {
          return;
        }
        if (t.nodeType !== 38) {
          return;
        }
        const n = u.DocumentSymbolCollector.collectFromNode(this._program, t, this._token, this._parseResults.parserOutput.parseTree, {
          treatModuleInImportAndFromImportSame: true,
          useCase: p.ReferenceUseCase.References
        });
        const a = this._parseResults.tokenizerOutput.lines;
        return n.map(e => ({
          kind: e.node.nodeType === 38 && o.isWriteAccess(e.node) ? i.DocumentHighlightKind.Write : i.DocumentHighlightKind.Read,
          range: d.convertOffsetsToRange(e.range.start, c.TextRange.getEnd(e.range), a)
        }));
      }
    };
  },
  67032: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DocumentSymbolCollector = exports.AliasResolver = undefined;
    exports.getDeclarationsForNameNode = I;
    exports.addDeclarationIfUnique = k;
    const i = __importStar(require(26687));
    const o = require(28445);
    const l = require(83760);
    const p = require(41557);
    const d = require(88744);
    const c = __importStar(require(95952));
    const u = require(53266);
    const m = require(3433);
    const y = require(3113);
    const g = require(91426);
    const h = require(58147);
    const f = require(34455);
    const T = require(48281);
    const v = require(56507);
    const b = require(71745);
    class _ {
      constructor(e) {
        this._evaluator = e;
        this._caches = [undefined, undefined];
      }
      resolve(e, t) {
        const n = t ? 0 : 1;
        if (this._caches[n] && this._caches[n].original === e) {
          return this._caches[n].resolved;
        }
        const a = this._evaluator.resolveAliasDeclaration(e, t, {
          allowExternallyHiddenAccess: true,
          skipFileNeededCheck: true
        });
        this._caches[n] = {
          original: e,
          resolved: a
        };
        return a;
      }
    }
    exports.AliasResolver = _;
    class C extends d.ParseTreeWalker {
      constructor(e, t, n, a, r, s) {
        var i;
        var o;
        var l;
        var p;
        var d;
        super();
        this._program = e;
        this._startingNode = a;
        this._cancellationToken = r;
        this._results = [];
        this._dunderAllNameNodes = new Set();
        this._symbolNames = new Set();
        this._declarations = [];
        this._aliasResolver = new _(this._program.evaluator);
        t.forEach(e => this._symbolNames.add(e));
        this._declarations.push(...n);
        this._treatModuleInImportAndFromImportSame = (i = s == null ? undefined : s.treatModuleInImportAndFromImportSame) !== null && i !== undefined && i;
        this._skipUnreachableCode = (o = s == null ? undefined : s.skipUnreachableCode) === null || o === undefined || o;
        this._useCase = (l = s == null ? undefined : s.useCase) !== null && l !== undefined ? l : v.ReferenceUseCase.References;
        this._usageProviders = (p = s == null ? undefined : s.providers) !== null && p !== undefined ? p : ((d = this._program.serviceProvider.tryGet(b.ServiceKeys.symbolUsageProviderFactory)) !== null && d !== undefined ? d : []).map(e => e.tryCreateProvider(this._useCase, n, this._cancellationToken)).filter(f.isDefined);
        if ((s == null ? undefined : s.providers) === undefined) {
          this._usageProviders.forEach(e => {
            e.appendSymbolNamesTo(this._symbolNames);
            e.appendDeclarationsTo(this._declarations);
          });
        }
        this._setDunderAllNodes(this._startingNode);
      }
      static collectFromNode(e, t, n, a, r) {
        const s = this.getDeclarationsForNode(e, t, true, n);
        if (!(a = a ?? p.getModuleNode(t))) {
          return [];
        }
        return new C(e, [t.d.value], s, a, n, r).collect();
      }
      static getDeclarationsForNode(e, t, n, a) {
        g.throwIfCancellationRequested(a);
        const r = e.evaluator;
        if (!r) {
          return [];
        }
        const s = I(r, t, false);
        const l = i.getFileInfo(t);
        const p = l.fileUri;
        const d = [];
        const c = e.getSourceMapper(p, a);
        s.forEach(e => {
          const t = r.resolveAliasDeclaration(e, n);
          if (t && (k(d, t), c && y.isStubFile(t.uri))) {
            const e = c.findDeclarations(t);
            for (const t of e) {
              if (t && !t.uri.isEmpty()) {
                k(d, t);
              }
            }
          }
        });
        const h = e.getSourceFileInfo(p);
        if (h && h.sourceFile.getIPythonMode() === u.IPythonMode.CellDocs) {
          let n = l.builtinsScope;
          while (n && n.type === 4) {
            f(n == null ? undefined : n.lookUpSymbol(t.d.value), d);
            n = n == null ? undefined : n.parent;
          }
          m.collectImportedByCells(e, h).forEach(n => {
            var a;
            const r = (a = e.getParseResults(n.sourceFile.getUri())) === null || a === undefined ? undefined : a.parserOutput.parseTree;
            if (r) {
              const e = i.getScope(r);
              f(e == null ? undefined : e.lookUpSymbol(t.d.value), d);
            }
          });
        }
        return d;
        function f(e, t) {
          if (e != null) {
            e.getDeclarations().filter(e => !o.isAliasDeclaration(e)).forEach(e => {
              const a = r.resolveAliasDeclaration(e, n);
              if (a) {
                k(t, a);
              }
            });
          }
        }
      }
      collect() {
        this.walk(this._startingNode);
        return this._results;
      }
      walk(e) {
        if (!this._skipUnreachableCode || !i.isCodeUnreachable(e)) {
          super.walk(e);
        }
      }
      visitName(e) {
        g.throwIfCancellationRequested(this._cancellationToken);
        if (!this._symbolNames.has(e.d.value)) {
          return false;
        }
        if (this._declarations.length > 0) {
          const t = I(this._evaluator, e, this._skipUnreachableCode);
          if (t && t.length > 0 && this._resultsContainsDeclaration(e, t)) {
            this._addResult(e);
          }
        } else {
          this._addResult(e);
        }
        return false;
      }
      visitStringList(e) {
        if (this._declarations.some(t => {
          var n;
          return ((n = t.node) === null || n === undefined ? undefined : n.id) === e.id;
        })) {
          const t = e.d.strings.find(e => this._symbolNames.has(e.d.value));
          if (t && t.nodeType === 49) {
            this._addResult(t);
          }
        }
        return super.visitStringList(e);
      }
      visitString(e) {
        g.throwIfCancellationRequested(this._cancellationToken);
        if (this._dunderAllNameNodes.has(e)) {
          this._addResult(e);
        }
        return false;
      }
      get _evaluator() {
        return this._program.evaluator;
      }
      _addResult(e) {
        const t = e.nodeType === 38 ? e.d.token : p.getStringNodeValueRange(e);
        this._results.push({
          node: e,
          range: t
        });
      }
      _isDeclarationAllowed(e) {
        return this._declarations.some(t => l.areDeclarationsSame(t, e, this._treatModuleInImportAndFromImportSame, true));
      }
      _resultsContainsDeclaration(e, t) {
        const n = [...t];
        this._usageProviders.forEach(a => a.appendDeclarationsAt(e, t, n));
        return n.some(e => {
          const t = this._aliasResolver.resolve(e, false);
          if (!t) {
            return false;
          }
          if (this._isDeclarationAllowed(t)) {
            return true;
          }
          const n = this._getResolveAliasDeclaration(t);
          return !!n && n !== t && this._isDeclarationAllowed(n);
        });
      }
      _getResolveAliasDeclaration(e) {
        if (n(e)) {
          return l.getDeclarationsWithUsesLocalNameRemoved([e])[0];
        }
        const t = this._aliasResolver.resolve(e, true);
        if (n(t)) {
          return l.getDeclarationsWithUsesLocalNameRemoved([t])[0];
        } else {
          return t;
        }
        function n(e) {
          return !!e && e.type === 8 && e.node && e.usesLocalName && e.node.nodeType === 24;
        }
      }
      _setDunderAllNodes(e) {
        if (e.nodeType !== 36) {
          return;
        }
        const t = i.getDunderAllInfo(e);
        if (!t) {
          return;
        }
        const n = c.getScopeForNode(e);
        if (n) {
          t.stringNodes.forEach(e => {
            if (!this._symbolNames.has(e.d.value)) {
              return;
            }
            const t = n.lookUpSymbolRecursive(e.d.value);
            if (t && this._resultsContainsDeclaration(e, t.symbol.getDeclarations())) {
              this._dunderAllNameNodes.add(e);
            }
          });
        }
      }
    }
    function I(e, t, n = true) {
      var a;
      if (((a = t.parent) === null || a === undefined ? undefined : a.nodeType) !== 37) {
        return function (e, t, n = true) {
          var a;
          var r;
          var s;
          var i;
          T.assert(((a = t.parent) === null || a === undefined ? undefined : a.nodeType) !== 37);
          let p = ((r = e.getDeclInfoForNameNode(t, n)) === null || r === undefined ? undefined : r.decls) || [];
          if (((s = t.parent) === null || s === undefined ? undefined : s.nodeType) === 26) {
            p = p.filter(e => e.node === t.parent);
          }
          if (p.length === 0) {
            const n = e.getType(t);
            if ((n == null ? undefined : n.category) === 7) {
              return [l.synthesizeAliasDeclaration(n.priv.fileUri)];
            }
          }
          for (const t of p.filter(e => o.isAliasDeclaration(e) && !e.loadSymbolsFromPath)) {
            const a = t.node;
            if (a.nodeType !== 26) {
              h.appendArray(p, ((i = e.getDeclInfoForNameNode(a.d.module.d.nameParts[0], n)) === null || i === undefined ? undefined : i.decls) || []);
            }
          }
          return p;
        }(e, t, n);
      } else {
        return function (e, t) {
          var n;
          var a;
          var r;
          var s;
          var i;
          var p;
          var d;
          T.assert(((n = t.parent) === null || n === undefined ? undefined : n.nodeType) === 37);
          const u = t.parent;
          if (((a = u.parent) === null || a === undefined ? undefined : a.nodeType) === 24 || ((r = u.parent) === null || r === undefined ? undefined : r.nodeType) === 25) {
            const n = u.d.nameParts.findIndex(e => e === t);
            if (n === 0) {
              const n = [];
              h.appendArray(n, ((i = (s = e.getDeclInfoForNameNode(u.d.nameParts[0])) === null || s === undefined ? undefined : s.decls) === null || i === undefined ? undefined : i.filter(e => o.isAliasDeclaration(e))) || []);
              if (n.length === 0 || u.parent.nodeType !== 24) {
                return n;
              }
              const a = u.d.nameParts.length === 1 && u.parent.nodeType === 24 && !!u.parent.d.alias;
              const r = a ? u.parent.d.alias.d.value : u.d.nameParts[0].d.value;
              const d = (p = c.getScopeForNode(t)) === null || p === undefined ? undefined : p.lookUpSymbolRecursive(r);
              if (d && u.d.nameParts.length === 1) {
                let e = [];
                h.appendArray(e, d.symbol.getDeclarations().filter(e => o.isAliasDeclaration(e)));
                if (e.length > 1) {
                  e = e.filter(e => e.firstNamePart !== undefined ? e.firstNamePart === u.d.nameParts[0].d.value : e.node === u.parent);
                }
                if (a) {
                  e = l.getDeclarationsWithUsesLocalNameRemoved(e);
                }
                h.appendArray(n, e);
              }
              return n;
            }
            return n > 0 && ((d = e.getDeclInfoForNameNode(u.d.nameParts[n])) === null || d === undefined ? undefined : d.decls) || [];
          }
          return [];
        }(e, t);
      }
    }
    function k(e, t) {
      for (const n of e) {
        if (l.areDeclarationsSame(n, t, false, true)) {
          return;
        }
      }
      e.push(t);
    }
    exports.DocumentSymbolCollector = C;
  },
  86846: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DocumentSymbolProvider = undefined;
    exports.convertToFlatSymbols = l;
    const a = require(56911);
    const r = require(26687);
    const s = require(91426);
    const i = require(5884);
    const o = require(76135);
    function l(e, t, n) {
      const a = [];
      for (const r of n) {
        p(e.fileSystem, a, t, r);
      }
      return a;
    }
    function p(e, t, n, r, s) {
      const o = {
        name: r.name,
        kind: r.kind,
        location: a.Location.create(i.convertUriToLspUriString(e, n), r.range)
      };
      if (r.tags) {
        o.tags = r.tags;
      }
      if (s) {
        o.containerName = s.name;
      }
      t.push(o);
      if (r.children) {
        for (const a of r.children) {
          p(e, t, n, a, r);
        }
      }
    }
    exports.DocumentSymbolProvider = class {
      constructor(e, t, n, a, r) {
        this.program = e;
        this.uri = t;
        this._supportHierarchicalDocumentSymbol = n;
        this._indexOptions = a;
        this._token = r;
        this._parseResults = this.program.getParseResults(this.uri);
      }
      getSymbols() {
        if (!this._parseResults) {
          return [];
        }
        const e = this.getHierarchicalSymbols();
        if (this._supportHierarchicalDocumentSymbol) {
          return e;
        } else {
          return l(this.program, this.uri, e);
        }
      }
      getHierarchicalSymbols() {
        const e = [];
        const t = this.program.getParseResults(this.uri);
        if (!t) {
          return e;
        }
        const n = r.getFileInfo(t.parserOutput.parseTree);
        if (!n) {
          return e;
        }
        const a = o.SymbolIndexer.indexSymbols(n, t, this._indexOptions, this._token);
        this.appendDocumentSymbolsRecursive(a, e);
        return e;
      }
      appendDocumentSymbolsRecursive(e, t) {
        s.throwIfCancellationRequested(this._token);
        if (e) {
          for (const n of e) {
            if (n.alias) {
              continue;
            }
            if (!n.name) {
              continue;
            }
            const e = [];
            this.appendDocumentSymbolsRecursive(n.children, e);
            const a = {
              name: n.name,
              kind: n.kind,
              range: n.range,
              selectionRange: n.selectionRange,
              children: e
            };
            t.push(a);
          }
        }
      }
    };
  },
  55275: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DynamicFeatures = exports.DynamicFeature = undefined;
    exports.DynamicFeature = class {
      constructor(e) {
        this.name = e;
      }
      register() {
        this.registerFeature().then(e => {
          this.dispose();
          this._lastRegistration = e;
        });
      }
      update(e) {}
      dispose() {
        var e;
        if ((e = this._lastRegistration) !== null && e !== undefined) {
          e.dispose();
        }
        this._lastRegistration = undefined;
      }
    };
    exports.DynamicFeatures = class {
      constructor() {
        this._map = new Map();
      }
      add(e) {
        const t = this._map.get(e.name);
        if (t) {
          t.dispose();
        }
        this._map.set(e.name, e);
      }
      update(e) {
        for (const t of this._map.values()) {
          t.update(e);
        }
      }
      register() {
        for (const e of this._map.values()) {
          e.register();
        }
      }
      unregister() {
        for (const e of this._map.values()) {
          e.dispose();
        }
        this._map.clear();
      }
    };
  },
  86295: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FileWatcherDynamicFeature = undefined;
    const a = require(56911);
    const r = require(5884);
    const s = require(55275);
    const i = require(34455);
    const o = require(4883);
    class l extends s.DynamicFeature {
      constructor(e, t, n, a) {
        super('file watcher');
        this._connection = e;
        this._hasWatchFileRelativePathCapability = t;
        this._fs = n;
        this._workspaceFactory = a;
      }
      registerFeature() {
        const e = a.WatchKind.Create | a.WatchKind.Change | a.WatchKind.Delete;
        const t = [{
          globPattern: `**/${o.configFileName}`,
          kind: e
        }, {
          globPattern: '**',
          kind: e
        }];
        if (this._hasWatchFileRelativePathCapability) {
          const n = this._workspaceFactory.getNonDefaultWorkspaces().map(e => [...e.searchPathsToWatch, ...e.service.getConfigOptions().getExecutionEnvironments().map(e => e.extraPaths).flat()]);
          r.deduplicateFolders(n, this._workspaceFactory.getNonDefaultWorkspaces().map(e => e.rootUri).filter(i.isDefined)).forEach(n => {
            const a = r.isFile(this._fs, n, true) ? {
              baseUri: n.getDirectory().toString(),
              pattern: n.fileName
            } : {
              baseUri: n.toString(),
              pattern: '**'
            };
            t.push({
              globPattern: a,
              kind: e
            });
          });
        }
        return this._connection.client.register(a.DidChangeWatchedFilesNotification.type, {
          watchers: t
        });
      }
    }
    exports.FileWatcherDynamicFeature = l;
  },
  79943: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.HoverProvider = undefined;
    exports.convertHoverResults = f;
    exports.addParameterResultsPart = T;
    exports.addDocumentationResultsPart = v;
    exports.getVariableTypeText = b;
    const i = require(56911);
    const o = require(28445);
    const l = __importStar(require(41557));
    const p = require(30889);
    const d = require(92324);
    const c = require(21024);
    const u = require(91426);
    const m = require(48281);
    const y = require(56814);
    const g = require(88754);
    const h = require(39426);
    function f(e, t) {
      if (!e) {
        return null;
      }
      const n = e.parts.map(e => {
        if (e.python) {
          if (t === i.MarkupKind.Markdown) {
            return `\`\`\`python
${e.text}
\`\`\`
`;
          }
          if (t === i.MarkupKind.PlainText) {
            return e.text + '\n\n';
          }
          m.fail(`Unsupported markup type: ${t}`);
        }
        return e.text;
      }).join('').trimEnd();
      return {
        contents: {
          kind: t,
          value: n
        },
        range: e.range
      };
    }
    function T(e, t, n, a, r) {
      var s;
      var i;
      let o;
      const p = l.getEnclosingFunction((n == null ? undefined : n.node) || t);
      if (p) {
        o = l.getDocString((i = (s = p == null ? undefined : p.d.suite) === null || s === undefined ? undefined : s.d.statements) !== null && i !== undefined ? i : []);
        if (o) {
          o = e.docStringService().extractParameterDocumentation(o, t.d.value, a);
        }
      }
      if (o) {
        r.push({
          python: false,
          text: o
        });
      }
    }
    function v(e, t, n, a, r) {
      if (t) {
        if (n === i.MarkupKind.Markdown) {
          const n = e.docStringService().convertDocStringToMarkdown(t, p.isBuiltInModule(r == null ? undefined : r.uri));
          if (a.length > 0 && n.length > 0) {
            a.push({
              text: '---\n'
            });
          }
          a.push({
            text: n,
            python: false
          });
          return;
        }
        if (n !== i.MarkupKind.PlainText) {
          m.fail(`Unsupported markup type: ${n}`);
        } else {
          a.push({
            text: e.docStringService().convertDocStringToPlainText(t),
            python: false
          });
        }
      }
    }
    function b(e, t, n, a, r, s) {
      var i;
      let o;
      let l = 'variable';
      if (t) {
        l = t.isConstant || e.isFinalVariableDeclaration(t) ? 'constant' : 'variable';
      }
      if (((i = a.props) === null || i === undefined ? undefined : i.typeAliasInfo) && r.nodeType === 38) {
        const t = c.getTypeAliasInfo(a);
        if ((t == null ? undefined : t.shared.name) === r.d.value) {
          if (!c.isTypeVar(a)) {
            return `(type) ${n} = ${e.printType(d.convertToInstance(h.getTypeForToolTip(e, r)), {
              expandTypeAlias: true
            })}`;
          }
          l = c.isParamSpec(a) ? 'param spec' : 'type variable';
          o = a.shared.name;
        }
      }
      if (a.category === 4 || a.category === 5) {
        return h.getToolTipForType(a, l, n, e, false, s);
      }
      return `(${l}) ${o ?? n + ': ' + e.printType(h.getTypeForToolTip(e, r))}`;
    }
    class _ {
      constructor(e, t, n, a, r) {
        this._program = e;
        this._fileUri = t;
        this._position = n;
        this._format = a;
        this._token = r;
        this._parseResults = this._program.getParseResults(this._fileUri);
        this._sourceMapper = this._program.getSourceMapper(this._fileUri, this._token, true);
      }
      getHover() {
        return f(this._getHoverResult(), this._format);
      }
      static getPrimaryDeclaration(e) {
        const t = e[0];
        if (t.type === 8 && e.length > 1 || t.type === 1 && e.length > 1 && t.isDefinedBySlots) {
          return e[1];
        } else {
          return t;
        }
      }
      get _evaluator() {
        return this._program.evaluator;
      }
      get _functionSignatureDisplay() {
        return this._program.configOptions.functionSignatureDisplay;
      }
      _getHoverResult() {
        var e;
        var t;
        u.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const n = y.convertPositionToOffset(this._position, this._parseResults.tokenizerOutput.lines);
        if (n === undefined) {
          return null;
        }
        let a = l.findNodeByOffset(this._parseResults.parserOutput.parseTree, n);
        if (a === undefined) {
          return null;
        }
        const r = {
          parts: [],
          range: {
            start: y.convertOffsetToPosition(a.start, this._parseResults.tokenizerOutput.lines),
            end: y.convertOffsetToPosition(g.TextRange.getEnd(a), this._parseResults.tokenizerOutput.lines)
          }
        };
        if (a.nodeType === 38) {
          if (((e = a.parent) === null || e === undefined ? undefined : e.nodeType) === 1 && a.parent.d.isNameSameAsValue && a.parent.d.name === a && a.parent.d.valueExpr.nodeType === 38) {
            a = a.parent.d.valueExpr;
          }
          const t = this._evaluator.getDeclInfoForNameNode(a);
          const n = t == null ? undefined : t.decls;
          if (n && n.length > 0) {
            const e = _.getPrimaryDeclaration(n);
            this._addResultsForDeclaration(r.parts, e, a);
          } else {
            if (t && t.synthesizedTypes.length > 0) {
              const e = a;
              if (t != null) {
                t.synthesizedTypes.forEach(t => {
                  this._addResultsForSynthesizedType(r.parts, t, e);
                });
              }
              this._addDocumentationPart(r.parts, a, undefined);
            } else {
              if ((!a.parent || a.parent.nodeType !== 37) && r.parts.length === 0) {
                const e = this._getType(a);
                let t;
                if (c.isModule(e)) {
                  t = `(module) ${a.d.value}`;
                } else {
                  let n = 'function';
                  let r = false;
                  if (d.isMaybeDescriptorInstance(e, false)) {
                    r = true;
                    n = 'property';
                  }
                  t = h.getToolTipForType(e, n, a.d.value, this._evaluator, r, this._functionSignatureDisplay);
                }
                this._addResultsPart(r.parts, t, true);
                this._addDocumentationPart(r.parts, a, undefined);
              }
            }
          }
        } else {
          if (a.nodeType === 49) {
            const e = (t = this._evaluator.getExpectedType(a)) === null || t === undefined ? undefined : t.type;
            if (e !== undefined) {
              this._tryAddPartsForTypedDictKey(a, e, r.parts);
            }
          }
        }
        if (r.parts.length > 0) {
          return r;
        } else {
          return null;
        }
      }
      _addResultsForDeclaration(e, t, n) {
        var a;
        var r;
        var s;
        const i = t.type === 8 ? this._evaluator.resolveAliasDeclaration(t, true) : t;
        if (!i || i.type === 8 && o.isUnresolvedAliasDeclaration(i)) {
          this._addResultsPart(e, `(import) ${n.d.value}${this._getTypeText(n)}`, true);
        } else {
          switch (i.type) {
            case 0:
              this._addResultsPart(e, n.d.value + this._getTypeText(n), true);
              this._addDocumentationPart(e, n, i);
              break;
            case 1:
              {
                let r = n;
                if (t.node.nodeType === 24 || t.node.nodeType === 26) {
                  if (t.node.d.alias && n !== t.node.d.alias && i.node.nodeType === 38) {
                    r = i.node;
                  }
                } else {
                  if (((a = n.parent) === null || a === undefined ? undefined : a.nodeType) === 1 && n.parent.d.name === n && t.node.nodeType === 38) {
                    r = t.node;
                  }
                }
                const s = this._getType(r);
                const o = b(this._evaluator, i, n.d.value, s, r, this._functionSignatureDisplay);
                this._addResultsPart(e, o, true);
                this._addDocumentationPart(e, n, i);
                break;
              }
            case 2:
              this._addResultsPart(e, `(parameter) ${n.d.value}${this._getTypeText(n)}`, true);
              T(this._program.serviceProvider, n, i, this._format, e);
              this._addDocumentationPart(e, n, i);
              break;
            case 3:
              {
                const t = l.getParentNodeOfType(n, 76);
                const a = (r = t == null ? undefined : t.parent) === null || r === undefined ? undefined : r.nodeType;
                const s = a === 10 || a === 77;
                this._addResultsPart(e, `(type parameter) ${n.d.value}${this._getTypeText(n, {
                  printTypeVarVariance: s
                })}`, true);
                this._addDocumentationPart(e, n, i);
                break;
              }
            case 6:
            case 7:
              {
                if (this._addInitOrNewMethodInsteadIfCallNode(n, e, i)) {
                  return;
                }
                const t = i.type === 6 ? i.node.d.name : n;
                this._addResultsPart(e, `(class) ${t.d.value}`, true);
                this._addDocumentationPart(e, n, i);
                break;
              }
            case 5:
              {
                let t = 'function';
                let a = false;
                if (i.isMethod) {
                  const e = (s = this._evaluator.getTypeForDeclaration(i)) === null || s === undefined ? undefined : s.type;
                  a = !!e && d.isMaybeDescriptorInstance(e, false);
                  t = a ? 'property' : 'method';
                }
                let r = this._getType(n);
                const o = this._getType(i.node.d.name);
                r = c.isAnyOrUnknown(r) ? o : r;
                const l = h.getToolTipForType(r, t, n.d.value, this._evaluator, a, this._functionSignatureDisplay);
                this._addResultsPart(e, l, true);
                this._addDocumentationPart(e, n, i);
                break;
              }
            case 8:
              this._addResultsPart(e, `(module) ${n.d.value}`, true);
              this._addDocumentationPart(e, n, i);
              break;
            case 4:
              {
                const t = d.convertToInstance(this._getType(n));
                const a = this._evaluator.printType(t, {
                  expandTypeAlias: true
                });
                this._addResultsPart(e, `(type) ${n.d.value} = ${a}`, true);
                this._addDocumentationPart(e, n, i);
                break;
              }
            default:
              m.assertNever(i);
          }
        }
      }
      _addResultsForSynthesizedType(e, t, n) {
        var a;
        let r;
        if (c.isModule(t.type)) {
          r = `(module) ${n.d.value}`;
        } else {
          const e = (a = t.node) !== null && a !== undefined ? a : n;
          const s = this._getType(e);
          r = b(this._evaluator, undefined, e.d.value, s, e, this._functionSignatureDisplay);
        }
        if (r) {
          this._addResultsPart(e, r, true);
        }
      }
      _tryAddPartsForTypedDictKey(e, t, n) {
        d.doForEachSubtype(t, t => {
          var a;
          var r;
          if (c.isClassInstance(t) && c.ClassType.isTypedDictClass(t)) {
            const s = (a = t.shared.typedDictEntries) === null || a === undefined ? undefined : a.knownItems.get(e.d.value);
            if (s) {
              if (n.length > 0) {
                n.push({
                  text: '\n\n---\n'
                });
              }
              const a = `(key) ${e.d.value}: ${this._evaluator.printType(s.valueType)}`;
              this._addResultsPart(n, a, true);
              const i = (r = c.ClassType.getSymbolTable(t).get(e.d.value)) === null || r === undefined ? undefined : r.getDeclarations();
              if (i !== undefined && (i == null ? undefined : i.length) !== 0) {
                const e = i[0];
                if (e.type === 1 && e.docString !== undefined) {
                  this._addDocumentationPartForType(n, t, e);
                }
              }
            }
          }
        });
      }
      _addInitOrNewMethodInsteadIfCallNode(e, t, n) {
        const a = h.getClassAndConstructorTypes(e, this._evaluator);
        if (!a) {
          return false;
        }
        if (a.methodType && (c.isFunction(a.methodType) || c.isOverloaded(a.methodType))) {
          this._addResultsPart(t, h.getConstructorTooltip(e.d.value, a.methodType, this._evaluator, this._functionSignatureDisplay), true);
          if (!this._addDocumentationPartForType(t, a.methodType, n)) {
            this._addDocumentationPartForType(t, a.classType, n);
          }
          return true;
        }
        return false;
      }
      _getType(e) {
        return h.getTypeForToolTip(this._evaluator, e);
      }
      _getTypeText(e, t) {
        const n = this._getType(e);
        return `: ${this._evaluator.printType(n, t)}`;
      }
      _addDocumentationPart(e, t, n) {
        const a = this._getType(t);
        this._addDocumentationPartForType(e, a, n, t.d.value);
      }
      _addDocumentationPartForType(e, t, n, a) {
        const r = h.getDocumentationPartsForTypeAndDecl(this._sourceMapper, t, n, this._evaluator, {
          name: a
        });
        v(this._program.serviceProvider, r, this._format, e, n);
        return !!r;
      }
      _addResultsPart(e, t, n = false) {
        e.push({
          python: n,
          text: t
        });
      }
    }
    exports.HoverProvider = _;
  },
  47091: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.canNavigateToFile = s;
    exports.convertDocumentRangesToLocation = function (e, t, n = i) {
      return t.map(t => n(e, t)).filter(e => !!e);
    };
    exports.convertDocumentRangeToLocation = i;
    const a = require(38659);
    const r = require(5884);
    function s(e, t) {
      return !e.isInZip(t);
    }
    function i(e, t) {
      if (s(e, t.uri)) {
        return a.Location.create(r.convertUriToLspUriString(e, t.uri), t.range);
      }
    }
  },
  26005: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ReferencesProvider = exports.FindReferencesTreeWalker = exports.ReferencesResult = undefined;
    const i = require(28445);
    const o = require(83760);
    const l = __importStar(require(41557));
    const p = require(3433);
    const d = require(4064);
    const c = require(21024);
    const u = require(91426);
    const m = require(58147);
    const y = require(34455);
    const g = require(48281);
    const h = require(56507);
    const f = require(56814);
    const T = require(71745);
    const v = require(88754);
    const b = require(67032);
    const _ = require(47091);
    class C {
      constructor(e, t, n, a, r, s, o) {
        this.requiresGlobalSearch = e;
        this.nodeAtOffset = t;
        this.symbolNames = n;
        this.declarations = a;
        this.useCase = r;
        this.providers = s;
        this._reporter = o;
        this._results = [];
        this.nonImportDeclarations = a.filter(e => {
          var t;
          if (!i.isAliasDeclaration(e)) {
            return true;
          }
          if (!e.usesLocalName || !e.node) {
            return false;
          }
          if (e.node.nodeType === 25) {
            return false;
          }
          const a = (t = e.node.d.alias) === null || t === undefined ? undefined : t.d.value;
          return !!n.some(e => e === a);
        });
      }
      get containsOnlyImportDecls() {
        return this.declarations.length > 0 && this.nonImportDeclarations.length === 0;
      }
      get locations() {
        return this._results.map(e => e.location);
      }
      get results() {
        return this._results;
      }
      addResults(...e) {
        if (e.length !== 0) {
          if (this._reporter) {
            this._reporter(e.map(e => e.location));
          }
          m.appendArray(this._results, e);
        }
      }
    }
    exports.ReferencesResult = C;
    class I {
      constructor(e, t, n, a, r, s = I.createDocumentRange) {
        this._program = e;
        this._fileUri = t;
        this._referencesResult = n;
        this._includeDeclaration = a;
        this._cancellationToken = r;
        this._createDocumentRange = s;
        this._parseResults = this._program.getParseResults(this._fileUri);
      }
      findReferences(e) {
        var t;
        if (e === undefined) {
          e = (t = this._parseResults) === null || t === undefined ? undefined : t.parserOutput.parseTree;
        }
        const n = [];
        if (!this._parseResults) {
          return n;
        }
        const a = new b.DocumentSymbolCollector(this._program, this._referencesResult.symbolNames, this._referencesResult.declarations, e, this._cancellationToken, {
          treatModuleInImportAndFromImportSame: true,
          skipUnreachableCode: false,
          useCase: this._referencesResult.useCase,
          providers: this._referencesResult.providers
        });
        for (const e of a.collect()) {
          if (this._includeDeclaration || e.node !== this._referencesResult.nodeAtOffset) {
            n.push({
              node: e.node,
              location: this._createDocumentRange(this._fileUri, e, this._parseResults),
              parentRange: e.node.parent ? {
                start: f.convertOffsetToPosition(e.node.parent.start, this._parseResults.tokenizerOutput.lines),
                end: f.convertOffsetToPosition(v.TextRange.getEnd(e.node.parent), this._parseResults.tokenizerOutput.lines)
              } : undefined
            });
          }
        }
        return n;
      }
      static createDocumentRange(e, t, n) {
        return {
          uri: e,
          range: {
            start: f.convertOffsetToPosition(t.range.start, n.tokenizerOutput.lines),
            end: f.convertOffsetToPosition(v.TextRange.getEnd(t.range), n.tokenizerOutput.lines)
          }
        };
      }
    }
    exports.FindReferencesTreeWalker = I;
    class k {
      constructor(e, t, n, a) {
        this._program = e;
        this._token = t;
        this._createDocumentRange = n;
        this._convertToLocation = a;
      }
      reportReferences(e, t, n, a) {
        const r = this._program.getSourceFileInfo(e);
        if (!r) {
          return;
        }
        if (!this._program.getParseResults(e)) {
          return;
        }
        const s = [];
        const i = a ? e => a.report(_.convertDocumentRangesToLocation(this._program.fileSystem, e, this._convertToLocation)) : e => m.appendArray(s, _.convertDocumentRangesToLocation(this._program.fileSystem, e, this._convertToLocation));
        const o = p.isUserCode(r);
        const l = k.getDeclarationForPosition(this._program, e, t, i, h.ReferenceUseCase.References, this._token);
        if (!l) {
          return;
        }
        if (!l.requiresGlobalSearch) {
          this.addReferencesToResult(r.sourceFile.getUri(), n, l);
        }
        for (const e of this._program.getSourceFileInfoList()) {
          u.throwIfCancellationRequested(this._token);
          if (e.isOpenByClient || !o || p.isUserCode(e)) {
            const t = e.sourceFile.getFileContent();
            if (!t || !!l.symbolNames.some(e => t.search(e) >= 0)) {
              this.addReferencesToResult(e.sourceFile.getUri(), n, l);
            }
            this._program.handleMemoryHighUsage();
          }
        }
        if (n) {
          for (const e of l.declarations) {
            u.throwIfCancellationRequested(this._token);
            if (l.locations.some(t => t.uri.equals(e.uri))) {
              continue;
            }
            const t = this._program.getSourceFileInfo(e.uri);
            if (!t) {
              continue;
            }
            const a = new C(l.requiresGlobalSearch, l.nodeAtOffset, l.symbolNames, l.declarations, l.useCase, l.providers);
            this.addReferencesToResult(t.sourceFile.getUri(), n, a);
            for (const t of a.results) {
              if (t.location.uri.equals(e.uri) && v.doesRangeContain(e.range, t.location.range)) {
                l.addResults(t);
              }
            }
          }
        }
        const d = new Set();
        const c = [];
        for (const e of s) {
          const t = `${e.uri.toString()}:${e.range.start.line}:${e.range.start.character}`;
          if (!d.has(t)) {
            d.add(t);
            c.push(e);
          }
        }
        return c;
      }
      addReferencesToResult(e, t, n) {
        if (!this._program.getParseResults(e)) {
          return;
        }
        const a = new I(this._program, e, n, t, this._token, this._createDocumentRange);
        n.addResults(...a.findReferences());
      }
      static getDeclarationForNode(e, t, n, a, r, s) {
        var i;
        u.throwIfCancellationRequested(s);
        const p = b.DocumentSymbolCollector.getDeclarationsForNode(e, n, false, s);
        if (p.length === 0) {
          return;
        }
        const m = function (e, t, n, a) {
          const r = e.lookUpSymbolRecursive(n, n.d.value, false);
          if (r && !s(r.symbol)) {
            return false;
          }
          return a.some(e => {
            var n;
            var a;
            if (!e.uri.equals(t)) {
              return true;
            }
            const r = l.getEvaluationScopeNode(e.node).node;
            return r.nodeType === 36 || r.nodeType === 10 || ((a = (n = e.node) === null || n === undefined ? undefined : n.parent) === null || a === undefined ? undefined : a.nodeType) === 35 && e.node === e.node.parent.d.member;
          });
          function s(e, t = 0) {
            return !(t > c.maxTypeRecursionCount) && (t++, !!d.isVisibleExternally(e) && e.getDeclarations().reduce((e, n) => {
              if (!e) {
                return false;
              }
              switch (n.type) {
                case 8:
                case 0:
                case 7:
                  return e;
                case 6:
                case 5:
                case 2:
                  return e && i(n.node.d.name, t);
                case 3:
                  return false;
                case 1:
                case 4:
                  return n.node.nodeType === 38 && e && i(n.node, t);
                default:
                  g.assertNever(n);
              }
            }, true));
          }
          function i(t, n) {
            const a = l.getEvaluationScopeNode(t).node;
            switch (a.nodeType) {
              case 10:
              case 31:
                {
                  const t = a.d.name;
                  const r = e.lookUpSymbolRecursive(t, t.d.value, false);
                  return !r || s(r.symbol, n);
                }
              case 33:
              case 11:
              case 76:
                return false;
              case 36:
                return true;
              default:
                g.assertNever(a);
            }
          }
        }(e.evaluator, t, n, p);
        const h = new Set(p.map(e => o.getNameFromDeclaration(e)).filter(e => !!e));
        h.add(n.d.value);
        const f = ((i = e.serviceProvider.tryGet(T.ServiceKeys.symbolUsageProviderFactory)) !== null && i !== undefined ? i : []).map(e => e.tryCreateProvider(r, p, s)).filter(y.isDefined);
        f.forEach(e => {
          e.appendSymbolNamesTo(h);
          e.appendDeclarationsTo(p);
        });
        return new C(m, n, Array.from(h.values()), p, r, f, a);
      }
      static getDeclarationForPosition(e, t, n, a, r, s) {
        u.throwIfCancellationRequested(s);
        const i = e.getParseResults(t);
        if (!i) {
          return;
        }
        const o = f.convertPositionToOffset(n, i.tokenizerOutput.lines);
        if (o === undefined) {
          return;
        }
        const p = l.findNodeByOffset(i.parserOutput.parseTree, o);
        if (p !== undefined && p.nodeType === 38) {
          return this.getDeclarationForNode(e, t, p, a, r, s);
        } else {
          return undefined;
        }
      }
    }
    exports.ReferencesProvider = k;
  },
  79725: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.RenameProvider = undefined;
    const a = require(3433);
    const r = require(91426);
    const s = require(48281);
    const i = require(56507);
    const o = require(56814);
    const l = require(74382);
    const p = require(26005);
    class d {
      constructor(e, t, n, a) {
        this._program = e;
        this._fileUri = t;
        this._position = n;
        this._token = a;
        this._parseResults = this._program.getParseResults(this._fileUri);
      }
      canRenameSymbol(e, t) {
        r.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const n = this._getReferenceResult();
        if (!n) {
          return null;
        }
        if (d.getRenameSymbolMode(this._program, this._fileUri, n, e, t) === 'none') {
          return null;
        } else {
          return o.convertTextRangeToRange(n.nodeAtOffset, this._parseResults.tokenizerOutput.lines);
        }
      }
      renameSymbol(e, t, n) {
        var i;
        r.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const o = this._getReferenceResult();
        if (!o) {
          return null;
        }
        const c = new p.ReferencesProvider(this._program, this._token);
        const u = d.getRenameSymbolMode(this._program, this._fileUri, o, t, n);
        switch (u) {
          case 'singleFileMode':
            c.addReferencesToResult(this._fileUri, true, o);
            break;
          case 'multiFileMode':
            for (const e of this._program.getSourceFileInfoList()) {
              if (a.isUserCode(e)) {
                const t = (i = e.sourceFile.getFileContent()) !== null && i !== undefined ? i : '';
                if (!o.symbolNames.some(e => t.search(e) >= 0)) {
                  continue;
                }
                c.addReferencesToResult(e.sourceFile.getUri(), true, o);
              }
              this._program.handleMemoryHighUsage();
            }
            break;
          case 'none':
            return null;
          default:
            s.assertNever(u);
        }
        const m = [];
        o.results.forEach(t => {
          var n;
          const a = t.node;
          let r = t.location.range;
          let s = e;
          if (a.nodeType === 38 && ((n = a.parent) === null || n === undefined ? undefined : n.nodeType) === 1 && a.parent.d.isNameSameAsValue && t.parentRange) {
            r = t.parentRange;
            s = a === a.parent.d.valueExpr ? `${a.d.value}=${e}` : `${e}=${a.d.value}`;
          }
          m.push({
            fileUri: t.location.uri,
            range: r,
            replacementText: s
          });
        });
        return l.convertToWorkspaceEdit(this._program.fileSystem, {
          edits: m,
          fileOperations: []
        });
      }
      static getRenameSymbolMode(e, t, n, r, s) {
        const i = e.getSourceFileInfo(t);
        const o = a.isUserCode(i);
        if (r || o && !n.requiresGlobalSearch || !o && i.isOpenByClient && n.declarations.every(t => e.getSourceFileInfo(t.uri) === i)) {
          return 'singleFileMode';
        } else {
          if (n.declarations.every(t => a.isUserCode(e.getSourceFileInfo(t.uri)))) {
            return 'multiFileMode';
          } else {
            return 'none';
          }
        }
      }
      _getReferenceResult() {
        const e = p.ReferencesProvider.getDeclarationForPosition(this._program, this._fileUri, this._position, undefined, i.ReferenceUseCase.Rename, this._token);
        if (e && !e.containsOnlyImportDecls && e.nonImportDeclarations.length !== 0) {
          return new p.ReferencesResult(e.requiresGlobalSearch, e.nodeAtOffset, e.symbolNames, e.nonImportDeclarations, e.useCase, e.providers);
        }
      }
    }
    exports.RenameProvider = d;
  },
  7380: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SignatureHelpProvider = undefined;
    const i = require(56911);
    const o = require(26687);
    const l = require(44321);
    const p = __importStar(require(41557));
    const d = require(41557);
    const c = require(30889);
    const u = require(91426);
    const m = require(56814);
    const y = require(49969);
    const g = require(39426);
    exports.SignatureHelpProvider = class {
      constructor(e, t, n, a, r, s, i, o, l) {
        this._program = e;
        this._fileUri = t;
        this._position = n;
        this._format = a;
        this._hasSignatureLabelOffsetCapability = r;
        this._hasActiveParameterCapability = s;
        this._context = i;
        this._docStringService = o;
        this._token = l;
        this._parseResults = this._program.getParseResults(this._fileUri);
        this._sourceMapper = this._program.getSourceMapper(this._fileUri, this._token, true);
      }
      getSignatureHelp() {
        return this._convert(this._getSignatureHelp());
      }
      get _evaluator() {
        return this._program.evaluator;
      }
      _getSignatureHelp() {
        var e;
        u.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return;
        }
        const t = m.convertPositionToOffset(this._position, this._parseResults.tokenizerOutput.lines);
        if (t === undefined) {
          return;
        }
        let n = p.findNodeByOffset(this._parseResults.parserOutput.parseTree, t);
        const a = n;
        const r = n ? p.getNodeDepth(n) : 0;
        let s = t - 1;
        while (s >= 0) {
          const e = this._parseResults.text.substr(s, 1);
          if (e === ',' || e === '(') {
            break;
          }
          const t = p.findNodeByOffset(this._parseResults.parserOutput.parseTree, s);
          if (t && t !== a) {
            if (p.getNodeDepth(t) > r) {
              n = t;
            }
            break;
          }
          s--;
        }
        if (n === undefined) {
          return;
        }
        const i = d.getCallNodeAndActiveParamIndex(n, t, this._parseResults.tokenizerOutput.tokens);
        if (!i) {
          return;
        }
        const o = this._evaluator.getCallSignatureInfo(i.callNode, i.activeIndex, i.activeOrFake);
        if (!o) {
          return;
        }
        return {
          signatures: o.signatures.map(e => this._makeSignature(o.callNode, e)),
          callHasParameters: !!((e = o.callNode.d.args) === null || e === undefined ? undefined : e.length)
        };
      }
      _convert(e) {
        var t;
        var n;
        var a;
        if (!e) {
          return;
        }
        const r = e.signatures.map(e => {
          let t = [];
          if (e.parameters) {
            t = e.parameters.map(e => {
              var t;
              return {
                label: this._hasSignatureLabelOffsetCapability ? [e.startOffset, e.endOffset] : e.text,
                documentation: {
                  kind: this._format,
                  value: (t = e.documentation) !== null && t !== undefined ? t : ''
                }
              };
            });
          }
          const n = i.SignatureInformation.create(e.label, undefined, ...t);
          if (e.documentation !== undefined) {
            n.documentation = e.documentation;
          }
          if (e.activeParameter !== undefined) {
            n.activeParameter = e.activeParameter;
          }
          return n;
        });
        const s = t => {
          var n;
          return t.activeParameter !== undefined || !e.callHasParameters && !((n = t.parameters) === null || n === undefined ? undefined : n.length);
        };
        let o = r.findIndex(s);
        if (o === -1) {
          o = undefined;
        }
        let l = o !== undefined ? r[o].activeParameter : undefined;
        if (((t = this._context) === null || t === undefined ? undefined : t.isRetrigger) && this._context.triggerKind !== i.SignatureHelpTriggerKind.Invoked) {
          const e = (n = this._context.activeSignatureHelp) === null || n === undefined ? undefined : n.activeSignature;
          if (e !== undefined && e < r.length) {
            const t = r[e];
            if (s(t)) {
              o = e;
              l = (a = t.activeParameter) !== null && a !== undefined ? a : undefined;
            }
          }
        }
        if (this._hasActiveParameterCapability || o === undefined) {
          l = Math.max(...r.map(e => {
            var t;
            var n;
            if ((n = (t = e.parameters) === null || t === undefined ? undefined : t.length) !== null && n !== undefined) {
              return n;
            } else {
              return 0;
            }
          }));
        }
        return {
          signatures: r,
          activeSignature: o,
          activeParameter: l
        };
      }
      _makeSignature(e, t) {
        var n;
        const a = t.type;
        const r = this._evaluator.printFunctionParts(a, 1024);
        const s = [];
        const p = (n = g.getFunctionDocStringFromType(a, this._sourceMapper, this._evaluator)) !== null && n !== undefined ? n : this._getDocStringFromCallNode(e);
        const d = o.getFileInfo(e);
        const u = l.getParamListDetails(a);
        let m;
        let h = '(';
        let f = true;
        const T = a.shared.parameters;
        r[0].forEach((e, n) => {
          let a = '';
          if (n < T.length) {
            a = T[n].name || '';
          } else {
            if (T.length > 0) {
              a = T[T.length - 1].name || '';
            }
          }
          if (!u.params.some(e => e.param.name === a && e.kind === l.ParamKind.Keyword) || !!y.Tokenizer.isPythonIdentifier(a)) {
            if (!f) {
              h += ', ';
            }
            f = false;
            s.push({
              startOffset: h.length,
              endOffset: h.length + e.length,
              text: e
            });
            if (a && t.activeParam && t.activeParam.name === a) {
              m = s.length - 1;
            }
            h += e;
          }
        });
        h += `) -> ${r[1]}`;
        if (t.activeParam && m === undefined) {
          m = T.indexOf(t.activeParam);
          if (m === -1) {
            m = undefined;
          }
        }
        if (m !== undefined) {
          const e = s[m];
          if (e) {
            e.documentation = this._docStringService.extractParameterDocumentation(p || '', T[m].name || '', this._format);
          }
        }
        const v = {
          label: h,
          parameters: s,
          activeParameter: m
        };
        if (p) {
          if (this._format === i.MarkupKind.Markdown) {
            v.documentation = {
              kind: i.MarkupKind.Markdown,
              value: this._docStringService.convertDocStringToMarkdown(p, c.isBuiltInModule(d == null ? undefined : d.fileUri))
            };
          } else {
            v.documentation = {
              kind: i.MarkupKind.PlainText,
              value: this._docStringService.convertDocStringToPlainText(p)
            };
          }
        }
        return v;
      }
      _getDocStringFromCallNode(e) {
        var t;
        var n;
        let a;
        const r = e.d.leftExpr;
        if (r.nodeType === 38) {
          a = r;
        } else {
          if (r.nodeType === 35) {
            a = r.d.member;
          }
        }
        if (a) {
          for (const e of (n = (t = this._evaluator.getDeclInfoForNameNode(a)) === null || t === undefined ? undefined : t.decls) !== null && n !== undefined ? n : []) {
            const t = this._evaluator.resolveAliasDeclaration(e, true);
            if (!t) {
              continue;
            }
            const n = this._evaluator.getType(a);
            if (!n) {
              continue;
            }
            const r = g.getDocumentationPartsForTypeAndDecl(this._sourceMapper, n, t, this._evaluator);
            if (r) {
              return r;
            }
          }
        }
      }
    };
  },
  76135: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SymbolIndexer = undefined;
    exports.isIndexSymbolVisibleFlagSet = function (e, t) {
      return !!(e.visibilityFlags & t);
    };
    const i = __importStar(require(26687));
    const o = require(4064);
    const l = require(91426);
    const p = require(56412);
    const d = require(56814);
    const c = require(16835);
    function u(e, t, n, a, r, s) {
      l.throwIfCancellationRequested(s);
      const y = i.getScope(n);
      if (!y) {
        return;
      }
      y.symbolTable.forEach((n, i) => {
        if (n.isIgnoredForProtocolMatch()) {
          return;
        }
        let l = o.getLastTypedDeclarationForSymbol(n);
        if (!l && n.hasDeclarations()) {
          l = n.getDeclarations()[0];
        }
        if (l && (l.type !== 8 || m(l, a))) {
          (function (e, t, n, a, r, s, i, o) {
            const l = p.getSymbolKind(n, undefined, s);
            if (l === undefined) {
              return;
            }
            let y = n.range;
            let g = y;
            const h = [];
            if (n.type === 6 || n.type === 5) {
              u(e, t, n.node, a, h, o);
              g = d.convertOffsetsToRange(n.node.start, n.node.start + n.node.length, t.tokenizerOutput.lines);
            }
            if (n.type === 8) {
              if (!m(n, a)) {
                return;
              }
              if (n.node.nodeType === 24 && n.node.d.alias) {
                y = g = d.convertTextRangeToRange(n.node.d.alias.d.token, t.tokenizerOutput.lines);
              }
            }
            const f = {
              name: s,
              visibilityFlags: 1,
              kind: l,
              itemKind: c.convertSymbolKindToCompletionItemKind(l),
              alias: undefined,
              range: g,
              selectionRange: y,
              children: h
            };
            i.push(f);
          })(e, t, l, a, o.isVisibleExternally(n), i, r, s);
        }
      });
    }
    function m(e, t) {
      return !!t.includeAliases && (e.node.nodeType === 24 || e.node.nodeType === 26) && e.node.d.alias !== undefined;
    }
    exports.SymbolIndexer = class {
      static indexSymbols(e, t, n, a) {
        const r = [];
        u(e, t, t.parserOutput.parseTree, n, r, a);
        return r;
      }
    };
  },
  39426: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getToolTipForType = function (e, t, n, a, r, s) {
      let i = '';
      if (p.isOverloaded(e)) {
        i = t.length > 0 ? `(${t})\n` : '';
        i += `${m(e, a, s)}`;
      } else {
        if (p.isFunction(e)) {
          i = `${y(t, n, e, a, r, s)}`;
        } else {
          i = t.length > 0 ? `(${t}) ` : '';
          i += `${n}: ${a.printType(e)}`;
        }
      }
      return i;
    };
    exports.getOverloadedTooltip = m;
    exports.getFunctionTooltip = y;
    exports.getConstructorTooltip = function e(t, n, a, r) {
      let s = '';
      if (p.isOverloaded(n)) {
        p.OverloadedType.getOverloads(n).map(n => e(t, n, a, r)).forEach((e, t) => {
          s += e + ': ...\n\n';
        });
      } else {
        if (p.isFunction(n)) {
          const e = r === d.SignatureDisplayType.formatted ? `
${' '.repeat(u)}` : ' ';
          const i = g(a.printFunctionParts(n), e, r);
          s += `class ${t}${i}`;
        }
      }
      return s;
    };
    exports.getFunctionDocStringFromType = h;
    exports.getOverloadedDocStringsFromType = f;
    exports.getDocumentationPartsForTypeAndDecl = function (e, t, n, a, r) {
      var s;
      var i;
      const l = function (e, t, n, a) {
        var r;
        if (!t) {
          return;
        }
        if (t.type === 4) {
          return t.docString;
        }
        if (t.type === 1) {
          if (t.typeAliasName && t.docString) {
            return t.docString;
          }
          const n = (r = a == null ? undefined : a.getDeclarations().find(e => e.type === 1 && !!e.docString)) !== null && r !== undefined ? r : t;
          const s = o.getVariableDocString(n, e);
          if (s) {
            return s;
          }
        }
        if (t.type === 5) {
          const a = o.getPropertyDocStringInherited(t, e, n);
          if (a) {
            return a;
          }
        }
        return;
      }(e, n, a, r == null ? undefined : r.symbol);
      let d;
      if ((n == null ? undefined : n.type) === 8) {
        if (n.type === 8 && n.node && n.node.nodeType === 24 && (r == null ? undefined : r.name) && !n.node.d.alias) {
          const e = n.node.d.module.d.nameParts.find(e => e.d.value === r.name);
          if (e) {
            const t = (i = (s = a.getDeclInfoForNameNode(e)) === null || s === undefined ? undefined : s.decls) !== null && i !== undefined ? i : [n];
            n = t.length > 0 ? t[0] : n;
          }
        }
        d = o.getModuleDocStringFromUris([n.uri], e);
      }
      d = d ?? (t ? function (e, t, n, a, r) {
        if (p.isModule(t)) {
          const a = o.getModuleDocString(t, n, e);
          if (a) {
            return a;
          }
        } else {
          if (p.isInstantiableClass(t)) {
            const a = o.getClassDocString(t, n, e);
            if (a) {
              return a;
            }
          } else {
            if (p.isFunction(t)) {
              const n = r ? a.bindFunctionToClassOrObject(r, t) : t;
              if (n && p.isFunction(n)) {
                const t = h(n, e, a);
                if (t) {
                  return t;
                }
              }
            } else {
              if (p.isOverloaded(t)) {
                const n = r ? a.bindFunctionToClassOrObject(r, t) : t;
                if (n && p.isOverloaded(n)) {
                  const t = f(n, e, a).find(e => e);
                  if (t) {
                    return t;
                  }
                }
              }
            }
          }
        }
        return;
      }(e, t, n, a, r == null ? undefined : r.boundObjectOrClass) : undefined);
      if (l && d && l !== d) {
        return `${l}\n\n${d}`;
      } else {
        return l || d;
      }
    };
    exports.getAutoImportText = function (e, t, n) {
      let a;
      a = t ? `from ${t} import ${e}` : `import ${e}`;
      if (n) {
        a = `${a} as ${n}`;
      }
      return a;
    };
    exports.combineExpressionTypes = function (e, t) {
      const n = e.map(e => t.getType(e) || p.UnknownType.create());
      let a = p.combineTypes(n);
      if (n.length === 1 && a.category === 6 && p.ClassType.isBuiltIn(a, 'list') && a.priv.typeArgs) {
        a = a.priv.typeArgs[0];
      } else {
        if (n.length === 1 && a.category === 6 && p.ClassType.isBuiltIn(a, 'range')) {
          a = t.getBuiltInObject(e[0], 'int');
        }
      }
      return a;
    };
    exports.getClassAndConstructorTypes = function (e, t) {
      var n;
      var a;
      let r = e;
      if (((n = r == null ? undefined : r.parent) === null || n === undefined ? undefined : n.nodeType) === 35 && e === r.parent.d.member || ((a = r == null ? undefined : r.parent) === null || a === undefined ? undefined : a.nodeType) === 27) {
        r = e.parent;
      }
      if (!r || !r.parent || r.parent.nodeType !== 9 || r.parent.d.leftExpr !== r) {
        return;
      }
      const s = b(t, e);
      if (!p.isInstantiableClass(s)) {
        return;
      }
      const i = b(t, r.parent);
      if (!p.isClassInstance(i)) {
        return;
      }
      let o;
      const d = l.lookUpClassMember(s, '__init__', 16);
      if (d) {
        const n = t.getTypeOfMember(d);
        if (p.isFunction(n) || p.isOverloaded(n)) {
          o = T(t, e, i, n);
        }
      }
      if (!o || o && p.isFunction(o) && (p.FunctionType.hasDefaultParams(o) || o.shared.parameters.length === 0)) {
        const n = l.lookUpClassMember(s, '__new__', 20);
        if (n) {
          const a = t.getTypeOfMember(n);
          if (p.isFunction(a) || p.isOverloaded(a)) {
            o = T(t, e, i, a, true);
          }
        }
      }
      return {
        methodType: o,
        classType: s
      };
    };
    exports.bindFunctionToClassOrObjectToolTip = T;
    exports.limitOverloadBasedOnCall = v;
    exports.getTypeForToolTip = b;
    const i = __importStar(require(41557));
    const o = require(30889);
    const l = require(92324);
    const p = require(21024);
    const d = require(12522);
    const c = require(34455);
    const u = 4;
    function m(e, t, n, a = 70) {
      let r = '';
      const s = p.OverloadedType.getOverloads(e).map(e => y('', e.shared.name, e, t, false, n));
      for (let e = 0; e < s.length; e++) {
        if (e !== 0 && s[e].length > a && s[e - 1].length <= a) {
          r += '\n';
        }
        r += s[e] + ': ...';
        if (e < s.length - 1) {
          r += '\n';
          if (s[e].length > a) {
            r += '\n';
          }
        }
      }
      return r;
    }
    function y(e, t, n, a, r = false, s) {
      const i = e.length === 0 ? '' : `(${e}) `;
      const o = s === d.SignatureDisplayType.formatted ? `
${' '.repeat(u)}` : '';
      const l = a.printFunctionParts(n);
      const c = `${g(l, o, s)} -> ${l[1]}`;
      if (p.TypeBase.isInstantiable(n)) {
        return `${i}${t}: type[${c}]`;
      }
      const m = r ? ': ' : '';
      let y = '';
      if (!r) {
        y = 'def ';
        if (p.FunctionType.isAsync(n)) {
          y = `async ${y}`;
        }
      }
      return `${i}${y}${t}${m}${c}`;
    }
    function g(e, t, n) {
      if (n === d.SignatureDisplayType.formatted && e.length > 0 && e[0].length > 1) {
        return `(${t}${e[0].join(`,${t}`)}\n)`;
      } else {
        return `(${e[0].join(', ')})`;
      }
    }
    function h(e, t, n) {
      const a = e.shared.declaration;
      const r = a ? i.getEnclosingClass(a.node) : undefined;
      const s = r ? n.getTypeOfClass(r) : undefined;
      return o.getFunctionDocStringInherited(e, a, t, s == null ? undefined : s.classType);
    }
    function f(e, t, n) {
      const a = p.OverloadedType.getOverloads(e);
      if (a.length === 0) {
        return [];
      }
      const r = a[0].shared.declaration;
      const s = r ? i.getEnclosingClass(r.node) : undefined;
      const l = s ? n.getTypeOfClass(s) : undefined;
      return o.getOverloadedDocStringsInherited(e, a.map(e => e.shared.declaration).filter(c.isDefined), t, n, l == null ? undefined : l.classType);
    }
    function T(e, t, n, a, r) {
      const s = e.bindFunctionToClassOrObject(n, a, undefined, r);
      if (s) {
        return v(e, s, t);
      }
    }
    function v(e, t, n) {
      if (!p.isOverloaded(t) || n.nodeType !== 38) {
        return t;
      }
      const a = i.getCallForName(n);
      if (!a) {
        return t;
      }
      const r = e.getTypeResult(a);
      if (r && r.overloadsUsedForCall && r.overloadsUsedForCall.length !== 0) {
        if (r.overloadsUsedForCall.length === 1) {
          return r.overloadsUsedForCall[0];
        } else {
          return p.OverloadedType.create(r.overloadsUsedForCall);
        }
      } else {
        return t;
      }
    }
    function b(e, t) {
      var n;
      const a = (n = e.getType(t)) !== null && n !== undefined ? n : p.UnknownType.create();
      return v(e, a, t);
    }
  },
  46292: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.WorkspaceSymbolProvider = undefined;
    const i = require(26687);
    const o = require(3433);
    const l = require(91426);
    const p = require(58147);
    const d = __importStar(require(89740));
    const c = require(5884);
    const u = require(76135);
    exports.WorkspaceSymbolProvider = class {
      constructor(e, t, n, a) {
        this._workspaces = e;
        this._query = n;
        this._token = a;
        this._allSymbols = [];
        this._reporter = t ? e => t.report(e) : e => p.appendArray(this._allSymbols, e);
      }
      reportSymbols() {
        for (const e of this._workspaces) {
          if (!e.disableLanguageServices && !e.disableWorkspaceSymbol) {
            if (e.isInitialized.resolved()) {
              e.service.run(e => {
                this._reportSymbolsForProgram(e);
              }, this._token);
            }
          }
        }
        return this._allSymbols;
      }
      getSymbolsForDocument(e, t) {
        const n = [];
        const a = e.getParseResults(t);
        if (!a) {
          return n;
        }
        const r = i.getFileInfo(a.parserOutput.parseTree);
        if (!r) {
          return n;
        }
        const s = u.SymbolIndexer.indexSymbols(r, a, {
          includeAliases: false
        }, this._token);
        this.appendWorkspaceSymbolsRecursive(s, e, t, '', n);
        return n;
      }
      appendWorkspaceSymbolsRecursive(e, t, n, a, r) {
        l.throwIfCancellationRequested(this._token);
        if (e) {
          for (const s of e) {
            if (!s.alias) {
              if (d.isPatternInSymbol(this._query, s.name)) {
                const e = {
                  uri: c.convertUriToLspUriString(t.fileSystem, n),
                  range: s.selectionRange
                };
                const i = {
                  name: s.name,
                  kind: s.kind,
                  location: e
                };
                if (a.length) {
                  i.containerName = a;
                }
                r.push(i);
              }
              this.appendWorkspaceSymbolsRecursive(s.children, t, n, this._getContainerName(a, s.name), r);
            }
          }
        }
      }
      _reportSymbolsForProgram(e) {
        if (this._query) {
          for (const t of e.getSourceFileInfoList()) {
            if (!o.isUserCode(t)) {
              continue;
            }
            const n = this.getSymbolsForDocument(e, t.sourceFile.getUri());
            if (n.length > 0) {
              this._reporter(n);
            }
            e.handleMemoryHighUsage();
          }
        }
      }
      _getContainerName(e, t) {
        if (e.length > 0) {
          return `${e}.${t}`;
        } else {
          return t;
        }
      }
    };
  },
  67703: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.LocAddendum = exports.LocMessage = exports.Localizer = exports.ParameterizedString = undefined;
    exports.setGetRawString = function (e) {
      const t = w;
      w = e;
      return t;
    };
    exports.getRawStringFromMap = S;
    exports.setLocaleOverride = function (e) {
      C = undefined;
      k = e.toLowerCase();
    };
    exports.setForceEnglishDiagnostics = function (e) {
      A = e;
    };
    exports.getLocaleFromEnv = x;
    exports.loadStringsForLocale = P;
    const a = require(48281);
    const r = require(73068);
    const s = require(94397);
    const i = require(84268);
    const o = require(45458);
    const l = require(18154);
    const p = require(51667);
    const d = require(3879);
    const c = require(83472);
    const u = require(96838);
    const m = require(55169);
    const y = require(12957);
    const g = require(78483);
    const h = require(83132);
    const f = require(63982);
    const T = require(95610);
    class v {
      constructor(e) {
        this._formatString = e;
      }
      format(e) {
        let t = this._formatString;
        Object.keys(e).forEach(n => {
          t = t.replace(new RegExp(`{${n}}`, 'g'), e[n].toString());
        });
        return t;
      }
      getFormatString() {
        return this._formatString;
      }
    }
    exports.ParameterizedString = v;
    const b = 'en-us';
    const _ = new Map([['cs', r], ['de', s], ['en-us', i], ['en', i], ['es', o], ['fr', l], ['it', p], ['ja', d], ['ko', c], ['pl', u], ['pt-br', m], ['qps-ploc', y], ['ru', g], ['tr', h], ['zh-cn', f], ['zh-tw', T]]);
    let C;
    let I = {};
    let k;
    let w = function (e) {
      if (C === undefined) {
        C = function () {
          I = function () {
            const e = _.get(b);
            if (e) {
              return e;
            }
            console.error('Could not load default strings');
            return {};
          }();
          return P(x(), _);
        }();
      }
      const t = e.split('.');
      const n = (t[0] === 'Diagnostic' || t[0] === 'DiagnosticAddendum') && A ? S(I, t) : S(C, t) || S(I, t);
      if (n) {
        return n;
      }
      a.fail(`Missing localized string for key "${e}"`);
    };
    function S(e, t) {
      let n = e;
      for (const e of t) {
        if (!n[e]) {
          return;
        }
        n = n[e];
      }
      if (typeof n == 'string') {
        return n;
      } else {
        return n.message;
      }
    }
    let A = false;
    function x() {
      if (k) {
        return k;
      }
      try {
        const e = process?.env;
        const t = e == null ? undefined : e.VSCODE_NLS_CONFIG;
        if (t) {
          try {
            return JSON.parse(t).locale || b;
          } catch {}
        }
        const n = (e == null ? undefined : e.LC_ALL) || (e == null ? undefined : e.LC_MESSAGES) || (e == null ? undefined : e.LANG) || (e == null ? undefined : e.LANGUAGE);
        if (n) {
          const e = n.split('.');
          if (e.length > 0 && e[0]) {
            return e[0] || b;
          }
        }
      } catch {}
      return b;
    }
    function P(e, t) {
      if (e === b) {
        return {};
      }
      let n = t.get(e);
      if (n !== undefined) {
        return n;
      }
      const a = e.split('-');
      if (a.length > 0 && a[0] && (n = t.get(a[0]), n !== undefined)) {
        return n;
      } else {
        return {};
      }
    }
    var D;
    (function (e) {
      let t;
      let n;
      let a;
      let r;
      let s;
      (function (e) {
        e.annotatedMetadataInconsistent = () => new v(w('Diagnostic.annotatedMetadataInconsistent'));
        e.abstractMethodInvocation = () => new v(w('Diagnostic.abstractMethodInvocation'));
        e.annotatedParamCountMismatch = () => new v(w('Diagnostic.annotatedParamCountMismatch'));
        e.annotatedTypeArgMissing = () => w('Diagnostic.annotatedTypeArgMissing');
        e.annotationBytesString = () => w('Diagnostic.annotationBytesString');
        e.annotationFormatString = () => w('Diagnostic.annotationFormatString');
        e.annotationNotSupported = () => w('Diagnostic.annotationNotSupported');
        e.annotationRawString = () => w('Diagnostic.annotationRawString');
        e.annotationSpansStrings = () => w('Diagnostic.annotationSpansStrings');
        e.annotationStringEscape = () => w('Diagnostic.annotationStringEscape');
        e.argAssignment = () => new v(w('Diagnostic.argAssignment'));
        e.argAssignmentFunction = () => new v(w('Diagnostic.argAssignmentFunction'));
        e.argAssignmentParam = () => new v(w('Diagnostic.argAssignmentParam'));
        e.argAssignmentParamFunction = () => new v(w('Diagnostic.argAssignmentParamFunction'));
        e.argMissingForParam = () => new v(w('Diagnostic.argMissingForParam'));
        e.argMissingForParams = () => new v(w('Diagnostic.argMissingForParams'));
        e.argMorePositionalExpectedCount = () => new v(w('Diagnostic.argMorePositionalExpectedCount'));
        e.argMorePositionalExpectedOne = () => w('Diagnostic.argMorePositionalExpectedOne');
        e.argPositional = () => w('Diagnostic.argPositional');
        e.argPositionalExpectedCount = () => new v(w('Diagnostic.argPositionalExpectedCount'));
        e.argPositionalExpectedOne = () => w('Diagnostic.argPositionalExpectedOne');
        e.argTypePartiallyUnknown = () => w('Diagnostic.argTypePartiallyUnknown');
        e.argTypeUnknown = () => w('Diagnostic.argTypeUnknown');
        e.assertAlwaysTrue = () => w('Diagnostic.assertAlwaysTrue');
        e.assertTypeArgs = () => w('Diagnostic.assertTypeArgs');
        e.assertTypeTypeMismatch = () => new v(w('Diagnostic.assertTypeTypeMismatch'));
        e.assignmentExprContext = () => w('Diagnostic.assignmentExprContext');
        e.assignmentExprComprehension = () => new v(w('Diagnostic.assignmentExprComprehension'));
        e.assignmentExprInSubscript = () => w('Diagnostic.assignmentExprInSubscript');
        e.assignmentInProtocol = () => w('Diagnostic.assignmentInProtocol');
        e.assignmentTargetExpr = () => w('Diagnostic.assignmentTargetExpr');
        e.asyncNotInAsyncFunction = () => w('Diagnostic.asyncNotInAsyncFunction');
        e.awaitIllegal = () => w('Diagnostic.awaitIllegal');
        e.awaitNotAllowed = () => w('Diagnostic.awaitNotAllowed');
        e.awaitNotInAsync = () => w('Diagnostic.awaitNotInAsync');
        e.backticksIllegal = () => w('Diagnostic.backticksIllegal');
        e.baseClassCircular = () => w('Diagnostic.baseClassCircular');
        e.baseClassFinal = () => new v(w('Diagnostic.baseClassFinal'));
        e.baseClassIncompatible = () => new v(w('Diagnostic.baseClassIncompatible'));
        e.baseClassInvalid = () => w('Diagnostic.baseClassInvalid');
        e.baseClassMethodTypeIncompatible = () => new v(w('Diagnostic.baseClassMethodTypeIncompatible'));
        e.baseClassVariableTypeIncompatible = () => new v(w('Diagnostic.baseClassVariableTypeIncompatible'));
        e.baseClassUnknown = () => w('Diagnostic.baseClassUnknown');
        e.binaryOperationNotAllowed = () => w('Diagnostic.binaryOperationNotAllowed');
        e.bindTypeMismatch = () => new v(w('Diagnostic.bindTypeMismatch'));
        e.breakInExceptionGroup = () => w('Diagnostic.breakInExceptionGroup');
        e.breakOutsideLoop = () => w('Diagnostic.breakOutsideLoop');
        e.callableExtraArgs = () => w('Diagnostic.callableExtraArgs');
        e.callableFirstArg = () => w('Diagnostic.callableFirstArg');
        e.callableNotInstantiable = () => new v(w('Diagnostic.callableNotInstantiable'));
        e.callableSecondArg = () => w('Diagnostic.callableSecondArg');
        e.casePatternIsIrrefutable = () => w('Diagnostic.casePatternIsIrrefutable');
        e.classAlreadySpecialized = () => new v(w('Diagnostic.classAlreadySpecialized'));
        e.classDecoratorTypeUnknown = () => w('Diagnostic.classDecoratorTypeUnknown');
        e.classDefinitionCycle = () => new v(w('Diagnostic.classDefinitionCycle'));
        e.classGetItemClsParam = () => w('Diagnostic.classGetItemClsParam');
        e.classMethodClsParam = () => w('Diagnostic.classMethodClsParam');
        e.classNotRuntimeSubscriptable = () => new v(w('Diagnostic.classNotRuntimeSubscriptable'));
        e.classPatternBuiltInArgPositional = () => w('Diagnostic.classPatternBuiltInArgPositional');
        e.classPatternPositionalArgCount = () => new v(w('Diagnostic.classPatternPositionalArgCount'));
        e.classPatternTypeAlias = () => new v(w('Diagnostic.classPatternTypeAlias'));
        e.classPropertyDeprecated = () => w('Diagnostic.classPropertyDeprecated');
        e.classTypeParametersIllegal = () => w('Diagnostic.classTypeParametersIllegal');
        e.classVarNotAllowed = () => w('Diagnostic.classVarNotAllowed');
        e.classVarFirstArgMissing = () => w('Diagnostic.classVarFirstArgMissing');
        e.classVarOverridesInstanceVar = () => new v(w('Diagnostic.classVarOverridesInstanceVar'));
        e.classVarTooManyArgs = () => w('Diagnostic.classVarTooManyArgs');
        e.classVarWithTypeVar = () => w('Diagnostic.classVarWithTypeVar');
        e.clsSelfParamTypeMismatch = () => new v(w('Diagnostic.clsSelfParamTypeMismatch'));
        e.codeTooComplexToAnalyze = () => w('Diagnostic.codeTooComplexToAnalyze');
        e.collectionAliasInstantiation = () => new v(w('Diagnostic.collectionAliasInstantiation'));
        e.comparisonAlwaysFalse = () => new v(w('Diagnostic.comparisonAlwaysFalse'));
        e.comparisonAlwaysTrue = () => new v(w('Diagnostic.comparisonAlwaysTrue'));
        e.comprehensionInDict = () => w('Diagnostic.comprehensionInDict');
        e.comprehensionInSet = () => w('Diagnostic.comprehensionInSet');
        e.concatenateContext = () => w('Diagnostic.concatenateContext');
        e.concatenateParamSpecMissing = () => w('Diagnostic.concatenateParamSpecMissing');
        e.concatenateTypeArgsMissing = () => w('Diagnostic.concatenateTypeArgsMissing');
        e.conditionalOperandInvalid = () => new v(w('Diagnostic.conditionalOperandInvalid'));
        e.constantRedefinition = () => new v(w('Diagnostic.constantRedefinition'));
        e.coroutineInConditionalExpression = () => w('Diagnostic.coroutineInConditionalExpression');
        e.constructorParametersMismatch = () => new v(w('Diagnostic.constructorParametersMismatch'));
        e.containmentAlwaysFalse = () => new v(w('Diagnostic.containmentAlwaysFalse'));
        e.containmentAlwaysTrue = () => new v(w('Diagnostic.containmentAlwaysTrue'));
        e.continueInExceptionGroup = () => w('Diagnostic.continueInExceptionGroup');
        e.continueOutsideLoop = () => w('Diagnostic.continueOutsideLoop');
        e.dataClassBaseClassFrozen = () => w('Diagnostic.dataClassBaseClassFrozen');
        e.dataClassBaseClassNotFrozen = () => w('Diagnostic.dataClassBaseClassNotFrozen');
        e.dataClassConverterFunction = () => new v(w('Diagnostic.dataClassConverterFunction'));
        e.dataClassConverterOverloads = () => new v(w('Diagnostic.dataClassConverterOverloads'));
        e.dataClassFieldInheritedDefault = () => new v(w('Diagnostic.dataClassFieldInheritedDefault'));
        e.dataClassFieldWithDefault = () => w('Diagnostic.dataClassFieldWithDefault');
        e.dataClassFieldWithoutAnnotation = () => w('Diagnostic.dataClassFieldWithoutAnnotation');
        e.dataClassFieldWithPrivateName = () => w('Diagnostic.dataClassFieldWithPrivateName');
        e.dataClassPostInitParamCount = () => new v(w('Diagnostic.dataClassPostInitParamCount'));
        e.dataClassPostInitType = () => new v(w('Diagnostic.dataClassPostInitType'));
        e.dataClassSlotsOverwrite = () => w('Diagnostic.dataClassSlotsOverwrite');
        e.dataClassTransformExpectedBoolLiteral = () => w('Diagnostic.dataClassTransformExpectedBoolLiteral');
        e.dataClassTransformFieldSpecifier = () => new v(w('Diagnostic.dataClassTransformFieldSpecifier'));
        e.dataClassTransformPositionalParam = () => w('Diagnostic.dataClassTransformPositionalParam');
        e.dataClassTransformUnknownArgument = () => new v(w('Diagnostic.dataClassTransformUnknownArgument'));
        e.dataProtocolInSubclassCheck = () => w('Diagnostic.dataProtocolInSubclassCheck');
        e.declaredReturnTypePartiallyUnknown = () => new v(w('Diagnostic.declaredReturnTypePartiallyUnknown'));
        e.declaredReturnTypeUnknown = () => w('Diagnostic.declaredReturnTypeUnknown');
        e.defaultValueContainsCall = () => w('Diagnostic.defaultValueContainsCall');
        e.defaultValueNotAllowed = () => w('Diagnostic.defaultValueNotAllowed');
        e.deprecatedClass = () => new v(w('Diagnostic.deprecatedClass'));
        e.deprecatedConstructor = () => new v(w('Diagnostic.deprecatedConstructor'));
        e.deprecatedDescriptorDeleter = () => new v(w('Diagnostic.deprecatedDescriptorDeleter'));
        e.deprecatedDescriptorGetter = () => new v(w('Diagnostic.deprecatedDescriptorGetter'));
        e.deprecatedDescriptorSetter = () => new v(w('Diagnostic.deprecatedDescriptorSetter'));
        e.deprecatedFunction = () => new v(w('Diagnostic.deprecatedFunction'));
        e.deprecatedMethod = () => new v(w('Diagnostic.deprecatedMethod'));
        e.deprecatedPropertyDeleter = () => new v(w('Diagnostic.deprecatedPropertyDeleter'));
        e.deprecatedPropertyGetter = () => new v(w('Diagnostic.deprecatedPropertyGetter'));
        e.deprecatedPropertySetter = () => new v(w('Diagnostic.deprecatedPropertySetter'));
        e.deprecatedType = () => new v(w('Diagnostic.deprecatedType'));
        e.dictExpandIllegalInComprehension = () => w('Diagnostic.dictExpandIllegalInComprehension');
        e.dictInAnnotation = () => w('Diagnostic.dictInAnnotation');
        e.dictKeyValuePairs = () => w('Diagnostic.dictKeyValuePairs');
        e.dictUnpackIsNotMapping = () => w('Diagnostic.dictUnpackIsNotMapping');
        e.delTargetExpr = () => w('Diagnostic.delTargetExpr');
        e.dunderAllSymbolNotPresent = () => new v(w('Diagnostic.dunderAllSymbolNotPresent'));
        e.duplicateArgsParam = () => w('Diagnostic.duplicateArgsParam');
        e.duplicateBaseClass = () => w('Diagnostic.duplicateBaseClass');
        e.duplicateCatchAll = () => w('Diagnostic.duplicateCatchAll');
        e.duplicateEnumMember = () => new v(w('Diagnostic.duplicateEnumMember'));
        e.duplicateGenericAndProtocolBase = () => w('Diagnostic.duplicateGenericAndProtocolBase');
        e.duplicateImport = () => new v(w('Diagnostic.duplicateImport'));
        e.duplicateKwargsParam = () => w('Diagnostic.duplicateKwargsParam');
        e.duplicateKeywordOnly = () => w('Diagnostic.duplicateKeywordOnly');
        e.duplicateParam = () => new v(w('Diagnostic.duplicateParam'));
        e.duplicateCapturePatternTarget = () => new v(w('Diagnostic.duplicateCapturePatternTarget'));
        e.duplicateStarPattern = () => w('Diagnostic.duplicateStarPattern');
        e.duplicateStarStarPattern = () => w('Diagnostic.duplicateStarStarPattern');
        e.duplicatePositionOnly = () => w('Diagnostic.duplicatePositionOnly');
        e.duplicateUnpack = () => w('Diagnostic.duplicateUnpack');
        e.ellipsisAfterUnpacked = () => w('Diagnostic.ellipsisAfterUnpacked');
        e.ellipsisContext = () => w('Diagnostic.ellipsisContext');
        e.ellipsisSecondArg = () => w('Diagnostic.ellipsisSecondArg');
        e.enumClassOverride = () => new v(w('Diagnostic.enumClassOverride'));
        e.enumMemberDelete = () => new v(w('Diagnostic.enumMemberDelete'));
        e.enumMemberSet = () => new v(w('Diagnostic.enumMemberSet'));
        e.enumMemberTypeAnnotation = () => w('Diagnostic.enumMemberTypeAnnotation');
        e.exceptionGroupIncompatible = () => w('Diagnostic.exceptionGroupIncompatible');
        e.exceptGroupMismatch = () => w('Diagnostic.exceptGroupMismatch');
        e.exceptGroupRequiresType = () => w('Diagnostic.exceptGroupRequiresType');
        e.exceptionGroupTypeIncorrect = () => w('Diagnostic.exceptionGroupTypeIncorrect');
        e.exceptionTypeIncorrect = () => new v(w('Diagnostic.exceptionTypeIncorrect'));
        e.exceptionTypeNotClass = () => new v(w('Diagnostic.exceptionTypeNotClass'));
        e.exceptionTypeNotInstantiable = () => new v(w('Diagnostic.exceptionTypeNotInstantiable'));
        e.expectedAfterDecorator = () => w('Diagnostic.expectedAfterDecorator');
        e.expectedArrow = () => w('Diagnostic.expectedArrow');
        e.expectedAsAfterException = () => w('Diagnostic.expectedAsAfterException');
        e.expectedAssignRightHandExpr = () => w('Diagnostic.expectedAssignRightHandExpr');
        e.expectedBinaryRightHandExpr = () => w('Diagnostic.expectedBinaryRightHandExpr');
        e.expectedBoolLiteral = () => w('Diagnostic.expectedBoolLiteral');
        e.expectedCase = () => w('Diagnostic.expectedCase');
        e.expectedClassName = () => w('Diagnostic.expectedClassName');
        e.expectedCloseBrace = () => w('Diagnostic.expectedCloseBrace');
        e.expectedCloseBracket = () => w('Diagnostic.expectedCloseBracket');
        e.expectedCloseParen = () => w('Diagnostic.expectedCloseParen');
        e.expectedColon = () => w('Diagnostic.expectedColon');
        e.expectedComplexNumberLiteral = () => w('Diagnostic.expectedComplexNumberLiteral');
        e.expectedDecoratorExpr = () => w('Diagnostic.expectedDecoratorExpr');
        e.expectedDecoratorName = () => w('Diagnostic.expectedDecoratorName');
        e.expectedDecoratorNewline = () => w('Diagnostic.expectedDecoratorNewline');
        e.expectedDelExpr = () => w('Diagnostic.expectedDelExpr');
        e.expectedElse = () => w('Diagnostic.expectedElse');
        e.expectedEquals = () => w('Diagnostic.expectedEquals');
        e.expectedExceptionClass = () => w('Diagnostic.expectedExceptionClass');
        e.expectedExceptionObj = () => w('Diagnostic.expectedExceptionObj');
        e.expectedExpr = () => w('Diagnostic.expectedExpr');
        e.expectedIdentifier = () => w('Diagnostic.expectedIdentifier');
        e.expectedImport = () => w('Diagnostic.expectedImport');
        e.expectedImportAlias = () => w('Diagnostic.expectedImportAlias');
        e.expectedImportSymbols = () => w('Diagnostic.expectedImportSymbols');
        e.expectedIndentedBlock = () => w('Diagnostic.expectedIndentedBlock');
        e.expectedIn = () => w('Diagnostic.expectedIn');
        e.expectedInExpr = () => w('Diagnostic.expectedInExpr');
        e.expectedFunctionAfterAsync = () => w('Diagnostic.expectedFunctionAfterAsync');
        e.expectedFunctionName = () => w('Diagnostic.expectedFunctionName');
        e.expectedMemberName = () => w('Diagnostic.expectedMemberName');
        e.expectedModuleName = () => w('Diagnostic.expectedModuleName');
        e.expectedNameAfterAs = () => w('Diagnostic.expectedNameAfterAs');
        e.expectedNamedParameter = () => w('Diagnostic.expectedNamedParameter');
        e.expectedNewline = () => w('Diagnostic.expectedNewline');
        e.expectedNewlineOrSemicolon = () => w('Diagnostic.expectedNewlineOrSemicolon');
        e.expectedOpenParen = () => w('Diagnostic.expectedOpenParen');
        e.expectedParamName = () => w('Diagnostic.expectedParamName');
        e.expectedPatternExpr = () => w('Diagnostic.expectedPatternExpr');
        e.expectedPatternSubjectExpr = () => w('Diagnostic.expectedPatternSubjectExpr');
        e.expectedPatternValue = () => w('Diagnostic.expectedPatternValue');
        e.expectedReturnExpr = () => w('Diagnostic.expectedReturnExpr');
        e.expectedSliceIndex = () => w('Diagnostic.expectedSliceIndex');
        e.expectedTypeNotString = () => w('Diagnostic.expectedTypeNotString');
        e.expectedTypeParameterName = () => w('Diagnostic.expectedTypeParameterName');
        e.expectedYieldExpr = () => w('Diagnostic.expectedYieldExpr');
        e.finalClassIsAbstract = () => new v(w('Diagnostic.finalClassIsAbstract'));
        e.finalContext = () => w('Diagnostic.finalContext');
        e.finalInLoop = () => w('Diagnostic.finalInLoop');
        e.finalMethodOverride = () => new v(w('Diagnostic.finalMethodOverride'));
        e.finalNonMethod = () => new v(w('Diagnostic.finalNonMethod'));
        e.finalReassigned = () => new v(w('Diagnostic.finalReassigned'));
        e.finalRedeclaration = () => new v(w('Diagnostic.finalRedeclaration'));
        e.finalRedeclarationBySubclass = () => new v(w('Diagnostic.finalRedeclarationBySubclass'));
        e.finalTooManyArgs = () => w('Diagnostic.finalTooManyArgs');
        e.finalUnassigned = () => new v(w('Diagnostic.finalUnassigned'));
        e.formatStringBrace = () => w('Diagnostic.formatStringBrace');
        e.formatStringBytes = () => w('Diagnostic.formatStringBytes');
        e.formatStringDebuggingIllegal = () => w('Diagnostic.formatStringDebuggingIllegal');
        e.formatStringEscape = () => w('Diagnostic.formatStringEscape');
        e.formatStringExpectedConversion = () => w('Diagnostic.formatStringExpectedConversion');
        e.formatStringInPattern = () => w('Diagnostic.formatStringInPattern');
        e.formatStringIllegal = () => w('Diagnostic.formatStringIllegal');
        e.formatStringNestedFormatSpecifier = () => w('Diagnostic.formatStringNestedFormatSpecifier');
        e.formatStringNestedQuote = () => w('Diagnostic.formatStringNestedQuote');
        e.formatStringUnicode = () => w('Diagnostic.formatStringUnicode');
        e.formatStringUnterminated = () => w('Diagnostic.formatStringUnterminated');
        e.functionDecoratorTypeUnknown = () => w('Diagnostic.functionDecoratorTypeUnknown');
        e.functionInConditionalExpression = () => w('Diagnostic.functionInConditionalExpression');
        e.functionTypeParametersIllegal = () => w('Diagnostic.functionTypeParametersIllegal');
        e.futureImportLocationNotAllowed = () => w('Diagnostic.futureImportLocationNotAllowed');
        e.generatorAsyncReturnType = () => new v(w('Diagnostic.generatorAsyncReturnType'));
        e.generatorNotParenthesized = () => w('Diagnostic.generatorNotParenthesized');
        e.generatorSyncReturnType = () => new v(w('Diagnostic.generatorSyncReturnType'));
        e.genericBaseClassNotAllowed = () => w('Diagnostic.genericBaseClassNotAllowed');
        e.genericClassAssigned = () => w('Diagnostic.genericClassAssigned');
        e.genericClassDeleted = () => w('Diagnostic.genericClassDeleted');
        e.genericInstanceVariableAccess = () => w('Diagnostic.genericInstanceVariableAccess');
        e.genericNotAllowed = () => w('Diagnostic.genericNotAllowed');
        e.genericTypeAliasBoundTypeVar = () => new v(w('Diagnostic.genericTypeAliasBoundTypeVar'));
        e.genericTypeArgMissing = () => w('Diagnostic.genericTypeArgMissing');
        e.genericTypeArgTypeVar = () => w('Diagnostic.genericTypeArgTypeVar');
        e.genericTypeArgUnique = () => w('Diagnostic.genericTypeArgUnique');
        e.globalReassignment = () => new v(w('Diagnostic.globalReassignment'));
        e.globalRedefinition = () => new v(w('Diagnostic.globalRedefinition'));
        e.implicitStringConcat = () => w('Diagnostic.implicitStringConcat');
        e.importCycleDetected = () => w('Diagnostic.importCycleDetected');
        e.importDepthExceeded = () => new v(w('Diagnostic.importDepthExceeded'));
        e.importResolveFailure = () => new v(w('Diagnostic.importResolveFailure'));
        e.importSourceResolveFailure = () => new v(w('Diagnostic.importSourceResolveFailure'));
        e.importSymbolUnknown = () => new v(w('Diagnostic.importSymbolUnknown'));
        e.incompatibleMethodOverride = () => new v(w('Diagnostic.incompatibleMethodOverride'));
        e.inconsistentIndent = () => w('Diagnostic.inconsistentIndent');
        e.inconsistentTabs = () => w('Diagnostic.inconsistentTabs');
        e.initMethodSelfParamTypeVar = () => w('Diagnostic.initMethodSelfParamTypeVar');
        e.initMustReturnNone = () => w('Diagnostic.initMustReturnNone');
        e.initSubclassClsParam = () => w('Diagnostic.initSubclassClsParam');
        e.initSubclassCallFailed = () => w('Diagnostic.initSubclassCallFailed');
        e.initVarNotAllowed = () => w('Diagnostic.initVarNotAllowed');
        e.instanceMethodSelfParam = () => w('Diagnostic.instanceMethodSelfParam');
        e.instanceVarOverridesClassVar = () => new v(w('Diagnostic.instanceVarOverridesClassVar'));
        e.instantiateAbstract = () => new v(w('Diagnostic.instantiateAbstract'));
        e.instantiateProtocol = () => new v(w('Diagnostic.instantiateProtocol'));
        e.internalBindError = () => new v(w('Diagnostic.internalBindError'));
        e.internalParseError = () => new v(w('Diagnostic.internalParseError'));
        e.internalTypeCheckingError = () => new v(w('Diagnostic.internalTypeCheckingError'));
        e.invalidIdentifierChar = () => w('Diagnostic.invalidIdentifierChar');
        e.invalidStubStatement = () => w('Diagnostic.invalidStubStatement');
        e.invalidTokenChars = () => new v(w('Diagnostic.invalidTokenChars'));
        e.isInstanceInvalidType = () => new v(w('Diagnostic.isInstanceInvalidType'));
        e.isSubclassInvalidType = () => new v(w('Diagnostic.isSubclassInvalidType'));
        e.keyValueInSet = () => w('Diagnostic.keyValueInSet');
        e.keywordArgInTypeArgument = () => w('Diagnostic.keywordArgInTypeArgument');
        e.keywordArgShortcutIllegal = () => w('Diagnostic.keywordArgShortcutIllegal');
        e.keywordOnlyAfterArgs = () => w('Diagnostic.keywordOnlyAfterArgs');
        e.keywordParameterMissing = () => w('Diagnostic.keywordParameterMissing');
        e.keywordSubscriptIllegal = () => w('Diagnostic.keywordSubscriptIllegal');
        e.lambdaReturnTypeUnknown = () => w('Diagnostic.lambdaReturnTypeUnknown');
        e.lambdaReturnTypePartiallyUnknown = () => new v(w('Diagnostic.lambdaReturnTypePartiallyUnknown'));
        e.listAssignmentMismatch = () => new v(w('Diagnostic.listAssignmentMismatch'));
        e.listInAnnotation = () => w('Diagnostic.listInAnnotation');
        e.literalNamedUnicodeEscape = () => w('Diagnostic.literalNamedUnicodeEscape');
        e.literalUnsupportedType = () => w('Diagnostic.literalUnsupportedType');
        e.literalEmptyArgs = () => w('Diagnostic.literalEmptyArgs');
        e.literalNotAllowed = () => w('Diagnostic.literalNotAllowed');
        e.literalNotCallable = () => w('Diagnostic.literalNotCallable');
        e.matchIncompatible = () => w('Diagnostic.matchIncompatible');
        e.matchIsNotExhaustive = () => w('Diagnostic.matchIsNotExhaustive');
        e.maxParseDepthExceeded = () => w('Diagnostic.maxParseDepthExceeded');
        e.memberAccess = () => new v(w('Diagnostic.memberAccess'));
        e.memberDelete = () => new v(w('Diagnostic.memberDelete'));
        e.memberSet = () => new v(w('Diagnostic.memberSet'));
        e.metaclassConflict = () => w('Diagnostic.metaclassConflict');
        e.metaclassDuplicate = () => w('Diagnostic.metaclassDuplicate');
        e.metaclassIsGeneric = () => w('Diagnostic.metaclassIsGeneric');
        e.methodNotDefined = () => new v(w('Diagnostic.methodNotDefined'));
        e.methodNotDefinedOnType = () => new v(w('Diagnostic.methodNotDefinedOnType'));
        e.methodOrdering = () => w('Diagnostic.methodOrdering');
        e.methodOverridden = () => new v(w('Diagnostic.methodOverridden'));
        e.methodReturnsNonObject = () => new v(w('Diagnostic.methodReturnsNonObject'));
        e.missingSuperCall = () => new v(w('Diagnostic.missingSuperCall'));
        e.mixingBytesAndStr = () => w('Diagnostic.mixingBytesAndStr');
        e.moduleAsType = () => w('Diagnostic.moduleAsType');
        e.moduleNotCallable = () => w('Diagnostic.moduleNotCallable');
        e.moduleUnknownMember = () => new v(w('Diagnostic.moduleUnknownMember'));
        e.namedExceptAfterCatchAll = () => w('Diagnostic.namedExceptAfterCatchAll');
        e.namedParamAfterParamSpecArgs = () => new v(w('Diagnostic.namedParamAfterParamSpecArgs'));
        e.namedTupleEmptyName = () => w('Diagnostic.namedTupleEmptyName');
        e.namedTupleEntryRedeclared = () => new v(w('Diagnostic.namedTupleEntryRedeclared'));
        e.namedTupleFirstArg = () => w('Diagnostic.namedTupleFirstArg');
        e.namedTupleMultipleInheritance = () => w('Diagnostic.namedTupleMultipleInheritance');
        e.namedTupleNameKeyword = () => w('Diagnostic.namedTupleNameKeyword');
        e.namedTupleNameType = () => w('Diagnostic.namedTupleNameType');
        e.namedTupleNameUnique = () => w('Diagnostic.namedTupleNameUnique');
        e.namedTupleNoTypes = () => w('Diagnostic.namedTupleNoTypes');
        e.namedTupleSecondArg = () => w('Diagnostic.namedTupleSecondArg');
        e.newClsParam = () => w('Diagnostic.newClsParam');
        e.newTypeAnyOrUnknown = () => w('Diagnostic.newTypeAnyOrUnknown');
        e.newTypeBadName = () => w('Diagnostic.newTypeBadName');
        e.newTypeLiteral = () => w('Diagnostic.newTypeLiteral');
        e.newTypeNameMismatch = () => w('Diagnostic.newTypeNameMismatch');
        e.newTypeNotAClass = () => w('Diagnostic.newTypeNotAClass');
        e.newTypeParamCount = () => w('Diagnostic.newTypeParamCount');
        e.newTypeProtocolClass = () => w('Diagnostic.newTypeProtocolClass');
        e.nonDefaultAfterDefault = () => w('Diagnostic.nonDefaultAfterDefault');
        e.noneNotCallable = () => w('Diagnostic.noneNotCallable');
        e.noneNotIterable = () => w('Diagnostic.noneNotIterable');
        e.noneNotSubscriptable = () => w('Diagnostic.noneNotSubscriptable');
        e.noneNotUsableWith = () => w('Diagnostic.noneNotUsableWith');
        e.noneOperator = () => new v(w('Diagnostic.noneOperator'));
        e.noneUnknownMember = () => new v(w('Diagnostic.noneUnknownMember'));
        e.nonLocalNoBinding = () => new v(w('Diagnostic.nonLocalNoBinding'));
        e.nonLocalReassignment = () => new v(w('Diagnostic.nonLocalReassignment'));
        e.nonLocalRedefinition = () => new v(w('Diagnostic.nonLocalRedefinition'));
        e.nonLocalInModule = () => w('Diagnostic.nonLocalInModule');
        e.noOverload = () => new v(w('Diagnostic.noOverload'));
        e.noReturnContainsReturn = () => w('Diagnostic.noReturnContainsReturn');
        e.noReturnContainsYield = () => w('Diagnostic.noReturnContainsYield');
        e.noReturnReturnsNone = () => w('Diagnostic.noReturnReturnsNone');
        e.notRequiredArgCount = () => w('Diagnostic.notRequiredArgCount');
        e.notRequiredNotInTypedDict = () => w('Diagnostic.notRequiredNotInTypedDict');
        e.objectNotCallable = () => new v(w('Diagnostic.objectNotCallable'));
        e.obscuredClassDeclaration = () => new v(w('Diagnostic.obscuredClassDeclaration'));
        e.obscuredFunctionDeclaration = () => new v(w('Diagnostic.obscuredFunctionDeclaration'));
        e.obscuredMethodDeclaration = () => new v(w('Diagnostic.obscuredMethodDeclaration'));
        e.obscuredParameterDeclaration = () => new v(w('Diagnostic.obscuredParameterDeclaration'));
        e.obscuredTypeAliasDeclaration = () => new v(w('Diagnostic.obscuredTypeAliasDeclaration'));
        e.obscuredVariableDeclaration = () => new v(w('Diagnostic.obscuredVariableDeclaration'));
        e.operatorLessOrGreaterDeprecated = () => w('Diagnostic.operatorLessOrGreaterDeprecated');
        e.optionalExtraArgs = () => w('Diagnostic.optionalExtraArgs');
        e.orPatternIrrefutable = () => w('Diagnostic.orPatternIrrefutable');
        e.orPatternMissingName = () => w('Diagnostic.orPatternMissingName');
        e.overlappingKeywordArgs = () => new v(w('Diagnostic.overlappingKeywordArgs'));
        e.overlappingOverload = () => new v(w('Diagnostic.overlappingOverload'));
        e.overloadAbstractMismatch = () => new v(w('Diagnostic.overloadAbstractMismatch'));
        e.overloadAbstractImplMismatch = () => new v(w('Diagnostic.overloadAbstractImplMismatch'));
        e.overloadClassMethodInconsistent = () => new v(w('Diagnostic.overloadClassMethodInconsistent'));
        e.overloadFinalInconsistencyImpl = () => new v(w('Diagnostic.overloadFinalInconsistencyImpl'));
        e.overloadFinalInconsistencyNoImpl = () => new v(w('Diagnostic.overloadFinalInconsistencyNoImpl'));
        e.overloadImplementationMismatch = () => new v(w('Diagnostic.overloadImplementationMismatch'));
        e.overloadReturnTypeMismatch = () => new v(w('Diagnostic.overloadReturnTypeMismatch'));
        e.overloadStaticMethodInconsistent = () => new v(w('Diagnostic.overloadStaticMethodInconsistent'));
        e.overloadWithoutImplementation = () => new v(w('Diagnostic.overloadWithoutImplementation'));
        e.overriddenMethodNotFound = () => new v(w('Diagnostic.overriddenMethodNotFound'));
        e.overrideDecoratorMissing = () => new v(w('Diagnostic.overrideDecoratorMissing'));
        e.paramAfterKwargsParam = () => w('Diagnostic.paramAfterKwargsParam');
        e.paramAlreadyAssigned = () => new v(w('Diagnostic.paramAlreadyAssigned'));
        e.paramAnnotationMissing = () => new v(w('Diagnostic.paramAnnotationMissing'));
        e.paramNameMissing = () => new v(w('Diagnostic.paramNameMissing'));
        e.paramSpecArgsKwargsDuplicate = () => new v(w('Diagnostic.paramSpecArgsKwargsDuplicate'));
        e.paramSpecArgsKwargsUsage = () => w('Diagnostic.paramSpecArgsKwargsUsage');
        e.paramSpecArgsMissing = () => new v(w('Diagnostic.paramSpecArgsMissing'));
        e.paramSpecArgsUsage = () => w('Diagnostic.paramSpecArgsUsage');
        e.paramSpecAssignedName = () => new v(w('Diagnostic.paramSpecAssignedName'));
        e.paramSpecContext = () => w('Diagnostic.paramSpecContext');
        e.paramSpecDefaultNotTuple = () => w('Diagnostic.paramSpecDefaultNotTuple');
        e.paramSpecFirstArg = () => w('Diagnostic.paramSpecFirstArg');
        e.paramSpecKwargsUsage = () => w('Diagnostic.paramSpecKwargsUsage');
        e.paramSpecNotUsedByOuterScope = () => new v(w('Diagnostic.paramSpecNotUsedByOuterScope'));
        e.paramSpecUnknownArg = () => w('Diagnostic.paramSpecUnknownArg');
        e.paramSpecUnknownMember = () => new v(w('Diagnostic.paramSpecUnknownMember'));
        e.paramSpecUnknownParam = () => new v(w('Diagnostic.paramSpecUnknownParam'));
        e.paramTypeCovariant = () => w('Diagnostic.paramTypeCovariant');
        e.paramTypeUnknown = () => new v(w('Diagnostic.paramTypeUnknown'));
        e.paramAssignmentMismatch = () => new v(w('Diagnostic.paramAssignmentMismatch'));
        e.paramTypePartiallyUnknown = () => new v(w('Diagnostic.paramTypePartiallyUnknown'));
        e.parenthesizedContextManagerIllegal = () => w('Diagnostic.parenthesizedContextManagerIllegal');
        e.patternNeverMatches = () => new v(w('Diagnostic.patternNeverMatches'));
        e.positionArgAfterNamedArg = () => w('Diagnostic.positionArgAfterNamedArg');
        e.privateImportFromPyTypedModule = () => new v(w('Diagnostic.privateImportFromPyTypedModule'));
        e.positionOnlyAfterArgs = () => w('Diagnostic.positionOnlyAfterArgs');
        e.positionOnlyAfterKeywordOnly = () => w('Diagnostic.positionOnlyAfterKeywordOnly');
        e.positionOnlyAfterNon = () => w('Diagnostic.positionOnlyAfterNon');
        e.positionOnlyIncompatible = () => w('Diagnostic.positionOnlyIncompatible');
        e.positionOnlyFirstParam = () => w('Diagnostic.positionOnlyFirstParam');
        e.privateUsedOutsideOfClass = () => new v(w('Diagnostic.privateUsedOutsideOfClass'));
        e.privateUsedOutsideOfModule = () => new v(w('Diagnostic.privateUsedOutsideOfModule'));
        e.propertyOverridden = () => new v(w('Diagnostic.propertyOverridden'));
        e.propertyStaticMethod = () => w('Diagnostic.propertyStaticMethod');
        e.protectedUsedOutsideOfClass = () => new v(w('Diagnostic.protectedUsedOutsideOfClass'));
        e.protocolBaseClass = () => new v(w('Diagnostic.protocolBaseClass'));
        e.protocolBaseClassWithTypeArgs = () => w('Diagnostic.protocolBaseClassWithTypeArgs');
        e.protocolIllegal = () => w('Diagnostic.protocolIllegal');
        e.protocolNotAllowed = () => w('Diagnostic.protocolNotAllowed');
        e.protocolTypeArgMustBeTypeParam = () => w('Diagnostic.protocolTypeArgMustBeTypeParam');
        e.protocolUnsafeOverlap = () => new v(w('Diagnostic.protocolUnsafeOverlap'));
        e.protocolVarianceContravariant = () => new v(w('Diagnostic.protocolVarianceContravariant'));
        e.protocolVarianceCovariant = () => new v(w('Diagnostic.protocolVarianceCovariant'));
        e.protocolVarianceInvariant = () => new v(w('Diagnostic.protocolVarianceInvariant'));
        e.pyrightCommentInvalidDiagnosticBoolValue = () => w('Diagnostic.pyrightCommentInvalidDiagnosticBoolValue');
        e.pyrightCommentInvalidDiagnosticSeverityValue = () => w('Diagnostic.pyrightCommentInvalidDiagnosticSeverityValue');
        e.pyrightCommentMissingDirective = () => w('Diagnostic.pyrightCommentMissingDirective');
        e.pyrightCommentNotOnOwnLine = () => w('Diagnostic.pyrightCommentNotOnOwnLine');
        e.pyrightCommentUnknownDirective = () => new v(w('Diagnostic.pyrightCommentUnknownDirective'));
        e.pyrightCommentUnknownDiagnosticRule = () => new v(w('Diagnostic.pyrightCommentUnknownDiagnosticRule'));
        e.readOnlyArgCount = () => w('Diagnostic.readOnlyArgCount');
        e.readOnlyNotInTypedDict = () => w('Diagnostic.readOnlyNotInTypedDict');
        e.recursiveDefinition = () => new v(w('Diagnostic.recursiveDefinition'));
        e.relativeImportNotAllowed = () => w('Diagnostic.relativeImportNotAllowed');
        e.requiredArgCount = () => w('Diagnostic.requiredArgCount');
        e.requiredNotInTypedDict = () => w('Diagnostic.requiredNotInTypedDict');
        e.returnInAsyncGenerator = () => w('Diagnostic.returnInAsyncGenerator');
        e.returnMissing = () => new v(w('Diagnostic.returnMissing'));
        e.returnInExceptionGroup = () => w('Diagnostic.returnInExceptionGroup');
        e.returnOutsideFunction = () => w('Diagnostic.returnOutsideFunction');
        e.returnTypeContravariant = () => w('Diagnostic.returnTypeContravariant');
        e.returnTypeMismatch = () => new v(w('Diagnostic.returnTypeMismatch'));
        e.returnTypeUnknown = () => w('Diagnostic.returnTypeUnknown');
        e.returnTypePartiallyUnknown = () => new v(w('Diagnostic.returnTypePartiallyUnknown'));
        e.revealLocalsArgs = () => w('Diagnostic.revealLocalsArgs');
        e.revealLocalsNone = () => w('Diagnostic.revealLocalsNone');
        e.revealTypeArgs = () => w('Diagnostic.revealTypeArgs');
        e.revealTypeExpectedTextArg = () => w('Diagnostic.revealTypeExpectedTextArg');
        e.revealTypeExpectedTextMismatch = () => new v(w('Diagnostic.revealTypeExpectedTextMismatch'));
        e.revealTypeExpectedTypeMismatch = () => new v(w('Diagnostic.revealTypeExpectedTypeMismatch'));
        e.selfTypeContext = () => w('Diagnostic.selfTypeContext');
        e.selfTypeMetaclass = () => w('Diagnostic.selfTypeMetaclass');
        e.selfTypeWithTypedSelfOrCls = () => w('Diagnostic.selfTypeWithTypedSelfOrCls');
        e.setterGetterTypeMismatch = () => w('Diagnostic.setterGetterTypeMismatch');
        e.starPatternInAsPattern = () => w('Diagnostic.starPatternInAsPattern');
        e.starPatternInOrPattern = () => w('Diagnostic.starPatternInOrPattern');
        e.singleOverload = () => new v(w('Diagnostic.singleOverload'));
        e.slotsAttributeError = () => new v(w('Diagnostic.slotsAttributeError'));
        e.slotsClassVarConflict = () => new v(w('Diagnostic.slotsClassVarConflict'));
        e.starStarWildcardNotAllowed = () => w('Diagnostic.starStarWildcardNotAllowed');
        e.staticClsSelfParam = () => w('Diagnostic.staticClsSelfParam');
        e.stdlibModuleOverridden = () => new v(w('Diagnostic.stdlibModuleOverridden'));
        e.stringNonAsciiBytes = () => w('Diagnostic.stringNonAsciiBytes');
        e.stringNotSubscriptable = () => w('Diagnostic.stringNotSubscriptable');
        e.stringUnsupportedEscape = () => w('Diagnostic.stringUnsupportedEscape');
        e.stringUnterminated = () => w('Diagnostic.stringUnterminated');
        e.stubFileMissing = () => new v(w('Diagnostic.stubFileMissing'));
        e.stubUsesGetAttr = () => w('Diagnostic.stubUsesGetAttr');
        e.sublistParamsIncompatible = () => w('Diagnostic.sublistParamsIncompatible');
        e.superCallArgCount = () => w('Diagnostic.superCallArgCount');
        e.superCallFirstArg = () => new v(w('Diagnostic.superCallFirstArg'));
        e.superCallSecondArg = () => new v(w('Diagnostic.superCallSecondArg'));
        e.superCallZeroArgForm = () => w('Diagnostic.superCallZeroArgForm');
        e.superCallZeroArgFormStaticMethod = () => w('Diagnostic.superCallZeroArgFormStaticMethod');
        e.symbolIsUnbound = () => new v(w('Diagnostic.symbolIsUnbound'));
        e.symbolIsUndefined = () => new v(w('Diagnostic.symbolIsUndefined'));
        e.symbolIsPossiblyUnbound = () => new v(w('Diagnostic.symbolIsPossiblyUnbound'));
        e.symbolOverridden = () => new v(w('Diagnostic.symbolOverridden'));
        e.ternaryNotAllowed = () => w('Diagnostic.ternaryNotAllowed');
        e.totalOrderingMissingMethod = () => w('Diagnostic.totalOrderingMissingMethod');
        e.trailingCommaInFromImport = () => w('Diagnostic.trailingCommaInFromImport');
        e.tryWithoutExcept = () => w('Diagnostic.tryWithoutExcept');
        e.tupleAssignmentMismatch = () => new v(w('Diagnostic.tupleAssignmentMismatch'));
        e.tupleInAnnotation = () => w('Diagnostic.tupleInAnnotation');
        e.tupleIndexOutOfRange = () => new v(w('Diagnostic.tupleIndexOutOfRange'));
        e.typeAliasIllegalExpressionForm = () => w('Diagnostic.typeAliasIllegalExpressionForm');
        e.typeAliasIsRecursiveDirect = () => new v(w('Diagnostic.typeAliasIsRecursiveDirect'));
        e.typeAliasNotInModuleOrClass = () => w('Diagnostic.typeAliasNotInModuleOrClass');
        e.typeAliasRedeclared = () => new v(w('Diagnostic.typeAliasRedeclared'));
        e.typeAliasStatementIllegal = () => w('Diagnostic.typeAliasStatementIllegal');
        e.typeAliasStatementBadScope = () => w('Diagnostic.typeAliasStatementBadScope');
        e.typeAliasTypeBaseClass = () => w('Diagnostic.typeAliasTypeBaseClass');
        e.typeAliasTypeMustBeAssigned = () => w('Diagnostic.typeAliasTypeMustBeAssigned');
        e.typeAliasTypeNameArg = () => w('Diagnostic.typeAliasTypeNameArg');
        e.typeAliasTypeNameMismatch = () => w('Diagnostic.typeAliasTypeNameMismatch');
        e.typeAliasTypeParamInvalid = () => w('Diagnostic.typeAliasTypeParamInvalid');
        e.typeAnnotationCall = () => w('Diagnostic.typeAnnotationCall');
        e.typeAnnotationVariable = () => w('Diagnostic.typeAnnotationVariable');
        e.typeAnnotationWithCallable = () => w('Diagnostic.typeAnnotationWithCallable');
        e.typeArgListExpected = () => w('Diagnostic.typeArgListExpected');
        e.typeArgListNotAllowed = () => w('Diagnostic.typeArgListNotAllowed');
        e.typeArgsExpectingNone = () => new v(w('Diagnostic.typeArgsExpectingNone'));
        e.typeArgsMismatchOne = () => new v(w('Diagnostic.typeArgsMismatchOne'));
        e.typeArgsMissingForAlias = () => new v(w('Diagnostic.typeArgsMissingForAlias'));
        e.typeArgsMissingForClass = () => new v(w('Diagnostic.typeArgsMissingForClass'));
        e.typeArgsTooFew = () => new v(w('Diagnostic.typeArgsTooFew'));
        e.typeArgsTooMany = () => new v(w('Diagnostic.typeArgsTooMany'));
        e.typeAssignmentMismatch = () => new v(w('Diagnostic.typeAssignmentMismatch'));
        e.typeAssignmentMismatchWildcard = () => new v(w('Diagnostic.typeAssignmentMismatchWildcard'));
        e.typeCallNotAllowed = () => w('Diagnostic.typeCallNotAllowed');
        e.typeCheckOnly = () => new v(w('Diagnostic.typeCheckOnly'));
        e.typeCommentDeprecated = () => w('Diagnostic.typeCommentDeprecated');
        e.typedDictAccess = () => w('Diagnostic.typedDictAccess');
        e.typedDictAssignedName = () => new v(w('Diagnostic.typedDictAssignedName'));
        e.typedDictBadVar = () => w('Diagnostic.typedDictBadVar');
        e.typedDictBaseClass = () => w('Diagnostic.typedDictBaseClass');
        e.typedDictBoolParam = () => new v(w('Diagnostic.typedDictBoolParam'));
        e.typedDictClosedExtras = () => new v(w('Diagnostic.typedDictClosedExtras'));
        e.typedDictClosedNoExtras = () => new v(w('Diagnostic.typedDictClosedNoExtras'));
        e.typedDictDelete = () => w('Diagnostic.typedDictDelete');
        e.typedDictEmptyName = () => w('Diagnostic.typedDictEmptyName');
        e.typedDictEntryName = () => w('Diagnostic.typedDictEntryName');
        e.typedDictEntryUnique = () => w('Diagnostic.typedDictEntryUnique');
        e.typedDictExtraArgs = () => w('Diagnostic.typedDictExtraArgs');
        e.typedDictExtraItemsClosed = () => w('Diagnostic.typedDictExtraItemsClosed');
        e.typedDictFieldNotRequiredRedefinition = () => new v(w('Diagnostic.typedDictFieldNotRequiredRedefinition'));
        e.typedDictFieldReadOnlyRedefinition = () => new v(w('Diagnostic.typedDictFieldReadOnlyRedefinition'));
        e.typedDictFieldRequiredRedefinition = () => new v(w('Diagnostic.typedDictFieldRequiredRedefinition'));
        e.typedDictFirstArg = () => w('Diagnostic.typedDictFirstArg');
        e.typedDictInClassPattern = () => w('Diagnostic.typedDictInClassPattern');
        e.typedDictInitsubclassParameter = () => new v(w('Diagnostic.typedDictInitsubclassParameter'));
        e.typedDictNotAllowed = () => w('Diagnostic.typedDictNotAllowed');
        e.typedDictSecondArgDict = () => w('Diagnostic.typedDictSecondArgDict');
        e.typedDictSecondArgDictEntry = () => w('Diagnostic.typedDictSecondArgDictEntry');
        e.typedDictSet = () => w('Diagnostic.typedDictSet');
        e.typeExpectedClass = () => new v(w('Diagnostic.typeExpectedClass'));
        e.typeFormArgs = () => w('Diagnostic.typeFormArgs');
        e.typeGuardArgCount = () => w('Diagnostic.typeGuardArgCount');
        e.typeGuardParamCount = () => w('Diagnostic.typeGuardParamCount');
        e.typeIsReturnType = () => new v(w('Diagnostic.typeIsReturnType'));
        e.typeNotAwaitable = () => new v(w('Diagnostic.typeNotAwaitable'));
        e.typeNotIntantiable = () => new v(w('Diagnostic.typeNotIntantiable'));
        e.typeNotIterable = () => new v(w('Diagnostic.typeNotIterable'));
        e.typeNotSpecializable = () => new v(w('Diagnostic.typeNotSpecializable'));
        e.typeNotSubscriptable = () => new v(w('Diagnostic.typeNotSubscriptable'));
        e.typeNotUsableWith = () => new v(w('Diagnostic.typeNotUsableWith'));
        e.typeNotSupportBinaryOperator = () => new v(w('Diagnostic.typeNotSupportBinaryOperator'));
        e.typeNotSupportBinaryOperatorBidirectional = () => new v(w('Diagnostic.typeNotSupportBinaryOperatorBidirectional'));
        e.typeNotSupportUnaryOperator = () => new v(w('Diagnostic.typeNotSupportUnaryOperator'));
        e.typeNotSupportUnaryOperatorBidirectional = () => new v(w('Diagnostic.typeNotSupportUnaryOperatorBidirectional'));
        e.typeParameterBoundNotAllowed = () => w('Diagnostic.typeParameterBoundNotAllowed');
        e.typeParameterConstraintTuple = () => w('Diagnostic.typeParameterConstraintTuple');
        e.typeParameterExistingTypeParameter = () => new v(w('Diagnostic.typeParameterExistingTypeParameter'));
        e.typeParametersMissing = () => w('Diagnostic.typeParametersMissing');
        e.typeParameterNotDeclared = () => new v(w('Diagnostic.typeParameterNotDeclared'));
        e.typePartiallyUnknown = () => new v(w('Diagnostic.typePartiallyUnknown'));
        e.typeUnknown = () => new v(w('Diagnostic.typeUnknown'));
        e.typeVarAssignedName = () => new v(w('Diagnostic.typeVarAssignedName'));
        e.typeVarAssignmentMismatch = () => new v(w('Diagnostic.typeVarAssignmentMismatch'));
        e.typeVarBoundAndConstrained = () => w('Diagnostic.typeVarBoundAndConstrained');
        e.typeVarBoundGeneric = () => w('Diagnostic.typeVarBoundGeneric');
        e.typeVarConstraintGeneric = () => w('Diagnostic.typeVarConstraintGeneric');
        e.typeVarDefaultBoundMismatch = () => w('Diagnostic.typeVarDefaultBoundMismatch');
        e.typeVarDefaultConstraintMismatch = () => w('Diagnostic.typeVarDefaultConstraintMismatch');
        e.typeVarDefaultIllegal = () => w('Diagnostic.typeVarDefaultIllegal');
        e.typeVarDefaultInvalidTypeVar = () => new v(w('Diagnostic.typeVarDefaultInvalidTypeVar'));
        e.typeVarFirstArg = () => w('Diagnostic.typeVarFirstArg');
        e.typeVarInvalidForMemberVariable = () => new v(w('Diagnostic.typeVarInvalidForMemberVariable'));
        e.typeVarNoMember = () => new v(w('Diagnostic.typeVarNoMember'));
        e.typeVarNotSubscriptable = () => new v(w('Diagnostic.typeVarNotSubscriptable'));
        e.typeVarNotUsedByOuterScope = () => new v(w('Diagnostic.typeVarNotUsedByOuterScope'));
        e.typeVarPossiblyUnsolvable = () => new v(w('Diagnostic.typeVarPossiblyUnsolvable'));
        e.typeVarSingleConstraint = () => w('Diagnostic.typeVarSingleConstraint');
        e.typeVarsNotInGenericOrProtocol = () => w('Diagnostic.typeVarsNotInGenericOrProtocol');
        e.typeVarTupleContext = () => w('Diagnostic.typeVarTupleContext');
        e.typeVarTupleDefaultNotUnpacked = () => w('Diagnostic.typeVarTupleDefaultNotUnpacked');
        e.typeVarTupleMustBeUnpacked = () => w('Diagnostic.typeVarTupleMustBeUnpacked');
        e.typeVarTupleConstraints = () => w('Diagnostic.typeVarTupleConstraints');
        e.typeVarTupleUnknownParam = () => new v(w('Diagnostic.typeVarTupleUnknownParam'));
        e.typeVarUnknownParam = () => new v(w('Diagnostic.typeVarUnknownParam'));
        e.typeVarUsedByOuterScope = () => new v(w('Diagnostic.typeVarUsedByOuterScope'));
        e.typeVarUsedOnlyOnce = () => new v(w('Diagnostic.typeVarUsedOnlyOnce'));
        e.typeVarVariance = () => w('Diagnostic.typeVarVariance');
        e.typeVarWithDefaultFollowsVariadic = () => new v(w('Diagnostic.typeVarWithDefaultFollowsVariadic'));
        e.typeVarWithoutDefault = () => new v(w('Diagnostic.typeVarWithoutDefault'));
        e.unaccessedClass = () => new v(w('Diagnostic.unaccessedClass'));
        e.unaccessedFunction = () => new v(w('Diagnostic.unaccessedFunction'));
        e.unaccessedImport = () => new v(w('Diagnostic.unaccessedImport'));
        e.unaccessedSymbol = () => new v(w('Diagnostic.unaccessedSymbol'));
        e.unaccessedVariable = () => new v(w('Diagnostic.unaccessedVariable'));
        e.unannotatedFunctionSkipped = () => new v(w('Diagnostic.unannotatedFunctionSkipped'));
        e.unaryOperationNotAllowed = () => w('Diagnostic.unaryOperationNotAllowed');
        e.unexpectedAsyncToken = () => w('Diagnostic.unexpectedAsyncToken');
        e.unexpectedExprToken = () => w('Diagnostic.unexpectedExprToken');
        e.unexpectedIndent = () => w('Diagnostic.unexpectedIndent');
        e.unexpectedUnindent = () => w('Diagnostic.unexpectedUnindent');
        e.unhashableDictKey = () => w('Diagnostic.unhashableDictKey');
        e.unhashableSetEntry = () => w('Diagnostic.unhashableSetEntry');
        e.unionForwardReferenceNotAllowed = () => w('Diagnostic.unionForwardReferenceNotAllowed');
        e.unionSyntaxIllegal = () => w('Diagnostic.unionSyntaxIllegal');
        e.unionTypeArgCount = () => w('Diagnostic.unionTypeArgCount');
        e.uninitializedAbstractVariables = () => new v(w('Diagnostic.uninitializedAbstractVariables'));
        e.uninitializedInstanceVariable = () => new v(w('Diagnostic.uninitializedInstanceVariable'));
        e.unionUnpackedTuple = () => w('Diagnostic.unionUnpackedTuple');
        e.unionUnpackedTypeVarTuple = () => w('Diagnostic.unionUnpackedTypeVarTuple');
        e.unnecessaryCast = () => new v(w('Diagnostic.unnecessaryCast'));
        e.unnecessaryIsInstanceAlways = () => new v(w('Diagnostic.unnecessaryIsInstanceAlways'));
        e.unnecessaryIsSubclassAlways = () => new v(w('Diagnostic.unnecessaryIsSubclassAlways'));
        e.unnecessaryIsInstanceNever = () => new v(w('Diagnostic.unnecessaryIsInstanceNever'));
        e.unnecessaryIsSubclassNever = () => new v(w('Diagnostic.unnecessaryIsSubclassNever'));
        e.unnecessaryPyrightIgnore = () => w('Diagnostic.unnecessaryPyrightIgnore');
        e.unnecessaryPyrightIgnoreRule = () => new v(w('Diagnostic.unnecessaryPyrightIgnoreRule'));
        e.unnecessaryTypeIgnore = () => w('Diagnostic.unnecessaryTypeIgnore');
        e.unpackArgCount = () => w('Diagnostic.unpackArgCount');
        e.unpackedArgInTypeArgument = () => w('Diagnostic.unpackedArgInTypeArgument');
        e.unpackedArgWithVariadicParam = () => w('Diagnostic.unpackedArgWithVariadicParam');
        e.unpackedDictArgumentNotMapping = () => w('Diagnostic.unpackedDictArgumentNotMapping');
        e.unpackedDictSubscriptIllegal = () => w('Diagnostic.unpackedDictSubscriptIllegal');
        e.unpackedSubscriptIllegal = () => w('Diagnostic.unpackedSubscriptIllegal');
        e.unpackedTypedDictArgument = () => w('Diagnostic.unpackedTypedDictArgument');
        e.unpackedTypeVarTupleExpected = () => new v(w('Diagnostic.unpackedTypeVarTupleExpected'));
        e.unpackExpectedTypedDict = () => w('Diagnostic.unpackExpectedTypedDict');
        e.unpackExpectedTypeVarTuple = () => w('Diagnostic.unpackExpectedTypeVarTuple');
        e.unpackIllegalInComprehension = () => w('Diagnostic.unpackIllegalInComprehension');
        e.unpackInAnnotation = () => w('Diagnostic.unpackInAnnotation');
        e.unpackInDict = () => w('Diagnostic.unpackInDict');
        e.unpackInSet = () => w('Diagnostic.unpackInSet');
        e.unpackNotAllowed = () => w('Diagnostic.unpackNotAllowed');
        e.unpackOperatorNotAllowed = () => w('Diagnostic.unpackOperatorNotAllowed');
        e.unpackTuplesIllegal = () => w('Diagnostic.unpackTuplesIllegal');
        e.unreachableCode = () => w('Diagnostic.unreachableCode');
        e.unreachableCodeType = () => w('Diagnostic.unreachableCodeType');
        e.unreachableExcept = () => w('Diagnostic.unreachableExcept');
        e.unsupportedDunderAllOperation = () => w('Diagnostic.unsupportedDunderAllOperation');
        e.unusedCallResult = () => new v(w('Diagnostic.unusedCallResult'));
        e.unusedCoroutine = () => w('Diagnostic.unusedCoroutine');
        e.unusedExpression = () => w('Diagnostic.unusedExpression');
        e.varAnnotationIllegal = () => w('Diagnostic.varAnnotationIllegal');
        e.variableFinalOverride = () => new v(w('Diagnostic.variableFinalOverride'));
        e.variadicTypeArgsTooMany = () => w('Diagnostic.variadicTypeArgsTooMany');
        e.variadicTypeParamTooManyAlias = () => new v(w('Diagnostic.variadicTypeParamTooManyAlias'));
        e.variadicTypeParamTooManyClass = () => new v(w('Diagnostic.variadicTypeParamTooManyClass'));
        e.walrusIllegal = () => w('Diagnostic.walrusIllegal');
        e.walrusNotAllowed = () => w('Diagnostic.walrusNotAllowed');
        e.wildcardInFunction = () => w('Diagnostic.wildcardInFunction');
        e.wildcardPatternTypeUnknown = () => w('Diagnostic.wildcardPatternTypeUnknown');
        e.wildcardPatternTypePartiallyUnknown = () => w('Diagnostic.wildcardPatternTypePartiallyUnknown');
        e.wildcardLibraryImport = () => w('Diagnostic.wildcardLibraryImport');
        e.yieldFromIllegal = () => w('Diagnostic.yieldFromIllegal');
        e.yieldFromOutsideAsync = () => w('Diagnostic.yieldFromOutsideAsync');
        e.yieldOutsideFunction = () => w('Diagnostic.yieldOutsideFunction');
        e.yieldWithinComprehension = () => w('Diagnostic.yieldWithinComprehension');
        e.zeroCaseStatementsFound = () => w('Diagnostic.zeroCaseStatementsFound');
        e.zeroLengthTupleNotAllowed = () => w('Diagnostic.zeroLengthTupleNotAllowed');
      })(t = e.Diagnostic ||= {});
      (function (e) {
        e.annotatedNotAllowed = () => w('DiagnosticAddendum.annotatedNotAllowed');
        e.argParam = () => new v(w('DiagnosticAddendum.argParam'));
        e.argParamFunction = () => new v(w('DiagnosticAddendum.argParamFunction'));
        e.argsParamMissing = () => new v(w('DiagnosticAddendum.argsParamMissing'));
        e.argsPositionOnly = () => new v(w('DiagnosticAddendum.argsPositionOnly'));
        e.argumentType = () => new v(w('DiagnosticAddendum.argumentType'));
        e.argumentTypes = () => new v(w('DiagnosticAddendum.argumentTypes'));
        e.assignToNone = () => w('DiagnosticAddendum.assignToNone');
        e.asyncHelp = () => w('DiagnosticAddendum.asyncHelp');
        e.baseClassIncompatible = () => new v(w('DiagnosticAddendum.baseClassIncompatible'));
        e.baseClassIncompatibleSubclass = () => new v(w('DiagnosticAddendum.baseClassIncompatibleSubclass'));
        e.baseClassOverriddenType = () => new v(w('DiagnosticAddendum.baseClassOverriddenType'));
        e.baseClassOverridesType = () => new v(w('DiagnosticAddendum.baseClassOverridesType'));
        e.bytesTypePromotions = () => w('DiagnosticAddendum.bytesTypePromotions');
        e.conditionalRequiresBool = () => new v(w('DiagnosticAddendum.conditionalRequiresBool'));
        e.dataClassFrozen = () => new v(w('DiagnosticAddendum.dataClassFrozen'));
        e.dataClassFieldLocation = () => w('DiagnosticAddendum.dataClassFieldLocation');
        e.dataProtocolUnsupported = () => new v(w('DiagnosticAddendum.dataProtocolUnsupported'));
        e.descriptorAccessBindingFailed = () => new v(w('DiagnosticAddendum.descriptorAccessBindingFailed'));
        e.descriptorAccessCallFailed = () => new v(w('DiagnosticAddendum.descriptorAccessCallFailed'));
        e.finalMethod = () => w('DiagnosticAddendum.finalMethod');
        e.functionParamDefaultMissing = () => new v(w('DiagnosticAddendum.functionParamDefaultMissing'));
        e.functionParamName = () => new v(w('DiagnosticAddendum.functionParamName'));
        e.functionParamPositionOnly = () => new v(w('DiagnosticAddendum.functionParamPositionOnly'));
        e.functionReturnTypeMismatch = () => new v(w('DiagnosticAddendum.functionReturnTypeMismatch'));
        e.functionTooFewParams = () => new v(w('DiagnosticAddendum.functionTooFewParams'));
        e.genericClassNotAllowed = () => w('DiagnosticAddendum.genericClassNotAllowed');
        e.incompatibleGetter = () => w('DiagnosticAddendum.incompatibleGetter');
        e.incompatibleSetter = () => w('DiagnosticAddendum.incompatibleSetter');
        e.incompatibleDeleter = () => w('DiagnosticAddendum.incompatibleDeleter');
        e.initMethodLocation = () => new v(w('DiagnosticAddendum.initMethodLocation'));
        e.initMethodSignature = () => new v(w('DiagnosticAddendum.initMethodSignature'));
        e.initSubclassLocation = () => new v(w('DiagnosticAddendum.initSubclassLocation'));
        e.invariantSuggestionDict = () => w('DiagnosticAddendum.invariantSuggestionDict');
        e.invariantSuggestionList = () => w('DiagnosticAddendum.invariantSuggestionList');
        e.invariantSuggestionSet = () => w('DiagnosticAddendum.invariantSuggestionSet');
        e.isinstanceClassNotSupported = () => new v(w('DiagnosticAddendum.isinstanceClassNotSupported'));
        e.functionTooManyParams = () => new v(w('DiagnosticAddendum.functionTooManyParams'));
        e.keyNotRequired = () => new v(w('DiagnosticAddendum.keyNotRequired'));
        e.keyReadOnly = () => new v(w('DiagnosticAddendum.keyReadOnly'));
        e.keyRequiredDeleted = () => new v(w('DiagnosticAddendum.keyRequiredDeleted'));
        e.keyUndefined = () => new v(w('DiagnosticAddendum.keyUndefined'));
        e.kwargsParamMissing = () => new v(w('DiagnosticAddendum.kwargsParamMissing'));
        e.listAssignmentMismatch = () => new v(w('DiagnosticAddendum.listAssignmentMismatch'));
        e.literalAssignmentMismatch = () => new v(w('DiagnosticAddendum.literalAssignmentMismatch'));
        e.matchIsNotExhaustiveType = () => new v(w('DiagnosticAddendum.matchIsNotExhaustiveType'));
        e.matchIsNotExhaustiveHint = () => w('DiagnosticAddendum.matchIsNotExhaustiveHint');
        e.memberAssignment = () => new v(w('DiagnosticAddendum.memberAssignment'));
        e.memberIsAbstract = () => new v(w('DiagnosticAddendum.memberIsAbstract'));
        e.memberIsAbstractMore = () => new v(w('DiagnosticAddendum.memberIsAbstractMore'));
        e.memberIsClassVarInProtocol = () => new v(w('DiagnosticAddendum.memberIsClassVarInProtocol'));
        e.memberIsInitVar = () => new v(w('DiagnosticAddendum.memberIsInitVar'));
        e.memberIsInvariant = () => new v(w('DiagnosticAddendum.memberIsInvariant'));
        e.memberIsNotClassVarInClass = () => new v(w('DiagnosticAddendum.memberIsNotClassVarInClass'));
        e.memberIsNotClassVarInProtocol = () => new v(w('DiagnosticAddendum.memberIsNotClassVarInProtocol'));
        e.memberIsNotReadOnlyInProtocol = () => new v(w('DiagnosticAddendum.memberIsNotReadOnlyInProtocol'));
        e.memberIsReadOnlyInProtocol = () => new v(w('DiagnosticAddendum.memberIsReadOnlyInProtocol'));
        e.memberIsWritableInProtocol = () => new v(w('DiagnosticAddendum.memberIsWritableInProtocol'));
        e.memberSetClassVar = () => new v(w('DiagnosticAddendum.memberSetClassVar'));
        e.memberTypeMismatch = () => new v(w('DiagnosticAddendum.memberTypeMismatch'));
        e.memberUnknown = () => new v(w('DiagnosticAddendum.memberUnknown'));
        e.metaclassConflict = () => new v(w('DiagnosticAddendum.metaclassConflict'));
        e.missingGetter = () => w('DiagnosticAddendum.missingGetter');
        e.missingSetter = () => w('DiagnosticAddendum.missingSetter');
        e.missingDeleter = () => w('DiagnosticAddendum.missingDeleter');
        e.namedParamMissingInDest = () => new v(w('DiagnosticAddendum.namedParamMissingInDest'));
        e.namedParamMissingInSource = () => new v(w('DiagnosticAddendum.namedParamMissingInSource'));
        e.namedParamTypeMismatch = () => new v(w('DiagnosticAddendum.namedParamTypeMismatch'));
        e.namedTupleNotAllowed = () => w('DiagnosticAddendum.namedTupleNotAllowed');
        e.newMethodLocation = () => new v(w('DiagnosticAddendum.newMethodLocation'));
        e.newMethodSignature = () => new v(w('DiagnosticAddendum.newMethodSignature'));
        e.noneNotAllowed = () => w('DiagnosticAddendum.noneNotAllowed');
        e.newTypeClassNotAllowed = () => w('DiagnosticAddendum.newTypeClassNotAllowed');
        e.noOverloadAssignable = () => new v(w('DiagnosticAddendum.noOverloadAssignable'));
        e.orPatternMissingName = () => new v(w('DiagnosticAddendum.orPatternMissingName'));
        e.overloadIndex = () => new v(w('DiagnosticAddendum.overloadIndex'));
        e.overloadSignature = () => w('DiagnosticAddendum.overloadSignature');
        e.overloadNotAssignable = () => new v(w('DiagnosticAddendum.overloadNotAssignable'));
        e.overriddenMethod = () => w('DiagnosticAddendum.overriddenMethod');
        e.overriddenSymbol = () => w('DiagnosticAddendum.overriddenSymbol');
        e.overrideIsInvariant = () => w('DiagnosticAddendum.overrideIsInvariant');
        e.overrideInvariantMismatch = () => new v(w('DiagnosticAddendum.overrideInvariantMismatch'));
        e.overrideNoOverloadMatches = () => w('DiagnosticAddendum.overrideNoOverloadMatches');
        e.overrideNotClassMethod = () => w('DiagnosticAddendum.overrideNotClassMethod');
        e.overrideNotInstanceMethod = () => w('DiagnosticAddendum.overrideNotInstanceMethod');
        e.overrideNotStaticMethod = () => w('DiagnosticAddendum.overrideNotStaticMethod');
        e.overrideOverloadNoMatch = () => w('DiagnosticAddendum.overrideOverloadNoMatch');
        e.overrideOverloadOrder = () => w('DiagnosticAddendum.overrideOverloadOrder');
        e.overrideParamKeywordNoDefault = () => new v(w('DiagnosticAddendum.overrideParamKeywordNoDefault'));
        e.overrideParamKeywordType = () => new v(w('DiagnosticAddendum.overrideParamKeywordType'));
        e.overrideParamName = () => new v(w('DiagnosticAddendum.overrideParamName'));
        e.overrideParamNameExtra = () => new v(w('DiagnosticAddendum.overrideParamNameExtra'));
        e.overrideParamNameMissing = () => new v(w('DiagnosticAddendum.overrideParamNameMissing'));
        e.overrideParamNamePositionOnly = () => new v(w('DiagnosticAddendum.overrideParamNamePositionOnly'));
        e.overrideParamNoDefault = () => new v(w('DiagnosticAddendum.overrideParamNoDefault'));
        e.overrideParamType = () => new v(w('DiagnosticAddendum.overrideParamType'));
        e.overridePositionalParamCount = () => new v(w('DiagnosticAddendum.overridePositionalParamCount'));
        e.overrideReturnType = () => new v(w('DiagnosticAddendum.overrideReturnType'));
        e.overrideType = () => new v(w('DiagnosticAddendum.overrideType'));
        e.paramAssignment = () => new v(w('DiagnosticAddendum.paramAssignment'));
        e.paramSpecMissingInOverride = () => w('DiagnosticAddendum.paramSpecMissingInOverride');
        e.paramType = () => new v(w('DiagnosticAddendum.paramType'));
        e.privateImportFromPyTypedSource = () => new v(w('DiagnosticAddendum.privateImportFromPyTypedSource'));
        e.propertyAccessFromProtocolClass = () => w('DiagnosticAddendum.propertyAccessFromProtocolClass');
        e.propertyMethodIncompatible = () => new v(w('DiagnosticAddendum.propertyMethodIncompatible'));
        e.propertyMethodMissing = () => new v(w('DiagnosticAddendum.propertyMethodMissing'));
        e.propertyMissingDeleter = () => new v(w('DiagnosticAddendum.propertyMissingDeleter'));
        e.propertyMissingSetter = () => new v(w('DiagnosticAddendum.propertyMissingSetter'));
        e.protocolIncompatible = () => new v(w('DiagnosticAddendum.protocolIncompatible'));
        e.protocolMemberMissing = () => new v(w('DiagnosticAddendum.protocolMemberMissing'));
        e.protocolRequiresRuntimeCheckable = () => w('DiagnosticAddendum.protocolRequiresRuntimeCheckable');
        e.protocolSourceIsNotConcrete = () => new v(w('DiagnosticAddendum.protocolSourceIsNotConcrete'));
        e.protocolUnsafeOverlap = () => new v(w('DiagnosticAddendum.protocolUnsafeOverlap'));
        e.pyrightCommentIgnoreTip = () => w('DiagnosticAddendum.pyrightCommentIgnoreTip');
        e.readOnlyAttribute = () => new v(w('DiagnosticAddendum.readOnlyAttribute'));
        e.seeDeclaration = () => w('DiagnosticAddendum.seeDeclaration');
        e.seeClassDeclaration = () => w('DiagnosticAddendum.seeClassDeclaration');
        e.seeFunctionDeclaration = () => w('DiagnosticAddendum.seeFunctionDeclaration');
        e.seeMethodDeclaration = () => w('DiagnosticAddendum.seeMethodDeclaration');
        e.seeParameterDeclaration = () => w('DiagnosticAddendum.seeParameterDeclaration');
        e.seeTypeAliasDeclaration = () => w('DiagnosticAddendum.seeTypeAliasDeclaration');
        e.seeVariableDeclaration = () => w('DiagnosticAddendum.seeVariableDeclaration');
        e.tupleEntryTypeMismatch = () => new v(w('DiagnosticAddendum.tupleEntryTypeMismatch'));
        e.tupleAssignmentMismatch = () => new v(w('DiagnosticAddendum.tupleAssignmentMismatch'));
        e.tupleSizeIndeterminateSrc = () => new v(w('DiagnosticAddendum.tupleSizeIndeterminateSrc'));
        e.tupleSizeIndeterminateSrcDest = () => new v(w('DiagnosticAddendum.tupleSizeIndeterminateSrcDest'));
        e.tupleSizeMismatch = () => new v(w('DiagnosticAddendum.tupleSizeMismatch'));
        e.tupleSizeMismatchIndeterminateDest = () => new v(w('DiagnosticAddendum.tupleSizeMismatchIndeterminateDest'));
        e.typeAliasInstanceCheck = () => w('DiagnosticAddendum.typeAliasInstanceCheck');
        e.typeAssignmentMismatch = () => new v(w('DiagnosticAddendum.typeAssignmentMismatch'));
        e.typeBound = () => new v(w('DiagnosticAddendum.typeBound'));
        e.typeConstrainedTypeVar = () => new v(w('DiagnosticAddendum.typeConstrainedTypeVar'));
        e.typedDictBaseClass = () => new v(w('DiagnosticAddendum.typedDictBaseClass'));
        e.typedDictClassNotAllowed = () => w('DiagnosticAddendum.typedDictClassNotAllowed');
        e.typedDictExtraFieldNotAllowed = () => new v(w('DiagnosticAddendum.typedDictExtraFieldNotAllowed'));
        e.typedDictExtraFieldTypeMismatch = () => new v(w('DiagnosticAddendum.typedDictExtraFieldTypeMismatch'));
        e.typedDictFieldMissing = () => new v(w('DiagnosticAddendum.typedDictFieldMissing'));
        e.typedDictClosedExtraNotAllowed = () => new v(w('DiagnosticAddendum.typedDictClosedExtraNotAllowed'));
        e.typedDictClosedExtraTypeMismatch = () => new v(w('DiagnosticAddendum.typedDictClosedExtraTypeMismatch'));
        e.typedDictClosedFieldNotRequired = () => new v(w('DiagnosticAddendum.typedDictClosedFieldNotRequired'));
        e.typedDictFieldNotReadOnly = () => new v(w('DiagnosticAddendum.typedDictFieldNotReadOnly'));
        e.typedDictFieldNotRequired = () => new v(w('DiagnosticAddendum.typedDictFieldNotRequired'));
        e.typedDictFieldRequired = () => new v(w('DiagnosticAddendum.typedDictFieldRequired'));
        e.typedDictFieldTypeMismatch = () => new v(w('DiagnosticAddendum.typedDictFieldTypeMismatch'));
        e.typedDictFieldUndefined = () => new v(w('DiagnosticAddendum.typedDictFieldUndefined'));
        e.typedDictFinalMismatch = () => new v(w('DiagnosticAddendum.typedDictFinalMismatch'));
        e.typedDictKeyAccess = () => new v(w('DiagnosticAddendum.typedDictKeyAccess'));
        e.typedDictNotAllowed = () => w('DiagnosticAddendum.typedDictNotAllowed');
        e.typeIncompatible = () => new v(w('DiagnosticAddendum.typeIncompatible'));
        e.typeNotClass = () => new v(w('DiagnosticAddendum.typeNotClass'));
        e.typeParamSpec = () => new v(w('DiagnosticAddendum.typeParamSpec'));
        e.typeNotStringLiteral = () => new v(w('DiagnosticAddendum.typeNotStringLiteral'));
        e.typeOfSymbol = () => new v(w('DiagnosticAddendum.typeOfSymbol'));
        e.typeUnsupported = () => new v(w('DiagnosticAddendum.typeUnsupported'));
        e.typeVarDefaultOutOfScope = () => new v(w('DiagnosticAddendum.typeVarDefaultOutOfScope'));
        e.typeVarIsContravariant = () => new v(w('DiagnosticAddendum.typeVarIsContravariant'));
        e.typeVarIsCovariant = () => new v(w('DiagnosticAddendum.typeVarIsCovariant'));
        e.typeVarIsInvariant = () => new v(w('DiagnosticAddendum.typeVarIsInvariant'));
        e.typeVarsMissing = () => new v(w('DiagnosticAddendum.typeVarsMissing'));
        e.typeVarNotAllowed = () => w('DiagnosticAddendum.typeVarNotAllowed');
        e.typeVarTupleRequiresKnownLength = () => w('DiagnosticAddendum.typeVarTupleRequiresKnownLength');
        e.typeVarUnnecessarySuggestion = () => new v(w('DiagnosticAddendum.typeVarUnnecessarySuggestion'));
        e.typeVarUnsolvableRemedy = () => w('DiagnosticAddendum.typeVarUnsolvableRemedy');
        e.unhashableType = () => new v(w('DiagnosticAddendum.unhashableType'));
        e.uninitializedAbstractVariable = () => new v(w('DiagnosticAddendum.uninitializedAbstractVariable'));
        e.unreachableExcept = () => new v(w('DiagnosticAddendum.unreachableExcept'));
        e.useDictInstead = () => w('DiagnosticAddendum.useDictInstead');
        e.useListInstead = () => w('DiagnosticAddendum.useListInstead');
        e.useTupleInstead = () => w('DiagnosticAddendum.useTupleInstead');
        e.useTypeInstead = () => w('DiagnosticAddendum.useTypeInstead');
        e.varianceMismatchForClass = () => new v(w('DiagnosticAddendum.varianceMismatchForClass'));
        e.varianceMismatchForTypeAlias = () => new v(w('DiagnosticAddendum.varianceMismatchForTypeAlias'));
      })(n = e.DiagnosticAddendum ||= {});
      (function (e) {
        e.createTypeStub = () => w('CodeAction.createTypeStub');
        e.createTypeStubFor = () => new v(w('CodeAction.createTypeStubFor'));
        e.executingCommand = () => w('CodeAction.executingCommand');
        e.filesToAnalyzeOne = () => w('CodeAction.filesToAnalyzeOne');
        e.filesToAnalyzeCount = () => new v(w('CodeAction.filesToAnalyzeCount'));
        e.findingReferences = () => w('CodeAction.findingReferences');
        e.organizeImports = () => w('CodeAction.organizeImports');
        e.renameShadowedFile = () => new v(w('CodeAction.renameShadowedFile'));
      })(a = e.CodeAction ||= {});
      (function (e) {
        e.autoImportDetail = () => w('Completion.autoImportDetail');
        e.indexValueDetail = () => w('Completion.indexValueDetail');
      })(r = e.Completion ||= {});
      (function (e) {
        e.longOperation = () => w('Service.longOperation');
      })(s = e.Service ||= {});
    })(D || (exports.Localizer = D = {}));
    exports.LocMessage = D.Diagnostic;
    exports.LocAddendum = D.DiagnosticAddendum;
  },
  86500: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.run = async function (e, t) {
      await s.initializeDependencies();
      if (r.isMainThread) {
        e(a.createConnection(o()));
      } else {
        t();
      }
    };
    exports.getConnectionOptions = o;
    const a = require(8713);
    const r = require(28167);
    const s = require(64330);
    const i = require(34487);
    function o() {
      return {
        cancellationStrategy: i.getCancellationStrategyFromArgv(process.argv)
      };
    }
  },
  51651: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CharacterStream = undefined;
    const a = require(4794);
    exports.CharacterStream = class {
      constructor(e) {
        this._text = e;
        this._position = 0;
        this._currentChar = e.length > 0 ? e.charCodeAt(0) : 0;
        this._isEndOfStream = e.length === 0;
      }
      get position() {
        return this._position;
      }
      set position(e) {
        this._position = e;
        this._checkBounds();
      }
      get currentChar() {
        return this._currentChar;
      }
      get nextChar() {
        if (this.position + 1 < this._text.length) {
          return this._text.charCodeAt(this.position + 1);
        } else {
          return 0;
        }
      }
      get prevChar() {
        if (this.position - 1 >= 0) {
          return this._text.charCodeAt(this.position - 1);
        } else {
          return 0;
        }
      }
      get length() {
        return this._text.length;
      }
      getText() {
        return this._text;
      }
      getCurrentChar() {
        return this._currentChar;
      }
      isEndOfStream() {
        return this._isEndOfStream;
      }
      lookAhead(e) {
        const t = this._position + e;
        if (t < 0 || t >= this._text.length) {
          return 0;
        } else {
          return this._text.charCodeAt(t);
        }
      }
      advance(e) {
        this.position += e;
      }
      moveNext() {
        if (this._position < this._text.length - 1) {
          this._position += 1;
          this._currentChar = this._text.charCodeAt(this._position);
          return true;
        } else {
          this.advance(1);
          return !this.isEndOfStream();
        }
      }
      isAtWhiteSpace() {
        return a.isWhiteSpace(this.currentChar);
      }
      isAtLineBreak() {
        return a.isLineBreak(this.currentChar);
      }
      skipLineBreak() {
        if (this._currentChar === 13) {
          this.moveNext();
          if (this.currentChar === 10) {
            this.moveNext();
          }
        } else {
          if (this._currentChar === 10) {
            this.moveNext();
          }
        }
      }
      skipWhitespace() {
        while (!this.isEndOfStream() && this.isAtWhiteSpace()) {
          this.moveNext();
        }
      }
      skipToEol() {
        while (!this.isEndOfStream() && !this.isAtLineBreak()) {
          this.moveNext();
        }
      }
      skipToWhitespace() {
        while (!this.isEndOfStream() && !this.isAtWhiteSpace()) {
          this.moveNext();
        }
      }
      charCodeAt(e) {
        return this._text.charCodeAt(e);
      }
      _checkBounds() {
        if (this._position < 0) {
          this._position = 0;
        }
        this._isEndOfStream = this._position >= this._text.length;
        if (this._isEndOfStream) {
          this._position = this._text.length;
        }
        this._currentChar = this._isEndOfStream ? 0 : this._text.charCodeAt(this._position);
      }
    };
  },
  4794: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.isIdentifierStartChar = function (e, t) {
      if (e < l) {
        return p[e] === o.StartIdentifierChar;
      }
      if (!u) {
        _(false);
        u = true;
      }
      let n;
      n = t !== undefined ? y(e, t) : d[e];
      return n === o.StartIdentifierChar;
    };
    exports.isIdentifierChar = function (e, t) {
      if (e < l) {
        return p[e] === o.StartIdentifierChar || p[e] === o.IdentifierChar;
      }
      if (!u) {
        _(false);
        u = true;
      }
      if (t !== undefined) {
        return y(e, t);
      }
      return d[e] === o.StartIdentifierChar || d[e] === o.IdentifierChar;
    };
    exports.isSurrogateChar = function (e) {
      if (e < l) {
        return false;
      }
      if (!u) {
        _(false);
        u = true;
      }
      return d[e] === o.SurrogateChar;
    };
    exports.isWhiteSpace = function (e) {
      return e === 32 || e === 9 || e === 12;
    };
    exports.isLineBreak = function (e) {
      return e === 13 || e === 10;
    };
    exports.isNumber = function (e) {
      return e >= 48 && e <= 57 || e === 95;
    };
    exports.isDecimal = m;
    exports.isHex = function (e) {
      return m(e) || e >= 97 && e <= 102 || e >= 65 && e <= 70 || e === 95;
    };
    exports.isOctal = function (e) {
      return e >= 48 && e <= 55 || e === 95;
    };
    exports.isBinary = function (e) {
      return e === 48 || e === 49 || e === 95;
    };
    const i = __importStar(require(14911));
    var o;
    (function (e) {
      e[e.NotIdentifierChar = 0] = 'NotIdentifierChar';
      e[e.StartIdentifierChar = 1] = 'StartIdentifierChar';
      e[e.IdentifierChar = 2] = 'IdentifierChar';
      e[e.SurrogateChar = 3] = 'SurrogateChar';
    })(o ||= {});
    const l = 256;
    const p = new Array(l);
    const d = {};
    const c = {};
    let u = false;
    function m(e) {
      return e >= 48 && e <= 57 || e === 95;
    }
    function y(e, t) {
      if (d[e] !== o.SurrogateChar) {
        return o.NotIdentifierChar;
      }
      const n = c[e];
      if (n) {
        return n[t];
      } else {
        return o.NotIdentifierChar;
      }
    }
    const g = [[95, 6277, 6278, 8472, 8494, 12443, 12444], i.unicodeLu, i.unicodeLl, i.unicodeLt, i.unicodeLo, i.unicodeLm, i.unicodeNl];
    const h = [i.unicodeLuSurrogate, i.unicodeLlSurrogate, i.unicodeLoSurrogate, i.unicodeLmSurrogate, i.unicodeNlSurrogate];
    const f = [[183, 903, 4969, 4970, 4971, 4972, 4973, 4974, 4975, 4976, 4977, 6618], i.unicodeMn, i.unicodeMc, i.unicodeNd, i.unicodePc];
    const T = [i.unicodeMnSurrogate, i.unicodeMcSurrogate, i.unicodeNdSurrogate];
    function v(e, t, n, a, r) {
      for (let s = 0; s < e.length; s++) {
        const i = e[s];
        let o;
        let p;
        if (Array.isArray(i)) {
          o = i[0];
          p = i[1];
        } else {
          o = p = i;
        }
        for (let e = o; e <= p; e++) {
          if (e < l) {
            a[e] = t;
          } else {
            r[e] = t;
          }
        }
        if (n && o >= l) {
          break;
        }
      }
    }
    function b(e, t) {
      for (const n in e) {
        if (!c[n]) {
          c[n] = {};
          d[n] = o.SurrogateChar;
        }
        v(e[n], t, false, c[n], c[n]);
      }
    }
    function _(e) {
      p.fill(o.NotIdentifierChar);
      f.forEach(t => {
        v(t, o.IdentifierChar, e, p, d);
      });
      g.forEach(t => {
        v(t, o.StartIdentifierChar, e, p, d);
      });
      if (!e) {
        for (const e of T) {
          b(e, o.IdentifierChar);
        }
        for (const e of h) {
          b(e, o.StartIdentifierChar);
        }
      }
    }
    _(true);
  },
  85114: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DictionaryExpandEntryNode = exports.DictionaryKeyEntryNode = exports.DictionaryNode = exports.StringListNode = exports.FormatStringNode = exports.StringNode = exports.NumberNode = exports.EllipsisNode = exports.ConstantNode = exports.NameNode = exports.LambdaNode = exports.MemberAccessNode = exports.YieldFromNode = exports.YieldNode = exports.SliceNode = exports.IndexNode = exports.ComprehensionNode = exports.CallNode = exports.TupleNode = exports.UnpackNode = exports.TernaryNode = exports.AwaitNode = exports.AugmentedAssignmentNode = exports.FunctionAnnotationNode = exports.TypeAnnotationNode = exports.TypeAliasNode = exports.TypeParameterListNode = exports.TypeParameterNode = exports.TypeParamKind = exports.AssignmentNode = exports.AssignmentExpressionNode = exports.BinaryOperationNode = exports.UnaryOperationNode = exports.ErrorNode = exports.StatementListNode = exports.DecoratorNode = exports.WithItemNode = exports.WithNode = exports.ClassNode = exports.ParameterNode = exports.FunctionNode = exports.ExceptNode = exports.TryNode = exports.ComprehensionIfNode = exports.ComprehensionForNode = exports.ForNode = exports.WhileNode = exports.IfNode = exports.SuiteNode = exports.ModuleNode = undefined;
    exports.PatternValueNode = exports.PatternMappingExpandEntryNode = exports.PatternMappingKeyEntryNode = exports.PatternMappingNode = exports.PatternCaptureNode = exports.PatternClassArgumentNode = exports.PatternClassNode = exports.PatternLiteralNode = exports.PatternAsNode = exports.PatternSequenceNode = exports.CaseNode = exports.MatchNode = exports.RaiseNode = exports.ReturnNode = exports.ContinueNode = exports.BreakNode = exports.AssertNode = exports.NonlocalNode = exports.GlobalNode = exports.ImportFromAsNode = exports.ImportFromNode = exports.ImportAsNode = exports.ModuleNameNode = exports.ImportNode = exports.PassNode = exports.DelNode = exports.ArgumentNode = exports.ListNode = exports.SetNode = undefined;
    exports.getNextNodeId = function () {
      return r++;
    };
    exports.extendRange = s;
    exports.isExpressionNode = function (e) {
      switch (e.nodeType) {
        case 0:
        case 55:
        case 7:
        case 4:
        case 54:
        case 6:
        case 51:
        case 56:
        case 52:
        case 9:
        case 11:
        case 27:
        case 46:
        case 60:
        case 61:
        case 35:
        case 33:
        case 38:
        case 14:
        case 21:
        case 40:
        case 49:
        case 30:
        case 48:
        case 18:
        case 34:
        case 45:
          return true;
        default:
          return false;
      }
    };
    const a = require(88754);
    let r = 1;
    function s(e, t) {
      const n = a.TextRange.extend(e, t);
      e.start = n.start;
      e.length = n.length;
    }
    var i;
    var o;
    var l;
    var p;
    var d;
    var c;
    var u;
    var m;
    var y;
    var g;
    var h;
    var f;
    var T;
    var v;
    var b;
    var _;
    var C;
    var I;
    var k;
    var w;
    var S;
    var A;
    var x;
    var P;
    var D;
    var N;
    var F;
    var E;
    var M;
    var O;
    var z;
    var U;
    var V;
    var R;
    var L;
    var B;
    var j;
    var q;
    var G;
    var W;
    var K;
    var $;
    var H;
    var Z;
    var Y;
    var J;
    var Q;
    var X;
    var ee;
    var te;
    var ne;
    var ae;
    var re;
    var se;
    var ie;
    var oe;
    var le;
    var pe;
    var de;
    var ce;
    var ue;
    var me;
    var ye;
    var ge;
    var he;
    var fe;
    var Te;
    var ve;
    var be;
    var _e;
    var Ce;
    var Ie;
    var ke;
    var we;
    var Se;
    var Ae;
    var xe;
    var Pe;
    var De;
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 36,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            statements: []
          }
        };
      };
    })(i || (exports.ModuleNode = i = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 50,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            statements: [],
            typeComment: undefined
          }
        };
      };
    })(o || (exports.SuiteNode = o = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 22,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            testExpr: t,
            ifSuite: n,
            elseSuite: a
          }
        };
        t.parent = i;
        n.parent = i;
        s(i, t);
        s(i, n);
        if (a) {
          s(i, a);
          a.parent = i;
        }
        return i;
      };
    })(l || (exports.IfNode = l = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 57,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            testExpr: t,
            whileSuite: n
          }
        };
        t.parent = a;
        n.parent = a;
        s(a, n);
        return a;
      };
    })(p || (exports.WhileNode = p = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 29,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            targetExpr: t,
            iterableExpr: n,
            forSuite: a
          }
        };
        t.parent = i;
        n.parent = i;
        a.parent = i;
        s(i, a);
        return i;
      };
    })(d || (exports.ForNode = d = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 12,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            targetExpr: t,
            iterableExpr: n
          }
        };
        t.parent = a;
        n.parent = a;
        s(a, t);
        s(a, n);
        return a;
      };
    })(c || (exports.ComprehensionForNode = c = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 13,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            testExpr: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(u || (exports.ComprehensionIfNode = u = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 53,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            trySuite: t,
            exceptClauses: []
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(m || (exports.TryNode = m = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 28,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            exceptSuite: t,
            isExceptGroup: n
          }
        };
        t.parent = a;
        s(a, t);
        return a;
      };
    })(y || (exports.ExceptNode = y = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 31,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            decorators: [],
            isAsync: false,
            name: t,
            typeParams: a,
            params: [],
            returnAnnotation: undefined,
            funcAnnotationComment: undefined,
            suite: n
          }
        };
        t.parent = i;
        n.parent = i;
        if (a) {
          a.parent = i;
        }
        s(i, n);
        return i;
      };
    })(g || (exports.FunctionNode = g = {}));
    (function (e) {
      e.create = function (e, t) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 41,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            category: t,
            name: undefined,
            annotation: undefined,
            annotationComment: undefined,
            defaultValue: undefined
          }
        };
      };
    })(h || (exports.ParameterNode = h = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 10,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            decorators: [],
            name: t,
            typeParams: a,
            arguments: [],
            suite: n
          }
        };
        t.parent = i;
        n.parent = i;
        if (a) {
          a.parent = i;
        }
        s(i, n);
        return i;
      };
      e.createDummyForDecorators = function (e) {
        const t = {
          start: e[0].start,
          length: 0,
          nodeType: 10,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            decorators: e,
            name: {
              start: e[0].start,
              length: 0,
              nodeType: 38,
              id: 0,
              parent: undefined,
              a: undefined,
              d: {
                token: {
                  type: 7,
                  start: 0,
                  length: 0,
                  comments: [],
                  value: ''
                },
                value: ''
              }
            },
            typeParams: undefined,
            arguments: [],
            suite: {
              start: e[0].start,
              length: 0,
              nodeType: 50,
              id: 0,
              parent: undefined,
              a: undefined,
              d: {
                statements: [],
                typeComment: undefined
              }
            }
          }
        };
        e.forEach(e => {
          e.parent = t;
          s(t, e);
        });
        t.d.name.parent = t;
        t.d.suite.parent = t;
        return t;
      };
    })(f || (exports.ClassNode = f = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 58,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            withItems: [],
            suite: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(T || (exports.WithNode = T = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 59,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: e
          }
        };
        e.parent = t;
        return t;
      };
    })(v || (exports.WithItemNode = v = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 16,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(b || (exports.DecoratorNode = b = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 47,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            statements: []
          }
        };
      };
    })(_ || (exports.StatementListNode = _ = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 0,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            category: t,
            child: n,
            decorators: a
          }
        };
        if (n) {
          n.parent = i;
          s(i, n);
        }
        if (a) {
          a.forEach(e => {
            e.parent = i;
          });
          if (a.length > 0) {
            s(i, a[0]);
          }
        }
        return i;
      };
    })(C || (exports.ErrorNode = C = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 55,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            operator: n,
            operatorToken: e,
            expr: t,
            hasParens: false
          }
        };
        t.parent = a;
        s(a, t);
        return a;
      };
    })(I || (exports.UnaryOperationNode = I = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 7,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            operatorToken: n,
            operator: a,
            rightExpr: t,
            hasParens: false
          }
        };
        e.parent = i;
        t.parent = i;
        s(i, t);
        return i;
      };
    })(k || (exports.BinaryOperationNode = k = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 4,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            name: e,
            walrusToken: t,
            rightExpr: n,
            hasParens: false
          }
        };
        e.parent = a;
        n.parent = a;
        s(a, n);
        return a;
      };
    })(w || (exports.AssignmentExpressionNode = w = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 3,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            rightExpr: t
          }
        };
        e.parent = n;
        t.parent = n;
        s(n, t);
        return n;
      };
    })(S || (exports.AssignmentNode = S = {}));
    (function (e) {
      e[e.TypeVar = 0] = 'TypeVar';
      e[e.TypeVarTuple = 1] = 'TypeVarTuple';
      e[e.ParamSpec = 2] = 'ParamSpec';
    })(A || (exports.TypeParamKind = A = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 75,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            name: e,
            typeParamKind: t,
            boundExpr: n,
            defaultExpr: a
          }
        };
        e.parent = i;
        if (n) {
          n.parent = i;
          s(i, n);
        }
        if (a) {
          a.parent = i;
          s(i, a);
        }
        return i;
      };
    })(x || (exports.TypeParameterNode = x = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 76,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            params: n
          }
        };
        s(a, t);
        n.forEach(e => {
          s(a, e);
          e.parent = a;
        });
        return a;
      };
    })(P || (exports.TypeParameterListNode = P = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 77,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            name: t,
            typeParams: a,
            expr: n
          }
        };
        t.parent = i;
        n.parent = i;
        if (a) {
          a.parent = i;
        }
        s(i, n);
        return i;
      };
    })(D || (exports.TypeAliasNode = D = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 54,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            valueExpr: e,
            annotation: t
          }
        };
        e.parent = n;
        t.parent = n;
        s(n, t);
        return n;
      };
    })(N || (exports.TypeAnnotationNode = N = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 62,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            isEllipsis: t,
            paramAnnotations: n,
            returnAnnotation: a
          }
        };
        n.forEach(e => {
          e.parent = i;
        });
        a.parent = i;
        s(i, a);
        return i;
      };
    })(F || (exports.FunctionAnnotationNode = F = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 5,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            operator: n,
            rightExpr: t,
            destExpr: a
          }
        };
        e.parent = i;
        t.parent = i;
        a.parent = i;
        s(i, t);
        return i;
      };
    })(E || (exports.AugmentedAssignmentNode = E = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 6,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t,
            awaitToken: e,
            hasParens: false
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(M || (exports.AwaitNode = M = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 51,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            ifExpr: e,
            testExpr: t,
            elseExpr: n
          }
        };
        e.parent = a;
        t.parent = a;
        n.parent = a;
        s(a, n);
        return a;
      };
    })(O || (exports.TernaryNode = O = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 56,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t,
            starToken: e
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(z || (exports.UnpackNode = z = {}));
    (function (e) {
      e.create = function (e, t) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 52,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            items: [],
            hasParens: t
          }
        };
      };
    })(U || (exports.TupleNode = U = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 9,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            args: t,
            trailingComma: n
          }
        };
        e.parent = a;
        if (t.length > 0) {
          t.forEach(e => {
            e.parent = a;
          });
          s(a, t[t.length - 1]);
        }
        return a;
      };
    })(V || (exports.CallNode = V = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 11,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: e,
            forIfNodes: [],
            isGenerator: t,
            hasParens: false
          }
        };
        e.parent = n;
        return n;
      };
    })(R || (exports.ComprehensionNode = R = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 27,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            items: t,
            trailingComma: n
          }
        };
        e.parent = i;
        t.forEach(e => {
          e.parent = i;
        });
        s(i, a);
        return i;
      };
    })(L || (exports.IndexNode = L = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 46,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(B || (exports.SliceNode = B = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 60,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t
          }
        };
        if (t) {
          t.parent = n;
          s(n, t);
        }
        return n;
      };
    })(j || (exports.YieldNode = j = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 61,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(q || (exports.YieldFromNode = q = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 35,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            member: t
          }
        };
        e.parent = n;
        t.parent = n;
        s(n, t);
        return n;
      };
    })(G || (exports.MemberAccessNode = G = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 33,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            params: [],
            expr: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(W || (exports.LambdaNode = W = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 38,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            token: e,
            value: e.value
          }
        };
      };
    })(K || (exports.NameNode = K = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 14,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            constType: e.keywordType
          }
        };
      };
    })($ || (exports.ConstantNode = $ = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 21,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(H || (exports.EllipsisNode = H = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 40,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            value: e.value,
            isInteger: e.isInteger,
            isImaginary: e.isImaginary
          }
        };
      };
    })(Z || (exports.NumberNode = Z = {}));
    (function (e) {
      e.create = function (e, t) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 49,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            token: e,
            value: t
          }
        };
      };
    })(Y || (exports.StringNode = Y = {}));
    (function (e) {
      e.create = function (e, t, n, a, i) {
        const o = {
          start: e.start,
          length: e.length,
          nodeType: 30,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            token: e,
            middleTokens: n,
            fieldExprs: a,
            formatExprs: i,
            value: ''
          }
        };
        a.forEach(e => {
          e.parent = o;
          s(o, e);
        });
        if (i) {
          i.forEach(e => {
            e.parent = o;
            s(o, e);
          });
        }
        if (t) {
          s(o, t);
        }
        return o;
      };
    })(J || (exports.FormatStringNode = J = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e[0].start,
          length: e[0].length,
          nodeType: 48,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            strings: e,
            annotation: undefined,
            hasParens: false
          }
        };
        if (e.length > 0) {
          e.forEach(e => {
            e.parent = t;
          });
          s(t, e[e.length - 1]);
        }
        return t;
      };
    })(Q || (exports.StringListNode = Q = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 18,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            items: [],
            trailingCommaToken: undefined
          }
        };
      };
    })(X || (exports.DictionaryNode = X = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 20,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            keyExpr: e,
            valueExpr: t
          }
        };
        e.parent = n;
        t.parent = n;
        s(n, t);
        return n;
      };
    })(ee || (exports.DictionaryKeyEntryNode = ee = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 19,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: e
          }
        };
        e.parent = t;
        return t;
      };
    })(te || (exports.DictionaryExpandEntryNode = te = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 45,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            items: []
          }
        };
      };
    })(ne || (exports.SetNode = ne = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 34,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            items: []
          }
        };
      };
    })(ae || (exports.ListNode = ae = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e ? e.start : t.start,
          length: e ? e.length : t.length,
          nodeType: 1,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            argCategory: n,
            name: undefined,
            valueExpr: t,
            isNameSameAsValue: false
          }
        };
        t.parent = a;
        s(a, t);
        return a;
      };
    })(re || (exports.ArgumentNode = re = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 17,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            targets: []
          }
        };
      };
    })(se || (exports.DelNode = se = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 42,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(ie || (exports.PassNode = ie = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 23,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            list: []
          }
        };
      };
    })(oe || (exports.ImportNode = oe = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 37,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leadingDots: 0,
            nameParts: []
          }
        };
      };
    })(le || (exports.ModuleNameNode = le = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 24,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            module: e
          }
        };
        e.parent = t;
        return t;
      };
    })(pe || (exports.ImportAsNode = pe = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 25,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            module: t,
            imports: [],
            isWildcardImport: false,
            usesParens: false
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(de || (exports.ImportFromNode = de = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 26,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            name: e
          }
        };
        e.parent = t;
        return t;
      };
    })(ce || (exports.ImportFromAsNode = ce = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 32,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            targets: []
          }
        };
      };
    })(ue || (exports.GlobalNode = ue = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 39,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            targets: []
          }
        };
      };
    })(me || (exports.NonlocalNode = me = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 2,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            testExpr: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(ye || (exports.AssertNode = ye = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 8,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(ge || (exports.BreakNode = ge = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 15,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(he || (exports.ContinueNode = he = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 44,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(fe || (exports.ReturnNode = fe = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 43,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(Te || (exports.RaiseNode = Te = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 63,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t,
            cases: []
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(ve || (exports.MatchNode = ve = {}));
    (function (e) {
      e.create = function (e, t, n, a, i) {
        const o = {
          start: e.start,
          length: e.length,
          nodeType: 64,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            pattern: t,
            isIrrefutable: n,
            guardExpr: a,
            suite: i
          }
        };
        s(o, i);
        t.parent = o;
        i.parent = o;
        if (a) {
          a.parent = o;
        }
        return o;
      };
    })(be || (exports.CaseNode = be = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = t.findIndex(e => e.d.orPatterns.length === 1 && e.d.orPatterns[0].nodeType === 69 && e.d.orPatterns[0].d.isStar);
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 65,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            entries: t,
            starEntryIndex: n >= 0 ? n : undefined
          }
        };
        if (t.length > 0) {
          s(a, t[t.length - 1]);
        }
        t.forEach(e => {
          e.parent = a;
        });
        return a;
      };
    })(_e || (exports.PatternSequenceNode = _e = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e[0].start,
          length: e[0].length,
          nodeType: 66,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            orPatterns: e,
            target: t
          }
        };
        if (e.length > 1) {
          s(n, e[e.length - 1]);
        }
        e.forEach(e => {
          e.parent = n;
        });
        if (t) {
          s(n, t);
          t.parent = n;
        }
        return n;
      };
    })(Ce || (exports.PatternAsNode = Ce = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 67,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: e
          }
        };
        e.parent = t;
        return t;
      };
    })(Ie || (exports.PatternLiteralNode = Ie = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 68,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            className: e,
            args: t
          }
        };
        e.parent = n;
        t.forEach(e => {
          e.parent = n;
        });
        if (t.length > 0) {
          s(n, t[t.length - 1]);
        }
        return n;
      };
    })(ke || (exports.PatternClassNode = ke = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 74,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            pattern: e,
            name: t
          }
        };
        e.parent = n;
        if (t) {
          s(n, t);
          t.parent = n;
        }
        return n;
      };
    })(we || (exports.PatternClassArgumentNode = we = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 69,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            target: e,
            isStar: t !== undefined,
            isWildcard: e.d.value === '_'
          }
        };
        e.parent = n;
        if (t) {
          s(n, t);
        }
        return n;
      };
    })(Se || (exports.PatternCaptureNode = Se = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 70,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            entries: t
          }
        };
        if (t.length > 0) {
          s(n, t[t.length - 1]);
        }
        t.forEach(e => {
          e.parent = n;
        });
        return n;
      };
    })(Ae || (exports.PatternMappingNode = Ae = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 71,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            keyPattern: e,
            valuePattern: t
          }
        };
        e.parent = n;
        t.parent = n;
        s(n, t);
        return n;
      };
    })(xe || (exports.PatternMappingKeyEntryNode = xe = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 72,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            target: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(Pe || (exports.PatternMappingExpandEntryNode = Pe = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 73,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: e
          }
        };
        e.parent = t;
        return t;
      };
    })(De || (exports.PatternValueNode = De = {}));
  },
  96941: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Parser = exports.ParseOptions = undefined;
    const i = require(53266);
    const o = require(58147);
    const l = require(48281);
    const p = require(11479);
    const d = require(36316);
    const c = require(56814);
    const u = require(63808);
    const m = require(88754);
    const y = require(71582);
    const g = require(67703);
    const h = require(85114);
    const f = __importStar(require(23981));
    const T = require(49969);
    const v = require(92600);
    class b {
      constructor() {
        this.isStubFile = false;
        this.pythonVersion = u.latestStablePythonVersion;
        this.reportInvalidStringEscapeSequence = false;
        this.skipFunctionAndClassBody = false;
        this.ipythonMode = i.IPythonMode.None;
        this.reportErrorsForParsedStringContents = false;
      }
    }
    exports.ParseOptions = b;
    const _ = 256;
    class C {
      constructor() {
        this._tokenIndex = 0;
        this._areErrorsSuppressed = false;
        this._parseOptions = new b();
        this._diagSink = new d.DiagnosticSink();
        this._isInLoop = false;
        this._isInFunction = false;
        this._isInExceptionGroup = false;
        this._isParsingTypeAnnotation = false;
        this._isParsingIndexTrailer = false;
        this._isParsingQuotedText = false;
        this._futureImports = new Set();
        this._importedModules = [];
        this._containsWildcardImport = false;
        this._assignmentExpressionsAllowed = true;
        this._typingImportAliases = [];
        this._typingSymbolAliases = new Map();
        this._maxChildDepthMap = new Map();
      }
      parseSourceFile(e, t, n) {
        y.timingStats.tokenizeFileTime.timeOperation(() => {
          this._startNewParse(e, 0, e.length, t, n);
        });
        const a = h.ModuleNode.create({
          start: 0,
          length: e.length
        });
        y.timingStats.parseFileTime.timeOperation(() => {
          while (!this._atEof()) {
            if (!this._consumeTokenIfType(2)) {
              const e = this._peekToken();
              if (e.type === 3) {
                this._getNextToken();
                const t = e;
                if (t.isIndentAmbiguous) {
                  this._addSyntaxError(g.LocMessage.inconsistentTabs(), t);
                } else {
                  this._addSyntaxError(g.LocMessage.unexpectedIndent(), e);
                }
              }
              const t = this._parseStatement();
              if (t) {
                t.parent = a;
                a.d.statements.push(t);
              } else {
                this._consumeTokensUntilType([2]);
              }
            }
          }
        });
        l.assert(this._tokenizerOutput !== undefined);
        return {
          text: e,
          parserOutput: {
            parseTree: a,
            importedModules: this._importedModules,
            futureImports: this._futureImports,
            containsWildcardImport: this._containsWildcardImport,
            typingSymbolAliases: this._typingSymbolAliases
          },
          tokenizerOutput: this._tokenizerOutput
        };
      }
      parseTextExpression(e, t, n, a, r = 0, s = 0, i) {
        const o = new d.DiagnosticSink();
        let l;
        this._startNewParse(e, t, n, a, o, s);
        if (i) {
          this._typingSymbolAliases = new Map(i);
        }
        if (r === 1) {
          this._isParsingQuotedText = true;
          l = this._parseTypeAnnotation();
        } else {
          if (r === 2) {
            this._isParsingQuotedText = true;
            l = this._parseFunctionTypeAnnotation();
          } else {
            const e = this._parseTestOrStarExpressionList(false, true);
            if (e.parseError) {
              l = e.parseError;
            } else {
              if (e.list.length === 0) {
                this._addSyntaxError(g.LocMessage.expectedExpr(), this._peekToken());
              }
              l = this._makeExpressionOrTuple(e, false);
            }
          }
        }
        if (this._peekTokenType() === 2) {
          this._getNextToken();
        }
        if (!this._atEof()) {
          this._addSyntaxError(g.LocMessage.unexpectedExprToken(), this._peekToken());
        }
        return {
          parseTree: l,
          lines: this._tokenizerOutput.lines,
          diagnostics: o.fetchAndClear()
        };
      }
      _startNewParse(e, t, n, a, r, s = 0) {
        this._fileContents = e;
        this._parseOptions = a;
        this._diagSink = r;
        const i = new T.Tokenizer();
        this._tokenizerOutput = i.tokenize(e, t, n, s, this._parseOptions.ipythonMode);
        this._tokenIndex = 0;
      }
      _parseStatement() {
        if (this._consumeTokenIfType(4)) {
          this._addSyntaxError(g.LocMessage.unexpectedUnindent(), this._peekToken());
        }
        switch (this._peekKeywordType()) {
          case 20:
            return this._parseIfStatement();
          case 36:
            return this._parseWhileStatement();
          case 17:
            return this._parseForStatement();
          case 34:
            return this._parseTryStatement();
          case 37:
            return this._parseWithStatement();
          case 10:
            return this._parseFunctionDef();
          case 7:
            return this._parseClassDef();
          case 3:
            return this._parseAsyncStatement();
          case 25:
            {
              const e = this._peekToken(1);
              let t = false;
              if (e.type === 10 || e.type === 11 || e.type === 12 || e.type === 20 || e.type === 2 || e.type === 1) {
                t = true;
              } else {
                if (e.type === 9) {
                  const n = e;
                  if (n.operatorType !== 26 && n.operatorType !== 0 && n.operatorType !== 5 && n.operatorType !== 33) {
                    t = true;
                  }
                }
              }
              if (!t) {
                const e = this._parseMatchStatement();
                if (e) {
                  return e;
                }
              }
              break;
            }
        }
        if (this._peekOperatorType() === 22) {
          return this._parseDecorated();
        } else {
          return this._parseSimpleStatement();
        }
      }
      _parseAsyncStatement() {
        const e = this._getKeywordToken(3);
        switch (this._peekKeywordType()) {
          case 10:
            return this._parseFunctionDef(e);
          case 37:
            return this._parseWithStatement(e);
          case 17:
            return this._parseForStatement(e);
        }
        this._addSyntaxError(g.LocMessage.unexpectedAsyncToken(), e);
      }
      _parseTypeAliasStatement() {
        const e = this._getKeywordToken(35);
        if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_12)) {
          this._addSyntaxError(g.LocMessage.typeAliasStatementIllegal(), e);
        }
        const t = this._getTokenIfIdentifier();
        l.assert(t !== undefined);
        const n = h.NameNode.create(t);
        let a;
        if (this._peekToken().type === 15) {
          a = this._parseTypeParameterList();
        }
        const r = this._peekToken();
        if (r.type !== 9 || r.operatorType !== 2) {
          this._addSyntaxError(g.LocMessage.expectedEquals(), r);
        } else {
          this._getNextToken();
        }
        const s = this._isParsingTypeAnnotation;
        this._isParsingTypeAnnotation = true;
        const i = this._parseTestExpression(false);
        this._isParsingTypeAnnotation = s;
        return h.TypeAliasNode.create(e, n, i, a);
      }
      _parseTypeParameterList() {
        const e = [];
        const t = this._getNextToken();
        for (l.assert(t.type === 15);;) {
          if (this._peekToken().type === 16) {
            if (e.length === 0) {
              this._addSyntaxError(g.LocMessage.typeParametersMissing(), this._peekToken());
            }
            break;
          }
          const t = this._parseTypeParameter();
          if (!t) {
            break;
          }
          e.push(t);
          if (!this._consumeTokenIfType(12)) {
            break;
          }
        }
        const n = this._peekToken();
        if (n.type !== 16) {
          this._addSyntaxError(g.LocMessage.expectedCloseBracket(), this._peekToken());
          this._consumeTokensUntilType([2, 16, 10]);
        } else {
          this._getNextToken();
        }
        return h.TypeParameterListNode.create(t, n, e);
      }
      _parseTypeParameter() {
        let e = h.TypeParamKind.TypeVar;
        if (this._consumeTokenIfOperator(26)) {
          e = h.TypeParamKind.TypeVarTuple;
        } else {
          if (this._consumeTokenIfOperator(29)) {
            e = h.TypeParamKind.ParamSpec;
          }
        }
        const t = this._getTokenIfIdentifier();
        if (!t) {
          this._addSyntaxError(g.LocMessage.expectedTypeParameterName(), this._peekToken());
          return;
        }
        const n = h.NameNode.create(t);
        let a;
        let r;
        if (this._consumeTokenIfType(10)) {
          a = this._parseExpression(false);
          if (e !== h.TypeParamKind.TypeVar) {
            this._addSyntaxError(g.LocMessage.typeParameterBoundNotAllowed(), a);
          }
        }
        if (this._consumeTokenIfOperator(2)) {
          r = this._parseExpression(e === h.TypeParamKind.TypeVarTuple);
          if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_13)) {
            this._addSyntaxError(g.LocMessage.typeVarDefaultIllegal(), r);
          }
        }
        return h.TypeParameterNode.create(n, e, a, r);
      }
      _parseMatchStatement() {
        let e = false;
        this._suppressErrors(() => {
          const t = this._tokenIndex;
          this._getKeywordToken(25);
          const n = this._parseTestOrStarListAsExpression(true, true, 12, () => g.LocMessage.expectedReturnExpr());
          e = n.nodeType !== 0 && this._peekToken().type === 10;
          this._tokenIndex = t;
        });
        if (!e) {
          return;
        }
        const t = this._getKeywordToken(25);
        const n = this._parseTestOrStarListAsExpression(true, true, 12, () => g.LocMessage.expectedReturnExpr());
        const a = h.MatchNode.create(t, n);
        const r = this._peekToken();
        if (this._consumeTokenIfType(10)) {
          h.extendRange(a, r);
          if (this._consumeTokenIfType(2)) {
            const e = this._peekToken();
            if (this._consumeTokenIfType(3)) {
              const t = e;
              if (t.isIndentAmbiguous) {
                this._addSyntaxError(g.LocMessage.inconsistentTabs(), t);
              }
            } else {
              this._addSyntaxError(g.LocMessage.expectedIndentedBlock(), this._peekToken());
            }
            while (true) {
              const e = this._peekToken();
              if (e.type === 3) {
                this._getNextToken();
                const t = e;
                if (t.isIndentAmbiguous) {
                  this._addSyntaxError(g.LocMessage.inconsistentTabs(), t);
                } else {
                  this._addSyntaxError(g.LocMessage.unexpectedIndent(), e);
                }
              }
              const t = this._parseCaseStatement();
              if (t) {
                t.parent = a;
                a.d.cases.push(t);
              } else {
                if (this._consumeTokensUntilType([2, 10])) {
                  this._getNextToken();
                }
              }
              const n = this._peekToken();
              if (this._consumeTokenIfType(4)) {
                if (!n.matchesIndent) {
                  this._addSyntaxError(g.LocMessage.inconsistentIndent(), n);
                }
                if (n.isDedentAmbiguous) {
                  this._addSyntaxError(g.LocMessage.inconsistentTabs(), n);
                }
                break;
              }
              if (this._peekTokenType() === 1) {
                break;
              }
            }
          } else {
            this._addSyntaxError(g.LocMessage.expectedNewline(), r);
          }
          if (a.d.cases.length > 0) {
            h.extendRange(a, a.d.cases[a.d.cases.length - 1]);
          } else {
            this._addSyntaxError(g.LocMessage.zeroCaseStatementsFound(), t);
          }
        } else {
          this._addSyntaxError(g.LocMessage.expectedColon(), r);
          if (this._consumeTokensUntilType([2, 10])) {
            this._getNextToken();
          }
        }
        if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_10)) {
          this._addSyntaxError(g.LocMessage.matchIncompatible(), t);
        }
        for (let e = 0; e < a.d.cases.length - 1; e++) {
          const t = a.d.cases[e];
          if (!t.d.guardExpr && t.d.isIrrefutable) {
            this._addSyntaxError(g.LocMessage.casePatternIsIrrefutable(), t.d.pattern);
          }
        }
        return a;
      }
      _parseCaseStatement() {
        const e = this._peekToken();
        if (!this._consumeTokenIfKeyword(6)) {
          this._addSyntaxError(g.LocMessage.expectedCase(), e);
          return;
        }
        const t = this._parsePatternSequence();
        let n;
        let a;
        if (t.parseError) {
          n = t.parseError;
        } else {
          if (t.list.length === 0) {
            this._addSyntaxError(g.LocMessage.expectedPatternExpr(), this._peekToken());
            n = h.ErrorNode.create(e, 11);
          } else {
            if (t.list.length !== 1 || t.trailingComma) {
              n = h.PatternSequenceNode.create(t.list[0], t.list);
            } else {
              const e = t.list[0].d.orPatterns[0];
              n = e.nodeType === 69 && e.d.isStar ? h.PatternSequenceNode.create(t.list[0], t.list) : t.list[0];
            }
          }
        }
        if (n.nodeType !== 0) {
          const e = new Map();
          const t = new Map();
          this._reportDuplicatePatternCaptureTargets(n, e, t);
        }
        if (this._consumeTokenIfKeyword(20)) {
          a = this._parseTestExpression(true);
        }
        const r = this._parseSuite(this._isInFunction);
        return h.CaseNode.create(e, n, this._isPatternIrrefutable(n), a, r);
      }
      _isPatternIrrefutable(e) {
        return e.nodeType === 69 || e.nodeType === 66 && e.d.orPatterns.some(e => this._isPatternIrrefutable(e));
      }
      _reportDuplicatePatternCaptureTargets(e, t, n) {
        const a = e => {
          if (t.has(e.d.value) || n.has(e.d.value)) {
            this._addSyntaxError(g.LocMessage.duplicateCapturePatternTarget().format({
              name: e.d.value
            }), e);
          } else {
            n.set(e.d.value, e);
          }
        };
        switch (e.nodeType) {
          case 65:
            e.d.entries.forEach(e => {
              this._reportDuplicatePatternCaptureTargets(e, t, n);
            });
            break;
          case 68:
            e.d.args.forEach(e => {
              this._reportDuplicatePatternCaptureTargets(e.d.pattern, t, n);
            });
            break;
          case 66:
            {
              if (e.d.target) {
                a(e.d.target);
              }
              const t = e.d.orPatterns.map(e => {
                const t = new Map();
                this._reportDuplicatePatternCaptureTargets(e, n, t);
                return t;
              });
              const r = new Map();
              t.forEach(e => {
                e.forEach(e => {
                  if (!r.has(e.d.value)) {
                    r.set(e.d.value, e);
                    a(e);
                  }
                });
              });
              break;
            }
          case 69:
            if (!e.d.isWildcard) {
              a(e.d.target);
            }
            break;
          case 70:
            e.d.entries.forEach(e => {
              if (e.nodeType === 72) {
                a(e.d.target);
              } else {
                this._reportDuplicatePatternCaptureTargets(e.d.keyPattern, t, n);
                this._reportDuplicatePatternCaptureTargets(e.d.valuePattern, t, n);
              }
            });
        }
      }
      _getPatternTargetNames(e, t) {
        switch (e.nodeType) {
          case 65:
            e.d.entries.forEach(e => {
              this._getPatternTargetNames(e, t);
            });
            break;
          case 68:
            e.d.args.forEach(e => {
              this._getPatternTargetNames(e.d.pattern, t);
            });
            break;
          case 66:
            if (e.d.target) {
              t.add(e.d.target.d.value);
            }
            e.d.orPatterns.forEach(e => {
              this._getPatternTargetNames(e, t);
            });
            break;
          case 69:
            if (!e.d.isWildcard) {
              t.add(e.d.target.d.value);
            }
            break;
          case 70:
            e.d.entries.forEach(e => {
              if (e.nodeType === 72) {
                t.add(e.d.target.d.value);
              } else {
                this._getPatternTargetNames(e.d.keyPattern, t);
                this._getPatternTargetNames(e.d.valuePattern, t);
              }
            });
        }
      }
      _parsePatternSequence() {
        const e = this._parseExpressionListGeneric(() => this._parsePatternAs());
        const t = e.list.filter(e => e.d.orPatterns.length === 1 && e.d.orPatterns[0].nodeType === 69 && e.d.orPatterns[0].d.isStar);
        if (t.length > 1) {
          this._addSyntaxError(g.LocMessage.duplicateStarPattern(), t[1].d.orPatterns[0]);
        }
        return e;
      }
      _parsePatternAs() {
        const e = [];
        while (true) {
          const t = this._parsePatternAtom();
          e.push(t);
          if (!this._consumeTokenIfOperator(6)) {
            break;
          }
        }
        let t;
        if (e.length > 1) {
          e.forEach(e => {
            if (e.nodeType === 69 && e.d.isStar) {
              this._addSyntaxError(g.LocMessage.starPatternInOrPattern(), e);
            }
          });
        }
        if (this._consumeTokenIfKeyword(1)) {
          const e = this._getTokenIfIdentifier();
          if (e) {
            t = h.NameNode.create(e);
          } else {
            this._addSyntaxError(g.LocMessage.expectedNameAfterAs(), this._peekToken());
          }
        }
        if (t && e.length === 1 && e[0].nodeType === 69 && e[0].d.isStar) {
          this._addSyntaxError(g.LocMessage.starPatternInAsPattern(), e[0]);
        }
        e.forEach((t, n) => {
          if (n < e.length - 1 && this._isPatternIrrefutable(t)) {
            this._addSyntaxError(g.LocMessage.orPatternIrrefutable(), t);
          }
        });
        const n = new Set();
        e.forEach(e => {
          this._getPatternTargetNames(e, n);
        });
        e.forEach(e => {
          const t = new Set();
          this._getPatternTargetNames(e, t);
          if (t.size < n.size) {
            const a = Array.from(n.keys()).filter(e => !t.has(e));
            const r = new p.DiagnosticAddendum();
            r.addMessage(g.LocAddendum.orPatternMissingName().format({
              name: a.map(e => `"${e}"`).join(', ')
            }));
            this._addSyntaxError(g.LocMessage.orPatternMissingName() + r.getString(), e);
          }
        });
        return h.PatternAsNode.create(e, t);
      }
      _parsePatternAtom() {
        const e = this._parsePatternLiteral();
        if (e) {
          return e;
        }
        const t = this._parsePatternCaptureOrValue();
        if (t) {
          const e = this._peekToken();
          if (t.nodeType === 0 || !this._consumeTokenIfType(13)) {
            return t;
          }
          const n = this._parseClassPatternArgList();
          const a = t.nodeType === 69 ? t.d.target : t.d.expr;
          const r = h.PatternClassNode.create(a, n);
          if (!this._consumeTokenIfType(14)) {
            this._addSyntaxError(g.LocMessage.expectedCloseParen(), e);
            this._consumeTokensUntilType([2]);
            h.extendRange(r, this._peekToken());
          }
          return r;
        }
        const n = this._peekToken();
        if (this._peekOperatorType() === 26) {
          const e = this._getNextToken();
          const t = this._getTokenIfIdentifier();
          if (t) {
            return h.PatternCaptureNode.create(h.NameNode.create(t), e);
          } else {
            this._addSyntaxError(g.LocMessage.expectedIdentifier(), this._peekToken());
            return h.ErrorNode.create(e, 2);
          }
        }
        if (n.type === 13 || n.type === 15) {
          const e = this._getNextToken();
          const t = this._parsePatternSequence();
          let a;
          if (t.parseError) {
            a = t.parseError;
          } else {
            if (t.list.length !== 1 || t.trailingComma || e.type !== 13) {
              a = h.PatternSequenceNode.create(e, t.list);
            } else {
              const r = t.list[0].d.orPatterns[0];
              a = r.nodeType === 69 && r.d.isStar ? h.PatternSequenceNode.create(e, t.list) : t.list[0];
              h.extendRange(a, n);
            }
          }
          const r = this._peekToken();
          if (this._consumeTokenIfType(n.type === 13 ? 14 : 16)) {
            h.extendRange(a, r);
          } else {
            this._addSyntaxError(n.type === 13 ? g.LocMessage.expectedCloseParen() : g.LocMessage.expectedCloseBracket(), n);
            this._consumeTokensUntilType([10, n.type === 13 ? 14 : 16]);
          }
          return a;
        }
        if (n.type === 17) {
          const e = this._getNextToken();
          const t = this._parsePatternMapping(e);
          const a = this._peekToken();
          if (this._consumeTokenIfType(18)) {
            h.extendRange(t, a);
          } else {
            this._addSyntaxError(g.LocMessage.expectedCloseBrace(), n);
            this._consumeTokensUntilType([10, 18]);
          }
          return t;
        }
        return this._handleExpressionParseError(11, g.LocMessage.expectedPatternExpr());
      }
      _parseClassPatternArgList() {
        const e = [];
        let t = false;
        while (true) {
          const n = this._peekTokenType();
          if (n === 14 || n === 2 || n === 1) {
            break;
          }
          const a = this._parseClassPatternArgument();
          if (a.d.name) {
            t = true;
          } else {
            if (t && !a.d.name) {
              this._addSyntaxError(g.LocMessage.positionArgAfterNamedArg(), a);
            }
          }
          e.push(a);
          if (!this._consumeTokenIfType(12)) {
            break;
          }
        }
        return e;
      }
      _parseClassPatternArgument() {
        const e = this._peekToken();
        const t = this._peekToken(1);
        let n;
        if ((e.type === 7 || e.type === 8) && t.type === 9 && t.operatorType === 2) {
          const e = this._getTokenIfIdentifier();
          if (e !== undefined) {
            n = h.NameNode.create(e);
            this._getNextToken();
          }
        }
        const a = this._parsePatternAs();
        return h.PatternClassArgumentNode.create(a, n);
      }
      _parsePatternLiteral() {
        const e = this._peekToken();
        const t = this._peekOperatorType();
        if (e.type === 6 || t === 33) {
          return this._parsePatternLiteralNumber();
        }
        if (e.type === 5) {
          const e = this._parseAtom();
          l.assert(e.nodeType === 48);
          e.d.strings.forEach(e => {
            if (e.nodeType === 30) {
              this._addSyntaxError(g.LocMessage.formatStringInPattern(), e);
            }
          });
          return h.PatternLiteralNode.create(e);
        }
        if (e.type === 8) {
          const t = e;
          if (t.keywordType === 15 || t.keywordType === 33 || t.keywordType === 26) {
            return h.PatternLiteralNode.create(this._parseAtom());
          }
        }
      }
      _parsePatternLiteralNumber() {
        const e = this._parseArithmeticExpression();
        let t;
        let n;
        if (e.nodeType === 7) {
          if (e.d.operator === 33 || e.d.operator === 0) {
            t = e.d.leftExpr;
            n = e.d.rightExpr;
          }
        } else {
          t = e;
        }
        if (t) {
          if (t.nodeType === 55 && t.d.operator === 33) {
            t = t.d.expr;
          }
          if (t.nodeType !== 40 || n !== undefined && t.d.isImaginary) {
            this._addSyntaxError(g.LocMessage.expectedComplexNumberLiteral(), e);
            n = undefined;
          }
        }
        if (n) {
          if (n.nodeType === 55 && n.d.operator === 33) {
            n = n.d.expr;
          }
          if (n.nodeType !== 40 || !n.d.isImaginary) {
            this._addSyntaxError(g.LocMessage.expectedComplexNumberLiteral(), e);
          }
        }
        return h.PatternLiteralNode.create(e);
      }
      _parsePatternMapping(e) {
        const t = this._parseExpressionListGeneric(() => this._parsePatternMappingItem());
        if (t.list.length > 0) {
          const n = t.list.filter(e => e.nodeType === 72);
          if (n.length > 1) {
            this._addSyntaxError(g.LocMessage.duplicateStarStarPattern(), n[1]);
          }
          return h.PatternMappingNode.create(e, t.list);
        }
        return t.parseError || h.ErrorNode.create(this._peekToken(), 11);
      }
      _parsePatternMappingItem() {
        let e;
        const t = this._peekToken();
        if (this._consumeTokenIfOperator(29)) {
          const e = this._getTokenIfIdentifier();
          if (!e) {
            this._addSyntaxError(g.LocMessage.expectedIdentifier(), this._peekToken());
            return h.ErrorNode.create(this._peekToken(), 11);
          }
          const n = h.NameNode.create(e);
          if (e.value === '_') {
            this._addSyntaxError(g.LocMessage.starStarWildcardNotAllowed(), n);
          }
          return h.PatternMappingExpandEntryNode.create(t, n);
        }
        const n = this._parsePatternLiteral();
        if (n) {
          e = n;
        } else {
          const t = this._parsePatternCaptureOrValue();
          if (t) {
            if (t.nodeType === 73) {
              e = t;
            } else {
              this._addSyntaxError(g.LocMessage.expectedPatternValue(), t);
              e = h.ErrorNode.create(this._peekToken(), 11);
            }
          }
        }
        let a;
        if (!e) {
          this._addSyntaxError(g.LocMessage.expectedPatternExpr(), this._peekToken());
          e = h.ErrorNode.create(this._peekToken(), 11);
        }
        if (this._consumeTokenIfType(10)) {
          a = this._parsePatternAs();
        } else {
          this._addSyntaxError(g.LocMessage.expectedColon(), this._peekToken());
          a = h.ErrorNode.create(this._peekToken(), 11);
        }
        return h.PatternMappingKeyEntryNode.create(e, a);
      }
      _parsePatternCaptureOrValue() {
        const e = this._peekToken();
        if (e.type === 7 || e.type === 8) {
          let e;
          while (true) {
            const t = this._getTokenIfIdentifier();
            if (!t) {
              this._addSyntaxError(g.LocMessage.expectedIdentifier(), this._peekToken());
              break;
            }
            {
              const n = h.NameNode.create(t);
              e = e ? h.MemberAccessNode.create(e, n) : n;
            }
            if (!this._consumeTokenIfType(20)) {
              break;
            }
          }
          if (e) {
            if (e.nodeType === 35) {
              return h.PatternValueNode.create(e);
            } else {
              return h.PatternCaptureNode.create(e);
            }
          } else {
            this._addSyntaxError(g.LocMessage.expectedIdentifier(), this._peekToken());
            return h.ErrorNode.create(this._peekToken(), 11);
          }
        }
      }
      _parseIfStatement(e = 20) {
        const t = this._getKeywordToken(e);
        const n = this._parseTestExpression(true);
        const a = this._parseSuite(this._isInFunction);
        const r = h.IfNode.create(t, n, a);
        if (this._consumeTokenIfKeyword(13)) {
          r.d.elseSuite = this._parseSuite(this._isInFunction);
          r.d.elseSuite.parent = r;
          h.extendRange(r, r.d.elseSuite);
        } else {
          if (this._peekKeywordType() === 12) {
            r.d.elseSuite = this._parseIfStatement(12);
            r.d.elseSuite.parent = r;
            h.extendRange(r, r.d.elseSuite);
          }
        }
        return r;
      }
      _parseExceptSuite(e, t) {
        const n = this._isInExceptionGroup;
        if (e) {
          this._isInExceptionGroup = true;
        }
        const a = t();
        this._isInExceptionGroup = n;
        return a;
      }
      _parseLoopSuite() {
        const e = this._isInLoop;
        let t;
        this._isInLoop = true;
        const n = this._parseSuite(this._isInFunction, false, () => {
          const e = this._getTypeAnnotationCommentText();
          if (e) {
            t = e;
          }
        });
        this._isInLoop = e;
        if (t) {
          n.d.typeComment = t;
        }
        return n;
      }
      _parseSuite(e = false, t = false, n) {
        const a = this._peekToken();
        const r = h.SuiteNode.create(a);
        if (!this._consumeTokenIfType(10) && (this._addSyntaxError(g.LocMessage.expectedColon(), a), this._consumeTokensUntilType([2, 10]))) {
          if (this._peekTokenType() === 10) {
            this._getNextToken();
          } else {
            if (this._peekToken(1).type !== 3) {
              this._getNextToken();
              return r;
            }
          }
        }
        if (t) {
          if (this._consumeTokenIfType(2)) {
            let e = 0;
            while (true) {
              const t = this._getNextToken();
              if (t.type === 3) {
                e++;
              }
              if (t.type === 4 && (t.isDedentAmbiguous && this._addSyntaxError(g.LocMessage.inconsistentTabs(), t), e--, e === 0)) {
                break;
              }
              if (t.type === 1) {
                break;
              }
            }
          } else {
            this._parseSimpleStatement();
          }
          if (this._tokenIndex > 0) {
            h.extendRange(r, this._tokenizerOutput.tokens.getItemAt(this._tokenIndex - 1));
          }
          return r;
        }
        if (n) {
          n();
        }
        const s = this._isInFunction;
        this._isInFunction = e;
        if (this._consumeTokenIfType(2)) {
          if (n) {
            n();
          }
          const e = this._peekToken();
          if (!this._consumeTokenIfType(3)) {
            this._addSyntaxError(g.LocMessage.expectedIndentedBlock(), this._peekToken());
            return r;
          }
          const t = e;
          for (t.isIndentAmbiguous && this._addSyntaxError(g.LocMessage.inconsistentTabs(), t);;) {
            const e = this._peekToken();
            if (e.type === 3) {
              this._getNextToken();
              const t = e;
              if (t.isIndentAmbiguous) {
                this._addSyntaxError(g.LocMessage.inconsistentTabs(), t);
              } else {
                this._addSyntaxError(g.LocMessage.unexpectedIndent(), e);
              }
            } else {
              if (e.type === 4) {
                const n = e;
                if (!n.matchesIndent) {
                  this._addSyntaxError(g.LocMessage.inconsistentIndent(), n);
                }
                if (n.isDedentAmbiguous) {
                  this._addSyntaxError(g.LocMessage.inconsistentTabs(), n);
                }
                if (r.d.statements.length > 0) {
                  this._consumeTokenIfType(4);
                } else {
                  h.extendRange(r, n);
                }
                if (!t || n.indentAmount < t.indentAmount) {
                  break;
                }
                if (n.indentAmount === t.indentAmount) {
                  const e = this._peekToken();
                  if (this._consumeTokenIfType(4)) {
                    h.extendRange(r, e);
                    break;
                  }
                }
              }
            }
            const n = this._parseStatement();
            if (n) {
              n.parent = r;
              r.d.statements.push(n);
            } else {
              this._consumeTokensUntilType([2]);
            }
            if (this._peekTokenType() === 1) {
              break;
            }
          }
        } else {
          const e = this._parseSimpleStatement();
          r.d.statements.push(e);
          e.parent = r;
        }
        if (r.d.statements.length > 0) {
          h.extendRange(r, r.d.statements[r.d.statements.length - 1]);
        }
        this._isInFunction = s;
        return r;
      }
      _parseForStatement(e) {
        const t = this._getKeywordToken(17);
        const n = this._parseExpressionListAsPossibleTuple(2, () => g.LocMessage.expectedExpr(), t);
        let a;
        let r;
        let s;
        if (this._consumeTokenIfKeyword(22)) {
          a = this._parseTestOrStarListAsExpression(false, true, 2, () => g.LocMessage.expectedInExpr());
          r = this._parseLoopSuite();
          if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_9) && !this._parseOptions.isStubFile && a.nodeType === 52 && !a.d.hasParens) {
            let e = false;
            a.d.items.forEach(t => {
              if (t.nodeType === 56 && !e) {
                this._addSyntaxError(g.LocMessage.unpackOperatorNotAllowed(), t);
                e = true;
              }
            });
          }
          if (this._consumeTokenIfKeyword(13)) {
            s = this._parseSuite(this._isInFunction);
          }
        } else {
          a = this._handleExpressionParseError(0, g.LocMessage.expectedIn());
          r = h.SuiteNode.create(this._peekToken());
        }
        const i = h.ForNode.create(t, n, a, r);
        i.d.elseSuite = s;
        if (s) {
          h.extendRange(i, s);
          s.parent = i;
        }
        if (e) {
          i.d.isAsync = true;
          i.d.asyncToken = e;
          h.extendRange(i, e);
        }
        if (r.d.typeComment) {
          i.d.typeComment = r.d.typeComment;
        }
        return i;
      }
      _tryParseComprehension(e, t) {
        const n = this._tryParseCompForStatement();
        if (!n) {
          return;
        }
        if (e.nodeType === 56) {
          this._addSyntaxError(g.LocMessage.unpackIllegalInComprehension(), e);
        } else {
          if (e.nodeType === 19) {
            this._addSyntaxError(g.LocMessage.dictExpandIllegalInComprehension(), e);
          }
        }
        const a = h.ComprehensionNode.create(e, t);
        const r = [n];
        while (true) {
          const e = this._tryParseCompForStatement() || this._tryParseCompIfStatement();
          if (!e) {
            break;
          }
          e.parent = a;
          r.push(e);
        }
        a.d.forIfNodes = r;
        if (r.length > 0) {
          r.forEach(e => {
            e.parent = a;
          });
          h.extendRange(a, r[r.length - 1]);
        }
        return a;
      }
      _tryParseCompForStatement() {
        const e = this._peekKeywordType();
        if (e === 3) {
          const e = this._peekToken(1);
          if (e.type !== 8 || e.keywordType !== 17) {
            return;
          }
        } else {
          if (e !== 17) {
            return;
          }
        }
        let t;
        if (this._peekKeywordType() === 3) {
          t = this._getKeywordToken(3);
        }
        const n = this._getKeywordToken(17);
        const a = this._parseExpressionListAsPossibleTuple(2, () => g.LocMessage.expectedExpr(), n);
        let r;
        if (this._consumeTokenIfKeyword(22)) {
          this._disallowAssignmentExpression(() => {
            r = this._parseOrTest();
          });
        } else {
          r = this._handleExpressionParseError(0, g.LocMessage.expectedIn());
        }
        const s = h.ComprehensionForNode.create(t || n, a, r);
        if (t) {
          s.d.isAsync = true;
          s.d.asyncToken = t;
        }
        return s;
      }
      _tryParseCompIfStatement() {
        if (this._peekKeywordType() !== 20) {
          return;
        }
        const e = this._getKeywordToken(20);
        const t = this._tryParseLambdaExpression() || this._parseAssignmentExpression(true);
        return h.ComprehensionIfNode.create(e, t);
      }
      _parseWhileStatement() {
        const e = this._getKeywordToken(36);
        const t = h.WhileNode.create(e, this._parseTestExpression(true), this._parseLoopSuite());
        if (this._consumeTokenIfKeyword(13)) {
          t.d.elseSuite = this._parseSuite(this._isInFunction);
          t.d.elseSuite.parent = t;
          h.extendRange(t, t.d.elseSuite);
        }
        return t;
      }
      _parseTryStatement() {
        const e = this._getKeywordToken(34);
        const t = this._parseSuite(this._isInFunction);
        const n = h.TryNode.create(e, t);
        let a = false;
        let r = false;
        while (true) {
          const e = this._peekToken();
          if (!this._consumeTokenIfKeyword(14)) {
            break;
          }
          const t = this._peekToken();
          let s;
          let i;
          let o = false;
          if (this._consumeTokenIfOperator(26)) {
            if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_11) && !this._parseOptions.isStubFile) {
              this._addSyntaxError(g.LocMessage.exceptionGroupIncompatible(), t);
            }
            o = true;
            if (!r && n.d.exceptClauses.some(e => !e.d.isExceptGroup)) {
              this._addSyntaxError(g.LocMessage.exceptGroupMismatch(), t);
              r = true;
            }
          } else {
            if (!r && n.d.exceptClauses.some(e => e.d.isExceptGroup)) {
              this._addSyntaxError(g.LocMessage.exceptGroupMismatch(), t);
              r = true;
            }
          }
          if (this._peekTokenType() !== 10) {
            s = this._parseTestExpression(true);
            if (this._consumeTokenIfKeyword(1)) {
              i = this._getTokenIfIdentifier();
              if (!i) {
                this._addSyntaxError(g.LocMessage.expectedNameAfterAs(), this._peekToken());
              }
            } else {
              const e = this._peekToken();
              if (this._consumeTokenIfType(12)) {
                this._addSyntaxError(g.LocMessage.expectedAsAfterException(), e);
                this._parseTestExpression(false);
              }
            }
          } else {
            if (o) {
              this._addSyntaxError(g.LocMessage.exceptGroupRequiresType(), this._peekToken());
            }
          }
          if (s) {
            if (a) {
              this._addSyntaxError(g.LocMessage.namedExceptAfterCatchAll(), s);
            }
          } else {
            if (a) {
              this._addSyntaxError(g.LocMessage.duplicateCatchAll(), e);
            }
            a = true;
          }
          const l = this._parseExceptSuite(o, () => this._parseSuite(this._isInFunction));
          const p = h.ExceptNode.create(e, l, o);
          if (s) {
            p.d.typeExpr = s;
            p.d.typeExpr.parent = p;
          }
          if (i) {
            p.d.name = h.NameNode.create(i);
            p.d.name.parent = p;
          }
          n.d.exceptClauses.push(p);
          p.parent = n;
        }
        if (n.d.exceptClauses.length > 0) {
          h.extendRange(n, n.d.exceptClauses[n.d.exceptClauses.length - 1]);
          if (this._consumeTokenIfKeyword(13)) {
            n.d.elseSuite = this._parseSuite(this._isInFunction);
            n.d.elseSuite.parent = n;
            h.extendRange(n, n.d.elseSuite);
          }
        }
        if (this._consumeTokenIfKeyword(16)) {
          n.d.finallySuite = this._parseSuite(this._isInFunction);
          n.d.finallySuite.parent = n;
          h.extendRange(n, n.d.finallySuite);
        }
        if (!n.d.finallySuite && n.d.exceptClauses.length === 0) {
          this._addSyntaxError(g.LocMessage.tryWithoutExcept(), e);
        }
        return n;
      }
      _parseFunctionDef(e, t) {
        const n = this._getKeywordToken(10);
        const a = this._getTokenIfIdentifier();
        if (!a) {
          this._addSyntaxError(g.LocMessage.expectedFunctionName(), n);
          return h.ErrorNode.create(n, 10, undefined, t);
        }
        let r;
        if (this._peekToken().type === 15) {
          r = this._parseTypeParameterList();
          if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_12)) {
            this._addSyntaxError(g.LocMessage.functionTypeParametersIllegal(), r);
          }
        }
        const s = this._peekToken();
        if (!this._consumeTokenIfType(13)) {
          this._addSyntaxError(g.LocMessage.expectedOpenParen(), this._peekToken());
          return h.ErrorNode.create(a, 10, h.NameNode.create(a), t);
        }
        const i = this._parseVarArgsList(14, true);
        let o;
        let l;
        if (!this._consumeTokenIfType(14)) {
          this._addSyntaxError(g.LocMessage.expectedCloseParen(), s);
          this._consumeTokensUntilType([10]);
        }
        if (this._consumeTokenIfType(21)) {
          o = this._parseTypeAnnotation();
        }
        const p = this._isInExceptionGroup;
        this._isInExceptionGroup = false;
        const d = this._parseSuite(true, this._parseOptions.skipFunctionAndClassBody, () => {
          if (!l) {
            l = this._getTypeAnnotationCommentText();
          }
        });
        this._isInExceptionGroup = p;
        const c = h.FunctionNode.create(n, h.NameNode.create(a), d, r);
        if (e) {
          c.d.isAsync = true;
          h.extendRange(c, e);
        }
        c.d.params = i;
        i.forEach(e => {
          e.parent = c;
        });
        if (t) {
          c.d.decorators = t;
          t.forEach(e => {
            e.parent = c;
          });
          if (t.length > 0) {
            h.extendRange(c, t[0]);
          }
        }
        if (o) {
          c.d.returnAnnotation = o;
          c.d.returnAnnotation.parent = c;
          h.extendRange(c, o);
        }
        if (l) {
          this._parseFunctionTypeAnnotationComment(l, c);
        }
        return c;
      }
      _parseVarArgsList(e, t) {
        const n = new Map();
        const a = [];
        let r = false;
        let s = false;
        let i = false;
        let o = false;
        let l = false;
        let p = false;
        let d = false;
        while (this._peekTokenType() !== e) {
          const c = this._parseParameter(t);
          if (!c) {
            this._consumeTokensUntilType([e]);
            break;
          }
          if (c.d.name) {
            const e = c.d.name.d.value;
            if (n.has(e)) {
              this._addSyntaxError(g.LocMessage.duplicateParam().format({
                name: e
              }), c.d.name);
            } else {
              n.set(e, e);
            }
          } else {
            if (c.d.category === 0 && a.length === 0) {
              this._addSyntaxError(g.LocMessage.positionOnlyFirstParam(), c);
            }
          }
          if (c.d.category === 0) {
            if (c.d.name) {
              if (i) {
                l = true;
              }
              if (c.d.defaultValue) {
                r = true;
              } else {
                if (!!r && !i && !p && !s) {
                  this._addSyntaxError(g.LocMessage.nonDefaultAfterDefault(), c);
                  s = true;
                }
              }
            } else {
              if (o) {
                this._addSyntaxError(g.LocMessage.duplicatePositionOnly(), c);
              } else {
                if (i) {
                  this._addSyntaxError(g.LocMessage.positionOnlyAfterKeywordOnly(), c);
                } else {
                  if (p) {
                    this._addSyntaxError(g.LocMessage.positionOnlyAfterArgs(), c);
                  }
                }
              }
              o = true;
            }
          }
          a.push(c);
          if (c.d.category === 1) {
            if (c.d.name) {
              if (i || p) {
                this._addSyntaxError(g.LocMessage.duplicateArgsParam(), c);
              }
              p = true;
            } else {
              if (i) {
                this._addSyntaxError(g.LocMessage.duplicateKeywordOnly(), c);
              } else {
                if (p) {
                  this._addSyntaxError(g.LocMessage.keywordOnlyAfterArgs(), c);
                }
              }
              i = true;
            }
          }
          if (c.d.category === 2) {
            if (d) {
              this._addSyntaxError(g.LocMessage.duplicateKwargsParam(), c);
            }
            d = true;
            if (i && !l) {
              this._addSyntaxError(g.LocMessage.keywordParameterMissing(), c);
            }
          } else {
            if (d) {
              this._addSyntaxError(g.LocMessage.paramAfterKwargsParam(), c);
            }
          }
          const u = this._consumeTokenIfType(12);
          if (t && !c.d.annotation) {
            const e = this._parseVariableTypeAnnotationComment();
            if (e) {
              c.d.annotationComment = e;
              c.d.annotationComment.parent = c;
              h.extendRange(c, c.d.annotationComment);
            }
          }
          if (!u) {
            break;
          }
        }
        if (a.length > 0) {
          const e = a[a.length - 1];
          if (e.d.category === 1 && !e.d.name) {
            this._addSyntaxError(g.LocMessage.expectedNamedParameter(), e);
          }
        }
        return a;
      }
      _parseParameter(e) {
        let t = 0;
        let n = 0;
        const a = this._peekToken();
        if (this._consumeTokenIfOperator(26)) {
          t = 1;
        } else {
          if (this._consumeTokenIfOperator(29)) {
            t = 2;
          } else {
            if (this._consumeTokenIfOperator(10)) {
              if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_8) && !this._parseOptions.isStubFile) {
                this._addSyntaxError(g.LocMessage.positionOnlyIncompatible(), a);
              }
              n = 1;
            }
          }
        }
        const r = this._getTokenIfIdentifier();
        if (!r) {
          if (t === 1) {
            return h.ParameterNode.create(a, 1);
          }
          if (n === 1) {
            return h.ParameterNode.create(a, 0);
          }
          if (this._peekTokenType() === 13) {
            const e = this._getNextToken();
            if (this._consumeTokensUntilType([14])) {
              this._getNextToken();
            }
            this._addSyntaxError(g.LocMessage.sublistParamsIncompatible(), e);
          } else {
            this._addSyntaxError(g.LocMessage.expectedParamName(), this._peekToken());
          }
        }
        let s = 0;
        if (t === 1) {
          s = 1;
        } else {
          if (t === 2) {
            s = 2;
          }
        }
        const i = h.ParameterNode.create(a, s);
        if (r) {
          i.d.name = h.NameNode.create(r);
          i.d.name.parent = i;
          h.extendRange(i, r);
        }
        if (e && this._consumeTokenIfType(10)) {
          i.d.annotation = this._parseTypeAnnotation(s === 1);
          i.d.annotation.parent = i;
          h.extendRange(i, i.d.annotation);
        }
        if (this._consumeTokenIfOperator(2)) {
          i.d.defaultValue = this._parseTestExpression(false);
          i.d.defaultValue.parent = i;
          h.extendRange(i, i.d.defaultValue);
          if (t > 0) {
            this._addSyntaxError(g.LocMessage.defaultValueNotAllowed(), i.d.defaultValue);
          }
        }
        return i;
      }
      _parseWithStatement(e) {
        const t = this._getKeywordToken(37);
        let n = [];
        const a = this._peekToken();
        let r;
        let s = false;
        if (a.type === 13) {
          const e = this._tokenIndex;
          this._suppressErrors(() => {
            for (this._getNextToken(); n.push(this._parseWithItem()), this._consumeTokenIfType(12) && this._peekToken().type !== 14;);
            if (this._peekToken().type === 14 && this._peekToken(1).type === 10) {
              s = n.length !== 1 || n[0].d.target !== undefined;
            }
            this._tokenIndex = e;
            n = [];
          });
        }
        for (s && (this._consumeTokenIfType(13), u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_9) && this._addSyntaxError(g.LocMessage.parenthesizedContextManagerIllegal(), a)); n.push(this._parseWithItem()), this._consumeTokenIfType(12) && this._peekToken().type !== 14;);
        if (s) {
          if (!this._consumeTokenIfType(14)) {
            this._addSyntaxError(g.LocMessage.expectedCloseParen(), a);
          }
        }
        const i = this._parseSuite(this._isInFunction, false, () => {
          const e = this._getTypeAnnotationCommentText();
          if (e) {
            r = e;
          }
        });
        const o = h.WithNode.create(t, i);
        if (e) {
          o.d.isAsync = true;
          o.d.asyncToken = e;
          h.extendRange(o, e);
        }
        if (r) {
          o.d.typeComment = r;
        }
        o.d.withItems = n;
        n.forEach(e => {
          e.parent = o;
        });
        return o;
      }
      _parseWithItem() {
        const e = this._parseTestExpression(true);
        const t = h.WithItemNode.create(e);
        if (this._consumeTokenIfKeyword(1)) {
          t.d.target = this._parseExpression(false);
          t.d.target.parent = t;
          h.extendRange(t, t.d.target);
        }
        return t;
      }
      _parseDecorated() {
        const e = [];
        while (this._peekOperatorType() === 22) {
          e.push(this._parseDecorator());
        }
        const t = this._peekToken();
        if (t.type === 8) {
          if (t.keywordType === 3) {
            this._getNextToken();
            if (this._peekKeywordType() === 10) {
              return this._parseFunctionDef(t, e);
            }
            this._addSyntaxError(g.LocMessage.expectedFunctionAfterAsync(), this._peekToken());
          } else {
            if (t.keywordType === 10) {
              return this._parseFunctionDef(undefined, e);
            }
            if (t.keywordType === 7) {
              return this._parseClassDef(e);
            }
          }
        }
        this._addSyntaxError(g.LocMessage.expectedAfterDecorator(), this._peekToken());
        return h.ClassNode.createDummyForDecorators(e);
      }
      _parseDecorator() {
        const e = this._getNextToken();
        l.assert(e.operatorType === 22);
        const t = this._parseTestExpression(true);
        if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_9)) {
          let e = false;
          if (this._isNameOrMemberAccessExpression(t) || t.nodeType === 9 && this._isNameOrMemberAccessExpression(t.d.leftExpr)) {
            e = true;
          }
          if (!e) {
            this._addSyntaxError(g.LocMessage.expectedDecoratorExpr(), t);
          }
        }
        const n = h.DecoratorNode.create(e, t);
        if (!this._consumeTokenIfType(2)) {
          this._addSyntaxError(g.LocMessage.expectedDecoratorNewline(), this._peekToken());
          this._consumeTokensUntilType([2]);
        }
        return n;
      }
      _isNameOrMemberAccessExpression(e) {
        return e.nodeType === 38 || e.nodeType === 35 && this._isNameOrMemberAccessExpression(e.d.leftExpr);
      }
      _parseClassDef(e) {
        const t = this._getKeywordToken(7);
        let n;
        let a = this._getTokenIfIdentifier();
        if (!a) {
          this._addSyntaxError(g.LocMessage.expectedClassName(), this._peekToken());
          a = v.IdentifierToken.create(0, 0, '', undefined);
        }
        if (this._peekToken().type === 15) {
          n = this._parseTypeParameterList();
          if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_12)) {
            this._addSyntaxError(g.LocMessage.classTypeParametersIllegal(), n);
          }
        }
        let r = [];
        const s = this._peekToken();
        if (this._consumeTokenIfType(13)) {
          r = this._parseArgList().args;
          if (!this._consumeTokenIfType(14)) {
            this._addSyntaxError(g.LocMessage.expectedCloseParen(), s);
          }
        }
        const i = this._parseSuite(false, this._parseOptions.skipFunctionAndClassBody);
        const o = h.ClassNode.create(t, h.NameNode.create(a), i, n);
        o.d.arguments = r;
        r.forEach(e => {
          e.parent = o;
        });
        if (e) {
          o.d.decorators = e;
          if (e.length > 0) {
            e.forEach(e => {
              e.parent = o;
            });
            h.extendRange(o, e[0]);
          }
        }
        return o;
      }
      _parsePassStatement() {
        return h.PassNode.create(this._getKeywordToken(30));
      }
      _parseBreakStatement() {
        const e = this._getKeywordToken(5);
        if (this._isInLoop) {
          if (this._isInExceptionGroup) {
            this._addSyntaxError(g.LocMessage.breakInExceptionGroup(), e);
          }
        } else {
          this._addSyntaxError(g.LocMessage.breakOutsideLoop(), e);
        }
        return h.BreakNode.create(e);
      }
      _parseContinueStatement() {
        const e = this._getKeywordToken(8);
        if (this._isInLoop) {
          if (this._isInExceptionGroup) {
            this._addSyntaxError(g.LocMessage.continueInExceptionGroup(), e);
          }
        } else {
          this._addSyntaxError(g.LocMessage.continueOutsideLoop(), e);
        }
        return h.ContinueNode.create(e);
      }
      _parseReturnStatement() {
        const e = this._getKeywordToken(32);
        const t = h.ReturnNode.create(e);
        if (this._isInFunction) {
          if (this._isInExceptionGroup) {
            this._addSyntaxError(g.LocMessage.returnInExceptionGroup(), e);
          }
        } else {
          this._addSyntaxError(g.LocMessage.returnOutsideFunction(), e);
        }
        if (!this._isNextTokenNeverExpression()) {
          const e = this._parseTestOrStarListAsExpression(true, true, 2, () => g.LocMessage.expectedReturnExpr());
          this._reportConditionalErrorForStarTupleElement(e);
          t.d.expr = e;
          t.d.expr.parent = t;
          h.extendRange(t, e);
        }
        return t;
      }
      _parseFromStatement() {
        const e = this._getKeywordToken(18);
        const t = this._parseDottedModuleName(true);
        const n = h.ImportFromNode.create(e, t);
        const a = t.d.leadingDots === 0 && t.d.nameParts.length === 1 && t.d.nameParts[0].d.value === '__future__';
        const r = this._peekToken();
        if (this._consumeTokenIfKeyword(21)) {
          h.extendRange(n, r);
          const e = this._peekToken();
          if (this._consumeTokenIfOperator(26)) {
            h.extendRange(n, e);
            n.d.isWildcardImport = true;
            n.d.wildcardToken = e;
            this._containsWildcardImport = true;
          } else {
            const e = this._peekToken();
            const t = this._consumeTokenIfType(13);
            let r;
            while (true) {
              const e = this._getTokenIfIdentifier();
              if (!e) {
                break;
              }
              r = undefined;
              const t = h.ImportFromAsNode.create(h.NameNode.create(e));
              if (this._consumeTokenIfKeyword(1)) {
                const e = this._getTokenIfIdentifier();
                if (e) {
                  t.d.alias = h.NameNode.create(e);
                  t.d.alias.parent = t;
                  h.extendRange(t, e);
                } else {
                  this._addSyntaxError(g.LocMessage.expectedImportAlias(), this._peekToken());
                }
              }
              n.d.imports.push(t);
              t.parent = n;
              h.extendRange(n, t);
              if (a) {
                this._futureImports.add(e.value);
              }
              const s = this._peekToken();
              if (!this._consumeTokenIfType(12)) {
                break;
              }
              r = s;
            }
            if (n.d.imports.length === 0) {
              this._addSyntaxError(g.LocMessage.expectedImportSymbols(), this._peekToken());
            }
            if (t) {
              n.d.usesParens = true;
              const t = this._peekToken();
              if (this._consumeTokenIfType(14)) {
                h.extendRange(n, t);
              } else {
                this._addSyntaxError(g.LocMessage.expectedCloseParen(), e);
              }
            } else {
              if (r) {
                this._addSyntaxError(g.LocMessage.trailingCommaInFromImport(), r);
              }
            }
          }
        } else {
          this._addSyntaxError(g.LocMessage.expectedImport(), this._peekToken());
          if (!t.d.hasTrailingDot) {
            n.d.missingImport = true;
          }
        }
        this._importedModules.push({
          nameNode: n.d.module,
          leadingDots: n.d.module.d.leadingDots,
          nameParts: n.d.module.d.nameParts.map(e => e.d.value),
          importedSymbols: new Set(n.d.imports.map(e => e.d.name.d.value))
        });
        let s = false;
        if (n.d.module.d.nameParts.length === 1) {
          const e = n.d.module.d.nameParts[0].d.value;
          if (e === 'typing' || e === 'typing_extensions') {
            s = true;
          }
        }
        if (s) {
          const e = ['Literal', 'TypeAlias', 'Annotated'];
          if (n.d.isWildcardImport) {
            e.forEach(e => {
              this._typingSymbolAliases.set(e, e);
            });
          } else {
            n.d.imports.forEach(t => {
              var n;
              if (e.some(e => e === t.d.name.d.value)) {
                this._typingSymbolAliases.set(((n = t.d.alias) === null || n === undefined ? undefined : n.d.value) || t.d.name.d.value, t.d.name.d.value);
              }
            });
          }
        }
        return n;
      }
      _parseImportStatement() {
        var e;
        const t = this._getKeywordToken(21);
        const n = h.ImportNode.create(t);
        while (true) {
          const t = this._parseDottedModuleName();
          const a = h.ImportAsNode.create(t);
          if (this._consumeTokenIfKeyword(1)) {
            const e = this._getTokenIfIdentifier();
            if (e) {
              a.d.alias = h.NameNode.create(e);
              a.d.alias.parent = a;
              h.extendRange(a, a.d.alias);
            } else {
              this._addSyntaxError(g.LocMessage.expectedImportAlias(), this._peekToken());
            }
          }
          if (a.d.module.d.leadingDots > 0) {
            this._addSyntaxError(g.LocMessage.relativeImportNotAllowed(), a.d.module);
          }
          n.d.list.push(a);
          a.parent = n;
          const r = a.d.module.d.nameParts.map(e => e.d.value);
          if (a.d.alias || a.d.module.d.leadingDots > 0 || a.d.module.d.nameParts.length === 0) {
            this._importedModules.push({
              nameNode: a.d.module,
              leadingDots: a.d.module.d.leadingDots,
              nameParts: r,
              importedSymbols: undefined
            });
          } else {
            a.d.module.d.nameParts.forEach((e, t) => {
              this._importedModules.push({
                nameNode: a.d.module,
                leadingDots: a.d.module.d.leadingDots,
                nameParts: r.slice(0, t + 1),
                importedSymbols: undefined
              });
            });
          }
          if (t.d.nameParts.length === 1) {
            const n = t.d.nameParts[0].d.value;
            if (n === 'typing' || n === 'typing_extensions') {
              this._typingImportAliases.push(((e = a.d.alias) === null || e === undefined ? undefined : e.d.value) || n);
            }
          }
          if (!this._consumeTokenIfType(12)) {
            break;
          }
        }
        if (n.d.list.length > 0) {
          h.extendRange(n, n.d.list[n.d.list.length - 1]);
        }
        return n;
      }
      _parseDottedModuleName(e = false) {
        var t;
        const n = h.ModuleNameNode.create(this._peekToken());
        while (true) {
          const e = (t = this._getTokenIfType(19)) !== null && t !== undefined ? t : this._getTokenIfType(20);
          if (!e) {
            break;
          }
          if (e.type === 19) {
            n.d.leadingDots += 3;
          } else {
            n.d.leadingDots++;
          }
          h.extendRange(n, e);
        }
        while (true) {
          const t = this._getTokenIfIdentifier();
          if (!t) {
            if (!e || n.d.leadingDots === 0 || n.d.nameParts.length > 0) {
              this._addSyntaxError(g.LocMessage.expectedModuleName(), this._peekToken());
              n.d.hasTrailingDot = true;
            }
            break;
          }
          const a = h.NameNode.create(t);
          n.d.nameParts.push(a);
          a.parent = n;
          h.extendRange(n, a);
          const r = this._peekToken();
          if (!this._consumeTokenIfType(20)) {
            break;
          }
          h.extendRange(n, r);
        }
        return n;
      }
      _parseGlobalStatement() {
        const e = this._getKeywordToken(19);
        const t = h.GlobalNode.create(e);
        t.d.targets = this._parseNameList();
        if (t.d.targets.length > 0) {
          t.d.targets.forEach(e => {
            e.parent = t;
          });
          h.extendRange(t, t.d.targets[t.d.targets.length - 1]);
        }
        return t;
      }
      _parseNonlocalStatement() {
        const e = this._getKeywordToken(27);
        const t = h.NonlocalNode.create(e);
        t.d.targets = this._parseNameList();
        if (t.d.targets.length > 0) {
          t.d.targets.forEach(e => {
            e.parent = t;
          });
          h.extendRange(t, t.d.targets[t.d.targets.length - 1]);
        }
        return t;
      }
      _parseNameList() {
        const e = [];
        while (true) {
          const t = this._getTokenIfIdentifier();
          if (!t) {
            this._addSyntaxError(g.LocMessage.expectedIdentifier(), this._peekToken());
            break;
          }
          e.push(h.NameNode.create(t));
          if (!this._consumeTokenIfType(12)) {
            break;
          }
        }
        return e;
      }
      _parseRaiseStatement() {
        const e = this._getKeywordToken(31);
        const t = h.RaiseNode.create(e);
        if (!this._isNextTokenNeverExpression()) {
          t.d.expr = this._parseTestExpression(true);
          t.d.expr.parent = t;
          h.extendRange(t, t.d.expr);
          if (this._consumeTokenIfKeyword(18)) {
            t.d.fromExpr = this._parseTestExpression(true);
            t.d.fromExpr.parent = t;
            h.extendRange(t, t.d.fromExpr);
          }
        }
        return t;
      }
      _parseAssertStatement() {
        const e = this._getKeywordToken(2);
        const t = this._parseTestExpression(false);
        const n = h.AssertNode.create(e, t);
        if (this._consumeTokenIfType(12)) {
          const e = this._parseTestExpression(false);
          n.d.exceptionExpr = e;
          n.d.exceptionExpr.parent = n;
          h.extendRange(n, e);
        }
        return n;
      }
      _parseDelStatement() {
        const e = this._getKeywordToken(11);
        const t = this._parseExpressionList(true);
        if (!t.parseError && t.list.length === 0) {
          this._addSyntaxError(g.LocMessage.expectedDelExpr(), this._peekToken());
        }
        const n = h.DelNode.create(e);
        n.d.targets = t.list;
        if (n.d.targets.length > 0) {
          n.d.targets.forEach(e => {
            e.parent = n;
          });
          h.extendRange(n, n.d.targets[n.d.targets.length - 1]);
        }
        return n;
      }
      _parseYieldExpression() {
        const e = this._getKeywordToken(38);
        const t = this._peekToken();
        if (this._consumeTokenIfKeyword(18)) {
          if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_3)) {
            this._addSyntaxError(g.LocMessage.yieldFromIllegal(), t);
          }
          return h.YieldFromNode.create(e, this._parseTestExpression(false));
        }
        let n;
        if (!this._isNextTokenNeverExpression()) {
          n = this._parseTestOrStarListAsExpression(false, true, 2, () => g.LocMessage.expectedYieldExpr());
          this._reportConditionalErrorForStarTupleElement(n);
        }
        return h.YieldNode.create(e, n);
      }
      _tryParseYieldExpression() {
        if (this._peekKeywordType() === 38) {
          return this._parseYieldExpression();
        }
      }
      _parseSimpleStatement() {
        const e = h.StatementListNode.create(this._peekToken());
        while (true) {
          if (this._peekTokenType() === 0) {
            const e = this._getNextToken();
            const t = this._fileContents.substr(e.start, e.length).charCodeAt(0);
            this._addSyntaxError(g.LocMessage.invalidTokenChars().format({
              text: `\\u${t.toString(16)}`
            }), e);
            this._consumeTokensUntilType([2]);
            break;
          }
          const t = this._parseSmallStatement();
          e.d.statements.push(t);
          t.parent = e;
          h.extendRange(e, t);
          if (t.nodeType === 0) {
            break;
          }
          if (!this._consumeTokenIfType(11)) {
            break;
          }
          const n = this._peekTokenType();
          if (n === 2 || n === 1) {
            break;
          }
        }
        if (!this._consumeTokenIfType(2)) {
          this._addSyntaxError(g.LocMessage.expectedNewlineOrSemicolon(), this._peekToken());
        }
        return e;
      }
      _parseSmallStatement() {
        switch (this._peekKeywordType()) {
          case 30:
            return this._parsePassStatement();
          case 5:
            return this._parseBreakStatement();
          case 8:
            return this._parseContinueStatement();
          case 32:
            return this._parseReturnStatement();
          case 18:
            return this._parseFromStatement();
          case 21:
            return this._parseImportStatement();
          case 19:
            return this._parseGlobalStatement();
          case 27:
            return this._parseNonlocalStatement();
          case 31:
            return this._parseRaiseStatement();
          case 2:
            return this._parseAssertStatement();
          case 11:
            return this._parseDelStatement();
          case 38:
            return this._parseYieldExpression();
          case 35:
            {
              const e = this._peekToken(1);
              const t = this._peekToken(2);
              let n = true;
              if ((e.type === 7 || e.type === 8 && v.KeywordToken.isSoftKeyword(e)) && (t.type === 15 || t.type === 9 && t.operatorType === 2)) {
                n = false;
              }
              if (!n) {
                return this._parseTypeAliasStatement();
              }
              break;
            }
        }
        return this._parseExpressionStatement();
      }
      _makeExpressionOrTuple(e, t) {
        if (e.list.length === 1 && !e.trailingComma) {
          if (e.list[0].nodeType === 56) {
            this._addSyntaxError(g.LocMessage.unpackOperatorNotAllowed(), e.list[0]);
          }
          return e.list[0];
        }
        const n = e.list.length > 0 ? e.list[0] : this._peekToken(-1);
        const a = h.TupleNode.create(n, t);
        a.d.items = e.list;
        if (e.list.length > 0) {
          e.list.forEach(e => {
            e.parent = a;
          });
          h.extendRange(a, e.list[e.list.length - 1]);
        }
        return a;
      }
      _parseExpressionListAsPossibleTuple(e, t, n) {
        if (this._isNextTokenNeverExpression()) {
          this._addSyntaxError(t(), n);
          return h.ErrorNode.create(n, e);
        }
        const a = this._parseExpressionList(true);
        if (a.parseError) {
          return a.parseError;
        } else {
          return this._makeExpressionOrTuple(a, false);
        }
      }
      _parseTestListAsExpression(e, t) {
        if (this._isNextTokenNeverExpression()) {
          return this._handleExpressionParseError(e, t());
        }
        const n = this._parseTestExpressionList();
        if (n.parseError) {
          return n.parseError;
        } else {
          return this._makeExpressionOrTuple(n, false);
        }
      }
      _parseTestOrStarListAsExpression(e, t, n, a) {
        if (this._isNextTokenNeverExpression()) {
          return this._handleExpressionParseError(n, a());
        }
        const r = this._parseTestOrStarExpressionList(e, t);
        if (r.parseError) {
          return r.parseError;
        } else {
          return this._makeExpressionOrTuple(r, false);
        }
      }
      _parseExpressionList(e) {
        return this._parseExpressionListGeneric(() => this._parseExpression(e));
      }
      _parseTestExpressionList() {
        return this._parseExpressionListGeneric(() => this._parseTestExpression(false));
      }
      _parseTestOrStarExpressionList(e, t) {
        const n = this._parseExpressionListGeneric(() => this._parseTestOrStarExpression(e));
        if (!t && !n.parseError) {
          let e = false;
          for (const t of n.list) {
            if (t.nodeType === 56) {
              if (e) {
                this._addSyntaxError(g.LocMessage.duplicateUnpack(), t);
                break;
              }
              e = true;
            }
          }
        }
        return n;
      }
      _parseExpression(e) {
        const t = this._peekToken();
        if (e && this._consumeTokenIfOperator(26)) {
          return h.UnpackNode.create(t, this._parseExpression(false));
        } else {
          return this._parseBitwiseOrExpression();
        }
      }
      _parseTestOrStarExpression(e) {
        if (this._peekOperatorType() === 26) {
          return this._parseExpression(true);
        } else {
          return this._parseTestExpression(e);
        }
      }
      _parseTestExpression(e) {
        if (this._peekKeywordType() === 24) {
          return this._parseLambdaExpression();
        }
        const t = this._parseAssignmentExpression(!e);
        if (t.nodeType === 0) {
          return t;
        }
        if (!this._consumeTokenIfKeyword(20)) {
          return t;
        }
        const n = this._parseOrTest();
        if (n.nodeType === 0) {
          return n;
        }
        if (!this._consumeTokenIfKeyword(13)) {
          return h.TernaryNode.create(t, n, this._handleExpressionParseError(1, g.LocMessage.expectedElse()));
        }
        const a = this._parseTestExpression(true);
        return h.TernaryNode.create(t, n, a);
      }
      _parseAssignmentExpression(e = false) {
        const t = this._parseOrTest();
        if (t.nodeType === 0) {
          return t;
        }
        if (t.nodeType !== 38) {
          return t;
        }
        const n = this._peekToken();
        if (!this._consumeTokenIfOperator(35)) {
          return t;
        }
        if (!this._assignmentExpressionsAllowed || !!e) {
          this._addSyntaxError(g.LocMessage.walrusNotAllowed(), n);
        }
        if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_8)) {
          this._addSyntaxError(g.LocMessage.walrusIllegal(), n);
        }
        const a = this._parseTestExpression(false);
        return h.AssignmentExpressionNode.create(t, n, a);
      }
      _parseOrTest() {
        let e = this._parseAndTest();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          const t = this._peekToken();
          if (!this._consumeTokenIfKeyword(29)) {
            break;
          }
          const n = this._parseAndTest();
          e = this._createBinaryOperationNode(e, n, t, 37);
        }
        return e;
      }
      _parseAndTest() {
        let e = this._parseNotTest();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          const t = this._peekToken();
          if (!this._consumeTokenIfKeyword(0)) {
            break;
          }
          const n = this._parseNotTest();
          e = this._createBinaryOperationNode(e, n, t, 36);
        }
        return e;
      }
      _parseNotTest() {
        const e = this._peekToken();
        if (this._consumeTokenIfKeyword(28)) {
          const t = this._parseNotTest();
          return this._createUnaryOperationNode(e, t, 38);
        }
        return this._parseComparison();
      }
      _parseComparison() {
        let e = this._parseBitwiseOrExpression();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          let t;
          const n = this._peekToken();
          if (T.Tokenizer.isOperatorComparison(this._peekOperatorType())) {
            t = this._peekOperatorType();
            if (t === 19) {
              this._addSyntaxError(g.LocMessage.operatorLessOrGreaterDeprecated(), n);
              t = 28;
            }
            this._getNextToken();
          } else {
            if (this._consumeTokenIfKeyword(22)) {
              t = 41;
            } else {
              if (this._consumeTokenIfKeyword(23)) {
                t = this._consumeTokenIfKeyword(28) ? 40 : 39;
              } else {
                if (this._peekKeywordType() === 28) {
                  const e = this._peekToken(1);
                  if (e.type === 8 && e.keywordType === 22) {
                    this._getNextToken();
                    this._getNextToken();
                    t = 42;
                  }
                }
              }
            }
          }
          if (t === undefined) {
            break;
          }
          const a = this._parseComparison();
          e = this._createBinaryOperationNode(e, a, n, t);
        }
        return e;
      }
      _parseBitwiseOrExpression() {
        let e = this._parseBitwiseXorExpression();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          const t = this._peekToken();
          if (!this._consumeTokenIfOperator(6)) {
            break;
          }
          const n = this._parseBitwiseXorExpression();
          e = this._createBinaryOperationNode(e, n, t, 6);
        }
        return e;
      }
      _parseBitwiseXorExpression() {
        let e = this._parseBitwiseAndExpression();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          const t = this._peekToken();
          if (!this._consumeTokenIfOperator(8)) {
            break;
          }
          const n = this._parseBitwiseAndExpression();
          e = this._createBinaryOperationNode(e, n, t, 8);
        }
        return e;
      }
      _parseBitwiseAndExpression() {
        let e = this._parseShiftExpression();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          const t = this._peekToken();
          if (!this._consumeTokenIfOperator(3)) {
            break;
          }
          const n = this._parseShiftExpression();
          e = this._createBinaryOperationNode(e, n, t, 3);
        }
        return e;
      }
      _parseShiftExpression() {
        let e = this._parseArithmeticExpression();
        if (e.nodeType === 0) {
          return e;
        }
        let t = this._peekToken();
        let n = this._peekOperatorType();
        while (n === 17 || n === 31) {
          this._getNextToken();
          const a = this._parseArithmeticExpression();
          e = this._createBinaryOperationNode(e, a, t, n);
          t = this._peekToken();
          n = this._peekOperatorType();
        }
        return e;
      }
      _parseArithmeticExpression() {
        let e = this._parseArithmeticTerm();
        if (e.nodeType === 0) {
          return e;
        }
        let t = this._peekToken();
        let n = this._peekOperatorType();
        while (n === 0 || n === 33) {
          this._getNextToken();
          const a = this._parseArithmeticTerm();
          if (a.nodeType === 0) {
            return a;
          }
          e = this._createBinaryOperationNode(e, a, t, n);
          t = this._peekToken();
          n = this._peekOperatorType();
        }
        return e;
      }
      _parseArithmeticTerm() {
        let e = this._parseArithmeticFactor();
        if (e.nodeType === 0) {
          return e;
        }
        let t = this._peekToken();
        let n = this._peekOperatorType();
        while (n === 26 || n === 22 || n === 10 || n === 24 || n === 13) {
          this._getNextToken();
          const a = this._parseArithmeticFactor();
          e = this._createBinaryOperationNode(e, a, t, n);
          t = this._peekToken();
          n = this._peekOperatorType();
        }
        return e;
      }
      _parseArithmeticFactor() {
        const e = this._peekToken();
        const t = this._peekOperatorType();
        if (t === 0 || t === 33 || t === 5) {
          this._getNextToken();
          const n = this._parseArithmeticFactor();
          return this._createUnaryOperationNode(e, n, t);
        }
        const n = this._parseAtomExpression();
        if (n.nodeType === 0) {
          return n;
        }
        const a = this._peekToken();
        if (this._consumeTokenIfOperator(29)) {
          const e = this._parseArithmeticFactor();
          return this._createBinaryOperationNode(n, e, a, 29);
        }
        return n;
      }
      _isTypingAnnotation(e, t) {
        if (e.nodeType === 38) {
          if (this._typingSymbolAliases.get(e.d.value) === t) {
            return true;
          }
        } else {
          if (e.nodeType === 35 && e.d.leftExpr.nodeType === 38 && e.d.member.d.value === t) {
            const t = e.d.leftExpr.d.value;
            return this._typingImportAliases.some(e => e === t);
          }
        }
        return false;
      }
      _parseAtomExpression() {
        var e;
        var t;
        var n;
        let a;
        if (this._peekKeywordType() === 4) {
          a = this._getKeywordToken(4);
          if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_5)) {
            this._addSyntaxError(g.LocMessage.awaitIllegal(), a);
          }
        }
        let r = this._parseAtom();
        if (r.nodeType === 0) {
          return r;
        }
        while (true) {
          const a = this._peekToken();
          if (this._consumeTokenIfType(13)) {
            const t = this._isParsingTypeAnnotation;
            this._isParsingTypeAnnotation = false;
            const n = this._parseArgList();
            const s = h.CallNode.create(r, n.args, n.trailingComma);
            if (n.args.length > 1 || n.trailingComma) {
              n.args.forEach(e => {
                if (e.d.valueExpr.nodeType === 11) {
                  if (!e.d.valueExpr.d.hasParens) {
                    this._addSyntaxError(g.LocMessage.generatorNotParenthesized(), e.d.valueExpr);
                  }
                }
              });
            }
            const i = this._peekToken();
            let o = false;
            if (this._consumeTokenIfType(14)) {
              h.extendRange(s, i);
              o = true;
            } else {
              this._addSyntaxError(g.LocMessage.expectedCloseParen(), a);
              this._consumeTokensUntilType([2]);
              h.extendRange(s, this._peekToken());
            }
            this._isParsingTypeAnnotation = t;
            const l = (e = this._maxChildDepthMap.get(r.id)) !== null && e !== undefined ? e : 0;
            if (l >= _) {
              r = h.ErrorNode.create(s, 15);
              this._addSyntaxError(g.LocMessage.maxParseDepthExceeded(), r);
            } else {
              r = s;
              this._maxChildDepthMap.set(s.id, l + 1);
            }
            if (!o) {
              break;
            }
          } else {
            if (this._consumeTokenIfType(15)) {
              const e = this._isParsingIndexTrailer;
              const n = this._isParsingTypeAnnotation;
              if (this._isTypingAnnotation(r, 'Literal') || this._isTypingAnnotation(r, 'Annotated')) {
                this._isParsingTypeAnnotation = false;
              }
              this._isParsingIndexTrailer = true;
              const s = this._parseSubscriptList();
              this._isParsingTypeAnnotation = n;
              this._isParsingIndexTrailer = e;
              const i = this._peekToken();
              const o = h.IndexNode.create(r, s.list, s.trailingComma, i);
              h.extendRange(o, o);
              if (!this._consumeTokenIfType(16)) {
                this._handleExpressionParseError(6, g.LocMessage.expectedCloseBracket(), a, o);
              }
              const l = (t = this._maxChildDepthMap.get(r.id)) !== null && t !== undefined ? t : 0;
              if (l >= _) {
                r = h.ErrorNode.create(o, 15);
                this._addSyntaxError(g.LocMessage.maxParseDepthExceeded(), r);
              } else {
                r = o;
                this._maxChildDepthMap.set(o.id, l + 1);
              }
            } else {
              if (!this._consumeTokenIfType(20)) {
                break;
              }
              {
                const e = this._getTokenIfIdentifier();
                if (!e) {
                  return this._handleExpressionParseError(7, g.LocMessage.expectedMemberName(), a, r, [8]);
                }
                const t = h.MemberAccessNode.create(r, h.NameNode.create(e));
                const s = (n = this._maxChildDepthMap.get(r.id)) !== null && n !== undefined ? n : 0;
                if (s >= _) {
                  r = h.ErrorNode.create(t, 15);
                  this._addSyntaxError(g.LocMessage.maxParseDepthExceeded(), r);
                } else {
                  r = t;
                  this._maxChildDepthMap.set(t.id, s + 1);
                }
              }
            }
          }
        }
        if (a) {
          return h.AwaitNode.create(a, r);
        } else {
          return r;
        }
      }
      _parseSubscriptList() {
        const e = [];
        let t = false;
        let n = false;
        while (true) {
          const a = this._peekToken();
          if (a.type !== 10 && this._isNextTokenNeverExpression()) {
            break;
          }
          let r = 0;
          if (this._consumeTokenIfOperator(26)) {
            r = 1;
          } else {
            if (this._consumeTokenIfOperator(29)) {
              r = 2;
            }
          }
          const s = this._tokenIndex;
          let i;
          let o = this._parsePossibleSlice();
          if (r === 0) {
            if (this._consumeTokenIfOperator(2)) {
              const e = o;
              o = this._parsePossibleSlice();
              if (e.nodeType === 38) {
                i = e.d.token;
              } else {
                this._addSyntaxError(g.LocMessage.expectedParamName(), e);
              }
            } else {
              if (o.nodeType === 38 && this._peekOperatorType() === 35) {
                this._tokenIndex = s;
                o = this._parseTestExpression(true);
                if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_10)) {
                  this._addSyntaxError(g.LocMessage.assignmentExprInSubscript(), o);
                }
              }
            }
          }
          const l = h.ArgumentNode.create(a, o, r);
          if (i) {
            l.d.name = h.NameNode.create(i);
            l.d.name.parent = l;
          }
          if (l.d.name) {
            t = true;
          } else {
            if (t && l.d.argCategory === 0) {
              this._addSyntaxError(g.LocMessage.positionArgAfterNamedArg(), l);
            }
          }
          e.push(l);
          if (l.d.name) {
            this._addSyntaxError(g.LocMessage.keywordSubscriptIllegal(), l.d.name);
          }
          if (r !== 0) {
            const e = this._parseOptions.isStubFile || this._isParsingQuotedText || u.PythonVersion.isGreaterOrEqualTo(this._getLanguageVersion(), u.pythonVersion3_11);
            if (r === 1 && !e) {
              this._addSyntaxError(g.LocMessage.unpackedSubscriptIllegal(), l);
            }
            if (r === 2) {
              this._addSyntaxError(g.LocMessage.unpackedDictSubscriptIllegal(), l);
            }
          }
          if (!this._consumeTokenIfType(12)) {
            n = false;
            break;
          }
          n = true;
        }
        if (e.length === 0) {
          const t = this._handleExpressionParseError(3, g.LocMessage.expectedSliceIndex(), undefined, undefined, [16]);
          e.push(h.ArgumentNode.create(this._peekToken(), t, 0));
        }
        return {
          list: e,
          trailingComma: n
        };
      }
      _parsePossibleSlice() {
        const e = this._peekToken();
        const t = [undefined, undefined, undefined];
        let n = 0;
        let a = false;
        while (true) {
          const e = this._peekTokenType();
          if (e === 16 || e === 12) {
            break;
          }
          if (e !== 10) {
            const e = this._parseOptions.isStubFile || u.PythonVersion.isGreaterOrEqualTo(this._getLanguageVersion(), u.pythonVersion3_10);
            t[n] = this._parseTestExpression(e);
          }
          n++;
          if (n >= 3 || !this._consumeTokenIfType(10)) {
            break;
          }
          a = true;
        }
        if (!a) {
          if (t[0]) {
            return t[0];
          } else {
            return h.ErrorNode.create(this._peekToken(), 3);
          }
        }
        const r = h.SliceNode.create(e);
        r.d.startValue = t[0];
        if (r.d.startValue) {
          r.d.startValue.parent = r;
        }
        r.d.endValue = t[1];
        if (r.d.endValue) {
          r.d.endValue.parent = r;
        }
        r.d.stepValue = t[2];
        if (r.d.stepValue) {
          r.d.stepValue.parent = r;
        }
        const s = t[2] || t[1] || t[0];
        if (s) {
          h.extendRange(r, s);
        }
        return r;
      }
      _parseArgList() {
        const e = [];
        let t = false;
        let n = false;
        while (true) {
          const a = this._peekTokenType();
          if (a === 14 || a === 2 || a === 1) {
            break;
          }
          n = false;
          const r = this._parseArgument();
          if (r.d.name) {
            t = true;
          } else {
            if (t && r.d.argCategory === 0) {
              this._addSyntaxError(g.LocMessage.positionArgAfterNamedArg(), r);
            }
          }
          e.push(r);
          if (!this._consumeTokenIfType(12)) {
            break;
          }
          n = true;
        }
        return {
          args: e,
          trailingComma: n
        };
      }
      _parseArgument() {
        const e = this._peekToken();
        let t = 0;
        if (this._consumeTokenIfOperator(26)) {
          t = 1;
        } else {
          if (this._consumeTokenIfOperator(29)) {
            t = 2;
          }
        }
        let n;
        let a;
        let r = this._parseTestExpression(true);
        let s = false;
        if (t === 0) {
          const e = this._peekToken();
          if (this._consumeTokenIfOperator(2)) {
            a = e;
            const t = r;
            if (t.nodeType !== 38 || this._peekTokenType() !== 12 && this._peekTokenType() !== 14) {
              r = this._parseTestExpression(false);
              if (t.nodeType === 38) {
                n = h.NameNode.create(t.d.token);
              } else {
                this._addSyntaxError(g.LocMessage.expectedParamName(), t);
              }
            } else {
              n = h.NameNode.create(t.d.token);
              if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_14)) {
                this._addSyntaxError(g.LocMessage.keywordArgShortcutIllegal(), a);
                r = h.ErrorNode.create(a, 14);
              } else {
                r = h.NameNode.create(t.d.token);
                s = true;
              }
            }
          } else {
            const e = this._tryParseComprehension(r, true);
            if (e) {
              r = e;
            }
          }
        }
        const i = h.ArgumentNode.create(e, r, t);
        if (n) {
          i.d.name = n;
          i.d.isNameSameAsValue = s;
          i.d.name.parent = i;
          if (a) {
            h.extendRange(i, a);
          }
        }
        return i;
      }
      _parseAtom() {
        const e = this._peekToken();
        if (e.type === 19) {
          return h.EllipsisNode.create(this._getNextToken());
        }
        if (e.type === 6) {
          return h.NumberNode.create(this._getNextToken());
        }
        if (e.type === 7) {
          return h.NameNode.create(this._getNextToken());
        }
        if (e.type === 5 || e.type === 24) {
          return this._parseStringList();
        }
        if (e.type === 22) {
          this._getNextToken();
          this._addSyntaxError(g.LocMessage.backticksIllegal(), e);
          const t = this._parseTestListAsExpression(2, () => g.LocMessage.expectedExpr());
          this._consumeTokenIfType(22);
          return t;
        }
        if (e.type === 13) {
          const e = this._parseTupleAtom();
          if (e.nodeType === 55 || e.nodeType === 6 || e.nodeType === 7) {
            e.d.hasParens = true;
          }
          if (e.nodeType === 48 || e.nodeType === 11 || e.nodeType === 4) {
            e.d.hasParens = true;
          }
          return e;
        }
        if (e.type === 15) {
          return this._parseListAtom();
        }
        if (e.type === 17) {
          return this._parseDictionaryOrSetAtom();
        }
        if (e.type === 8) {
          const t = e;
          if (t.keywordType === 15 || t.keywordType === 33 || t.keywordType === 9 || t.keywordType === 26) {
            return h.ConstantNode.create(this._getNextToken());
          }
          const n = this._getTokenIfIdentifier();
          if (n) {
            return h.NameNode.create(n);
          }
        }
        return this._handleExpressionParseError(2, g.LocMessage.expectedExpr());
      }
      _handleExpressionParseError(e, t, n, a, r) {
        var s;
        this._addSyntaxError(t, n ?? this._peekToken());
        const i = [2];
        if (r) {
          o.appendArray(i, r);
        }
        const l = this._peekToken();
        const p = i.some(e => l.type === e) ? (s = n ?? a) !== null && s !== undefined ? s : m.TextRange.create(l.start, 0) : l;
        const d = h.ErrorNode.create(p, e, a);
        this._consumeTokensUntilType(i);
        return d;
      }
      _parseLambdaExpression(e = true) {
        const t = this._getKeywordToken(24);
        const n = this._parseVarArgsList(10, false);
        let a;
        if (!this._consumeTokenIfType(10)) {
          this._addSyntaxError(g.LocMessage.expectedColon(), this._peekToken());
        }
        a = e ? this._parseTestExpression(false) : this._tryParseLambdaExpression(false) || this._parseOrTest();
        const r = h.LambdaNode.create(t, a);
        r.d.params = n;
        n.forEach(e => {
          e.parent = r;
        });
        return r;
      }
      _tryParseLambdaExpression(e = true) {
        if (this._peekKeywordType() === 24) {
          return this._parseLambdaExpression(e);
        }
      }
      _parseTupleAtom() {
        var e;
        const t = this._getNextToken();
        l.assert(t.type === 13);
        const n = this._tryParseYieldExpression();
        if (n) {
          if (this._peekTokenType() !== 14) {
            return this._handleExpressionParseError(8, g.LocMessage.expectedCloseParen(), t, n);
          } else {
            h.extendRange(n, this._getNextToken());
            return n;
          }
        }
        const a = this._parseTestListWithComprehension(true);
        const r = this._makeExpressionOrTuple(a, true);
        h.extendRange(r, t);
        if (this._peekTokenType() !== 14) {
          return this._handleExpressionParseError(8, g.LocMessage.expectedCloseParen(), t, (e = a.parseError) !== null && e !== undefined ? e : r);
        } else {
          h.extendRange(r, this._getNextToken());
          return r;
        }
      }
      _parseListAtom() {
        var e;
        const t = this._getNextToken();
        l.assert(t.type === 15);
        const n = this._parseTestListWithComprehension(false);
        const a = this._peekToken();
        if (this._consumeTokenIfType(16)) {
          return r();
        } else {
          return this._handleExpressionParseError(9, g.LocMessage.expectedCloseBracket(), t, (e = n.parseError) !== null && e !== undefined ? e : r());
        }
        function r() {
          const e = h.ListNode.create(t);
          if (a) {
            h.extendRange(e, a);
          }
          if (n.list.length > 0) {
            n.list.forEach(t => {
              t.parent = e;
            });
            h.extendRange(e, n.list[n.list.length - 1]);
          }
          e.d.items = n.list;
          return e;
        }
      }
      _parseTestListWithComprehension(e) {
        let t = false;
        return this._parseExpressionListGeneric(() => {
          let n = this._parseTestOrStarExpression(true);
          const a = this._tryParseComprehension(n, e);
          if (a) {
            n = a;
            t = true;
          }
          return n;
        }, () => this._isNextTokenNeverExpression(), () => t);
      }
      _parseDictionaryOrSetAtom() {
        const e = this._getNextToken();
        l.assert(e.type === 17);
        const t = [];
        const n = [];
        let a;
        let r = false;
        let s = false;
        let i = false;
        let o = true;
        while (this._peekTokenType() !== 18) {
          let e;
          let p;
          let d;
          a = undefined;
          const c = this._peekToken();
          if (this._consumeTokenIfOperator(29)) {
            e = this._parseExpression(false);
          } else {
            p = this._parseTestOrStarExpression(true);
            let e = u.PythonVersion.isGreaterOrEqualTo(this._getLanguageVersion(), u.pythonVersion3_10);
            if (this._consumeTokenIfType(10)) {
              d = this._parseTestExpression(false);
              e = false;
            }
            if (!e && p.nodeType === 4 && !p.d.hasParens) {
              this._addSyntaxError(g.LocMessage.walrusNotAllowed(), p.d.walrusToken);
            }
          }
          if (p && d) {
            if (p.nodeType === 56) {
              this._addSyntaxError(g.LocMessage.unpackInDict(), p);
            }
            if (s) {
              this._addSyntaxError(g.LocMessage.keyValueInSet(), d);
            } else {
              const e = h.DictionaryKeyEntryNode.create(p, d);
              let n = e;
              const a = this._tryParseComprehension(e, false);
              if (a) {
                n = a;
                i = true;
                if (!o) {
                  this._addSyntaxError(g.LocMessage.comprehensionInDict(), n);
                }
              }
              t.push(n);
              r = true;
            }
          } else {
            if (e) {
              if (s) {
                this._addSyntaxError(g.LocMessage.unpackInSet(), e);
              } else {
                const n = h.DictionaryExpandEntryNode.create(e);
                h.extendRange(n, c);
                let a = n;
                const s = this._tryParseComprehension(n, false);
                if (s) {
                  a = s;
                  i = true;
                  if (!o) {
                    this._addSyntaxError(g.LocMessage.comprehensionInDict(), e);
                  }
                }
                t.push(a);
                r = true;
              }
            } else {
              l.assert(p !== undefined);
              if (p) {
                if (r) {
                  const e = h.ErrorNode.create(this._peekToken(), 13);
                  const n = h.DictionaryKeyEntryNode.create(p, e);
                  t.push(n);
                  this._addSyntaxError(g.LocMessage.dictKeyValuePairs(), p);
                } else {
                  const e = this._tryParseComprehension(p, false);
                  if (e) {
                    p = e;
                    i = true;
                    if (!o) {
                      this._addSyntaxError(g.LocMessage.comprehensionInSet(), p);
                    }
                  }
                  n.push(p);
                  s = true;
                }
              }
            }
          }
          if (i) {
            break;
          }
          if (this._peekTokenType() !== 12) {
            break;
          }
          a = this._getNextToken();
          o = false;
        }
        let p = this._peekToken();
        if (!this._consumeTokenIfType(18)) {
          this._addSyntaxError(g.LocMessage.expectedCloseBrace(), e);
          p = undefined;
        }
        if (s) {
          const t = h.SetNode.create(e);
          if (p) {
            h.extendRange(t, p);
          }
          if (n.length > 0) {
            h.extendRange(t, n[n.length - 1]);
          }
          n.forEach(e => {
            e.parent = t;
          });
          t.d.items = n;
          return t;
        }
        const d = h.DictionaryNode.create(e);
        if (a) {
          d.d.trailingCommaToken = a;
          h.extendRange(d, a);
        }
        if (p) {
          h.extendRange(d, p);
        }
        if (t.length > 0) {
          t.forEach(e => {
            e.parent = d;
          });
          h.extendRange(d, t[t.length - 1]);
        }
        d.d.items = t;
        return d;
      }
      _parseExpressionListGeneric(e, t = () => this._isNextTokenNeverExpression(), n = () => false) {
        let a = false;
        const r = [];
        let s;
        while (!t()) {
          const t = e();
          if (t.nodeType === 0) {
            s = t;
            break;
          }
          r.push(t);
          if (n()) {
            break;
          }
          if (!this._consumeTokenIfType(12)) {
            a = false;
            break;
          }
          a = true;
        }
        return {
          trailingComma: a,
          list: r,
          parseError: s
        };
      }
      _parseExpressionStatement() {
        var e;
        var t;
        let n;
        let a = this._parseTestOrStarListAsExpression(false, false, 2, () => g.LocMessage.expectedExpr());
        if (a.nodeType === 0) {
          return a;
        }
        if (this._consumeTokenIfType(10)) {
          n = this._parseTypeAnnotation();
          a = h.TypeAnnotationNode.create(a, n);
          if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_6)) {
            this._addSyntaxError(g.LocMessage.varAnnotationIllegal(), n);
          }
          if (!this._consumeTokenIfOperator(2)) {
            return a;
          }
          const t = this._isTypingAnnotation(n, 'TypeAlias');
          const r = this._isParsingTypeAnnotation;
          if (t) {
            this._isParsingTypeAnnotation = true;
          }
          const s = (e = this._tryParseYieldExpression()) !== null && e !== undefined ? e : this._parseTestOrStarListAsExpression(false, true, 2, () => g.LocMessage.expectedAssignRightHandExpr());
          this._isParsingTypeAnnotation = r;
          return h.AssignmentNode.create(a, s);
        }
        if (this._consumeTokenIfOperator(2)) {
          return this._parseChainAssignments(a);
        }
        if (T.Tokenizer.isOperatorAssignment(this._peekOperatorType())) {
          const e = this._getNextToken();
          const n = (t = this._tryParseYieldExpression()) !== null && t !== undefined ? t : this._parseTestOrStarListAsExpression(false, true, 2, () => g.LocMessage.expectedBinaryRightHandExpr());
          this._reportConditionalErrorForStarTupleElement(n, u.pythonVersion3_9);
          const r = Object.assign({}, a);
          r.id = h.getNextNodeId();
          return h.AugmentedAssignmentNode.create(a, n, e.operatorType, r);
        }
        return a;
      }
      _parseChainAssignments(e) {
        var t;
        const n = [e];
        let a;
        while (a = (t = this._tryParseYieldExpression()) !== null && t !== undefined ? t : this._parseTestOrStarListAsExpression(false, true, 2, () => g.LocMessage.expectedAssignRightHandExpr()), a.nodeType !== 0 && this._consumeTokenIfOperator(2)) {
          n.push(a);
        }
        let r = h.AssignmentNode.create(n[0], a);
        const s = this._parseVariableTypeAnnotationComment();
        if (s) {
          if (n.length > 1) {
            r.d.chainedAnnotationComment = s;
          } else {
            r.d.annotationComment = s;
            r.d.annotationComment.parent = r;
            h.extendRange(r, r.d.annotationComment);
          }
        }
        n.forEach((e, t) => {
          if (t > 0) {
            r = h.AssignmentNode.create(e, r);
          }
        });
        return r;
      }
      _parseFunctionTypeAnnotation() {
        const e = this._peekToken();
        if (!this._consumeTokenIfType(13)) {
          this._addSyntaxError(g.LocMessage.expectedOpenParen(), this._peekToken());
          return;
        }
        let t = [];
        while (true) {
          const e = this._peekTokenType();
          if (e === 14 || e === 2 || e === 1) {
            break;
          }
          if (!this._consumeTokenIfOperator(26)) {
            this._consumeTokenIfOperator(29);
          }
          const n = this._parseTypeAnnotation();
          t.push(n);
          if (!this._consumeTokenIfType(12)) {
            break;
          }
        }
        if (!this._consumeTokenIfType(14)) {
          this._addSyntaxError(g.LocMessage.expectedCloseParen(), e);
          this._consumeTokensUntilType([10]);
        }
        if (!this._consumeTokenIfType(21)) {
          this._addSyntaxError(g.LocMessage.expectedArrow(), this._peekToken());
          return;
        }
        const n = this._parseTypeAnnotation();
        let a = false;
        if (t.length === 1 && t[0].nodeType === 21) {
          t = [];
          a = true;
        }
        return h.FunctionAnnotationNode.create(e, a, t, n);
      }
      _parseTypeAnnotation(e = false) {
        const t = this._isParsingTypeAnnotation;
        this._isParsingTypeAnnotation = true;
        const n = this._peekToken();
        const a = this._consumeTokenIfOperator(26);
        if (a && e && !this._parseOptions.isStubFile && !this._isParsingQuotedText && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_11)) {
          this._addSyntaxError(g.LocMessage.unpackedSubscriptIllegal(), n);
        }
        let r = this._parseTestExpression(false);
        if (a) {
          r = h.UnpackNode.create(n, r);
        }
        this._isParsingTypeAnnotation = t;
        return r;
      }
      _reportStringTokenErrors(e, t) {
        if (e.flags & 65536) {
          this._addSyntaxError(g.LocMessage.stringUnterminated(), e);
        }
        if (t == null ? undefined : t.nonAsciiInBytes) {
          this._addSyntaxError(g.LocMessage.stringNonAsciiBytes(), e);
        }
        if (e.flags & 64) {
          if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_6)) {
            this._addSyntaxError(g.LocMessage.formatStringIllegal(), e);
          }
          if (e.flags & 32) {
            this._addSyntaxError(g.LocMessage.formatStringBytes(), e);
          }
          if (e.flags & 16) {
            this._addSyntaxError(g.LocMessage.formatStringUnicode(), e);
          }
        }
      }
      _makeStringNode(e) {
        const t = f.getUnescapedString(e);
        this._reportStringTokenErrors(e, t);
        return h.StringNode.create(e, t.value);
      }
      _getTypeAnnotationCommentText() {
        if (this._tokenIndex === 0) {
          return;
        }
        const e = this._tokenizerOutput.tokens.getItemAt(this._tokenIndex - 1);
        const t = this._tokenizerOutput.tokens.getItemAt(this._tokenIndex);
        if (e.start + e.length === t.start) {
          return;
        }
        const n = this._fileContents.slice(e.start + e.length, t.start).match(/^(\s*#\s*type:\s*)([^\r\n]*)/);
        if (!n) {
          return;
        }
        const a = n[2];
        if (a.trim().match(/^ignore(\s|\[|$)/)) {
          return;
        }
        const r = e.start + e.length + n[1].length;
        return v.StringToken.create(r, a.length, 0, a, 0, undefined);
      }
      _parseVariableTypeAnnotationComment() {
        const e = this._getTypeAnnotationCommentText();
        if (!e) {
          return;
        }
        const t = this._makeStringNode(e);
        const n = h.StringListNode.create([t]);
        const a = new C().parseTextExpression(this._fileContents, e.start, e.length, this._parseOptions, 1, undefined, this._typingSymbolAliases);
        a.diagnostics.forEach(e => {
          this._addSyntaxError(e.message, n);
        });
        if (a.parseTree) {
          return a.parseTree;
        } else {
          return undefined;
        }
      }
      _parseFunctionTypeAnnotationComment(e, t) {
        const n = this._makeStringNode(e);
        const a = h.StringListNode.create([n]);
        const r = new C().parseTextExpression(this._fileContents, e.start, e.length, this._parseOptions, 2, undefined, this._typingSymbolAliases);
        r.diagnostics.forEach(e => {
          this._addSyntaxError(e.message, a);
        });
        if (!r.parseTree) {
          return;
        }
        const s = r.parseTree;
        t.d.funcAnnotationComment = s;
        s.parent = t;
        h.extendRange(t, s);
      }
      _parseFStringReplacementField(e, t, n, a = 0) {
        var r;
        let s = this._getNextToken();
        l.assert(s.type === 17);
        const i = (r = this._tryParseYieldExpression()) !== null && r !== undefined ? r : this._parseTestOrStarListAsExpression(true, true, 2, () => g.LocMessage.expectedExpr());
        e.push(i);
        return i.nodeType !== 0 && (s = this._peekToken(), s.type === 9 && s.operatorType === 2 && (u.PythonVersion.isLessThan(this._parseOptions.pythonVersion, u.pythonVersion3_8) && this._addSyntaxError(g.LocMessage.formatStringDebuggingIllegal(), s), this._getNextToken(), s = this._peekToken()), s.type === 23 && (this._getNextToken(), s = this._peekToken(), s.type !== 7 ? this._addSyntaxError(g.LocMessage.formatStringExpectedConversion(), s) : (this._getNextToken(), s = this._peekToken())), s.type === 10 && (this._getNextToken(), this._parseFStringFormatString(e, t, n, a), s = this._peekToken()), s.type !== 18 ? (this._addSyntaxError(g.LocMessage.formatStringUnterminated(), s), false) : (this._getNextToken(), true));
      }
      _parseFStringFormatString(e, t, n, a) {
        while (true) {
          const r = this._peekToken();
          if (r.type === 18 || r.type === 26) {
            break;
          }
          if (r.type !== 25) {
            if (r.type !== 17) {
              break;
            }
            if (a === 2) {
              this._addSyntaxError(g.LocMessage.formatStringNestedFormatSpecifier(), r);
            }
            this._parseFStringReplacementField(e, t, n, a + 1);
          } else {
            this._getNextToken();
          }
        }
      }
      _parseFormatString(e) {
        const t = [];
        const n = [];
        const a = [];
        let r;
        while (true) {
          const s = this._peekToken();
          if (s.type === 26) {
            r = s;
            if (r.flags & 65536) {
              this._addSyntaxError(g.LocMessage.stringUnterminated(), e);
            }
            this._getNextToken();
            break;
          }
          if (s.type !== 25) {
            if (s.type !== 17) {
              if (this._consumeTokensUntilType([26])) {
                this._getNextToken();
              }
              this._addSyntaxError(s.type === 18 ? g.LocMessage.formatStringBrace() : g.LocMessage.stringUnterminated(), s);
              break;
            }
            if (!this._parseFStringReplacementField(n, t, a)) {
              if (this._consumeTokensUntilType([26, 2]) && this._peekToken().type === 26) {
                this._getNextToken();
              }
              break;
            }
          } else {
            t.push(s);
            this._getNextToken();
          }
        }
        this._reportStringTokenErrors(e);
        return h.FormatStringNode.create(e, r, t, n, a);
      }
      _createBinaryOperationNode(e, t, n, a) {
        var r;
        var s;
        const i = h.BinaryOperationNode.create(e, t, n, a);
        const o = (r = this._maxChildDepthMap.get(e.id)) !== null && r !== undefined ? r : 0;
        const l = (s = this._maxChildDepthMap.get(t.id)) !== null && s !== undefined ? s : 0;
        if (o >= _ || l >= _) {
          this._addSyntaxError(g.LocMessage.maxParseDepthExceeded(), i);
          return h.ErrorNode.create(i, 15);
        } else {
          this._maxChildDepthMap.set(i.id, Math.max(o, l) + 1);
          return i;
        }
      }
      _createUnaryOperationNode(e, t, n) {
        var a;
        const r = h.UnaryOperationNode.create(e, t, n);
        const s = (a = this._maxChildDepthMap.get(t.id)) !== null && a !== undefined ? a : 0;
        if (s >= _) {
          this._addSyntaxError(g.LocMessage.maxParseDepthExceeded(), r);
          return h.ErrorNode.create(r, 15);
        } else {
          this._maxChildDepthMap.set(r.id, s + 1);
          return r;
        }
      }
      _parseStringList() {
        const e = [];
        while (true) {
          const t = this._peekToken();
          if (t.type === 5) {
            e.push(this._makeStringNode(this._getNextToken()));
          } else {
            if (t.type !== 24) {
              break;
            }
            e.push(this._parseFormatString(this._getNextToken()));
          }
        }
        const t = h.StringListNode.create(e);
        if (this._isParsingTypeAnnotation) {
          if (t.d.strings.length > 1) {
            if (this._isParsingQuotedText) {
              this._addSyntaxError(g.LocMessage.annotationSpansStrings(), t);
            }
          } else {
            if (t.d.strings[0].nodeType === 30) {
              if (this._isParsingQuotedText) {
                this._addSyntaxError(g.LocMessage.annotationFormatString(), t);
              }
            } else {
              const e = t.d.strings[0].d.token;
              const n = f.getUnescapedString(t.d.strings[0].d.token).value;
              const a = e.start;
              const r = e.prefixLength + e.quoteMarkLength;
              if (n.length !== e.length - r - e.quoteMarkLength) {
                if (this._isParsingQuotedText) {
                  this._addSyntaxError(g.LocMessage.annotationStringEscape(), t);
                }
              } else {
                if (!(e.flags & 104)) {
                  const e = new C().parseTextExpression(this._fileContents, a + r, n.length, this._parseOptions, 1, t.d.strings[0].d.token.flags & 4 ? 1 : 0, this._typingSymbolAliases);
                  if (e.diagnostics.length === 0 || this._parseOptions.reportErrorsForParsedStringContents) {
                    e.diagnostics.forEach(e => {
                      this._addSyntaxError(e.message, t);
                    });
                    if (e.parseTree) {
                      t.d.annotation = e.parseTree;
                      t.d.annotation.parent = t;
                    }
                  }
                }
              }
            }
          }
        }
        return t;
      }
      _reportConditionalErrorForStarTupleElement(e, t = u.pythonVersion3_8) {
        if (e.nodeType === 52 && !e.d.hasParens && !u.PythonVersion.isGreaterOrEqualTo(this._parseOptions.pythonVersion, t)) {
          for (const t of e.d.items) {
            if (t.nodeType === 56) {
              this._addSyntaxError(g.LocMessage.unpackTuplesIllegal(), t);
              return;
            }
          }
        }
      }
      _isNextTokenNeverExpression() {
        switch (this._peekToken().type) {
          case 8:
            switch (this._peekKeywordType()) {
              case 17:
              case 22:
              case 20:
                return true;
            }
            break;
          case 9:
            switch (this._peekOperatorType()) {
              case 1:
              case 34:
              case 27:
              case 11:
              case 25:
              case 4:
              case 7:
              case 9:
              case 18:
              case 32:
              case 30:
              case 14:
              case 2:
                return true;
            }
            break;
          case 3:
          case 4:
          case 2:
          case 1:
          case 11:
          case 14:
          case 16:
          case 18:
          case 12:
          case 10:
          case 23:
          case 25:
          case 26:
            return true;
        }
        return false;
      }
      _disallowAssignmentExpression(e) {
        const t = this._assignmentExpressionsAllowed;
        this._assignmentExpressionsAllowed = false;
        e();
        this._assignmentExpressionsAllowed = t;
      }
      _getNextToken() {
        const e = this._tokenizerOutput.tokens.getItemAt(this._tokenIndex);
        if (!this._atEof()) {
          this._tokenIndex++;
        }
        return e;
      }
      _atEof() {
        return this._tokenIndex >= this._tokenizerOutput.tokens.count - 1;
      }
      _peekToken(e = 0) {
        if (this._tokenIndex + e < 0) {
          return this._tokenizerOutput.tokens.getItemAt(0);
        } else {
          if (this._tokenIndex + e >= this._tokenizerOutput.tokens.count) {
            return this._tokenizerOutput.tokens.getItemAt(this._tokenizerOutput.tokens.count - 1);
          } else {
            return this._tokenizerOutput.tokens.getItemAt(this._tokenIndex + e);
          }
        }
      }
      _peekTokenType() {
        return this._peekToken().type;
      }
      _peekKeywordType() {
        const e = this._peekToken();
        if (e.type === 8) {
          return e.keywordType;
        }
      }
      _peekOperatorType() {
        const e = this._peekToken();
        if (e.type === 9) {
          return e.operatorType;
        }
      }
      _getTokenIfIdentifier() {
        const e = this._peekToken();
        if (e.type === 7) {
          return this._getNextToken();
        }
        if (e.type === 0) {
          this._getNextToken();
          this._addSyntaxError(g.LocMessage.invalidIdentifierChar(), e);
          return v.IdentifierToken.create(e.start, e.length, '', e.comments);
        }
        if (e.type === 8) {
          const t = e;
          if (v.KeywordToken.isSoftKeyword(t)) {
            const t = this._fileContents.substr(e.start, e.length);
            this._getNextToken();
            return v.IdentifierToken.create(e.start, e.length, t, e.comments);
          }
        }
      }
      _consumeTokensUntilType(e) {
        while (true) {
          const t = this._peekToken();
          if (e.some(e => e === t.type)) {
            return true;
          }
          if (t.type === 1) {
            return false;
          }
          this._getNextToken();
        }
      }
      _getTokenIfType(e) {
        if (this._peekTokenType() === e) {
          return this._getNextToken();
        }
      }
      _consumeTokenIfType(e) {
        return !!this._getTokenIfType(e);
      }
      _consumeTokenIfKeyword(e) {
        return this._peekKeywordType() === e && (this._getNextToken(), true);
      }
      _consumeTokenIfOperator(e) {
        return this._peekOperatorType() === e && (this._getNextToken(), true);
      }
      _getKeywordToken(e) {
        const t = this._getNextToken();
        l.assert(t.type === 8);
        l.assert(t.keywordType === e);
        return t;
      }
      _getLanguageVersion() {
        return this._parseOptions.pythonVersion;
      }
      _suppressErrors(e) {
        const t = this._areErrorsSuppressed;
        try {
          this._areErrorsSuppressed = true;
          e();
        } finally {
          this._areErrorsSuppressed = t;
        }
      }
      _addSyntaxError(e, t) {
        l.assert(t !== undefined);
        if (!this._areErrorsSuppressed) {
          this._diagSink.addError(e, c.convertOffsetsToRange(t.start, t.start + t.length, this._tokenizerOutput.lines));
        }
      }
    }
    exports.Parser = C;
  },
  23981: (module, exports) => {
    function n(e, t) {
      const n = e.valueParts.join('');
      const a = t !== n ? n : t;
      return {
        ...e,
        value: a
      };
    }
    function a(e) {
      return e >= 48 && e <= 57 || e >= 97 && e <= 122 || e >= 65 && e <= 90;
    }
    function r(e) {
      return e >= 48 && e <= 55;
    }
    function s(e) {
      return e >= 48 && e <= 57 || e >= 97 && e <= 102 || e >= 65 && e <= 70;
    }
    function i(e) {
      if (e >= 48 && e <= 57) {
        return e - 48;
      } else {
        if (e >= 97 && e <= 102) {
          return e - 97 + 10;
        } else {
          if (e >= 65 && e <= 70) {
            return e - 65 + 10;
          } else {
            return 0;
          }
        }
      }
    }
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getUnescapedString = function (e) {
      const t = e.escapedValue;
      const o = !!(e.flags & 8);
      if (o) {
        return {
          value: t,
          unescapeErrors: [],
          nonAsciiInBytes: false
        };
      }
      const l = [];
      for (let e = 0; e < t.length; e++) {
        l.push(t.charCodeAt(e));
      }
      const p = !!(e.flags & 32);
      if (!l.some(e => e === 13 || e === 10 || e === 92)) {
        return {
          value: t,
          unescapeErrors: [],
          nonAsciiInBytes: p && l.some(e => e >= 128)
        };
      }
      let d = 0;
      const c = {
        valueParts: [],
        unescapeErrors: [],
        nonAsciiInBytes: false
      };
      const u = () => {
        if (!o) {
          c.unescapeErrors.push({
            offset: d - 1,
            length: 2,
            errorType: 0
          });
        }
      };
      const m = (e = 0) => d + e >= l.length ? 3 : l[d + e];
      const y = e => {
        let t = false;
        let n = 0;
        let a = '';
        for (let a = 0; a < e; a++) {
          const e = m(1 + a);
          if (!s(e)) {
            t = true;
            break;
          }
          n = n * 16 + i(e);
        }
        if (t) {
          u();
          a = `\\${String.fromCharCode(m())}`;
          d++;
        } else {
          a = String.fromCharCode(n);
          d += 1 + e;
        }
        return a;
      };
      const g = e => {
        const t = String.fromCharCode(e);
        c.valueParts.push(t);
      };
      while (true) {
        let e = m();
        if (e === 3) {
          return n(c, t);
        }
        if (e === 92) {
          d++;
          if (o) {
            g(e);
            continue;
          }
          e = m();
          let t = '';
          if (e === 13 || e === 10) {
            if (e === 13 && m(1) === 10) {
              if (o) {
                t += String.fromCharCode(e);
              }
              d++;
              e = m();
            }
            if (o) {
              t = `\\${t}${String.fromCharCode(e)}`;
            }
            d++;
          } else {
            if (o) {
              t = `\\${String.fromCharCode(e)}`;
              d++;
            } else {
              switch (e) {
                case 92:
                case 39:
                case 34:
                  t = String.fromCharCode(e);
                  d++;
                  break;
                case 97:
                  t = '';
                  d++;
                  break;
                case 98:
                  t = '\b';
                  d++;
                  break;
                case 102:
                  t = '\f';
                  d++;
                  break;
                case 110:
                  t = '\n';
                  d++;
                  break;
                case 114:
                  t = '\r';
                  d++;
                  break;
                case 116:
                  t = '\t';
                  d++;
                  break;
                case 118:
                  t = '';
                  d++;
                  break;
                case 120:
                  t = y(2);
                  break;
                case 78:
                  {
                    let n = false;
                    let r = 1;
                    if (m(r) !== 123) {
                      n = true;
                    } else {
                      for (r++;;) {
                        const e = m(r);
                        if (e === 125) {
                          break;
                        }
                        if (!a(e) && e !== 45 && (h = e) !== 32 && h !== 9) {
                          n = true;
                          break;
                        }
                        r++;
                      }
                    }
                    if (n) {
                      u();
                      t = `\\${String.fromCharCode(e)}`;
                      d++;
                    } else {
                      t = '-';
                      d += 1 + r;
                    }
                    break;
                  }
                case 117:
                  t = y(4);
                  break;
                case 85:
                  t = y(8);
                  break;
                default:
                  if (r(e)) {
                    let n = e - 48;
                    d++;
                    e = m();
                    if (r(e)) {
                      n = n * 8 + e - 48;
                      d++;
                      e = m();
                      if (r(e)) {
                        n = n * 8 + e - 48;
                        d++;
                      }
                    }
                    t = String.fromCharCode(n);
                  } else {
                    t = '\\';
                    u();
                  }
              }
            }
          }
          c.valueParts.push(t);
        } else {
          if (e === 10 || e === 13) {
            if (e === 13 && m(1) === 10) {
              g(e);
              d++;
              e = m();
            }
            g(e);
            d++;
          } else {
            if (p && e >= 128) {
              c.nonAsciiInBytes = true;
            }
            g(e);
            d++;
          }
        }
      }
      var h;
    };
  },
  49969: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Tokenizer = undefined;
    const a = require(41557);
    const r = require(53266);
    const s = require(95418);
    const i = require(4794);
    const o = require(51651);
    const l = require(92600);
    const p = new Map([['and', 0], ['as', 1], ['assert', 2], ['async', 3], ['await', 4], ['break', 5], ['case', 6], ['class', 7], ['continue', 8], ['__debug__', 9], ['def', 10], ['del', 11], ['elif', 12], ['else', 13], ['except', 14], ['finally', 16], ['for', 17], ['from', 18], ['global', 19], ['if', 20], ['import', 21], ['in', 22], ['is', 23], ['lambda', 24], ['match', 25], ['nonlocal', 27], ['not', 28], ['or', 29], ['pass', 30], ['raise', 31], ['return', 32], ['try', 34], ['type', 35], ['while', 36], ['with', 37], ['yield', 38], ['False', 15], ['None', 26], ['True', 33]]);
    const d = new Set(['match', 'case', 'type']);
    const c = {
      0: 3,
      1: 4,
      2: 4,
      3: 2,
      4: 4,
      5: 1,
      6: 2,
      7: 4,
      8: 2,
      9: 4,
      10: 2,
      11: 4,
      12: 10,
      13: 2,
      14: 4,
      15: 10,
      16: 10,
      17: 2,
      18: 4,
      19: 26,
      20: 10,
      21: 10,
      22: 2,
      23: 4,
      24: 2,
      25: 4,
      26: 2,
      27: 4,
      28: 10,
      29: 2,
      30: 4,
      31: 2,
      32: 4,
      33: 2,
      34: 4,
      36: 2,
      37: 2,
      38: 1,
      39: 2,
      40: 2,
      41: 2,
      42: 2
    };
    exports.Tokenizer = class {
      constructor() {
        this._cs = new o.CharacterStream('');
        this._tokens = [];
        this._prevLineStart = 0;
        this._parenDepth = 0;
        this._lineRanges = [];
        this._indentAmounts = [];
        this._typeIgnoreLines = new Map();
        this._pyrightIgnoreLines = new Map();
        this._fStringStack = [];
        this._crCount = 0;
        this._crLfCount = 0;
        this._lfCount = 0;
        this._indentCount = 0;
        this._indentTabCount = 0;
        this._indentSpacesTotal = 0;
        this._singleQuoteCount = 0;
        this._doubleQuoteCount = 0;
        this._ipythonMode = r.IPythonMode.None;
      }
      tokenize(e, t = 0, n = e.length, a = 0, i = r.IPythonMode.None) {
        this._cs = new o.CharacterStream(e);
        this._cs.position = t;
        this._tokens = [];
        this._prevLineStart = 0;
        this._parenDepth = a;
        this._lineRanges = [];
        this._indentAmounts = [];
        this._ipythonMode = i;
        const p = t + n;
        for (t === 0 && this._readIndentationAfterNewLine(); !this._cs.isEndOfStream() && !(this._addNextToken(), this._cs.position >= p););
        while (this._activeFString) {
          this._tokens.push(l.FStringEndToken.create(this._cs.position, 0, this._activeFString.startToken.flags | 65536));
          this._activeFString = this._fStringStack.pop();
        }
        if (this._tokens.length === 0 || this._tokens[this._tokens.length - 1].type !== 2) {
          if (this._parenDepth === 0) {
            this._tokens.push(l.NewLineToken.create(this._cs.position, 0, 3, this._getComments()));
          }
        }
        this._setIndent(this._cs.position, 0, 0, false, false);
        this._tokens.push(l.Token.create(1, this._cs.position, 0, this._getComments()));
        this._addLineRange();
        if (this._lineRanges.length > 0) {
          const t = this._lineRanges[this._lineRanges.length - 1];
          const n = e.charCodeAt(t.start + t.length - 1);
          if (n === 13 || n === 10) {
            this._lineRanges.push({
              start: this._cs.position,
              length: 0
            });
          }
        }
        let d = '\n';
        if (this._crCount > this._crLfCount && this._crCount > this._lfCount) {
          d = '\r';
        } else {
          if (this._crLfCount > this._crCount && this._crLfCount > this._lfCount) {
            d = '\r\n';
          }
        }
        let c = '    ';
        let u = false;
        if (this._indentTabCount > this._indentCount / 2) {
          u = true;
          c = '\t';
        } else {
          if (this._indentCount > 0) {
            u = true;
            let e = Math.round(this._indentSpacesTotal / this._indentCount);
            if (e < 1) {
              e = 1;
            } else {
              if (e > 8) {
                e = 8;
              }
            }
            c = '';
            for (let t = 0; t < e; t++) {
              c += ' ';
            }
          }
        }
        return {
          tokens: new s.TextRangeCollection(this._tokens),
          lines: new s.TextRangeCollection(this._lineRanges),
          typeIgnoreLines: this._typeIgnoreLines,
          typeIgnoreAll: this._typeIgnoreAll,
          pyrightIgnoreLines: this._pyrightIgnoreLines,
          predominantEndOfLineSequence: d,
          hasPredominantTabSequence: u,
          predominantTabSequence: c,
          predominantSingleQuoteCharacter: this._singleQuoteCount >= this._doubleQuoteCount ? '\'' : '"'
        };
      }
      static getOperatorInfo(e) {
        return c[e];
      }
      static isPythonKeyword(e, t = false) {
        return !!p.get(e) && (!!t || !d.has(e));
      }
      static isPythonIdentifier(e) {
        for (let t = 0; t < e.length; t++) {
          if (t === 0 ? !i.isIdentifierStartChar(e.charCodeAt(t)) : !i.isIdentifierChar(e.charCodeAt(t))) {
            return false;
          }
        }
        return true;
      }
      static isOperatorAssignment(e) {
        return e !== undefined && c[e] !== undefined && !!(c[e] & 4);
      }
      static isOperatorComparison(e) {
        return e !== undefined && c[e] !== undefined && !!(c[e] & 8);
      }
      _addNextToken() {
        if (!this._activeFString || this._activeFString.activeReplacementField && !this._activeFString.activeReplacementField.inFormatSpecifier) {
          this._cs.skipWhitespace();
        } else {
          this._handleFStringMiddle();
        }
        if (!this._cs.isEndOfStream() && !this._handleCharacter()) {
          this._cs.moveNext();
        }
      }
      _handleCharacter() {
        var e;
        var t;
        const n = this._getStringPrefixLength();
        if (n >= 0) {
          let e = '';
          if (n > 0) {
            e = this._cs.getText().slice(this._cs.position, this._cs.position + n);
            this._cs.advance(n);
          }
          const t = this._getQuoteTypeFlags(e);
          if (t !== 0) {
            this._handleString(t, n);
            return true;
          }
        }
        if (this._cs.currentChar === 35) {
          this._handleComment();
          return true;
        }
        if (this._ipythonMode) {
          const e = this._getIPythonMagicsKind();
          if (e === 'line') {
            this._handleIPythonMagics(this._cs.currentChar === 37 ? 1 : 2);
            return true;
          }
          if (e === 'cell') {
            this._handleIPythonMagics(this._cs.currentChar === 37 ? 3 : 4);
            return true;
          }
        }
        switch (this._cs.currentChar) {
          case 65279:
            return this._cs.position !== 0 && this._handleInvalid();
          case 13:
            {
              const e = this._cs.nextChar === 10 ? 2 : 1;
              const t = e === 2 ? 2 : 0;
              this._handleNewLine(e, t);
              return true;
            }
          case 10:
            this._handleNewLine(1, 1);
            return true;
          case 92:
            if (this._cs.nextChar === 13) {
              if (this._cs.lookAhead(2) === 10) {
                this._cs.advance(3);
              } else {
                this._cs.advance(2);
              }
              this._addLineRange();
              if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].type === 2) {
                this._readIndentationAfterNewLine();
              }
              return true;
            } else {
              if (this._cs.nextChar === 10) {
                this._cs.advance(2);
                this._addLineRange();
                if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].type === 2) {
                  this._readIndentationAfterNewLine();
                }
                return true;
              } else {
                return this._handleInvalid();
              }
            }
          case 40:
            this._parenDepth++;
            this._tokens.push(l.Token.create(13, this._cs.position, 1, this._getComments()));
            break;
          case 41:
            if (this._parenDepth > 0) {
              this._parenDepth--;
            }
            this._tokens.push(l.Token.create(14, this._cs.position, 1, this._getComments()));
            break;
          case 91:
            this._parenDepth++;
            this._tokens.push(l.Token.create(15, this._cs.position, 1, this._getComments()));
            break;
          case 93:
            if (this._parenDepth > 0) {
              this._parenDepth--;
            }
            this._tokens.push(l.Token.create(16, this._cs.position, 1, this._getComments()));
            break;
          case 123:
            this._parenDepth++;
            this._tokens.push(l.Token.create(17, this._cs.position, 1, this._getComments()));
            if (this._activeFString) {
              if (!this._activeFString.activeReplacementField || !!this._activeFString.activeReplacementField.inFormatSpecifier) {
                if (this._activeFString.activeReplacementField) {
                  this._activeFString.replacementFieldStack.push(this._activeFString.activeReplacementField);
                }
                this._activeFString.activeReplacementField = {
                  inFormatSpecifier: false,
                  parenDepth: this._parenDepth
                };
              }
            }
            break;
          case 125:
            if (this._activeFString && ((e = this._activeFString.activeReplacementField) === null || e === undefined ? undefined : e.parenDepth) === this._parenDepth) {
              this._activeFString.activeReplacementField = this._activeFString.replacementFieldStack.pop();
            }
            if (this._parenDepth > 0) {
              this._parenDepth--;
            }
            this._tokens.push(l.Token.create(18, this._cs.position, 1, this._getComments()));
            break;
          case 44:
            this._tokens.push(l.Token.create(12, this._cs.position, 1, this._getComments()));
            break;
          case 96:
            this._tokens.push(l.Token.create(22, this._cs.position, 1, this._getComments()));
            break;
          case 59:
            this._tokens.push(l.Token.create(11, this._cs.position, 1, this._getComments()));
            break;
          case 58:
            if (this._cs.nextChar === 61 && (!this._activeFString || !this._activeFString.activeReplacementField || this._activeFString.activeReplacementField.parenDepth !== this._parenDepth)) {
              this._tokens.push(l.OperatorToken.create(this._cs.position, 2, 35, this._getComments()));
              this._cs.advance(1);
              break;
            }
            this._tokens.push(l.Token.create(10, this._cs.position, 1, this._getComments()));
            if (((t = this._activeFString) === null || t === undefined ? undefined : t.activeReplacementField) && this._parenDepth === this._activeFString.activeReplacementField.parenDepth) {
              this._activeFString.activeReplacementField.inFormatSpecifier = true;
            }
            break;
          default:
            if (this._isPossibleNumber() && this._tryNumber()) {
              return true;
            }
            if (this._cs.currentChar === 46) {
              if (this._cs.nextChar === 46 && this._cs.lookAhead(2) === 46) {
                this._tokens.push(l.Token.create(19, this._cs.position, 3, this._getComments()));
                this._cs.advance(3);
                return true;
              }
              this._tokens.push(l.Token.create(20, this._cs.position, 1, this._getComments()));
              break;
            }
            return !!this._tryIdentifier() || !!this._tryOperator() || this._handleInvalid();
        }
        return false;
      }
      _addLineRange() {
        const e = this._cs.position - this._prevLineStart;
        if (e > 0) {
          this._lineRanges.push({
            start: this._prevLineStart,
            length: e
          });
        }
        this._prevLineStart = this._cs.position;
      }
      _handleNewLine(e, t) {
        if (this._parenDepth === 0 && t !== 3) {
          if (this._tokens.length === 0 || this._tokens[this._tokens.length - 1].type !== 2) {
            this._tokens.push(l.NewLineToken.create(this._cs.position, e, t, this._getComments()));
          }
        }
        if (t === 0) {
          this._crCount++;
        } else {
          if (t === 2) {
            this._crLfCount++;
          } else {
            this._lfCount++;
          }
        }
        this._cs.advance(e);
        this._addLineRange();
        this._readIndentationAfterNewLine();
      }
      _readIndentationAfterNewLine() {
        let e = 0;
        let t = 0;
        let n = false;
        let a = false;
        const r = this._cs.position;
        while (!this._cs.isEndOfStream()) {
          switch (this._cs.currentChar) {
            case 32:
              e++;
              t++;
              a = true;
              this._cs.moveNext();
              break;
            case 9:
              e++;
              t += 8 - t % 8;
              n = true;
              this._cs.moveNext();
              break;
            case 12:
              e = 0;
              t = 0;
              n = false;
              a = false;
              this._cs.moveNext();
              break;
            default:
              this._setIndent(r, e, t, a, n);
              return;
            case 35:
            case 10:
            case 13:
              return;
          }
        }
      }
      _setIndent(e, t, n, a, r) {
        if (!(this._parenDepth > 0)) {
          if (this._indentAmounts.length === 0) {
            if (n > 0) {
              this._indentCount++;
              if (r) {
                this._indentTabCount++;
              }
              this._indentSpacesTotal += n;
              this._indentAmounts.push({
                tab1Spaces: t,
                tab8Spaces: n,
                isSpacePresent: a,
                isTabPresent: r
              });
              this._tokens.push(l.IndentToken.create(e, t, n, false, this._getComments()));
            }
          } else {
            const s = this._indentAmounts[this._indentAmounts.length - 1];
            if (s.tab8Spaces < n) {
              const i = (s.isSpacePresent && r || s.isTabPresent && a) && s.tab1Spaces >= t;
              this._indentCount++;
              if (r) {
                this._indentTabCount++;
              }
              this._indentSpacesTotal += n - this._indentAmounts[this._indentAmounts.length - 1].tab8Spaces;
              this._indentAmounts.push({
                tab1Spaces: t,
                tab8Spaces: n,
                isSpacePresent: a,
                isTabPresent: r
              });
              this._tokens.push(l.IndentToken.create(e, t, n, i, this._getComments()));
            } else {
              if (s.tab8Spaces === n) {
                if (s.isSpacePresent && r || s.isTabPresent && a) {
                  this._tokens.push(l.IndentToken.create(e, t, n, true, this._getComments()));
                }
              } else {
                let e = s.isSpacePresent && r || s.isTabPresent && a;
                const t = [];
                while (this._indentAmounts.length > 0 && this._indentAmounts[this._indentAmounts.length - 1].tab8Spaces > n) {
                  t.push(this._indentAmounts.length > 1 ? this._indentAmounts[this._indentAmounts.length - 2].tab8Spaces : 0);
                  this._indentAmounts.pop();
                }
                t.forEach((a, r) => {
                  const s = r < t.length - 1 || a === n;
                  const i = r < t.length - 1 ? a : n;
                  this._tokens.push(l.DedentToken.create(this._cs.position, 0, i, s, e, this._getComments()));
                  e = false;
                });
              }
            }
          }
        }
      }
      _tryIdentifier() {
        const e = () => {
          while (true) {
            if (i.isIdentifierChar(this._cs.currentChar)) {
              this._cs.moveNext();
            } else {
              if (!i.isIdentifierChar(this._cs.currentChar, this._cs.nextChar)) {
                break;
              }
              this._cs.moveNext();
              this._cs.moveNext();
            }
          }
        };
        const t = this._cs.position;
        if (i.isIdentifierStartChar(this._cs.currentChar)) {
          this._cs.moveNext();
          e();
        } else {
          if (i.isIdentifierStartChar(this._cs.currentChar, this._cs.nextChar)) {
            this._cs.moveNext();
            this._cs.moveNext();
            e();
          }
        }
        if (this._cs.position > t) {
          const e = this._cs.getText().slice(t, this._cs.position);
          if (p.has(e)) {
            this._tokens.push(l.KeywordToken.create(t, this._cs.position - t, p.get(e), this._getComments()));
          } else {
            this._tokens.push(l.IdentifierToken.create(t, this._cs.position - t, e, this._getComments()));
          }
          return true;
        }
        return false;
      }
      _isPossibleNumber() {
        return !!i.isDecimal(this._cs.currentChar) || this._cs.currentChar === 46 && !!i.isDecimal(this._cs.nextChar);
      }
      _tryNumber() {
        const e = this._cs.position;
        if (this._cs.currentChar === 48) {
          let t = 0;
          let n = 0;
          if (this._cs.nextChar !== 120 && this._cs.nextChar !== 88 || !i.isHex(this._cs.lookAhead(2))) {
            if (this._cs.nextChar !== 98 && this._cs.nextChar !== 66 || !i.isBinary(this._cs.lookAhead(2))) {
              if ((this._cs.nextChar === 111 || this._cs.nextChar === 79) && i.isOctal(this._cs.lookAhead(2))) {
                this._cs.advance(2);
                n = 2;
                while (i.isOctal(this._cs.currentChar)) {
                  this._cs.moveNext();
                }
                t = 8;
              }
            } else {
              this._cs.advance(2);
              n = 2;
              while (i.isBinary(this._cs.currentChar)) {
                this._cs.moveNext();
              }
              t = 2;
            }
          } else {
            this._cs.advance(2);
            n = 2;
            while (i.isHex(this._cs.currentChar)) {
              this._cs.moveNext();
            }
            t = 16;
          }
          if (t > 0) {
            const a = this._cs.getText().slice(e, this._cs.position);
            const r = a.replace(/_/g, '');
            let s = parseInt(r.slice(n), t);
            if (!isNaN(s)) {
              const t = BigInt(r);
              if (!isFinite(s) || s < Number.MIN_SAFE_INTEGER || s > Number.MAX_SAFE_INTEGER) {
                s = t;
              }
              this._tokens.push(l.NumberToken.create(e, a.length, s, true, false, this._getComments()));
              return true;
            }
          }
        }
        let t = false;
        let n = false;
        if (this._cs.currentChar >= 49 && this._cs.currentChar <= 57) {
          while (i.isDecimal(this._cs.currentChar)) {
            n = true;
            this._cs.moveNext();
          }
          t = this._cs.currentChar !== 46 && this._cs.currentChar !== 101 && this._cs.currentChar !== 69;
        }
        if (this._cs.currentChar === 48) {
          for (n = true; this._cs.currentChar === 48 || this._cs.currentChar === 95;) {
            this._cs.moveNext();
          }
          t = this._cs.currentChar !== 46 && this._cs.currentChar !== 101 && this._cs.currentChar !== 69 && (this._cs.currentChar < 49 || this._cs.currentChar > 57);
        }
        if (t) {
          let t = this._cs.getText().slice(e, this._cs.position);
          const n = t.replace(/_/g, '');
          let a = parseInt(n, 10);
          if (!isNaN(a)) {
            let r = false;
            const s = BigInt(n);
            if (!isFinite(a) || s < Number.MIN_SAFE_INTEGER || s > Number.MAX_SAFE_INTEGER) {
              a = s;
            }
            if (this._cs.currentChar === 106 || this._cs.currentChar === 74) {
              r = true;
              t += String.fromCharCode(this._cs.currentChar);
              this._cs.moveNext();
            }
            this._tokens.push(l.NumberToken.create(e, t.length, a, true, r, this._getComments()));
            return true;
          }
        }
        this._cs.position = e;
        if ((n || this._cs.currentChar === 46 && this._cs.nextChar >= 48 && this._cs.nextChar <= 57) && this._skipFloatingPointCandidate()) {
          let t = this._cs.getText().slice(e, this._cs.position);
          const n = parseFloat(t);
          if (!isNaN(n)) {
            let a = false;
            if (this._cs.currentChar === 106 || this._cs.currentChar === 74) {
              a = true;
              t += String.fromCharCode(this._cs.currentChar);
              this._cs.moveNext();
            }
            this._tokens.push(l.NumberToken.create(e, this._cs.position - e, n, false, a, this._getComments()));
            return true;
          }
        }
        this._cs.position = e;
        return false;
      }
      _tryOperator() {
        var e;
        var t;
        let n = 0;
        const a = this._cs.nextChar;
        let r;
        switch (this._cs.currentChar) {
          case 43:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 1 : 0;
            break;
          case 38:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 4 : 3;
            break;
          case 124:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 7 : 6;
            break;
          case 94:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 9 : 8;
            break;
          case 61:
            if (((e = this._activeFString) === null || e === undefined ? undefined : e.activeReplacementField) && ((t = this._activeFString) === null || t === undefined ? undefined : t.activeReplacementField.parenDepth) === this._parenDepth && !this._activeFString.activeReplacementField.inFormatSpecifier && a !== 61) {
              n = 1;
              r = 2;
              break;
            }
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 12 : 2;
            break;
          case 33:
            if (a !== 61) {
              return !!this._activeFString && (this._tokens.push(l.Token.create(23, this._cs.position, 1, this._getComments())), this._cs.advance(1), true);
            }
            n = 2;
            r = 28;
            break;
          case 37:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 25 : 24;
            break;
          case 126:
            n = 1;
            r = 5;
            break;
          case 45:
            if (a === 62) {
              this._tokens.push(l.Token.create(21, this._cs.position, 2, this._getComments()));
              this._cs.advance(2);
              return true;
            }
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 34 : 33;
            break;
          case 42:
            if (a === 42) {
              n = this._cs.lookAhead(2) === 61 ? 3 : 2;
              r = n === 3 ? 30 : 29;
            } else {
              n = a === 61 ? 2 : 1;
              r = n === 2 ? 27 : 26;
            }
            break;
          case 47:
            if (a === 47) {
              n = this._cs.lookAhead(2) === 61 ? 3 : 2;
              r = n === 3 ? 14 : 13;
            } else {
              n = a === 61 ? 2 : 1;
              r = n === 2 ? 11 : 10;
            }
            break;
          case 60:
            if (a === 60) {
              n = this._cs.lookAhead(2) === 61 ? 3 : 2;
              r = n === 3 ? 18 : 17;
            } else {
              if (a === 62) {
                n = 2;
                r = 19;
              } else {
                n = a === 61 ? 2 : 1;
                r = n === 2 ? 21 : 20;
              }
            }
            break;
          case 62:
            if (a === 62) {
              n = this._cs.lookAhead(2) === 61 ? 3 : 2;
              r = n === 3 ? 32 : 31;
            } else {
              n = a === 61 ? 2 : 1;
              r = n === 2 ? 16 : 15;
            }
            break;
          case 64:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 23 : 22;
            break;
          default:
            return false;
        }
        this._tokens.push(l.OperatorToken.create(this._cs.position, n, r, this._getComments()));
        this._cs.advance(n);
        return n > 0;
      }
      _handleInvalid() {
        const e = this._cs.position;
        while (this._cs.currentChar !== 10 && this._cs.currentChar !== 13 && !this._cs.isAtWhiteSpace() && !this._cs.isEndOfStream()) {
          if (i.isSurrogateChar(this._cs.currentChar)) {
            this._cs.moveNext();
            this._cs.moveNext();
          } else {
            this._cs.moveNext();
          }
        }
        const t = this._cs.position - e;
        return t > 0 && (this._tokens.push(l.Token.create(0, e, t, this._getComments())), true);
      }
      _getComments() {
        const e = this._comments;
        this._comments = undefined;
        return e;
      }
      _getIPythonMagicsKind() {
        if ((e = this._cs.currentChar) !== 37 && e !== 33) {
          return;
        }
        var e;
        const t = this._tokens.length > 0 ? this._tokens[this._tokens.length - 1] : undefined;
        if (t === undefined || a.isWhitespace(t)) {
          if (this._cs.nextChar === this._cs.currentChar) {
            this._cs.moveNext();
            return 'cell';
          } else {
            return 'line';
          }
        }
      }
      _handleIPythonMagics(e) {
        const t = this._cs.position + 1;
        let n = t;
        do {
          this._cs.skipToEol();
          if (e === 1 || e === 2) {
            const e = this._cs.position - n;
            if (!this._cs.getText().slice(n, n + e).match(/\\\s*$/)) {
              break;
            }
          }
          this._cs.moveNext();
          n = this._cs.position + 1;
        } while (!this._cs.isEndOfStream());
        const a = this._cs.position - t;
        const r = l.Comment.create(t, a, this._cs.getText().slice(t, t + a), e);
        this._addComments(r);
      }
      _handleComment() {
        var e;
        var t;
        const n = this._cs.position + 1;
        this._cs.skipToEol();
        const a = this._cs.position - n;
        const r = l.Comment.create(n, a, this._cs.getText().slice(n, n + a));
        const s = r.value.match(/((^|#)\s*)type:\s*ignore(\s*\[([\s\w-,]*)\]|\s|$)/);
        if (s) {
          const t = n + ((e = s.index) !== null && e !== undefined ? e : 0);
          const a = {
            range: {
              start: t + s[1].length,
              length: s[0].length - s[1].length
            },
            rulesList: this._getIgnoreCommentRulesList(t, s)
          };
          if (this._tokens.findIndex(e => e.type !== 2 && e && e.type !== 3) < 0) {
            this._typeIgnoreAll = a;
          } else {
            this._typeIgnoreLines.set(this._lineRanges.length, a);
          }
        }
        const i = r.value.match(/((^|#)\s*)pyright:\s*ignore(\s*\[([\s\w-,]*)\]|\s|$)/);
        if (i) {
          const e = n + ((t = i.index) !== null && t !== undefined ? t : 0);
          const a = {
            range: {
              start: e + i[1].length,
              length: i[0].length - i[1].length
            },
            rulesList: this._getIgnoreCommentRulesList(e, i)
          };
          this._pyrightIgnoreLines.set(this._lineRanges.length, a);
        }
        this._addComments(r);
      }
      _getIgnoreCommentRulesList(e, t) {
        if (t.length < 5 || t[4] === undefined) {
          return;
        }
        const n = t[4].split(',');
        const a = [];
        let r = e + t[0].indexOf('[') + 1;
        for (const e of n) {
          const t = e.trimStart();
          r += e.length - t.length;
          const n = t.trimEnd();
          if (n.length > 0) {
            a.push({
              range: {
                start: r,
                length: n.length
              },
              text: n
            });
          }
          r += t.length + 1;
        }
        return a;
      }
      _addComments(e) {
        if (this._comments) {
          this._comments.push(e);
        } else {
          this._comments = [e];
        }
      }
      _getStringPrefixLength() {
        if (this._cs.currentChar === 39 || this._cs.currentChar === 34) {
          return 0;
        }
        if (this._cs.nextChar === 39 || this._cs.nextChar === 34) {
          switch (this._cs.currentChar) {
            case 102:
            case 70:
            case 114:
            case 82:
            case 98:
            case 66:
            case 117:
            case 85:
              return 1;
          }
        }
        if (this._cs.lookAhead(2) === 39 || this._cs.lookAhead(2) === 34) {
          switch (this._cs.getText().slice(this._cs.position, this._cs.position + 2).toLowerCase()) {
            case 'rf':
            case 'fr':
            case 'ur':
            case 'ru':
            case 'br':
            case 'rb':
              return 2;
          }
        }
        return -1;
      }
      _getQuoteTypeFlags(e) {
        let t = 0;
        e = e.toLowerCase();
        for (let n = 0; n < e.length; n++) {
          switch (e[n]) {
            case 'u':
              t |= 16;
              break;
            case 'b':
              t |= 32;
              break;
            case 'r':
              t |= 8;
              break;
            case 'f':
              t |= 64;
          }
        }
        if (this._cs.currentChar === 39) {
          t |= 1;
          if (this._cs.nextChar === 39 && this._cs.lookAhead(2) === 39) {
            t |= 4;
          }
        } else {
          if (this._cs.currentChar === 34) {
            t |= 2;
            if (this._cs.nextChar === 34 && this._cs.lookAhead(2) === 34) {
              t |= 4;
            }
          }
        }
        return t;
      }
      _handleString(e, t) {
        var n;
        const a = this._cs.position - t;
        if (e & 64) {
          if (e & 4) {
            this._cs.advance(3);
          } else {
            this._cs.moveNext();
          }
          const n = this._cs.position;
          const r = l.FStringStartToken.create(a, n - a, e, t, this._getComments());
          const s = {
            startToken: r,
            replacementFieldStack: []
          };
          if (this._activeFString) {
            this._fStringStack.push(this._activeFString);
          }
          this._activeFString = s;
          this._tokens.push(r);
        } else {
          if (e & 4) {
            this._cs.advance(3);
          } else {
            this._cs.moveNext();
            if (e & 1) {
              this._singleQuoteCount++;
            } else {
              this._doubleQuoteCount++;
            }
          }
          const r = this._skipToEndOfStringLiteral(e);
          const s = this._cs.position;
          if (r.flags & 65536 && ((n = this._activeFString) === null || n === undefined ? undefined : n.activeReplacementField) && !(e & 120)) {
            const t = 7;
            if ((this._activeFString.startToken.flags & t) == (e & t)) {
              for (this._cs.position = a; this._activeFString.replacementFieldStack.length > 0;) {
                this._activeFString.activeReplacementField = this._activeFString.replacementFieldStack.pop();
              }
              this._parenDepth = this._activeFString.activeReplacementField.parenDepth - 1;
              this._activeFString.activeReplacementField = undefined;
              return;
            }
          }
          this._tokens.push(l.StringToken.create(a, s - a, r.flags, r.escapedValue, t, this._getComments()));
        }
      }
      _handleFStringMiddle() {
        var e;
        const t = this._activeFString;
        const n = !!((e = this._activeFString.activeReplacementField) === null || e === undefined ? undefined : e.inFormatSpecifier);
        const a = this._cs.position;
        const r = t.startToken.flags;
        const s = this._skipToEndOfStringLiteral(r, n);
        const i = this._cs.position;
        const o = !!(s.flags & 65536);
        const p = !!(s.flags & 128);
        const d = !!(s.flags & 256);
        const c = !o && !p && !d;
        let u = i - a;
        if (c) {
          u -= t.startToken.quoteMarkLength;
        }
        if (u > 0 || o) {
          this._tokens.push(l.FStringMiddleToken.create(a, u, s.flags, s.escapedValue));
        }
        if (c) {
          this._tokens.push(l.FStringEndToken.create(a + u, t.startToken.quoteMarkLength, s.flags));
          this._activeFString = this._fStringStack.pop();
        } else {
          if (o) {
            this._activeFString = this._fStringStack.pop();
          }
        }
      }
      _skipToEndOfStringLiteral(e, t = false) {
        const n = e & 1 ? 39 : 34;
        const a = !!(e & 4);
        const r = !!(e & 64);
        let s = false;
        const i = this._cs.position;
        let o = 0;
        const l = () => this._cs.getText().slice(i, i + o);
        while (true) {
          if (this._cs.isEndOfStream()) {
            e |= 65536;
            return {
              escapedValue: l(),
              flags: e
            };
          }
          if (this._cs.currentChar === 92) {
            o++;
            this._cs.moveNext();
            if (s || this._cs.getCurrentChar() !== 78 || this._cs.nextChar !== 123) {
              const e = this._cs.getCurrentChar() === 39 || this._cs.getCurrentChar() === 34;
              const t = this._cs.getCurrentChar() === 13 || this._cs.getCurrentChar() === 10;
              const n = this._cs.getCurrentChar() === 92;
              if (!r || n || e || t) {
                if (t) {
                  if (this._cs.getCurrentChar() === 13 && this._cs.nextChar === 10) {
                    o++;
                    this._cs.moveNext();
                  }
                  o++;
                  this._cs.moveNext();
                  this._addLineRange();
                } else {
                  o++;
                  this._cs.moveNext();
                }
              }
            } else {
              e |= 512;
              s = true;
            }
          } else {
            if (this._cs.currentChar === 10 || this._cs.currentChar === 13) {
              if (!a && !r) {
                e |= 65536;
                return {
                  escapedValue: l(),
                  flags: e
                };
              }
              if (this._cs.currentChar === 13 && this._cs.nextChar === 10) {
                o++;
                this._cs.moveNext();
              }
              o++;
              this._cs.moveNext();
              this._addLineRange();
            } else {
              if (!a && this._cs.currentChar === n) {
                this._cs.moveNext();
                break;
              }
              if (a && this._cs.currentChar === n && this._cs.nextChar === n && this._cs.lookAhead(2) === n) {
                this._cs.advance(3);
                break;
              }
              if (!s && r && this._cs.currentChar === 123) {
                if (t || this._cs.nextChar !== 123) {
                  e |= 128;
                  break;
                }
                o++;
                this._cs.moveNext();
                o++;
                this._cs.moveNext();
              } else {
                if (s && this._cs.currentChar === 125) {
                  s = false;
                  o++;
                  this._cs.moveNext();
                } else {
                  if (r && this._cs.currentChar === 125) {
                    if (t || this._cs.nextChar !== 125) {
                      e |= 256;
                      break;
                    }
                    o++;
                    this._cs.moveNext();
                    o++;
                    this._cs.moveNext();
                  } else {
                    o++;
                    this._cs.moveNext();
                  }
                }
              }
            }
          }
        }
        return {
          escapedValue: l(),
          flags: e
        };
      }
      _skipFloatingPointCandidate() {
        const e = this._cs.position;
        this._skipFractionalNumber();
        if (this._cs.position > e) {
          if (this._cs.currentChar === 101 || this._cs.currentChar === 69) {
            this._cs.moveNext();
            this._skipDecimalNumber(true);
          }
        }
        return this._cs.position > e;
      }
      _skipFractionalNumber() {
        this._skipDecimalNumber(false);
        if (this._cs.currentChar === 46) {
          this._cs.moveNext();
        }
        this._skipDecimalNumber(false);
      }
      _skipDecimalNumber(e) {
        for (!e || this._cs.currentChar !== 45 && this._cs.currentChar !== 43 || this._cs.moveNext(); i.isDecimal(this._cs.currentChar);) {
          this._cs.moveNext();
        }
      }
    };
  },
  92600: (module, exports) => {
    var n;
    var a;
    var r;
    var s;
    var i;
    var o;
    var l;
    var p;
    var d;
    var c;
    var u;
    var m;
    var y;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.IdentifierToken = exports.OperatorToken = exports.NumberToken = exports.FStringEndToken = exports.FStringMiddleToken = exports.FStringStartToken = exports.StringToken = exports.KeywordToken = exports.NewLineToken = exports.DedentToken = exports.IndentToken = exports.Token = exports.Comment = exports.softKeywords = undefined;
    exports.softKeywords = [9, 25, 6, 35];
    (function (e) {
      e.create = function (e, t, n, a = 0) {
        return {
          type: a,
          start: e,
          length: t,
          value: n
        };
      };
    })(n || (exports.Comment = n = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: t,
          length: n,
          type: e,
          comments: a
        };
      };
    })(a || (exports.Token = a = {}));
    (function (e) {
      e.create = function (e, t, n, a, r) {
        return {
          start: e,
          length: t,
          type: 3,
          isIndentAmbiguous: a,
          comments: r,
          indentAmount: n
        };
      };
    })(r || (exports.IndentToken = r = {}));
    (function (e) {
      e.create = function (e, t, n, a, r, s) {
        return {
          start: e,
          length: t,
          type: 4,
          comments: s,
          indentAmount: n,
          matchesIndent: a,
          isDedentAmbiguous: r
        };
      };
    })(s || (exports.DedentToken = s = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: e,
          length: t,
          type: 2,
          comments: a,
          newLineType: n
        };
      };
    })(i || (exports.NewLineToken = i = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: e,
          length: t,
          type: 8,
          comments: a,
          keywordType: n
        };
      };
      e.isSoftKeyword = function (e) {
        return exports.softKeywords.some(t => e.keywordType === t);
      };
    })(o || (exports.KeywordToken = o = {}));
    (function (e) {
      e.create = function (e, t, n, a, r, s) {
        return {
          start: e,
          length: t,
          type: 5,
          flags: n,
          escapedValue: a,
          prefixLength: r,
          quoteMarkLength: n & 4 ? 3 : 1,
          comments: s
        };
      };
    })(l || (exports.StringToken = l = {}));
    (function (e) {
      e.create = function (e, t, n, a, r) {
        return {
          start: e,
          length: t,
          type: 24,
          flags: n,
          prefixLength: a,
          quoteMarkLength: n & 4 ? 3 : 1,
          comments: r
        };
      };
    })(p || (exports.FStringStartToken = p = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: e,
          length: t,
          type: 25,
          flags: n,
          escapedValue: a
        };
      };
    })(d || (exports.FStringMiddleToken = d = {}));
    (function (e) {
      e.create = function (e, t, n) {
        return {
          start: e,
          length: t,
          type: 26,
          flags: n
        };
      };
    })(c || (exports.FStringEndToken = c = {}));
    (function (e) {
      e.create = function (e, t, n, a, r, s) {
        return {
          start: e,
          length: t,
          type: 6,
          isInteger: a,
          isImaginary: r,
          value: n,
          comments: s
        };
      };
    })(u || (exports.NumberToken = u = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: e,
          length: t,
          type: 9,
          operatorType: n,
          comments: a
        };
      };
    })(m || (exports.OperatorToken = m = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: e,
          length: t,
          type: 7,
          value: n.normalize('NFKC'),
          comments: a
        };
      };
    })(y || (exports.IdentifierToken = y = {}));
  },
  14911: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.unicodePc = exports.unicodeNdSurrogate = exports.unicodeNd = exports.unicodeMcSurrogate = exports.unicodeMc = exports.unicodeMnSurrogate = exports.unicodeMn = exports.unicodeNlSurrogate = exports.unicodeNl = exports.unicodeLmSurrogate = exports.unicodeLm = exports.unicodeLoSurrogate = exports.unicodeLo = exports.unicodeLt = exports.unicodeLlSurrogate = exports.unicodeLl = exports.unicodeLuSurrogate = exports.unicodeLu = undefined;
    exports.unicodeLu = [[65, 90], [192, 214], [216, 222], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 313, 315, 317, 319, 321, 323, 325, 327, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, 452, 455, 458, 461, 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, 497, 500, [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, 880, 882, 886, 895, 902, [904, 906], 908, [910, 911], [913, 929], [931, 939], 975, [978, 980], 984, 986, 988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006, 1012, 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], [4256, 4293], 4295, 4301, [5024, 5109], 7305, [7312, 7354], [7357, 7359], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], [8120, 8123], [8136, 8139], [8152, 8155], [8168, 8172], [8184, 8187], 8450, 8455, [8459, 8461], [8464, 8466], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8496, 8499], [8510, 8511], 8517, 8579, [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11390, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, [42955, 42956], 42960, 42966, 42968, 42970, 42972, 42997, [65313, 65338], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [68736, 68786], [68944, 68965], [71840, 71871], [93760, 93791], [119808, 119833], [119860, 119885], [119912, 119937], 119964, [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119989], [120016, 120041], [120068, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120120, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120172, 120197], [120224, 120249], [120276, 120301], [120328, 120353], [120380, 120405], [120432, 120457], [120488, 120512], [120546, 120570], [120604, 120628], [120662, 120686], [120720, 120744], 120778, [125184, 125217]];
    exports.unicodeLuSurrogate = {
      55297: [[56320, 56359], [56496, 56531], [56688, 56698], [56700, 56714], [56716, 56722], [56724, 56725]],
      55299: [[56448, 56498], [56656, 56677]],
      55302: [[56480, 56511]],
      55323: [[56896, 56927]],
      55349: [[56320, 56345], [56372, 56397], [56424, 56449], 56476, [56478, 56479], 56482, [56485, 56486], [56489, 56492], [56494, 56501], [56528, 56553], [56580, 56581], [56583, 56586], [56589, 56596], [56598, 56604], [56632, 56633], [56635, 56638], [56640, 56644], 56646, [56650, 56656], [56684, 56709], [56736, 56761], [56788, 56813], [56840, 56865], [56892, 56917], [56944, 56969], [57000, 57024], [57058, 57082], [57116, 57140], [57174, 57198], [57232, 57256], 57290],
      55354: [[56576, 56609]]
    };
    exports.unicodeLl = [[97, 122], 181, [223, 246], [248, 255], 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, [311, 312], 314, 316, 318, 320, 322, 324, 326, [328, 329], 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, [382, 384], 387, 389, 392, [396, 397], 402, 405, [409, 411], 414, 417, 419, 421, 424, [426, 427], 429, 432, 436, 438, [441, 442], [445, 447], 454, 457, 460, 462, 464, 466, 468, 470, 472, 474, [476, 477], 479, 481, 483, 485, 487, 489, 491, 493, [495, 496], 499, 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 545, 547, 549, 551, 553, 555, 557, 559, 561, [563, 569], 572, [575, 576], 578, 583, 585, 587, 589, [591, 659], [661, 687], 881, 883, 887, [891, 893], 912, [940, 974], [976, 977], [981, 983], 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, [1007, 1011], 1013, 1016, [1019, 1020], [1072, 1119], 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, [1230, 1231], 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, [1376, 1416], [4304, 4346], [4349, 4351], [5112, 5117], [7296, 7304], 7306, [7424, 7467], [7531, 7543], [7545, 7578], 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, [7829, 7837], 7839, 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8000, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8071], [8080, 8087], [8096, 8103], [8112, 8116], [8118, 8119], 8126, [8130, 8132], [8134, 8135], [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], 8458, [8462, 8463], 8467, 8495, 8500, 8505, [8508, 8509], [8518, 8521], 8526, 8580, [11312, 11359], 11361, [11365, 11366], 11368, 11370, 11372, 11377, [11379, 11380], [11382, 11387], 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, [11491, 11492], 11500, 11502, 11507, [11520, 11557], 11559, 11565, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, 42651, 42787, 42789, 42791, 42793, 42795, 42797, [42799, 42801], 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, 42863, [42865, 42872], 42874, 42876, 42879, 42881, 42883, 42885, 42887, 42892, 42894, 42897, [42899, 42901], 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42927, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42957, 42961, 42963, 42965, 42967, 42969, 42971, 42998, 43002, [43824, 43866], [43872, 43880], [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370], [66600, 66639], [66776, 66811], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68800, 68850], [68976, 68997], [71872, 71903], [93792, 93823], [119834, 119859], [119886, 119892], [119894, 119911], [119938, 119963], [119990, 119993], 119995, [119997, 120003], [120005, 120015], [120042, 120067], [120094, 120119], [120146, 120171], [120198, 120223], [120250, 120275], [120302, 120327], [120354, 120379], [120406, 120431], [120458, 120485], [120514, 120538], [120540, 120545], [120572, 120596], [120598, 120603], [120630, 120654], [120656, 120661], [120688, 120712], [120714, 120719], [120746, 120770], [120772, 120777], 120779, [122624, 122633], [122635, 122654], [122661, 122666], [125218, 125251]];
    exports.unicodeLlSurrogate = {
      55297: [[56360, 56399], [56536, 56571], [56727, 56737], [56739, 56753], [56755, 56761], [56763, 56764]],
      55299: [[56512, 56562], [56688, 56709]],
      55302: [[56512, 56543]],
      55323: [[56928, 56959]],
      55349: [[56346, 56371], [56398, 56404], [56406, 56423], [56450, 56475], [56502, 56505], 56507, [56509, 56515], [56517, 56527], [56554, 56579], [56606, 56631], [56658, 56683], [56710, 56735], [56762, 56787], [56814, 56839], [56866, 56891], [56918, 56943], [56970, 56997], [57026, 57050], [57052, 57057], [57084, 57108], [57110, 57115], [57142, 57166], [57168, 57173], [57200, 57224], [57226, 57231], [57258, 57282], [57284, 57289], 57291],
      55351: [[57088, 57097], [57099, 57118], [57125, 57130]],
      55354: [[56610, 56643]]
    };
    exports.unicodeLt = [453, 456, 459, 498, [8072, 8079], [8088, 8095], [8104, 8111], 8124, 8140, 8188];
    exports.unicodeLo = [170, 186, 443, [448, 451], 660, [1488, 1514], [1519, 1522], [1568, 1599], [1601, 1610], [1646, 1647], [1649, 1747], 1749, [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2048, 2069], [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2248], [2308, 2361], 2365, 2384, [2392, 2401], [2418, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3585, 3632], [3634, 3635], [3648, 3653], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], 4159, [4176, 4181], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4352, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5873, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6000], [6016, 6067], 6108, [6176, 6210], [6212, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7287], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [8501, 8504], [11568, 11623], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], 12294, 12348, [12353, 12438], 12447, [12449, 12538], 12543, [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 40980], [40982, 42124], [42192, 42231], [42240, 42507], [42512, 42527], [42538, 42539], 42606, [42656, 42725], 42895, 42999, [43003, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], [43488, 43492], [43495, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43631], [43633, 43638], 43642, [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43740], [43744, 43754], 43762, [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43968, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65382, 65391], [65393, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66368], [66370, 66377], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66640, 66717], [66816, 66855], [66864, 66915], [67008, 67059], [67072, 67382], [67392, 67413], [67424, 67431], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68864, 68899], [68938, 68941], 68943, [69248, 69289], [69296, 69297], [69314, 69316], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70528, 70537], 70539, 70542, [70544, 70581], 70583, 70609, 70611, [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71424, 71450], [71488, 71494], [71680, 71723], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72640, 72672], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [78944, 82938], [82944, 83526], [90368, 90397], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [93027, 93047], [93053, 93071], [93507, 93546], [93952, 94026], 94032, [94208, 100343], [100352, 101589], [101631, 101640], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 122634, [123136, 123180], 123214, [123536, 123565], [123584, 123627], [124112, 124138], [124368, 124397], 124400, [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [191472, 192093], [194560, 195101], [196608, 201546], [201552, 205743]];
    exports.unicodeLoSurrogate = {
      55296: [[56320, 56331], [56333, 56358], [56360, 56378], [56380, 56381], [56383, 56397], [56400, 56413], [56448, 56570], [56960, 56988], [56992, 57040], [57088, 57119], [57133, 57152], [57154, 57161], [57168, 57205], [57216, 57245], [57248, 57283], [57288, 57295]],
      55297: [[56400, 56477], [56576, 56615], [56624, 56675], [56768, 56819], [56832, 57142], [57152, 57173], [57184, 57191]],
      55298: [[56320, 56325], 56328, [56330, 56373], [56375, 56376], 56380, [56383, 56405], [56416, 56438], [56448, 56478], [56544, 56562], [56564, 56565], [56576, 56597], [56608, 56633], [56704, 56759], [56766, 56767], 56832, [56848, 56851], [56853, 56855], [56857, 56885], [56928, 56956], [56960, 56988], [57024, 57031], [57033, 57060], [57088, 57141], [57152, 57173], [57184, 57202], [57216, 57233]],
      55299: [[56320, 56392], [56576, 56611], [56650, 56653], 56655, [56960, 57001], [57008, 57009], [57026, 57028], [57088, 57116], 57127, [57136, 57157], [57200, 57217], [57264, 57284], [57312, 57334]],
      55300: [[56323, 56375], [56433, 56434], 56437, [56451, 56495], [56528, 56552], [56579, 56614], 56644, 56647, [56656, 56690], 56694, [56707, 56754], [56769, 56772], 56794, 56796, [56832, 56849], [56851, 56875], [56895, 56896], [56960, 56966], 56968, [56970, 56973], [56975, 56989], [56991, 57000], [57008, 57054], [57093, 57100], [57103, 57104], [57107, 57128], [57130, 57136], [57138, 57139], [57141, 57145], 57149, 57168, [57181, 57185], [57216, 57225], 57227, 57230, [57232, 57269], 57271, 57297, 57299],
      55301: [[56320, 56372], [56391, 56394], [56415, 56417], [56448, 56495], [56516, 56517], 56519, [56704, 56750], [56792, 56795], [56832, 56879], 56900, [56960, 57002], 57016, [57088, 57114], [57152, 57158]],
      55302: [[56320, 56363], [56575, 56582], 56585, [56588, 56595], [56597, 56598], [56600, 56623], 56639, 56641, [56736, 56743], [56746, 56784], 56801, 56803, 56832, [56843, 56882], 56890, 56912, [56924, 56969], 56989, [57008, 57080], [57280, 57312]],
      55303: [[56320, 56328], [56330, 56366], 56384, [56434, 56463], [56576, 56582], [56584, 56585], [56587, 56624], 56646, [56672, 56677], [56679, 56680], [56682, 56713], 56728, [57056, 57074], 57090, [57092, 57104], [57106, 57139], 57264],
      55304: [[56320, 57241]],
      55305: [[56448, 56643]],
      55307: [[57232, 57328]],
      55308: [[56320, 57343]],
      55309: [[56320, 56367], [56385, 56390], [56416, 57343]],
      55310: [[56320, 57343]],
      55311: [[56320, 57343]],
      55312: [[56320, 57338]],
      55313: [[56320, 56902]],
      55320: [[56576, 56605]],
      55322: [[56320, 56888], [56896, 56926], [56944, 57022], [57040, 57069], [57088, 57135], [57187, 57207], [57213, 57231]],
      55323: [[56643, 56682], [57088, 57162], 57168],
      55324: [[56320, 57343]],
      55325: [[56320, 57343]],
      55326: [[56320, 57343]],
      55327: [[56320, 57343]],
      55328: [[56320, 57343]],
      55329: [[56320, 57335]],
      55330: [[56320, 57343]],
      55331: [[56320, 56533], [56575, 56584]],
      55340: [[56320, 56610], 56626, [56656, 56658], 56661, [56676, 56679], [56688, 57083]],
      55343: [[56320, 56426], [56432, 56444], [56448, 56456], [56464, 56473]],
      55351: [57098],
      55352: [[56576, 56620], 56654, [56976, 57005], [57024, 57067]],
      55353: [[56528, 56554], [56784, 56813], 56816, [57312, 57318], [57320, 57323], [57325, 57326], [57328, 57342]],
      55354: [[56320, 56516]],
      55355: [[56832, 56835], [56837, 56863], [56865, 56866], 56868, 56871, [56873, 56882], [56884, 56887], 56889, 56891, 56898, 56903, 56905, 56907, [56909, 56911], [56913, 56914], 56916, 56919, 56921, 56923, 56925, 56927, [56929, 56930], 56932, [56935, 56938], [56940, 56946], [56948, 56951], [56953, 56956], 56958, [56960, 56969], [56971, 56987], [56993, 56995], [56997, 57001], [57003, 57019]],
      55360: [[56320, 57343]],
      55361: [[56320, 57343]],
      55362: [[56320, 57343]],
      55363: [[56320, 57343]],
      55364: [[56320, 57343]],
      55365: [[56320, 57343]],
      55366: [[56320, 57343]],
      55367: [[56320, 57343]],
      55368: [[56320, 57343]],
      55369: [[56320, 57343]],
      55370: [[56320, 57343]],
      55371: [[56320, 57343]],
      55372: [[56320, 57343]],
      55373: [[56320, 57343]],
      55374: [[56320, 57343]],
      55375: [[56320, 57343]],
      55376: [[56320, 57343]],
      55377: [[56320, 57343]],
      55378: [[56320, 57343]],
      55379: [[56320, 57343]],
      55380: [[56320, 57343]],
      55381: [[56320, 57343]],
      55382: [[56320, 57343]],
      55383: [[56320, 57343]],
      55384: [[56320, 57343]],
      55385: [[56320, 57343]],
      55386: [[56320, 57343]],
      55387: [[56320, 57343]],
      55388: [[56320, 57343]],
      55389: [[56320, 57343]],
      55390: [[56320, 57343]],
      55391: [[56320, 57343]],
      55392: [[56320, 57343]],
      55393: [[56320, 57343]],
      55394: [[56320, 57343]],
      55395: [[56320, 57343]],
      55396: [[56320, 57343]],
      55397: [[56320, 57343]],
      55398: [[56320, 57343]],
      55399: [[56320, 57343]],
      55400: [[56320, 57343]],
      55401: [[56320, 57055], [57088, 57343]],
      55402: [[56320, 57343]],
      55403: [[56320, 57343]],
      55404: [[56320, 57343]],
      55405: [[56320, 57145], [57152, 57343]],
      55406: [[56320, 56349], [56352, 57343]],
      55407: [[56320, 57343]],
      55408: [[56320, 57343]],
      55409: [[56320, 57343]],
      55410: [[56320, 57343]],
      55411: [[56320, 56993], [57008, 57343]],
      55412: [[56320, 57343]],
      55413: [[56320, 57343]],
      55414: [[56320, 57343]],
      55415: [[56320, 57343]],
      55416: [[56320, 57343]],
      55417: [[56320, 57343]],
      55418: [[56320, 57312], [57328, 57343]],
      55419: [[56320, 56925]],
      55422: [[56320, 56861]],
      55424: [[56320, 57343]],
      55425: [[56320, 57343]],
      55426: [[56320, 57343]],
      55427: [[56320, 57343]],
      55428: [[56320, 57162], [57168, 57343]],
      55429: [[56320, 57343]],
      55430: [[56320, 57343]],
      55431: [[56320, 57343]],
      55432: [[56320, 57263]]
    };
    exports.unicodeLm = [[688, 705], [710, 721], [736, 740], 748, 750, 884, 890, 1369, 1600, [1765, 1766], [2036, 2037], 2042, 2074, 2084, 2088, 2249, 2417, 3654, 3782, 4348, 6103, 6211, 6823, [7288, 7293], [7468, 7530], 7544, [7579, 7615], 8305, 8319, [8336, 8348], [11388, 11389], 11631, 11823, 12293, [12337, 12341], 12347, [12445, 12446], [12540, 12542], 40981, [42232, 42237], 42508, 42623, [42652, 42653], [42775, 42783], 42864, 42888, [42994, 42996], [43000, 43001], 43471, 43494, 43632, 43741, [43763, 43764], [43868, 43871], 43881, 65392, [65438, 65439], [67456, 67461], [67463, 67504], [67506, 67514], 68942, 68975, [92992, 92995], [93504, 93506], [93547, 93548], [94099, 94111], [94176, 94177], 94179, [110576, 110579], [110581, 110587], [110589, 110590], [122928, 122989], [123191, 123197], 124139, 125259];
    exports.unicodeLmSurrogate = {
      55297: [[57216, 57221], [57223, 57264], [57266, 57274]],
      55299: [56654, 56687],
      55322: [[57152, 57155]],
      55323: [[56640, 56642], [56683, 56684], [57235, 57247], [57312, 57313], 57315],
      55339: [[57328, 57331], [57333, 57339], [57341, 57342]],
      55352: [[56368, 56429], [56631, 56637]],
      55353: [56555],
      55354: [56651]
    };
    exports.unicodeNl = [[5870, 5872], [8544, 8578], [8581, 8584], 12295, [12321, 12329], [12344, 12346], [42726, 42735], [65856, 65908], 66369, 66378, [66513, 66517], [74752, 74862]];
    exports.unicodeNlSurrogate = {
      55296: [[56640, 56692], 57153, 57162, [57297, 57301]],
      55305: [[56320, 56430]]
    };
    exports.unicodeMn = [[768, 879], [1155, 1159], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2199, 2207], [2250, 2273], [2275, 2306], 2362, 2364, [2369, 2376], 2381, [2385, 2391], [2402, 2403], 2433, 2492, [2497, 2500], 2509, [2530, 2531], 2558, [2561, 2562], 2620, [2625, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2690], 2748, [2753, 2757], [2759, 2760], 2765, [2786, 2787], [2810, 2815], 2817, 2876, 2879, [2881, 2884], 2893, [2901, 2902], [2914, 2915], 2946, 3008, 3021, 3072, 3076, 3132, [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], 3201, 3260, 3263, 3270, [3276, 3277], [3298, 3299], [3328, 3329], [3387, 3388], [3393, 3396], 3405, [3426, 3427], 3457, 3530, [3538, 3540], 3542, 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], 4226, [4229, 4230], 4237, 4253, [4957, 4959], [5906, 5908], [5938, 5939], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], 6086, [6089, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6434], [6439, 6440], 6450, [6457, 6459], [6679, 6680], 6683, 6742, [6744, 6750], 6752, 6754, [6757, 6764], [6771, 6780], 6783, [6832, 6845], [6847, 6862], [6912, 6915], 6964, [6966, 6970], 6972, 6978, [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], 7142, [7144, 7145], 7149, [7151, 7153], [7212, 7219], [7222, 7223], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7616, 7679], [8400, 8412], 8417, [8421, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12333], [12441, 12442], 42607, [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43045, 43046], 43052, [43204, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43345], [43392, 43394], 43443, [43446, 43449], [43452, 43453], 43493, [43561, 43566], [43569, 43570], [43573, 43574], 43587, 43596, 43644, 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43756, 43757], 43766, 44005, 44008, 44013, 64286, [65024, 65039], [65056, 65071], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [68969, 68973], [69291, 69292], [69372, 69375], [69446, 69456], [69506, 69509], 69633, [69688, 69702], 69744, [69747, 69748], [69759, 69761], [69811, 69814], [69817, 69818], 69826, [69888, 69890], [69927, 69931], [69933, 69940], 70003, [70016, 70017], [70070, 70078], [70089, 70092], 70095, [70191, 70193], 70196, [70198, 70199], 70206, 70209, 70367, [70371, 70378], [70400, 70401], [70459, 70460], 70464, [70502, 70508], [70512, 70516], [70587, 70592], 70606, 70608, 70610, [70625, 70626], [70712, 70719], [70722, 70724], 70726, 70750, [70835, 70840], 70842, [70847, 70848], [70850, 70851], [71090, 71093], [71100, 71101], [71103, 71104], [71132, 71133], [71219, 71226], 71229, [71231, 71232], 71339, 71341, [71344, 71349], 71351, 71453, 71455, [71458, 71461], [71463, 71467], [71727, 71735], [71737, 71738], [71995, 71996], 71998, 72003, [72148, 72151], [72154, 72155], 72160, [72193, 72202], [72243, 72248], [72251, 72254], 72263, [72273, 72278], [72281, 72283], [72330, 72342], [72344, 72345], [72752, 72758], [72760, 72765], 72767, [72850, 72871], [72874, 72880], [72882, 72883], [72885, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73104, 73105], 73109, 73111, [73459, 73460], [73472, 73473], [73526, 73530], 73536, 73538, 73562, 78912, [78919, 78933], [90398, 90409], [90413, 90415], [92912, 92916], [92976, 92982], 94031, [94095, 94098], 94180, [113821, 113822], [118528, 118573], [118576, 118598], [119143, 119145], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [124398, 124399], [125136, 125142], [125252, 125258], [917760, 917999]];
    exports.unicodeMnSurrogate = {
      55296: [56829, 57056, [57206, 57210]],
      55298: [[56833, 56835], [56837, 56838], [56844, 56847], [56888, 56890], 56895, [57061, 57062]],
      55299: [[56612, 56615], [56681, 56685], [57003, 57004], [57084, 57087], [57158, 57168], [57218, 57221]],
      55300: [56321, [56376, 56390], 56432, [56435, 56436], [56447, 56449], [56499, 56502], [56505, 56506], 56514, [56576, 56578], [56615, 56619], [56621, 56628], 56691, [56704, 56705], [56758, 56766], [56777, 56780], 56783, [56879, 56881], 56884, [56886, 56887], 56894, 56897, 57055, [57059, 57066], [57088, 57089], [57147, 57148], 57152, [57190, 57196], [57200, 57204], [57275, 57280], 57294, 57296, 57298, [57313, 57314]],
      55301: [[56376, 56383], [56386, 56388], 56390, 56414, [56499, 56504], 56506, [56511, 56512], [56514, 56515], [56754, 56757], [56764, 56765], [56767, 56768], [56796, 56797], [56883, 56890], 56893, [56895, 56896], 57003, 57005, [57008, 57013], 57015, 57117, 57119, [57122, 57125], [57127, 57131]],
      55302: [[56367, 56375], [56377, 56378], [56635, 56636], 56638, 56643, [56788, 56791], [56794, 56795], 56800, [56833, 56842], [56883, 56888], [56891, 56894], 56903, [56913, 56918], [56921, 56923], [56970, 56982], [56984, 56985]],
      55303: [[56368, 56374], [56376, 56381], 56383, [56466, 56487], [56490, 56496], [56498, 56499], [56501, 56502], [56625, 56630], 56634, [56636, 56637], [56639, 56645], 56647, [56720, 56721], 56725, 56727, [57075, 57076], [57088, 57089], [57142, 57146], 57152, 57154, 57178],
      55309: [56384, [56391, 56405]],
      55320: [[56606, 56617], [56621, 56623]],
      55322: [[57072, 57076], [57136, 57142]],
      55323: [57167, [57231, 57234], 57316],
      55343: [[56477, 56478]],
      55347: [[57088, 57133], [57136, 57158]],
      55348: [[56679, 56681], [56699, 56706], [56709, 56715], [56746, 56749], [56898, 56900]],
      55350: [[56832, 56886], [56891, 56940], 56949, 56964, [56987, 56991], [56993, 57007]],
      55352: [[56320, 56326], [56328, 56344], [56347, 56353], [56355, 56356], [56358, 56362], 56463, [56624, 56630], 57006, [57068, 57071]],
      55353: [[56556, 56559], [56814, 56815]],
      55354: [[56528, 56534], [56644, 56650]],
      56128: [[56576, 56815]]
    };
    exports.unicodeMc = [2307, 2363, [2366, 2368], [2377, 2380], [2382, 2383], [2434, 2435], [2494, 2496], [2503, 2504], [2507, 2508], 2519, 2563, [2622, 2624], 2691, [2750, 2752], 2761, [2763, 2764], [2818, 2819], 2878, 2880, [2887, 2888], [2891, 2892], 2903, [3006, 3007], [3009, 3010], [3014, 3016], [3018, 3020], 3031, [3073, 3075], [3137, 3140], [3202, 3203], 3262, [3264, 3268], [3271, 3272], [3274, 3275], [3285, 3286], 3315, [3330, 3331], [3390, 3392], [3398, 3400], [3402, 3404], 3415, [3458, 3459], [3535, 3537], [3544, 3551], [3570, 3571], [3902, 3903], 3967, [4139, 4140], 4145, 4152, [4155, 4156], [4182, 4183], [4194, 4196], [4199, 4205], [4227, 4228], [4231, 4236], 4239, [4250, 4252], 5909, 5940, 6070, [6078, 6085], [6087, 6088], [6435, 6438], [6441, 6443], [6448, 6449], [6451, 6456], [6681, 6682], 6741, 6743, 6753, [6755, 6756], [6765, 6770], 6916, 6965, 6971, [6973, 6977], [6979, 6980], 7042, 7073, [7078, 7079], 7082, 7143, [7146, 7148], 7150, [7154, 7155], [7204, 7211], [7220, 7221], 7393, 7415, [12334, 12335], [43043, 43044], 43047, [43136, 43137], [43188, 43203], [43346, 43347], 43395, [43444, 43445], [43450, 43451], [43454, 43456], [43567, 43568], [43571, 43572], 43597, 43643, 43645, 43755, [43758, 43759], 43765, [44003, 44004], [44006, 44007], [44009, 44010], 44012, 69632, 69634, 69762, [69808, 69810], [69815, 69816], 69932, [69957, 69958], 70018, [70067, 70069], [70079, 70080], 70094, [70188, 70190], [70194, 70195], 70197, [70368, 70370], [70402, 70403], [70462, 70463], [70465, 70468], [70471, 70472], [70475, 70477], 70487, [70498, 70499], [70584, 70586], 70594, 70597, [70599, 70602], [70604, 70605], 70607, [70709, 70711], [70720, 70721], 70725, [70832, 70834], 70841, [70843, 70846], 70849, [71087, 71089], [71096, 71099], 71102, [71216, 71218], [71227, 71228], 71230, 71340, [71342, 71343], 71350, 71454, [71456, 71457], 71462, [71724, 71726], 71736, [71984, 71989], [71991, 71992], 71997, 72000, 72002, [72145, 72147], [72156, 72159], 72164, 72249, [72279, 72280], 72343, 72751, 72766, 72873, 72881, 72884, [73098, 73102], [73107, 73108], 73110, [73461, 73462], 73475, [73524, 73525], [73534, 73535], 73537, [90410, 90412], [94033, 94087], [94192, 94193], [119141, 119142], [119149, 119154]];
    exports.unicodeMcSurrogate = {
      55300: [56320, 56322, 56450, [56496, 56498], [56503, 56504], 56620, [56645, 56646], 56706, [56755, 56757], [56767, 56768], 56782, [56876, 56878], [56882, 56883], 56885, [57056, 57058], [57090, 57091], [57150, 57151], [57153, 57156], [57159, 57160], [57163, 57165], 57175, [57186, 57187], [57272, 57274], 57282, 57285, [57287, 57290], [57292, 57293], 57295],
      55301: [[56373, 56375], [56384, 56385], 56389, [56496, 56498], 56505, [56507, 56510], 56513, [56751, 56753], [56760, 56763], 56766, [56880, 56882], [56891, 56892], 56894, 57004, [57006, 57007], 57014, 57118, [57120, 57121], 57126],
      55302: [[56364, 56366], 56376, [56624, 56629], [56631, 56632], 56637, 56640, 56642, [56785, 56787], [56796, 56799], 56804, 56889, [56919, 56920], 56983],
      55303: [56367, 56382, 56489, 56497, 56500, [56714, 56718], [56723, 56724], 56726, [57077, 57078], 57091, [57140, 57141], [57150, 57151], 57153],
      55320: [[56618, 56620]],
      55323: [[57169, 57223], [57328, 57329]],
      55348: [[56677, 56678], [56685, 56690]]
    };
    exports.unicodeNd = [[48, 57], [1632, 1641], [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2662, 2671], [2790, 2799], [2918, 2927], [3046, 3055], [3174, 3183], [3302, 3311], [3430, 3439], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3881], [4160, 4169], [4240, 4249], [6112, 6121], [6160, 6169], [6470, 6479], [6608, 6617], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], [42528, 42537], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [65296, 65305], [66720, 66729], [68912, 68921], [68928, 68937], [69734, 69743], [69872, 69881], [69942, 69951], [70096, 70105], [70384, 70393], [70736, 70745], [70864, 70873], [71248, 71257], [71360, 71369], [71376, 71395], [71472, 71481], [71904, 71913], [72016, 72025], [72688, 72697], [72784, 72793], [73040, 73049], [73120, 73129], [73552, 73561], [90416, 90425], [92768, 92777], [92864, 92873], [93008, 93017], [93552, 93561], [118000, 118009], [120782, 120831], [123200, 123209], [123632, 123641], [124144, 124153], [124401, 124410], [125264, 125273], [130032, 130041]];
    exports.unicodeNdSurrogate = {
      55297: [[56480, 56489]],
      55299: [[56624, 56633], [56640, 56649]],
      55300: [[56422, 56431], [56560, 56569], [56630, 56639], [56784, 56793], [57072, 57081]],
      55301: [[56400, 56409], [56528, 56537], [56912, 56921], [57024, 57033], [57040, 57059], [57136, 57145]],
      55302: [[56544, 56553], [56656, 56665], [57328, 57337]],
      55303: [[56400, 56409], [56656, 56665], [56736, 56745], [57168, 57177]],
      55320: [[56624, 56633]],
      55322: [[56928, 56937], [57024, 57033], [57168, 57177]],
      55323: [[56688, 56697]],
      55347: [[56560, 56569]],
      55349: [[57294, 57343]],
      55352: [[56640, 56649], [57072, 57081]],
      55353: [[56560, 56569], [56817, 56826]],
      55354: [[56656, 56665]],
      55358: [[57328, 57337]]
    };
    exports.unicodePc = [95, [8255, 8256], 8276, [65075, 65076], [65101, 65103], 65343];
  },
  62226: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.PyrightFileSystem = exports.SupportPartialStubs = undefined;
    const a = require(92031);
    const r = require(4883);
    const s = require(5884);
    const i = require(86789);
    var o;
    (function (e) {
      e.is = function (e) {
        return e.isPartialStubPackagesScanned && e.isPathScanned && e.processPartialStubPackages && e.clearPartialStubs;
      };
    })(o || (exports.SupportPartialStubs = o = {}));
    class l extends i.ReadOnlyAugmentedFileSystem {
      constructor(e) {
        super(e);
        this._rootSearched = new Set();
        this._partialStubPackagePaths = new Set();
      }
      mkdirSync(e, t) {
        this.realFS.mkdirSync(e, t);
      }
      chdir(e) {
        this.realFS.chdir(e);
      }
      writeFileSync(e, t, n) {
        this.realFS.writeFileSync(this.getOriginalPath(e), t, n);
      }
      rmdirSync(e) {
        this.realFS.rmdirSync(this.getOriginalPath(e));
      }
      unlinkSync(e) {
        this.realFS.unlinkSync(this.getOriginalPath(e));
      }
      createWriteStream(e) {
        return this.realFS.createWriteStream(this.getOriginalPath(e));
      }
      copyFileSync(e, t) {
        this.realFS.copyFileSync(this.getOriginalPath(e), this.getOriginalPath(t));
      }
      isPartialStubPackagesScanned(e) {
        return !!e.root && this.isPathScanned(e.root);
      }
      isPathScanned(e) {
        return this._rootSearched.has(e.key);
      }
      processPartialStubPackages(e, t, n, i) {
        var o;
        const l = i ?? this._allowMoving.bind(this);
        for (const i of e) {
          this._rootSearched.add(i.key);
          if (!this.realFS.existsSync(i) || !s.isDirectory(this.realFS, i)) {
            continue;
          }
          let e = [];
          try {
            e = this.realFS.readdirEntriesSync(i);
          } catch {}
          const p = i.equals(n);
          for (const n of e) {
            const e = i.combinePaths(n.name);
            if (!(n.isSymbolicLink() ? !!((o = s.tryStat(this.realFS, e)) === null || o === undefined ? undefined : o.isDirectory()) : n.isDirectory()) || !n.name.endsWith(r.stubsSuffix)) {
              continue;
            }
            const d = a.getPyTypedInfo(this.realFS, e);
            if (!d || !d.isPartiallyTyped) {
              continue;
            }
            let c;
            this._partialStubPackagePaths.add(e.key);
            const u = n.name.substr(0, n.name.length - r.stubsSuffix.length);
            for (const n of t) {
              const t = n.combinePaths(u);
              try {
                const n = s.tryStat(this.realFS, t);
                if (!(n == null ? undefined : n.isDirectory())) {
                  continue;
                }
                if (!l(p, a.getPyTypedInfo(this.realFS, t), d)) {
                  continue;
                }
                c = c ?? this._getRelativePathPartialStubs(e);
                for (const n of c) {
                  const a = e.resolvePaths(n);
                  const r = t.resolvePaths(n);
                  this.recordMovedEntry(r, a, t);
                }
              } catch {}
            }
          }
        }
      }
      clearPartialStubs() {
        super.clear();
        this._rootSearched.clear();
        this._partialStubPackagePaths.clear();
      }
      isMovedEntry(e) {
        return this._partialStubPackagePaths.has(e.key) || super.isMovedEntry(e);
      }
      _allowMoving(e, t, n) {
        return !e || !t || t.isPartiallyTyped;
      }
      _getRelativePathPartialStubs(e) {
        const t = [];
        const n = a => {
          for (const r of this.realFS.readdirEntriesSync(a)) {
            const i = a.combinePaths(r.name);
            let o = r.isDirectory();
            let l = r.isFile();
            if (r.isSymbolicLink()) {
              const e = s.tryStat(this.realFS, i);
              if (e) {
                o = e.isDirectory();
                l = e.isFile();
              }
            }
            if (o) {
              n(i);
            }
            if (l && r.name.endsWith('.pyi')) {
              const n = e.getRelativePathComponents(i).join('/');
              if (n) {
                t.push(n);
              }
            }
          }
        };
        n(e);
        return t;
      }
    }
    exports.PyrightFileSystem = l;
  },
  86789: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ReadOnlyAugmentedFileSystem = undefined;
    const a = require(58147);
    const r = require(66643);
    exports.ReadOnlyAugmentedFileSystem = class {
      constructor(e) {
        this.realFS = e;
        this._entryMap = new Map();
        this._reverseEntryMap = new Map();
        this._folderMap = new Map();
      }
      existsSync(e) {
        return !this.isMovedEntry(e) && this.realFS.existsSync(this.getOriginalPath(e));
      }
      mkdirSync(e, t) {
        throw new Error('Operation is not allowed.');
      }
      chdir(e) {
        throw new Error('Operation is not allowed.');
      }
      readdirEntriesSync(e) {
        const t = [];
        const n = this._folderMap.get(e.key);
        if (!n || !!this.realFS.existsSync(e)) {
          a.appendArray(t, this.realFS.readdirEntriesSync(e).filter(t => !this.isMovedEntry(e.combinePaths(t.name)) && !(n == null ? undefined : n.some(e => e.name === t.name))));
        }
        if (!n) {
          return t;
        }
        const s = e.getFilePath();
        return t.concat(n.map(e => new r.VirtualDirent(e.name, e.isFile, s)));
      }
      readdirSync(e) {
        return this.readdirEntriesSync(e).map(e => e.name);
      }
      readFileSync(e, t) {
        return this.realFS.readFileSync(this.getOriginalPath(e), t);
      }
      writeFileSync(e, t, n) {
        throw new Error('Operation is not allowed.');
      }
      statSync(e) {
        return this.realFS.statSync(this.getOriginalPath(e));
      }
      rmdirSync(e) {
        throw new Error('Operation is not allowed.');
      }
      unlinkSync(e) {
        throw new Error('Operation is not allowed.');
      }
      realpathSync(e) {
        if (this._entryMap.has(e.key)) {
          return e;
        } else {
          return this.realFS.realpathSync(e);
        }
      }
      getModulePath() {
        return this.realFS.getModulePath();
      }
      createFileSystemWatcher(e, t) {
        return this.realFS.createFileSystemWatcher(e, t);
      }
      createReadStream(e) {
        return this.realFS.createReadStream(this.getOriginalPath(e));
      }
      createWriteStream(e) {
        throw new Error('Operation is not allowed.');
      }
      copyFileSync(e, t) {
        throw new Error('Operation is not allowed.');
      }
      readFile(e) {
        return this.realFS.readFile(this.getOriginalPath(e));
      }
      readFileText(e, t) {
        return this.realFS.readFileText(this.getOriginalPath(e), t);
      }
      realCasePath(e) {
        return this.realFS.realCasePath(e);
      }
      isMappedUri(e) {
        return this._entryMap.has(e.key) || this.realFS.isMappedUri(e);
      }
      getOriginalUri(e) {
        return this.realFS.getOriginalUri(this.getOriginalPath(e));
      }
      getMappedUri(e) {
        var t;
        const n = this.realFS.getMappedUri(e);
        if ((t = this._reverseEntryMap.get(n.key)) !== null && t !== undefined) {
          return t;
        } else {
          return n;
        }
      }
      isInZip(e) {
        return this.realFS.isInZip(e);
      }
      recordMovedEntry(e, t, n) {
        this._entryMap.set(e.key, t);
        this._reverseEntryMap.set(t.key, e);
        const r = e.getDirectory();
        const s = a.getOrAdd(this._folderMap, r.key, () => []);
        const i = e.fileName;
        if (!s.some(e => e.name === i)) {
          s.push({
            name: i,
            isFile: true
          });
        }
        const o = n.getRelativePathComponents(r);
        for (let e = 0; e < o.length; e++) {
          const t = n.combinePaths(...o.slice(0, e + 1));
          const r = t.getDirectory().key;
          const s = a.getOrAdd(this._folderMap, r, () => []);
          const i = t.fileName;
          if (!s.some(e => e.name === i)) {
            s.push({
              name: i,
              isFile: false
            });
          }
        }
      }
      getOriginalPath(e) {
        var t;
        if ((t = this._entryMap.get(e.key)) !== null && t !== undefined) {
          return t;
        } else {
          return e;
        }
      }
      isMovedEntry(e) {
        return this._reverseEntryMap.has(e.key);
      }
      clear() {
        this._entryMap.clear();
        this._reverseEntryMap.clear();
        this._folderMap.clear();
      }
    };
  },
  30741: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.WorkspaceFactory = exports.WellKnownWorkspaceKinds = undefined;
    exports.createInitStatus = o;
    exports.renameWorkspace = l;
    const a = require(51507);
    const r = require(27113);
    let s = 0;
    var i;
    function o() {
      let e = false;
      const t = a.createDeferred();
      const n = {
        promise: t.promise,
        resolve: () => {
          e = true;
          t.resolve();
        },
        markCalled: () => {
          e = true;
        },
        reset: () => e ? o() : n,
        resolved: () => t.resolved
      };
      return n;
    }
    function l(e, t) {
      e.workspaceName = t;
      e.service.setServiceName(t);
    }
    (function (e) {
      e.Default = 'default';
      e.Regular = 'regular';
      e.Limited = 'limited';
      e.Cloned = 'cloned';
      e.Test = 'test';
    })(i || (exports.WellKnownWorkspaceKinds = i = {}));
    function p(e) {
      return !!e.rootUri;
    }
    exports.WorkspaceFactory = class {
      constructor(e, t, n, a, r) {
        this._console = e;
        this._createService = t;
        this._onWorkspaceCreated = n;
        this._onWorkspaceRemoved = a;
        this._serviceProvider = r;
        this._defaultWorkspacePath = '<default>';
        this._map = new Map();
        this._id = s++;
        this._console.log(`WorkspaceFactory ${this._id} created`);
      }
      handleInitialize(e) {
        if (e.workspaceFolders) {
          e.workspaceFolders.forEach(e => {
            this._add(r.Uri.parse(e.uri, this._serviceProvider), e.name, [i.Regular]);
          });
        } else {
          if (e.rootPath) {
            this._add(r.Uri.file(e.rootPath, this._serviceProvider), '', [i.Regular]);
          }
        }
      }
      handleWorkspaceFoldersChanged(e, t) {
        var n;
        e.removed.forEach(e => {
          const t = r.Uri.parse(e.uri, this._serviceProvider);
          this.getNonDefaultWorkspaces().filter(e => e.rootUri.equals(t)).forEach(e => {
            this._remove(e);
          });
        });
        e.added.forEach(e => {
          const t = r.Uri.parse(e.uri, this._serviceProvider);
          this._add(t, e.name, [i.Regular]);
        });
        ((n = t == null ? undefined : t.filter(t => !e.added.some(e => e.uri === t.uri) && !e.removed.some(e => e.uri === t.uri))) !== null && n !== undefined ? n : []).forEach(e => {
          const t = r.Uri.parse(e.uri, this._serviceProvider);
          this.getNonDefaultWorkspaces().filter(n => n.rootUri.equals(t) && n.workspaceName !== e.name).forEach(t => l(t, e.name));
        });
      }
      items() {
        return Array.from(this._map.values());
      }
      clear() {
        this._map.forEach(e => {
          e.isInitialized.resolve();
          e.service.dispose();
        });
        this._map.clear();
        this._console.log(`WorkspaceFactory ${this._id} clear`);
      }
      hasMultipleWorkspaces(e) {
        if (this._map.size === 0 || this._map.size === 1) {
          return false;
        }
        let t = 0;
        for (const n of this._map) {
          if (!e || !!n[1].kinds.some(t => t === e)) {
            t++;
          }
          if (t > 1) {
            return true;
          }
        }
        return false;
      }
      getContainingWorkspace(e, t) {
        return this._getBestRegularWorkspace(this.getNonDefaultWorkspaces(i.Regular).filter(t => e.startsWith(t.rootUri)));
      }
      getNonDefaultWorkspaces(e) {
        const t = [];
        this._map.forEach(n => {
          if (n.rootUri) {
            if (!e || !!n.kinds.some(t => t === e)) {
              t.push(n);
            }
          }
        });
        return t;
      }
      async getWorkspaceForFile(e, t) {
        await Promise.all(this.items().map(e => e.isInitialized.promise));
        const n = await this._getOrCreateBestWorkspaceForFile(e);
        await n.isInitialized.promise;
        return n;
      }
      async getContainingWorkspacesForFile(e) {
        await Promise.all(this.items().map(e => e.isInitialized.promise));
        const t = this.items().filter(t => t.service.isTracked(e));
        if (t.length === 0) {
          t.push(this._getBestWorkspaceForFile(e));
        }
        await Promise.all(t.map(e => e.isInitialized.promise));
        return t;
      }
      _add(e, t, n) {
        const a = e ?? r.Uri.empty();
        if (!n.includes(i.Default) && !a.isLocal()) {
          n = [...n, i.Limited];
        }
        const s = {
          workspaceName: t,
          rootUri: e,
          kinds: n,
          service: this._createService(t, a, n),
          disableLanguageServices: false,
          disableTaggedHints: false,
          disableOrganizeImports: false,
          disableWorkspaceSymbol: false,
          isInitialized: o(),
          searchPathsToWatch: []
        };
        const l = this._getWorkspaceKey(s);
        this._remove(s);
        this._console.log(`WorkspaceFactory ${this._id} add ${l}`);
        this._map.set(l, s);
        this._onWorkspaceCreated(s);
        return s;
      }
      _remove(e) {
        const t = this._getWorkspaceKey(e);
        const n = this._map.get(t);
        if (n) {
          n.isInitialized.resolve();
          this._onWorkspaceRemoved(n);
          n.service.dispose();
          this._console.log(`WorkspaceFactory ${this._id} remove ${t}`);
          this._map.delete(t);
        }
      }
      _getDefaultWorkspaceKey() {
        return this._defaultWorkspacePath;
      }
      _getWorkspaceKey(e) {
        if (e.kinds.includes(i.Default)) {
          return this._getDefaultWorkspaceKey();
        } else {
          return `${e.rootUri}`;
        }
      }
      async _getOrCreateBestWorkspaceForFile(e) {
        const t = this._getBestWorkspaceForFile(e);
        await t.isInitialized.promise;
        return t;
      }
      _getBestWorkspaceForFile(e) {
        let t;
        const n = this.items().filter(t => t.service.isTracked(e)).filter(p);
        t = this._getBestRegularWorkspace(n);
        const a = this.getNonDefaultWorkspaces(i.Regular);
        if (t === undefined && a.every(t => t.rootUri.scheme === a[0].rootUri.scheme && (t.rootUri.scheme === e.scheme || e.isUntitled()) && t.rootUri.equals(a[0].rootUri))) {
          t = this._getBestRegularWorkspace(a);
        }
        if (t === undefined) {
          t = this._getBestRegularWorkspace(a.filter(t => t.service.hasSourceFile(e) && t.rootUri.scheme === e.scheme)) || t;
        }
        if (t === undefined) {
          t = this._getOrCreateDefaultWorkspace();
        }
        return t;
      }
      _getOrCreateDefaultWorkspace() {
        let e = this._map.get(this._getDefaultWorkspaceKey());
        if (!e) {
          e = this._add(undefined, this._defaultWorkspacePath, [i.Default]);
        }
        return e;
      }
      _getLongestPathWorkspace(e) {
        const t = e.reduce((e, t) => e ? t.rootUri.getPathLength() > e.getPathLength() ? t.rootUri : e : t.rootUri, r.Uri.empty());
        return e.find(e => e.rootUri.equals(t));
      }
      _getBestRegularWorkspace(e) {
        if (e.length !== 0) {
          if (e.length === 1) {
            return e[0];
          } else {
            return this._getLongestPathWorkspace(e);
          }
        }
      }
    };
  },
  73068: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Vytvořit zástupnou proceduru (Stub) typu',
        createTypeStubFor: 'Vytvořit zástupnou proceduru typu (Stub) pro modul {moduleName}',
        executingCommand: 'Spouští se příkaz',
        filesToAnalyzeCount: 'Počet souborů k analýze: {count}',
        filesToAnalyzeOne: '1 soubor k analýze',
        findingReferences: 'Hledají se odkazy',
        organizeImports: 'Uspořádat direktivy Import',
        renameShadowedFile: 'Přejmenovat „{oldFile}“ na „{newFile}“'
      },
      Completion: {
        autoImportDetail: 'Automatický import',
        indexValueDetail: 'Hodnota indexu'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Metodu „{method}“ nelze volat, protože je abstraktní a neimplementovaná.',
        annotatedMetadataInconsistent: 'Typ metadat s poznámkami „{metadataType}“ není kompatibilní s typem „{type}“.',
        annotatedParamCountMismatch: 'Počet poznámek parametrů se neshoduje: očekával(o/y) se {expected}, ale přijal(o/y) se {received}.',
        annotatedTypeArgMissing: 'Byl očekáván jeden argument typu a jedna nebo více poznámek pro Annotated',
        annotationBytesString: 'Výrazy typu nemůžou používat řetězcové literály bajtů.',
        annotationFormatString: 'Výrazy typu nemůžou používat formátovací řetězcové literály (f-strings).',
        annotationNotSupported: 'Poznámka typu není pro tento příkaz podporována',
        annotationRawString: 'Výrazy typu nemůžou používat literály nezpracovaného řetězce.',
        annotationSpansStrings: 'Výrazy typu nemůžou zahrnovat více řetězcových literálů.',
        annotationStringEscape: 'Výrazy typu nemůžou obsahovat řídicí znaky.',
        argAssignment: 'Argument typu {argType} není možné přiřadit k parametru typu {paramType}',
        argAssignmentFunction: 'Argument typu {argType} není možné přiřadit k parametru typu {paramType} ve funkci {functionName}',
        argAssignmentParam: 'Argument typu {argType} není možné přiřadit k parametru {paramName} typu {paramType}',
        argAssignmentParamFunction: 'Argument typu {argType} není možné přiřadit k parametru {paramName} typu {paramType} ve funkci {functionName}',
        argMissingForParam: 'Chybí argument pro parametr {name}',
        argMissingForParams: 'Chybí argumenty pro parametry {names}',
        argMorePositionalExpectedCount: 'Očekával se tento počet dalších pozičních argumentů: {expected}',
        argMorePositionalExpectedOne: 'Očekával se 1 další poziční argument',
        argPositional: 'Očekávaný poziční argument',
        argPositionalExpectedCount: 'Očekávaný počet pozičních argumentů: {expected}',
        argPositionalExpectedOne: 'Očekával se 1 poziční argument',
        argTypePartiallyUnknown: 'Typ argumentu je částečně neznámý',
        argTypeUnknown: 'Typ argumentu je neznámý',
        assertAlwaysTrue: 'Výraz Assert se vždy vyhodnotí jako true',
        assertTypeArgs: 'assert_type očekává dva poziční argumenty',
        assertTypeTypeMismatch: 'Neshoda assert_type: očekávalo se {expected}, ale přijalo se {received}',
        assignmentExprComprehension: 'Cíl výrazu přiřazení „{name}“ nemůže používat stejný název jako porozumění cíli',
        assignmentExprContext: 'Výraz přiřazení musí být uvnitř modulu, funkce nebo výrazu lambda',
        assignmentExprInSubscript: 'Výrazy přiřazení v dolním indexu se podporují jenom v Pythonu 3.10 a novějším',
        assignmentInProtocol: 'Proměnné instance nebo třídy v rámci třídy Protocol musí být explicitně deklarovány v těle třídy',
        assignmentTargetExpr: 'Výraz nemůže být cílem přiřazení',
        asyncNotInAsyncFunction: 'Použití „async“ není povolené mimo funkci async',
        awaitIllegal: 'Použití operátoru await vyžaduje Python 3.5 nebo novější',
        awaitNotAllowed: 'Výrazy typu nemůžou používat výraz await.',
        awaitNotInAsync: 'Operátor await je povolený jenom v rámci asynchronní funkce',
        backticksIllegal: 'V Pythonu 3.x nejsou podporovány výrazy obklopené zpětnými tečkami; místo toho použijte repr',
        baseClassCircular: 'Třída se nemůže odvozovat od sebe sama',
        baseClassFinal: 'Základní třída {type} je označená jako final a nemůže být podtřídou',
        baseClassIncompatible: 'Základní třídy typu {type} jsou vzájemně nekompatibilní',
        baseClassInvalid: 'Argument třídy musí být základní třída',
        baseClassMethodTypeIncompatible: 'Základní třídy pro třídu {classType} definují metodu {name} nekompatibilním způsobem',
        baseClassUnknown: 'Typ základní třídy je neznámý, co zakrývá typ odvozené třídy',
        baseClassVariableTypeIncompatible: 'Základní třídy pro třídu {classType} definují proměnnou {name} nekompatibilním způsobem',
        binaryOperationNotAllowed: 'Ve výrazu typu není povolený binární operátor.',
        bindTypeMismatch: 'Nepovedlo se vytvořit vazbu metody „{methodName}“, protože „{type}“ nejde přiřadit k parametru „{paramName}“',
        breakInExceptionGroup: 'V bloku except* není povolená možnost break.',
        breakOutsideLoop: '„break“ se dá použít jenom ve smyčce',
        callableExtraArgs: 'Pro Callable se očekávaly pouze dva argumenty typu',
        callableFirstArg: 'Očekával se seznam typů parametrů nebo ...',
        callableNotInstantiable: 'Není možné vytvořit instanci typu {type}',
        callableSecondArg: 'Očekával se návratový typ jako druhý argument typu pro Callable',
        casePatternIsIrrefutable: 'Nevyvratitelný vzorec je povolený jenom pro poslední výraz velikosti písmen',
        classAlreadySpecialized: 'Typ {type} je už specializovaný',
        classDecoratorTypeUnknown: 'Dekoratér netypové třídy překrývá typ třídy. dekoratér se ignoruje',
        classDefinitionCycle: 'Definice třídy pro „{name}“ závisí sama na sobě',
        classGetItemClsParam: 'Přepsání __class_getitem__ by mělo mít parametr cls',
        classMethodClsParam: 'Metody třídy by měly mít parametr „cls“',
        classNotRuntimeSubscriptable: 'Dolní index pro třídu {name} vygeneruje výjimku modulu runtime; výraz typu uzavřete do uvozovek.',
        classPatternBuiltInArgPositional: 'Vzor třídy přijímá pouze poziční dílčí vzor',
        classPatternPositionalArgCount: 'Příliš mnoho pozičních vzorů pro třídu "{type}"; očekávalo se {expected}, ale přijalo se {received}',
        classPatternTypeAlias: 'Typ „{type}“ nelze použít ve vzorci třídy, protože se jedná o specializovaný alias typu',
        classPropertyDeprecated: 'Vlastnosti třídy jsou v Pythonu 3.11 zastaralé a v Pythonu 3.13 se nebudou podporovat.',
        classTypeParametersIllegal: 'Syntaxe parametru typu třídy vyžaduje Python 312 nebo novější',
        classVarFirstArgMissing: 'Za ClassVar byl očekáván argument typu',
        classVarNotAllowed: 'ClassVar se v tomto kontextu nepovoluje',
        classVarOverridesInstanceVar: 'Proměnná třídy {name} přepíše proměnnou instance se stejným názvem ve třídě {className}',
        classVarTooManyArgs: 'Za „ClassVar“ byl očekáván pouze jeden argument typu',
        classVarWithTypeVar: 'Typ ClassVar nemůže obsahovat proměnné typu',
        clsSelfParamTypeMismatch: 'Typ parametru „{name}“ musí být nadtyp třídy „{classType}“',
        codeTooComplexToAnalyze: 'Kód je příliš složitý na analýzu; snižte složitost refaktorizací do podprogramů nebo redukcí podmíněných cest kódu',
        collectionAliasInstantiation: 'Nelze vytvořit instanci typu „{type}“. Použijte místo toho „{alias}“',
        comparisonAlwaysFalse: 'Podmínka se vždy vyhodnotí jako False, protože typy {leftType} a {rightType} se nepřekrývají',
        comparisonAlwaysTrue: 'Podmínka se vždy vyhodnotí jako True, protože typy {leftType} a {rightType} se nepřekrývají',
        comprehensionInDict: 'Porozumění není možné použít s jinými položkami slovníku',
        comprehensionInSet: 'Porozumění nelze použít s jinými položkami sady (set).',
        concatenateContext: 'Možnost „Concatenate“ není v tomto kontextu povolená.',
        concatenateParamSpecMissing: 'Poslední argument typu pro „Concatenate“ musí být „ParamSpec“ nebo „...“',
        concatenateTypeArgsMissing: 'Možnost „Concatenate“ vyžaduje alespoň dva argumenty typu',
        conditionalOperandInvalid: 'Neplatný podmíněný operand typu {type}',
        constantRedefinition: '„{name}“ je konstanta (protože je velkými písmeny) a nedá se předefinovat',
        constructorParametersMismatch: 'Neshoda mezi signaturou __new__ a __init__ ve třídě“ {classType}“',
        containmentAlwaysFalse: 'Výraz se vždy vyhodnotí jako False, protože typy „{leftType}“ a „{rightType}“ se nepřekrývají',
        containmentAlwaysTrue: 'Výraz se vždy vyhodnotí jako True, protože typy „{leftType}“ a „{rightType}“ se nepřekrývají.',
        continueInExceptionGroup: 'V bloku except* není povolená možnost continue.',
        continueOutsideLoop: 'continue se dá použít jenom ve smyčce',
        coroutineInConditionalExpression: 'Podmíněný výraz odkazuje na korutinu, která se vždy vyhodnotí jako True.',
        dataClassBaseClassFrozen: 'Nezablokovaná třída nemůže dědit z zmrazené třídy',
        dataClassBaseClassNotFrozen: 'Zablokovaná třída nemůže dědit z třídy, která není zablokovaná',
        dataClassConverterFunction: 'Argument typu {argType} není platný převaděč pro pole {fieldName} typu {fieldType}',
        dataClassConverterOverloads: 'Žádná přetížení {funcName} nejsou platné převaděče pro pole {fieldName} typu {fieldType}',
        dataClassFieldInheritedDefault: '{fieldName} přepíše pole se stejným názvem, ale chybí mu výchozí hodnota.',
        dataClassFieldWithDefault: 'Pole bez výchozích hodnot se nemůžou zobrazit po polích s výchozími hodnotami',
        dataClassFieldWithPrivateName: 'Pole datové třídy nemůže používat privátní název',
        dataClassFieldWithoutAnnotation: 'Pole dataclass bez poznámky typu způsobí výjimku modulu runtime',
        dataClassPostInitParamCount: 'Datová třída __post_init__ má nesprávný počet parametrů; počet polí InitVar je {expected}',
        dataClassPostInitType: 'Neshoda typu parametru metody __post_init__ datové třídy pro pole {fieldName}',
        dataClassSlotsOverwrite: '__slots__ je už ve třídě definovaný',
        dataClassTransformExpectedBoolLiteral: 'Očekával se výraz, který se staticky vyhodnotí jako True nebo False',
        dataClassTransformFieldSpecifier: 'Očekávala se řazená kolekce členů (tuple) tříd nebo funkcí, ale byl přijat typ „{type}“.',
        dataClassTransformPositionalParam: 'Všechny argumenty dataclass_transform musí být argumenty klíčových slov',
        dataClassTransformUnknownArgument: 'Argument {name} není v dataclass_transform podporován',
        dataProtocolInSubclassCheck: 'Datové protokoly (které zahrnují atributy bez metody) nejsou ve voláních issubclass povolené.',
        declaredReturnTypePartiallyUnknown: 'Deklarovaný návratový typ {returnType} je částečně neznámý',
        declaredReturnTypeUnknown: 'Deklarovaný návratový typ je neznámý',
        defaultValueContainsCall: 'Volání funkcí a měnitelné objekty nejsou povoleny ve výrazu výchozí hodnoty parametru',
        defaultValueNotAllowed: 'Parametr s * nebo ** nemůže mít výchozí hodnotu',
        delTargetExpr: 'Výraz se nedá odstranit',
        deprecatedClass: 'Třída {name} je zastaralá',
        deprecatedConstructor: 'Konstruktor pro třídu {name} je zastaralý',
        deprecatedDescriptorDeleter: 'Metoda „__delete__“ pro popisovač „{name}“ je zastaralá',
        deprecatedDescriptorGetter: 'Metoda „__get__“ pro popisovač „{name}“ je zastaralá',
        deprecatedDescriptorSetter: 'Metoda „__set__“ pro popisovač „{name}“ je zastaralá',
        deprecatedFunction: 'Funkce {name} je zastaralá.',
        deprecatedMethod: 'Metoda {name} ve třídě {className} je zastaralá.',
        deprecatedPropertyDeleter: 'Metoda deleter pro property „{name}“ je zastaralá.',
        deprecatedPropertyGetter: 'Metoda getter pro property „{name}“ je zastaralá.',
        deprecatedPropertySetter: 'Metoda setter pro property „{name}“ je zastaralá.',
        deprecatedType: 'Tento typ je zastaralý jako Python {version}; místo toho použijte {replacement}',
        dictExpandIllegalInComprehension: 'Rozšíření slovníku není v porozumění povoleno',
        dictInAnnotation: 'Výraz slovníku není ve výrazu typu povolený.',
        dictKeyValuePairs: 'Položky slovníku musí obsahovat páry klíč/hodnota',
        dictUnpackIsNotMapping: 'Očekávalo se mapování pro operátor rozbalení slovníku',
        dunderAllSymbolNotPresent: '{name} je zadáno v __all__, ale v modulu se nenachází',
        duplicateArgsParam: 'Je povolený jenom jeden parametr *',
        duplicateBaseClass: 'Duplicitní základní třída není povolena',
        duplicateCapturePatternTarget: 'Cíl zachytávání {name} se v rámci stejného vzoru nemůže vyskytovat více než jednou',
        duplicateCatchAll: 'Je povolena pouze jedna klauzule catch-all except',
        duplicateEnumMember: 'Člen Enum {name} je už deklarovaný.',
        duplicateGenericAndProtocolBase: 'Je povolena pouze jedna základní třída Generic[...] nebo Protocol[...].',
        duplicateImport: 'Import {importName} je importován více než jednou',
        duplicateKeywordOnly: 'Je povolený jenom jeden oddělovač *',
        duplicateKwargsParam: 'Je povolený jenom jeden parametr **',
        duplicateParam: 'duplicitní parametr {name}',
        duplicatePositionOnly: 'Je povolený jenom jeden parametr „/“',
        duplicateStarPattern: 'V sekvenci vzorů je povolený jenom jeden vzor „*“',
        duplicateStarStarPattern: 'Je povolena pouze jedna položka „**“',
        duplicateUnpack: 'V seznamu (list) je povolena pouze jedna operace rozbalení.',
        ellipsisAfterUnpacked: '„…“ nelze použít s rozbalenou kolekcí TypeVarTuple nebo tuple.',
        ellipsisContext: '„...“ se v tomto kontextu nepovoluje',
        ellipsisSecondArg: '„...“ je povoleno pouze jako druhý ze dvou argumentů',
        enumClassOverride: 'Třída Enum {name} je final a nemůže být podtřídou.',
        enumMemberDelete: 'Člen Enum {name} se nedá odstranit.',
        enumMemberSet: 'Člen Enum {name} se nedá přiřadit.',
        enumMemberTypeAnnotation: 'Poznámky typu nejsou pro členy enum povolené.',
        exceptGroupMismatch: 'Příkaz Try nemůže obsahovat jak except, tak i except*.',
        exceptGroupRequiresType: 'Syntaxe skupiny výjimek ("except*") vyžaduje typ výjimky.',
        exceptionGroupIncompatible: 'Syntaxe skupiny výjimek ("except*") vyžaduje Python 3.11 nebo novější',
        exceptionGroupTypeIncorrect: 'Typ výjimky v except* se nedá odvodit z BaseGroupException.',
        exceptionTypeIncorrect: '„{type}“ se neodvozuje od BaseException',
        exceptionTypeNotClass: '{type} není platná třída výjimky',
        exceptionTypeNotInstantiable: 'Konstruktor pro výjimku typu {type} vyžaduje jeden nebo více argumentů',
        expectedAfterDecorator: 'Očekávaná deklarace funkce nebo třídy po dekoratéru',
        expectedArrow: 'Byl očekáván znak -> následovaný anotací návratového typu',
        expectedAsAfterException: 'Za typem výjimky byl očekáván znak „as“',
        expectedAssignRightHandExpr: 'Byl očekáván výraz napravo od znaku =',
        expectedBinaryRightHandExpr: 'Očekával se výraz napravo od operátoru',
        expectedBoolLiteral: 'Očekávala se hodnota True nebo False',
        expectedCase: 'Očekával se příkaz case',
        expectedClassName: 'Očekával se název třídy',
        expectedCloseBrace: '{ nebyla uzavřena',
        expectedCloseBracket: '[ nebyla uzavřena',
        expectedCloseParen: '( nebyla uzavřena',
        expectedColon: 'Očekával se znak :',
        expectedComplexNumberLiteral: 'Očekával se komplexní číselný literál pro porovnávání vzorů',
        expectedDecoratorExpr: 'Forma výrazu není podporována pro dekorátor před verzí Python 3.9',
        expectedDecoratorName: 'Očekával se název dekoratéru',
        expectedDecoratorNewline: 'Na konci dekoratéru byl očekáván nový řádek',
        expectedDelExpr: 'Za del se očekával výraz',
        expectedElse: 'Očekávalo se else',
        expectedEquals: 'Očekával se znak =',
        expectedExceptionClass: 'Neplatná třída nebo objekt výjimky',
        expectedExceptionObj: 'Byl očekáván objekt výjimky, třída výjimky nebo None',
        expectedExpr: 'Očekávaný výraz',
        expectedFunctionAfterAsync: 'Očekávaná definice funkce po „async“',
        expectedFunctionName: 'Za def se očekával název funkce',
        expectedIdentifier: 'Očekávaný identifikátor',
        expectedImport: 'Očekával se import',
        expectedImportAlias: 'Za as byl očekáván symbol',
        expectedImportSymbols: 'Po možnosti import se očekával jeden nebo více názvů symbolů.',
        expectedIn: 'Očekávalo se in',
        expectedInExpr: 'Za in byl očekáván výraz',
        expectedIndentedBlock: 'Očekával se odsazený blok',
        expectedMemberName: 'Za tečkou (.) byl očekáván název atributu.',
        expectedModuleName: 'Očekávaný název modulu',
        expectedNameAfterAs: 'Za „as“ se očekával název symbolu',
        expectedNamedParameter: 'Parametr klíčového slova musí následovat za znakem *',
        expectedNewline: 'Očekával se nový řádek',
        expectedNewlineOrSemicolon: 'Příkazy musí být oddělené novými řádky nebo středníky',
        expectedOpenParen: 'Očekával se znak „(“',
        expectedParamName: 'Očekával se název parametru',
        expectedPatternExpr: 'Očekávaný výraz vzoru',
        expectedPatternSubjectExpr: 'Očekávaný výraz předmětu vzoru',
        expectedPatternValue: 'Očekávaný výraz hodnoty vzoru ve formátu a.b',
        expectedReturnExpr: 'Za return se očekával výraz',
        expectedSliceIndex: 'Očekávaný výraz indexu nebo řezu',
        expectedTypeNotString: 'Očekával se typ, ale přijal se řetězcový literál',
        expectedTypeParameterName: 'Očekávaný název parametru typu',
        expectedYieldExpr: 'Očekávaný výraz v příkazu yield',
        finalClassIsAbstract: 'Třída „{type}“ je označena jako final a musí implementovat všechny abstraktní symboly.',
        finalContext: 'Final se v tomto kontextu nepovoluje',
        finalInLoop: 'Proměnnou Final nelze přiřadit ve smyčce.',
        finalMethodOverride: 'Metoda {name} nemůže přepsat metodu final definovanou ve třídě {className}.',
        finalNonMethod: 'Funkci „{name}“ nelze označit @final, protože se nejedná o metodu.',
        finalReassigned: '„{name}“ se deklaruje jako Final a nedá se znovu přiřadit',
        finalRedeclaration: '{name} se dříve deklarovalo jako Final',
        finalRedeclarationBySubclass: '{name} se nedá deklarovat znovu, protože nadřazená třída {className} ji deklaruje jako Final.',
        finalTooManyArgs: 'Za Final byl očekáván jeden argument typu',
        finalUnassigned: '{name} se deklaruje jako Final, ale hodnota není přiřazená.',
        formatStringBrace: 'Jednoduchá pravá složená závorka není v literálu f-string povolena. použijte dvojitou pravou složenou závorku',
        formatStringBytes: 'Formátovací řetězcové literály (f-strings) nemůžou být binární',
        formatStringDebuggingIllegal: 'Specifikátor ladění F-string „=“ vyžaduje Python 3.8 nebo novější',
        formatStringEscape: 'Řídicí sekvence (zpětné lomítko) není povolená v části výrazu f-string před Python 3.12',
        formatStringExpectedConversion: 'V řetězci f-string byl za znakem ! očekáván specifikátor převodu',
        formatStringIllegal: 'Formátovací řetězcové literály (f-string) vyžadují Python 3.6 nebo novější',
        formatStringInPattern: 'Formátovací řetězec není ve vzoru povolený',
        formatStringNestedFormatSpecifier: 'Příliš hluboko vnořené výrazy v rámci specifikátoru formátovacího řetězce',
        formatStringNestedQuote: 'Řetězce vnořené v řetězci f-string nemůžou používat stejný znak uvozovek jako řetězec f-string před Python 3.12',
        formatStringUnicode: 'Formátovací řetězcové literály (f-strings) nemůžou být unicode',
        formatStringUnterminated: 'Neukončený výraz v f-string; očekává se „}“',
        functionDecoratorTypeUnknown: 'Dekorátor netypové funkce překrývá typ funkce; ignoruje se dekoratér',
        functionInConditionalExpression: 'Podmíněný výraz odkazuje na funkci, která se vždy vyhodnotí jako True',
        functionTypeParametersIllegal: 'Syntaxe parametru typu funkce vyžaduje Python 3.12 nebo novější',
        futureImportLocationNotAllowed: 'Importy z __future__ musí být na začátku souboru',
        generatorAsyncReturnType: 'Návratový typ funkce asynchronního generátoru musí být kompatibilní s typem AsyncGenerator[{yieldType}, Any]',
        generatorNotParenthesized: 'Výrazy generátoru musí být v závorkách, pokud nejsou jediným argumentem',
        generatorSyncReturnType: 'Návratový typ funkce generátoru musí být kompatibilní s Generator[{yieldType}, Any, Any]',
        genericBaseClassNotAllowed: 'Základní třídu „Generic“ nejde použít se syntaxí parametru typu',
        genericClassAssigned: 'Obecný typ třídy není možné přiřadit',
        genericClassDeleted: 'Obecný typ třídy nelze odstranit',
        genericInstanceVariableAccess: 'Přístup k obecné proměnné instance prostřednictvím třídy je nejednoznačný.',
        genericNotAllowed: 'Generic není v tomto kontextu platný',
        genericTypeAliasBoundTypeVar: 'Alias obecného typu v rámci třídy nemůže používat proměnné vázaného typu {names}',
        genericTypeArgMissing: 'Generic vyžaduje alespoň jeden argument typu',
        genericTypeArgTypeVar: 'Argument typu pro Generic musí být proměnná typu',
        genericTypeArgUnique: 'Argumenty typu pro Generic musí být jedinečné',
        globalReassignment: '{name} je přiřazen před deklarací global.',
        globalRedefinition: 'Název {name} už je deklarován jako global.',
        implicitStringConcat: 'Implicitní zřetězení řetězců není povolené',
        importCycleDetected: 'V řetězci importu byl zjištěn cyklus',
        importDepthExceeded: 'Hloubka řetězu importu překročila {depth}',
        importResolveFailure: 'Import {importName} se nepovedlo vyřešit',
        importSourceResolveFailure: 'Import {importName} se nepovedlo přeložit ze zdroje',
        importSymbolUnknown: '{name} je neznámý symbol importu',
        incompatibleMethodOverride: 'Metoda {name} přepisuje třídu {className} nekompatibilním způsobem',
        inconsistentIndent: 'Množství zrušeného odsazení neodpovídá předchozímu odsazení',
        inconsistentTabs: 'Nekonzistentní použití tabulátorů a mezer v odsazení',
        initMethodSelfParamTypeVar: 'Anotace typu pro parametr self metody __init__ nemůže obsahovat proměnné typu s oborem třídy.',
        initMustReturnNone: 'Návratový typ __init__ musí být None',
        initSubclassCallFailed: 'Nesprávné argumenty klíčového slova pro metodu __init_subclass__',
        initSubclassClsParam: 'Přepsání __init_subclass__ by mělo mít parametr cls',
        initVarNotAllowed: 'InitVar se v tomto kontextu nepovoluje.',
        instanceMethodSelfParam: 'Metody instance by měly mít parametr self',
        instanceVarOverridesClassVar: 'Proměnná instance „{name}“ přepíše proměnnou třídy se stejným názvem ve třídě „{className}“',
        instantiateAbstract: 'Nelze vytvořit instanci abstraktní třídy „{type}“',
        instantiateProtocol: 'Nelze vytvořit instanci třídy Protocol „{type}“.',
        internalBindError: 'Při vytváření vazby souboru {file} došlo k vnitřní chybě: {message}',
        internalParseError: 'Při analýze souboru {file} došlo k vnitřní chybě: {message}',
        internalTypeCheckingError: 'Při kontrole typu souboru {file} došlo k vnitřní chybě: {message}',
        invalidIdentifierChar: 'Neplatný znak v identifikátoru',
        invalidStubStatement: 'Příkaz je v souboru zástupné procedury (stub) typu bezvýznamný.',
        invalidTokenChars: 'Neplatný znak „{text}“ v tokenu',
        isInstanceInvalidType: 'Druhý argument pro „isinstance“ musí být třída nebo řazená kolekce členů (tuple) tříd.',
        isSubclassInvalidType: 'Druhý argument pro issubclass musí být třída nebo řazená kolekce členů (tuple) tříd.',
        keyValueInSet: 'Páry klíč-hodnota nejsou v rámci sady (set) povoleny.',
        keywordArgInTypeArgument: 'Argumenty klíčových slov nelze použít v seznamech argumentů typu',
        keywordArgShortcutIllegal: 'Zástupce argumentu klíčového slova vyžaduje Python 3.14 nebo novější.',
        keywordOnlyAfterArgs: 'Oddělovač argumentů jen pro klíčová slova není povolený za parametrem *',
        keywordParameterMissing: 'Jeden nebo více parametrů klíčového slova musí následovat za parametrem „*“',
        keywordSubscriptIllegal: 'Argumenty klíčových slov v dolních indexech nejsou podporovány',
        lambdaReturnTypePartiallyUnknown: 'Návratový typ lambda {returnType} je částečně neznámý',
        lambdaReturnTypeUnknown: 'Návratový typ výrazu lambda je neznámý',
        listAssignmentMismatch: 'Výraz s typem {type} se nedá přiřadit k cílovému seznamu',
        listInAnnotation: 'Výraz List není ve výrazu typu povolený.',
        literalEmptyArgs: 'Za literálem (Literal) se očekával jeden nebo více argumentů typu.',
        literalNamedUnicodeEscape: 'Pojmenované řídicí sekvence Unicode nejsou v poznámkách řetězců Literal podporovány.',
        literalNotAllowed: '„Literal“ nejde v tomto kontextu použít bez argumentu typu.',
        literalNotCallable: 'Není možné vytvořit instanci typu Literal.',
        literalUnsupportedType: 'Argumenty typu pro Literal musí být None, hodnota literálu (int, bool, str nebo bytes) nebo hodnota enum.',
        matchIncompatible: 'Příkazy match vyžadují Python 3.10 nebo novější',
        matchIsNotExhaustive: 'Případy v rámci příkazu match nezpracovávají kompletně všechny hodnoty',
        maxParseDepthExceeded: 'Byla překročena maximální hloubka analýzy; rozdělte výraz na dílčí výrazy',
        memberAccess: 'Nelze získat přístup k atributu {name} pro třídu {type}.',
        memberDelete: 'Nelze odstranit atribut {name} pro třídu {type}.',
        memberSet: 'Nelze přiřadit k atributu {name} pro třídu {type}.',
        metaclassConflict: 'Metatřída odvozené třídy musí být podtřídou metatříd všech jejích základních tříd',
        metaclassDuplicate: 'Je možné zadat pouze jednu metatřídu',
        metaclassIsGeneric: 'Metatřída nemůže být obecná',
        methodNotDefined: 'Metoda {name} není definována',
        methodNotDefinedOnType: 'Metoda {name} není u typu {type} definována',
        methodOrdering: 'Není možné vytvořit konzistentní řazení metod',
        methodOverridden: '„{name}“ přepisuje metodu se stejným názvem ve třídě „{className}“ s nekompatibilním typem {type}',
        methodReturnsNonObject: 'Metoda {name} nevrací objekt',
        missingSuperCall: 'Metoda {methodName} nevolá metodu se stejným názvem v nadřazené třídě',
        mixingBytesAndStr: 'Hodnoty bytes a str nelze zřetězit.',
        moduleAsType: 'Modul nejde použít jako typ',
        moduleNotCallable: 'Modul není volatelný',
        moduleUnknownMember: '{memberName} není známý atribut modulu {moduleName}.',
        namedExceptAfterCatchAll: 'Za klauzulí catch-all except se nemůže objevit pojmenovaná klauzule except',
        namedParamAfterParamSpecArgs: 'Parametr klíčového slova {name} se nemůže objevit v signatuře za parametrem ParamSpec args.',
        namedTupleEmptyName: 'Názvy v pojmenované řazené kolekci členů (tuple) nemůžou být prázdné.',
        namedTupleEntryRedeclared: '{name} nejde přepsat, protože nadřazená třída {className} je pojmenovaná řazená kolekce členů (tuple).',
        namedTupleFirstArg: 'Jako první argument byl očekáván název pojmenované třídy řazené kolekce členů (tuple).',
        namedTupleMultipleInheritance: 'Vícenásobná dědičnost s NamedTuple se nepodporuje',
        namedTupleNameKeyword: 'Názvy polí nemůžou být klíčové slovo.',
        namedTupleNameType: 'Očekávala se řazená kolekce členů (tuple) se dvěma položkami určující název a typ položky.',
        namedTupleNameUnique: 'Názvy v pojmenované řazené kolekci členů (tuple) musí být jedinečné.',
        namedTupleNoTypes: 'namedtuple neposkytuje žádné typy pro položky řazené kolekce členů; místo toho použijte NamedTuple',
        namedTupleSecondArg: 'Jako druhý argument byl očekáván pojmenovaný seznam (list) řazené kolekce členů (tuple).',
        newClsParam: 'Přepsání __new__ by mělo mít parametr cls',
        newTypeAnyOrUnknown: 'Druhý argument pro NewType musí být známá třída, nikoli Any nebo Unknown.',
        newTypeBadName: 'Prvním argumentem pro NewType musí být řetězcový literál',
        newTypeLiteral: 'Typ NewType není možné použít s typem Literal',
        newTypeNameMismatch: 'Typ NewType musí být přiřazen proměnné se stejným názvem.',
        newTypeNotAClass: 'Očekávaná třída jako druhý argument pro NewType',
        newTypeParamCount: 'NewType vyžaduje dva poziční argumenty',
        newTypeProtocolClass: 'NewType nelze použít se strukturálním typem (třída Protocol nebo TypedDict).',
        noOverload: 'Zadaným argumentům neodpovídají žádná přetížení pro {name}',
        noReturnContainsReturn: 'Funkce s deklarovaným návratovým typem return type NoReturn nemůže obsahovat příkaz return.',
        noReturnContainsYield: 'Funkce s deklarovaným návratovým typem NoReturn nemůže obsahovat příkaz yield',
        noReturnReturnsNone: 'Funkce s deklarovaným návratovým typem „NoReturn“ nemůže vrátit „None“.',
        nonDefaultAfterDefault: 'Nevýchozí argument následuje za výchozím argumentem',
        nonLocalInModule: 'Deklarace Nonlocal není povolená na úrovni modulu.',
        nonLocalNoBinding: 'Nenašla se žádná vazba pro nonlocal {name}.',
        nonLocalReassignment: '{name} je přiřazeno před deklarací nonlocal.',
        nonLocalRedefinition: '{name} již bylo deklarováno jako nonlocal.',
        noneNotCallable: 'Objekt typu „None“ nelze volat.',
        noneNotIterable: 'Objekt typu None není možné použít jako iterovatelnou hodnotu',
        noneNotSubscriptable: 'Objekt typu “None“ nelze zadat jako dolní index',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Operátor {operator} se pro None nepodporuje',
        noneUnknownMember: '{name} není známý atribut None.',
        notRequiredArgCount: 'Za NotRequired byl očekáván jeden argument typu',
        notRequiredNotInTypedDict: 'NotRequired není v tomto kontextu povolené',
        objectNotCallable: 'Objekt typu {type} není možné volat',
        obscuredClassDeclaration: 'Deklarace třídy {name} je zakrytá deklarací stejného jména',
        obscuredFunctionDeclaration: 'Deklarace funkce {name} je zakrytá deklarací stejného názvu',
        obscuredMethodDeclaration: 'Deklarace metody {name} je zakrytá deklarací stejného názvu',
        obscuredParameterDeclaration: 'Deklarace parametru {name} je zakrytá deklarací stejného názvu',
        obscuredTypeAliasDeclaration: 'Deklarace aliasu typu {name} je zakrytá deklarací stejného názvu',
        obscuredVariableDeclaration: 'Deklarace {name} je zakrytá deklarací stejného názvu',
        operatorLessOrGreaterDeprecated: 'Operátor <> se v Pythonu 3 nepodporuje; místo toho použijte !=',
        optionalExtraArgs: 'Za nepovinnou hodnotou (Optional) se očekával jeden argument typu.',
        orPatternIrrefutable: 'Nevratný vzor je povolený jenom jako poslední dílčí vzorec ve vzorci „or“',
        orPatternMissingName: 'Všechny dílčí vzory v rámci vzoru or musí cílit na stejné názvy',
        overlappingKeywordArgs: 'Slovník silného typu se překrývá s parametrem klíčového slova: {names}',
        overlappingOverload: 'Přetížení {obscured} pro {name} se nikdy nepoužije, protože jeho parametry se překrývají s přetížením {obscuredBy}',
        overloadAbstractImplMismatch: 'Přetížení musí odpovídat abstraktnímu stavu implementace.',
        overloadAbstractMismatch: 'Buď musí být všechna přetížení abstraktní, nebo naopak nesmí být žádné z nich abstraktní.',
        overloadClassMethodInconsistent: 'Přetížení pro {name} používají @classmethod nekonzistentně.',
        overloadFinalInconsistencyImpl: 'Přetížení pro „{name}“ je označené @final ale implementace není',
        overloadFinalInconsistencyNoImpl: 'Přetížení {index} pro „{name}“ je označené @final ale přetížení 1 není',
        overloadImplementationMismatch: 'Přetížená implementace není konzistentní se signaturou přetížení {index}',
        overloadReturnTypeMismatch: 'Přetížení {prevIndex} pro {name} se překrývá s přetížením {newIndex} a vrací nekompatibilní typ',
        overloadStaticMethodInconsistent: 'Přetížení pro {name} používají @staticmethod nekonzistentně.',
        overloadWithoutImplementation: '„{name}“ je označené jako přetížení (overload), ale není zadaná žádná implementace.',
        overriddenMethodNotFound: 'Metoda „{name}“ je označená jako přepsání (override), ale neexistuje žádná základní metoda se stejným názvem.',
        overrideDecoratorMissing: 'Metoda „{name}“ není označená jako přepsání (override), ale přepisuje metodu ve třídě „{className}“.',
        paramAfterKwargsParam: 'Parametr nemůže následovat za parametrem „**“',
        paramAlreadyAssigned: 'Parametr {name} je už přiřazený',
        paramAnnotationMissing: 'Chybí poznámka typu pro parametr „{name}“',
        paramAssignmentMismatch: 'Výraz typu „{sourceType}“ nelze přiřadit k parametru typu „{paramType}“',
        paramNameMissing: 'Žádný parametr s názvem {name}',
        paramSpecArgsKwargsDuplicate: 'Argumenty pro ParamSpec {type} již byly zadány.',
        paramSpecArgsKwargsUsage: 'Atributy args a kwargs ParamSpec se musí vyskytovat v signatuře funkce.',
        paramSpecArgsMissing: 'Chybí argumenty pro parametr ParamSpec {type}',
        paramSpecArgsUsage: 'Atribut args ParamSpec je platný jenom v případě, že se používá s parametrem *args.',
        paramSpecAssignedName: 'Parametr ParamSpec musí být přiřazen proměnné s názvem {name}',
        paramSpecContext: 'ParamSpec se v tomto kontextu nepovoluje',
        paramSpecDefaultNotTuple: 'Očekávaly se tři tečky, výraz řazené kolekce členů (tuple) nebo ParamSpec pro výchozí hodnotu ParamSpec.',
        paramSpecFirstArg: 'Očekával se název parametru ParamSpec jako první argument',
        paramSpecKwargsUsage: 'Atribut kwargs ParamSpec je platný jenom v případě, že se používá s parametrem **kwargs.',
        paramSpecNotUsedByOuterScope: 'Parametr ParamSpec {name} nemá v tomto kontextu žádný význam',
        paramSpecUnknownArg: 'Parametr ParamSpec nepodporuje více než jeden argument',
        paramSpecUnknownMember: '{name} není známý atribut ParamSpec.',
        paramSpecUnknownParam: '„{name}“ je neznámý parametr parametru ParamSpec',
        paramTypeCovariant: 'Proměnnou kovariantní typu není možné použít v typu parametru',
        paramTypePartiallyUnknown: 'Typ parametru {paramName} je částečně neznámý',
        paramTypeUnknown: 'Typ parametru {paramName} je neznámý',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Vzor se nikdy nebude shodovat s typem předmětu {type}',
        positionArgAfterNamedArg: 'Poziční argument se nemůže objevit za argumenty klíčového slova',
        positionOnlyAfterArgs: 'Oddělovač parametrů jen pro pozici není povolený za parametrem *.',
        positionOnlyAfterKeywordOnly: 'Parametr / se musí zobrazit před parametrem *',
        positionOnlyAfterNon: 'Parametr jen pro pozici není povolený za parametrem, který není jen pro pozici.',
        positionOnlyFirstParam: 'Oddělovač parametrů jen pro pozici není povolený jako první parametr.',
        positionOnlyIncompatible: 'Oddělovač parametrů jen pro pozici vyžaduje Python 3.8 nebo novější.',
        privateImportFromPyTypedModule: '{name} se neexportuje z modulu {module}',
        privateUsedOutsideOfClass: '{name} je privátní a používá se mimo třídu, ve které je deklarovaná',
        privateUsedOutsideOfModule: '{name} je privátní a používá se mimo modul, ve kterém je deklarován',
        propertyOverridden: '„{name}“ nesprávně přepíše vlastnost (property) se stejným názvem ve třídě „{className}“.',
        propertyStaticMethod: 'Statické metody nejsou povoleny pro metodu getter, setter nebo deleter vlastnosti (property).',
        protectedUsedOutsideOfClass: '„{name}“ je chráněn(ý/o/é) a používá se mimo třídu, ve které je deklarovaná',
        protocolBaseClass: 'Třída Protocol {classType} se nemůže odvozovat od třídy, která není třídou Protocol {baseType}.',
        protocolBaseClassWithTypeArgs: 'Argumenty typu nejsou u třídy Protocol povoleny při použití syntaxe parametru typu',
        protocolIllegal: 'Použití třídy Protocol vyžaduje Python 3.7 nebo novější.',
        protocolNotAllowed: '„Protocol“ nejde v tomto kontextu použít.',
        protocolTypeArgMustBeTypeParam: 'Argument typu pro „Protocol“ musí být parametr typu.',
        protocolUnsafeOverlap: 'Třída se nebezpečně překrývá s názvem „{name}“ a může vytvořit shodu při spuštění.',
        protocolVarianceContravariant: 'Proměnná typu {variable} použitá v obecné třídě Protocol {class} by měla být kontravariantní.',
        protocolVarianceCovariant: 'Proměnná typu {variable} použitá v obecné třídě Protocol {class} by měla být kovariantní.',
        protocolVarianceInvariant: 'Proměnná typu {variable} použitá v obecné třídě Protocol {class} by měla být invariantní.',
        pyrightCommentInvalidDiagnosticBoolValue: 'Za direktivou komentářů Pyright musí následovat znak =a hodnota true nebo false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Za direktivou komentářů Pyright musí následovat = a hodnota true, false, error, warning, information nebo none',
        pyrightCommentMissingDirective: 'Za komentářem Pyright musí následovat direktiva (basic nebo strict) nebo diagnostické pravidlo.',
        pyrightCommentNotOnOwnLine: 'Komentáře Pyright používané k řízení nastavení na úrovni souborů se musí zobrazovat na vlastním řádku',
        pyrightCommentUnknownDiagnosticRule: '{rule} je neznámé diagnostické pravidlo pro komentář pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: '{value} je neplatná hodnota pro komentář pyright; očekávalo se true, false, error, warning, information nebo none',
        pyrightCommentUnknownDirective: 'Direktiva {directive} je neznámá direktiva pro komentář pyright; očekávalo se strict nebo basic',
        readOnlyArgCount: 'Za „ReadOnly“ se očekával jeden argument typu',
        readOnlyNotInTypedDict: 'ReadOnly není v tomto kontextu povolené',
        recursiveDefinition: 'Typ „{name}“ nelze určit, protože odkazuje sám na sebe',
        relativeImportNotAllowed: 'Relativní importy se nedají použít s formulářem „import .a“; místo toho použijte „from . import a“.',
        requiredArgCount: 'Za povinným argumentem (Required) se očekával jeden argument typu.',
        requiredNotInTypedDict: 'Required není v tomto kontextu povoleno',
        returnInAsyncGenerator: 'Příkaz Return s hodnotou není v asynchronním generátoru povolený',
        returnInExceptionGroup: 'V bloku except* není povolená možnost return.',
        returnMissing: 'Funkce s deklarovaným návratovým typem „{returnType}“ musí vracet hodnotu na všech cestách kódu',
        returnOutsideFunction: '„return“ se dá použít jenom v rámci funkce',
        returnTypeContravariant: 'Kontravariantní proměnnou typu nejde použít v návratovém typu',
        returnTypeMismatch: 'Typ {exprType} se nedá přiřadit k návratovému typu {returnType}.',
        returnTypePartiallyUnknown: 'Návratový typ {returnType} je částečně neznámý',
        returnTypeUnknown: 'Návratový typ je neznámý',
        revealLocalsArgs: 'Pro volání reveal_locals se neočekávaly žádné argumenty',
        revealLocalsNone: 'V tomto oboru nejsou žádné místní hodnoty (locals).',
        revealTypeArgs: 'Pro volání reveal_type byl očekáván jeden poziční argument',
        revealTypeExpectedTextArg: 'Argument „expected_text“ pro funkci „reveal_type“ musí být hodnota literálu str',
        revealTypeExpectedTextMismatch: 'Neshoda typu textu; očekávaný počet: {expected}, počet, který byl přijat: {received}',
        revealTypeExpectedTypeMismatch: 'Neshoda typů; Očekával(o/y) se „{expected}“, ale přijal(o/y) se „{received}“',
        selfTypeContext: 'Self není v tomto kontextu platné',
        selfTypeMetaclass: '„Self“ nelze použít v rámci metatřídy (podtřídy „type“).',
        selfTypeWithTypedSelfOrCls: 'Self není možné použít ve funkci s parametrem self nebo cls, která má jinou poznámku typu než Self',
        setterGetterTypeMismatch: 'Typ hodnoty metody setter vlastnosti (property) není možné přiřadit návratovému typu getter.',
        singleOverload: '{name} je označené jako přetížení, ale chybí další přetížení',
        slotsAttributeError: '„{name}“ není zadaný v __slots__',
        slotsClassVarConflict: '{name} je v konfliktu s proměnnou instance deklarovanou v __slots__',
        starPatternInAsPattern: 'Vzor hvězdy se nedá použít s cílem as',
        starPatternInOrPattern: 'Vzor hvězdy nemůže být ORed v jiných vzorech',
        starStarWildcardNotAllowed: '** není možné použít se zástupným znakem _',
        staticClsSelfParam: 'Statické metody by neměly přijímat parametr self nebo cls',
        stdlibModuleOverridden: '„{path}“ přepisuje modul stdlib „{name}“',
        stringNonAsciiBytes: 'Znak jiný než ASCII není povolený v bajtech řetězcového literálu',
        stringNotSubscriptable: 'Řetězcový výraz není možné ve výrazu typu zadat jako dolní index. Uzavřete celý výraz do uvozovek.',
        stringUnsupportedEscape: 'Nepodporovaná řídicí sekvence v řetězcovém literálu',
        stringUnterminated: 'Řetězcový literál je neukončený',
        stubFileMissing: 'Soubor zástupné procedury (stub) pro „{importName}“ se nenašel.',
        stubUsesGetAttr: 'Soubor zástupné procedury (stub) typu je neúplný; __getattr__ zakrývá typové chyby pro modul.',
        sublistParamsIncompatible: 'Parametry sublist nejsou v Pythonu 3.x podporované.',
        superCallArgCount: 'Pro volání „super“ se očekávaly maximálně dva argumenty',
        superCallFirstArg: 'Jako první argument pro volání super se očekával typ třídy, ale přijal se {type}',
        superCallSecondArg: 'Druhý argument volání super musí být objekt nebo třída odvozená z typu {type}',
        superCallZeroArgForm: 'Forma nulového argumentu „super“ volání je platná pouze v rámci metody.',
        superCallZeroArgFormStaticMethod: 'Forma nulového argumentu „super“ volání není platná v rámci statické metody.',
        symbolIsPossiblyUnbound: '{name} je pravděpodobně nevázané',
        symbolIsUnbound: 'Název {name} je nevázaný',
        symbolIsUndefined: '{name} není definované',
        symbolOverridden: '{name} přepíše symbol stejného názvu ve třídě {className}',
        ternaryNotAllowed: 'Výraz ternary není ve výrazu typu povolený.',
        totalOrderingMissingMethod: 'Třída musí definovat jednu z __lt__, __le__, __gt__ nebo __ge__, aby bylo možné používat total_ordering',
        trailingCommaInFromImport: 'Koncová čárka není povolena bez okolních závorek',
        tryWithoutExcept: 'Příkaz Try musí mít alespoň jednu klauzuli except nebo finally',
        tupleAssignmentMismatch: 'Výraz s typem „{type}“ se nedá přiřadit cílové řazené kolekci členů (tuple).',
        tupleInAnnotation: 'Výraz řazené kolekce členů (tuple) není ve výrazu typu povolený.',
        tupleIndexOutOfRange: 'Index {index} je pro typ {type} mimo rozsah',
        typeAliasIllegalExpressionForm: 'Neplatný formulář výrazu pro definici aliasu typu',
        typeAliasIsRecursiveDirect: 'Alias typu „{name}“ nemůže ve své definici používat sám sebe',
        typeAliasNotInModuleOrClass: 'Typ TypeAlias je možné definovat pouze v rámci oboru modulu nebo třídy',
        typeAliasRedeclared: '„{name}“ se deklaruje jako TypeAlias a dá se přiřadit jenom jednou.',
        typeAliasStatementBadScope: 'Příkaz type se dá použít jenom v rámci oboru modulu nebo třídy.',
        typeAliasStatementIllegal: 'Příkaz alias typu vyžaduje Python 3.12 nebo novější',
        typeAliasTypeBaseClass: 'Alias typu definovaný v příkazu "type" nejde použít jako základní třídu.',
        typeAliasTypeMustBeAssigned: 'Typ TypeAliasType musí být přiřazen proměnné se stejným názvem jako alias typu',
        typeAliasTypeNameArg: 'První argument TypeAliasType musí být řetězcový literál představující název aliasu typu.',
        typeAliasTypeNameMismatch: 'Název aliasu typu se musí shodovat s názvem proměnné, ke které je přiřazená',
        typeAliasTypeParamInvalid: 'Seznam parametrů typu musí být řazená kolekce členů (tuple) obsahující pouze TypeVar, TypeVarTuple nebo ParamSpec.',
        typeAnnotationCall: 'Výraz volání není ve výrazu typu povolený',
        typeAnnotationVariable: 'Proměnná není ve výrazu typu povolená',
        typeAnnotationWithCallable: 'Argument typu pro „type“ musí být třída; volatelné objekty se nepodporují.',
        typeArgListExpected: 'Očekával se parametr ParamSpec, tři tečky nebo seznam (list) typů.',
        typeArgListNotAllowed: 'Výraz seznamu (list) není pro tento argument typu povolený.',
        typeArgsExpectingNone: 'Pro třídu {name} se neočekávaly žádné argumenty typu',
        typeArgsMismatchOne: 'Očekával se jeden argument typu, ale bylo přijato {received}',
        typeArgsMissingForAlias: 'Pro alias obecného typu {name} se očekávaly argumenty typu',
        typeArgsMissingForClass: 'Očekávané argumenty typu pro obecnou třídu „{name}“',
        typeArgsTooFew: 'Pro {name} se zadalo příliš málo argumentů typu. Očekávalo se {expected}, ale přijalo se {received}',
        typeArgsTooMany: 'Pro „{name}“ se zadalo příliš mnoho argumentů typu. Očekával(o/y) se {expected}, ale přijal(o/y) se {received}',
        typeAssignmentMismatch: 'Typ {sourceType} se nedá přiřadit k deklarovanému typu {destType}.',
        typeAssignmentMismatchWildcard: 'Symbol importu {name} má typ {sourceType}, který se nedá přiřadit k deklarovanému typu {destType}.',
        typeCallNotAllowed: 'Volání type() by se nemělo používat ve výrazu typu.',
        typeCheckOnly: 'Název {name} je označený jako @type_check_only a dá se použít jenom v poznámkách typu',
        typeCommentDeprecated: 'Použití komentářů type je zastaralé místo toho použít anotaci type.',
        typeExpectedClass: 'Očekávala se třída, ale byl přijat typ {type}.',
        typeFormArgs: 'TypeForm přijímá jeden poziční argument.',
        typeGuardArgCount: 'Za TypeGuard nebo TypeIs byl očekáván jeden argument typu.',
        typeGuardParamCount: 'Funkce a metody ochrany typů definované uživatelem musí mít alespoň jeden vstupní parametr',
        typeIsReturnType: 'Návratový typ TypeIs ({returnType}) není konzistentní s typem parametru hodnoty ({type}).',
        typeNotAwaitable: '„{type}“ není awaitable.',
        typeNotIntantiable: 'Není možné vytvořit instanci {type}',
        typeNotIterable: '{type} není možné iterovat',
        typeNotSpecializable: 'Nepovedlo se specializovat typ „{type}“',
        typeNotSubscriptable: 'Objekt typu {type} není možné zadat jako dolní index',
        typeNotSupportBinaryOperator: 'Operátor „{operator}“ se pro typy „{leftType}“ a „{rightType}“ nepodporuje',
        typeNotSupportBinaryOperatorBidirectional: 'Operátor {operator} není podporován pro typy „{leftType}“ a „{rightType}“, pokud se očekává typ „{expectedType}“',
        typeNotSupportUnaryOperator: 'Operátor {operator} se pro typ {type} nepodporuje',
        typeNotSupportUnaryOperatorBidirectional: 'Operátor {operator} není podporován pro typ {type}, když očekávaný typ je {expectedType}',
        typeNotUsableWith: 'Objekt typu {type} není možné použít s typem with, protože neimplementuje metodu {method}',
        typeParameterBoundNotAllowed: 'Vazbu nebo omezení nelze použít s parametrem variadického typu ani s parametrem ParamSpec',
        typeParameterConstraintTuple: 'Omezení parametru typu musí být řazená kolekce členů dvou nebo více typů',
        typeParameterExistingTypeParameter: 'Parametr typu {name} se už používá',
        typeParameterNotDeclared: 'Parametr typu {name} není zahrnutý v seznamu parametrů typu pro kontejner {container}',
        typeParametersMissing: 'Musí být zadán alespoň jeden parametr typu',
        typePartiallyUnknown: 'Typ {name} je částečně neznámý',
        typeUnknown: 'Typ {name} je neznámý',
        typeVarAssignedName: 'Typ TypeVar musí být přiřazen proměnné s názvem {name}',
        typeVarAssignmentMismatch: 'Typ „{type}“ se nedá přiřadit proměnné typu „{name}“',
        typeVarBoundAndConstrained: 'TypeVar nemůže být současně vázaný i omezený',
        typeVarBoundGeneric: 'Vázaný typ TypeVar nemůže být obecný',
        typeVarConstraintGeneric: 'Typ omezení TypeVar nemůže být obecný',
        typeVarDefaultBoundMismatch: 'Výchozí typ TypeVar musí být podtyp vázaného typu',
        typeVarDefaultConstraintMismatch: 'Výchozí typ TypeVar musí být jeden z omezených typů',
        typeVarDefaultIllegal: 'Výchozí typy proměnných typů vyžadují Python 3.13 nebo novější',
        typeVarDefaultInvalidTypeVar: 'Parametr typu {name} má výchozí typ, který odkazuje na jednu nebo více proměnných typu, které jsou mimo obor',
        typeVarFirstArg: 'Očekával se název TypeVar jako první argument',
        typeVarInvalidForMemberVariable: 'Typ atributu nemůže používat proměnnou typu {name} vymezenou na místní metodu.',
        typeVarNoMember: 'TypeVar {type} nemá žádný atribut {name}.',
        typeVarNotSubscriptable: 'TypeVar {type} není možné zadat jako dolní index',
        typeVarNotUsedByOuterScope: 'Proměnná typu {name} nemá v tomto kontextu žádný význam',
        typeVarPossiblyUnsolvable: 'Proměnná typu „{name}“ může být nevyřešená, pokud volající nezadá žádný argument pro parametr „{param}“',
        typeVarSingleConstraint: 'TypeVar musí mít alespoň dva omezené typy',
        typeVarTupleConstraints: 'TypeVarTuple nemůže mít omezení hodnoty',
        typeVarTupleContext: 'TypeVarTuple se v tomto kontextu nepovoluje',
        typeVarTupleDefaultNotUnpacked: 'Výchozí typ TypeVarTuple musí být rozbalená řazená kolekce členů (tuple) nebo TypeVarTuple.',
        typeVarTupleMustBeUnpacked: 'Pro hodnotu TypeVarTuple se vyžaduje operátor rozbalení',
        typeVarTupleUnknownParam: '{name} je neznámý parametr pro TypeVarTuple',
        typeVarUnknownParam: '„{name}“ je neznámý parametr pro TypeVar',
        typeVarUsedByOuterScope: 'TypeVar „{name}“ se už používá ve vnějším oboru',
        typeVarUsedOnlyOnce: 'TypeVar {name} se v signatuře obecné funkce zobrazuje jenom jednou',
        typeVarVariance: 'TypeVar nemůže být kovariantní i kontravariantní',
        typeVarWithDefaultFollowsVariadic: 'TypeVar {typeVarName} má výchozí hodnotu a nemůže následovat po TypeVarTuple {variadicName}.',
        typeVarWithoutDefault: '„{name}“ se v seznamu parametrů typu nemůže zobrazit za „{other}“ , protože nemá žádný výchozí typ',
        typeVarsNotInGenericOrProtocol: 'Generic[] nebo Protocol[] musí obsahovat všechny proměnné typu',
        typedDictAccess: 'Nepovedlo se získat přístup k položce v TypedDict',
        typedDictAssignedName: 'TypedDict se musí přiřadit proměnné s názvem „{name}“.',
        typedDictBadVar: 'Třídy TypedDict můžou obsahovat jenom poznámky typu',
        typedDictBaseClass: 'Všechny základní třídy pro třídy TypedDict musí být také třídami TypedDict',
        typedDictBoolParam: 'Očekávalo se, že parametr {name} bude mít hodnotu True nebo False',
        typedDictClosedExtras: 'Základní třída {name} je closed TypedDict; další položky musí být typu {type}.',
        typedDictClosedNoExtras: 'Základní třída {name} je closed TypedDict; položky navíc nejsou povolené.',
        typedDictDelete: 'Nepovedlo se odstranit položku v TypedDict',
        typedDictEmptyName: 'Názvy v rámci TypedDict nemůžou být prázdné',
        typedDictEntryName: 'Očekával se řetězcový literál pro název položky slovníku',
        typedDictEntryUnique: 'Názvy ve slovníku musí být jedinečné',
        typedDictExtraArgs: 'Nadbytečné argumenty TypedDict nejsou podporovány',
        typedDictExtraItemsClosed: 'Objekt TypedDict nelze closed, pokud podporuje další položky.',
        typedDictFieldNotRequiredRedefinition: 'Položka TypedDict {name} nejde předefinovat jako NotRequired.',
        typedDictFieldReadOnlyRedefinition: 'Položka TypedDict {name} nejde předefinovat jako ReadOnly.',
        typedDictFieldRequiredRedefinition: 'Položka TypedDict {name} nejde předefinovat jako Required.',
        typedDictFirstArg: 'Jako první argument byl očekáván název třídy TypedDict',
        typedDictInClassPattern: 'Třída TypedDict není ve vzoru třídy povolena.',
        typedDictInitsubclassParameter: 'TypedDict nepodporuje parametr __init_subclass__ „{name}“.',
        typedDictNotAllowed: '„TypedDict“ se v tomto kontextu nedá použít.',
        typedDictSecondArgDict: 'Jako druhý parametr se očekával parametr dict nebo keyword.',
        typedDictSecondArgDictEntry: 'Očekávaná jednoduchá položka slovníku',
        typedDictSet: 'Nelze přiřadit položku v TypedDict',
        unaccessedClass: 'Třída „{name}“ není přístupná',
        unaccessedFunction: 'Funkce {name} není přístupná',
        unaccessedImport: 'Import {name} není přístupný',
        unaccessedSymbol: '{name} není přístupné',
        unaccessedVariable: 'Proměnná {name} není přístupná',
        unannotatedFunctionSkipped: 'Analýza funkce „{name}“ se přeskočila, protože není označená',
        unaryOperationNotAllowed: 'Ve výrazu typu není povolený unární operátor.',
        unexpectedAsyncToken: 'Očekávalo se, že za async bude následovat def, with nebo for',
        unexpectedExprToken: 'Neočekávaný token na konci výrazu',
        unexpectedIndent: 'Neočekávané odsazení',
        unexpectedUnindent: 'Neočekává se unindent',
        unhashableDictKey: 'Klíč slovníku musí být hashovatelný',
        unhashableSetEntry: 'Položka set musí být hashovatelná.',
        uninitializedAbstractVariables: 'Proměnné definované v abstraktní základní třídě nejsou inicializovány ve třídě final {classType}.',
        uninitializedInstanceVariable: 'Proměnná instance {name} není inicializována v těle třídy nebo v metodě __init__',
        unionForwardReferenceNotAllowed: 'Syntaxi Union není možné použít s operandem řetězce; použijte uvozovky kolem celého výrazu.',
        unionSyntaxIllegal: 'Alternativní syntaxe pro sjednocení vyžaduje Python 3.10 nebo novější',
        unionTypeArgCount: 'Union vyžaduje dva nebo více argumentů typu.',
        unionUnpackedTuple: 'Union nemůže obsahovat rozbalenou řazenou kolekci členů (tuple).',
        unionUnpackedTypeVarTuple: 'Union nemůže obsahovat rozbalený typ TypeVarTuple.',
        unnecessaryCast: 'Nepotřebné volání „cast“; typ už je „{type}“.',
        unnecessaryIsInstanceAlways: 'Zbytečné volání isinstance; {testType} je vždy instancí třídy {classType}',
        unnecessaryIsInstanceNever: 'Zbytečné volání isinstance; {testType} není nikdy instancí třídy {classType}',
        unnecessaryIsSubclassAlways: 'Nepotřebné volání issubclass; „{testType}“ je vždy podtřídou třídy „{classType}“',
        unnecessaryIsSubclassNever: 'Zbytečné volání issubclass; {testType} není nikdy podtřídou třídy {classType}',
        unnecessaryPyrightIgnore: 'Nepotřebný komentář „# pyright: ignore“',
        unnecessaryPyrightIgnoreRule: 'Nepotřebné pravidlo # pyright: ignore: {name}',
        unnecessaryTypeIgnore: 'Nepotřebný komentář „# type: ignore“',
        unpackArgCount: 'Po rozbalení „Unpack“ se očekával jeden argument typu',
        unpackExpectedTypeVarTuple: 'Jako argument typu pro Unpack byl očekáván typ TypeVarTuple nebo tuple.',
        unpackExpectedTypedDict: 'Byl očekáván argument typu TypedDict pro rozbalení Unpack',
        unpackIllegalInComprehension: 'Operace rozbalení není v porozumění povolená',
        unpackInAnnotation: 'Ve výrazu typu není povolený operátor rozbalení.',
        unpackInDict: 'Operace rozbalení není ve slovnících povolena',
        unpackInSet: 'Operátor rozbalení není v sadě (set) povolený.',
        unpackNotAllowed: 'Unpack se v tomto kontextu nepovoluje.',
        unpackOperatorNotAllowed: 'Operace rozbalení není v tomto kontextu povolená',
        unpackTuplesIllegal: 'Operace rozbalení není povolená v řazených kolekcích členů před Pythonem 3.8',
        unpackedArgInTypeArgument: 'V tomto kontextu nelze použít rozbalené argumenty.',
        unpackedArgWithVariadicParam: 'Pro parametr TypeVarTuple nejde použít rozbalený argument',
        unpackedDictArgumentNotMapping: 'Výraz argumentu za ** musí být mapování s typem klíče str',
        unpackedDictSubscriptIllegal: 'Operátor rozbalení slovníku v dolním indexu není povolený',
        unpackedSubscriptIllegal: 'Operátor rozbalení v dolním indexu vyžaduje Python 3.11 nebo novější',
        unpackedTypeVarTupleExpected: 'Byl očekáván rozbalený typ TypeVarTuple; použijte Unpack[{name1}] nebo *{name2}',
        unpackedTypedDictArgument: 'Nepovedlo se spárovat nebalený argument TypedDict s parametry',
        unreachableCode: 'Kód je nedostupný',
        unreachableCodeType: 'Analýza typů indikuje, že kód není dostupný.',
        unreachableExcept: 'Klauzule Except je nedosažitelná, protože výjimka je již zpracována',
        unsupportedDunderAllOperation: 'Operace s __all__ se nepodporuje, takže exportovaný seznam symbolů nemusí být správný',
        unusedCallResult: 'Výsledek výrazu volání je typu „{type}“ a nepoužívá se. přiřadit proměnné „_“, pokud je to záměrné',
        unusedCoroutine: 'Výsledek volání asynchronní funkce se nepoužívá; použijte operátor await nebo přiřaďte výsledek proměnné',
        unusedExpression: 'Hodnota výrazu se nepoužívá',
        varAnnotationIllegal: 'Poznámky type pro proměnné vyžadují Python 3.6 nebo novější; pro kompatibilitu s předchozími verzemi použijte komentáře type.',
        variableFinalOverride: 'Proměnná {name} je označená jako Final a přepíše proměnnou non-Final se stejným názvem ve třídě {className}.',
        variadicTypeArgsTooMany: 'Seznam argumentů typů může mít maximálně jeden rozbalený typ TypeVarTuple nebo tuple.',
        variadicTypeParamTooManyAlias: 'Alias typu může mít maximálně jeden parametr typu TypeVarTuple, ale přijal několik ({names})',
        variadicTypeParamTooManyClass: 'Obecná třída může mít maximálně jeden parametr typu TypeVarTuple, ale přijala více ({names})',
        walrusIllegal: 'Operátor := vyžaduje Python 3.8 nebo novější',
        walrusNotAllowed: 'Operátor := není v tomto kontextu povolen bez okolních závorek',
        wildcardInFunction: 'V rámci třídy nebo funkce není povolen import se zástupnými znaky.',
        wildcardLibraryImport: 'Není povolený import se zástupnými znaky z knihovny.',
        wildcardPatternTypePartiallyUnknown: 'Typ zachycený vzorem se zástupnými znaky je částečně neznámý',
        wildcardPatternTypeUnknown: 'Typ zachycený vzorem se zástupnými znaky je neznámý',
        yieldFromIllegal: 'Použití příkazu yield from vyžaduje Python 3.3 nebo novější',
        yieldFromOutsideAsync: 'yield from není v asynchronní funkci povoleno',
        yieldOutsideFunction: '„yield“ není povoleno mimo funkci nebo lambdu',
        yieldWithinComprehension: '„yield“ není povolené uvnitř porozumění',
        zeroCaseStatementsFound: 'Výraz shody (match) obsahovat alespoň jeden výraz velikosti písmen (case).',
        zeroLengthTupleNotAllowed: 'Řazená kolekce členů (tuple) s nulovou délkou není v tomto kontextu povolená.'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Speciální formulář Annotated nejde použít s kontrolami instancí a tříd.',
        argParam: 'Argument odpovídá parametru {paramName}',
        argParamFunction: 'Argument odpovídá parametru {paramName} ve funkci {functionName}',
        argsParamMissing: 'Parametr „*{paramName}“ nemá žádný odpovídající parametr',
        argsPositionOnly: 'Neshoda parametrů pouze s pozicí; Očekával(o/y) se {expected}, ale přijal(o/y) se {received}',
        argumentType: 'Typ argumentu je {type}',
        argumentTypes: 'Typy argumentů: ({types})',
        assignToNone: 'Typ se nedá přiřadit k None.',
        asyncHelp: 'Měli jste na mysli „async with“?',
        baseClassIncompatible: 'Základní třída {baseClass} není kompatibilní s typem {type}',
        baseClassIncompatibleSubclass: 'Základní třída {baseClass} je odvozená od třídy {subclass}, která není kompatibilní s typem {type}',
        baseClassOverriddenType: 'Základní třída {baseClass} poskytuje typ {type}, který je přepsán',
        baseClassOverridesType: 'Základní třída „{baseClass}“ přepisuje typ „{type}“',
        bytesTypePromotions: 'Pokud chcete povolit chování povýšení typu pro „bytearray“ a „memoryview“, nastavte disableBytesTypePromotions na false',
        conditionalRequiresBool: 'Metoda __bool__ pro typ {operandType} vrací typ {boolReturnType} místo bool',
        dataClassFieldLocation: 'Deklarace pole',
        dataClassFrozen: '{name} je zablokované',
        dataProtocolUnsupported: '„{name}“ je datový protokol.',
        descriptorAccessBindingFailed: 'Nepovedlo se vytvořit vazbu metody {name} pro třídu popisovače {className}.',
        descriptorAccessCallFailed: 'Nepovedlo se volat metodu {name} pro třídu popisovače {className}.',
        finalMethod: 'Metoda Final',
        functionParamDefaultMissing: 'V parametru „{name}“ chybí výchozí argument',
        functionParamName: 'Neshoda názvu parametru: {destName} a {srcName}',
        functionParamPositionOnly: 'Neshoda parametrů pouze s pozicí; Parametr „{name}“ není jen pro pozici.',
        functionReturnTypeMismatch: 'Návratový typ funkce „{sourceType}“ není kompatibilní s typem „{destType}“',
        functionTooFewParams: 'Funkce přijímá příliš málo pozičních parametrů; očekávaný počet: {expected}, počet, který byl přijat: {received}',
        functionTooManyParams: 'Funkce přijímá příliš mnoho pozičních parametrů; očekávaný počet: {expected}, počet, který byl přijat: {received}',
        genericClassNotAllowed: 'Obecný typ s argumenty obecného typu se pro kontroly instancí nebo tříd nepovoluje.',
        incompatibleDeleter: 'Metoda deleter vlastnosti (property) je nekompatibilní.',
        incompatibleGetter: 'Metoda getter vlastnosti (property) je nekompatibilní.',
        incompatibleSetter: 'Metoda setter vlastnosti (property) je nekompatibilní.',
        initMethodLocation: 'Metoda __init__ je definována ve třídě {type}',
        initMethodSignature: 'Podpis __init__ je {type}',
        initSubclassLocation: 'Metoda __init_subclass__ je definována ve třídě {name}.',
        invariantSuggestionDict: 'Zvažte přepnutí z možnosti „dict“ na možnost „Mapping“, která je v typu hodnoty kovariantní.',
        invariantSuggestionList: 'Zvažte přepnutí z možnosti „list“ na možnost „Sequence“, která je kovariantní.',
        invariantSuggestionSet: 'Zvažte přepnutí z možnosti „set“ na možnost „Container“, která je kovariantní.',
        isinstanceClassNotSupported: '{type} se pro kontroly instancí a tříd nepodporuje.',
        keyNotRequired: '„{name}! není v typu „{type}“ povinný klíč, takže přístup může vést k výjimce modulu runtime',
        keyReadOnly: '{name} je klíč jen pro čtení v {type}',
        keyRequiredDeleted: '{name} je povinný klíč a nedá se odstranit',
        keyUndefined: '{name} není definovaný klíč v typu {type}',
        kwargsParamMissing: 'Parametr „**{paramName}“ nemá žádný odpovídající parametr',
        listAssignmentMismatch: 'Typ {type} není kompatibilní s cílovým seznamem',
        literalAssignmentMismatch: '{sourceType} se nedá přiřadit k typu {destType}.',
        matchIsNotExhaustiveHint: 'Pokud není zamýšleno vyčerpávající zpracování, přidejte case _: pass',
        matchIsNotExhaustiveType: 'Nezpracovaný typ: {type}',
        memberAssignment: 'Výraz typu {type} nelze přiřadit k atributu {name} třídy {classType}.',
        memberIsAbstract: '„{type}.{name}“ není implementováno.',
        memberIsAbstractMore: 'a tento počet dalších: {count}...',
        memberIsClassVarInProtocol: '„{name}“ je v protokolu definován jako ClassVar.',
        memberIsInitVar: '{name} je pole init-only.',
        memberIsInvariant: '{name} je invariantní, protože je proměnlivé',
        memberIsNotClassVarInClass: '„{name}“ musí být definováno jako ClassVar, aby bylo kompatibilní s protokolem.',
        memberIsNotClassVarInProtocol: '„{name}“ není v protokolu definován jako ClassVar.',
        memberIsNotReadOnlyInProtocol: '{name} není v protokolu jen pro čtení.',
        memberIsReadOnlyInProtocol: '{name} je v protokolu jen pro čtení.',
        memberIsWritableInProtocol: '{name} se dá zapisovat do protokolu.',
        memberSetClassVar: 'Atribut {name} nelze přiřadit prostřednictvím instance třídy, protože jde o ClassVar.',
        memberTypeMismatch: '{name} je nekompatibilní typ',
        memberUnknown: 'Atribut {name} je neznámý.',
        metaclassConflict: 'Metatřída {metaclass1} je v konfliktu s metatřídou {metaclass2}.',
        missingDeleter: 'Chybí metoda deleter vlastnosti (property).',
        missingGetter: 'Chybí metoda getter vlastnosti (property).',
        missingSetter: 'Chybí metoda setter vlastnosti (property).',
        namedParamMissingInDest: 'Další parametr „{name}“',
        namedParamMissingInSource: 'Chybí parametr klíčového slova „{name}“.',
        namedParamTypeMismatch: 'Parametr klíčového slova {name} typu {sourceType} není kompatibilní s typem {destType}.',
        namedTupleNotAllowed: 'NamedTuple se nedá použít pro kontroly instancí nebo tříd.',
        newMethodLocation: 'Metoda __new__ je definována ve třídě {type}',
        newMethodSignature: 'Podpis __new__ je {type}',
        newTypeClassNotAllowed: 'Třídu vytvořenou pomocí NewType nelze použít s kontrolami instancí a tříd.',
        noOverloadAssignable: 'Typ {type} neodpovídá žádné přetížené funkci',
        noneNotAllowed: 'Možnost None se nedá použít pro kontroly instancí nebo tříd.',
        orPatternMissingName: 'Chybějící názvy: {name}',
        overloadIndex: 'Přetížení {index} je nejbližší shoda.',
        overloadNotAssignable: 'Nejméně jedno přetížení {name} není možné přiřadit',
        overloadSignature: 'Tady je definován podpis přetížení',
        overriddenMethod: 'Přepsaná metoda',
        overriddenSymbol: 'Přepsaný symbol',
        overrideInvariantMismatch: 'Typ přepsání „{overrideType}“není stejný jako základní typ „{baseType}“',
        overrideIsInvariant: 'Proměnná je proměnlivá, takže její typ je invariantní',
        overrideNoOverloadMatches: 'Signatura přetížení v přepsání není kompatibilní se základní metodou',
        overrideNotClassMethod: 'Základní metoda je deklarována jako metoda classmethod, ale přepsání není',
        overrideNotInstanceMethod: 'Základní metoda je deklarována jako instanční metoda, ale přepsání není',
        overrideNotStaticMethod: 'Základní metoda je deklarována jako staticmethod, ale přepsání není',
        overrideOverloadNoMatch: 'Přepsání nezahrnuje všechna přetížení metody základní třídy',
        overrideOverloadOrder: 'Přetížení přepisované metody musí být ve stejném pořadí jako základní metoda',
        overrideParamKeywordNoDefault: 'Neshoda parametru klíčového slova „{name}“: základní parametr má výchozí hodnotu argumentu, parametr pro přepsání ne',
        overrideParamKeywordType: 'Neshoda typu parametru klíčového slova „{name}“: základní parametr je typu „{baseType}“, parametr přepsání je typu „{overrideType}“',
        overrideParamName: 'Neshoda názvu parametru {index}: základní parametr má název „{baseName}“, parametr přepsání má název „{overrideName}“',
        overrideParamNameExtra: 'V základu chybí parametr {name}',
        overrideParamNameMissing: 'V přepsání chybí parametr „{name}“',
        overrideParamNamePositionOnly: 'Neshoda parametru {index}: základní parametr {baseName} je parametr klíčového slova, přepisující parametr je pouze pozice',
        overrideParamNoDefault: 'Neshoda parametru {index}: Základní parametr má výchozí hodnotu argumentu, parametr přepsání se neshoduje.',
        overrideParamType: 'Neshoda typu parametru {index}: Základní parametr je typu „{baseType}“, parametr přepsání je typu „{overrideType}“.',
        overridePositionalParamCount: 'Neshoda počtu pozičních parametrů; Základní metoda má „{baseCount}“, ale přepsání má {overrideCount}',
        overrideReturnType: 'Neshoda návratového typu: Základní metoda vrací typ {baseType}, přepsání vrací typ {overrideType}',
        overrideType: 'Základní třída definuje typ jako {type}',
        paramAssignment: 'Parametr {index}: typ {sourceType} není kompatibilní s typem {destType}.',
        paramSpecMissingInOverride: 'V metodě přepsání chybí parametry ParamSpec',
        paramType: 'Typ parametru je {paramType}',
        privateImportFromPyTypedSource: 'Místo toho importovat z modulu {module}',
        propertyAccessFromProtocolClass: 'Vlastnost definovaná v rámci třídy protokolu není přístupná jako proměnná třídy',
        propertyMethodIncompatible: 'Metoda vlastnosti (property) {name} není kompatibilní.',
        propertyMethodMissing: 'V přepsání (override) chybí metoda vlastnosti (property) „{name}“.',
        propertyMissingDeleter: 'Vlastnost (property) {name} nemá definovanou metodu deleter.',
        propertyMissingSetter: 'Vlastnost (property) {name} nemá definovanou metodu setter.',
        protocolIncompatible: '{sourceType} není kompatibilní s protokolem {destType}',
        protocolMemberMissing: '{name} není k dispozici',
        protocolRequiresRuntimeCheckable: 'Třída Protocol musí být @runtime_checkable, aby se použila při kontrolách instancí a tříd.',
        protocolSourceIsNotConcrete: '„{sourceType}“ není konkrétní typ třídy a nedá se přiřadit k typu „{destType}“',
        protocolUnsafeOverlap: 'Atributy „{name}“ mají stejné názvy jako protokol.',
        pyrightCommentIgnoreTip: 'Pokud chcete potlačit diagnostiku pro jeden řádek, použijte # pyright: ignore[<diagnostic rules>]',
        readOnlyAttribute: 'Atribut {name} je jen pro čtení',
        seeClassDeclaration: 'Viz deklarace třídy',
        seeDeclaration: 'Viz deklarace',
        seeFunctionDeclaration: 'Viz deklarace funkce',
        seeMethodDeclaration: 'Viz deklarace metody',
        seeParameterDeclaration: 'Viz deklarace parametru',
        seeTypeAliasDeclaration: 'Zobrazit deklaraci aliasu typu',
        seeVariableDeclaration: 'Zobrazit deklaraci proměnné',
        tupleAssignmentMismatch: 'Typ „{type}“ není kompatibilní s cílovou řazenou kolekcí členů (tuple).',
        tupleEntryTypeMismatch: 'Položka řazené kolekce členů (tuple) {entry} je nesprávného typu.',
        tupleSizeIndeterminateSrc: 'Neshoda velikosti řazené kolekce členů (tuple); očekávalo se {expected}, ale přijalo se neurčité.',
        tupleSizeIndeterminateSrcDest: 'Neshoda velikosti řazené kolekce členů (tuple); očekávalo se min. {expected}, ale přijalo se neurčité.',
        tupleSizeMismatch: 'Neshoda velikosti řazené kolekce členů (tuple); očekávalo se {expected}, ale přijalo se {received}.',
        tupleSizeMismatchIndeterminateDest: 'Neshoda velikosti řazené kolekce členů (tuple); Očekávalo se {expected}, ale přijalo se {received}.',
        typeAliasInstanceCheck: 'Alias typu vytvořený pomocí příkazu „type“ se nedá použít s kontrolami instancí a tříd.',
        typeAssignmentMismatch: 'Typ {sourceType} se nedá přiřadit k typu {destType}.',
        typeBound: 'Typ {sourceType} se nedá přiřadit k horní hranici {destType} pro proměnnou typu {name}.',
        typeConstrainedTypeVar: 'Typ {type} se nedá přiřadit k proměnné omezeného typu {name}.',
        typeIncompatible: '{sourceType} se nedá přiřadit k {destType}.',
        typeNotClass: '{type} není třída',
        typeNotStringLiteral: '„{type}“ není řetězcový literál',
        typeOfSymbol: 'Typ „{name}“ je „{type}“',
        typeParamSpec: 'Typ {type} není kompatibilní s parametrem ParamSpec {name}',
        typeUnsupported: 'Typ {type} není podporován',
        typeVarDefaultOutOfScope: 'Proměnná typu {name} není v oboru',
        typeVarIsContravariant: 'Parametr typu „{name}“ je kontravariantní, ale „{sourceType}“ není nadtyp „{destType}“.',
        typeVarIsCovariant: 'Parametr typu „{name}“ je kovariantní, ale „{sourceType}“ není podtyp „{destType}“.',
        typeVarIsInvariant: 'Parametr typu „{name}“ je invariantní, ale „{sourceType}“ není stejný jako „{destType}“.',
        typeVarNotAllowed: 'TypeVar se pro kontroly instancí nebo tříd nepovoluje.',
        typeVarTupleRequiresKnownLength: 'Typ TypeVarTuple nemůže být vázaný na řazenou kolekci členů (tuple) neznámé délky.',
        typeVarUnnecessarySuggestion: 'Místo toho použijte {type}.',
        typeVarUnsolvableRemedy: 'Zadejte přetížení, které určuje návratový typ, pokud argument není zadán',
        typeVarsMissing: 'Chybějící proměnné typu: {names}',
        typedDictBaseClass: 'Třída „{type}“ není TypedDict.',
        typedDictClassNotAllowed: 'Třída TypedDict není povolená pro kontroly instancí nebo tříd.',
        typedDictClosedExtraNotAllowed: 'Do {name} nejde přidat položku.',
        typedDictClosedExtraTypeMismatch: 'Nelze přidat položku {name} s typem {type}.',
        typedDictClosedFieldNotRequired: 'Nelze přidat položku {name}, protože musí být NotRequired.',
        typedDictExtraFieldNotAllowed: '{name} není k dispozici v {type}',
        typedDictExtraFieldTypeMismatch: 'Typ {name} není kompatibilní s typem „extra_items“ v typu {type}.',
        typedDictFieldMissing: 'V {type} chybí {name}',
        typedDictFieldNotReadOnly: '{name} není v {type} jen pro čtení',
        typedDictFieldNotRequired: '{name} se v typu {type} nevyžaduje',
        typedDictFieldRequired: '{name} se vyžaduje v {type}',
        typedDictFieldTypeMismatch: 'Typ {type} se nedá přiřadit k položce {name}',
        typedDictFieldUndefined: '{name} je nedefinovaná položka v typu {type}',
        typedDictFinalMismatch: '{sourceType} není kompatibilní s {destType} z důvodu neshody @final',
        typedDictKeyAccess: 'Použít ["{name}"] k odkazování na položku v TypedDict',
        typedDictNotAllowed: 'TypedDict se nedá použít pro kontroly instancí nebo tříd.',
        unhashableType: 'Typ „{type}“ nejde zatřiďovat',
        uninitializedAbstractVariable: 'Proměnná instance {name} je definovaná v abstraktní základní třídě {classType}, ale neinicializovala se',
        unreachableExcept: '{exceptionType} je podtřídou {parentType}',
        useDictInstead: 'Označte typ slovníku pomocí Dict[T1, T2]',
        useListInstead: 'Použijte List[T] k označení typu seznamu (list) nebo Union[T1, T2] k označení typu sjednocení (union).',
        useTupleInstead: 'Použijte tuple[T1, ..., Tn] k označení typu řazené kolekce členů (tuple) nebo Union[T1, T2] k označení typu sjednocení (union).',
        useTypeInstead: 'Místo toho použít Type[T]',
        varianceMismatchForClass: 'Odchylka argumentu typu „{typeVarName}“ není kompatibilní se základní třídou „{className}“',
        varianceMismatchForTypeAlias: 'Rozptyl argumentu typu „{typeVarName}“ není kompatibilní s typem „{typeAliasParam}“'
      },
      Service: {
        longOperation: 'Výčet zdrojových souborů pracovního prostoru trvá dlouho. Zvažte raději otevření podsložky. [Další informace](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  94397: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Type Stub erstellen',
        createTypeStubFor: 'Type Stub für "{moduleName}" erstellen',
        executingCommand: 'Der Befehl wird ausgeführt.',
        filesToAnalyzeCount: '{count} Dateien zu analysieren',
        filesToAnalyzeOne: '1 zu analysierende Datei',
        findingReferences: 'Verweise werden gesucht',
        organizeImports: 'Import-Direktiven organisieren',
        renameShadowedFile: '"{oldFile}" in "{newFile}" umbenennen'
      },
      Completion: {
        autoImportDetail: 'Autoimport',
        indexValueDetail: 'Indexwert'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Die Methode „{method}“ kann nicht aufgerufen werden, da sie abstrakt und nicht implementiert ist.',
        annotatedMetadataInconsistent: 'Der mit Anmerkungen versehene Metadatentyp „{metadataType}“ ist nicht mit dem Typ „{type}“ kompatibel.',
        annotatedParamCountMismatch: 'Nicht übereinstimmende Parameteranmerkungsanzahl: {expected} erwartet, aber {received} empfangen',
        annotatedTypeArgMissing: 'Es wurde ein Typargument und mindestens eine Anmerkung für "Annotated" erwartet.',
        annotationBytesString: 'In Typausdrücken dürfen keine Bytes-Zeichenfolgenliterale verwendet werden',
        annotationFormatString: 'Typausdrücke dürfen keine Formatzeichenfolgenliterale (f-strings) enthalten',
        annotationNotSupported: 'Typanmerkung wird für diese Anweisung nicht unterstützt.',
        annotationRawString: 'Typausdrücke dürfen keine unformatierten Zeichenfolgenliterale enthalten',
        annotationSpansStrings: 'Typausdrücke dürfen nicht mehrere Zeichenfolgenliterale umfassen.',
        annotationStringEscape: 'Typausdrücke dürfen keine Escapezeichen enthalten',
        argAssignment: 'Ein Argument vom Typ "{argType}" kann dem Parameter vom Typ "{paramType}" nicht zugewiesen werden.',
        argAssignmentFunction: 'Ein Argument vom Typ "{argType}" kann dem Parameter vom Typ "{paramType}" in der Funktion "{functionName}" nicht zugewiesen werden.',
        argAssignmentParam: 'Ein Argument vom Typ "{argType}" kann dem Parameter "{paramName}" vom Typ "{paramType}" nicht zugewiesen werden.',
        argAssignmentParamFunction: 'Ein Argument vom Typ "{argType}" kann dem Parameter "{paramName}" vom Typ "{paramType}" in der Funktion "{functionName}" nicht zugewiesen werden.',
        argMissingForParam: 'Für Parameter {name} fehlt ein Argument.',
        argMissingForParams: 'Fehlende Argumente für die Parameter {names}',
        argMorePositionalExpectedCount: 'Es wurden {expected} weitere Positionsargumente erwartet.',
        argMorePositionalExpectedOne: 'Es wurde 1 weiteres Positionsargument erwartet.',
        argPositional: 'Positionsargument erwartet',
        argPositionalExpectedCount: 'Es wurden {expected} Positionsargumente erwartet.',
        argPositionalExpectedOne: 'Es wurde 1 Positionsargument erwartet.',
        argTypePartiallyUnknown: 'Der Argumenttyp ist teilweise unbekannt',
        argTypeUnknown: 'Argumenttyp ist unbekannt',
        assertAlwaysTrue: 'Assertausdruck wird immer als „true“ ausgewertet.',
        assertTypeArgs: '"assert_type" erwartet zwei Positionsargumente.',
        assertTypeTypeMismatch: '"assert_type" Konflikt: "{expected}" erwartet, aber "{received}" empfangen',
        assignmentExprComprehension: 'Ziel des Zuweisungsausdrucks "{name}" kann nicht denselben Namen wie das Verständnis für das Ziel verwenden.',
        assignmentExprContext: 'Der Zuweisungsausdruck muss sich innerhalb des Moduls, der Funktion oder der Lambdafunktion befinden.',
        assignmentExprInSubscript: 'Zuweisungsausdrücke innerhalb eines Tiefgestellten werden nur in Python 3.10 und höher unterstützt.',
        assignmentInProtocol: 'Instanzen- oder Klassenvariablen innerhalb einer Protocol Klasse müssen explizit innerhalb des Klassentexts deklariert werden.',
        assignmentTargetExpr: 'Der Ausdruck kann kein Zuweisungsziel sein.',
        asyncNotInAsyncFunction: 'Die Verwendung von "async" ist außerhalb einer asynchronen Funktion nicht zulässig.',
        awaitIllegal: 'Die Verwendung von "await" erfordert Python 3.5 oder höher.',
        awaitNotAllowed: 'In Typausdrücken darf „await“ nicht verwendet werden',
        awaitNotInAsync: '"await" ist nur innerhalb einer asynchronen Funktion zulässig.',
        backticksIllegal: 'Ausdrücke, die von Backticks umgeben sind, werden in Python 3.x nicht unterstützt; verwenden Sie stattdessen repr',
        baseClassCircular: 'Die Klasse kann nicht von sich selbst abgeleitet werden.',
        baseClassFinal: 'Die Basisklasse "{type}" ist als final gekennzeichnet und kann nicht als Unterklasse verwendet werden.',
        baseClassIncompatible: 'Basisklassen von {type} sind gegenseitig inkompatibel.',
        baseClassInvalid: 'Das Argument für die Klasse muss eine Basisklasse sein.',
        baseClassMethodTypeIncompatible: 'Basisklassen für die Klasse "{classType}" definieren die Methode "{name}" auf inkompatible Weise.',
        baseClassUnknown: 'Der Basisklassentyp ist unbekannt, sodass der Typ der abgeleiteten Klasse verdeckt wird.',
        baseClassVariableTypeIncompatible: 'Basisklassen für die Klasse "{classType}" definieren die Variable "{name}" auf inkompatible Weise.',
        binaryOperationNotAllowed: 'Der binärer Operator ist im Typausdruck nicht zulässig',
        bindTypeMismatch: 'Die Methode "{methodName}" konnte nicht gebunden werden, da "{type}" dem Parameter "{paramName}" nicht zugewiesen werden kann.',
        breakInExceptionGroup: '„break“ ist in einem „except*“ Block nicht zulässig.',
        breakOutsideLoop: '"break" kann nur innerhalb einer Schleife verwendet werden.',
        callableExtraArgs: 'Es wurden nur zwei Typargumente für "Callable" erwartet.',
        callableFirstArg: 'Parametertypliste oder "..." erwartet.',
        callableNotInstantiable: 'Der Typ "{type}" kann nicht instanziiert werden.',
        callableSecondArg: 'Rückgabetyp als zweites Typargument für "Callable" erwartet',
        casePatternIsIrrefutable: 'Ein unwiderlegbares Muster ist nur für die letzte case-Anweisung zulässig.',
        classAlreadySpecialized: 'Der Typ "{type}" ist bereits spezialisiert.',
        classDecoratorTypeUnknown: 'Der nicht typisierte Klassendekorator verdeckt den Typ der Klasse; Decorator wird ignoriert.',
        classDefinitionCycle: 'Die Klassendefinition für "{name}" hängt von sich selbst ab.',
        classGetItemClsParam: '__class_getitem__ Außerkraftsetzung sollte einen "cls"-Parameter annehmen.',
        classMethodClsParam: 'Klassenmethoden sollten einen "cls"-Parameter verwenden.',
        classNotRuntimeSubscriptable: 'Tiefgestellte Zeichen für die Klasse „{name}“ generieren eine Laufzeitausnahme; schließen Sie den Typausdruck in Anführungszeichen ein',
        classPatternBuiltInArgPositional: 'Das Klassenmuster akzeptiert nur positionsbezogenes Untermuster.',
        classPatternPositionalArgCount: 'Zu viele Positionsmuster für Klasse "{type}". Erwartet: {expected}, empfangen: {received}.',
        classPatternTypeAlias: '"{type}" kann nicht in einem Klassenmuster verwendet werden, da es sich um einen spezialisierten Typalias handelt.',
        classPropertyDeprecated: 'Klasseneigenschaften sind in Python 3.11 veraltet und werden in Python 3.13 nicht unterstützt.',
        classTypeParametersIllegal: 'Die Syntax des Klassentypparameters erfordert Python 3.12 oder höher.',
        classVarFirstArgMissing: 'Nach "ClassVar" wurde ein Typargument erwartet.',
        classVarNotAllowed: '"ClassVar" ist in diesem Kontext nicht zulässig.',
        classVarOverridesInstanceVar: 'Die Klassenvariable "{name}" überschreibt die Instanzvariable desselben Namens in der Klasse "{className}"',
        classVarTooManyArgs: 'Nach "ClassVar" wird ein Typargument erwartet.',
        classVarWithTypeVar: 'Der Typ "ClassVar" darf keine Typvariablen enthalten.',
        clsSelfParamTypeMismatch: 'Der Typ des Parameters "{name}" muss ein Obertyp seiner Klasse "{classType}" sein',
        codeTooComplexToAnalyze: 'Der Code ist zu komplex für die Analyse; verringern Sie die Komplexität durch Refactoring in Unterroutinen oder durch Reduzieren bedingter Codepfade',
        collectionAliasInstantiation: 'Der Typ "{type}" kann nicht instanziiert werden, verwenden Sie stattdessen "{alias}".',
        comparisonAlwaysFalse: 'Die Bedingung wird immer als False ausgewertet, da die Typen "{leftType}" und "{rightType}" keine Überlappung aufweisen.',
        comparisonAlwaysTrue: 'Die Bedingung wird immer als True ausgewertet, da die Typen "{leftType}" und "{rightType}" keine Überlappung aufweisen.',
        comprehensionInDict: 'Verständnis kann nicht mit anderen Wörterbucheinträgen verwendet werden.',
        comprehensionInSet: 'Verständnis kann nicht mit anderen „set“ Einträgen verwendet werden.',
        concatenateContext: '„Concatenate“ ist in diesem Kontext nicht zulässig.',
        concatenateParamSpecMissing: 'Das letzte Typargument für "Concatenate" muss ein ParamSpec oder "..." sein.',
        concatenateTypeArgsMissing: '„Concatenate„ erfordert mindestens zwei Typargumente.',
        conditionalOperandInvalid: 'Ungültiger bedingter Operand vom Typ "{type}"',
        constantRedefinition: '"{name}" ist konstant (da es sich um Großbuchstaben handelt) und kann nicht neu definiert werden.',
        constructorParametersMismatch: 'Keine Übereinstimmung zwischen der Signatur von __new__ und __init__ in der Klasse "{classType}"',
        containmentAlwaysFalse: 'Der Ausdruck wird immer als False ausgewertet, da die Typen "{leftType}" und "{rightType}" keine Überlappung aufweisen.',
        containmentAlwaysTrue: 'Der Ausdruck wird immer als True ausgewertet, da die Typen "{leftType}" und "{rightType}" keine Überlappung aufweisen.',
        continueInExceptionGroup: '„continue“ ist in einem „except*“ Block nicht zulässig.',
        continueOutsideLoop: '"continue" kann nur innerhalb einer Schleife verwendet werden.',
        coroutineInConditionalExpression: 'Bedingter Ausdruck verweist auf eine Coroutine, die immer zu "True" ausgewertet wird.',
        dataClassBaseClassFrozen: 'Eine nicht fixierte Klasse kann nicht von einer fixierten Klasse erben.',
        dataClassBaseClassNotFrozen: 'Eine fixierte Klasse kann nicht von einer nicht fixierten Klasse erben.',
        dataClassConverterFunction: 'Das Argument vom Typ "{argType}" ist kein gültiger Konverter für das Feld "{fieldName}" vom Typ "{fieldType}"',
        dataClassConverterOverloads: 'Keine Überladungen von "{funcName}" sind gültige Konverter für das Feld "{fieldName}" vom Typ "{fieldType}"',
        dataClassFieldInheritedDefault: '„{fieldName}“ überschreibt ein Feld mit demselben Namen, aber es fehlt ein Standardwert',
        dataClassFieldWithDefault: 'Felder ohne Standardwerte dürfen nicht nach Feldern mit Standardwerten angezeigt werden.',
        dataClassFieldWithPrivateName: 'Das Feld "Dataclass" kann keinen privaten Namen verwenden.',
        dataClassFieldWithoutAnnotation: 'Datenklassenfeld ohne Typanmerkung verursacht eine Laufzeitausnahme',
        dataClassPostInitParamCount: 'Dataclass __post_init__ falsche Parameteranzahl; Anzahl von InitVar-Feldern ist {expected}',
        dataClassPostInitType: 'Dataclass __post_init__ Methodenparametertypkonflikt für Feld "{fieldName}"',
        dataClassSlotsOverwrite: '__slots__ ist bereits in der Klasse definiert.',
        dataClassTransformExpectedBoolLiteral: 'Es wurde ein Ausdruck erwartet, der statisch als True oder False ausgewertet wird.',
        dataClassTransformFieldSpecifier: 'Es wurde tuple von Klassen oder Funktionen erwartet, es wurde jedoch der Typ "{type}" empfangen',
        dataClassTransformPositionalParam: 'Alle Argumente für "dataclass_transform" müssen Schlüsselwortargumente sein.',
        dataClassTransformUnknownArgument: 'Argument "{name}" wird von dataclass_transform nicht unterstützt.',
        dataProtocolInSubclassCheck: 'Datenprotokolle (die Nicht-Methodenattribute enthalten) sind in „issubclass“-Aufrufen nicht zulässig.',
        declaredReturnTypePartiallyUnknown: 'Der deklarierte Rückgabetyp "{returnType}" ist teilweise unbekannt.',
        declaredReturnTypeUnknown: 'Unbekannter Rückgabetyp deklariert',
        defaultValueContainsCall: 'Funktionsaufrufe und änderbare Objekte sind innerhalb des Parameterstandardwertausdrucks nicht zulässig.',
        defaultValueNotAllowed: 'Ein Parameter mit "*" oder "**" darf keinen Standardwert aufweisen.',
        delTargetExpr: 'Der Ausdruck kann nicht gelöscht werden',
        deprecatedClass: 'Die Klasse "{name}" ist veraltet.',
        deprecatedConstructor: 'Der Konstruktor für die Klasse "{name}" ist veraltet.',
        deprecatedDescriptorDeleter: 'Die Methode "__delete__" für den Deskriptor "{name}" ist veraltet.',
        deprecatedDescriptorGetter: 'Die Methode "__get__" für den Deskriptor "{name}" ist veraltet.',
        deprecatedDescriptorSetter: 'Die Methode "__set__" für den Deskriptor "{name}" ist veraltet.',
        deprecatedFunction: 'Die Funktion "{name}" ist veraltet.',
        deprecatedMethod: 'Die Methode "{name}" in der Klasse "{className}" ist veraltet.',
        deprecatedPropertyDeleter: 'Der deleter für property "{name}" ist veraltet.',
        deprecatedPropertyGetter: 'Der getter für property "{name}" ist veraltet.',
        deprecatedPropertySetter: 'Der setter für property "{name}" ist veraltet.',
        deprecatedType: 'Dieser Typ ist ab python-{version} veraltet; verwenden Sie stattdessen "{replacement}"',
        dictExpandIllegalInComprehension: 'Wörterbucherweiterung ist im Verständnis nicht zulässig.',
        dictInAnnotation: 'Der Wörterbuchausdruck ist im Typausdruck nicht zulässig',
        dictKeyValuePairs: 'Wörterbucheinträge müssen Schlüssel-Wert-Paare enthalten.',
        dictUnpackIsNotMapping: 'Es wird eine Zuordnung für den Operator zum Entpacken des Wörterbuchs erwartet.',
        dunderAllSymbolNotPresent: '"{name}" ist in __all__ angegeben, aber nicht im Modul vorhanden.',
        duplicateArgsParam: 'Es ist nur ein "*"-Parameter zulässig.',
        duplicateBaseClass: 'Doppelte Basisklasse nicht zulässig',
        duplicateCapturePatternTarget: '"{name}" des Erfassungsziels darf nicht mehrmals innerhalb desselben Musters vorkommen.',
        duplicateCatchAll: 'Es ist nur eine catch-all except-Klausel zulässig.',
        duplicateEnumMember: 'Der Enumerationsmember "{name}" wurde bereits deklariert.',
        duplicateGenericAndProtocolBase: 'Es ist nur eine Generic[...]- oder ein Protocol[...]-Basisklasse zulässig.',
        duplicateImport: '"{importName}" wurde mehrmals importiert.',
        duplicateKeywordOnly: 'Es ist nur ein "*"-Trennzeichen zulässig.',
        duplicateKwargsParam: 'Es ist nur ein "**"-Parameter zulässig.',
        duplicateParam: 'Doppelter Parameter "{name}"',
        duplicatePositionOnly: 'Es ist nur ein "/"-Parameter zulässig.',
        duplicateStarPattern: 'In einer Mustersequenz ist nur ein "*"-Muster zulässig.',
        duplicateStarStarPattern: 'Es ist nur ein "**"-Eintrag zulässig.',
        duplicateUnpack: 'In list ist nur ein Vorgang zum Entpacken zulässig.',
        ellipsisAfterUnpacked: '„...“ kann nicht mit einem entpackten „TypeVarTuple“ oder „tuple“ verwendet werden.',
        ellipsisContext: '"..." ist in diesem Kontext nicht zulässig.',
        ellipsisSecondArg: '"..." ist nur als zweites von zwei Argumenten zulässig.',
        enumClassOverride: 'Die Enumerationsklasse "{name}" ist final und kann nicht in eine Unterklasse aufgenommen werden.',
        enumMemberDelete: 'Das Enumerationselement "{name}" kann nicht gelöscht werden.',
        enumMemberSet: 'Das Enumerationselement "{name}" kann nicht zugewiesen werden.',
        enumMemberTypeAnnotation: 'Typanmerkungen sind für enum Member nicht zulässig',
        exceptGroupMismatch: 'Die „try“-Anweisung darf nicht sowohl „except“ als auch „except*“ enthalten.',
        exceptGroupRequiresType: 'Die Ausnahmegruppensyntax („except*“) erfordert einen Ausnahmetyp.',
        exceptionGroupIncompatible: 'Die Ausnahmegruppensyntax ("except*") erfordert Python 3.11 oder höher.',
        exceptionGroupTypeIncorrect: 'Der Ausnahmetyp in except* kann nicht von BaseGroupException abgeleitet werden.',
        exceptionTypeIncorrect: '"{type}" ist nicht von BaseException abgeleitet.',
        exceptionTypeNotClass: '"{type}" ist keine gültige Ausnahmeklasse.',
        exceptionTypeNotInstantiable: 'Der Konstruktor für den Ausnahmetyp "{type}" erfordert mindestens ein Argument.',
        expectedAfterDecorator: 'Es wurde eine Funktions- oder Klassendeklaration nach dem Decorator erwartet.',
        expectedArrow: '"->" gefolgt von Rückgabetypanmerkung erwartet',
        expectedAsAfterException: '"as" nach Ausnahmetyp erwartet',
        expectedAssignRightHandExpr: 'Ausdruck rechts von "=" erwartet',
        expectedBinaryRightHandExpr: 'Ausdruck rechts vom Operator',
        expectedBoolLiteral: '"True" oder "False" erwartet',
        expectedCase: '"case"-Anweisung erwartet',
        expectedClassName: 'Klassenname erwartet',
        expectedCloseBrace: '"{" wurde nicht geschlossen.',
        expectedCloseBracket: '"[" wurde nicht geschlossen.',
        expectedCloseParen: '"(" wurde nicht geschlossen.',
        expectedColon: '":" erwartet',
        expectedComplexNumberLiteral: 'Für den Musterabgleich wurde ein komplexes Zahlenliteral erwartet.',
        expectedDecoratorExpr: 'Das Ausdrucksformular wird für den Decorator vor Python 3.9 nicht unterstützt.',
        expectedDecoratorName: 'Decoratorname erwartet',
        expectedDecoratorNewline: 'Am Ende des Decorators wurde eine neue Zeile erwartet.',
        expectedDelExpr: 'Ausdruck nach "del" erwartet',
        expectedElse: 'Unerwartetes "else"',
        expectedEquals: '"=" erwartet',
        expectedExceptionClass: 'Ungültige Ausnahmeklasse oder ungültiges Objekt.',
        expectedExceptionObj: 'Ausnahmeobjekt, Ausnahmeklasse oder None erwartet',
        expectedExpr: 'Ausdruck erwartet.',
        expectedFunctionAfterAsync: 'Funktionsdefinition nach "async" erwartet',
        expectedFunctionName: 'Funktionsname nach "def" erwartet',
        expectedIdentifier: 'Bezeichner erwartet',
        expectedImport: '"import" erwartet',
        expectedImportAlias: 'Symbol nach "as" erwartet',
        expectedImportSymbols: 'Nach dem "import" wurde mindestens ein Symbolname erwartet.',
        expectedIn: '"in" wurde erwartet.',
        expectedInExpr: 'Ausdruck nach "in" erwartet',
        expectedIndentedBlock: 'Eingerückter Block erwartet',
        expectedMemberName: 'Attributname nach „.“ erwartet',
        expectedModuleName: 'Modulname erwartet',
        expectedNameAfterAs: 'Symbolname nach "as" erwartet',
        expectedNamedParameter: 'Der Schlüsselwortparameter muss auf "*" folgen.',
        expectedNewline: 'Zeilenumbruch erwartet',
        expectedNewlineOrSemicolon: 'Anweisungen müssen durch Zeilenumbrüche oder Semikolons getrennt werden.',
        expectedOpenParen: '"(" erwartet',
        expectedParamName: 'Parametername erwartet',
        expectedPatternExpr: 'Musterausdruck erwartet',
        expectedPatternSubjectExpr: 'Musterbetreffausdruck erwartet',
        expectedPatternValue: 'Es wurde ein Musterwertausdruck im Format "a.b" erwartet.',
        expectedReturnExpr: 'Ausdruck nach "return" erwartet',
        expectedSliceIndex: 'Index- oder Sliceausdruck erwartet',
        expectedTypeNotString: 'Typ erwartet, aber Zeichenfolgenliteral empfangen',
        expectedTypeParameterName: 'Name für Typparameter erwartet',
        expectedYieldExpr: 'Ausdruck in yield-Anweisung erwartet',
        finalClassIsAbstract: 'Die Klasse „{type}“ ist als final markiert und muss alle abstrakten Symbole implementieren.',
        finalContext: '"Final" ist in diesem Kontext nicht zulässig.',
        finalInLoop: 'Eine "Final"-Variable kann nicht innerhalb einer Schleife zugewiesen werden.',
        finalMethodOverride: 'Die Methode "{name}" kann die in der Klasse definierte final Methode "{className}" nicht überschreiben.',
        finalNonMethod: 'Die Funktion „{name}“ kann nicht @final markiert werden, da sie keine Methode ist.',
        finalReassigned: '"{name}" ist als "Final" deklariert und kann nicht neu zugewiesen werden.',
        finalRedeclaration: '"{name}" wurde zuvor als "Final" deklariert.',
        finalRedeclarationBySubclass: '"{name}" kann nicht neu deklariert werden, da die übergeordnete Klasse "{className}" es als Final deklariert.',
        finalTooManyArgs: 'Nach "Final" wurde ein einzelnes Typargument erwartet.',
        finalUnassigned: '"{name}" ist als Final deklariert, aber der Wert ist nicht zugewiesen.',
        formatStringBrace: 'Eine einzelne schließende geschweifte Klammer ist innerhalb des f-string-Literals nicht zulässig; verwenden Sie doppelte schließende geschweifte Klammern.',
        formatStringBytes: 'Formatzeichenfolgenliterale (f-strings) dürfen nicht binär sein.',
        formatStringDebuggingIllegal: 'Der F-String-Debugspezifizierer "=" erfordert Python 3.8 oder höher.',
        formatStringEscape: 'Escapesequenz (umgekehrter Schrägstrich) ist im Ausdrucksteil der f-Zeichenfolge vor Python 3.12 nicht zulässig.',
        formatStringExpectedConversion: 'Nach "!" in f-string wurde ein Konvertierungsspezifizierer erwartet.',
        formatStringIllegal: 'Formatzeichenfolgenliterale (f-strings) erfordern Python 3.6 oder höher.',
        formatStringInPattern: 'Die Formatzeichenfolge ist im Muster nicht zulässig.',
        formatStringNestedFormatSpecifier: 'Ausdrücke sind zu tief im Formatzeichenfolgenspezifizierer geschachtelt.',
        formatStringNestedQuote: 'Zeichenfolgen, die in einer f-Zeichenfolge geschachtelt sind, dürfen nicht dasselbe Anführungszeichen wie die f-Zeichenfolge vor Python 3.12 verwenden.',
        formatStringUnicode: 'Formatzeichenfolgenliterale (f-strings) dürfen nicht Unicode sein.',
        formatStringUnterminated: 'Nicht abgeschlossener Ausdruck in f-string; "}" wird erwartet.',
        functionDecoratorTypeUnknown: 'Ein nicht typisierter Funktionsdekorator verdeckt den Funktionstyp; Decorator wird ignoriert.',
        functionInConditionalExpression: 'Bedingter Ausdruck verweist auf eine Funktion, die immer zu "True" ausgewertet wird.',
        functionTypeParametersIllegal: 'Die Syntax des Funktionstypparameters erfordert Python 3.12 oder höher.',
        futureImportLocationNotAllowed: 'Importe von __future__ müssen am Anfang der Datei auftreten',
        generatorAsyncReturnType: 'Der Rückgabetyp der asynchronen Generatorfunktion muss mit "AsyncGenerator[{yieldType}, Any]" kompatibel sein.',
        generatorNotParenthesized: 'Generatorausdrücke müssen in Klammern gesetzt werden, wenn sie nicht das einzige Argument sind.',
        generatorSyncReturnType: 'Der Rückgabetyp der Generatorfunktion muss mit "Generator[{yieldType}, Any, Any]" kompatibel sein.',
        genericBaseClassNotAllowed: 'Die Basisklasse "Generic" kann nicht mit der Typparametersyntax verwendet werden.',
        genericClassAssigned: 'Der generische Klassentyp kann nicht zugewiesen werden.',
        genericClassDeleted: 'Der generische Klassentyp kann nicht gelöscht werden.',
        genericInstanceVariableAccess: 'Der Zugriff auf die generische Instanzvariable über die Klasse ist mehrdeutig.',
        genericNotAllowed: '"Generic" ist in diesem Kontext nicht gültig.',
        genericTypeAliasBoundTypeVar: 'Der generische Typalias innerhalb der Klasse kann keine gebundenen Typvariablen {names} verwenden.',
        genericTypeArgMissing: '"Generic" erfordert mindestens ein Typargument.',
        genericTypeArgTypeVar: 'Das Typargument für "Generic" muss eine Typvariable sein.',
        genericTypeArgUnique: 'Typargumente für "Generic" müssen eindeutig sein.',
        globalReassignment: '"{name}" wird vor einer globalen Deklaration zugewiesen.',
        globalRedefinition: '"{name}" wurde bereits als global deklariert.',
        implicitStringConcat: 'Implizite Zeichenfolgenverkettung nicht zulässig',
        importCycleDetected: 'Zyklus in Importkette erkannt',
        importDepthExceeded: 'Importkettentiefe überschritten {depth}',
        importResolveFailure: 'Import "{importName}" konnte nicht aufgelöst werden.',
        importSourceResolveFailure: 'Import "{importName}" konnte aus der Quelle nicht aufgelöst werden.',
        importSymbolUnknown: '"{name}" ist ein unbekanntes Importsymbol.',
        incompatibleMethodOverride: 'Die Methode "{name}" überschreibt die Klasse "{className}" auf inkompatible Weise.',
        inconsistentIndent: 'Der Betrag für Nichteinzug stimmt nicht mit dem vorherigen Einzug überein.',
        inconsistentTabs: 'Inkonsistente Verwendung von Tabulatoren und Leerzeichen im Einzug.',
        initMethodSelfParamTypeVar: 'Typ-Anmerkung für "self"-Parameter der "__init__"-Methode kann keine klassenübergreifenden Typvariablen enthalten',
        initMustReturnNone: 'Der Rückgabetyp von "__init__" muss "None" sein.',
        initSubclassCallFailed: 'Falsche Schlüsselwortargumente für __init_subclass__ Methode.',
        initSubclassClsParam: '__init_subclass__ Außerkraftsetzung sollte einen "cls"-Parameter annehmen.',
        initVarNotAllowed: '„InitVar“ ist in diesem Kontext nicht zulässig.',
        instanceMethodSelfParam: 'Instanzmethoden sollten einen "self"-Parameter verwenden.',
        instanceVarOverridesClassVar: 'Die Instanzvariable "{name}" überschreibt die Klassenvariable desselben Namens in der Klasse "{className}"',
        instantiateAbstract: 'Abstrakte Klasse "{type}" kann nicht erstellt werden.',
        instantiateProtocol: 'Die Protocol-Klasse "{type}" kann nicht instanziiert werden.',
        internalBindError: 'Interner Fehler beim Binden der Datei "{file}": {message}',
        internalParseError: 'Interner Fehler beim Parsen der Datei "{file}": {message}',
        internalTypeCheckingError: 'Interner Fehler bei der Typüberprüfung der Datei "{file}": {message}',
        invalidIdentifierChar: 'Ungültiges Zeichen in Bezeichner',
        invalidStubStatement: 'Die Anweisung ist innerhalb einer Typstubdatei bedeutungslos.',
        invalidTokenChars: 'Ungültiges Zeichen "{text}" im Token',
        isInstanceInvalidType: 'Das zweite Argument für "isinstance" muss eine Klasse oder tuple von Klassen sein.',
        isSubclassInvalidType: 'Das zweite Argument für "issubclass" muss eine Klasse oder tuple von Klassen sein.',
        keyValueInSet: 'Schlüssel-Wert-Paare sind innerhalb einer Menge „set“ nicht zulässig.',
        keywordArgInTypeArgument: 'Schlüsselwortargumente können nicht in Typargumentlisten verwendet werden.',
        keywordArgShortcutIllegal: 'Die Tastenkombination für Schlüsselwortargumente erfordert Python 3.14 oder höher.',
        keywordOnlyAfterArgs: 'Schlüsselworttrennzeichen ist nach dem Parameter "*" nicht zulässig.',
        keywordParameterMissing: 'Mindestens ein Schlüsselwortparameter muss dem Parameter "*" folgen.',
        keywordSubscriptIllegal: 'Schlüsselwortargumente innerhalb von Tiefskripts werden nicht unterstützt.',
        lambdaReturnTypePartiallyUnknown: 'Der Rückgabetyp des Lambdaausdrucks "{returnType}" ist teilweise unbekannt.',
        lambdaReturnTypeUnknown: 'Der Rückgabetyp der Lambdafunktion ist unbekannt.',
        listAssignmentMismatch: 'Ein Ausdruck vom Typ "{type}" kann der Zielliste nicht zugewiesen werden.',
        listInAnnotation: 'Der Listenausdruck ist im Typausdruck nicht zulässig',
        literalEmptyArgs: 'Nach "Literal" wurde mindestens ein Typargument erwartet.',
        literalNamedUnicodeEscape: 'Benannte Escapesequenz für Unicodezeichen werden in Zeichenfolgenanmerkungen vom Typ „Literal“ nicht unterstützt.',
        literalNotAllowed: '"Literal" kann in diesem Kontext nicht ohne Typargument verwendet werden.',
        literalNotCallable: 'Der Literaltyp kann nicht instanziiert werden.',
        literalUnsupportedType: 'Typargumente für "Literal" müssen None, ein Literalwert (int, bool, str oder bytes) oder ein enum Wert sein.',
        matchIncompatible: 'Match Anweisungen erfordern Python 3.10 oder höher',
        matchIsNotExhaustive: 'Fälle innerhalb der match-Anweisung behandeln nicht umfassend alle Werte.',
        maxParseDepthExceeded: 'Maximale Analysetiefe überschritten; brechen Sie den Ausdruck in kleinere Unterausdrücke um',
        memberAccess: 'Auf das Attribut „{name}“ für die Klasse „{type}“ kann nicht zugegriffen werden',
        memberDelete: 'Das Attribut „{name}“ für die Klasse „{type}“ kann nicht gelöscht werden',
        memberSet: 'Zum Attribut „{name}“ für die Klasse „{type}“ kann nicht zugewiesen werden',
        metaclassConflict: 'Die Metaklasse einer abgeleiteten Klasse muss eine Unterklasse der Metaklassen aller ihrer Basisklassen sein.',
        metaclassDuplicate: 'Es kann nur eine Metaklasse angegeben werden.',
        metaclassIsGeneric: 'Metaklasse kann nicht generisch sein.',
        methodNotDefined: '"{name}" Methode nicht definiert',
        methodNotDefinedOnType: 'Die Methode "{name}" ist für den Typ "{type}" nicht definiert.',
        methodOrdering: 'Es kann keine konsistente Methodenreihenfolge erstellt werden.',
        methodOverridden: '"{name}" überschreibt die Methode mit demselben Namen in der Klasse "{className}" mit inkompatiblem Typ "{type}"',
        methodReturnsNonObject: 'Die Methode "{name}" gibt kein Objekt zurück.',
        missingSuperCall: 'Die Methode "{methodName}" ruft nicht die Methode mit demselben Namen in der übergeordneten Klasse auf.',
        mixingBytesAndStr: 'Bytes- und str-Werte können nicht verkettet werden',
        moduleAsType: 'Das Modul kann nicht als Typ verwendet werden.',
        moduleNotCallable: 'Das Modul kann nicht aufgerufen werden.',
        moduleUnknownMember: '„{memberName}“ ist kein bekanntes Attribut des Moduls „{moduleName}“',
        namedExceptAfterCatchAll: 'Eine benannte except-Klausel darf nicht nach catch-all except-Klausel auftreten.',
        namedParamAfterParamSpecArgs: 'Der Schlüsselwortparameter "{name}" kann nicht in der Signatur nach dem Parameter "ParamSpec args" verwendet werden.',
        namedTupleEmptyName: 'Namen innerhalb benannten tuple dürfen nicht leer sein.',
        namedTupleEntryRedeclared: '"{name}" kann nicht überschrieben werden, da die übergeordnete benannte tuple Klasse "{className}" ist.',
        namedTupleFirstArg: 'Es wird ein benannter tuple Klassenname als erstes Argument erwartet.',
        namedTupleMultipleInheritance: 'Mehrfachvererbung mit NamedTuple wird nicht unterstützt.',
        namedTupleNameKeyword: 'Feldnamen dürfen kein Schlüsselwort sein.',
        namedTupleNameType: 'Es wurde tuple mit zwei Einträgen unter Angabe von Eintragsname und -typ erwartet.',
        namedTupleNameUnique: 'Namen innerhalb benannten tuple müssen eindeutig sein.',
        namedTupleNoTypes: '"namedtuple" stellt keine Typen für Tupeleinträge bereit; verwenden Sie stattdessen "NamedTuple".',
        namedTupleSecondArg: 'Benannte tuple Eintragsliste als zweites Argument erwartet',
        newClsParam: '__new__ Außerkraftsetzung sollte einen "cls"-Parameter annehmen.',
        newTypeAnyOrUnknown: 'Das zweite Argument für NewType muss eine bekannte Klasse sein, nicht „Any“ oder „Unknown“.',
        newTypeBadName: 'Das erste Argument für NewType muss ein Zeichenfolgenliteral sein.',
        newTypeLiteral: '"NewType" kann nicht mit dem Literaltyp verwendet werden.',
        newTypeNameMismatch: 'NewType muss einer Variablen mit demselben Namen zugewiesen werden.',
        newTypeNotAClass: 'Klasse als zweites Argument für NewType erwartet',
        newTypeParamCount: 'NewType erfordert zwei Positionsargumente.',
        newTypeProtocolClass: 'NewType kann nicht mit strukturellem Typ (Protocol- oder TypedDict-Klasse) verwendet werden.',
        noOverload: 'Keine Überladungen für "{name}" stimmen mit den angegebenen Argumenten überein.',
        noReturnContainsReturn: 'Eine Funktion mit dem deklarierten return Typ "NoReturn" kann keine return-Anweisung enthalten.',
        noReturnContainsYield: 'Eine Funktion mit dem deklarierten Rückgabetyp "NoReturn" kann keine yield-Anweisung enthalten.',
        noReturnReturnsNone: 'Eine Funktion mit dem deklarierten Rückgabetyp "NoReturn" kann nicht "None" zurückgeben.',
        nonDefaultAfterDefault: 'Das nicht standardmäßige Argument folgt dem Standardargument.',
        nonLocalInModule: 'Nonlocal Deklaration auf Modulebene nicht zulässig',
        nonLocalNoBinding: 'Es wurde keine Bindung für nonlocal "{name}" gefunden.',
        nonLocalReassignment: '"{name}" wird vor einer nonlocal Deklaration zugewiesen.',
        nonLocalRedefinition: '"{name}" wurde bereits als nonlocal deklariert.',
        noneNotCallable: 'Ein Objekt vom Typ "None" kann nicht aufgerufen werden.',
        noneNotIterable: 'Ein Objekt vom Typ "None" kann nicht als iterierbarer Wert verwendet werden.',
        noneNotSubscriptable: 'Das Objekt vom Typ "None" kann nicht tiefgestellt werden.',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Der Operator "{operator}" wird für den "{None}" nicht unterstützt.',
        noneUnknownMember: '„{name}“ ist kein bekanntes Attribut von „None“',
        notRequiredArgCount: 'Nach "NotRequired" wurde ein einzelnes Typargument erwartet.',
        notRequiredNotInTypedDict: '"NotRequired" ist in diesem Kontext nicht zulässig.',
        objectNotCallable: 'Das Objekt vom Typ "{type}" kann nicht aufgerufen werden.',
        obscuredClassDeclaration: 'Die Klassendeklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        obscuredFunctionDeclaration: 'Die Funktionsdeklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        obscuredMethodDeclaration: 'Die Methodendeklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        obscuredParameterDeclaration: 'Die Parameterdeklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        obscuredTypeAliasDeclaration: 'Die Typaliasdeklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        obscuredVariableDeclaration: 'Die Deklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        operatorLessOrGreaterDeprecated: 'Der Operator "<>" wird in Python 3 nicht unterstützt; verwenden Sie stattdessen "!=".',
        optionalExtraArgs: 'Nach "Optional" wurde ein Typargument erwartet.',
        orPatternIrrefutable: 'Ein irrefutables Muster ist nur als letztes Unterpattern in einem "or"-Muster zulässig.',
        orPatternMissingName: 'Alle Teilmuster innerhalb eines "or"-Musters müssen auf dieselben Namen zielen.',
        overlappingKeywordArgs: 'Typisierte Wörterbuchüberlappungen mit Schlüsselwortparameter: {names}',
        overlappingOverload: 'Überladung {obscured} für "{name}" wird nie verwendet, da sich die Parameter überlappen, {obscuredBy}',
        overloadAbstractImplMismatch: 'Überladungen müssen dem abstrakten Status der Implementierung entsprechen.',
        overloadAbstractMismatch: 'Überladungen müssen alle abstrakt sein oder nicht.',
        overloadClassMethodInconsistent: 'Überladungen für "{name}" verwenden @classmethod inkonsistent',
        overloadFinalInconsistencyImpl: 'Die Überladung für „{name}“ ist @final markiert, die Implementierung ist es jedoch nicht.',
        overloadFinalInconsistencyNoImpl: 'Überladung {index} für „{name}“ ist als @final markiert, Überladung 1 ist es jedoch nicht.',
        overloadImplementationMismatch: 'Die überladene Implementierung ist nicht konsistent mit der Signatur der Überladung {index}',
        overloadReturnTypeMismatch: 'Überladung {prevIndex} für "{name}" überlappt {newIndex} und gibt einen inkompatiblen Typ zurück.',
        overloadStaticMethodInconsistent: 'Überladungen für "{name}" verwenden @staticmethod inkonsistent',
        overloadWithoutImplementation: '"{name}" ist als overload markiert, es wurde jedoch keine Implementierung bereitgestellt.',
        overriddenMethodNotFound: 'Die Methode "{name}" ist als override markiert, aber es ist keine Basismethode mit demselben Namen vorhanden.',
        overrideDecoratorMissing: 'Die Methode "{name}" ist nicht als override markiert, überschreibt jedoch eine Methode in der Klasse "{className}"',
        paramAfterKwargsParam: 'Der Parameter kann nicht auf den Parameter "**" folgen.',
        paramAlreadyAssigned: 'Der Parameter "{name}" ist bereits zugewiesen.',
        paramAnnotationMissing: 'Typanmerkung fehlt für Parameter "{name}"',
        paramAssignmentMismatch: 'Ein Ausdruck vom Typ "{sourceType}" kann keinem Parameter vom Typ "{paramType}" zugewiesen werden.',
        paramNameMissing: 'Kein Parameter mit dem Namen "{name}"',
        paramSpecArgsKwargsDuplicate: 'Es wurden bereits Argumente für ParamSpec "{type}" bereitgestellt',
        paramSpecArgsKwargsUsage: 'Die Attribute „args“ und „kwargs“ von ParamSpec müssen beide innerhalb einer Funktionssignatur auftreten',
        paramSpecArgsMissing: 'Argumente für ParamSpec "{type}" fehlen.',
        paramSpecArgsUsage: 'Das Attribut „args“ von ParamSpec ist nur gültig, wenn es mit dem Parameter „*args“ verwendet wird',
        paramSpecAssignedName: 'ParamSpec muss einer Variablen mit dem Namen "{name}" zugewiesen werden.',
        paramSpecContext: 'ParamSpec ist in diesem Kontext nicht zulässig.',
        paramSpecDefaultNotTuple: 'Es wurde ein Auslassungszeichen, ein tuple Ausdruck oder ParamSpec für den Standardwert von ParamSpec erwartet.',
        paramSpecFirstArg: 'Der Name von ParamSpec wurde als erstes Argument erwartet.',
        paramSpecKwargsUsage: 'Das Attribut „kwargs“ von ParamSpec ist nur gültig, wenn es mit dem Parameter „**kwargs“ verwendet wird',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" hat in diesem Kontext keine Bedeutung.',
        paramSpecUnknownArg: 'ParamSpec unterstützt nur ein Argument.',
        paramSpecUnknownMember: '„{name}“ ist kein bekanntes Attribut von ParamSpec',
        paramSpecUnknownParam: '"{name}" ist ein unbekannter Parameter für ParamSpec.',
        paramTypeCovariant: 'Eine Variable vom Typ "Covariant" kann nicht im Parametertyp verwendet werden.',
        paramTypePartiallyUnknown: 'Der Typ des Parameters "{paramName}" ist teilweise unbekannt.',
        paramTypeUnknown: 'Der Typ des Parameters "{paramName}" ist unbekannt.',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Das Muster wird für den Antragstellertyp "{type}" nie abgeglichen',
        positionArgAfterNamedArg: 'Ein Positionsargument darf nicht nach Schlüsselwortargumenten stehen.',
        positionOnlyAfterArgs: 'Das Parametertrennzeichen "Nur Position" ist nach dem Parameter "*" nicht zulässig.',
        positionOnlyAfterKeywordOnly: 'Der Parameter "/" muss vor dem Parameter "*" stehen.',
        positionOnlyAfterNon: 'Der Parameter "Nur Position" ist nach einem Parameter, der nicht vom Typ "Nur Position" ist, nicht zulässig.',
        positionOnlyFirstParam: 'Das Parametertrennzeichen "Nur Position" ist als erster Parameter nicht zulässig.',
        positionOnlyIncompatible: 'Für das Parametertrennzeichen "Nur Position" ist Python 3.8 oder höher erforderlich.',
        privateImportFromPyTypedModule: '"{name}" wird nicht aus dem Modul "{module}" exportiert.',
        privateUsedOutsideOfClass: '"{name}" ist privat und wird außerhalb der Klasse verwendet, in dem es deklariert ist.',
        privateUsedOutsideOfModule: '"{name}" ist privat und wird außerhalb des Moduls verwendet, in dem es deklariert ist.',
        propertyOverridden: '"{name}" überschreibt property desselben Namens in der Klasse "{className}" nicht ordnungsgemäß',
        propertyStaticMethod: 'Statische Methoden sind für property getter, setter oder deleter nicht zulässig.',
        protectedUsedOutsideOfClass: '"{name}" ist geschützt und wird außerhalb der Klasse verwendet, in der es deklariert ist.',
        protocolBaseClass: 'Die Protocol-Klasse "{classType}" kann nicht von einer non-Protocol-Klasse "{baseType}" abgeleitet werden',
        protocolBaseClassWithTypeArgs: 'Typargumente sind mit der Protocol Klasse nicht zulässig, wenn die Typparametersyntax verwendet wird.',
        protocolIllegal: 'Die Verwendung von "Protocol" erfordert Python 3.7 oder höher.',
        protocolNotAllowed: '"Protocol" kann in diesem Kontext nicht verwendet werden.',
        protocolTypeArgMustBeTypeParam: 'Das Typargument für „Protocol“ muss ein Typparameter sein.',
        protocolUnsafeOverlap: 'Die Klasse überlappt unsicher mit „{name}“ und könnte zur Laufzeit eine Übereinstimmung erzeugen.',
        protocolVarianceContravariant: 'Die Typvariable "{variable}", die im generischen Protocol "{class}" verwendet wird, muss "contravariant" sein.',
        protocolVarianceCovariant: 'Die Typvariable "{variable}", die im generischen Protocol "{class}" verwendet wird, muss "covariant" sein.',
        protocolVarianceInvariant: 'Die Typvariable "{variable}", die im generischen Protocol "{class}" verwendet wird, muss "invariant" sein.',
        pyrightCommentInvalidDiagnosticBoolValue: 'Auf die Pyright-Kommentardirektive muss "=" und der Wert "true" oder "false" folgen.',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Auf die Pyright-Kommentardirektive muss "=" und der Wert "true", "false", "error", "warning", "information" oder "none" folgen.',
        pyrightCommentMissingDirective: 'Auf einen Pyright-Kommentar muss eine Direktive (basic oder strict) oder eine Diagnoseregel folgen.',
        pyrightCommentNotOnOwnLine: 'Pyright-Kommentare, die zum Steuern von Einstellungen auf Dateiebene verwendet werden, müssen in ihrer eigenen Zeile angezeigt werden.',
        pyrightCommentUnknownDiagnosticRule: '"{rule}" ist eine unbekannte Diagnoseregel für pyright-Kommentar.',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" ist ein ungültiger Wert für den pyright-Kommentar; "true", "false", "error", "warning", "information" oder "none" erwartet.',
        pyrightCommentUnknownDirective: '"{directive}" ist eine unbekannte Direktive für pyright-Kommentar; "strict" oder "basic" erwartet',
        readOnlyArgCount: 'Nach "ReadOnly" wurde ein einzelnes Typargument erwartet.',
        readOnlyNotInTypedDict: '"ReadOnly" ist in diesem Kontext nicht zulässig.',
        recursiveDefinition: 'Der Typ von "{name}" konnte nicht bestimmt werden, da er sich auf selbst bezieht.',
        relativeImportNotAllowed: 'Relative Importe können nicht mit dem Formular "import .a" verwendet werden; verwenden Sie stattdessen "from . import a"',
        requiredArgCount: 'Nach "Required" wurde ein einzelnes Typargument erwartet.',
        requiredNotInTypedDict: '"Required" ist in diesem Kontext nicht zulässig.',
        returnInAsyncGenerator: 'Eine Return-Anweisung mit einem Wert ist im asynchronen Generator nicht zulässig.',
        returnInExceptionGroup: '„return“ ist in einem „except*“ Block nicht zulässig.',
        returnMissing: 'Die Funktion mit dem deklarierten Rückgabetyp "{returnType}" muss einen Wert für alle Codepfade zurückgeben.',
        returnOutsideFunction: '"return" kann nur innerhalb einer Funktion verwendet werden.',
        returnTypeContravariant: 'Die Variable vom Typ "contravariant" kann nicht im Rückgabetyp verwendet werden.',
        returnTypeMismatch: 'Der Typ „{exprType}“ kann dem Rückgabetyp „{returnType}“ nicht zugewiesen werden',
        returnTypePartiallyUnknown: 'Der Rückgabetyp "{returnType}" ist teilweise unbekannt.',
        returnTypeUnknown: 'Unbekannter Rückgabetyp',
        revealLocalsArgs: 'Es wurden keine Argumente für den Aufruf "reveal_locals" erwartet.',
        revealLocalsNone: 'Keine locals Elemente in diesem Bereich',
        revealTypeArgs: 'Für den Aufruf "reveal_type" wurde ein einzelnes Positionsargument erwartet.',
        revealTypeExpectedTextArg: 'Das Argument "expected_text" für die Funktion "reveal_type" muss ein str-Literalwert sein.',
        revealTypeExpectedTextMismatch: 'Typentextkonflikt; "{expected}" erwartet, aber "{received}" empfangen',
        revealTypeExpectedTypeMismatch: 'Typenkonflikt; "{expected}" erwartet, aber "{received}" empfangen',
        selfTypeContext: '"Self" ist in diesem Kontext ungültig.',
        selfTypeMetaclass: '„Self“ kann nicht innerhalb einer Metaklasse (einer Unterklasse von „type“) verwendet werden.',
        selfTypeWithTypedSelfOrCls: '"Self" kann nicht in einer Funktion mit einem Parameter "self" oder "cls" verwendet werden, der eine andere Typanmerkung als "Self" aufweist.',
        setterGetterTypeMismatch: 'Der Property setter Werttyp kann dem getter Rückgabetyp nicht zugewiesen werden.',
        singleOverload: '"{name}" ist als Überladung markiert, aber es fehlen weitere Überladungen.',
        slotsAttributeError: '"{name}" ist in __slots__ nicht angegeben.',
        slotsClassVarConflict: '"{name}" steht in Konflikt mit Instanzvariablen, die in __slots__ deklariert sind.',
        starPatternInAsPattern: 'Das Sternmuster kann nicht mit dem Ziel "as" verwendet werden.',
        starPatternInOrPattern: 'Das Sternmuster kann in anderen Mustern nicht ORed sein.',
        starStarWildcardNotAllowed: '** kann nicht zusammen mit Platzhalter "_" verwendet werden',
        staticClsSelfParam: 'Statische Methoden dürfen keinen "self"- oder "cls"-Parameter annehmen.',
        stdlibModuleOverridden: '"{path}" überschreibt das stdlib-Modul "{name}"',
        stringNonAsciiBytes: 'Ein Nicht-ASCII-Zeichen ist im Zeichenfolgenliteral in Bytes nicht zulässig.',
        stringNotSubscriptable: 'Der Zeichenfolgenausdruck kann im Typausdruck nicht tiefgestellt werden; schließen Sie den samten Ausdruck in Anführungszeichen ein',
        stringUnsupportedEscape: 'Nicht unterstützte Escapesequenz im Zeichenfolgenliteral.',
        stringUnterminated: 'Das Zeichenfolgenliteral ist nicht beendet.',
        stubFileMissing: 'Die Stubdatei wurde für "{importName}" nicht gefunden.',
        stubUsesGetAttr: 'Die Typ-Stub-Datei ist unvollständig; "__getattr__" verdeckt Typfehler für Modul',
        sublistParamsIncompatible: 'Sublist Parameter werden in Python 3.x nicht unterstützt.',
        superCallArgCount: 'Es werden nicht mehr als zwei Argumente für den „super“ Aufruf erwartet.',
        superCallFirstArg: 'Klassentyp als erstes Argument für super-Aufruf erwartet, aber "{type}" empfangen',
        superCallSecondArg: 'Das zweite Argument für den "super"-Aufruf muss ein Objekt oder eine Klasse sein, das bzw. die von "{type}" abgeleitet wird.',
        superCallZeroArgForm: 'Die Nullargumentform des „super“ Aufrufs ist nur innerhalb einer Methode gültig.',
        superCallZeroArgFormStaticMethod: 'Die Nullargumentform des „super“ Aufrufs ist nicht innerhalb einer statischen Methode gültig.',
        symbolIsPossiblyUnbound: '"{name}" ist möglicherweise ungebunden.',
        symbolIsUnbound: '"{name}" ist ungebunden.',
        symbolIsUndefined: '"{name}" ist nicht definiert.',
        symbolOverridden: '"{name}" überschreibt das Symbol desselben Namens in der Klasse "{className}"',
        ternaryNotAllowed: 'Der ternäre Ausdruck ist im Typausdruck nicht zulässig',
        totalOrderingMissingMethod: 'Die Klasse muss "__lt__", "__le__", "__gt__" oder "__ge__" definieren, um total_ordering zu verwenden.',
        trailingCommaInFromImport: 'Nachgestelltes Komma ist ohne umgebende Klammern nicht zulässig.',
        tryWithoutExcept: 'Die try-Anweisung muss mindestens eine except- oder finally-Klausel aufweisen.',
        tupleAssignmentMismatch: 'Ein Ausdruck vom Typ "{type}" kann dem Ziel-tuple nicht zugewiesen werden.',
        tupleInAnnotation: 'Der Tuple-ausdruck ist im Typausdruck nicht zulässig',
        tupleIndexOutOfRange: 'Der Index {index} liegt für den Typ {type} außerhalb des gültigen Bereichs.',
        typeAliasIllegalExpressionForm: 'Ungültiges Ausdrucksformular für Typaliasdefinition',
        typeAliasIsRecursiveDirect: 'Der Typalias "{name}" kann sich nicht selbst in seiner Definition verwenden.',
        typeAliasNotInModuleOrClass: 'TypeAlias kann nur innerhalb eines Moduls oder Klassenbereichs definiert werden.',
        typeAliasRedeclared: '"{name}" ist als TypeAlias deklariert und kann nur einmal zugewiesen werden.',
        typeAliasStatementBadScope: 'Eine type Anweisung kann nur innerhalb eines Moduls oder Klassenbereichs verwendet werden.',
        typeAliasStatementIllegal: 'Die Typaliasanweisung erfordert Python 3.12 oder höher.',
        typeAliasTypeBaseClass: 'Ein in einer "type"-Anweisung definierter type Alias kann nicht als Basisklasse verwendet werden.',
        typeAliasTypeMustBeAssigned: 'TypeAliasType muss einer Variablen mit dem gleichen Namen wie der Typalias zugewiesen werden.',
        typeAliasTypeNameArg: 'Das erste Argument für TypeAliasType muss ein Zeichenfolgenliteral sein, das den Namen des Typalias darstellt.',
        typeAliasTypeNameMismatch: 'Der Name des Typalias muss mit dem Namen der Variablen übereinstimmen, der er zugewiesen ist.',
        typeAliasTypeParamInvalid: 'Die Typparameterliste muss tuple sein, das nur TypeVar, TypeVarTuple oder ParamSpec enthält.',
        typeAnnotationCall: 'Der Aufrufausdruck ist im Typausdruck nicht zulässig',
        typeAnnotationVariable: 'Variable im Typausdruck nicht zulässig',
        typeAnnotationWithCallable: 'Das Typargument für "type" muss eine Klasse sein. Aufrufbare Elemente werden nicht unterstützt.',
        typeArgListExpected: 'ParamSpec, Ellipse oder list der Typen erwartet',
        typeArgListNotAllowed: 'Der Listenausdruck ist für dieses Typargument nicht zulässig.',
        typeArgsExpectingNone: 'Für die Klasse "{name}" werden keine Typargumente erwartet.',
        typeArgsMismatchOne: 'Es wurde ein Typargument erwartet, es wurde jedoch {received} empfangen.',
        typeArgsMissingForAlias: 'Für den generischen Typalias "{name}" werden Typargumente erwartet.',
        typeArgsMissingForClass: 'Für die generische Klasse "{name}" werden Typargumente erwartet.',
        typeArgsTooFew: 'Für "{name}" wurden zu wenige Typargumente angegeben; {expected} erwartet, aber {received} empfangen',
        typeArgsTooMany: 'Für "{name}" wurden zu viele Typargumente angegeben; {expected} erwartet, aber {received} empfangen',
        typeAssignmentMismatch: 'Der Typ „{sourceType}“ kann dem deklarierten Typ „{destType}“ nicht zugewiesen werden',
        typeAssignmentMismatchWildcard: 'Das Importsymbol „{name}“ weist den Typ „{sourceType}“ auf, der dem deklarierten Typ „{destType}“ nicht zugewiesen werden kann.',
        typeCallNotAllowed: 'Der type()-Aufruf darf nicht im Typausdruck verwendet werden',
        typeCheckOnly: '"{name}" ist als @type_check_only markiert und kann nur in Typanmerkungen verwendet werden.',
        typeCommentDeprecated: 'Die Verwendung von type Kommentaren ist veraltet; verwenden Sie stattdessen type Anmerkung',
        typeExpectedClass: 'Die Klasse wurde erwartet, aber „{type}“ wurde empfangen.',
        typeFormArgs: '„TypeForm“ akzeptiert ein einzelnes positionelles Argument',
        typeGuardArgCount: 'Nach "TypeGuard" oder "TypeIs" wurde ein einzelnes Typargument erwartet.',
        typeGuardParamCount: 'Benutzerdefinierte Typenschutzfunktionen und -methoden müssen mindestens einen Eingabeparameter aufweisen.',
        typeIsReturnType: 'Der Rückgabetyp von TypeIs ("{returnType}") ist nicht konsistent mit dem Wertparametertyp ("{type}").',
        typeNotAwaitable: '"{type}" ist nicht awaitable.',
        typeNotIntantiable: '"{type}" kann nicht instanziiert werden.',
        typeNotIterable: '"{type}" ist nicht iterierbar.',
        typeNotSpecializable: 'Der Typ "{type}" konnte nicht spezialisiert werden',
        typeNotSubscriptable: 'Das Objekt vom Typ "{type}" kann nicht tiefgestellt werden.',
        typeNotSupportBinaryOperator: 'Der Operator "{operator}" wird für Typen "{leftType}" und "{rightType}" nicht unterstützt.',
        typeNotSupportBinaryOperatorBidirectional: 'Der Operator "{operator}" wird für die Typen "{leftType}" und "{rightType}" nicht unterstützt, wenn der erwartete Typ "{expectedType}" ist.',
        typeNotSupportUnaryOperator: 'Der Operator "{operator}" wird für den Typ "{type}" nicht unterstützt.',
        typeNotSupportUnaryOperatorBidirectional: 'Der Operator "{operator}" wird für den Typ "{type}" nicht unterstützt, wenn der erwartete Typ "{expectedType}" ist.',
        typeNotUsableWith: 'Ein Objekt vom Typ "{type}" kann nicht mit "with" verwendet werden, da es nicht {method} implementiert.',
        typeParameterBoundNotAllowed: '"Bound" oder "constraint" kann nicht mit einem variadic-Typparameter oder ParamSpec verwendet werden.',
        typeParameterConstraintTuple: 'Die Typparametereinschränkung muss ein Tupel mit mindestens zwei Typen sein.',
        typeParameterExistingTypeParameter: 'Der Typparameter "{name}" wird bereits verwendet.',
        typeParameterNotDeclared: 'Der Typparameter "{name}" ist nicht in der Typparameterliste für "{container}" enthalten.',
        typeParametersMissing: 'Es muss mindestens ein Typparameter angegeben werden.',
        typePartiallyUnknown: 'Der Typ von "{name}" ist teilweise unbekannt.',
        typeUnknown: 'Der Typ von "{name}" ist unbekannt.',
        typeVarAssignedName: 'TypeVar muss einer Variablen mit dem Namen "{name}" zugewiesen werden.',
        typeVarAssignmentMismatch: 'Der Typ "{type}" kann der Typvariablen "{name}" nicht zugewiesen werden.',
        typeVarBoundAndConstrained: 'TypeVar kann nicht gleichzeitig gebunden und eingeschränkt sein.',
        typeVarBoundGeneric: 'Der gebundene Typ "TypeVar" darf nicht generisch sein.',
        typeVarConstraintGeneric: 'Der Typ der TypeVar-Einschränkung darf nicht generisch sein.',
        typeVarDefaultBoundMismatch: 'Der Standardtyp "TypeVar" muss ein Untertyp des gebundenen Typs sein.',
        typeVarDefaultConstraintMismatch: 'Der Standardtyp "TypeVar" muss einer der eingeschränkten Typen sein.',
        typeVarDefaultIllegal: 'Für Standardtypen von Typvariablen ist Python 3.13 oder höher erforderlich.',
        typeVarDefaultInvalidTypeVar: 'Der Typparameter "{name}" weist einen Standardtyp auf, der auf eine oder mehrere Typvariablen verweist, die außerhalb des Gültigkeitsbereichs liegen.',
        typeVarFirstArg: 'Der Name von TypeVar wurde als erstes Argument erwartet.',
        typeVarInvalidForMemberVariable: 'Der Attributtyp kann keine Typvariable "{name}" verwenden, die auf die lokale Methode festgelegt ist.',
        typeVarNoMember: 'TypeVar „{type}“ weist kein Attribut „{name}“ auf',
        typeVarNotSubscriptable: 'TypeVar "{type}" kann nicht tiefgestellt werden.',
        typeVarNotUsedByOuterScope: 'Die Typvariable "{name}" hat in diesem Kontext keine Bedeutung.',
        typeVarPossiblyUnsolvable: 'Die Typvariable "{name}" wird möglicherweise nicht aufgelöst, wenn der Aufrufer kein Argument für Parameter "{param}" bereitstellt',
        typeVarSingleConstraint: 'TypeVar muss mindestens zwei eingeschränkte Typen aufweisen.',
        typeVarTupleConstraints: 'TypeVarTuple darf keine Werteinschränkungen aufweisen.',
        typeVarTupleContext: 'TypeVarTuple ist in diesem Kontext nicht zulässig.',
        typeVarTupleDefaultNotUnpacked: 'Der Standardtyp "TypeVarTuple" muss entpacktes tuple oder ein TypeVarTuple sein.',
        typeVarTupleMustBeUnpacked: 'Der Entpackungsoperator ist für den TypeVarTuple-Wert erforderlich.',
        typeVarTupleUnknownParam: '"{name}" ist ein unbekannter Parameter für TypeVarTuple.',
        typeVarUnknownParam: '"{name}" ist ein unbekannter Parameter für TypeVar.',
        typeVarUsedByOuterScope: 'TypeVar "{name}" wird bereits von einem äußeren Bereich verwendet.',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" wird in der generischen Funktionssignatur nur einmal angezeigt.',
        typeVarVariance: 'TypeVar darf nicht gleichzeitig "covariant" und "contravariant" sein.',
        typeVarWithDefaultFollowsVariadic: 'TypeVar „{typeVarName}“ weist einen Standardwert auf und kann TypeVarTuple „{variadicName}“ nicht folgen.',
        typeVarWithoutDefault: '"{name}" kann nicht nach "{other}" in der Typparameterliste angezeigt werden, da es keinen Standardtyp aufweist.',
        typeVarsNotInGenericOrProtocol: 'Generic[] oder Protocol[] müssen alle Typvariablen enthalten.',
        typedDictAccess: 'Auf das Element in TypedDict konnte nicht zugegriffen werden.',
        typedDictAssignedName: 'TypedDict muss einer Variablen mit dem Namen „{name}“ zugewiesen werden.',
        typedDictBadVar: 'TypedDict-Klassen dürfen nur Typanmerkungen enthalten.',
        typedDictBaseClass: 'Alle Basisklassen für TypedDict-Klassen müssen auch TypedDict-Klassen sein.',
        typedDictBoolParam: 'Es wird erwartet, dass "{name}" Parameter den Wert "True" oder "False" aufweist.',
        typedDictClosedExtras: 'Die Basisklasse „{name}“ ist ein closed TypedDict; zusätzliche Elemente müssen vom Typ „{type}“ sein.',
        typedDictClosedNoExtras: 'Die Basisklasse „{name}“ ist ein closed TypedDict; zusätzliche Elemente sind nicht zulässig.',
        typedDictDelete: 'Das Element in TypedDict konnte nicht gelöscht werden.',
        typedDictEmptyName: 'Namen innerhalb eines TypedDict dürfen nicht leer sein.',
        typedDictEntryName: 'Für den Wörterbucheintragsnamen wurde ein Zeichenfolgenliteral erwartet.',
        typedDictEntryUnique: 'Namen innerhalb eines Wörterbuchs müssen eindeutig sein.',
        typedDictExtraArgs: 'Zusätzliche TypedDict-Argumente werden nicht unterstützt.',
        typedDictExtraItemsClosed: 'Ein TypedDict kann nicht auf closed (geschlossen) gesetzt werden, wenn es zusätzliche Elemente unterstützt.',
        typedDictFieldNotRequiredRedefinition: 'Das TypedDict-Element „{name}“ kann nicht als „NotRequired“ neu definiert werden.',
        typedDictFieldReadOnlyRedefinition: 'Das TypedDict-Element „{name}“ kann nicht als „ReadOnly“ neu definiert werden.',
        typedDictFieldRequiredRedefinition: 'Das TypedDict-Element „{name}“ kann nicht als „Required“ neu definiert werden.',
        typedDictFirstArg: 'Der Klassenname "TypedDict" wird als erstes Argument erwartet.',
        typedDictInClassPattern: 'Die TypedDict-Klasse ist im Klassenmuster nicht zulässig.',
        typedDictInitsubclassParameter: 'TypedDict unterstützt __init_subclass__ Parameter „{name}“ nicht.',
        typedDictNotAllowed: '"TypedDict" kann in diesem Kontext nicht verwendet werden.',
        typedDictSecondArgDict: 'Es wird ein dict- oder Schlüsselwortparameter als zweiter Parameter erwartet.',
        typedDictSecondArgDictEntry: 'Einfacher Wörterbucheintrag erwartet',
        typedDictSet: 'Element konnte in TypedDict nicht zugewiesen werden.',
        unaccessedClass: 'Auf die Klasse "{name}" kann nicht zugegriffen werden.',
        unaccessedFunction: 'Auf die Funktion "{name}" kann nicht zugegriffen werden.',
        unaccessedImport: 'Auf den Import "{name}" kann nicht zugegriffen werden.',
        unaccessedSymbol: 'Auf "{name}" kann nicht zugegriffen werden.',
        unaccessedVariable: 'Auf die Variable "{name}" kann nicht zugegriffen werden.',
        unannotatedFunctionSkipped: 'Die Analyse der Funktion "{name}" wird übersprungen, da sie nicht kommentiert wurde.',
        unaryOperationNotAllowed: 'Der unäre Operator ist im Typausdruck nicht zulässig',
        unexpectedAsyncToken: 'Es wurde erwartet, dass "def", "with" oder "for" auf "async" folgt.',
        unexpectedExprToken: 'Unerwartetes Token am Ende des Ausdrucks.',
        unexpectedIndent: 'Unerwarteter Einzug',
        unexpectedUnindent: '"Unindent" nicht erwartet.',
        unhashableDictKey: 'Der Wörterbuchschlüssel muss hashbar sein.',
        unhashableSetEntry: 'Der Eintrag "Set" muss hashbar sein.',
        uninitializedAbstractVariables: 'In der abstrakten Basisklasse definierte Variablen sind in der final Klasse "{classType}" nicht initialisiert',
        uninitializedInstanceVariable: 'Die Instanzvariable "{name}" ist im Klassentext oder in der __init__ Methode nicht initialisiert.',
        unionForwardReferenceNotAllowed: 'Die Unionsyntax kann nicht mit einem Zeichenfolgenoperanden verwendet werden; verwenden Sie Anführungszeichen um den gesamten Ausdruck',
        unionSyntaxIllegal: 'Alternative Syntax für Unions erfordert Python 3.10 oder höher.',
        unionTypeArgCount: 'Union erfordert mindestens zwei Typargumente.',
        unionUnpackedTuple: 'Union kann kein entpacktes tuple enthalten.',
        unionUnpackedTypeVarTuple: 'Die Union kann kein entpacktes TypeVarTuple enthalten.',
        unnecessaryCast: 'Nicht erforderlicher "cast"-Aufruf; der Typ ist bereits "{type}".',
        unnecessaryIsInstanceAlways: 'Nicht erforderlicher isinstance-Aufruf; "{testType}" ist immer eine Instanz von "{classType}"',
        unnecessaryIsInstanceNever: 'Nicht erforderlicher isinstance-Aufruf; "{testType}" ist nie eine Instanz von "{classType}"',
        unnecessaryIsSubclassAlways: 'Nicht erforderlicher issubclass-Aufruf; "{testType}" ist immer eine Unterklasse von "{classType}"',
        unnecessaryIsSubclassNever: 'Nicht erforderlicher issubclass-Aufruf; "{testType}" ist nie eine Unterklasse von "{classType}"',
        unnecessaryPyrightIgnore: 'Unnötiger "# pyright: ignore"-Kommentar',
        unnecessaryPyrightIgnoreRule: 'Unnötiger "# pyright: ignore"-Regel: "{name}"',
        unnecessaryTypeIgnore: 'Nicht erforderlicher "# type: ignore"-Kommentar',
        unpackArgCount: 'Nach "Unpack" wurde ein einzelnes Typargument erwartet.',
        unpackExpectedTypeVarTuple: '„TypeVarTuple“ oder „tuple“ als Typargument für „Unpack“ erwartet',
        unpackExpectedTypedDict: 'TypedDict-Typargument für Unpack erwartet',
        unpackIllegalInComprehension: 'Der Entpackvorgang ist in Verständnis nicht zulässig.',
        unpackInAnnotation: 'Der Operator zum Entpacken ist im Typausdruck nicht zulässig',
        unpackInDict: 'Der Entpackvorgang ist in Wörterbüchern nicht zulässig.',
        unpackInSet: 'Der Operator zum Entpacken ist innerhalb einer Menge „set“ nicht zulässig.',
        unpackNotAllowed: '"Unpack" ist in diesem Kontext nicht zulässig.',
        unpackOperatorNotAllowed: 'Der Entpackvorgang ist in diesem Kontext nicht zulässig.',
        unpackTuplesIllegal: 'Der Entpackvorgang ist in Tupeln vor Python 3.8 nicht zulässig.',
        unpackedArgInTypeArgument: 'Nicht gepackte Argumente können in diesem Kontext nicht verwendet werden.',
        unpackedArgWithVariadicParam: 'Das nicht gepackte Argument kann nicht für den Parameter "TypeVarTuple" verwendet werden.',
        unpackedDictArgumentNotMapping: 'Der Argumentausdruck nach ** muss eine Zuordnung mit dem Schlüsseltyp "str" sein.',
        unpackedDictSubscriptIllegal: 'Der Operator zum Entpacken des Wörterbuchs in tiefgestellten Zeichen ist nicht zulässig.',
        unpackedSubscriptIllegal: 'Das Entpacken des Operators im Tiefstellungsskript erfordert Python 3.11 oder höher.',
        unpackedTypeVarTupleExpected: 'Nicht gepackter TypeVarTuple erwartet; verwenden Sie Unpack[{name1}] oder *{name2}',
        unpackedTypedDictArgument: 'Das entpackte TypedDict-Argument kann nicht mit Parametern abgelichen werden.',
        unreachableCode: 'Der Code ist nicht erreichbar.',
        unreachableCodeType: 'Typanalyse weist darauf hin, dass Code nicht erreichbar ist',
        unreachableExcept: 'Die except-Klausel ist nicht erreichbar, weil die Ausnahme bereits behandelt wird.',
        unsupportedDunderAllOperation: 'Der Vorgang für "__all__" wird nicht unterstützt, daher ist die exportierte Symbolliste möglicherweise falsch.',
        unusedCallResult: 'Das Ergebnis des Aufrufausdrucks ist vom Typ "{type}" und wird nicht verwendet; der Variablen "_" zuweisen, wenn dies beabsichtigt ist',
        unusedCoroutine: 'Das Ergebnis eines asynchronen Funktionsaufrufs wird nicht verwendet; verwenden Sie "await", oder weisen Sie der Variablen ein Ergebnis zu.',
        unusedExpression: 'Der Ausdruckswert wird nicht verwendet.',
        varAnnotationIllegal: 'Type Anmerkungen für Variablen erfordern Python 3.6 oder höher; verwenden Sie den type Kommentar für Kompatibilität mit früheren Versionen',
        variableFinalOverride: 'Die Variable "{name}" ist als "Final" gekennzeichnet und überschreibt die Nicht-Final-Variable desselben Namens in der Klasse "{className}"',
        variadicTypeArgsTooMany: 'Die Liste der Typargumente darf höchstens ein entpacktes „TypeVarTuple“ oder „tuple“ enthalten.',
        variadicTypeParamTooManyAlias: 'Der Typalias darf höchstens einen TypeVarTuple-Typparameter aufweisen, es wurden jedoch mehrere ({names}) empfangen.',
        variadicTypeParamTooManyClass: 'Die generische Klasse darf höchstens einen TypeVarTuple-Typparameter aufweisen, es wurden jedoch mehrere ({names}) empfangen.',
        walrusIllegal: 'Der Operator ":=" erfordert Python 3.8 oder höher.',
        walrusNotAllowed: 'Der Operator ":=" ist in diesem Kontext ohne umgebende Klammern nicht zulässig.',
        wildcardInFunction: 'Der Platzhalterimport ist innerhalb einer Klasse oder Funktion nicht zulässig.',
        wildcardLibraryImport: 'Der Platzhalterimport aus einer Bibliothek ist nicht zulässig.',
        wildcardPatternTypePartiallyUnknown: 'Der durch das Platzhaltermuster erfasste Typ ist teilweise unbekannt.',
        wildcardPatternTypeUnknown: 'Der durch das Platzhaltermuster erfasste Typ ist unbekannt.',
        yieldFromIllegal: 'Die Verwendung von "yield from" erfordert Python 3.3 oder höher.',
        yieldFromOutsideAsync: '"yield from" ist in einer asynchronen Funktion nicht zulässig.',
        yieldOutsideFunction: '"yield" ist außerhalb einer Funktion oder eines Lambdas nicht zulässig.',
        yieldWithinComprehension: '„yield“ ist innerhalb eines Verständnisses nicht zulässig',
        zeroCaseStatementsFound: 'Die match-Anweisung muss mindestens eine case-Anweisung enthalten',
        zeroLengthTupleNotAllowed: 'Zero-length tuple is not allowed in this context'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Das Sonderformular „Annotated“ kann nicht mit Instanz- und Klassenüberprüfungen verwendet werden.',
        argParam: 'Argument entspricht Parameter "{paramName}"',
        argParamFunction: 'Argument entspricht Parameter "{paramName}" in Funktion "{functionName}"',
        argsParamMissing: 'Der Parameter "*{paramName}" weist keinen entsprechenden Parameter auf.',
        argsPositionOnly: 'Nicht übereinstimmende Parameteranmerkungsanzahl: {expected} erwartet, aber {received} empfangen',
        argumentType: 'Argumenttyp ist "{type}"',
        argumentTypes: 'Argumenttypen: ({types})',
        assignToNone: 'Der Typ kann nicht „None“ zugewiesen werden.',
        asyncHelp: 'Meinten Sie "async with"?',
        baseClassIncompatible: 'Die Basisklasse "{baseClass}" ist nicht mit dem Typ "{type}" kompatibel.',
        baseClassIncompatibleSubclass: 'Die Basisklasse "{baseClass}" wird von "{subclass}" abgeleitet, die mit dem Typ "{type}" nicht kompatibel ist.',
        baseClassOverriddenType: 'Die Basisklasse "{baseClass}" stellt einen Typ "{type}" bereit, der überschrieben wird.',
        baseClassOverridesType: 'Basisklasse "{baseClass}" überschreibt mit Typ "{type}"',
        bytesTypePromotions: 'Legen Sie disableBytesTypePromotions auf false fest, um das Typerweiterungsverhalten für "bytearray" und "memoryview" zu aktivieren.',
        conditionalRequiresBool: 'Die Methode __bool__ für den Typ "{operandType}" gibt den Typ "{boolReturnType}" anstelle von "bool" zurück',
        dataClassFieldLocation: 'Felddeklaration',
        dataClassFrozen: '"{name}" ist fixiert',
        dataProtocolUnsupported: '„{name}“ ist ein Datenprotokoll.',
        descriptorAccessBindingFailed: 'Fehler beim Binden der Methode „{name}“ für die Deskriptorklasse „{className}“',
        descriptorAccessCallFailed: 'Fehler beim Aufrufen der Methode „{name}“ für die Deskriptorklasse „{className}“',
        finalMethod: 'Final Methode',
        functionParamDefaultMissing: 'Standardargument für Parameter "{name}" fehlt.',
        functionParamName: 'Parameternamen stimmen nicht überein: "{destName}" und "{srcName}"',
        functionParamPositionOnly: 'Nicht übereinstimmender Parameter „nur für Position“. Der Parameter „{name}“ ist nicht „nur für Position“.',
        functionReturnTypeMismatch: 'Der Funktionsrückgabetyp "{sourceType}" ist nicht mit dem Typ "{destType}" kompatibel.',
        functionTooFewParams: 'Die Funktion akzeptiert zu wenige Positionsparameter; {expected} erwartet, aber {received} empfangen',
        functionTooManyParams: 'Die Funktion akzeptiert zu viele Positionsparameter; {expected} erwartet, aber {received} empfangen',
        genericClassNotAllowed: 'Ein generischer Typ mit Typargumenten ist für Instanz- oder Klassenprüfungen nicht zulässig.',
        incompatibleDeleter: 'Die deleter Methode der Property ist nicht kompatibel.',
        incompatibleGetter: 'Die Property getter Methode ist nicht kompatibel.',
        incompatibleSetter: 'Die Property setter Methode ist nicht kompatibel.',
        initMethodLocation: 'Die __init__ Methode ist in der Klasse "{type}" definiert.',
        initMethodSignature: 'Die Signatur von __init__ ist "{type}".',
        initSubclassLocation: 'Die __init_subclass__ Methode ist in der Klasse "{name}" definiert.',
        invariantSuggestionDict: 'Erwägen Sie den Wechsel von "dict" zu "Mapping" (im Werttyp covariant).',
        invariantSuggestionList: 'Erwägen Sie den Wechsel von "list" zu "Sequence" (covariant).',
        invariantSuggestionSet: 'Erwägen Sie den Wechsel von „set“ zu „Container“, der Kovariante ist.',
        isinstanceClassNotSupported: '„{type}“ wird für Instanz- und Klassenüberprüfungen nicht unterstützt.',
        keyNotRequired: '"{name}" ist kein erforderlicher Schlüssel in "{type}". Der Zugriff kann daher zu einer Laufzeitausnahme führen.',
        keyReadOnly: '"{name}" ist ein schreibgeschützter Schlüssel in "{type}"',
        keyRequiredDeleted: '"{name}" ist ein erforderlicher Schlüssel und kann nicht gelöscht werden.',
        keyUndefined: '"{name}" ist kein definierter Schlüssel in "{type}"',
        kwargsParamMissing: 'Der Parameter "**{paramName}" weist keinen entsprechenden Parameter auf.',
        listAssignmentMismatch: 'Der Typ "{type}" ist nicht mit der Zielliste kompatibel.',
        literalAssignmentMismatch: '„{sourceType}“ kann dem Typ „{destType}“ nicht zugewiesen werden.',
        matchIsNotExhaustiveHint: 'Wenn keine ausführliche Behandlung beabsichtigt ist, fügen Sie "case _: pass" hinzu.',
        matchIsNotExhaustiveType: 'Unbehandelter Typ: "{type}"',
        memberAssignment: 'Ein Ausdruck vom Typ „{type}“ kann dem Attribut „{name}“ der Klasse „{classType}“ nicht zugewiesen werden',
        memberIsAbstract: '„{type}. {name}“ ist nicht implementiert.',
        memberIsAbstractMore: 'und {count} weitere...',
        memberIsClassVarInProtocol: '„{name}“ ist als ClassVar im Protokoll definiert.',
        memberIsInitVar: '„{name}“ ist ein init-only-Feld.',
        memberIsInvariant: '"{name}" ist invariant, da es änderbar ist.',
        memberIsNotClassVarInClass: '„{name}“ muss als ClassVar definiert sein, um mit dem Protokoll kompatibel zu sein.',
        memberIsNotClassVarInProtocol: '„{name}“ ist nicht als ClassVar im Protokoll definiert.',
        memberIsNotReadOnlyInProtocol: '"{name}" ist im Protokoll nicht schreibgeschützt.',
        memberIsReadOnlyInProtocol: '"{name}" ist im Protokoll schreibgeschützt.',
        memberIsWritableInProtocol: '"{name}" ist im Protokoll beschreibbar.',
        memberSetClassVar: 'Attribut „{name}“ kann nicht über eine Klasseninstanz zugewiesen werden, da es sich um eine ClassVar handelt',
        memberTypeMismatch: '"{name}" ist ein inkompatibler Typ.',
        memberUnknown: 'Das Attribut „{name}“ ist unbekannt',
        metaclassConflict: 'Die Metaklasse "{metaclass1}" verursacht einen Konflikt mit "{metaclass2}"',
        missingDeleter: 'Die Property deleter Methode fehlt.',
        missingGetter: 'Die Property getter Methode fehlt.',
        missingSetter: 'Die Property setter Methode fehlt.',
        namedParamMissingInDest: 'Zusätzlicher Parameter "{name}"',
        namedParamMissingInSource: 'Fehlender Schlüsselwortparameter "{name}"',
        namedParamTypeMismatch: 'Der Schlüsselwortparameter „{name}“ vom Typ „{sourceType}“ ist nicht mit dem Typ „{destType}“ kompatibel',
        namedTupleNotAllowed: 'NamedTuple kann nicht für Instanzen- oder Klassenüberprüfungen verwendet werden.',
        newMethodLocation: 'Die __new__ Methode ist in der Klasse "{type}" definiert.',
        newMethodSignature: 'Signatur von __new__ ist "{type}"',
        newTypeClassNotAllowed: 'Die mit NewType erstellte Klasse kann nicht mit Instanz- und Klassenüberprüfungen verwendet werden.',
        noOverloadAssignable: 'Keine überladene Funktion stimmt mit dem Typ "{type}" überein.',
        noneNotAllowed: '"None" kann nicht für Instanz- oder Klassenprüfungen verwendet werden.',
        orPatternMissingName: 'Fehlende Namen: {name}',
        overloadIndex: 'Überladung "{index}" ist die nächste Übereinstimmung.',
        overloadNotAssignable: 'Mindestens eine Überladung von "{name}" kann nicht zugewiesen werden.',
        overloadSignature: 'Die Überladungssignatur ist hier definiert.',
        overriddenMethod: 'Überschriebene Methode',
        overriddenSymbol: 'Außer Kraft gesetztes Symbol',
        overrideInvariantMismatch: 'Der Überschreibungstyp "{overrideType}" ist nicht identisch mit dem Basistyp "{baseType}".',
        overrideIsInvariant: 'Die Variable ist veränderlich, sodass ihr Typ unveränderlich ist.',
        overrideNoOverloadMatches: 'Keine Überladungssignatur in Überschreibung ist mit der Basismethode kompatibel.',
        overrideNotClassMethod: 'Die Basismethode ist als classmethod deklariert, die Überschreibung jedoch nicht',
        overrideNotInstanceMethod: 'Die Basismethode ist als Instanz deklariert, die Überschreibung jedoch nicht',
        overrideNotStaticMethod: 'Die Basismethode ist als staticmethod deklariert, die Überschreibung jedoch nicht',
        overrideOverloadNoMatch: 'Außerkraftsetzung behandelt nicht alle Überladungen der Basismethode.',
        overrideOverloadOrder: 'Überladungen für die Überschreibungsmethode müssen in der gleichen Reihenfolge wie die Basismethode vorliegen.',
        overrideParamKeywordNoDefault: 'Konflikt mit Schlüsselwortparameter "{name}": Der Basisparameter hat einen Standardargumentwert, der Außerkraftsetzungsparameter ist nicht identisch.',
        overrideParamKeywordType: 'Schlüsselwortparameter "{name}" Typenkonflikt: Basisparameter ist Typ "{baseType}", Überschreibungsparameter ist Typ "{overrideType}"',
        overrideParamName: 'Namenskonflikt mit Parameter {index}: Der Basisparameter hat den Namen "{baseName}", der Außerkraftsetzungsparameter ist "{overrideName}"',
        overrideParamNameExtra: 'Der Parameter "{name}" fehlt in der Basis.',
        overrideParamNameMissing: 'Der Parameter "{name}" fehlt in der Außerkraftsetzung.',
        overrideParamNamePositionOnly: 'Parameter „{index}“ stimmt nicht überein: Basisparameter „{baseName}“ ist Schlüsselwortparameter, Außerkraftsetzungsparameter ist „position-only“.',
        overrideParamNoDefault: 'Konflikt mit Parameter {index}: Der Basisparameter hat einen Standardargumentwert, der Außerkraftsetzungsparameter ist nicht identisch.',
        overrideParamType: 'Parameter {index} Typenkonflikt: Basisparameter ist Typ "{baseType}", Überschreibungsparameter ist Typ "{overrideType}"',
        overridePositionalParamCount: 'Anzahl der Positionsparameter stimmt nicht überein; die Basismethode hat {baseCount}, aber die Überschreibung hat {overrideCount}',
        overrideReturnType: 'Rückgabetypkonflikt: Basismethode gibt Typ "{baseType}" zurück, Überschreibung gibt Typ "{overrideType}" zurück',
        overrideType: 'Die Basisklasse definiert den Typ als "{type}"',
        paramAssignment: 'Parameter „{index}“: Typ „{sourceType}“ ist nicht mit dem Typ „{destType}“ kompatibel',
        paramSpecMissingInOverride: 'Parameter "ParamSpec" fehlen in der Überschreibungsmethode.',
        paramType: 'Parametertyp ist "{paramType}"',
        privateImportFromPyTypedSource: 'Stattdessen aus "{module}" importieren',
        propertyAccessFromProtocolClass: 'Auf eine in einer Protokollklasse definierte Eigenschaft kann nicht als Klassenvariable zugegriffen werden.',
        propertyMethodIncompatible: 'Die Property-Methode "{name}" ist inkompatibel.',
        propertyMethodMissing: 'Die Property-Methode "{name}" fehlt in der Überschreibung.',
        propertyMissingDeleter: 'Property "{name}" hat keinen definierten deleter.',
        propertyMissingSetter: 'Property "{name}" hat keinen definierten setter.',
        protocolIncompatible: '"{sourceType}" ist nicht mit dem Protokoll "{destType}" kompatibel.',
        protocolMemberMissing: '"{name}" ist nicht vorhanden.',
        protocolRequiresRuntimeCheckable: 'Die Protocol Klasse muss @runtime_checkable sein, damit sie mit Instanz- und Klassenprüfungen verwendet werden kann.',
        protocolSourceIsNotConcrete: '"{sourceType}" ist kein konkreter Klassentyp und kann dem Typ "{destType}" nicht zugewiesen werden.',
        protocolUnsafeOverlap: 'Attribute von „{name}“ weisen die gleichen Namen wie das Protokoll auf.',
        pyrightCommentIgnoreTip: 'Verwenden Sie "# pyright: ignore[<diagnostic rules>]", um die Diagnose für eine einzelne Zeile zu unterdrücken.',
        readOnlyAttribute: 'Das Attribut "{name}" ist schreibgeschützt.',
        seeClassDeclaration: 'Siehe Klassendeklaration',
        seeDeclaration: 'Siehe Deklaration',
        seeFunctionDeclaration: 'Siehe Funktionsdeklaration',
        seeMethodDeclaration: 'Siehe Methodendeklaration',
        seeParameterDeclaration: 'Siehe Parameterdeklaration',
        seeTypeAliasDeclaration: 'Siehe Typaliasdeklaration',
        seeVariableDeclaration: 'Siehe Variablendeklaration',
        tupleAssignmentMismatch: 'Der Typ "{type}" ist nicht mit dem Ziel-tuple kompatibel.',
        tupleEntryTypeMismatch: 'Der Tuple-eintrag {entry} ist ein falscher Typ.',
        tupleSizeIndeterminateSrc: 'Nicht übereinstimmende Tuple Größe; {expected} erwartet, aber unbestimmt empfangen',
        tupleSizeIndeterminateSrcDest: 'Nicht übereinstimmende Tuple Größe; {expected} oder mehr erwartet, aber „unbestimmt“ empfangen',
        tupleSizeMismatch: 'Nicht übereinstimmende Tuple Größe; {expected} erwartet, aber {received} empfangen',
        tupleSizeMismatchIndeterminateDest: 'Nicht übereinstimmende Tuple Größe; {expected} oder mehr erwartet, aber {received} empfangen',
        typeAliasInstanceCheck: 'Der mit der „type“-Anweisung erstellte Typalias kann nicht mit Instanz- und Klassenüberprüfungen verwendet werden.',
        typeAssignmentMismatch: 'Der Typ „{sourceType}“ kann dem Typ „{destType}“ nicht zugewiesen werden.',
        typeBound: 'Der Typ „{sourceType}“ kann der oberen Grenze „{destType}“ für die Typvariable „{name}“ nicht zugewiesen werden.',
        typeConstrainedTypeVar: 'Der Typ „{type}“ kann der eingeschränkten Typvariablen „{name}“ nicht zugewiesen werden',
        typeIncompatible: '„{sourceType}“ kann „{destType}“ nicht zugewiesen werden.',
        typeNotClass: '"{type}" ist keine Klasse.',
        typeNotStringLiteral: '"{type}" ist kein Zeichenfolgenliteral.',
        typeOfSymbol: 'Der Typ von "{name}" ist "{type}".',
        typeParamSpec: 'Typ "{type}" ist nicht mit ParamSpec "{name}" kompatibel.',
        typeUnsupported: 'Typ "{type}" wird nicht unterstützt.',
        typeVarDefaultOutOfScope: 'Die Typvariable "{name}" befindet sich nicht im Bereich.',
        typeVarIsContravariant: 'Der Typparameter "{name}" ist kontravariant, aber "{sourceType}" ist kein Supertyp von "{destType}"',
        typeVarIsCovariant: 'Der Typparameter "{name}" ist kovariant, aber "{sourceType}" ist kein Untertyp von "{destType}"',
        typeVarIsInvariant: 'Der Typparameter "{name}" ist invariant, "{sourceType}" ist jedoch nicht identisch mit "{destType}"',
        typeVarNotAllowed: 'TypeVar ist für Instanz- oder Klassenprüfungen nicht zulässig.',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple kann nicht an tuple unbekannter Länge gebunden werden.',
        typeVarUnnecessarySuggestion: 'Stattdessen {type} verwenden',
        typeVarUnsolvableRemedy: 'Geben Sie eine Überladung an, die den Rückgabetyp angibt, wenn das Argument nicht angegeben ist.',
        typeVarsMissing: 'Fehlende Typvariablen: {names}',
        typedDictBaseClass: 'Die Klasse "{type}" ist kein TypedDict.',
        typedDictClassNotAllowed: 'Die TypedDict-Klasse ist für Instanz- oder Klassenüberprüfungen nicht zulässig.',
        typedDictClosedExtraNotAllowed: 'Das Element „{name}“ kann nicht hinzugefügt werden.',
        typedDictClosedExtraTypeMismatch: 'Das Element „{name}“ mit dem Typ „{type}“ kann nicht hinzugefügt werden.',
        typedDictClosedFieldNotRequired: 'Das Element „{name}“ kann nicht hinzugefügt werden, da es „NotRequired“ sein muss.',
        typedDictExtraFieldNotAllowed: '„{name}“ ist in „{type}“ nicht vorhanden.',
        typedDictExtraFieldTypeMismatch: 'Der Typ von „{name}“ ist nicht mit dem Typ „extra_items“ in „{type}“ kompatibel.',
        typedDictFieldMissing: '"{name}" fehlt in "{type}"',
        typedDictFieldNotReadOnly: '"{name}" ist in "{type}" nicht schreibgeschützt.',
        typedDictFieldNotRequired: '"{name}" ist in "{type}" nicht erforderlich.',
        typedDictFieldRequired: '"{name}" ist in "{type}" erforderlich.',
        typedDictFieldTypeMismatch: 'Der Typ „{type}“ kann dem Element „{name}“ nicht zugewiesen werden.',
        typedDictFieldUndefined: '„{name}“ ist ein nicht definiertes Element im Typ „{type}“.',
        typedDictFinalMismatch: '"{sourceType}" ist aufgrund eines @final-Konflikts nicht mit "{destType}" kompatibel.',
        typedDictKeyAccess: '["{name}"] verwenden, um in TypedDict auf ein Element zu verweisen',
        typedDictNotAllowed: 'TypedDict kann nicht für Instanzen- oder Klassenüberprüfungen verwendet werden.',
        unhashableType: 'Der Typ "{type}" kann nicht mit einem Hash erstellt werden.',
        uninitializedAbstractVariable: 'Die Instanzvariable "{name}" ist in einer abstrakten Basisklasse "{classType}" definiert, aber nicht initialisiert.',
        unreachableExcept: '"{exceptionType}" ist eine Unterklasse von "{parentType}"',
        useDictInstead: 'Verwenden Sie Dict[T1, T2], um einen Wörterbuchtyp anzugeben.',
        useListInstead: 'Verwenden Sie List[T], um einen list Typ anzugeben, oder Union[T1, T2], um einen union-Typ anzugeben.',
        useTupleInstead: 'Verwenden Sie tuple[T1, ..., Tn], um einen tuple-Typ anzugeben, oder Union[T1, T2], um einen union-Typ anzugeben.',
        useTypeInstead: 'Stattdessen Type[T] verwenden',
        varianceMismatchForClass: 'Die Varianz des Typarguments "{typeVarName}" ist nicht mit der Basisklasse "{className}" kompatibel',
        varianceMismatchForTypeAlias: 'Die Varianz des Typarguments "{typeVarName}" ist nicht mit "{typeAliasParam}" kompatibel'
      },
      Service: {
        longOperation: 'Das Aufzählen von Arbeitsbereichsquelldateien nimmt viel Zeit in Anspruch. Erwägen Sie stattdessen, einen Unterordner zu öffnen. [Weitere Informationen](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  84268: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: {
          message: 'Create Type Stub',
          comment: '{Locked=\'Stub\'}'
        },
        createTypeStubFor: {
          message: 'Create Type Stub For "{moduleName}"',
          comment: '{Locked=\'Stub\'}'
        },
        executingCommand: 'Executing command',
        filesToAnalyzeCount: '{count} files to analyze',
        filesToAnalyzeOne: '1 file to analyze',
        findingReferences: 'Finding references',
        organizeImports: 'Organize Imports',
        renameShadowedFile: 'Rename "{oldFile}" to "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Auto-import',
        indexValueDetail: 'Index value'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Method "{method}" cannot be called because it is abstract and unimplemented',
        annotatedMetadataInconsistent: 'Annotated metadata type "{metadataType}" is not compatible with type "{type}"',
        annotatedParamCountMismatch: 'Parameter annotation count mismatch: expected {expected} but received {received}',
        annotatedTypeArgMissing: {
          message: 'Expected one type argument and one or more annotations for "Annotated"',
          comment: '{Locked=\'Annotated\'}'
        },
        annotationBytesString: 'Type expressions cannot use bytes string literals',
        annotationFormatString: {
          message: 'Type expressions cannot use format string literals (f-strings)',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        annotationNotSupported: 'Type annotation not supported for this statement',
        annotationRawString: 'Type expressions cannot use raw string literals',
        annotationSpansStrings: 'Type expressions cannot span multiple string literals',
        annotationStringEscape: 'Type expressions cannot contain escape characters',
        argAssignment: 'Argument of type "{argType}" cannot be assigned to parameter of type "{paramType}"',
        argAssignmentFunction: 'Argument of type "{argType}" cannot be assigned to parameter of type "{paramType}" in function "{functionName}"',
        argAssignmentParam: 'Argument of type "{argType}" cannot be assigned to parameter "{paramName}" of type "{paramType}"',
        argAssignmentParamFunction: 'Argument of type "{argType}" cannot be assigned to parameter "{paramName}" of type "{paramType}" in function "{functionName}"',
        argMissingForParam: 'Argument missing for parameter {name}',
        argMissingForParams: 'Arguments missing for parameters {names}',
        argMorePositionalExpectedCount: 'Expected {expected} more positional arguments',
        argMorePositionalExpectedOne: 'Expected 1 more positional argument',
        argPositional: 'Expected positional argument',
        argPositionalExpectedCount: 'Expected {expected} positional arguments',
        argPositionalExpectedOne: 'Expected 1 positional argument',
        argTypePartiallyUnknown: 'Argument type is partially unknown',
        argTypeUnknown: 'Argument type is unknown',
        assertAlwaysTrue: {
          message: 'Assert expression always evaluates to true',
          comment: '{Locked=\'true\'}'
        },
        assertTypeArgs: {
          message: '"assert_type" expects two positional arguments',
          comment: '{Locked=\'assert_type\'}'
        },
        assertTypeTypeMismatch: {
          message: '"assert_type" mismatch: expected "{expected}" but received "{received}"',
          comment: '{Locked=\'assert_type\'}'
        },
        assignmentExprComprehension: {
          message: 'Assignment expression target "{name}" cannot use same name as comprehension for target',
          comment: 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable'
        },
        assignmentExprContext: 'Assignment expression must be within module, function or lambda',
        assignmentExprInSubscript: 'Assignment expressions within a subscript are supported only in Python 3.10 and newer',
        assignmentInProtocol: {
          message: 'Instance or class variables within a Protocol class must be explicitly declared within the class body',
          comment: '{Locked=\'Protocol\'}'
        },
        assignmentTargetExpr: 'Expression cannot be assignment target',
        asyncNotInAsyncFunction: {
          message: 'Use of "async" not allowed outside of async function',
          comment: '{Locked=\'async\'}'
        },
        awaitIllegal: {
          message: 'Use of "await" requires Python 3.5 or newer',
          comment: '{Locked=\'await\'}'
        },
        awaitNotAllowed: {
          message: 'Type expressions cannot use "await"',
          comment: '{Locked=\'await\'}'
        },
        awaitNotInAsync: {
          message: '"await" allowed only within async function',
          comment: '{Locked=\'await\',\'async\'}'
        },
        backticksIllegal: {
          message: 'Expressions surrounded by backticks are not supported in Python 3.x; use repr instead',
          comment: '{Locked=\'repr\'}'
        },
        baseClassCircular: 'Class cannot derive from itself',
        baseClassFinal: {
          message: 'Base class "{type}" is marked final and cannot be subclassed',
          comment: '{Locked=\'final\'}'
        },
        baseClassIncompatible: 'Base classes of {type} are mutually incompatible',
        baseClassInvalid: 'Argument to class must be a base class',
        baseClassMethodTypeIncompatible: 'Base classes for class "{classType}" define method "{name}" in incompatible way',
        baseClassUnknown: 'Base class type is unknown, obscuring type of derived class',
        baseClassVariableTypeIncompatible: 'Base classes for class "{classType}" define variable "{name}" in incompatible way',
        binaryOperationNotAllowed: 'Binary operator not allowed in type expression',
        bindTypeMismatch: {
          message: 'Could not bind method "{methodName}" because "{type}" is not assignable to parameter "{paramName}"',
          comment: 'Binding is the process through which Pyright determines what object a name refers to'
        },
        breakInExceptionGroup: {
          message: '"break" is not allowed in an "except*" block',
          comment: '{Locked=\'break\',\'except*\'}'
        },
        breakOutsideLoop: {
          message: '"break" can be used only within a loop',
          comment: '{Locked=\'break\'}'
        },
        callableExtraArgs: {
          message: 'Expected only two type arguments to "Callable"',
          comment: '{Locked=\'Callable\'}'
        },
        callableFirstArg: 'Expected parameter type list or "..."',
        callableNotInstantiable: 'Cannot instantiate type "{type}"',
        callableSecondArg: {
          message: 'Expected return type as second type argument for "Callable"',
          comment: '{Locked=\'Callable\'}'
        },
        casePatternIsIrrefutable: 'Irrefutable pattern is allowed only for the last case statement',
        classAlreadySpecialized: 'Type "{type}" is already specialized',
        classDecoratorTypeUnknown: 'Untyped class decorator obscures type of class; ignoring decorator',
        classDefinitionCycle: 'Class definition for "{name}" depends on itself',
        classGetItemClsParam: {
          message: '__class_getitem__ override should take a "cls" parameter',
          comment: '{Locked=\'__class_getitem__\',\'cls\'}'
        },
        classMethodClsParam: {
          message: 'Class methods should take a "cls" parameter',
          comment: '{Locked=\'cls\'}'
        },
        classNotRuntimeSubscriptable: 'Subscript for class "{name}" will generate runtime exception; enclose type expression in quotes',
        classPatternBuiltInArgPositional: 'Class pattern accepts only positional sub-pattern',
        classPatternPositionalArgCount: 'Too many positional patterns for class "{type}"; expected {expected} but received {received}',
        classPatternTypeAlias: '"{type}" cannot be used in a class pattern because it is a specialized type alias',
        classPropertyDeprecated: 'Class properties are deprecated in Python 3.11 and will not be supported in Python 3.13',
        classTypeParametersIllegal: 'Class type parameter syntax requires Python 3.12 or newer',
        classVarFirstArgMissing: {
          message: 'Expected a type argument after "ClassVar"',
          comment: '{Locked=\'ClassVar\'}'
        },
        classVarNotAllowed: {
          message: '"ClassVar" is not allowed in this context',
          comment: '{Locked=\'ClassVar\'}'
        },
        classVarOverridesInstanceVar: 'Class variable "{name}" overrides instance variable of same name in class "{className}"',
        classVarTooManyArgs: {
          message: 'Expected only one type argument after "ClassVar"',
          comment: '{Locked=\'ClassVar\'}'
        },
        classVarWithTypeVar: {
          message: '"ClassVar" type cannot include type variables',
          comment: '{Locked=\'ClassVar\'}'
        },
        clsSelfParamTypeMismatch: 'Type of parameter "{name}" must be a supertype of its class "{classType}"',
        codeTooComplexToAnalyze: 'Code is too complex to analyze; reduce complexity by refactoring into subroutines or reducing conditional code paths',
        collectionAliasInstantiation: 'Type "{type}" cannot be instantiated, use "{alias}" instead',
        comparisonAlwaysFalse: {
          message: 'Condition will always evaluate to False since the types "{leftType}" and "{rightType}" have no overlap',
          comment: '{Locked=\'False\'}'
        },
        comparisonAlwaysTrue: {
          message: 'Condition will always evaluate to True since the types "{leftType}" and "{rightType}" have no overlap',
          comment: '{Locked=\'True\'}'
        },
        comprehensionInDict: {
          message: 'Comprehension cannot be used with other dictionary entries',
          comment: 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable'
        },
        comprehensionInSet: {
          message: 'Comprehension cannot be used with other set entries',
          comment: ['{Locked=\'set\'}', 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable']
        },
        concatenateContext: {
          message: '"Concatenate" is not allowed in this context',
          comment: '{Locked=\'Concatenate\'}'
        },
        concatenateParamSpecMissing: {
          message: 'Last type argument for "Concatenate" must be a ParamSpec or "..."',
          comment: '{Locked=\'Concatenate\',\'ParamSpec\',\'...\'}'
        },
        concatenateTypeArgsMissing: {
          message: '"Concatenate" requires at least two type arguments',
          comment: '{Locked=\'Concatenate\'}'
        },
        conditionalOperandInvalid: 'Invalid conditional operand of type "{type}"',
        constantRedefinition: '"{name}" is constant (because it is uppercase) and cannot be redefined',
        constructorParametersMismatch: {
          message: 'Mismatch between signature of __new__ and __init__ in class "{classType}"',
          comment: '{Locked=\'__new__\',\'__init__\'}'
        },
        containmentAlwaysFalse: {
          message: 'Expression will always evaluate to False since the types "{leftType}" and "{rightType}" have no overlap',
          comment: '{Locked=\'False\'}'
        },
        containmentAlwaysTrue: {
          message: 'Expression will always evaluate to True since the types "{leftType}" and "{rightType}" have no overlap',
          comment: '{Locked=\'True\'}'
        },
        continueInExceptionGroup: {
          message: '"continue" is not allowed in an "except*" block',
          comment: '{Locked=\'continue\',\'except*\'}'
        },
        continueOutsideLoop: {
          message: '"continue" can be used only within a loop',
          comment: '{Locked=\'continue\'}'
        },
        coroutineInConditionalExpression: {
          message: 'Conditional expression references coroutine which always evaluates to True',
          comment: '{Locked=\'True\'}'
        },
        dataClassBaseClassFrozen: 'A non-frozen class cannot inherit from a class that is frozen',
        dataClassBaseClassNotFrozen: 'A frozen class cannot inherit from a class that is not frozen',
        dataClassConverterFunction: 'Argument of type "{argType}" is not a valid converter for field "{fieldName}" of type "{fieldType}"',
        dataClassConverterOverloads: 'No overloads of "{funcName}" are valid converters for field "{fieldName}" of type "{fieldType}"',
        dataClassFieldInheritedDefault: '"{fieldName}" overrides a field of the same name but is missing a default value',
        dataClassFieldWithDefault: 'Fields without default values cannot appear after fields with default values',
        dataClassFieldWithPrivateName: 'Dataclass field cannot use private name',
        dataClassFieldWithoutAnnotation: 'Dataclass field without type annotation will cause runtime exception',
        dataClassPostInitParamCount: {
          message: 'Dataclass __post_init__ incorrect parameter count; number of InitVar fields is {expected}',
          comment: '{Locked=\'__post_init__\',\'InitVar\'}'
        },
        dataClassPostInitType: {
          message: 'Dataclass __post_init__ method parameter type mismatch for field "{fieldName}"',
          comment: '{Locked=\'__post_init__\'}'
        },
        dataClassSlotsOverwrite: {
          message: '__slots__ is already defined in class',
          comment: '{Locked=\'__slots__\'}'
        },
        dataClassTransformExpectedBoolLiteral: {
          message: 'Expected expression that statically evaluates to True or False',
          comment: '{Locked=\'True\',\'False\'}'
        },
        dataClassTransformFieldSpecifier: {
          message: 'Expected tuple of classes or functions but received type "{type}"',
          comment: '{Locked=\'tuple\'}'
        },
        dataClassTransformPositionalParam: {
          message: 'All arguments to "dataclass_transform" must be keyword arguments',
          comment: '{Locked=\'dataclass_transform\'}'
        },
        dataClassTransformUnknownArgument: {
          message: 'Argument "{name}" is not supported by dataclass_transform',
          comment: '{Locked=\'dataclass_transform\'}'
        },
        dataProtocolInSubclassCheck: {
          message: 'Data protocols (which include non-method attributes) are not allowed in issubclass calls',
          comment: '{Locked=\'issubclass\'}'
        },
        declaredReturnTypePartiallyUnknown: 'Declared return type, "{returnType}", is partially unknown',
        declaredReturnTypeUnknown: 'Declared return type is unknown',
        defaultValueContainsCall: 'Function calls and mutable objects not allowed within parameter default value expression',
        defaultValueNotAllowed: 'Parameter with "*" or "**" cannot have default value',
        delTargetExpr: 'Expression cannot be deleted',
        deprecatedClass: 'The class "{name}" is deprecated',
        deprecatedConstructor: 'The constructor for class "{name}" is deprecated',
        deprecatedDescriptorDeleter: 'The "__delete__" method for descriptor "{name}" is deprecated',
        deprecatedDescriptorGetter: 'The "__get__" method  for descriptor "{name}" is deprecated',
        deprecatedDescriptorSetter: 'The "__set__" method  for descriptor "{name}" is deprecated',
        deprecatedFunction: 'The function "{name}" is deprecated',
        deprecatedMethod: 'The method "{name}" in class "{className}" is deprecated',
        deprecatedPropertyDeleter: {
          message: 'The deleter for property "{name}" is deprecated',
          comment: '{Locked=\'deleter\',\'property\'}'
        },
        deprecatedPropertyGetter: {
          message: 'The getter for property "{name}" is deprecated',
          comment: '{Locked=\'getter\',\'property\'}'
        },
        deprecatedPropertySetter: {
          message: 'The setter for property "{name}" is deprecated',
          comment: '{Locked=\'setter\',\'property\'}'
        },
        deprecatedType: 'This type is deprecated as of Python {version}; use "{replacement}" instead',
        dictExpandIllegalInComprehension: {
          message: 'Dictionary expansion not allowed in comprehension',
          comment: 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable'
        },
        dictInAnnotation: 'Dictionary expression not allowed in type expression',
        dictKeyValuePairs: 'Dictionary entries must contain key/value pairs',
        dictUnpackIsNotMapping: 'Expected mapping for dictionary unpack operator',
        dunderAllSymbolNotPresent: {
          message: '"{name}" is specified in __all__ but is not present in module',
          comment: '{Locked=\'__all__\'}'
        },
        duplicateArgsParam: 'Only one "*" parameter allowed',
        duplicateBaseClass: 'Duplicate base class not allowed',
        duplicateCapturePatternTarget: 'Capture target "{name}" cannot appear more than once within the same pattern',
        duplicateCatchAll: {
          message: 'Only one catch-all except clause allowed',
          comment: '{Locked=\'except\'}'
        },
        duplicateEnumMember: {
          message: 'Enum member "{name}" is already declared',
          comment: '{Locked=\'Enum\'}'
        },
        duplicateGenericAndProtocolBase: {
          message: 'Only one Generic[...] or Protocol[...] base class allowed',
          comment: '{Locked=\'Generic[...]\',\'Protocol[...]\'}'
        },
        duplicateImport: '"{importName}" is imported more than once',
        duplicateKeywordOnly: 'Only one "*" separator allowed',
        duplicateKwargsParam: 'Only one "**" parameter allowed',
        duplicateParam: 'Duplicate parameter "{name}"',
        duplicatePositionOnly: 'Only one "/" parameter allowed',
        duplicateStarPattern: 'Only one "*" pattern allowed in a pattern sequence',
        duplicateStarStarPattern: 'Only one "**" entry allowed',
        duplicateUnpack: {
          message: 'Only one unpack operation allowed in list',
          comment: '{Locked=\'list\'}'
        },
        ellipsisAfterUnpacked: {
          message: '"..." cannot be used with an unpacked TypeVarTuple or tuple',
          comment: '{Locked=\'TypeVarTuple\',\'tuple\'}'
        },
        ellipsisContext: '"..." is not allowed in this context',
        ellipsisSecondArg: '"..." is allowed only as the second of two arguments',
        enumClassOverride: {
          message: 'Enum class "{name}" is final and cannot be subclassed',
          comment: '{Locked=\'Enum\',\'final\'}'
        },
        enumMemberDelete: {
          message: 'Enum member "{name}" cannot be deleted',
          comment: '{Locked=\'Enum\'}'
        },
        enumMemberSet: {
          message: 'Enum member "{name}" cannot be assigned',
          comment: '{Locked=\'Enum\'}'
        },
        enumMemberTypeAnnotation: {
          message: 'Type annotations are not allowed for enum members',
          comment: '{Locked=\'enum\'}'
        },
        exceptionGroupIncompatible: {
          message: 'Exception group syntax ("except*") requires Python 3.11 or newer',
          comment: '{Locked=\'except*\'}'
        },
        exceptGroupMismatch: {
          message: 'Try statement cannot include both "except" and "except*"',
          comment: '{Locked=\'except\',\'except*\'}'
        },
        exceptGroupRequiresType: {
          message: 'Exception group syntax ("except*") requires an exception type',
          comment: '{Locked=\'except*\'}'
        },
        exceptionGroupTypeIncorrect: {
          message: 'Exception type in except* cannot derive from BaseGroupException',
          comment: '{Locked=\'except*\',\'BaseGroupException\'}'
        },
        exceptionTypeIncorrect: {
          message: '"{type}" does not derive from BaseException',
          comment: '{Locked=\'BaseException\'}'
        },
        exceptionTypeNotClass: '"{type}" is not a valid exception class',
        exceptionTypeNotInstantiable: 'Constructor for exception type "{type}" requires one or more arguments',
        expectedAfterDecorator: 'Expected function or class declaration after decorator',
        expectedArrow: 'Expected "->" followed by return type annotation',
        expectedAsAfterException: {
          message: 'Expected "as" after exception type',
          comment: '{Locked=\'as\'}'
        },
        expectedAssignRightHandExpr: 'Expected expression to the right of "="',
        expectedBinaryRightHandExpr: 'Expected expression to the right of operator',
        expectedBoolLiteral: {
          message: 'Expected True or False',
          comment: '{Locked=\'True\',\'False\'}'
        },
        expectedCase: {
          message: 'Expected "case" statement',
          comment: '{Locked=\'case\'}'
        },
        expectedClassName: 'Expected class name',
        expectedCloseBrace: '"{" was not closed',
        expectedCloseBracket: '"[" was not closed',
        expectedCloseParen: '"(" was not closed',
        expectedColon: 'Expected ":"',
        expectedComplexNumberLiteral: {
          message: 'Expected complex number literal for pattern matching',
          comment: 'Complex numbers are a mathematical concept consisting of a real number and an imaginary number'
        },
        expectedDecoratorExpr: 'Expression form not supported for decorator prior to Python 3.9',
        expectedDecoratorName: 'Expected decorator name',
        expectedDecoratorNewline: 'Expected new line at end of decorator',
        expectedDelExpr: {
          message: 'Expected expression after "del"',
          comment: '{Locked=\'del\'}'
        },
        expectedElse: {
          message: 'Expected "else"',
          comment: '{Locked=\'else\'}'
        },
        expectedEquals: 'Expected "="',
        expectedExceptionClass: 'Invalid exception class or object',
        expectedExceptionObj: {
          message: 'Expected exception object, exception class or None',
          comment: '{Locked=\'None\'}'
        },
        expectedExpr: 'Expected expression',
        expectedFunctionAfterAsync: {
          message: 'Expected function definition after "async"',
          comment: '{Locked=\'async\'}'
        },
        expectedFunctionName: {
          message: 'Expected function name after "def"',
          comment: '{Locked=\'def\'}'
        },
        expectedIdentifier: 'Expected identifier',
        expectedImport: {
          message: 'Expected "import"',
          comment: '{Locked=\'import\'}'
        },
        expectedImportAlias: {
          message: 'Expected symbol after "as"',
          comment: '{Locked=\'as\'}'
        },
        expectedImportSymbols: {
          message: 'Expected one or more symbol names after "import"',
          comment: '{Locked=\'import\'}'
        },
        expectedIn: {
          message: 'Expected "in"',
          comment: '{Locked=\'in\'}'
        },
        expectedInExpr: {
          message: 'Expected expression after "in"',
          comment: '{Locked=\'in\'}'
        },
        expectedIndentedBlock: 'Expected indented block',
        expectedMemberName: 'Expected attribute name after "."',
        expectedModuleName: 'Expected module name',
        expectedNameAfterAs: {
          message: 'Expected symbol name after "as"',
          comment: '{Locked=\'as\'}'
        },
        expectedNamedParameter: 'Keyword parameter must follow "*"',
        expectedNewline: 'Expected newline',
        expectedNewlineOrSemicolon: 'Statements must be separated by newlines or semicolons',
        expectedOpenParen: 'Expected "("',
        expectedParamName: 'Expected parameter name',
        expectedPatternExpr: 'Expected pattern expression',
        expectedPatternSubjectExpr: 'Expected pattern subject expression',
        expectedPatternValue: {
          message: 'Expected pattern value expression of the form "a.b"',
          comment: '{Locked=\'a.b\'}'
        },
        expectedReturnExpr: {
          message: 'Expected expression after "return"',
          comment: '{Locked=\'return\'}'
        },
        expectedSliceIndex: 'Expected index or slice expression',
        expectedTypeNotString: 'Expected type but received a string literal',
        expectedTypeParameterName: 'Expected type parameter name',
        expectedYieldExpr: {
          message: 'Expected expression in yield statement',
          comment: '{Locked=\'yield\'}'
        },
        finalClassIsAbstract: {
          message: 'Class "{type}" is marked final and must implement all abstract symbols',
          comment: '{Locked=\'final\'}'
        },
        finalContext: {
          message: '"Final" is not allowed in this context',
          comment: '{Locked=\'Final\'}'
        },
        finalInLoop: {
          message: 'A "Final" variable cannot be assigned within a loop',
          comment: '{Locked=\'Final\'}'
        },
        finalMethodOverride: {
          message: 'Method "{name}" cannot override final method defined in class "{className}"',
          comment: '{Locked=\'final\'}'
        },
        finalNonMethod: {
          message: 'Function "{name}" cannot be marked @final because it is not a method',
          comment: '{Locked=\'@final\'}'
        },
        finalReassigned: {
          message: '"{name}" is declared as Final and cannot be reassigned',
          comment: '{Locked=\'Final\'}'
        },
        finalRedeclaration: {
          message: '"{name}" was previously declared as Final',
          comment: '{Locked=\'Final\'}'
        },
        finalRedeclarationBySubclass: {
          message: '"{name}" cannot be redeclared because parent class "{className}" declares it as Final',
          comment: '{Locked=\'Final\'}'
        },
        finalTooManyArgs: {
          message: 'Expected a single type argument after "Final"',
          comment: '{Locked=\'Final\'}'
        },
        finalUnassigned: {
          message: '"{name}" is declared Final, but value is not assigned',
          comment: '{Locked=\'Final\'}'
        },
        formatStringBrace: {
          message: 'Single close brace not allowed within f-string literal; use double close brace',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringBytes: {
          message: 'Format string literals (f-strings) cannot be binary',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringDebuggingIllegal: {
          message: 'F-string debugging specifier "=" requires Python 3.8 or newer',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringEscape: {
          message: 'Escape sequence (backslash) not allowed in expression portion of f-string prior to Python 3.12',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringExpectedConversion: {
          message: 'Expected a conversion specifier after "!" in f-string',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringIllegal: {
          message: 'Format string literals (f-strings) require Python 3.6 or newer',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringInPattern: 'Format string not allowed in pattern',
        formatStringNestedFormatSpecifier: 'Expressions nested too deeply within format string specifier',
        formatStringNestedQuote: {
          message: 'Strings nested within an f-string cannot use the same quote character as the f-string prior to Python 3.12',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringUnicode: {
          message: 'Format string literals (f-strings) cannot be unicode',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringUnterminated: {
          message: 'Unterminated expression in f-string; expecting "}"',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        functionDecoratorTypeUnknown: 'Untyped function decorator obscures type of function; ignoring decorator',
        functionInConditionalExpression: {
          message: 'Conditional expression references function which always evaluates to True',
          comment: '{Locked=\'True\'}'
        },
        functionTypeParametersIllegal: 'Function type parameter syntax requires Python 3.12 or newer',
        futureImportLocationNotAllowed: {
          message: 'Imports from __future__ must be at the beginning of the file',
          comment: '{Locked=\'__future__\'}'
        },
        generatorAsyncReturnType: {
          message: 'Return type of async generator function must be compatible with "AsyncGenerator[{yieldType}, Any]"',
          comment: '{Locked=\'async\',\'AsyncGenerator[{yieldType}, Any]\'}'
        },
        generatorNotParenthesized: 'Generator expressions must be parenthesized if not sole argument',
        generatorSyncReturnType: {
          message: 'Return type of generator function must be compatible with "Generator[{yieldType}, Any, Any]"',
          comment: '{Locked=\'Generator[{yieldType}, Any, Any]\'}'
        },
        genericBaseClassNotAllowed: {
          message: '"Generic" base class cannot be used with type parameter syntax',
          comment: '{Locked=\'Generic\'}'
        },
        genericClassAssigned: {
          message: 'Generic class type cannot be assigned',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        genericClassDeleted: {
          message: 'Generic class type cannot be deleted',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        genericInstanceVariableAccess: {
          message: 'Access to generic instance variable through class is ambiguous',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        genericNotAllowed: {
          message: '"Generic" is not valid in this context',
          comment: '{Locked=\'Generic\'}'
        },
        genericTypeAliasBoundTypeVar: {
          message: 'Generic type alias within class cannot use bound type variables {names}',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        genericTypeArgMissing: {
          message: '"Generic" requires at least one type argument',
          comment: '{Locked=\'Generic\'}'
        },
        genericTypeArgTypeVar: {
          message: 'Type argument for "Generic" must be a type variable',
          comment: '{Locked=\'Generic\'}'
        },
        genericTypeArgUnique: {
          message: 'Type arguments for "Generic" must be unique',
          comment: '{Locked=\'Generic\'}'
        },
        globalReassignment: {
          message: '"{name}" is assigned before global declaration',
          comment: '{Locked=\'global\'}'
        },
        globalRedefinition: {
          message: '"{name}" was already declared global',
          comment: '{Locked=\'global\'}'
        },
        implicitStringConcat: 'Implicit string concatenation not allowed',
        importCycleDetected: 'Cycle detected in import chain',
        importDepthExceeded: 'Import chain depth exceeded {depth}',
        importResolveFailure: 'Import "{importName}" could not be resolved',
        importSourceResolveFailure: 'Import "{importName}" could not be resolved from source',
        importSymbolUnknown: '"{name}" is unknown import symbol',
        incompatibleMethodOverride: 'Method "{name}" overrides class "{className}" in an incompatible manner',
        inconsistentIndent: 'Unindent amount does not match previous indent',
        inconsistentTabs: 'Inconsistent use of tabs and spaces in indentation',
        initMethodSelfParamTypeVar: {
          message: 'Type annotation for "self" parameter of "__init__" method cannot contain class-scoped type variables',
          comment: '{Locked=\'self\',\'__init__\'}'
        },
        initMustReturnNone: {
          message: 'Return type of "__init__" must be None',
          comment: '{Locked=\'__init__\',\'None\'}'
        },
        initSubclassCallFailed: {
          message: 'Incorrect keyword arguments for __init_subclass__ method',
          comment: '{Locked=\'__init_subclass__\'}'
        },
        initSubclassClsParam: {
          message: '__init_subclass__ override should take a "cls" parameter',
          comment: '{Locked=\'__init_subclass__\',\'cls\'}'
        },
        initVarNotAllowed: {
          message: '"InitVar" is not allowed in this context',
          comment: '{Locked=\'InitVar\'}'
        },
        instanceMethodSelfParam: {
          message: 'Instance methods should take a "self" parameter',
          comment: '{Locked=\'self\'}'
        },
        instanceVarOverridesClassVar: 'Instance variable "{name}" overrides class variable of same name in class "{className}"',
        instantiateAbstract: 'Cannot instantiate abstract class "{type}"',
        instantiateProtocol: {
          message: 'Cannot instantiate Protocol class "{type}"',
          comment: '{Locked=\'Protocol\'}'
        },
        internalBindError: {
          message: 'An internal error occurred while binding file "{file}": {message}',
          comment: 'Binding is the process through which Pyright determines what object a name refers to'
        },
        internalParseError: 'An internal error occurred while parsing file "{file}": {message}',
        internalTypeCheckingError: 'An internal error occurred while type checking file "{file}": {message}',
        invalidIdentifierChar: 'Invalid character in identifier',
        invalidStubStatement: {
          message: 'Statement is meaningless within a type stub file',
          comment: '{StrContains=i\'stub\'}'
        },
        invalidTokenChars: 'Invalid character "{text}" in token',
        isInstanceInvalidType: {
          message: 'Second argument to "isinstance" must be a class or tuple of classes',
          comment: '{Locked=\'isinstance\',\'tuple\'}'
        },
        isSubclassInvalidType: {
          message: 'Second argument to "issubclass" must be a class or tuple of classes',
          comment: '{Locked=\'issubclass\',\'tuple\'}'
        },
        keyValueInSet: {
          message: 'Key/value pairs are not allowed within a set',
          comment: '{Locked=\'set\'}'
        },
        keywordArgInTypeArgument: 'Keyword arguments cannot be used in type argument lists',
        keywordArgShortcutIllegal: 'Keyword argument shortcut requires Python 3.14 or newer',
        keywordOnlyAfterArgs: 'Keyword-only argument separator not allowed after "*" parameter',
        keywordParameterMissing: 'One or more keyword parameters must follow "*" parameter',
        keywordSubscriptIllegal: 'Keyword arguments within subscripts are not supported',
        lambdaReturnTypePartiallyUnknown: 'Return type of lambda, "{returnType}", is partially unknown',
        lambdaReturnTypeUnknown: 'Return type of lambda is unknown',
        listAssignmentMismatch: 'Expression with type "{type}" cannot be assigned to target list',
        listInAnnotation: {
          message: 'List expression not allowed in type expression',
          comment: '{Locked=\'List\'}'
        },
        literalEmptyArgs: {
          message: 'Expected one or more type arguments after "Literal"',
          comment: '{Locked=\'Literal\'}'
        },
        literalNamedUnicodeEscape: {
          message: 'Named unicode escape sequences are not supported in "Literal" string annotations',
          comment: '{Locked=\'Literal\'}'
        },
        literalNotAllowed: {
          message: '"Literal" cannot be used in this context without a type argument',
          comment: '{Locked=\'Literal\'}'
        },
        literalNotCallable: {
          message: 'Literal type cannot be instantiated',
          comment: '{Locked=\'Literal\'}'
        },
        literalUnsupportedType: {
          message: 'Type arguments for "Literal" must be None, a literal value (int, bool, str, or bytes), or an enum value',
          comment: '{Locked=\'Literal\',\'None\',\'int\',\'bool\',\'str\',\'bytes\',\'enum\'}'
        },
        matchIncompatible: {
          message: 'Match statements require Python 3.10 or newer',
          comment: ['{StrContains=i\'match\'}', '\'match\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        matchIsNotExhaustive: {
          message: 'Cases within match statement do not exhaustively handle all values',
          comment: ['{Locked=\'match\'}', 'Case statements are children of match statements where \'case\' is a keyword. It may be best to keep \'case\' in English']
        },
        maxParseDepthExceeded: 'Maximum parse depth exceeded; break expression into smaller sub-expressions',
        memberAccess: 'Cannot access attribute "{name}" for class "{type}"',
        memberDelete: 'Cannot delete attribute "{name}" for class "{type}"',
        memberSet: 'Cannot assign to attribute "{name}" for class "{type}"',
        metaclassConflict: {
          message: 'The metaclass of a derived class must be a subclass of the metaclasses of all its base classes',
          comment: 'Metaclasses are a complex concept and it may be best to not localize the term'
        },
        metaclassDuplicate: {
          message: 'Only one metaclass can be provided',
          comment: 'Metaclasses are a complex concept and it may be best to not localize the term'
        },
        metaclassIsGeneric: {
          message: 'Metaclass cannot be generic',
          comment: ['Metaclasses are a complex concept and it may be best to not localize the term', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        methodNotDefined: '"{name}" method not defined',
        methodNotDefinedOnType: '"{name}" method not defined on type "{type}"',
        methodOrdering: 'Cannot create consistent method ordering',
        methodOverridden: '"{name}" overrides method of same name in class "{className}" with incompatible type "{type}"',
        methodReturnsNonObject: '"{name}" method does not return an object',
        missingSuperCall: 'Method "{methodName}" does not call the method of the same name in parent class',
        mixingBytesAndStr: {
          message: 'Bytes and str values cannot be concatenated',
          comment: ['{Locked=\'str\'}', '{StrContains=i\'bytes\'}', '\'bytes\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        moduleAsType: 'Module cannot be used as a type',
        moduleNotCallable: 'Module is not callable',
        moduleUnknownMember: '"{memberName}" is not a known attribute of module "{moduleName}"',
        namedExceptAfterCatchAll: {
          message: 'A named except clause cannot appear after catch-all except clause',
          comment: '{Locked=\'except\'}'
        },
        namedParamAfterParamSpecArgs: {
          message: 'Keyword parameter "{name}" cannot appear in signature after ParamSpec args parameter',
          comment: '{Locked=\'ParamSpec\',\'args\'}'
        },
        namedTupleEmptyName: {
          message: 'Names within a named tuple cannot be empty',
          comment: '{Locked=\'tuple\'}'
        },
        namedTupleEntryRedeclared: {
          message: 'Cannot override "{name}" because parent class "{className}" is a named tuple',
          comment: '{Locked=\'tuple\'}'
        },
        namedTupleFirstArg: {
          message: 'Expected named tuple class name as first argument',
          comment: '{Locked=\'tuple\'}'
        },
        namedTupleMultipleInheritance: {
          message: 'Multiple inheritance with NamedTuple is not supported',
          comment: '{Locked=\'NamedTuple\'}'
        },
        namedTupleNameKeyword: 'Field names cannot be a keyword',
        namedTupleNameType: {
          message: 'Expected two-entry tuple specifying entry name and type',
          comment: '{Locked=\'tuple\'}'
        },
        namedTupleNameUnique: {
          message: 'Names within a named tuple must be unique',
          comment: '{Locked=\'tuple\'}'
        },
        namedTupleNoTypes: {
          message: '"namedtuple" provides no types for tuple entries; use "NamedTuple" instead',
          comment: '{Locked=\'namedtuple";\'tuple\',\'NamedTuple\'}'
        },
        namedTupleSecondArg: {
          message: 'Expected named tuple entry list as second argument',
          comment: '{Locked=\'tuple\',\'list\'}'
        },
        newClsParam: {
          message: '__new__ override should take a "cls" parameter',
          comment: '{Locked=\'__new__\',\'cls\'}'
        },
        newTypeAnyOrUnknown: {
          message: 'The second argument to NewType must be a known class, not Any or Unknown',
          comment: '{Locked=\'NewType\',\'Any\',\'Unknown\'}'
        },
        newTypeBadName: {
          message: 'The first argument to NewType must be a string literal',
          comment: '{Locked=\'NewType\'}'
        },
        newTypeLiteral: {
          message: 'NewType cannot be used with Literal type',
          comment: '{Locked=\'NewType\',\'Literal\'}'
        },
        newTypeNameMismatch: {
          message: 'NewType must be assigned to a variable with the same name',
          comment: '{Locked=\'NewType\'}'
        },
        newTypeNotAClass: {
          message: 'Expected class as second argument to NewType',
          comment: '{Locked=\'NewType\'}'
        },
        newTypeParamCount: {
          message: 'NewType requires two positional arguments',
          comment: '{Locked=\'NewType\'}'
        },
        newTypeProtocolClass: {
          message: 'NewType cannot be used with structural type (a Protocol or TypedDict class)',
          comment: '{Locked=\'NewType\',\'Protocol\',\'TypedDict\'}'
        },
        noOverload: 'No overloads for "{name}" match the provided arguments',
        noReturnContainsReturn: {
          message: 'Function with declared return type "NoReturn" cannot include a return statement',
          comment: '{Locked=\'NoReturn\',\'return\'}'
        },
        noReturnContainsYield: {
          message: 'Function with declared return type "NoReturn" cannot include a yield statement',
          comment: '{Locked=\'NoReturn\',\'yield\'}'
        },
        noReturnReturnsNone: {
          message: 'Function with declared return type "NoReturn" cannot return "None"',
          comment: '{Locked=\'NoReturn\',\'None\'}'
        },
        nonDefaultAfterDefault: 'Non-default argument follows default argument',
        nonLocalInModule: {
          message: 'Nonlocal declaration not allowed at module level',
          comment: ['{StrContains=i\'nonlocal\'}', '\'nonlocal\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        nonLocalNoBinding: {
          message: 'No binding for nonlocal "{name}" found',
          comment: ['{Locked=\'nonlocal\'}', '\'No binding found\' means that Pyright couldn\'t resolve the variable name to an object']
        },
        nonLocalReassignment: {
          message: '"{name}" is assigned before nonlocal declaration',
          comment: '{Locked=\'nonlocal\'}'
        },
        nonLocalRedefinition: {
          message: '"{name}" was already declared nonlocal',
          comment: '{Locked=\'nonlocal\'}'
        },
        noneNotCallable: {
          message: 'Object of type "None" cannot be called',
          comment: '{Locked=\'None\'}'
        },
        noneNotIterable: {
          message: 'Object of type "None" cannot be used as iterable value',
          comment: '{Locked=\'None\'}'
        },
        noneNotSubscriptable: {
          message: 'Object of type "None" is not subscriptable',
          comment: '{Locked=\'None\'}'
        },
        noneNotUsableWith: {
          message: 'Object of type "None" cannot be used with "with"',
          comment: '{Locked=\'None\',\'with\'}'
        },
        noneOperator: {
          message: 'Operator "{operator}" not supported for "None"',
          comment: '{Locked=\'None\'}'
        },
        noneUnknownMember: {
          message: '"{name}" is not a known attribute of "None"',
          comment: '{Locked=\'None\'}'
        },
        notRequiredArgCount: {
          message: 'Expected a single type argument after "NotRequired"',
          comment: '{Locked=\'NotRequired\'}'
        },
        notRequiredNotInTypedDict: {
          message: '"NotRequired" is not allowed in this context',
          comment: '{Locked=\'NotRequired\'}'
        },
        objectNotCallable: 'Object of type "{type}" is not callable',
        obscuredClassDeclaration: 'Class declaration "{name}" is obscured by a declaration of the same name',
        obscuredFunctionDeclaration: 'Function declaration "{name}" is obscured by a declaration of the same name',
        obscuredMethodDeclaration: 'Method declaration "{name}" is obscured by a declaration of the same name',
        obscuredParameterDeclaration: 'Parameter declaration "{name}" is obscured by a declaration of the same name',
        obscuredTypeAliasDeclaration: 'Type alias declaration "{name}" is obscured by a declaration of the same name',
        obscuredVariableDeclaration: 'Declaration "{name}" is obscured by a declaration of the same name',
        operatorLessOrGreaterDeprecated: 'Operator "<>" is not supported in Python 3; use "!=" instead',
        optionalExtraArgs: {
          message: 'Expected one type argument after "Optional"',
          comment: '{Locked=\'Optional\'}'
        },
        orPatternIrrefutable: {
          message: 'Irrefutable pattern allowed only as the last subpattern in an "or" pattern',
          comment: '{Locked=\'or\'}'
        },
        orPatternMissingName: {
          message: 'All subpatterns within an "or" pattern must target the same names',
          comment: '{Locked=\'or\'}'
        },
        overlappingKeywordArgs: 'Typed dictionary overlaps with keyword parameter: {names}',
        overlappingOverload: 'Overload {obscured} for "{name}" will never be used because its parameters overlap overload {obscuredBy}',
        overloadAbstractImplMismatch: 'Overloads must match abstract status of implementation',
        overloadAbstractMismatch: 'Overloads must all be abstract or not',
        overloadClassMethodInconsistent: {
          message: 'Overloads for "{name}" use @classmethod inconsistently',
          comment: '{Locked=\'@classmethod\'}'
        },
        overloadFinalInconsistencyImpl: {
          message: 'Overload for "{name}" is marked @final but implementation is not',
          comment: '{Locked=\'@final\'}'
        },
        overloadFinalInconsistencyNoImpl: {
          message: 'Overload {index} for "{name}" is marked @final but overload 1 is not',
          comment: '{Locked=\'@final\'}'
        },
        overloadImplementationMismatch: 'Overloaded implementation is not consistent with signature of overload {index}',
        overloadReturnTypeMismatch: 'Overload {prevIndex} for "{name}" overlaps overload {newIndex} and returns an incompatible type',
        overloadStaticMethodInconsistent: {
          message: 'Overloads for "{name}" use @staticmethod inconsistently',
          comment: '{Locked=\'@staticmethod\'}'
        },
        overloadWithoutImplementation: {
          message: '"{name}" is marked as overload, but no implementation is provided',
          comment: '{Locked=\'overload\'}'
        },
        overriddenMethodNotFound: {
          message: 'Method "{name}" is marked as override, but no base method of same name is present',
          comment: '{Locked=\'override\'}'
        },
        overrideDecoratorMissing: {
          message: 'Method "{name}" is not marked as override but is overriding a method in class "{className}"',
          comment: '{Locked=\'override\'}'
        },
        paramAfterKwargsParam: 'Parameter cannot follow "**" parameter',
        paramAlreadyAssigned: 'Parameter "{name}" is already assigned',
        paramAnnotationMissing: 'Type annotation is missing for parameter "{name}"',
        paramAssignmentMismatch: 'Expression of type "{sourceType}" cannot be assigned to parameter of type "{paramType}"',
        paramNameMissing: 'No parameter named "{name}"',
        paramSpecArgsKwargsDuplicate: {
          message: 'Arguments for ParamSpec "{type}" have already been provided',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecArgsKwargsUsage: {
          message: '"args" and "kwargs" attributes of ParamSpec must both appear within a function signature',
          comment: '{Locked=\'args\',\'kwargs\',\'ParamSpec\'}'
        },
        paramSpecArgsMissing: {
          message: 'Arguments for ParamSpec "{type}" are missing',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecArgsUsage: {
          message: '"args" attribute of ParamSpec is valid only when used with *args parameter',
          comment: '{Locked=\'args\',\'ParamSpec\',\'*args\'}'
        },
        paramSpecAssignedName: {
          message: 'ParamSpec must be assigned to a variable named "{name}"',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecContext: {
          message: 'ParamSpec is not allowed in this context',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecDefaultNotTuple: {
          message: 'Expected ellipsis, a tuple expression, or ParamSpec for default value of ParamSpec',
          comment: '{Locked=\'tuple\',\'ParamSpec\'}'
        },
        paramSpecFirstArg: {
          message: 'Expected name of ParamSpec as first argument',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecKwargsUsage: {
          message: '"kwargs" attribute of ParamSpec is valid only when used with **kwargs parameter',
          comment: '{Locked=\'kwargs\',\'ParamSpec\',\'**kwargs\'}'
        },
        paramSpecNotUsedByOuterScope: {
          message: 'ParamSpec "{name}" has no meaning in this context',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecUnknownArg: {
          message: 'ParamSpec does not support more than one argument',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecUnknownMember: {
          message: '"{name}" is not a known attribute of ParamSpec',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecUnknownParam: {
          message: '"{name}" is unknown parameter to ParamSpec',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramTypeCovariant: 'Covariant type variable cannot be used in parameter type',
        paramTypePartiallyUnknown: 'Type of parameter "{paramName}" is partially unknown',
        paramTypeUnknown: 'Type of parameter "{paramName}" is unknown',
        parenthesizedContextManagerIllegal: {
          message: 'Parentheses within "with" statement requires Python 3.9 or newer',
          comment: '{Locked=\'with\'}'
        },
        patternNeverMatches: 'Pattern will never be matched for subject type "{type}"',
        positionArgAfterNamedArg: 'Positional argument cannot appear after keyword arguments',
        positionOnlyAfterArgs: 'Position-only parameter separator not allowed after "*" parameter',
        positionOnlyAfterKeywordOnly: '"/" parameter must appear before "*" parameter',
        positionOnlyAfterNon: 'Position-only parameter not allowed after parameter that is not position-only',
        positionOnlyFirstParam: 'Position-only parameter separator not allowed as first parameter',
        positionOnlyIncompatible: 'Position-only parameter separator requires Python 3.8 or newer',
        privateImportFromPyTypedModule: '"{name}" is not exported from module "{module}"',
        privateUsedOutsideOfClass: '"{name}" is private and used outside of the class in which it is declared',
        privateUsedOutsideOfModule: '"{name}" is private and used outside of the module in which it is declared',
        propertyOverridden: {
          message: '"{name}" incorrectly overrides property of same name in class "{className}"',
          comment: '{Locked=\'property\'}'
        },
        propertyStaticMethod: {
          message: 'Static methods not allowed for property getter, setter or deleter',
          comment: '{Locked=\'property\',\'getter\',\'setter\',\'deleter\'}'
        },
        protectedUsedOutsideOfClass: '"{name}" is protected and used outside of the class in which it is declared',
        protocolBaseClass: {
          message: 'Protocol class "{classType}" cannot derive from non-Protocol class "{baseType}"',
          comment: '{Locked=\'Protocol\'}'
        },
        protocolBaseClassWithTypeArgs: {
          message: 'Type arguments are not allowed with Protocol class when using type parameter syntax',
          comment: '{Locked=\'Protocol\'}'
        },
        protocolIllegal: {
          message: 'Use of "Protocol" requires Python 3.7 or newer',
          comment: '{Locked=\'Protocol\'}'
        },
        protocolNotAllowed: {
          message: '"Protocol" cannot be used in this context',
          comment: '{Locked=\'Protocol\'}'
        },
        protocolTypeArgMustBeTypeParam: {
          message: 'Type argument for "Protocol" must be a type parameter',
          comment: '{Locked=\'Protocol\'}'
        },
        protocolUnsafeOverlap: 'Class overlaps "{name}" unsafely and could produce a match at runtime',
        protocolVarianceContravariant: {
          message: 'Type variable "{variable}" used in generic Protocol "{class}" should be contravariant',
          comment: ['{Locked=\'Protocol\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        protocolVarianceCovariant: {
          message: 'Type variable "{variable}" used in generic Protocol "{class}" should be covariant',
          comment: ['{Locked=\'Protocol\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        protocolVarianceInvariant: {
          message: 'Type variable "{variable}" used in generic Protocol "{class}" should be invariant',
          comment: ['{Locked=\'Protocol\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        pyrightCommentInvalidDiagnosticBoolValue: {
          message: 'Pyright comment directive must be followed by "=" and a value of true or false',
          comment: '{Locked=\'Pyright\',\'true\',\'false\'}'
        },
        pyrightCommentInvalidDiagnosticSeverityValue: {
          message: 'Pyright comment directive must be followed by "=" and a value of true, false, error, warning, information, or none',
          comment: '{Locked=\'Pyright\',\'true\',\'false\',\'error\',\'warning\',\'information\',\'none\'}'
        },
        pyrightCommentMissingDirective: {
          message: 'Pyright comment must be followed by a directive (basic or strict) or a diagnostic rule',
          comment: '{Locked=\'Pyright\',\'basic\',\'strict\'}'
        },
        pyrightCommentNotOnOwnLine: {
          message: 'Pyright comments used to control file-level settings must appear on their own line',
          comment: '{Locked=\'Pyright\'}'
        },
        pyrightCommentUnknownDiagnosticRule: {
          message: '"{rule}" is an unknown diagnostic rule for pyright comment',
          comment: '{Locked=\'pyright\'}'
        },
        pyrightCommentUnknownDiagnosticSeverityValue: {
          message: '"{value}" is invalid value for pyright comment; expected true, false, error, warning, information, or none',
          comment: '{Locked=\'pyright\',\'true\',\'false\',\'error\',\'warning\',\'information\',\'none\'}'
        },
        pyrightCommentUnknownDirective: {
          message: '"{directive}" is an unknown directive for pyright comment; expected "strict" or "basic"',
          comment: '{Locked=\'pyright\',\'strict\',\'basic\'}'
        },
        readOnlyArgCount: {
          message: 'Expected a single type argument after "ReadOnly"',
          comment: '{Locked=\'ReadOnly\'}'
        },
        readOnlyNotInTypedDict: {
          message: '"ReadOnly" is not allowed in this context',
          comment: '{Locked=\'ReadOnly\'}'
        },
        recursiveDefinition: 'Type of "{name}" could not be determined because it refers to itself',
        relativeImportNotAllowed: {
          message: 'Relative imports cannot be used with "import .a" form; use "from . import a" instead',
          comment: '{Locked=\'import .a\',\'from . import a\'}'
        },
        requiredArgCount: {
          message: 'Expected a single type argument after "Required"',
          comment: '{Locked=\'Required\'}'
        },
        requiredNotInTypedDict: {
          message: '"Required" is not allowed in this context',
          comment: '{Locked=\'Required\'}'
        },
        returnInAsyncGenerator: {
          message: 'Return statement with value is not allowed in async generator',
          comment: '{Locked=\'async\'}'
        },
        returnMissing: 'Function with declared return type "{returnType}" must return value on all code paths',
        returnInExceptionGroup: {
          message: '"return" is not allowed in an "except*" block',
          comment: '{Locked=\'return\',\'except*\'}'
        },
        returnOutsideFunction: {
          message: '"return" can be used only within a function',
          comment: '{Locked=\'return\'}'
        },
        returnTypeContravariant: 'Contravariant type variable cannot be used in return type',
        returnTypeMismatch: 'Type "{exprType}" is not assignable to return type "{returnType}"',
        returnTypePartiallyUnknown: 'Return type, "{returnType}", is partially unknown',
        returnTypeUnknown: 'Return type is unknown',
        revealLocalsArgs: {
          message: 'Expected no arguments for "reveal_locals" call',
          comment: '{Locked=\'reveal_locals\'}'
        },
        revealLocalsNone: {
          message: 'No locals in this scope',
          comment: '{Locked=\'locals\'}'
        },
        revealTypeArgs: {
          message: 'Expected a single positional argument for "reveal_type" call',
          comment: '{Locked=\'reveal_type\'}'
        },
        revealTypeExpectedTextArg: {
          message: 'The "expected_text" argument for function "reveal_type" must be a str literal value',
          comment: '{Locked=\'expected_text\',\'reveal_type\',\'str\'}'
        },
        revealTypeExpectedTextMismatch: 'Type text mismatch; expected "{expected}" but received "{received}"',
        revealTypeExpectedTypeMismatch: 'Type mismatch; expected "{expected}" but received "{received}"',
        selfTypeContext: {
          message: '"Self" is not valid in this context',
          comment: '{Locked=\'Self\'}'
        },
        selfTypeMetaclass: {
          message: '"Self" cannot be used within a metaclass (a subclass of "type")',
          comment: ['{Locked=\'Self\'}', 'Metaclasses are a complex concept and it may be best to not localize the term']
        },
        selfTypeWithTypedSelfOrCls: {
          message: '"Self" cannot be used in a function with a `self` or `cls` parameter that has a type annotation other than "Self"',
          comment: '{Locked=\'Self\',\'self\',\'cls\'}'
        },
        setterGetterTypeMismatch: {
          message: 'Property setter value type is not assignable to the getter return type',
          comment: ['{Locked=\'setter\',\'getter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        singleOverload: '"{name}" is marked as overload, but additional overloads are missing',
        slotsAttributeError: {
          message: '"{name}" is not specified in __slots__',
          comment: '{Locked=\'__slots__\'}'
        },
        slotsClassVarConflict: {
          message: '"{name}" conflicts with instance variable declared in __slots__',
          comment: '{Locked=\'__slots__\'}'
        },
        starPatternInAsPattern: {
          message: 'Star pattern cannot be used with "as" target',
          comment: ['{Locked=\'as\'}', 'Star pattern refers to the use of the * (star) character to represent a variable length pattern match']
        },
        starPatternInOrPattern: {
          message: 'Star pattern cannot be ORed within other patterns',
          comment: ['Star pattern refers to the use of the * (star) character to represent a variable length pattern match', '\'ORed\' means joined together with a binary \'or\' operation']
        },
        starStarWildcardNotAllowed: '** cannot be used with wildcard "_"',
        staticClsSelfParam: {
          message: 'Static methods should not take a "self" or "cls" parameter',
          comment: '{Locked=\'self\',\'cls\'}'
        },
        stdlibModuleOverridden: {
          message: '"{path}" is overriding the stdlib module "{name}"',
          comment: '{Locked=\'stdlib\'}'
        },
        stringNonAsciiBytes: {
          message: 'Non-ASCII character not allowed in bytes string literal',
          comment: '{Locked=\'ASCII\'}'
        },
        stringNotSubscriptable: 'String expression cannot be subscripted in type expression; enclose entire expression in quotes',
        stringUnsupportedEscape: 'Unsupported escape sequence in string literal',
        stringUnterminated: 'String literal is unterminated',
        stubFileMissing: {
          message: 'Stub file not found for "{importName}"',
          comment: '{StrContains=i\'stub\'}'
        },
        stubUsesGetAttr: {
          message: 'Type stub file is incomplete; "__getattr__" obscures type errors for module',
          comment: ['{Locked=\'__getattr__\'}', '{StrContains=i\'stub\'}']
        },
        sublistParamsIncompatible: {
          message: 'Sublist parameters are not supported in Python 3.x',
          comment: '{StrContains=i\'sublist\'}'
        },
        superCallArgCount: {
          message: 'Expected no more than two arguments to "super" call',
          comment: '{Locked=\'super\'}'
        },
        superCallFirstArg: {
          message: 'Expected class type as first argument to "super" call but received "{type}"',
          comment: '{Locked=\'super\'}'
        },
        superCallSecondArg: {
          message: 'Second argument to "super" call must be object or class that derives from "{type}"',
          comment: '{Locked=\'super\'}'
        },
        superCallZeroArgForm: {
          message: 'Zero-argument form of "super" call is valid only within a method',
          comment: '{Locked=\'super\'}'
        },
        superCallZeroArgFormStaticMethod: {
          message: 'Zero-argument form of "super" call is not valid within a static method',
          comment: '{Locked=\'super\'}'
        },
        symbolIsPossiblyUnbound: '"{name}" is possibly unbound',
        symbolIsUnbound: '"{name}" is unbound',
        symbolIsUndefined: '"{name}" is not defined',
        symbolOverridden: '"{name}" overrides symbol of same name in class "{className}"',
        ternaryNotAllowed: 'Ternary expression not allowed in type expression',
        totalOrderingMissingMethod: {
          message: 'Class must define one of "__lt__", "__le__", "__gt__", or "__ge__" to use total_ordering',
          comment: '{Locked=\'__lt__\',\'__le__\',\'__gt__\',\'__ge__\',\'total_ordering\'}'
        },
        trailingCommaInFromImport: 'Trailing comma not allowed without surrounding parentheses',
        tryWithoutExcept: {
          message: 'Try statement must have at least one except or finally clause',
          comment: ['{Locked=\'except\',\'finally\'}', '{StrContains=i\'try\'}', '\'try\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleAssignmentMismatch: {
          message: 'Expression with type "{type}" cannot be assigned to target tuple',
          comment: '{Locked=\'tuple\'}'
        },
        tupleInAnnotation: {
          message: 'Tuple expression not allowed in type expression',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleIndexOutOfRange: 'Index {index} is out of range for type {type}',
        typeAliasIllegalExpressionForm: 'Invalid expression form for type alias definition',
        typeAliasIsRecursiveDirect: 'Type alias "{name}" cannot use itself in its definition',
        typeAliasNotInModuleOrClass: {
          message: 'A TypeAlias can be defined only within a module or class scope',
          comment: '{Locked=\'TypeAlias\'}'
        },
        typeAliasRedeclared: {
          message: '"{name}" is declared as a TypeAlias and can be assigned only once',
          comment: '{Locked=\'TypeAlias\'}'
        },
        typeAliasStatementBadScope: {
          message: 'A type statement can be used only within a module or class scope',
          comment: '{Locked=\'type\'}'
        },
        typeAliasStatementIllegal: 'Type alias statement requires Python 3.12 or newer',
        typeAliasTypeBaseClass: {
          message: 'A type alias defined in a "type" statement cannot be used as a base class',
          comment: '{Locked=\'"type"\'}'
        },
        typeAliasTypeMustBeAssigned: {
          message: 'TypeAliasType must be assigned to a variable with the same name as the type alias',
          comment: '{Locked=\'TypeAliasType\'}'
        },
        typeAliasTypeNameArg: {
          message: 'First argument to TypeAliasType must be a string literal representing the name of the type alias',
          comment: '{Locked=\'TypeAliasType\'}'
        },
        typeAliasTypeNameMismatch: 'Name of type alias must match the name of the variable to which it is assigned',
        typeAliasTypeParamInvalid: {
          message: 'Type parameter list must be a tuple containing only TypeVar, TypeVarTuple, or ParamSpec',
          comment: '{Locked=\'tuple\',\'TypeVar\',\'TypeVarTuple\',\'ParamSpec\'}'
        },
        typeAnnotationCall: 'Call expression not allowed in type expression',
        typeAnnotationVariable: 'Variable not allowed in type expression',
        typeAnnotationWithCallable: {
          message: 'Type argument for "type" must be a class; callables are not supported',
          comment: ['{Locked=\'type\'}', '\'callables\' are objects that can be called like a function']
        },
        typeArgListExpected: {
          message: 'Expected ParamSpec, ellipsis, or list of types',
          comment: '{Locked=\'ParamSpec\',\'list\'}'
        },
        typeArgListNotAllowed: {
          message: 'List expression not allowed for this type argument',
          comment: ['{StrContains=i\'list\'}', '\'list\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        typeArgsExpectingNone: 'Expected no type arguments for class "{name}"',
        typeArgsMismatchOne: 'Expected one type argument but received {received}',
        typeArgsMissingForAlias: {
          message: 'Expected type arguments for generic type alias "{name}"',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        typeArgsMissingForClass: {
          message: 'Expected type arguments for generic class "{name}"',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        typeArgsTooFew: 'Too few type arguments provided for "{name}"; expected {expected} but received {received}',
        typeArgsTooMany: 'Too many type arguments provided for "{name}"; expected {expected} but received {received}',
        typeAssignmentMismatch: 'Type "{sourceType}" is not assignable to declared type "{destType}"',
        typeAssignmentMismatchWildcard: 'Import symbol "{name}" has type "{sourceType}", which is not assignable to declared type "{destType}"',
        typeCallNotAllowed: {
          message: 'type() call should not be used in type expression',
          comment: '{Locked=\'type()\'}'
        },
        typeCheckOnly: {
          message: '"{name}" is marked as @type_check_only and can be used only in type annotations',
          comment: '{Locked=\'@type_check_only\'}'
        },
        typeCommentDeprecated: {
          message: 'Use of type comments is deprecated; use type annotation instead',
          comment: '{Locked=\'type\'}'
        },
        typeExpectedClass: 'Expected class but received "{type}"',
        typeFormArgs: {
          message: '"TypeForm" accepts a single positional argument',
          comment: '{Locked=\'TypeForm\'}'
        },
        typeGuardArgCount: {
          message: 'Expected a single type argument after "TypeGuard" or "TypeIs"',
          comment: '{Locked=\'TypeGuard\',\'TypeIs\'}'
        },
        typeGuardParamCount: 'User-defined type guard functions and methods must have at least one input parameter',
        typeIsReturnType: {
          message: 'Return type of TypeIs ("{returnType}") is not consistent with value parameter type ("{type}")',
          comment: '{Locked=\'TypeIs\'}'
        },
        typeNotAwaitable: {
          message: '"{type}" is not awaitable',
          comment: '{Locked=\'awaitable\'}'
        },
        typeNotIntantiable: '"{type}" cannot be instantiated',
        typeNotIterable: '"{type}" is not iterable',
        typeNotSpecializable: 'Could not specialize type "{type}"',
        typeNotSubscriptable: 'Object of type "{type}" is not subscriptable',
        typeNotSupportBinaryOperator: 'Operator "{operator}" not supported for types "{leftType}" and "{rightType}"',
        typeNotSupportBinaryOperatorBidirectional: 'Operator "{operator}" not supported for types "{leftType}" and "{rightType}" when expected type is "{expectedType}"',
        typeNotSupportUnaryOperator: 'Operator "{operator}" not supported for type "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'Operator "{operator}" not supported for type "{type}" when expected type is "{expectedType}"',
        typeNotUsableWith: 'Object of type "{type}" cannot be used with "with" because it does not implement {method}',
        typeParameterBoundNotAllowed: {
          message: 'Bound or constraint cannot be used with a variadic type parameter or ParamSpec',
          comment: ['{Locked=\'ParamSpec\'}', '\'variadic\' means that it accepts a variable number of arguments']
        },
        typeParameterConstraintTuple: 'Type parameter constraint must be a tuple of two or more types',
        typeParameterExistingTypeParameter: 'Type parameter "{name}" is already in use',
        typeParameterNotDeclared: 'Type parameter "{name}" is not included in the type parameter list for "{container}"',
        typeParametersMissing: 'At least one type parameter must be specified',
        typePartiallyUnknown: 'Type of "{name}" is partially unknown',
        typeUnknown: 'Type of "{name}" is unknown',
        typeVarAssignedName: {
          message: 'TypeVar must be assigned to a variable named "{name}"',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarAssignmentMismatch: 'Type "{type}" cannot be assigned to type variable "{name}"',
        typeVarBoundAndConstrained: {
          message: 'TypeVar cannot be both bound and constrained',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarBoundGeneric: {
          message: 'TypeVar bound type cannot be generic',
          comment: ['{Locked=\'TypeVar\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        typeVarConstraintGeneric: {
          message: 'TypeVar constraint type cannot be generic',
          comment: ['{Locked=\'TypeVar\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        typeVarDefaultBoundMismatch: {
          message: 'TypeVar default type must be a subtype of the bound type',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarDefaultConstraintMismatch: {
          message: 'TypeVar default type must be one of the constrained types',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarDefaultIllegal: 'Type variable default types require Python 3.13 or newer',
        typeVarDefaultInvalidTypeVar: 'Type parameter "{name}" has a default type that refers to one or more type variables that are out of scope',
        typeVarFirstArg: {
          message: 'Expected name of TypeVar as first argument',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarInvalidForMemberVariable: 'Attribute type cannot use type variable "{name}" scoped to local method',
        typeVarNoMember: {
          message: 'TypeVar "{type}" has no attribute "{name}"',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarNotSubscriptable: {
          message: 'TypeVar "{type}" is not subscriptable',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarNotUsedByOuterScope: 'Type variable "{name}" has no meaning in this context',
        typeVarPossiblyUnsolvable: 'Type variable "{name}" may go unsolved if caller supplies no argument for parameter "{param}"',
        typeVarSingleConstraint: {
          message: 'TypeVar must have at least two constrained types',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarTupleConstraints: {
          message: 'TypeVarTuple cannot have value constraints',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        typeVarTupleContext: {
          message: 'TypeVarTuple is not allowed in this context',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        typeVarTupleDefaultNotUnpacked: {
          message: 'TypeVarTuple default type must be an unpacked tuple or TypeVarTuple',
          comment: '{Locked=\'TypeVarTuple\',\'tuple\'}'
        },
        typeVarTupleMustBeUnpacked: {
          message: 'Unpack operator is required for TypeVarTuple value',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        typeVarTupleUnknownParam: {
          message: '"{name}" is unknown parameter to TypeVarTuple',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        typeVarUnknownParam: {
          message: '"{name}" is unknown parameter to TypeVar',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarUsedByOuterScope: {
          message: 'TypeVar "{name}" is already in use by an outer scope',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarUsedOnlyOnce: {
          message: 'TypeVar "{name}" appears only once in generic function signature',
          comment: ['{Locked=\'TypeVar\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        typeVarVariance: {
          message: 'TypeVar cannot be both covariant and contravariant',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarWithDefaultFollowsVariadic: {
          message: 'TypeVar "{typeVarName}" has a default value and cannot follow TypeVarTuple "{variadicName}"',
          comment: '{Locked=\'TypeVar\',\'TypeVarTuple\'}'
        },
        typeVarWithoutDefault: '"{name}" cannot appear after "{other}" in type parameter list because it has no default type',
        typeVarsNotInGenericOrProtocol: {
          message: 'Generic[] or Protocol[] must include all type variables',
          comment: '{Locked=\'Generic[]\',\'Protocol[]\'}'
        },
        typedDictAccess: {
          message: 'Could not access item in TypedDict',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictAssignedName: {
          message: 'TypedDict must be assigned to a variable named "{name}"',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictBadVar: {
          message: 'TypedDict classes can contain only type annotations',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictBaseClass: {
          message: 'All base classes for TypedDict classes must also be TypedDict classes',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictBoolParam: {
          message: 'Expected "{name}" parameter to have a value of True or False',
          comment: '{Locked=\'True\',\'False\'}'
        },
        typedDictClosedExtras: {
          message: 'Base class "{name}" is a closed TypedDict; extra items must be type "{type}"',
          comment: '{Locked=\'closed\',\'TypedDict\'}'
        },
        typedDictClosedNoExtras: {
          message: 'Base class "{name}" is a closed TypedDict; extra items are not allowed',
          comment: '{Locked=\'closed\',\'TypedDict\'}'
        },
        typedDictDelete: {
          message: 'Could not delete item in TypedDict',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictEmptyName: {
          message: 'Names within a TypedDict cannot be empty',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictEntryName: 'Expected string literal for dictionary entry name',
        typedDictEntryUnique: 'Names within a dictionary must be unique',
        typedDictExtraArgs: {
          message: 'Extra TypedDict arguments not supported',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictExtraItemsClosed: {
          message: 'A TypedDict cannot be closed if it supports extra items',
          comment: '{Locked=\'TypedDict\',\'closed\'}'
        },
        typedDictFieldNotRequiredRedefinition: {
          message: 'TypedDict item "{name}" cannot be redefined as NotRequired',
          comment: '{Locked=\'TypedDict\',\'NotRequired\'}'
        },
        typedDictFieldReadOnlyRedefinition: {
          message: 'TypedDict item "{name}" cannot be redefined as ReadOnly',
          comment: '{Locked=\'TypedDict\',\'ReadOnly\'}'
        },
        typedDictFieldRequiredRedefinition: {
          message: 'TypedDict item "{name}" cannot be redefined as Required',
          comment: '{Locked=\'TypedDict\',\'Required\'}'
        },
        typedDictFirstArg: {
          message: 'Expected TypedDict class name as first argument',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictInClassPattern: {
          message: 'TypedDict class not allowed in class pattern',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictInitsubclassParameter: {
          message: 'TypedDict does not support __init_subclass__ parameter "{name}"',
          comment: '{Locked=\'TypedDict\',\'__init_subclass__\'}'
        },
        typedDictNotAllowed: {
          message: '"TypedDict" cannot be used in this context',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictSecondArgDict: {
          message: 'Expected dict or keyword parameter as second parameter',
          comment: '{Locked=\'dict\'}'
        },
        typedDictSecondArgDictEntry: 'Expected simple dictionary entry',
        typedDictSet: {
          message: 'Could not assign item in TypedDict',
          comment: '{Locked=\'TypedDict\'}'
        },
        unaccessedClass: 'Class "{name}" is not accessed',
        unaccessedFunction: 'Function "{name}" is not accessed',
        unaccessedImport: 'Import "{name}" is not accessed',
        unaccessedSymbol: '"{name}" is not accessed',
        unaccessedVariable: 'Variable "{name}" is not accessed',
        unannotatedFunctionSkipped: 'Analysis of function "{name}" is skipped because it is unannotated',
        unaryOperationNotAllowed: 'Unary operator not allowed in type expression',
        unexpectedAsyncToken: {
          message: 'Expected "def", "with" or "for" to follow "async"',
          comment: '{Locked=\'def\',\'with\',\'for\',\'async\'}'
        },
        unexpectedExprToken: 'Unexpected token at end of expression',
        unexpectedIndent: 'Unexpected indentation',
        unexpectedUnindent: 'Unindent not expected',
        unhashableDictKey: 'Dictionary key must be hashable',
        unhashableSetEntry: {
          message: 'Set entry must be hashable',
          comment: ['{StrContains=i\'set\'}', '\'set\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        uninitializedAbstractVariables: {
          message: 'Variables defined in abstract base class are not initialized in final class "{classType}"',
          comment: '{Locked=\'final\'}'
        },
        uninitializedInstanceVariable: {
          message: 'Instance variable "{name}" is not initialized in the class body or __init__ method',
          comment: '{Locked=\'__init__\'}'
        },
        unionForwardReferenceNotAllowed: {
          message: 'Union syntax cannot be used with string operand; use quotes around entire expression',
          comment: '{Locked=\'Union\'}'
        },
        unionSyntaxIllegal: {
          message: 'Alternative syntax for unions requires Python 3.10 or newer',
          comment: '\'unions\' as in the mathematical set theory term'
        },
        unionTypeArgCount: {
          message: 'Union requires two or more type arguments',
          comment: '{Locked=\'Union\'}'
        },
        unionUnpackedTuple: {
          message: 'Union cannot include an unpacked tuple',
          comment: '{Locked=\'Union\',\'tuple\'}'
        },
        unionUnpackedTypeVarTuple: {
          message: 'Union cannot include an unpacked TypeVarTuple',
          comment: '{Locked=\'Union\',\'TypeVarTuple\'}'
        },
        unnecessaryCast: {
          message: 'Unnecessary "cast" call; type is already "{type}"',
          comment: '{Locked=\'cast\'}'
        },
        unnecessaryIsInstanceAlways: {
          message: 'Unnecessary isinstance call; "{testType}" is always an instance of "{classType}"',
          comment: '{Locked=\'isinstance\'}'
        },
        unnecessaryIsSubclassAlways: {
          message: 'Unnecessary issubclass call; "{testType}" is always a subclass of "{classType}"',
          comment: '{Locked=\'issubclass\'}'
        },
        unnecessaryIsInstanceNever: {
          message: 'Unnecessary isinstance call; "{testType}" is never an instance of "{classType}"',
          comment: '{Locked=\'isinstance\'}'
        },
        unnecessaryIsSubclassNever: {
          message: 'Unnecessary issubclass call; "{testType}" is never a subclass of "{classType}"',
          comment: '{Locked=\'issubclass\'}'
        },
        unnecessaryPyrightIgnore: {
          message: 'Unnecessary "# pyright: ignore" comment',
          comment: '{Locked=\'# pyright: ignore\'}'
        },
        unnecessaryPyrightIgnoreRule: {
          message: 'Unnecessary "# pyright: ignore" rule: "{name}"',
          comment: '{Locked=\'# pyright: ignore\'}'
        },
        unnecessaryTypeIgnore: {
          message: 'Unnecessary "# type: ignore" comment',
          comment: '{Locked=\'# type: ignore\'}'
        },
        unpackArgCount: {
          message: 'Expected a single type argument after "Unpack"',
          comment: '{Locked=\'Unpack\'}'
        },
        unpackExpectedTypeVarTuple: {
          message: 'Expected TypeVarTuple or tuple as type argument for Unpack',
          comment: '{Locked=\'TypeVarTuple\',\'tuple\',\'Unpack\'}'
        },
        unpackExpectedTypedDict: {
          message: 'Expected TypedDict type argument for Unpack',
          comment: '{Locked=\'TypedDict\',\'Unpack\'}'
        },
        unpackIllegalInComprehension: {
          message: 'Unpack operation not allowed in comprehension',
          comment: 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable'
        },
        unpackInAnnotation: 'Unpack operator not allowed in type expression',
        unpackInDict: 'Unpack operation not allowed in dictionaries',
        unpackInSet: {
          message: 'Unpack operator not allowed within a set',
          comment: '{Locked=\'set\'}'
        },
        unpackNotAllowed: {
          message: 'Unpack is not allowed in this context',
          comment: '{Locked=\'Unpack\'}'
        },
        unpackOperatorNotAllowed: 'Unpack operation is not allowed in this context',
        unpackTuplesIllegal: {
          message: 'Unpack operation not allowed in tuples prior to Python 3.8',
          comment: '\'tuple\' is a keyword and should not be localized, but here it is pluralized'
        },
        unpackedArgInTypeArgument: 'Unpacked arguments cannot be used in this context',
        unpackedArgWithVariadicParam: {
          message: 'Unpacked argument cannot be used for TypeVarTuple parameter',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        unpackedDictArgumentNotMapping: {
          message: 'Argument expression after ** must be a mapping with a "str" key type',
          comment: '{Locked=\'str\'}'
        },
        unpackedDictSubscriptIllegal: 'Dictionary unpack operator in subscript is not allowed',
        unpackedSubscriptIllegal: 'Unpack operator in subscript requires Python 3.11 or newer',
        unpackedTypeVarTupleExpected: {
          message: 'Expected unpacked TypeVarTuple; use Unpack[{name1}] or *{name2}',
          comment: '{Locked=\'TypeVarTuple\',\'Unpack[{name1}]\',\'*{name2}\'}'
        },
        unpackedTypedDictArgument: {
          message: 'Unable to match unpacked TypedDict argument to parameters',
          comment: '{Locked=\'TypedDict\'}'
        },
        unreachableCode: 'Code is unreachable',
        unreachableCodeType: 'Type analysis indicates code is unreachable',
        unreachableExcept: {
          message: 'Except clause is unreachable because exception is already handled',
          comment: ['{StrContains=i\'except\'}', '\'except\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        unsupportedDunderAllOperation: {
          message: 'Operation on "__all__" is not supported, so exported symbol list may be incorrect',
          comment: '{Locked=\'__all__\'}'
        },
        unusedCallResult: 'Result of call expression is of type "{type}" and is not used; assign to variable "_" if this is intentional',
        unusedCoroutine: {
          message: 'Result of async function call is not used; use "await" or assign result to variable',
          comment: '{Locked=\'async\'}'
        },
        unusedExpression: 'Expression value is unused',
        varAnnotationIllegal: {
          message: 'Type annotations for variables requires Python 3.6 or newer; use type comment for compatibility with previous versions',
          comment: '{Locked=\'type\'}'
        },
        variableFinalOverride: {
          message: 'Variable "{name}" is marked Final and overrides non-Final variable of same name in class "{className}"',
          comment: '{Locked=\'Final\'}'
        },
        variadicTypeArgsTooMany: {
          message: 'Type argument list can have at most one unpacked TypeVarTuple or tuple',
          comment: '{Locked=\'TypeVarTuple\',\'tuple\'}'
        },
        variadicTypeParamTooManyAlias: {
          message: 'Type alias can have at most one TypeVarTuple type parameter but received multiple ({names})',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        variadicTypeParamTooManyClass: {
          message: 'Generic class can have at most one TypeVarTuple type parameter but received multiple ({names})',
          comment: ['{Locked=\'TypeVarTuple\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        walrusIllegal: 'Operator ":=" requires Python 3.8 or newer',
        walrusNotAllowed: 'Operator ":=" is not allowed in this context without surrounding parentheses',
        wildcardInFunction: {
          message: 'Wildcard import not allowed within a class or function',
          comment: '{Locked=\'import\'}'
        },
        wildcardLibraryImport: {
          message: 'Wildcard import from a library not allowed',
          comment: '{Locked=\'import\'}'
        },
        wildcardPatternTypePartiallyUnknown: 'Type captured by wildcard pattern is partially unknown',
        wildcardPatternTypeUnknown: 'Type captured by wildcard pattern is unknown',
        yieldFromIllegal: {
          message: 'Use of "yield from" requires Python 3.3 or newer',
          comment: '{Locked=\'yield from\'}'
        },
        yieldFromOutsideAsync: {
          message: '"yield from" not allowed in an async function',
          comment: '{Locked=\'yield from\',\'async\'}'
        },
        yieldOutsideFunction: {
          message: '"yield" not allowed outside of a function or lambda',
          comment: '{Locked=\'yield\'}'
        },
        yieldWithinComprehension: {
          message: '"yield" not allowed inside a comprehension',
          comment: ['{Locked=\'yield\'}', 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable']
        },
        zeroCaseStatementsFound: {
          message: 'Match statement must include at least one case statement',
          comment: ['{Locked=\'case\'}', '{StrContains=i\'match\'}', '\'match\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        zeroLengthTupleNotAllowed: {
          message: 'Zero-length tuple is not allowed in this context',
          comment: '{Locked=\'tuple\'}'
        }
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: {
          message: '"Annotated" special form cannot be used with instance and class checks',
          comment: '{Locked=\'Annotated\'}'
        },
        argParam: 'Argument corresponds to parameter "{paramName}"',
        argParamFunction: 'Argument corresponds to parameter "{paramName}" in function "{functionName}"',
        argsParamMissing: 'Parameter "*{paramName}" has no corresponding parameter',
        argsPositionOnly: 'Position-only parameter mismatch; expected {expected} but received {received}',
        argumentType: 'Argument type is "{type}"',
        argumentTypes: 'Argument types: ({types})',
        assignToNone: {
          message: 'Type is not assignable to "None"',
          comment: '{Locked=\'None\'}'
        },
        asyncHelp: {
          message: 'Did you mean "async with"?',
          comment: '{Locked=\'async with\'}'
        },
        baseClassIncompatible: 'Base class "{baseClass}" is incompatible with type "{type}"',
        baseClassIncompatibleSubclass: 'Base class "{baseClass}" derives from "{subclass}" which is incompatible with type "{type}"',
        baseClassOverriddenType: 'Base class "{baseClass}" provides type "{type}", which is overridden',
        baseClassOverridesType: 'Base class "{baseClass}" overrides with type "{type}"',
        bytesTypePromotions: {
          message: 'Set disableBytesTypePromotions to false to enable type promotion behavior for "bytearray" and "memoryview"',
          comment: '{Locked=\'disableBytesTypePromotions\',\'false\',\'bytearray\',\'memoryview\'}'
        },
        conditionalRequiresBool: {
          message: 'Method __bool__ for type "{operandType}" returns type "{boolReturnType}" rather than "bool"',
          comment: '{Locked=\'__bool__\'}'
        },
        dataClassFieldLocation: 'Field declaration',
        dataClassFrozen: '"{name}" is frozen',
        dataProtocolUnsupported: '"{name}" is a data protocol',
        descriptorAccessBindingFailed: {
          message: 'Failed to bind method "{name}" for descriptor class "{className}"',
          comment: 'Binding is the process through which Pyright determines what object a name refers to'
        },
        descriptorAccessCallFailed: 'Failed to call method "{name}" for descriptor class "{className}"',
        finalMethod: {
          message: 'Final method',
          comment: '{Locked=\'Final\'}'
        },
        functionParamDefaultMissing: 'Parameter "{name}" is missing default argument',
        functionParamName: 'Parameter name mismatch: "{destName}" versus "{srcName}"',
        functionParamPositionOnly: 'Position-only parameter mismatch; parameter "{name}" is not position-only',
        functionReturnTypeMismatch: 'Function return type "{sourceType}" is incompatible with type "{destType}"',
        functionTooFewParams: 'Function accepts too few positional parameters; expected {expected} but received {received}',
        functionTooManyParams: 'Function accepts too many positional parameters; expected {expected} but received {received}',
        genericClassNotAllowed: {
          message: 'Generic type with type arguments not allowed for instance or class checks',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        incompatibleDeleter: {
          message: 'Property deleter method is incompatible',
          comment: ['{Locked=\'deleter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        incompatibleGetter: {
          message: 'Property getter method is incompatible',
          comment: ['{Locked=\'getter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        incompatibleSetter: {
          message: 'Property setter method is incompatible',
          comment: ['{Locked=\'setter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        initMethodLocation: {
          message: 'The __init__ method is defined in class "{type}"',
          comment: '{Locked=\'__init__\'}'
        },
        initMethodSignature: {
          message: 'Signature of __init__ is "{type}"',
          comment: '{Locked=\'__init__\'}'
        },
        initSubclassLocation: {
          message: 'The __init_subclass__ method is defined in class "{name}"',
          comment: '{Locked=\'__init_subclass__\'}'
        },
        invariantSuggestionDict: {
          message: 'Consider switching from "dict" to "Mapping" which is covariant in the value type',
          comment: '{Locked=\'dict\',\'Mapping\'}'
        },
        invariantSuggestionList: {
          message: 'Consider switching from "list" to "Sequence" which is covariant',
          comment: '{Locked=\'list\',\'Sequence\'}'
        },
        invariantSuggestionSet: {
          message: 'Consider switching from "set" to "Container" which is covariant',
          comment: '{Locked=\'set\',\'Container\'}'
        },
        isinstanceClassNotSupported: '"{type}" is not supported for instance and class checks',
        keyNotRequired: '"{name}" is not a required key in "{type}", so access may result in runtime exception',
        keyReadOnly: '"{name}" is a read-only key in "{type}"',
        keyRequiredDeleted: '"{name}" is a required key and cannot be deleted',
        keyUndefined: '"{name}" is not a defined key in "{type}"',
        kwargsParamMissing: 'Parameter "**{paramName}" has no corresponding parameter',
        listAssignmentMismatch: 'Type "{type}" is incompatible with target list',
        literalAssignmentMismatch: '"{sourceType}" is not assignable to type "{destType}"',
        matchIsNotExhaustiveHint: {
          message: 'If exhaustive handling is not intended, add "case _: pass"',
          comment: '{Locked=\'case _: pass\'}'
        },
        matchIsNotExhaustiveType: 'Unhandled type: "{type}"',
        memberAssignment: 'Expression of type "{type}" cannot be assigned to attribute "{name}" of class "{classType}"',
        memberIsAbstract: '"{type}.{name}" is not implemented',
        memberIsAbstractMore: {
          message: 'and {count} more...',
          comment: '{StrEnds=\'...\'}'
        },
        memberIsClassVarInProtocol: {
          message: '"{name}" is defined as a ClassVar in protocol',
          comment: '{Locked=\'ClassVar\'}'
        },
        memberIsInitVar: {
          message: '"{name}" is an init-only field',
          comment: '{Locked=\'init-only\'}'
        },
        memberIsInvariant: '"{name}" is invariant because it is mutable',
        memberIsNotClassVarInClass: {
          message: '"{name}" must be defined as a ClassVar to be compatible with protocol',
          comment: '{Locked=\'ClassVar\'}'
        },
        memberIsNotClassVarInProtocol: {
          message: '"{name}" is not defined as a ClassVar in protocol',
          comment: '{Locked=\'ClassVar\'}'
        },
        memberIsNotReadOnlyInProtocol: '"{name}" is not read-only in protocol',
        memberIsReadOnlyInProtocol: '"{name}" is read-only in protocol',
        memberIsWritableInProtocol: '"{name}" is writable in protocol',
        memberSetClassVar: {
          message: 'Attribute "{name}" cannot be assigned through a class instance because it is a ClassVar',
          comment: '{Locked=\'ClassVar\'}'
        },
        memberTypeMismatch: '"{name}" is an incompatible type',
        memberUnknown: 'Attribute "{name}" is unknown',
        metaclassConflict: {
          message: 'Metaclass "{metaclass1}" conflicts with "{metaclass2}"',
          comment: 'Metaclasses are a complex concept and it may be best to not localize the term'
        },
        missingDeleter: {
          message: 'Property deleter method is missing',
          comment: ['{Locked=\'deleter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        missingGetter: {
          message: 'Property getter method is missing',
          comment: ['{Locked=\'getter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        missingSetter: {
          message: 'Property setter method is missing',
          comment: ['{Locked=\'setter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        namedParamMissingInDest: 'Extra parameter "{name}"',
        namedParamMissingInSource: 'Missing keyword parameter "{name}"',
        namedParamTypeMismatch: 'Keyword parameter "{name}" of type "{sourceType}" is incompatible with type "{destType}"',
        namedTupleNotAllowed: {
          message: 'NamedTuple cannot be used for instance or class checks',
          comment: '{Locked=\'NamedTuple\'}'
        },
        newMethodLocation: {
          message: 'The __new__ method is defined in class "{type}"',
          comment: '{Locked=\'__new__\'}'
        },
        newMethodSignature: {
          message: 'Signature of __new__ is "{type}"',
          comment: '{Locked=\'__new__\'}'
        },
        newTypeClassNotAllowed: {
          message: 'Class created with NewType cannot be used with instance and class checks',
          comment: '{Locked=\'NewType\'}'
        },
        noOverloadAssignable: 'No overloaded function matches type "{type}"',
        noneNotAllowed: {
          message: 'None cannot be used for instance or class checks',
          comment: '{Locked=\'None\'}'
        },
        orPatternMissingName: 'Missing names: {name}',
        overloadIndex: 'Overload {index} is the closest match',
        overloadNotAssignable: 'One or more overloads of "{name}" is not assignable',
        overloadSignature: 'Overload signature is defined here',
        overriddenMethod: 'Overridden method',
        overriddenSymbol: 'Overridden symbol',
        overrideInvariantMismatch: 'Override type "{overrideType}" is not the same as base type "{baseType}"',
        overrideIsInvariant: 'Variable is mutable so its type is invariant',
        overrideNoOverloadMatches: 'No overload signature in override is compatible with base method',
        overrideNotClassMethod: {
          message: 'Base method is declared as a classmethod but override is not',
          comment: '{Locked=\'classmethod\'}'
        },
        overrideNotInstanceMethod: 'Base method is declared as an instance method but override is not',
        overrideNotStaticMethod: {
          message: 'Base method is declared as a staticmethod but override is not',
          comment: '{Locked=\'staticmethod\'}'
        },
        overrideOverloadNoMatch: 'Override does not handle all overloads of base method',
        overrideOverloadOrder: 'Overloads for override method must be in the same order as the base method',
        overrideParamKeywordNoDefault: 'Keyword parameter "{name}" mismatch: base parameter has default argument value, override parameter does not',
        overrideParamKeywordType: 'Keyword parameter "{name}" type mismatch: base parameter is type "{baseType}", override parameter is type "{overrideType}"',
        overrideParamName: 'Parameter {index} name mismatch: base parameter is named "{baseName}", override parameter is named "{overrideName}"',
        overrideParamNameExtra: 'Parameter "{name}" is missing in base',
        overrideParamNameMissing: 'Parameter "{name}" is missing in override',
        overrideParamNamePositionOnly: 'Parameter {index} mismatch: base parameter "{baseName}" is keyword parameter, override parameter is position-only',
        overrideParamNoDefault: 'Parameter {index} mismatch: base parameter has default argument value, override parameter does not',
        overrideParamType: 'Parameter {index} type mismatch: base parameter is type "{baseType}", override parameter is type "{overrideType}"',
        overridePositionalParamCount: 'Positional parameter count mismatch; base method has {baseCount}, but override has {overrideCount}',
        overrideReturnType: 'Return type mismatch: base method returns type "{baseType}", override returns type "{overrideType}"',
        overrideType: 'Base class defines type as "{type}"',
        paramAssignment: 'Parameter {index}: type "{sourceType}" is incompatible with type "{destType}"',
        paramSpecMissingInOverride: {
          message: 'ParamSpec parameters are missing in override method',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramType: 'Parameter type is "{paramType}"',
        privateImportFromPyTypedSource: 'Import from "{module}" instead',
        propertyAccessFromProtocolClass: 'A property defined within a protocol class cannot be accessed as a class variable',
        propertyMethodIncompatible: {
          message: 'Property method "{name}" is incompatible',
          comment: ['{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        propertyMethodMissing: {
          message: 'Property method "{name}" is missing in override',
          comment: ['{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        propertyMissingDeleter: {
          message: 'Property "{name}" has no defined deleter',
          comment: ['{Locked=\'deleter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        propertyMissingSetter: {
          message: 'Property "{name}" has no defined setter',
          comment: ['{Locked=\'setter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        protocolIncompatible: '"{sourceType}" is incompatible with protocol "{destType}"',
        protocolMemberMissing: '"{name}" is not present',
        protocolRequiresRuntimeCheckable: {
          message: 'Protocol class must be @runtime_checkable to be used with instance and class checks',
          comment: '{Locked=\'Protocol\',\'@runtime_checkable\'}'
        },
        protocolSourceIsNotConcrete: '"{sourceType}" is not a concrete class type and cannot be assigned to type "{destType}"',
        protocolUnsafeOverlap: 'Attributes of "{name}" have the same names as the protocol',
        pyrightCommentIgnoreTip: {
          message: 'Use "# pyright: ignore[<diagnostic rules>]" to suppress diagnostics for a single line',
          comment: '{Locked=\'# pyright: ignore[<diagnostic rules>]\'}'
        },
        readOnlyAttribute: 'Attribute "{name}" is read-only',
        seeClassDeclaration: 'See class declaration',
        seeDeclaration: 'See declaration',
        seeFunctionDeclaration: 'See function declaration',
        seeMethodDeclaration: 'See method declaration',
        seeParameterDeclaration: 'See parameter declaration',
        seeTypeAliasDeclaration: 'See type alias declaration',
        seeVariableDeclaration: 'See variable declaration',
        tupleAssignmentMismatch: {
          message: 'Type "{type}" is incompatible with target tuple',
          comment: '{Locked=\'tuple\'}'
        },
        tupleEntryTypeMismatch: {
          message: 'Tuple entry {entry} is incorrect type',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleSizeIndeterminateSrc: {
          message: 'Tuple size mismatch; expected {expected} but received indeterminate',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleSizeIndeterminateSrcDest: {
          message: 'Tuple size mismatch; expected {expected} or more but received indeterminate',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleSizeMismatch: {
          message: 'Tuple size mismatch; expected {expected} but received {received}',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleSizeMismatchIndeterminateDest: {
          message: 'Tuple size mismatch; expected {expected} or more but received {received}',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        typeAliasInstanceCheck: {
          message: 'Type alias created with "type" statement cannot be used with instance and class checks',
          comment: '{Locked=\'type\'}'
        },
        typeAssignmentMismatch: 'Type "{sourceType}" is not assignable to type "{destType}"',
        typeBound: 'Type "{sourceType}" is not assignable to upper bound "{destType}" for type variable "{name}"',
        typeConstrainedTypeVar: 'Type "{type}" is not assignable to constrained type variable "{name}"',
        typeIncompatible: '"{sourceType}" is not assignable to "{destType}"',
        typeNotClass: '"{type}" is not a class',
        typeNotStringLiteral: '"{type}" is not a string literal',
        typeOfSymbol: 'Type of "{name}" is "{type}"',
        typeParamSpec: {
          message: 'Type "{type}" is incompatible with ParamSpec "{name}"',
          comment: '{Locked=\'ParamSpec\'}'
        },
        typeUnsupported: 'Type "{type}" is unsupported',
        typeVarDefaultOutOfScope: 'Type variable "{name}" is not in scope',
        typeVarIsContravariant: 'Type parameter "{name}" is contravariant, but "{sourceType}" is not a supertype of "{destType}"',
        typeVarIsCovariant: 'Type parameter "{name}" is covariant, but "{sourceType}" is not a subtype of "{destType}"',
        typeVarIsInvariant: 'Type parameter "{name}" is invariant, but "{sourceType}" is not the same as "{destType}"',
        typeVarNotAllowed: {
          message: 'TypeVar not allowed for instance or class checks',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarTupleRequiresKnownLength: {
          message: 'TypeVarTuple cannot be bound to a tuple of unknown length',
          comment: '{Locked=\'TypeVarTuple\',\'tuple\'}'
        },
        typeVarUnnecessarySuggestion: 'Use {type} instead',
        typeVarUnsolvableRemedy: 'Provide an overload that specifies the return type when the argument is not supplied',
        typeVarsMissing: 'Missing type variables: {names}',
        typedDictBaseClass: {
          message: 'Class "{type}" is not a TypedDict',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictClassNotAllowed: {
          message: 'TypedDict class not allowed for instance or class checks',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictClosedExtraNotAllowed: 'Cannot add item "{name}"',
        typedDictClosedExtraTypeMismatch: 'Cannot add item "{name}" with type "{type}"',
        typedDictClosedFieldNotRequired: {
          message: 'Cannot add item "{name}" because it must be NotRequired',
          comment: '{Locked=\'NotRequired\'}'
        },
        typedDictExtraFieldNotAllowed: '"{name}" is not present in "{type}"',
        typedDictExtraFieldTypeMismatch: {
          message: 'Type of "{name}" is incompatible with type of "extra_items" in "{type}"',
          comment: '{Locked=\'extra_items\'}'
        },
        typedDictFieldMissing: '"{name}" is missing from "{type}"',
        typedDictFieldNotReadOnly: '"{name}" is not read-only in "{type}"',
        typedDictFieldNotRequired: '"{name}" is not required in "{type}"',
        typedDictFieldRequired: '"{name}" is required in "{type}"',
        typedDictFieldTypeMismatch: 'Type "{type}" is not assignable to item "{name}"',
        typedDictFieldUndefined: '"{name}" is an undefined item in type "{type}"',
        typedDictFinalMismatch: {
          message: '"{sourceType}" is incompatible with "{destType}" because of a @final mismatch',
          comment: '{Locked=\'@final\'}'
        },
        typedDictKeyAccess: {
          message: 'Use ["{name}"] to reference item in TypedDict',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictNotAllowed: {
          message: 'TypedDict cannot be used for instance or class checks',
          comment: '{Locked=\'TypedDict\'}'
        },
        unhashableType: 'Type "{type}" is not hashable',
        uninitializedAbstractVariable: 'Instance variable "{name}" is defined in abstract base class "{classType}" but not initialized',
        unreachableExcept: '"{exceptionType}" is a subclass of "{parentType}"',
        useDictInstead: {
          message: 'Use Dict[T1, T2] to indicate a dictionary type',
          comment: '{Locked=\'Dict[T1, T2]\'}'
        },
        useListInstead: {
          message: 'Use List[T] to indicate a list type or Union[T1, T2] to indicate a union type',
          comment: '{Locked=\'List[T]\',\'list\',\'Union[T1, T2]\',\'union\'}'
        },
        useTupleInstead: {
          message: 'Use tuple[T1, ..., Tn] to indicate a tuple type or Union[T1, T2] to indicate a union type',
          comment: '{Locked=\'tuple[T1, ..., Tn]\',\'tuple\',\'Union[T1, T2]\',\'union\'}'
        },
        useTypeInstead: {
          message: 'Use Type[T] instead',
          comment: '{Locked=\'Type[T]\'}'
        },
        varianceMismatchForClass: 'Variance of type argument "{typeVarName}" is incompatible with base class "{className}"',
        varianceMismatchForTypeAlias: 'Variance of type argument "{typeVarName}" is incompatible with "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'Enumeration of workspace source files is taking a long time. Consider opening a sub-folder instead. [Learn more](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  45458: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Crear Tipo Stub',
        createTypeStubFor: 'Crear Tipo Stub Para "{moduleName}"',
        executingCommand: 'Ejecutando el comando',
        filesToAnalyzeCount: '{count} archivos para analizar',
        filesToAnalyzeOne: '1 archivo para analizar',
        findingReferences: 'Buscando referencias',
        organizeImports: 'Organizar Importaciones',
        renameShadowedFile: 'Cambie el nombre de "{oldFile}" a "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Importación automática',
        indexValueDetail: 'Valor de índice'
      },
      Diagnostic: {
        abstractMethodInvocation: 'No se puede llamar al método "{method}" porque es abstracto y no se ha implementado.',
        annotatedMetadataInconsistent: 'El tipo de metadatos anotados "{metadataType}" no es compatible con el tipo "{type}"',
        annotatedParamCountMismatch: 'El recuento de anotaciones del parámetro no coincide: se esperaba {expected}, pero se recibió {received}',
        annotatedTypeArgMissing: 'Se espera un argumento de tipo y una o más anotaciones para "Annotated".',
        annotationBytesString: 'Las expresiones de tipo no pueden usar literales de cadena de bytes',
        annotationFormatString: 'Las expresiones de tipo no pueden usar literales de cadena de formato (f-strings)',
        annotationNotSupported: 'No se admite la anotación de tipo para esta declaración',
        annotationRawString: 'Las expresiones de tipo no pueden usar literales de cadena sin formato',
        annotationSpansStrings: 'Las expresiones de tipo no pueden abarcar varios literales de cadena',
        annotationStringEscape: 'Las expresiones de tipo no pueden contener caracteres de escape',
        argAssignment: 'Argumento de tipo "{argType}" no puede ser asignado a parámetro de tipo "{paramType}"',
        argAssignmentFunction: 'El argumento de tipo "{argType}" no puede ser asignado a parámetro de tipo "{paramType}" en función "{functionName}"',
        argAssignmentParam: 'Argumento de tipo "{argType}" no puede ser asignado a parámetro "{paramName}" de tipo "{paramType}"',
        argAssignmentParamFunction: 'Argumento de tipo "{argType}" no puede ser asignado a parámetro "{paramName}" de tipo "{paramType}" en función "{functionName}"',
        argMissingForParam: 'Falta el argumento para el parámetro {name}',
        argMissingForParams: 'Faltan argumentos para los parámetros {names}',
        argMorePositionalExpectedCount: 'Más argumentos posicionales {expected} esperados',
        argMorePositionalExpectedOne: 'Se espera 1 argumento posicional más',
        argPositional: 'Argumento posicional esperado',
        argPositionalExpectedCount: 'Argumentos posicionales esperados {expected}',
        argPositionalExpectedOne: 'Se espera 1 argumento posicional',
        argTypePartiallyUnknown: 'El tipo de argumento es parcialmente desconocido',
        argTypeUnknown: 'Tipo de argumento desconocido',
        assertAlwaysTrue: 'La expresión Assert siempre se evalúa como true',
        assertTypeArgs: '"assert_type" espera dos argumentos posicionales',
        assertTypeTypeMismatch: 'Error de coincidencia "assert_type": se esperaba "{expected}" pero se ha recibido "{received}"',
        assignmentExprComprehension: 'El destino de la expresión de asignación "{name}" no puede usar el mismo nombre que la comprensión para el destino',
        assignmentExprContext: 'La expresión de asignación debe estar dentro de un módulo, función o lambda',
        assignmentExprInSubscript: 'Las expresiones de asignación dentro de un subíndice solo se admiten en Python 3.10 y versiones posteriores.',
        assignmentInProtocol: 'Las variables de instancia o clase dentro de una clase Protocol deben declararse explícitamente en el cuerpo de la clase.',
        assignmentTargetExpr: 'La expresión no puede ser objetivo de asignación',
        asyncNotInAsyncFunction: 'No se permite el uso de "async" fuera de la función async',
        awaitIllegal: 'El uso de "await" requiere Python 3.5 o posterior.',
        awaitNotAllowed: 'Las expresiones de tipo no pueden usar "await"',
        awaitNotInAsync: '"await" solo se permite dentro de una función async',
        backticksIllegal: 'En Python 3.x no se admiten expresiones rodeadas de puntos suspensivos; utilice repr en su lugar.',
        baseClassCircular: 'La clase no se puede derivar de sí misma',
        baseClassFinal: 'La clase base "{type}" está marcada como final y no puede ser subclasificada',
        baseClassIncompatible: 'Las clases base de {type} son mutuamente incompatibles',
        baseClassInvalid: 'El argumento de la clase debe ser una clase base',
        baseClassMethodTypeIncompatible: 'Las clases base para la clase "{classType}" definen el método "{name}" de forma incompatible',
        baseClassUnknown: 'Se desconoce el tipo de la clase base, lo que oculta el tipo de la clase derivada.',
        baseClassVariableTypeIncompatible: 'Las clases base para la clase "{classType}" definen la variable "{name}" de forma incompatible',
        binaryOperationNotAllowed: 'Operador binario no permitido en la expresión de tipo',
        bindTypeMismatch: 'No se pudo enlazar el método "{methodName}" porque "{type}" no se puede asignar al parámetro "{paramName}"',
        breakInExceptionGroup: 'No se permite "break" en un bloque "except*"',
        breakOutsideLoop: '"break" solo se puede usar dentro de un bucle',
        callableExtraArgs: 'Se esperaban solo dos argumentos de tipo para "Callable".',
        callableFirstArg: 'Lista de tipos de parámetros esperados o "..."',
        callableNotInstantiable: 'No se puede instanciar el tipo "{type}"',
        callableSecondArg: 'Tipo de retorno esperado como segundo argumento de tipo para "Callable"',
        casePatternIsIrrefutable: 'El patrón irrefutable solo se permite para la última instrucción case',
        classAlreadySpecialized: 'El tipo "{type}" ya está especializado',
        classDecoratorTypeUnknown: 'El decorador de clase sin tipo oculta el tipo de clase; omitiendo el elemento Decorator',
        classDefinitionCycle: 'La definición de clase para "{name}" depende de sí misma.',
        classGetItemClsParam: '__class_getitem__ debe tomar un parámetro "cls"',
        classMethodClsParam: 'Los métodos de clase deben tomar un parámetro "cls"',
        classNotRuntimeSubscriptable: 'El subíndice para la clase "{name}" generará una excepción en tiempo de ejecución; encierre la expresión de tipo entre comillas',
        classPatternBuiltInArgPositional: 'El patrón de clase solo acepta subpatrones posicionales',
        classPatternPositionalArgCount: 'Demasiados patrones posicionales para la clase "{type}"; esperado {expected} pero recibido {received}',
        classPatternTypeAlias: '"{type}" no se puede usar en un patrón de clase porque es un alias de tipo especializado',
        classPropertyDeprecated: 'Las propiedades de clase están en desuso en Python 3.11 y no se admitirán en Python 3.13.',
        classTypeParametersIllegal: 'La sintaxis de los parámetros de tipo de clase requiere Python 3.12 o posterior.',
        classVarFirstArgMissing: 'Se esperaba un argumento de tipo después de "ClassVar"',
        classVarNotAllowed: '"ClassVar" no está permitido en este contexto',
        classVarOverridesInstanceVar: 'La variable de clase "{name}" anula la variable de instancia del mismo nombre en la clase "{className}"',
        classVarTooManyArgs: 'Solo se esperaba un argumento de tipo después de "ClassVar"',
        classVarWithTypeVar: 'El tipo "ClassVar" no puede incluir variables de tipo',
        clsSelfParamTypeMismatch: 'El tipo de parámetro "{name}" debe ser un supertipo de su clase "{classType}"',
        codeTooComplexToAnalyze: 'El código es demasiado complejo para analizarlo; reduzca la complejidad refactorizándolo en subrutinas o reduciendo las rutas de código condicional.',
        collectionAliasInstantiation: 'No se puede crear una instancia del tipo "{type}"; use "{alias}" en su lugar.',
        comparisonAlwaysFalse: 'La condición siempre se evaluará como False, ya que los tipos "{leftType}" y "{rightType}" no se superponen.',
        comparisonAlwaysTrue: 'La condición siempre se evaluará como True, ya que los tipos "{leftType}" y "{rightType}" no se superponen.',
        comprehensionInDict: 'La comprensión no puede utilizarse con otras entradas del diccionario',
        comprehensionInSet: 'La comprensión no se puede usar con otras entradas de set',
        concatenateContext: '"Concatenate" no se permite en este contexto',
        concatenateParamSpecMissing: 'El último argumento de tipo para "Concatenate" debe ser un ParamSpec o "..."',
        concatenateTypeArgsMissing: '"Concatenate" requiere al menos dos argumentos de tipo',
        conditionalOperandInvalid: 'Operando condicional no válido de tipo "{type}"',
        constantRedefinition: '"{name}" es constante (porque está en mayúsculas) y no se puede volver a definir',
        constructorParametersMismatch: 'Error de coincidencia entre la firma de __new__ y __init__ en la clase "{classType}"',
        containmentAlwaysFalse: 'La expresión siempre se evaluará como False, ya que los tipos "{leftType}" y "{rightType}" no tienen superposición',
        containmentAlwaysTrue: 'La expresión siempre se evaluará como True, ya que los tipos "{leftType}" y "{rightType}" no tienen superposición',
        continueInExceptionGroup: 'No se permite "continue" en un bloque "except*"',
        continueOutsideLoop: '"continue" solo puede utilizarse dentro de un bucle',
        coroutineInConditionalExpression: 'La expresión condicional hace referencia a una corrutina que siempre se evalúa como True',
        dataClassBaseClassFrozen: 'Una clase no inmovilizada no puede heredar de una clase inmovilizada',
        dataClassBaseClassNotFrozen: 'Una clase congelada no puede heredar de una clase que no esté congelada',
        dataClassConverterFunction: 'Argumento de tipo "{argType}" no es un convertidor válido para el campo "{fieldName}" de tipo "{fieldType}"',
        dataClassConverterOverloads: 'No hay sobrecargas de "{funcName}" que sean convertidores válidos para el campo "{fieldName}" de tipo "{fieldType}"',
        dataClassFieldInheritedDefault: '"{fieldName}" invalida un campo con el mismo nombre, pero falta un valor predeterminado',
        dataClassFieldWithDefault: 'Los campos sin valores predeterminados no pueden aparecer después de los campos con valores predeterminados',
        dataClassFieldWithPrivateName: 'El campo Dataclass no puede utilizar un nombre privado',
        dataClassFieldWithoutAnnotation: 'El campo Dataclass sin anotación de tipo provocará una excepción en tiempo de ejecución',
        dataClassPostInitParamCount: 'Dataclass __post_init__ recuento de parámetros incorrecto; el número de campos InitVar es {expected}.',
        dataClassPostInitType: 'El tipo de parámetro del método __post_init__ de la clase de datos no coincide con el del campo "{fieldName}".',
        dataClassSlotsOverwrite: '__slots__ ya está definido en la clase',
        dataClassTransformExpectedBoolLiteral: 'Expresión esperada que se evalúa estáticamente como True o False',
        dataClassTransformFieldSpecifier: 'Se esperaba una tuple de clases o funciones, pero se recibió el tipo "{type}"',
        dataClassTransformPositionalParam: 'Todos los argumentos de "dataclass_transform" deben ser argumentos de palabra clave',
        dataClassTransformUnknownArgument: 'El argumento "{name}" no es compatible con dataclass_transform',
        dataProtocolInSubclassCheck: 'No se permiten protocolos de datos (que incluyen atributos que no son de método) en llamadas issubclass',
        declaredReturnTypePartiallyUnknown: 'El tipo de retorno declarado, "{returnType}", es parcialmente desconocido',
        declaredReturnTypeUnknown: 'El tipo de retorno declarado es desconocido',
        defaultValueContainsCall: 'No se permiten llamadas de función y objetos mutables dentro de la expresión de valor predeterminado del parámetro',
        defaultValueNotAllowed: 'Los parámetros con "*" o "**" no pueden tener valor por defecto',
        delTargetExpr: 'No se puede eliminar la expresión',
        deprecatedClass: 'La clase "{name}" está en desuso',
        deprecatedConstructor: 'El constructor de la clase "{name}" está obsoleto',
        deprecatedDescriptorDeleter: 'El método "__delete__" para el "{name}" de descriptor está en desuso',
        deprecatedDescriptorGetter: 'El método "__get__" para el "{name}" de descriptor está en desuso',
        deprecatedDescriptorSetter: 'El método "__set__" para el "{name}" de descriptor está en desuso',
        deprecatedFunction: 'La función "{name}" está obsoleta',
        deprecatedMethod: 'El método "{name}" en la clase "{className}" está en desuso',
        deprecatedPropertyDeleter: 'El deleter de la property "{name}" está en desuso',
        deprecatedPropertyGetter: 'El getter de la property "{name}" está en desuso',
        deprecatedPropertySetter: 'El setter de la property "{name}" está en desuso',
        deprecatedType: 'Este tipo está obsoleto a partir de la {version} de Python; utilice en su lugar "{replacement}".',
        dictExpandIllegalInComprehension: 'No se permite la ampliación del diccionario en la comprensión',
        dictInAnnotation: 'Expresión de diccionario no permitida en expresión de tipo',
        dictKeyValuePairs: 'Las entradas del diccionario deben contener pares clave/valor',
        dictUnpackIsNotMapping: 'Asignación esperada para el operador de desempaquetado del diccionario',
        dunderAllSymbolNotPresent: '"{name}" se especifica en __all__ pero no está presente en el módulo',
        duplicateArgsParam: 'Solo se permite un parámetro "*".',
        duplicateBaseClass: 'Clase base duplicada no permitida',
        duplicateCapturePatternTarget: 'El destino de captura "{name}" no puede aparecer más de una vez dentro del mismo patrón',
        duplicateCatchAll: 'Solo se permite una cláusula de except',
        duplicateEnumMember: 'El miembro Enum "{name}" ya está declarado',
        duplicateGenericAndProtocolBase: 'Solo se permite una clase base Generic[...] o Protocol[...].',
        duplicateImport: '"{importName}" se importa más de una vez',
        duplicateKeywordOnly: 'Solo se permite un separador "*".',
        duplicateKwargsParam: 'Solo se permite un parámetro "**".',
        duplicateParam: 'Parámetro duplicado "{name}"',
        duplicatePositionOnly: 'Solo se permite un parámetro "/"',
        duplicateStarPattern: 'Solo se permite un patrón "*" en una secuencia de patrones',
        duplicateStarStarPattern: 'Solo se permite una entrada "**"',
        duplicateUnpack: 'Solo se permite una operación de desempaquetado en la lista',
        ellipsisAfterUnpacked: '"..." no se puede usar con una TypeVarTuple o tuple sin empaquetar',
        ellipsisContext: '"..." no está permitido en este contexto',
        ellipsisSecondArg: '"..." está permitido sólo como el segundo de dos argumentos',
        enumClassOverride: 'La clase Enum "{name}" es final y no puede ser subclasificada',
        enumMemberDelete: 'No se puede eliminar el miembro de Enum "{name}"',
        enumMemberSet: 'No se puede asignar el miembro de Enum "{name}"',
        enumMemberTypeAnnotation: 'No se permiten anotaciones de tipo para miembros de enumeración',
        exceptGroupMismatch: 'La instrucción Try no puede incluir "except" y "except*"',
        exceptGroupRequiresType: 'La sintaxis del grupo de excepciones ("except*") requiere un tipo de excepción',
        exceptionGroupIncompatible: 'La sintaxis de grupo de excepciones ("except*") requiere Python 3.11 o posterior.',
        exceptionGroupTypeIncorrect: 'El tipo de excepción en except* no puede derivarse de BaseGroupException',
        exceptionTypeIncorrect: '"{type}" no se deriva de BaseException',
        exceptionTypeNotClass: '"{type}" no es una clase de excepción válida',
        exceptionTypeNotInstantiable: 'El constructor para el tipo de excepción "{type}" requiere uno o más argumentos',
        expectedAfterDecorator: 'Se esperaba una declaración de función o clase después del decorador',
        expectedArrow: 'Se esperaba "->" seguido de una anotación de tipo de retorno',
        expectedAsAfterException: 'Se esperaba "as" después del tipo de excepción',
        expectedAssignRightHandExpr: 'Expresión esperada a la derecha de "="',
        expectedBinaryRightHandExpr: 'Expresión esperada a la derecha del operador',
        expectedBoolLiteral: 'Se esperaba True o False',
        expectedCase: 'Declaración "case" esperada',
        expectedClassName: 'Nombre de clase esperado',
        expectedCloseBrace: '"{" no estaba cerrado',
        expectedCloseBracket: '"[" no estaba cerrado',
        expectedCloseParen: '"(" no estaba cerrado',
        expectedColon: 'Se esperaba ":"',
        expectedComplexNumberLiteral: 'Número complejo literal esperado para la concordancia de patrones',
        expectedDecoratorExpr: 'Forma de expresión no compatible con Decorator anterior a Python 3.9',
        expectedDecoratorName: 'Nombre esperado del Decorator',
        expectedDecoratorNewline: 'Nueva línea esperada al final de Decorator',
        expectedDelExpr: 'Expresión esperada después de "del"',
        expectedElse: 'Se espera "else"',
        expectedEquals: 'Se esperaba "="',
        expectedExceptionClass: 'Clase o objeto de excepción no válido',
        expectedExceptionObj: 'Objeto de excepción esperado, clase de excepción o None',
        expectedExpr: 'Se esperaba una expresión',
        expectedFunctionAfterAsync: 'Definición de función esperada después de "async"',
        expectedFunctionName: 'Se esperaba nombre de la función luego de "def"',
        expectedIdentifier: 'Identificador esperado',
        expectedImport: 'Se espera "import"',
        expectedImportAlias: 'Símbolo esperado después de "as"',
        expectedImportSymbols: 'Se esperan uno o más nombres de símbolos tras la importación',
        expectedIn: 'Se esperaba "in"',
        expectedInExpr: 'Expresión esperada después de "in"',
        expectedIndentedBlock: 'Bloque con sangría previsto',
        expectedMemberName: 'Se esperaba un nombre de atributo después de "."',
        expectedModuleName: 'Nombre de módulo esperado',
        expectedNameAfterAs: 'Se esperaba un nombre de símbolo después de "as"',
        expectedNamedParameter: 'El parámetro de palabra clave debe ir después de "*".',
        expectedNewline: 'Nueva línea esperada',
        expectedNewlineOrSemicolon: 'Las declaraciones deben ir separadas por nuevas líneas o punto y coma',
        expectedOpenParen: 'Se espera "("',
        expectedParamName: 'Nombre esperado del parámetro',
        expectedPatternExpr: 'Expresión del patrón esperado',
        expectedPatternSubjectExpr: 'Expresión de asunto de patrón esperada',
        expectedPatternValue: 'Expresión de valor de patrón esperada de la forma "a.b"',
        expectedReturnExpr: 'Expresión esperada después de "return"',
        expectedSliceIndex: 'Expresión de índice o segmento esperada',
        expectedTypeNotString: 'Se esperaba un tipo pero se ha recibido una cadena literal',
        expectedTypeParameterName: 'Nombre de parámetro de tipo esperado',
        expectedYieldExpr: 'Expresión esperada en la instrucción yield',
        finalClassIsAbstract: 'La clase "{type}" está marcada como final y debe implementar todos los símbolos abstractos',
        finalContext: '"Final" no está permitido en este contexto',
        finalInLoop: 'No se puede asignar una variable "Final" dentro de un bucle',
        finalMethodOverride: 'El método "{name}" no puede anular el método final definido en la clase " {className}"',
        finalNonMethod: 'La función "{name}" no se puede marcar @final porque no es un método',
        finalReassigned: '"{name}" se declara como Final y no se puede reasignar',
        finalRedeclaration: '"{name}" se declaró anteriormente como Final',
        finalRedeclarationBySubclass: '"{name}" no puede ser redeclarado porque la clase padre "{className}" lo declara como Final',
        finalTooManyArgs: 'Se esperaba un único argumento de tipo después de "Final".',
        finalUnassigned: '"{name}" se declara Final, pero no se asigna valor',
        formatStringBrace: 'No se permite una llave de cierre única dentro del literal de cadena f; usar llave de cierre doble',
        formatStringBytes: 'Los literales de cadena de formato (f-strings) no pueden ser binarios',
        formatStringDebuggingIllegal: 'El especificador de depuración de cadena F "=" requiere Python 3.8 o posterior',
        formatStringEscape: 'Secuencia de escape (barra diagonal inversa) no permitida en la parte de expresión de f-string anterior a Python 3.12',
        formatStringExpectedConversion: 'Se esperaba un especificador de conversión después de "!" en f-string',
        formatStringIllegal: 'Los literales de cadena de formato (f-strings) requieren Python 3.6 o posterior',
        formatStringInPattern: 'Cadena de formato no permitida en el patrón',
        formatStringNestedFormatSpecifier: 'Expresiones anidadas demasiado profundamente dentro del especificador de cadena de formato',
        formatStringNestedQuote: 'Las cadenas anidadas dentro de una cadena f no pueden usar el mismo carácter de comillas que la cadena f anterior a Python 3.12',
        formatStringUnicode: 'Los literales de cadena de formato (cadenas f) no pueden ser unicode',
        formatStringUnterminated: 'Expresión sin terminar en f-string; se esperaba "}"',
        functionDecoratorTypeUnknown: 'Un decorator de función no tipificado oculta el tipo de función; ignorar el decorator',
        functionInConditionalExpression: 'La expresión condicional hace referencia a una función que siempre se evalúa como True',
        functionTypeParametersIllegal: 'La sintaxis del parámetro de tipo de función requiere Python 3.12 o posterior',
        futureImportLocationNotAllowed: 'Las importaciones desde __future__ deben estar al principio del fichero',
        generatorAsyncReturnType: 'El tipo de retorno de la función generadora async debe ser compatible con "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: 'Las expresiones del generador deben ir entre paréntesis si no son el único argumento',
        generatorSyncReturnType: 'El tipo de retorno de la función generadora debe ser compatible con "Generator[{yieldType}, Any, Any]"',
        genericBaseClassNotAllowed: 'La clase base "Generic" no se puede usar con la sintaxis de parámetro de tipo',
        genericClassAssigned: 'No se puede asignar un tipo de clase genérico',
        genericClassDeleted: 'No se puede eliminar el tipo de clase genérica',
        genericInstanceVariableAccess: 'El acceso a la variable de instancia genérica a través de la clase es ambiguo',
        genericNotAllowed: '"Generic" no es válido en este contexto',
        genericTypeAliasBoundTypeVar: 'Los alias de tipo genérico dentro de una clase no pueden utilizar variables de tipo vinculadas {names}.',
        genericTypeArgMissing: '"Generic" requiere al menos un argumento de tipo',
        genericTypeArgTypeVar: 'El argumento de tipo para "Generic" debe ser una variable de tipo',
        genericTypeArgUnique: 'Los argumentos de tipo para "Generic" deben ser únicos',
        globalReassignment: '"{name}" se asigna antes de la declaración global',
        globalRedefinition: '"{name}" ya ha sido declarado global',
        implicitStringConcat: 'No se permite la concatenación implícita de cadenas',
        importCycleDetected: 'Ciclo detectado en la cadena de importación',
        importDepthExceeded: 'La profundidad de la cadena de importación superó {depth}',
        importResolveFailure: 'No se ha podido resolver la importación "{importName}".',
        importSourceResolveFailure: 'La importación "{importName}" no se ha podido resolver desde el origen',
        importSymbolUnknown: '"{name}" es un símbolo de importación desconocido',
        incompatibleMethodOverride: 'El método "{name}" sobrescribe la clase "{className}" de forma incompatible',
        inconsistentIndent: 'La cantidad sin sangría no coincide con la sangría anterior',
        inconsistentTabs: 'Uso incoherente de tabuladores y espacios en la sangría',
        initMethodSelfParamTypeVar: 'La anotación de tipo para el parámetro "self" del método "__init__" no puede contener variables de tipo con ámbito de clase',
        initMustReturnNone: 'El tipo de retorno de "__init__" debe ser None',
        initSubclassCallFailed: 'Argumentos de palabra clave incorrectos para el método __init_subclass__',
        initSubclassClsParam: '__init_subclass__ debe tomar un parámetro "cls"',
        initVarNotAllowed: '"InitVar" no se permite en este contexto',
        instanceMethodSelfParam: 'Los métodos de instancia deben tomar un parámetro "self"',
        instanceVarOverridesClassVar: 'La variable de instancia "{name}" invalida la variable de clase del mismo nombre en la clase "{className}"',
        instantiateAbstract: 'No se puede instanciar la clase abstracta "{type}"',
        instantiateProtocol: 'No se puede crear una instancia de la clase Protocol "{type}"',
        internalBindError: 'Se ha producido un error interno al vincular el archivo "{file}": {message}',
        internalParseError: 'Se ha producido un error interno al procesar el archivo "{file}": {message}',
        internalTypeCheckingError: 'Se ha producido un error interno al comprobar el tipo de archivo "{file}":{message}',
        invalidIdentifierChar: 'Carácter no válido en el identificador',
        invalidStubStatement: 'La declaración no tiene sentido dentro de un archivo de tipo stub',
        invalidTokenChars: 'Carácter "{text}" no válido en el token',
        isInstanceInvalidType: 'El segundo argumento de "isinstance" debe ser una clase o tuple de clases',
        isSubclassInvalidType: 'El segundo argumento de "issubclass" debe ser una clase o tuple de clases',
        keyValueInSet: 'No se permiten pares de clave/valor dentro de un set',
        keywordArgInTypeArgument: 'No se pueden usar argumentos de palabra clave en listas de argumentos de tipo',
        keywordArgShortcutIllegal: 'El acceso directo del argumento de palabra clave requiere Python 3.14 o posterior',
        keywordOnlyAfterArgs: 'No se permite el separador de argumentos por palabra clave después del parámetro "*".',
        keywordParameterMissing: 'Uno o varios parámetros de palabra clave deben seguir el parámetro "*"',
        keywordSubscriptIllegal: 'No se admiten argumentos de palabra clave dentro de subíndices',
        lambdaReturnTypePartiallyUnknown: 'El tipo de retorno de la lambda "{returnType}" es parcialmente desconocido.',
        lambdaReturnTypeUnknown: 'Se desconoce el tipo de retorno de la lambda',
        listAssignmentMismatch: 'La expresión con el tipo "{type}" no puede asignarse a la lista de destino',
        listInAnnotation: 'No se permite la expresión de List en la expresión de tipo',
        literalEmptyArgs: 'Se esperaban uno o varios argumentos de tipo después de "Literal"',
        literalNamedUnicodeEscape: 'No se admiten secuencias de escape Unicode con nombre en las anotaciones de cadena de "Literales".',
        literalNotAllowed: '"Literal" no se puede usar en este contexto sin un argumento de tipo',
        literalNotCallable: 'El tipo Literal no puede instanciarse',
        literalUnsupportedType: 'Los argumentos de tipo para "Literal" deben ser None, un valor literal (int, bool, str, o bytes), o un valor enum',
        matchIncompatible: 'Las declaraciones de Match requieren Python 3.10 o posterior',
        matchIsNotExhaustive: 'Los casos dentro de la declaración de match no tratan exhaustivamente todos los valores',
        maxParseDepthExceeded: 'Se ha superado la profundidad máxima de análisis; divida la expresión en subexpresiones más pequeñas.',
        memberAccess: 'No se puede tener acceso al atributo "{name}" para la clase "{type}"',
        memberDelete: 'No se puede eliminar el atributo "{name}" de la clase "{type}"',
        memberSet: 'No se puede asignar al atributo "{name}" para la clase "{type}"',
        metaclassConflict: 'La metaclase de una clase derivada debe ser una subclase de las metaclases de todas sus clases base',
        metaclassDuplicate: 'Solo se puede proporcionar una metaclase',
        metaclassIsGeneric: 'La metaclase no puede ser genérica',
        methodNotDefined: 'Método "{name}" no definido',
        methodNotDefinedOnType: 'Método "{name}" no definido en el tipo "{type}"',
        methodOrdering: 'No se puede crear una ordenación coherente de los métodos',
        methodOverridden: '"{name}" invalida el método del mismo nombre en la clase "{className}" con el tipo incompatible "{type}"',
        methodReturnsNonObject: 'El método "{name}" no devuelve un objeto',
        missingSuperCall: 'El método "{methodName}" no llama al método del mismo nombre en la clase principal.',
        mixingBytesAndStr: 'No se pueden concatenar los valores de bytes y str',
        moduleAsType: 'El módulo no se puede usar como tipo.',
        moduleNotCallable: 'No se puede llamar al módulo',
        moduleUnknownMember: '"{memberName}" no es un atributo conocido del módulo "{moduleName}"',
        namedExceptAfterCatchAll: 'Una cláusula except con nombre no puede aparecer después de la cláusula catch-all except',
        namedParamAfterParamSpecArgs: 'El parámetro de palabra clave "{name}" no puede aparecer en la firma después del parámetro ParamSpec args',
        namedTupleEmptyName: 'Los nombres de una tuple con nombre no pueden estar vacíos',
        namedTupleEntryRedeclared: 'No se puede invalidar "{name}" porque la clase primaria "{className}" es una tuple con nombre',
        namedTupleFirstArg: 'Nombre de clase de tuple como primer argumento',
        namedTupleMultipleInheritance: 'No se admite la herencia múltiple con NamedTuple',
        namedTupleNameKeyword: 'Los nombres de campo no pueden ser una palabra clave',
        namedTupleNameType: 'tuple de dos entradas esperada que especifica el nombre y el tipo de entrada',
        namedTupleNameUnique: 'Los nombres dentro de una tuple con nombre deben ser únicos',
        namedTupleNoTypes: '"namedtuple" no proporciona tipos para las entradas de tupla; utilice en su lugar "NamedTuple".',
        namedTupleSecondArg: 'list de entradas de tuple con nombre esperada como segundo argumento',
        newClsParam: '__new__ debe tomar un parámetro "cls"',
        newTypeAnyOrUnknown: 'El segundo argumento de NewType debe ser una clase conocida, no Any ni Unknown',
        newTypeBadName: 'El primer argumento de NewType debe ser una cadena literal',
        newTypeLiteral: 'NewType no se puede usar con el tipo Literal',
        newTypeNameMismatch: 'NewType debe asignarse a una variable con el mismo nombre',
        newTypeNotAClass: 'Clase esperada como segundo argumento de NewType',
        newTypeParamCount: 'NewType requiere dos argumentos posicionales',
        newTypeProtocolClass: 'NewType no se puede usar con un tipo estructural (Protocol o clase TypedDict)',
        noOverload: 'Ninguna sobrecarga para "{name}" coincide con los argumentos proporcionados',
        noReturnContainsReturn: 'La función con tipo de return declarado "NoReturn" no puede incluir una sentencia return',
        noReturnContainsYield: 'La función con tipo de retorno declarado "NoReturn" no puede incluir una instrucción yield',
        noReturnReturnsNone: 'La función con el tipo de valor devuelto declarado "NoReturn" no puede devolver "None"',
        nonDefaultAfterDefault: 'El argumento no predeterminado sigue al argumento predeterminado',
        nonLocalInModule: 'Declaración Nonlocal no permitida a nivel de módulo',
        nonLocalNoBinding: 'No se ha encontrado ningún enlace para "{name}" nonlocal.',
        nonLocalReassignment: '"{name}" se asigna antes de la declaración nonlocal',
        nonLocalRedefinition: '"{name}" ya fue declarado nonlocal',
        noneNotCallable: 'No se puede llamar al objeto de tipo "None"',
        noneNotIterable: 'No se puede utilizar un objeto de tipo "None" como valor iterable',
        noneNotSubscriptable: 'El objeto de tipo "None" no se puede suscribir',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'El operador "{operator}" no es compatible con "None".',
        noneUnknownMember: '"{name}" no es un atributo conocido de "None"',
        notRequiredArgCount: 'Se esperaba un único argumento de tipo después de "NotRequired".',
        notRequiredNotInTypedDict: '"NotRequired" no está permitido en este contexto',
        objectNotCallable: 'El objeto de tipo "{type}" no es invocable',
        obscuredClassDeclaration: 'La declaración de clase "{name}" queda oculta por una declaración del mismo nombre',
        obscuredFunctionDeclaration: 'La declaración de función "{name}" queda oculta por una declaración del mismo nombre',
        obscuredMethodDeclaration: 'La declaración de método "{name}" queda oculta por una declaración del mismo nombre',
        obscuredParameterDeclaration: 'La declaración de parámetro "{name}" queda oculta por una declaración del mismo nombre',
        obscuredTypeAliasDeclaration: 'La declaración de alias de tipo "{name}" queda oculta por una declaración del mismo nombre',
        obscuredVariableDeclaration: 'La declaración "{name}" está oculta por una declaración del mismo nombre',
        operatorLessOrGreaterDeprecated: 'El operador "<>" no es admitido en Python 3; utilice en su lugar "!=".',
        optionalExtraArgs: 'Se esperaba un argumento de tipo después de "Optional"',
        orPatternIrrefutable: 'El patrón irrefutable solo se permite como el último subpatrón en un patrón "or".',
        orPatternMissingName: 'Todos los subpatrones de un patrón "or" deben tener los mismos nombres',
        overlappingKeywordArgs: 'El diccionario escrito se superpone con el parámetro de palabra clave: {names}',
        overlappingOverload: 'La sobrecarga {obscured} para "{name}" nunca se utilizará porque sus parámetros se superpone con la sobrecarga {obscuredBy}.',
        overloadAbstractImplMismatch: 'Las sobrecargas deben coincidir con el estado abstracto de la implementación',
        overloadAbstractMismatch: 'Todos los métodos sobrecargados deben ser abstractos o no',
        overloadClassMethodInconsistent: 'Las sobrecargas de "{name}" usan @classmethod de forma incoherente',
        overloadFinalInconsistencyImpl: 'La sobrecarga de "{name}" está marcada @final pero la implementación no',
        overloadFinalInconsistencyNoImpl: 'La sobrecarga {index} para "{name}" está marcada @final pero la sobrecarga 1 no lo está.',
        overloadImplementationMismatch: 'La implementación de la sobrecarga no es consistente con la firma de la sobrecarga {index}',
        overloadReturnTypeMismatch: 'La sobrecarga {prevIndex} para " {name}" se superpone con la sobrecarga {newIndex} y devuelve un tipo incompatible',
        overloadStaticMethodInconsistent: 'Las sobrecargas de "{name}" usan @staticmethod de forma incoherente',
        overloadWithoutImplementation: '"{name}" está marcado como overload, pero no se proporciona ninguna implementación.',
        overriddenMethodNotFound: 'El método "{name}" está marcado como override, pero no existe ningún método base con el mismo nombre',
        overrideDecoratorMissing: 'El método "{name}" no está marcado como override, pero está reemplazando un método de la clase "{className}"',
        paramAfterKwargsParam: 'El parámetro no puede seguir el parámetro "**"',
        paramAlreadyAssigned: 'El parámetro "{name}" ya está asignado',
        paramAnnotationMissing: 'Falta la anotación de tipo para el parámetro "{name}"',
        paramAssignmentMismatch: 'La expresión de tipo "{sourceType}" no se puede asignar al parámetro de tipo "{paramType}"',
        paramNameMissing: 'Ningún parámetro llamado "{name}"',
        paramSpecArgsKwargsDuplicate: 'Ya se han proporcionado los argumentos para ParamSpec "{type}".',
        paramSpecArgsKwargsUsage: 'Los atributos "args" y "kwargs" de ParamSpec deben aparecer ambos dentro de una firma de función',
        paramSpecArgsMissing: 'Faltan argumentos para ParamSpec "{type}".',
        paramSpecArgsUsage: 'El atributo "args" de ParamSpec solo es válido cuando se usa con el parámetro *args.',
        paramSpecAssignedName: 'ParamSpec debe asignarse a una variable llamada "{name} "',
        paramSpecContext: 'ParamSpec no está permitido en este contexto',
        paramSpecDefaultNotTuple: 'Se esperaban puntos suspensivos, una expresión de tuple o ParamSpec para el valor predeterminado de ParamSpec',
        paramSpecFirstArg: 'Se esperaba el nombre de ParamSpec como primer argumento',
        paramSpecKwargsUsage: 'El miembro "kwargs" de ParamSpec solo es válido cuando se utiliza con el parámetro **kwargs',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" no tiene significado en este contexto',
        paramSpecUnknownArg: 'ParamSpec no admite más de un argumento',
        paramSpecUnknownMember: '"{name}" no es un atributo conocido de ParamSpec',
        paramSpecUnknownParam: '"{name}" es un parámetro desconocido para ParamSpec',
        paramTypeCovariant: 'La variable de tipo covariante no puede utilizarse en el tipo de parámetro',
        paramTypePartiallyUnknown: 'El tipo de parámetro "{paramName}" es parcialmente desconocido',
        paramTypeUnknown: 'Se desconoce el tipo del parámetro "{paramName}".',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'El patrón nunca coincidirá para el tipo de asunto "{type}"',
        positionArgAfterNamedArg: 'El argumento posicional no puede aparecer después de los argumentos de palabra clave',
        positionOnlyAfterArgs: 'No se permite el separador de parámetros de un solo puesto después del parámetro "*".',
        positionOnlyAfterKeywordOnly: 'El parámetro "/" debe aparecer antes del parámetro "*".',
        positionOnlyAfterNon: 'Parámetro de un solo puesto no permitido después del parámetro que no es de solo posición',
        positionOnlyFirstParam: 'Separador parámetros de solo un puesto no permitido como primer parámetro',
        positionOnlyIncompatible: 'El separador de parámetros de un solo puesto requiere Python 3.8 o posterior',
        privateImportFromPyTypedModule: '"{name}" no se exporta desde el módulo "{module}"',
        privateUsedOutsideOfClass: '"{name}" es privado y se utiliza fuera de la clase en la que se declara',
        privateUsedOutsideOfModule: '"{name}" es privado y se utiliza fuera del módulo en el que se declara',
        propertyOverridden: '"{name}" invalida incorrectamente la property del mismo nombre en la clase "{className}"',
        propertyStaticMethod: 'Métodos estáticos no permitidos para los valores de property getter, setter o deleter',
        protectedUsedOutsideOfClass: '"{name}" está protegido y se usa fuera de la clase en la que se declara',
        protocolBaseClass: 'La clase de Protocol "{classType}" no se puede derivar de la clase que no es Protocol "{baseType}"',
        protocolBaseClassWithTypeArgs: 'No se permiten argumentos de tipo con la clase Protocol cuando se usa la sintaxis de parámetro de tipo',
        protocolIllegal: 'El uso de "Protocolo" requiere Python 3.7 o posterior.',
        protocolNotAllowed: '"Protocolo" no puede utilizarse en este contexto',
        protocolTypeArgMustBeTypeParam: 'El argumento de tipo para "Protocol" debe ser un parámetro de tipo',
        protocolUnsafeOverlap: 'La clase se superpone "{name}" de forma no segura y podría producir una coincidencia en tiempo de ejecución',
        protocolVarianceContravariant: 'La variable de tipo "{variable}" usada en Protocol genérico "{class}" debe ser contravariante',
        protocolVarianceCovariant: 'La variable de tipo "{variable}" usada en Protocol genérico "{class}" debe ser covariante',
        protocolVarianceInvariant: 'La variable de tipo "{variable}" usada en Protocol genérico "{class}" debe ser invariable',
        pyrightCommentInvalidDiagnosticBoolValue: 'La directiva de comentario Pyright debe ir seguida de "=" y un valor de true o false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'La directiva de comentario Pyright debe ir seguida de "=" y un valor de true, false, error, warning, information o none.',
        pyrightCommentMissingDirective: 'El comentario de Pyright debe ir seguido de una directiva (basic o estricta) o de una regla de diagnóstico',
        pyrightCommentNotOnOwnLine: 'Los comentarios de Pyright utilizados para controlar los ajustes a nivel de archivo deben aparecer en su propia línea',
        pyrightCommentUnknownDiagnosticRule: '"{rule}" es una regla de diagnóstico desconocida para el comentario pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" es un valor no válido para el comentario pyright; se espera true, false, error, warning, information o none.',
        pyrightCommentUnknownDirective: '"{directive}" es una directiva desconocida para el comentario pyright; se esperaba "strict" o "basic".',
        readOnlyArgCount: 'Se esperaba un único argumento de tipo después de "ReadOnly"',
        readOnlyNotInTypedDict: '"ReadOnly" no está permitido en este contexto',
        recursiveDefinition: 'No se pudo determinar el tipo de "{name}" porque hace referencia a sí mismo.',
        relativeImportNotAllowed: 'Las importaciones relativas no pueden utilizarse con la forma "import .a"; utilice en su lugar "from . import a"',
        requiredArgCount: 'Se esperaba un único argumento de tipo después de "Required"',
        requiredNotInTypedDict: '"Required" no está permitido en este contexto',
        returnInAsyncGenerator: 'No se permite la instrucción Return con valor en el generador async',
        returnInExceptionGroup: 'No se permite "return" en un bloque "except*"',
        returnMissing: 'La función con el tipo de valor devuelto declarado "{returnType}" debe devolver un valor en todas las rutas de acceso del código.',
        returnOutsideFunction: '"return" solo se puede usar dentro de una función',
        returnTypeContravariant: 'La variable de tipo contravariante no se puede usar en el tipo de valor devuelto',
        returnTypeMismatch: 'El tipo "{exprType}" no se puede asignar al tipo de valor devuelto "{returnType}"',
        returnTypePartiallyUnknown: 'El tipo de retorno, "{returnType}", es parcialmente desconocido',
        returnTypeUnknown: 'Tipo de retorno desconocido',
        revealLocalsArgs: 'No se esperaba ningún argumento para la llamada "reveal_locals"',
        revealLocalsNone: 'No hay locals en este ámbito',
        revealTypeArgs: 'Se esperaba un único argumento posicional para la llamada "reveal_type"',
        revealTypeExpectedTextArg: 'El argumento "expected_text" de la función "reveal_type" debe ser un valor literal str.',
        revealTypeExpectedTextMismatch: 'El tipo de texto no coincide; se esperaba "{expected}" pero se ha recibido "{received}".',
        revealTypeExpectedTypeMismatch: 'Error de coincidencia de tipos; se esperaba "{expected}", pero se recibió "{received}"',
        selfTypeContext: '"Self" no es válido en este contexto',
        selfTypeMetaclass: '"Self" no se puede usar dentro de una metaclase (una subclase de "type")',
        selfTypeWithTypedSelfOrCls: '"Self" no puede utilizarse en una función con un parámetro `self` o `cls` que tenga una anotación de tipo distinta de "Self".',
        setterGetterTypeMismatch: 'El tipo de valor setter de Property no se puede asignar al tipo devuelto por el valor getter',
        singleOverload: '"{name}" está marcado como sobrecarga, pero faltan sobrecargas adicionales',
        slotsAttributeError: '"{name}" no se especificó en __slots__',
        slotsClassVarConflict: '"{name}" entra en conflicto con la variable de instancia declarada en __slots__',
        starPatternInAsPattern: 'El patrón estrella no puede utilizarse con el objetivo "as"',
        starPatternInOrPattern: 'El patrón de estrella no puede unirse a otros patrones',
        starStarWildcardNotAllowed: '** no puede utilizarse con el comodín "_".',
        staticClsSelfParam: 'Los métodos estáticos no deben tomar un parámetro "self" o "cls".',
        stdlibModuleOverridden: '"{path}" está reemplazando el módulo stdlib "{name}"',
        stringNonAsciiBytes: 'Carácter no ASCII no permitido en el literal de cadena de bytes',
        stringNotSubscriptable: 'La expresión de cadena no puede ir entre comillas en la expresión de tipo; encierre toda la expresión entre comillas.',
        stringUnsupportedEscape: 'Secuencia de escape no admitida en el literal de cadena',
        stringUnterminated: 'La cadena literal no está terminada',
        stubFileMissing: 'Archivo Stub no encontrado para "{importName}"',
        stubUsesGetAttr: 'El archivo stub de tipo está incompleto; "__getattr__" oculta errores de tipo para el módulo',
        sublistParamsIncompatible: 'Los parámetros de sublista no están soportados en Python 3.x',
        superCallArgCount: 'No se esperaban más de dos argumentos para la llamada "super"',
        superCallFirstArg: 'Se esperaba el tipo de clase como primer argumento de la llamada a "super" pero se recibió "{type}"',
        superCallSecondArg: 'El segundo argumento de la llamada a "super" debe ser un objeto o clase que derive de "{type}"',
        superCallZeroArgForm: 'La forma sin argumentos de la llamada "super" sólo es válida dentro de un método',
        superCallZeroArgFormStaticMethod: 'La forma sin argumentos de la llamada "super" no es válida en un método estático',
        symbolIsPossiblyUnbound: '"{name}" está posiblemente desvinculado',
        symbolIsUnbound: '"{name}" está sin consolidar',
        symbolIsUndefined: '"{name}" no está definido',
        symbolOverridden: '"{name}" anula el símbolo del mismo nombre en la clase "{className}"',
        ternaryNotAllowed: 'No se permite la expresión de ternario en la expresión de tipo',
        totalOrderingMissingMethod: 'La clase debe definir uno de "__lt__", "__le__", "__gt__", o "__ge__" para utilizar total_ordering',
        trailingCommaInFromImport: 'No se permite la coma final sin paréntesis alrededor',
        tryWithoutExcept: 'La instrucción Try debe tener al menos una cláusula except o finally',
        tupleAssignmentMismatch: 'La expresión con el tipo "{type}" no se puede asignar a la tuple de destino',
        tupleInAnnotation: 'No se permite la expresión de tuple en la expresión de tipo',
        tupleIndexOutOfRange: 'El índice {index} está fuera de rango para el tipo {type}.',
        typeAliasIllegalExpressionForm: 'Forma de expresión no válida para la definición de alias de tipo',
        typeAliasIsRecursiveDirect: 'El alias de tipo "{name}" no puede usarse a sí mismo en su definición',
        typeAliasNotInModuleOrClass: 'Un TypeAlias solo puede definirse en el ámbito de un módulo o de una clase',
        typeAliasRedeclared: '"{name}" se declara como TypeAlias y solo puede asignarse una vez',
        typeAliasStatementBadScope: 'Una instrucción de type solo se puede usar en el ámbito de un módulo o de una clase',
        typeAliasStatementIllegal: 'La sentencia Type alias requiere Python 3.12 o posterior',
        typeAliasTypeBaseClass: 'Un alias de tipo definido en una instrucción "type" no se puede usar como clase base',
        typeAliasTypeMustBeAssigned: 'TypeAliasType debe asignarse a una variable con el mismo nombre que el alias de tipo',
        typeAliasTypeNameArg: 'El primer argumento de TypeAliasType debe ser un literal de cadena que represente el nombre del alias de tipo',
        typeAliasTypeNameMismatch: 'El nombre del alias de tipo debe coincidir con el nombre de la variable a la que se asigna',
        typeAliasTypeParamInvalid: 'La lista de parámetros de tipo debe ser una tuple que contenga solo TypeVar, TypeVarTuple o ParamSpec.',
        typeAnnotationCall: 'No se permite la expresión de llamada en la expresión de tipo',
        typeAnnotationVariable: 'Variable no permitida en la expresión de tipo',
        typeAnnotationWithCallable: 'El argumento de tipo para "type" debe ser una clase; no se admiten invocables',
        typeArgListExpected: 'ParamSpec esperado, elipsis o lista de tipos',
        typeArgListNotAllowed: 'Expresión de lista no permitida para este argumento de tipo',
        typeArgsExpectingNone: 'No se esperaban argumentos de tipo para la clase "{name}"',
        typeArgsMismatchOne: 'Se esperaba un argumento de tipo pero ha recibido {received}',
        typeArgsMissingForAlias: 'Argumentos de tipo esperados para el alias de tipo genérico "{name}"',
        typeArgsMissingForClass: 'Se esperaban argumentos de tipo para la clase genérica "{name}"',
        typeArgsTooFew: 'Se han proporcionado muy pocos argumentos de tipo para "{name}"; se esperaba {expected} pero se ha recibido {received}.',
        typeArgsTooMany: 'Se proporcionaron demasiados argumentos de tipo para "{name}"; se esperaba {expected}, pero se recibieron {received}',
        typeAssignmentMismatch: 'El tipo "{sourceType}" no se puede asignar al tipo declarado "{destType}"',
        typeAssignmentMismatchWildcard: 'El símbolo de importación "{name}" tiene el tipo "{sourceType}", que no se puede asignar al tipo declarado "{destType}"',
        typeCallNotAllowed: 'La llamada a type() no debe utilizarse en la expresión de tipo',
        typeCheckOnly: '"{name}" está marcado como @type_check_only y solo se puede usar en anotaciones de tipo',
        typeCommentDeprecated: 'El uso de comentarios de type está obsoleto; utilice en su lugar anotaciones de type.',
        typeExpectedClass: 'Se esperaba la clase pero se recibió "{type}"',
        typeFormArgs: '"TypeForm" acepta un único argumento posicional',
        typeGuardArgCount: 'Se esperaba un único argumento de tipo después de "TypeGuard" o "TypeIs"',
        typeGuardParamCount: 'Las funciones y métodos de protección de tipo definidos por el usuario deben tener al menos un parámetro de entrada',
        typeIsReturnType: 'El tipo de valor devuelto de TypeIs ("{returnType}") no es coherente con el tipo de parámetro de valor ("{type}")',
        typeNotAwaitable: '"{type}" no se awaitable',
        typeNotIntantiable: '"{type}" no puede crear instancias',
        typeNotIterable: '"{type}" no es iterable',
        typeNotSpecializable: 'No se pudo especializar el tipo "{type}"',
        typeNotSubscriptable: 'Objeto de tipo "{type}" no es subscriptible',
        typeNotSupportBinaryOperator: 'El operador "{operator}" no se admite para los tipos "{leftType}" y "{rightType}"',
        typeNotSupportBinaryOperatorBidirectional: 'No se admite el operador "{operator}" para los tipos "{leftType}" y "{rightType}" cuando el tipo esperado es "{expectedType}"',
        typeNotSupportUnaryOperator: 'El operador "{operator}" no se admite para el tipo "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'Operador "{operator}" no admitido para el tipo "{type}" cuando el tipo esperado es "{expectedType}"',
        typeNotUsableWith: 'El objeto de tipo "{type}" no puede utilizarse con "con" porque no implementa {method}.',
        typeParameterBoundNotAllowed: 'No se pueden usar límites o restricciones con un parámetro de tipo variádico o ParamSpec',
        typeParameterConstraintTuple: 'La restricción del parámetro de tipo debe ser una tupla de dos o más tipos',
        typeParameterExistingTypeParameter: 'El parámetro de tipo "{name}" ya está en uso',
        typeParameterNotDeclared: 'El parámetro de tipo "{name}" no está incluido en la lista de parámetros de tipo para "{container}"',
        typeParametersMissing: 'Debe especificarse al menos un parámetro de tipo',
        typePartiallyUnknown: 'El tipo de "{name}" es parcialmente desconocido',
        typeUnknown: 'El tipo de "{name} " es desconocido',
        typeVarAssignedName: 'TypeVar debe asignarse a una variable llamada "{name}"',
        typeVarAssignmentMismatch: 'No se puede asignar el tipo "{type}" a la variable de tipo "{name}"',
        typeVarBoundAndConstrained: 'TypeVar no puede estar ligado y restringido a la vez',
        typeVarBoundGeneric: 'El tipo vinculado TypeVar no puede ser genérico',
        typeVarConstraintGeneric: 'El tipo de restricción TypeVar no puede ser genérico',
        typeVarDefaultBoundMismatch: 'El tipo predeterminado TypeVar debe ser un subtipo del tipo enlazado.',
        typeVarDefaultConstraintMismatch: 'El tipo predeterminado TypeVar debe ser uno de los tipos restringidos.',
        typeVarDefaultIllegal: 'Los tipos predeterminados de variable de tipo requieren Python 3.13 o posterior',
        typeVarDefaultInvalidTypeVar: 'El parámetro de tipo "{name}" tiene un tipo por defecto que hace referencia a una o más variables de tipo que están fuera de ámbito.',
        typeVarFirstArg: 'Nombre esperado de TypeVar como primer argumento',
        typeVarInvalidForMemberVariable: 'El tipo de atributo no puede usar una variable de tipo "{name}" con ámbito de método local',
        typeVarNoMember: 'TypeVar "{type}" no tiene ningún atributo "{name}"',
        typeVarNotSubscriptable: 'TypeVar "{type}" no es subscribible',
        typeVarNotUsedByOuterScope: 'La variable de tipo "{name}" no tiene ningún significado en este contexto',
        typeVarPossiblyUnsolvable: 'La variable de tipo "{name}" puede quedar sin resolver si el autor de la llamada no proporciona ningún argumento para el parámetro "{param}"',
        typeVarSingleConstraint: 'TypeVar debe tener al menos dos tipos restringidos',
        typeVarTupleConstraints: 'TypeVarTuple no puede tener restricciones de valor',
        typeVarTupleContext: 'TypeVarTuple no está permitido en este contexto',
        typeVarTupleDefaultNotUnpacked: 'El tipo predeterminado TypeVarTuple debe ser una tuple desempaquetada o TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'Se requiere el operador Unpack para el valor TypeVarTuple.',
        typeVarTupleUnknownParam: '"{name}" es un parámetro desconocido para TypeVarTuple',
        typeVarUnknownParam: '"{name}" es un parámetro desconocido para TypeVar',
        typeVarUsedByOuterScope: 'TypeVar "{name}" ya está en uso por un ámbito externo',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" solo aparece una vez en la firma de la función genérica',
        typeVarVariance: 'TypeVar no puede ser covariante y contravariante',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}" tiene un valor predeterminado y no puede seguir a TypeVarTuple "{variadicName}"',
        typeVarWithoutDefault: '"{name}" no puede aparecer después de "{other}" en la lista de parámetros de tipo porque no tiene ningún tipo predeterminado',
        typeVarsNotInGenericOrProtocol: 'Generic[] o Protocol[] deben incluir todas las variables de tipo',
        typedDictAccess: 'No se ha podido acceder al elemento en TypedDict',
        typedDictAssignedName: 'TypedDict debe asignarse a una variable denominada "{name}"',
        typedDictBadVar: 'Las clases TypedDict solo pueden contener anotaciones de tipo',
        typedDictBaseClass: 'Todas las clases base de las clases TypedDict deben ser también clases TypedDict',
        typedDictBoolParam: 'Se esperaba que el parámetro "{name}" tuviera un valor de True o False.',
        typedDictClosedExtras: 'La clase base "{name}" es un TypedDict closed; los elementos adicionales deben ser de tipo "{type}"',
        typedDictClosedNoExtras: 'La clase base "{name}" es un TypedDict closed; no se permiten elementos adicionales',
        typedDictDelete: 'No se puede eliminar un elemento en TypedDict',
        typedDictEmptyName: 'Los nombres de un TypedDict no pueden estar vacíos',
        typedDictEntryName: 'Cadena literal esperada para el nombre de la entrada del diccionario',
        typedDictEntryUnique: 'Los nombres dentro de un diccionario deben ser únicos',
        typedDictExtraArgs: 'No se admiten argumentos TypedDict adicionales',
        typedDictExtraItemsClosed: 'Un TypedDict no puede tener el estado closed si admite elementos adicionales',
        typedDictFieldNotRequiredRedefinition: 'El elemento TypedDict "{name}" no se puede redefinir como NotRequired',
        typedDictFieldReadOnlyRedefinition: 'El elemento TypedDict "{name}" no se puede redefinir como ReadOnly',
        typedDictFieldRequiredRedefinition: 'El elemento TypedDict "{name}" no se puede redefinir como Required',
        typedDictFirstArg: 'Nombre de clase TypedDict esperado como primer argumento',
        typedDictInClassPattern: 'No se permite la clase TypedDict en el patrón de clase',
        typedDictInitsubclassParameter: 'TypedDict no admite __init_subclass__ parámetro "{name}"',
        typedDictNotAllowed: '"TypedDict" no puede utilizarse en este contexto',
        typedDictSecondArgDict: 'Parámetro dict o palabra clave esperado como segundo parámetro',
        typedDictSecondArgDictEntry: 'Entrada de diccionario simple esperada',
        typedDictSet: 'No se pudo asignar el elemento en TypedDict',
        unaccessedClass: 'No se accede a la clase "{name}"',
        unaccessedFunction: 'No se accede a la función "{name}',
        unaccessedImport: 'No se accede a la importación "{name}',
        unaccessedSymbol: 'No se accede a "{name}"',
        unaccessedVariable: 'No se accede a la variable "{name} ".',
        unannotatedFunctionSkipped: 'Se omite el análisis de la función "{name}" porque no está anotada',
        unaryOperationNotAllowed: 'Operador unario no permitido en la expresión de tipo',
        unexpectedAsyncToken: 'Se esperaba que "def", "with" o "for" siguieran a "async".',
        unexpectedExprToken: 'Token inesperado al final de la expresión',
        unexpectedIndent: 'sangSangría inesperadaría inesperada',
        unexpectedUnindent: 'No se espera sangría',
        unhashableDictKey: 'La clave del diccionario debe ser hash',
        unhashableSetEntry: 'La entrada del set debe ser hashable',
        uninitializedAbstractVariables: 'Las variables definidas en la clase base abstracta no se inicializan en la clase final "{classType}"',
        uninitializedInstanceVariable: 'La variable de instancia "{name}" no está inicializada en el cuerpo de la clase o en el método __init__.',
        unionForwardReferenceNotAllowed: 'Union syntax cannot be used with string operand; use quotes around entire expression',
        unionSyntaxIllegal: 'La sintaxis alternativa para las uniones requiere Python 3.10 o posterior.',
        unionTypeArgCount: 'Union requiere dos o más argumentos de tipo',
        unionUnpackedTuple: 'La Union no puede incluir una tuple desempaquetada',
        unionUnpackedTypeVarTuple: 'La Union no puede incluir un TypeVarTuple desempaquetado',
        unnecessaryCast: 'Llamada "cast" innecesaria; el tipo ya es "{type}"',
        unnecessaryIsInstanceAlways: 'Llamada isinstance innecesaria; "{testType}" es siempre una instancia de "{classType}"',
        unnecessaryIsInstanceNever: 'Llamada isinstance innecesaria; "{testType}" es nunca una instancia de "{classType}"',
        unnecessaryIsSubclassAlways: 'Llamada de issubclass innecesaria; "{testType}" siempre es una subclase de "{classType}"',
        unnecessaryIsSubclassNever: 'Llamada de issubclass innecesaria; "{testType}" nunca es una subclase de "{classType}"',
        unnecessaryPyrightIgnore: 'Comentario "# pyright: ignore" innecesario',
        unnecessaryPyrightIgnoreRule: 'Regla innecesaria "# pyright: ignore": "{name}"',
        unnecessaryTypeIgnore: 'Comentario "# type: ignore" innecesario',
        unpackArgCount: 'Se esperaba un único argumento de tipo después de "Unpack"',
        unpackExpectedTypeVarTuple: 'Se esperaba TypeVarTuple o tuple como argumento de tipo para Unpack',
        unpackExpectedTypedDict: 'Se esperaba un argumento de tipo TypedDict para Unpack',
        unpackIllegalInComprehension: 'Operación de desempaquetado no permitida en la comprensión',
        unpackInAnnotation: 'No se permite el operador desempaquetado en la expresión de tipo',
        unpackInDict: 'Operación de desempaquetado no permitida en diccionarios',
        unpackInSet: 'No se permite el operador Unpack dentro de un set',
        unpackNotAllowed: 'Unpack no está permitido en este contexto',
        unpackOperatorNotAllowed: 'La operación de desempaquetado no está permitida en este contexto',
        unpackTuplesIllegal: 'Operación de desempaquetado no permitida en tuplas anteriores a Python 3.8',
        unpackedArgInTypeArgument: 'No se pueden usar argumentos sin empaquetar en este contexto',
        unpackedArgWithVariadicParam: 'No se puede usar un argumento desempaquetado para el parámetro TypeVarTuple',
        unpackedDictArgumentNotMapping: 'La expresión del argumento después de ** debe ser un mapeo con un tipo de clave "str".',
        unpackedDictSubscriptIllegal: 'El operador de desempaquetado del diccionario en el subíndice no está permitido',
        unpackedSubscriptIllegal: 'El operador de desempaquetado en el subíndice requiere Python 3.11 o posterior.',
        unpackedTypeVarTupleExpected: 'Se espera un TypeVarTuple desempaquetado; use Unpack[{name1}] o *{name2}',
        unpackedTypedDictArgument: 'No se puede emparejar el argumento TypedDict desempaquetado con los parámetros',
        unreachableCode: 'El código es inalcanzable',
        unreachableCodeType: 'El análisis de tipos indica que no se puede acceder al código',
        unreachableExcept: 'La cláusula Excepto es inalcanzable porque la excepción ya está administrada',
        unsupportedDunderAllOperation: 'No se admite la operación en "__all__", por lo que la lista de símbolos exportada puede ser incorrecta.',
        unusedCallResult: 'El resultado de la expresión de llamada es de tipo "{type}" y no se usa; asignar a la variable "_" si esto es intencionado',
        unusedCoroutine: 'El resultado de la llamada a una función async no se utiliza; utilice "await" o asigne el resultado a una variable.',
        unusedExpression: 'El valor de expresión no se usa',
        varAnnotationIllegal: 'Las anotaciones de type para variables requieren Python 3.6 o posterior; utilice el comentario de tipo para la compatibilidad con versiones anteriores.',
        variableFinalOverride: 'La variable "{name}" está marcada como Final y anula la variable no Final del mismo nombre en la clase "{className}".',
        variadicTypeArgsTooMany: 'La lista de argumentos de tipo puede tener como máximo una TypeVarTuple o tuple desempaquetada',
        variadicTypeParamTooManyAlias: 'Los alias de tipo pueden tener como máximo un parámetro de tipo TypeVarTuple, pero reciben varios ({names})',
        variadicTypeParamTooManyClass: 'La clase genérica puede tener como máximo un parámetro de tipo TypeVarTuple pero recibió múltiples ({names})',
        walrusIllegal: 'El operador ":=" requiere Python 3.8 o posterior',
        walrusNotAllowed: 'El operador ":=" no está permitido en este contexto sin paréntesis alrededor',
        wildcardInFunction: 'No se permite la importación de comodines dentro de una clase o función',
        wildcardLibraryImport: 'No se permite la importación de caracteres comodín desde una biblioteca',
        wildcardPatternTypePartiallyUnknown: 'El tipo capturado por el patrón comodín es parcialmente desconocido',
        wildcardPatternTypeUnknown: 'Se desconoce el tipo capturado por el patrón de caracteres comodín',
        yieldFromIllegal: 'El uso de "yield from" requiere Python 3.3 o posterior.',
        yieldFromOutsideAsync: '"yield from" no permitido en una función async',
        yieldOutsideFunction: '"yield" no se permite fuera de una función o lambda',
        yieldWithinComprehension: '"yield" no está permitido dentro de una comprensión de lista',
        zeroCaseStatementsFound: 'La instrucción Match debe incluir al menos una instrucción case',
        zeroLengthTupleNotAllowed: 'La tuple de longitud cero no está permitida en este contexto'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'El formulario especial "Annotated" no se puede usar con comprobaciones de instancia y clase',
        argParam: 'El argumento corresponde al parámetro "{paramName}"',
        argParamFunction: 'El argumento corresponde al parámetro "{paramName}" en la función "{functionName}"',
        argsParamMissing: 'El parámetro "*{paramName}" no tiene ningún parámetro correspondiente',
        argsPositionOnly: 'Error de coincidencia del parámetro de solo posición; se esperaba {expected}, pero se recibieron {received}',
        argumentType: 'El tipo de argumento es "{type}"',
        argumentTypes: 'Tipos de argumento: ({types})',
        assignToNone: 'El tipo no se puede asignar a "None"',
        asyncHelp: '¿Quería decir "async with"?',
        baseClassIncompatible: 'La clase base "{baseClass}" no es compatible con el tipo "{type}"',
        baseClassIncompatibleSubclass: 'La clase base "{baseClass}" deriva de "{subclass}", que no es compatible con el tipo "{type}"',
        baseClassOverriddenType: 'La clase base "{baseClass}" proporciona el tipo "{type}", que se sobrescribe',
        baseClassOverridesType: 'Invalidaciones de clase base "{baseClass}" con el tipo "{type}"',
        bytesTypePromotions: 'Establezca disableBytesTypePromotions en false para activar el comportamiento de promoción de tipos para "bytearray" y "memoryview".',
        conditionalRequiresBool: 'El método __bool__ para el tipo "{operandType}" devuelve el tipo "{boolReturnType}" en lugar de "bool"',
        dataClassFieldLocation: 'en declaración de campo',
        dataClassFrozen: '"{name}" está congelado',
        dataProtocolUnsupported: '"{name}" es un protocolo de datos',
        descriptorAccessBindingFailed: 'No se pudo enlazar el método "{name}" para la clase de descriptor "{className}"',
        descriptorAccessCallFailed: 'No se pudo llamar al método "{name}" para la clase de descriptor "{className}"',
        finalMethod: 'Final method',
        functionParamDefaultMissing: 'Falta el argumento predeterminado en el parámetro "{name}"',
        functionParamName: 'Nombre de parámetro no coincidente: "{destName}" frente a "{srcName}"',
        functionParamPositionOnly: 'Error de coincidencia del parámetro de solo posición; el parámetro "{name}" no es de solo posición',
        functionReturnTypeMismatch: 'El tipo de valor devuelto de la función "{sourceType}" no es compatible con el tipo "{destType}"',
        functionTooFewParams: 'La función acepta muy pocos parámetros posicionales; esperado {expected} pero recibido {received}',
        functionTooManyParams: 'La función acepta demasiados parámetros posicionales; esperado {expected} pero recibido {received}',
        genericClassNotAllowed: 'Tipo genérico con argumentos de tipo no permitidos para comprobaciones de instancia o clase',
        incompatibleDeleter: 'El método de deleter de property no es compatible',
        incompatibleGetter: 'El método getter de property no es compatible',
        incompatibleSetter: 'El método setter de la property no es compatible',
        initMethodLocation: 'El método __init__ se define en la clase "{type}"',
        initMethodSignature: 'La firma de __init__ es "{type}"',
        initSubclassLocation: 'El método __init_subclass__ se define en la clase "{name}"',
        invariantSuggestionDict: 'Considere cambiar de "dict" a " Mapping" que es covariante en el tipo de valor',
        invariantSuggestionList: 'Considere la posibilidad de cambiar de "lista" a "Sequence" que es covariante',
        invariantSuggestionSet: 'Considere la posibilidad de cambiar de "set" a "Container" que es covariante',
        isinstanceClassNotSupported: '"{type}" no se admite para las comprobaciones de instancia y clase',
        keyNotRequired: '"{name}" no es una clave necesaria en "{type}", por lo que el acceso puede dar lugar a una excepción en tiempo de ejecución',
        keyReadOnly: '"{name}" es una clave de solo lectura en "{type}"',
        keyRequiredDeleted: '"{name}" es una clave necesaria y no se puede eliminar',
        keyUndefined: '"{name}" no es una clave definida en "{type}"',
        kwargsParamMissing: 'El parámetro "**{paramName}" no tiene ningún parámetro correspondiente.',
        listAssignmentMismatch: 'El tipo "{type}" es incompatible con la lista de objetivos',
        literalAssignmentMismatch: '"{sourceType}" no se puede asignar al tipo "{destType}"',
        matchIsNotExhaustiveHint: 'Si no se pretende un tratamiento exhaustivo, agregue "case _: pass"',
        matchIsNotExhaustiveType: 'Tipo no manejado: "{type}"',
        memberAssignment: 'La expresión de tipo "{type}" no se puede asignar al atributo "{name}" de la clase "{classType}"',
        memberIsAbstract: '"{type}. {name}" no está implementado',
        memberIsAbstractMore: 'y {count} más...',
        memberIsClassVarInProtocol: '"{name}" se define como ClassVar en el protocolo',
        memberIsInitVar: '"{name}" es un campo init-only',
        memberIsInvariant: '"{name}" es invariable porque es mutable',
        memberIsNotClassVarInClass: '"{name}" debe definirse como ClassVar para que sea compatible con el protocolo',
        memberIsNotClassVarInProtocol: '"{name}" no está definido como ClassVar en el protocolo',
        memberIsNotReadOnlyInProtocol: '"{name}" no es de solo lectura en el protocolo',
        memberIsReadOnlyInProtocol: '"{name}" es de solo lectura en el protocolo',
        memberIsWritableInProtocol: '"{name}" se puede escribir en el protocolo',
        memberSetClassVar: 'El atributo "{name}" no se puede asignar a través de una instancia de clase porque es un ClassVar.',
        memberTypeMismatch: '"{name}" es un tipo incompatible',
        memberUnknown: 'Atributo "{name}" desconocido',
        metaclassConflict: 'La metaclase "{metaclass1}" entra en conflicto con "{metaclass2}"',
        missingDeleter: 'Falta el método de deleter de property',
        missingGetter: 'Falta el método getter de la property',
        missingSetter: 'Falta el método setter de property',
        namedParamMissingInDest: 'Parámetro adicional "{name}"',
        namedParamMissingInSource: 'Falta el parámetro de palabra clave "{name}"',
        namedParamTypeMismatch: 'El parámetro de palabra clave "{name}" de tipo "{sourceType}" no es compatible con el tipo "{destType}"',
        namedTupleNotAllowed: 'No se puede usar NamedTuple para comprobaciones de instancia o clase',
        newMethodLocation: 'El método __new__ está definido en la clase "{type}"',
        newMethodSignature: 'La firma de __new__ es "{type}"',
        newTypeClassNotAllowed: 'La clase creada con NewType no se puede usar con comprobaciones de instancia y clase',
        noOverloadAssignable: 'Ninguna función sobrecargada coincide con el tipo "{type}"',
        noneNotAllowed: 'No se puede usar None para comprobaciones de instancia o clase',
        orPatternMissingName: 'Nombres que faltan: {name}',
        overloadIndex: 'La sobrecarga {index} es la coincidencia más cercana',
        overloadNotAssignable: 'Una o más sobrecargas de "{name}" no es asignable',
        overloadSignature: 'Aquí se define la firma de la sobrecarga',
        overriddenMethod: 'Método reemplazado',
        overriddenSymbol: 'Símbolo anulado',
        overrideInvariantMismatch: 'El tipo de invalidación “{overrideType}” no es el mismo que el tipo básico “{baseType}”',
        overrideIsInvariant: 'La variable es mutable, por lo que su tipo es invariable',
        overrideNoOverloadMatches: 'Ninguna firma de sobrecarga en anulación es compatible con el método base',
        overrideNotClassMethod: 'El método base se declara como classmethod pero el Reemplazar no',
        overrideNotInstanceMethod: 'El método base se declara como método de instancia, pero la invalidación no',
        overrideNotStaticMethod: 'El método base se declara como staticmethod pero el reemplazo no',
        overrideOverloadNoMatch: 'La invalidación no controla todas las sobrecargas del método base',
        overrideOverloadOrder: 'Las sobrecargas para el método de anulación deben estar en el mismo orden que el método base',
        overrideParamKeywordNoDefault: 'El parámetro de palabra clave "{name}" no coincide: el parámetro base tiene el valor de argumento predeterminado, el parámetro de invalidación no',
        overrideParamKeywordType: 'El parámetro de palabra clave "{name}" no coincide: el parámetro base es de tipo "{baseType}", el parámetro de invalidación es de tipo "{overrideType}"',
        overrideParamName: 'El nombre del parámetro {index} no coincide: el parámetro base se denomina "{baseName}", el parámetro de invalidación se denomina "{overrideName}"',
        overrideParamNameExtra: 'Falta el parámetro "{name}" en la base',
        overrideParamNameMissing: 'Falta el parámetro "{name}" en la invalidación',
        overrideParamNamePositionOnly: 'El parámetro {index} no coincide: el parámetro base "{baseName}" es un parámetro de palabra clave, el parámetro de invalidación es de solo posición',
        overrideParamNoDefault: 'El parámetro {index} no coincide: el parámetro base tiene un valor de argumento predeterminado, el parámetro de invalidación no',
        overrideParamType: 'El parámetro {index} no coincide: el parámetro base es de tipo "{baseType}", el parámetro de invalidación es de tipo "{overrideType}"',
        overridePositionalParamCount: 'El recuento de parámetros posicionales no coincide; el método base tiene {baseCount}, pero la invalidación tiene {overrideCount}',
        overrideReturnType: 'Error de tipo de retorno: el método base devuelve el tipo "{baseType}", el reemplazo devuelve el tipo "{overrideType}".',
        overrideType: 'La clase base define el tipo como "{type}"',
        paramAssignment: 'El parámetro {index}: el tipo "{sourceType}" no es compatible con el tipo "{destType}"',
        paramSpecMissingInOverride: 'Faltan parámetros ParamSpec en el método de invalidación',
        paramType: 'El tipo de parámetro es "{paramType}"',
        privateImportFromPyTypedSource: 'Importar desde "{module}" en su lugar',
        propertyAccessFromProtocolClass: 'No se puede tener acceso a una propiedad definida dentro de una clase de protocolo como variable de clase',
        propertyMethodIncompatible: 'El método de property "{name}" no es compatible',
        propertyMethodMissing: 'Falta el método de property "{name}" en la invalidación',
        propertyMissingDeleter: 'Property "{name}" no tiene un supresor deleter',
        propertyMissingSetter: 'Property "{name}" no tiene el valor setter definido',
        protocolIncompatible: '"{sourceType}" no es compatible con el protocolo "{destType}"',
        protocolMemberMissing: '"{name}" no está presente.',
        protocolRequiresRuntimeCheckable: 'La clase de Protocol debe ser @runtime_checkable para usarse con comprobaciones de instancia y clase',
        protocolSourceIsNotConcrete: '"{sourceType}" no es un tipo de clase concreto y no se puede asignar al tipo "{destType}"',
        protocolUnsafeOverlap: 'Los atributos de "{name}" tienen los mismos nombres que el protocolo',
        pyrightCommentIgnoreTip: 'Utilice "# pyright: ignore[<diagnostic rules>]" para suprimir el diagnóstico de una sola línea',
        readOnlyAttribute: 'El atributo "{name}" es de solo lectura',
        seeClassDeclaration: 'Ver declaración de clase',
        seeDeclaration: 'Ver declaración',
        seeFunctionDeclaration: 'Ver declaración de función',
        seeMethodDeclaration: 'Consulte la declaración del métodoa',
        seeParameterDeclaration: 'Declaración de parámetro',
        seeTypeAliasDeclaration: 'Véase la declaración de alias de tipo',
        seeVariableDeclaration: 'declaración de variable out',
        tupleAssignmentMismatch: 'El tipo "{type}" no es compatible con la tuple de destino',
        tupleEntryTypeMismatch: 'La entrada {entry} de la tuple es de tipo incorrecto',
        tupleSizeIndeterminateSrc: 'El tamaño de la tuple no coincide; se esperaba {expected} pero se recibió uno indeterminado',
        tupleSizeIndeterminateSrcDest: 'El tamaño de la tuple no coincide; se esperaba {expected} o más, pero se recibió uno indeterminado',
        tupleSizeMismatch: 'El tamaño de la tuple no coincide; se esperaba {expected} pero se recibió {received}',
        tupleSizeMismatchIndeterminateDest: 'El tamaño de la tuple no coincide; se esperaba {expected} o más, pero se recibió {received}',
        typeAliasInstanceCheck: 'El alias de tipo creado con la instrucción "type" no se puede usar con comprobaciones de instancia y clase',
        typeAssignmentMismatch: 'El tipo "{sourceType}" no se puede asignar al tipo "{destType}"',
        typeBound: 'El tipo "{sourceType}" no se puede asignar al límite superior "{destType}" para la variable de tipo "{name}"',
        typeConstrainedTypeVar: 'El tipo "{type}" no se puede asignar a la variable de tipo restringido "{name}"',
        typeIncompatible: '"{sourceType}" no se puede asignar a "{destType}"',
        typeNotClass: '"{type}" no es una clase',
        typeNotStringLiteral: '"{type}" no es un literal de cadena',
        typeOfSymbol: 'El tipo de "{name}" es "{type}"',
        typeParamSpec: 'El tipo "{type}" no es compatible con ParamSpec "{name}"',
        typeUnsupported: 'El tipo "{type}" no es compatible',
        typeVarDefaultOutOfScope: 'La variable de tipo "{name} " no está en el ámbito de aplicación',
        typeVarIsContravariant: 'El parámetro de tipo "{name}" es contravariante, pero "{sourceType}" no es un supertipo de "{destType}"',
        typeVarIsCovariant: 'El parámetro de tipo "{name}" es covariante, pero "{sourceType}" no es un subtipo de "{destType}"',
        typeVarIsInvariant: 'El parámetro de tipo "{name}" es invariable, pero "{sourceType}" no es el mismo que "{destType}"',
        typeVarNotAllowed: 'TypeVar no se permite para comprobaciones de instancia o clase',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple no se puede enlazar a una tuple de longitud desconocida',
        typeVarUnnecessarySuggestion: 'Usar {type} en su lugar',
        typeVarUnsolvableRemedy: 'Proporciona una sobrecarga que especifica el tipo de retorno cuando no se proporciona el argumento',
        typeVarsMissing: 'Faltan variables de tipo: {names}',
        typedDictBaseClass: 'La clase “{type}” no es un TypedDict',
        typedDictClassNotAllowed: 'No se permite la clase TypedDict para comprobaciones de instancia o clase',
        typedDictClosedExtraNotAllowed: 'No se puede agregar el elemento "{name}"',
        typedDictClosedExtraTypeMismatch: 'No se puede agregar el elemento "{name}" con el tipo "{type}"',
        typedDictClosedFieldNotRequired: 'No se puede agregar el elemento "{name}" porque debe ser NotRequired.',
        typedDictExtraFieldNotAllowed: '"{name}" no está presente en "{type}"',
        typedDictExtraFieldTypeMismatch: 'El tipo de "{name}" no es compatible con el tipo de "extra_items" en "{type}"',
        typedDictFieldMissing: '"{name}" falta en "{type}"',
        typedDictFieldNotReadOnly: '"{name}" no es de solo lectura en "{type}"',
        typedDictFieldNotRequired: '"{name}" no es obligatorio en "{type}"',
        typedDictFieldRequired: '"{name}" es obligatorio en "{type}"',
        typedDictFieldTypeMismatch: 'El tipo "{type}" no se puede asignar al elemento "{name}"',
        typedDictFieldUndefined: '"{name}" es un elemento no definido en el tipo "{type}"',
        typedDictFinalMismatch: '"{sourceType}" no es compatible con "{destType}" debido a una discrepancia @final',
        typedDictKeyAccess: 'Utilizar ["{name}"] para hacer referencia al elemento en TypedDict',
        typedDictNotAllowed: 'No se puede usar TypedDict para comprobaciones de instancia o clase',
        unhashableType: 'El tipo "{type}" no admite hash',
        uninitializedAbstractVariable: 'La variable de instancia "{name}" está definida en la clase base abstracta "{classType} " pero no inicializada.',
        unreachableExcept: '"{exceptionType}" es una subclase de "{parentType}"',
        useDictInstead: 'Usar Dict[T1, T2] para indicar un tipo de diccionario',
        useListInstead: 'Usar List[T] para indicar un tipo de list o Union[T1, T2] para indicar un tipo de union',
        useTupleInstead: 'Utilice tuple[T1, ..., Tn] para indicar un tipo de tuple o Union[T1, T2] para indicar un tipo de union.',
        useTypeInstead: 'Utilice Type[T] en su lugar',
        varianceMismatchForClass: 'La varianza del argumento de tipo "{typeVarName}" no es compatible con la clase base "{className}"',
        varianceMismatchForTypeAlias: 'La varianza del argumento de tipo "{typeVarName}" no es compatible con "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'La enumeración de los archivos de origen del área de trabajo está tardando mucho tiempo. Considere la posibilidad de abrir una subcarpeta en su lugar. [Más información](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  18154: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Créer un Stub de type',
        createTypeStubFor: 'Créer un Stub de type pour « {moduleName} »',
        executingCommand: 'Exécution de la commande',
        filesToAnalyzeCount: '{count} fichiers à analyser',
        filesToAnalyzeOne: '1 fichier à analyser',
        findingReferences: 'Recherche de références',
        organizeImports: 'Organiser les importations',
        renameShadowedFile: 'Renommez "{oldFile}" en "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Importation automatique',
        indexValueDetail: 'Valeur de l\'indice'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Désolé, nous n’avons pas pu appeler la méthode « {method} », car elle est abstraite et non implémentée',
        annotatedMetadataInconsistent: 'Le type de métadonnées annoté « {metadataType} » n’est pas compatible avec le type « {type} »',
        annotatedParamCountMismatch: 'Non-concordance du nombre d\'annotations de paramètre : attendu {expected} mais reçu {received}',
        annotatedTypeArgMissing: 'Un argument de type et une ou plusieurs annotations sont attendus pour « Annotated »',
        annotationBytesString: 'Les expressions de type ne peuvent pas utiliser de littéraux de chaîne d\'octets',
        annotationFormatString: 'Les expressions de type ne peuvent pas utiliser de littéraux de chaîne de format (chaînes f)',
        annotationNotSupported: 'Annotation de type non prise en charge pour cette instruction',
        annotationRawString: 'Les expressions de type ne peuvent pas utiliser de littéraux de chaîne bruts',
        annotationSpansStrings: 'Les expressions de type ne peuvent pas s\'étendre sur plusieurs littéraux de chaîne',
        annotationStringEscape: 'Les expressions de type ne peuvent pas contenir de caractères d\'échappement',
        argAssignment: 'Impossible d’affecter l’argument de type « {argType} » au paramètre de type « {paramType} »',
        argAssignmentFunction: 'Impossible d’affecter l’argument de type « {argType} » au paramètre de type « {paramType} » dans la fonction « {functionName} »',
        argAssignmentParam: 'Impossible d’affecter l’argument de type « {argType} » au paramètre « {paramName} » de type « {paramType} »',
        argAssignmentParamFunction: 'Impossible d’affecter l’argument de type « {argType} » au paramètre « {paramName} » de type « {paramType} » dans la fonction « {functionName} »',
        argMissingForParam: 'Argument manquant pour le paramètre {name}',
        argMissingForParams: 'Arguments manquants pour les paramètres {names}',
        argMorePositionalExpectedCount: '{expected} arguments positionnels supplémentaires attendus',
        argMorePositionalExpectedOne: '1 argument positionnel supplémentaire attendu',
        argPositional: 'Argument positionnel attendu',
        argPositionalExpectedCount: 'Arguments positionnels {expected} attendus',
        argPositionalExpectedOne: '1 argument positionnel attendu',
        argTypePartiallyUnknown: 'Le type d\'argument est partiellement inconnu',
        argTypeUnknown: 'Le type d’argument est inconnu',
        assertAlwaysTrue: 'L’expression Assert prend toujours la valeur true',
        assertTypeArgs: '« assert_type » attend deux arguments positionnels',
        assertTypeTypeMismatch: 'Non-concordance de « assert_type » : « {expected} » attendu, mais « {received} »',
        assignmentExprComprehension: 'La cible d\'expression d\'affectation "{name}" ne peut pas utiliser le même nom que la compréhension pour la cible',
        assignmentExprContext: 'L’expression d’assignation doit se trouver dans le module, la fonction ou l’expression lambda',
        assignmentExprInSubscript: 'Les expressions d’assignation dans un indice sont prises en charge uniquement dans Python 3.10 et versions ultérieures',
        assignmentInProtocol: 'Les variables d\'instance ou de classe au sein d\'une classe Protocol doivent être explicitement déclarées dans le corps de la classe',
        assignmentTargetExpr: 'L’expression ne peut pas être une cible d’assignation',
        asyncNotInAsyncFunction: 'L\'utilisation de "async" n\'est pas autorisée en dehors de la fonction async',
        awaitIllegal: 'L’utilisation de « await » nécessite Python 3.5 ou version ultérieure',
        awaitNotAllowed: 'Les expressions de type ne peuvent pas utiliser « await »',
        awaitNotInAsync: '« await » autorisé uniquement dans la fonction asynchrone',
        backticksIllegal: 'Les expressions entourées de accents inverses ne sont pas prises en charge dans Python 3.x; utiliser repr à la place',
        baseClassCircular: 'La classe ne peut pas dériver d\'elle-même',
        baseClassFinal: 'La classe de base « {type} » est marquée comme finale et ne peut pas être sous-classée',
        baseClassIncompatible: 'Les classes de base de {type} sont mutuellement incompatibles',
        baseClassInvalid: 'L’argument pour la classe doit être une classe de base',
        baseClassMethodTypeIncompatible: 'Les classes de base de la classe « {classType} » définissent la méthode « {name} » de manière incompatible',
        baseClassUnknown: 'Le type de classe de base est inconnu, ce qui masque le type de classe dérivée',
        baseClassVariableTypeIncompatible: 'Les classes de base de la classe « {classType} » définissent la variable « {name} » de manière incompatible',
        binaryOperationNotAllowed: 'Opérateur binaire non autorisé dans l\'expression de type',
        bindTypeMismatch: 'Impossible de lier la méthode "{methodName}" car "{type}" n\'est pas attribuable au paramètre "{paramName}"',
        breakInExceptionGroup: '« break » n’est pas autorisé dans un bloc « except* »',
        breakOutsideLoop: '"break" ne peut être utilisé qu\'à l\'intérieur d\'une boucle',
        callableExtraArgs: 'Seuls deux arguments de type sont attendus pour « Callable »',
        callableFirstArg: 'Liste de types de paramètres attendue ou « ... »',
        callableNotInstantiable: 'Impossible d’instancier le type « {type} »',
        callableSecondArg: 'Type de retour attendu en tant que deuxième argument de type pour « Callable »',
        casePatternIsIrrefutable: 'Le motif irréfutable n\'est autorisé que pour la dernière instruction case',
        classAlreadySpecialized: 'Le type « {type} » est déjà spécialisé',
        classDecoratorTypeUnknown: 'Le décorateur de classe non typé masque le type de classe ; décorateur ignorant',
        classDefinitionCycle: 'La définition de classe pour "{name}" dépend d\'elle-même',
        classGetItemClsParam: '__class_getitem__ remplacement doit prendre un paramètre « cls »',
        classMethodClsParam: 'Les méthodes de classe doivent prendre un paramètre "cls"',
        classNotRuntimeSubscriptable: 'L\'indice pour la classe « {name} » générera une exception d\'exécution ; placez l\'expression de type entre guillemets',
        classPatternBuiltInArgPositional: 'Le modèle de classe accepte uniquement le sous-modèle positionnel',
        classPatternPositionalArgCount: 'Trop de modèles positionnels pour les "{type}" de classe ; {expected} attendue mais {received} reçues',
        classPatternTypeAlias: '"{type}" ne peut pas être utilisé dans un modèle de classe car il s\'agit d\'un alias de type spécialisé',
        classPropertyDeprecated: 'Les propriétés de classe sont obsolètes dans Python 3.11 et ne seront pas prises en charge dans Python 3.13',
        classTypeParametersIllegal: 'La syntaxe du paramètre de type de classe nécessite Python 3.12 ou version ultérieure',
        classVarFirstArgMissing: 'Attendu un argument de type après "ClassVar"',
        classVarNotAllowed: '« ClassVar » n’est pas autorisé dans ce contexte',
        classVarOverridesInstanceVar: 'La variable de classe « {name} » remplace la variable d’instance du même nom dans la classe « {className} »',
        classVarTooManyArgs: 'Attendu un seul argument de type après "ClassVar"',
        classVarWithTypeVar: 'Le type "ClassVar" ne peut pas inclure de variables de type',
        clsSelfParamTypeMismatch: 'Le type de paramètre "{name}" doit être un supertype de sa classe "{classType}"',
        codeTooComplexToAnalyze: 'Le code est trop complexe à analyser ; réduire la complexité en refactorisant en sous-routines ou en réduisant les chemins de code conditionnels',
        collectionAliasInstantiation: 'Le type "{type}" ne peut pas être instancié, utilisez "{alias}" à la place',
        comparisonAlwaysFalse: 'La condition prend toujours la valeur False, car les types « {leftType} » et « {rightType} » ne se chevauchent pas',
        comparisonAlwaysTrue: 'La condition prend toujours la valeur True, car les types « {leftType} » et « {rightType} » ne se chevauchent pas',
        comprehensionInDict: 'La compréhension ne peut pas être utilisée avec d’autres entrées de dictionnaire',
        comprehensionInSet: 'La compréhension ne peut pas être utilisée avec d’autres entrées set',
        concatenateContext: '« Concatenate » n’est pas autorisé dans ce contexte',
        concatenateParamSpecMissing: 'Le dernier argument de type pour « Concatenate » doit être un ParamSpec ou bien « ... »',
        concatenateTypeArgsMissing: '« Concatenate » nécessite au moins deux arguments de type',
        conditionalOperandInvalid: 'Opérande conditionnel non valide de type "{type}"',
        constantRedefinition: '"{name}" est constant (car il est en majuscule) et ne peut pas être redéfini',
        constructorParametersMismatch: 'Non-concordance entre la signature de __new__ et __init__ dans la classe "{classType}"',
        containmentAlwaysFalse: 'L\'expression sera toujours évaluée à False car les types "{leftType}" et "{rightType}" ne se chevauchent pas',
        containmentAlwaysTrue: 'L\'expression sera toujours évaluée à True puisque les types "{leftType}" et "{rightType}" ne se chevauchent pas',
        continueInExceptionGroup: '« continue » n’est pas autorisé dans un bloc « except* »',
        continueOutsideLoop: '« continuer » ne peut être utilisé qu’au sein d’une boucle',
        coroutineInConditionalExpression: 'L\'expression conditionnelle fait référence à une coroutine qui est toujours évaluée à True',
        dataClassBaseClassFrozen: 'Une classe non gelée ne peut pas hériter d\'une classe gelée',
        dataClassBaseClassNotFrozen: 'Une classe figée ne peut pas hériter d’une classe qui n’est pas figée',
        dataClassConverterFunction: 'L’argument de type « {argType} » n’est pas un convertisseur valide pour le champ « {fieldName} » de type « {fieldType} »',
        dataClassConverterOverloads: 'Aucune surcharge de « {funcName} » n’est valide pour le champ « {fieldName} » de type « {fieldType} »',
        dataClassFieldInheritedDefault: '« {fieldName} » remplace un champ du même nom mais n’a pas de valeur par défaut',
        dataClassFieldWithDefault: 'Les champs sans valeurs par défaut ne peuvent pas apparaître après les champs avec des valeurs par défaut',
        dataClassFieldWithPrivateName: 'Le champ Dataclass ne peut pas utiliser de nom privé',
        dataClassFieldWithoutAnnotation: 'Le champ Dataclass sans annotation de type provoquera une exception d\'exécution',
        dataClassPostInitParamCount: 'La classe de données __post_init__ nombre de paramètres incorrect ; le nombre de champs InitVar est {expected}',
        dataClassPostInitType: 'Incompatibilité du type de paramètre de méthode __post_init__ Dataclass pour le champ « {fieldName} »',
        dataClassSlotsOverwrite: '__slots__ est déjà défini dans la classe',
        dataClassTransformExpectedBoolLiteral: 'Expression attendue qui prend statiquement la valeur True ou False',
        dataClassTransformFieldSpecifier: 'Expected tuple of classes or functions but received type "{type}"',
        dataClassTransformPositionalParam: 'Tous les arguments de « dataclass_transform » doivent être des arguments de mot clé',
        dataClassTransformUnknownArgument: 'L’argument « {name} » n’est pas pris en charge par dataclass_transform',
        dataProtocolInSubclassCheck: 'Les protocoles de données (qui incluent des attributs non méthode) ne sont pas autorisés dans les appels de issubclass',
        declaredReturnTypePartiallyUnknown: 'Le type de retour déclaré « {returnType} » est partiellement inconnu',
        declaredReturnTypeUnknown: 'Le type de retour déclaré est inconnu',
        defaultValueContainsCall: 'Les appels de fonction et les objets mutables ne sont pas autorisés dans l\'expression de la valeur par défaut du paramètre',
        defaultValueNotAllowed: 'Le paramètre avec « * » ou « ** » ne peut pas avoir de valeur par défaut',
        delTargetExpr: 'L\'expression ne peut pas être supprimée',
        deprecatedClass: 'La classe "{name}" est obsolète',
        deprecatedConstructor: 'Le constructeur de la classe « {name} » est déconseillé',
        deprecatedDescriptorDeleter: 'La méthode « __delete__ » du descripteur « {name} » est déconseillée',
        deprecatedDescriptorGetter: 'La méthode « __get__ » du descripteur « {name} » est déconseillée',
        deprecatedDescriptorSetter: 'La méthode « __set__ » du descripteur « {name} » est déconseillée',
        deprecatedFunction: 'La fonction "{name}" est obsolète',
        deprecatedMethod: 'La méthode "{name}" dans la classe "{className}" est obsolète',
        deprecatedPropertyDeleter: 'Le deleter de la property « {name} » est déconseillé',
        deprecatedPropertyGetter: 'Le getter de la property « {name} » est déconseillé',
        deprecatedPropertySetter: 'Le setter de la property « {name} » est déconseillé',
        deprecatedType: 'Ce type est déconseillé à compter de Python {version}; utiliser « {replacement} » à la place',
        dictExpandIllegalInComprehension: 'Expansion du dictionnaire non autorisée dans la compréhension',
        dictInAnnotation: 'Expression de dictionnaire non autorisée dans l\'expression de type',
        dictKeyValuePairs: 'Les entrées de dictionnaire doivent contenir des paires clé/valeur',
        dictUnpackIsNotMapping: 'Mappage attendu pour l’opérateur de décompression de dictionnaire',
        dunderAllSymbolNotPresent: '« {name} » est spécifié dans __all__ mais n’est pas présent dans le module',
        duplicateArgsParam: 'Un seul paramètre « * » est autorisé',
        duplicateBaseClass: 'Classe de base en double non autorisée',
        duplicateCapturePatternTarget: 'La cible Capture "{name}" ne peut pas apparaître plus d\'une fois dans le même modèle',
        duplicateCatchAll: 'Une seule clause catch-all except autorisée',
        duplicateEnumMember: 'Le membre Enum « {name} » est déjà déclaré',
        duplicateGenericAndProtocolBase: 'Une seule classe de base Generic[...] ou Protocol[...] autorisée',
        duplicateImport: '« {importName} » est importé plusieurs fois',
        duplicateKeywordOnly: 'Un seul séparateur « * » autorisé',
        duplicateKwargsParam: 'Un seul paramètre « ** » est autorisé',
        duplicateParam: 'Dupliquer le paramètre « {name} »',
        duplicatePositionOnly: 'Un seul paramètre "/" autorisé',
        duplicateStarPattern: 'Un seul motif "*" autorisé dans une séquence de motifs',
        duplicateStarStarPattern: 'Une seule entrée "**" autorisée',
        duplicateUnpack: 'Une seule opération de décompression autorisée dans la liste',
        ellipsisAfterUnpacked: '"..." ne peut pas être utilisé avec un TypeVarTuple ou un tuple décompressé',
        ellipsisContext: '« ... » n’est pas autorisé dans ce contexte',
        ellipsisSecondArg: '« ... » n’est autorisé qu’en tant que second des deux arguments',
        enumClassOverride: 'La classe Enum « {name} » est finale et ne peut pas être sous-classée',
        enumMemberDelete: 'Le membre Enum « {name} » ne peut pas être supprimé',
        enumMemberSet: 'Le membre Enum « {name} » ne peut pas être affecté',
        enumMemberTypeAnnotation: 'Les annotations de type ne sont pas autorisées pour les membres enum',
        exceptGroupMismatch: 'L’instruction Try ne peut pas inclure à la fois « except » et « except* »',
        exceptGroupRequiresType: 'La syntaxe du groupe d’exceptions (« except* ») nécessite un type d’exception',
        exceptionGroupIncompatible: 'La syntaxe du groupe d’exceptions (« except* ») nécessite Python 3.11 ou version ultérieure',
        exceptionGroupTypeIncorrect: 'Le type d’exception dans except* ne peut pas dériver de BaseGroupException',
        exceptionTypeIncorrect: '"{type}" ne dérive pas de BaseException',
        exceptionTypeNotClass: '« {type} » n’est pas une classe d’exception valide',
        exceptionTypeNotInstantiable: 'Le constructeur pour le type d’exception « {type} » requiert un ou plusieurs arguments',
        expectedAfterDecorator: 'Fonction attendue ou déclaration de classe après le décorateur',
        expectedArrow: '« -> » attendu suivi d’une annotation de type de retour',
        expectedAsAfterException: '« as » attendu après le type d’exception',
        expectedAssignRightHandExpr: 'Expression attendue à droite de « = »',
        expectedBinaryRightHandExpr: 'Expression attendue à droite de l’opérateur',
        expectedBoolLiteral: 'Attendu True ou False',
        expectedCase: 'Instruction « case » attendue',
        expectedClassName: 'Nom de classe attendu',
        expectedCloseBrace: '« { » n’a pas été fermé',
        expectedCloseBracket: '« [ » n’a pas été fermé',
        expectedCloseParen: '« ( » n’a pas été fermé',
        expectedColon: '« : » attendu',
        expectedComplexNumberLiteral: 'Littéral de nombre complexe attendu pour la correspondance de modèle',
        expectedDecoratorExpr: 'Formulaire d’expression non pris en charge pour l’élément décoratif antérieur à Python 3.9',
        expectedDecoratorName: 'Nom de l’élément décoratif attendu',
        expectedDecoratorNewline: 'Nouvelle ligne attendue à la fin de l’élément décoratif',
        expectedDelExpr: 'Expression attendue après « del »',
        expectedElse: '« else » attendu',
        expectedEquals: '« = » attendu',
        expectedExceptionClass: 'Classe ou objet d\'exception non valide',
        expectedExceptionObj: 'Objet d’exception attendu, classe d’exception ou None',
        expectedExpr: 'Expression attendue',
        expectedFunctionAfterAsync: 'Définition de fonction attendue après "async"',
        expectedFunctionName: 'Nom de fonction attendu après « def »',
        expectedIdentifier: 'Identifiant attendu',
        expectedImport: '« importation » attendue',
        expectedImportAlias: 'Symbole attendu après « as »',
        expectedImportSymbols: 'Un ou plusieurs noms de symboles attendus après « l’importation »',
        expectedIn: '« in » attendu',
        expectedInExpr: 'Expression attendue après « in »',
        expectedIndentedBlock: 'Bloc en retrait attendu',
        expectedMemberName: 'Nom d’attribut attendu après « . »',
        expectedModuleName: 'Nom de module attendu',
        expectedNameAfterAs: 'Nom de symbole attendu après "as"',
        expectedNamedParameter: 'Le paramètre de mot clé doit suivre « * »',
        expectedNewline: 'Nouvelle ligne attendue',
        expectedNewlineOrSemicolon: 'Les instructions doivent être séparées par des nouvelles lignes ou des points-virgules',
        expectedOpenParen: 'Attendu "("',
        expectedParamName: 'Nom du paramètre attendu',
        expectedPatternExpr: 'Expression de modèle attendue',
        expectedPatternSubjectExpr: 'Expression du sujet du modèle attendu',
        expectedPatternValue: 'Expression de valeur de modèle attendue sous la forme « a.b »',
        expectedReturnExpr: 'Expression attendue après « return »',
        expectedSliceIndex: 'Expression d\'index ou de tranche attendue',
        expectedTypeNotString: 'Type attendu mais réception d’un littéral de chaîne',
        expectedTypeParameterName: 'Nom de paramètre de type attendu',
        expectedYieldExpr: 'Expression attendue dans l\'instruction yield',
        finalClassIsAbstract: 'La classe « {type} » est marquée comme finale et doit implémenter toutes les symboles abstraits',
        finalContext: '« Final » n’est pas autorisé dans ce contexte',
        finalInLoop: 'Impossible d’assigner une variable « Final » dans une boucle',
        finalMethodOverride: 'La méthode « {name} » ne peut pas remplacer la méthode finale définie dans la classe « {className} »',
        finalNonMethod: 'La fonction « {name} » ne peut pas être marquée @final, car il ne s’agit pas d’une méthode',
        finalReassigned: '« {name} » est déclaré Final et ne peut pas être réaffecté',
        finalRedeclaration: '« {name} » a été déclaré comme Final',
        finalRedeclarationBySubclass: '« {name} » ne peut pas être redéclaré, car la classe parente « {className} » la déclare Final',
        finalTooManyArgs: 'Argument de type unique attendu après « Final »',
        finalUnassigned: '« {name} » est déclaré Final, mais la valeur n’est pas affectée',
        formatStringBrace: 'Accolade fermante unique non autorisée dans le littéral f-string ; utiliser une double accolade fermée',
        formatStringBytes: 'Les littéraux de chaîne de format (chaînes f) ne peuvent pas être binaires',
        formatStringDebuggingIllegal: 'Le spécificateur de débogage de chaîne F "=" nécessite Python 3.8 ou une version plus récente',
        formatStringEscape: 'Séquence d\'échappement (barre oblique inverse) non autorisée dans la partie expression de la chaîne f avant Python 3.12',
        formatStringExpectedConversion: 'Spécificateur de conversion attendu après « ! » dans f-string',
        formatStringIllegal: 'Les littéraux de chaîne de format (chaînes f) nécessitent Python 3.6 ou une version plus récente',
        formatStringInPattern: 'Chaîne de format non autorisée dans le modèle',
        formatStringNestedFormatSpecifier: 'Expressions imbriqués trop profondément dans le spécificateur de chaîne de format',
        formatStringNestedQuote: 'Les chaînes imbriquées dans une chaîne f ne peuvent pas utiliser le même guillemet que la chaîne f avant Python 3.12',
        formatStringUnicode: 'Les littéraux de chaîne de format (f-strings) ne peuvent pas être unicode',
        formatStringUnterminated: 'Expression non terminée dans f-string ; attendant "}"',
        functionDecoratorTypeUnknown: 'Le décorateur de fonction non typé masque le type de fonction ; élément décoratif ignoré',
        functionInConditionalExpression: 'L’expression conditionnelle fait référence à une fonction qui prend toujours la valeur True',
        functionTypeParametersIllegal: 'La syntaxe des paramètres de type de fonction nécessite Python 3.12 ou une version plus récente',
        futureImportLocationNotAllowed: 'Les importations à partir de __future__ doivent se trouver au début du fichier',
        generatorAsyncReturnType: 'Le type de retour de la fonction de générateur asynchrone doit être compatible avec « AsyncGenerator[{yieldType}, Any] »',
        generatorNotParenthesized: 'Les expressions de générateur doivent être entre parenthèses si elles ne sont pas uniquement des arguments',
        generatorSyncReturnType: 'Le type de retour de la fonction de générateur doit être compatible avec « Generator[{yieldType}, Any, Any] »',
        genericBaseClassNotAllowed: 'La classe de base « Generic » ne peut pas être utilisée avec la syntaxe de paramètre de type',
        genericClassAssigned: 'Impossible d’attribuer le type de classe générique',
        genericClassDeleted: 'Le type de classe générique ne peut pas être supprimé',
        genericInstanceVariableAccess: 'L’accès à une variable d’instance générique via une classe est ambigu',
        genericNotAllowed: '« Generic » n’est pas valide dans ce contexte',
        genericTypeAliasBoundTypeVar: 'L’alias de type générique dans la classe ne peut pas utiliser les variables de type lié {names}',
        genericTypeArgMissing: '« Generic » nécessite au moins un argument de type',
        genericTypeArgTypeVar: 'L’argument de type pour « Generic » doit être une variable de type',
        genericTypeArgUnique: 'Les arguments de type pour « Generic » doivent être uniques',
        globalReassignment: '« {name} » est attribué avant la déclaration globale',
        globalRedefinition: '« {name} » a déjà été déclaré global',
        implicitStringConcat: 'Concaténation implicite de chaînes non autorisée',
        importCycleDetected: 'Cycle détecté dans la chaîne d\'importation',
        importDepthExceeded: 'La profondeur de la chaîne d\'importation a dépassé {depth}',
        importResolveFailure: 'Impossible de résoudre l’importation « {importName} »',
        importSourceResolveFailure: 'Impossible de résoudre l’importation « {importName} » à partir de la source',
        importSymbolUnknown: '« {name} » est un symbole d’importation inconnu',
        incompatibleMethodOverride: 'La méthode « {name} » remplace la classe « {className} » de manière incompatible',
        inconsistentIndent: 'Le montant du retrait ne correspond pas au retrait précédent',
        inconsistentTabs: 'Utilisation incohérente des onglets et des espaces dans la mise en retrait',
        initMethodSelfParamTypeVar: 'L’annotation de type pour le paramètre « self » de la méthode « __init__ » ne peut pas contenir de variables de type de portée de classe',
        initMustReturnNone: 'Le type de retour de « __init__ » doit être None',
        initSubclassCallFailed: 'Arguments de mot clé incorrects pour la méthode __init_subclass__',
        initSubclassClsParam: '__init_subclass__ remplacement doit prendre un paramètre « cls »',
        initVarNotAllowed: '« InitVar » n’est pas autorisé dans ce contexte',
        instanceMethodSelfParam: 'Les méthodes d’instance doivent prendre un paramètre « self »',
        instanceVarOverridesClassVar: 'La variable d\'instance "{name}" remplace la variable de classe du même nom dans la classe "{className}"',
        instantiateAbstract: 'Impossible d\'instancier la classe abstraite "{type}"',
        instantiateProtocol: 'Impossible d’instancier la classe de Protocol "{type}"',
        internalBindError: 'Une erreur interne s’est produite lors de la liaison du fichier « {file} » : {message}',
        internalParseError: 'Une erreur interne s’est produite lors de l’analyse du fichier « {file} » : {message}',
        internalTypeCheckingError: 'Une erreur interne s’est produite lors de la vérification de type du fichier « {file} » : {message}',
        invalidIdentifierChar: 'Caractère invalide dans l\'identifiant',
        invalidStubStatement: 'L’instruction n’a aucun sens dans un fichier stub de type',
        invalidTokenChars: 'Caractère non valide "{text}" dans le jeton',
        isInstanceInvalidType: 'Le deuxième argument de "isinstance" doit être une classe ou un tuple de classes',
        isSubclassInvalidType: 'Le deuxième argument de « issubclass » doit être une classe ou un tuple de classes',
        keyValueInSet: 'Les paires clé/valeur ne sont pas autorisées dans un set',
        keywordArgInTypeArgument: 'Les arguments de mot-clé ne peuvent pas être utilisés dans les listes d\'arguments de type',
        keywordArgShortcutIllegal: 'Le raccourci d’argument de mot clé nécessite Python 3.14 ou une version plus récente',
        keywordOnlyAfterArgs: 'Séparateur d’arguments mot clé uniquement non autorisé après le paramètre « * »',
        keywordParameterMissing: 'Un ou plusieurs paramètres de mot-clé doivent suivre le paramètre "*"',
        keywordSubscriptIllegal: 'Les arguments de mot-clé dans les indices ne sont pas pris en charge',
        lambdaReturnTypePartiallyUnknown: 'Le type de retour de lambda, « {returnType} », est partiellement inconnu',
        lambdaReturnTypeUnknown: 'Le type de retour de lambda est inconnu',
        listAssignmentMismatch: 'Impossible d’affecter l’expression de type « {type} » à la liste cible',
        listInAnnotation: 'Expression de List non autorisée dans l’expression de type',
        literalEmptyArgs: 'Attendu un ou plusieurs arguments de type après "Literal"',
        literalNamedUnicodeEscape: 'Les séquences d’échappement Unicode nommées ne sont pas prises en charge dans les annotations de chaîne « Literal »',
        literalNotAllowed: '« Literal » ne peut pas être utilisé dans ce contexte sans argument de type',
        literalNotCallable: 'Impossible d’instancier le type Literal',
        literalUnsupportedType: 'Les arguments de type pour « Literal » doivent être None, une valeur littérale (int, bool, str ou bytes) ou une valeur enum',
        matchIncompatible: 'Les instructions de Match nécessitent Python 3.10 ou version ultérieure',
        matchIsNotExhaustive: 'Les cas dans l’instruction match ne gèrent pas toutes les valeurs de manière exhaustive',
        maxParseDepthExceeded: 'Profondeur d’analyse maximale dépassée ; scinder l’expression en sous-expressions plus petites',
        memberAccess: 'Désolé... Nous ne pouvons pas accéder à l’attribut « {name} » pour la classe « {type} »',
        memberDelete: 'Désolé... Nous ne pouvons pas supprimer l’attribut « {name} » pour la classe « {type} »',
        memberSet: 'Désolé... Nous ne pouvons pas affecter l’attribut « {name} » pour la classe « {type} »',
        metaclassConflict: 'La métaclasse d’une classe dérivée doit être une sous-classe des métaclasses de toutes ses classes de base',
        metaclassDuplicate: 'Une seule métaclasse peut être fournie',
        metaclassIsGeneric: 'La métaclasse ne peut pas être générique',
        methodNotDefined: 'Méthode « {name} » non définie',
        methodNotDefinedOnType: 'Méthode « {name} » non définie sur le type « {type} »',
        methodOrdering: 'Impossible de créer un classement de méthode cohérent',
        methodOverridden: '"{name}" remplace la méthode du même nom dans la classe "{className}" avec un type incompatible "{type}"',
        methodReturnsNonObject: 'La méthode « {name} » ne retourne pas d’objet',
        missingSuperCall: 'La méthode « {methodName} » n’appelle pas la méthode du même nom dans la classe parente',
        mixingBytesAndStr: 'Les valeurs Bytes et str ne peuvent pas être concaténées',
        moduleAsType: 'Le module ne peut pas être utilisé comme type',
        moduleNotCallable: 'Le module ne peut pas être appelé',
        moduleUnknownMember: '« {memberName} » n’est pas un attribut connu du module « {moduleName} »',
        namedExceptAfterCatchAll: 'Une clause except nommée ne peut pas apparaître après une clause except fourre-tout',
        namedParamAfterParamSpecArgs: 'Le paramètre de mot clé « {name} » ne peut pas apparaître dans la signature après le paramètre ParamSpec args',
        namedTupleEmptyName: 'Les noms dans un tuple nommé ne peuvent pas être vides',
        namedTupleEntryRedeclared: 'Impossible de remplacer « {name} », car la classe parente « {className} » est un tuple nommé',
        namedTupleFirstArg: 'Nom de classe de tuple nommé attendu en tant que premier argument',
        namedTupleMultipleInheritance: 'L’héritage multiple avec NamedTuple n’est pas pris en charge',
        namedTupleNameKeyword: 'Les noms de champs ne peuvent pas être un mot-clé',
        namedTupleNameType: 'Expected two-entry tuple specifying entry name and type',
        namedTupleNameUnique: 'Les noms dans un tuple nommé doivent être uniques',
        namedTupleNoTypes: '« namedtuple » ne fournit aucun type pour les entrées de tuple ; utilisez « NamedTuple » à la place',
        namedTupleSecondArg: 'Expected named tuple entry list as second argument',
        newClsParam: '__new__ remplacement doit prendre un paramètre « cls »',
        newTypeAnyOrUnknown: 'Le deuxième argument de NewType doit être une classe connue, et non Any ou Unknown',
        newTypeBadName: 'Le premier argument de NewType doit être un littéral de chaîne',
        newTypeLiteral: 'Impossible d’utiliser NewType avec le type Literal',
        newTypeNameMismatch: 'NewType doit être affecté à une variable portant le même nom',
        newTypeNotAClass: 'Classe attendue comme deuxième argument de NewType',
        newTypeParamCount: 'NewType requiert deux arguments positionnels',
        newTypeProtocolClass: 'Désolé, nous n’avons pas pu utiliser NewType avec un type structurelle (un Protocol ou une classe TypedDict)',
        noOverload: 'Aucune surcharge pour « {name} » ne correspond aux arguments fournis',
        noReturnContainsReturn: 'La fonction avec le type de return déclaré « NoReturn » ne peut pas inclure d’instruction de return',
        noReturnContainsYield: 'La fonction avec le type de retour déclaré « NoReturn » ne peut pas inclure d’instruction yield',
        noReturnReturnsNone: 'La fonction avec le type de retour déclaré "NoReturn" ne peut pas renvoyer "None"',
        nonDefaultAfterDefault: 'L’argument autre que l’argument par défaut suit l’argument par défaut',
        nonLocalInModule: 'Déclaration nonlocal non autorisée au niveau du module',
        nonLocalNoBinding: 'Aucune liaison pour le « {name} » nonlocal trouvé',
        nonLocalReassignment: '« {name} » est attribué avant la déclaration nonlocal',
        nonLocalRedefinition: '« {name} » a déjà été déclaré nonlocal',
        noneNotCallable: 'L’objet de type « None » ne peut pas être appelé',
        noneNotIterable: 'L’objet de type « None » ne peut pas être utilisé en tant que valeur itérable',
        noneNotSubscriptable: 'L’objet de type « None » n’est pas inscriptible',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'L’opérateur « {operator} » n’est pas pris en charge pour « None »',
        noneUnknownMember: '« {name} » n’est pas un attribut connu de « None »',
        notRequiredArgCount: 'Argument de type unique attendu après « NotRequired »',
        notRequiredNotInTypedDict: '« NotRequired » n’est pas autorisé dans ce contexte',
        objectNotCallable: 'L’objet de type « {type} » n’est pas appelant',
        obscuredClassDeclaration: 'La déclaration de classe « {name} » est masquée par une déclaration du même nom',
        obscuredFunctionDeclaration: 'La déclaration de fonction « {name} » est masquée par une déclaration du même nom',
        obscuredMethodDeclaration: 'La déclaration de méthode « {name} » est masquée par une déclaration du même nom',
        obscuredParameterDeclaration: 'La déclaration de paramètre « {name} » est masquée par une déclaration du même nom',
        obscuredTypeAliasDeclaration: 'La déclaration d’alias de type « {name} » est masquée par une déclaration du même nom',
        obscuredVariableDeclaration: 'La déclaration « {name} » est masquée par une déclaration du même nom',
        operatorLessOrGreaterDeprecated: 'L’opérateur « <> » n’est pas pris en charge dans Python 3 ; utilisez « != » à la place',
        optionalExtraArgs: 'Attendu un argument de type après « Optional »',
        orPatternIrrefutable: 'Modèle irréfutable autorisé uniquement en tant que dernier sous-modèle dans un modèle "ou"',
        orPatternMissingName: 'Tous les sous-modèles d’un modèle « or » doivent cibler les mêmes noms',
        overlappingKeywordArgs: 'Le dictionnaire tapé chevauche avec le mot clé paramètre : {names}',
        overlappingOverload: 'La surcharge {obscured} pour « {name} » ne sera jamais utilisée, car ses paramètres chevauchent la surcharge {obscuredBy}',
        overloadAbstractImplMismatch: 'Les surcharges doivent correspondre à l’état abstrait de l’implémentation',
        overloadAbstractMismatch: 'Les surcharges doivent toutes être abstraites ou non',
        overloadClassMethodInconsistent: 'Les surcharges pour « {name} » utilisent @classmethod de manière incohérente',
        overloadFinalInconsistencyImpl: 'La surcharge pour « {name} » est marquée @final, mais l’implémentation ne l’est pas',
        overloadFinalInconsistencyNoImpl: 'La surcharge {index} pour « {name} » est marquée @final mais la surcharge 1 n’est pas',
        overloadImplementationMismatch: 'L’implémentation surchargée n’est pas cohérente avec la signature de la surcharge {index}',
        overloadReturnTypeMismatch: 'La surcharge {prevIndex} pour « {name} » chevauche la surcharge {newIndex} et retourne un type incompatible',
        overloadStaticMethodInconsistent: 'Les surcharges pour « {name} » utilisent @staticmethod de manière incohérente',
        overloadWithoutImplementation: '« {name} » est marqué comme overload, mais aucune implémentation n’est fournie',
        overriddenMethodNotFound: 'La méthode « {name} » est marquée comme override, mais aucune méthode de base du même nom n’est présente',
        overrideDecoratorMissing: 'La méthode "{name}" n\'est pas marquée comme override mais remplace une méthode dans la classe "{className}"',
        paramAfterKwargsParam: 'Le paramètre ne peut pas suivre le paramètre "**"',
        paramAlreadyAssigned: 'Le paramètre « {name} » est déjà affecté',
        paramAnnotationMissing: 'L\'annotation de type est manquante pour le paramètre "{name}"',
        paramAssignmentMismatch: 'L\'expression de type "{sourceType}" ne peut pas être affectée au paramètre de type "{paramType}"',
        paramNameMissing: 'Aucun paramètre nommé « {name} »',
        paramSpecArgsKwargsDuplicate: 'Des arguments pour ParamSpec « {type} » ont déjà été fournis',
        paramSpecArgsKwargsUsage: 'Les attributs « args » et « kwargs » de ParamSpec doivent apparaître tous les deux dans une signature de fonction',
        paramSpecArgsMissing: 'Les arguments pour ParamSpec « {type} » sont manquants',
        paramSpecArgsUsage: 'L’attribut « args » de ParamSpec n’est valide que lorsqu’il est utilisé avec le paramètre *args',
        paramSpecAssignedName: 'ParamSpec doit être affecté à une variable nommée « {name} »',
        paramSpecContext: 'ParamSpec n’est pas autorisé dans ce contexte',
        paramSpecDefaultNotTuple: 'Points de suspension attendus, expression de tuple ou ParamSpec pour la valeur par défaut de ParamSpec',
        paramSpecFirstArg: 'Nom attendu de ParamSpec comme premier argument',
        paramSpecKwargsUsage: 'L’attribut « kwargs » de ParamSpec n’est valide que lorsqu’il est utilisé avec le paramètre **kwargs',
        paramSpecNotUsedByOuterScope: 'ParamSpec « {name} » n’a aucune signification dans ce contexte',
        paramSpecUnknownArg: 'ParamSpec ne prend pas en charge plus d\'un argument',
        paramSpecUnknownMember: '« {name} » n’est pas un attribut connu de ParamSpec',
        paramSpecUnknownParam: '"{name}" est un paramètre inconnu pour ParamSpec',
        paramTypeCovariant: 'Impossible d’utiliser la variable de type Covariant dans le type de paramètre',
        paramTypePartiallyUnknown: 'Le type du paramètre « {paramName} » est partiellement inconnu',
        paramTypeUnknown: 'Le type de paramètre « {paramName} » est inconnu',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Le modèle ne sera jamais mis en correspondance pour le type d’objet « {type} »',
        positionArgAfterNamedArg: 'L’argument positionnel ne peut pas apparaître après les arguments de mot clé',
        positionOnlyAfterArgs: 'Séparateur de paramètres de position seule non autorisé après le paramètre « * »',
        positionOnlyAfterKeywordOnly: 'Le paramètre « / » doit apparaître avant le paramètre « * »',
        positionOnlyAfterNon: 'Paramètre de position seule non autorisé après un paramètre qui n’est pas en position seule',
        positionOnlyFirstParam: 'Séparateur de paramètres de position seule non autorisé en tant que premier paramètre',
        positionOnlyIncompatible: 'Le séparateur de paramètres de position seule requiert Python 3.8 ou version ultérieure',
        privateImportFromPyTypedModule: '« {name} » n’est pas exporté à partir du module « {module} »',
        privateUsedOutsideOfClass: '« {name} » est privé et utilisé en dehors de la classe dans laquelle il est déclaré',
        privateUsedOutsideOfModule: '« {name} » est privé et utilisé en dehors du module dans lequel il est déclaré',
        propertyOverridden: '« {name} » remplace à tort la property du même nom dans la classe « {className} »',
        propertyStaticMethod: 'Méthodes statiques non autorisées pour la property getter, setter ou deleter',
        protectedUsedOutsideOfClass: '"{name}" est protégé et utilisé en dehors de la classe dans laquelle il est déclaré',
        protocolBaseClass: 'La classe de Protocol "{classType}" ne peut pas dériver de la classe non Protocol "{baseType}"',
        protocolBaseClassWithTypeArgs: 'Les arguments de type ne sont pas autorisés avec la classe Protocol lors de l\'utilisation de la syntaxe des paramètres de type',
        protocolIllegal: 'L’utilisation de « Protocole » nécessite Python 3.7 ou une version plus récente',
        protocolNotAllowed: '"Protocole" ne peut pas être utilisé dans ce contexte',
        protocolTypeArgMustBeTypeParam: 'L’argument de type pour « Protocol » doit être un paramètre de type',
        protocolUnsafeOverlap: 'La classe chevauche « {name} » de manière non sécurisée et peut produire une correspondance au moment de l’exécution',
        protocolVarianceContravariant: 'La variable de type "{variable}" utilisée dans le Protocol générique "{class}" doit être contravariante',
        protocolVarianceCovariant: 'La variable de type "{variable}" utilisée dans le Protocol générique "{class}" doit être covariante',
        protocolVarianceInvariant: 'La variable de type "{variable}" utilisée dans le Protocol générique "{class}" doit être invariante',
        pyrightCommentInvalidDiagnosticBoolValue: 'La directive de commentaire Pyright doit être suivie de « = » et d’une valeur true ou false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'La directive de commentaire Pyright doit être suivie de « = » et avoir la valeur true, false, error, warning, information ou none',
        pyrightCommentMissingDirective: 'Le commentaire Pyright doit être suivi d’une directive (basic ou strict) ou d’une règle de diagnostic',
        pyrightCommentNotOnOwnLine: 'Les commentaires Pyright utilisés pour contrôler les paramètres au niveau du fichier doivent apparaître sur leur propre ligne',
        pyrightCommentUnknownDiagnosticRule: '« {rule} » est une règle de diagnostic inconnue pour le commentaire pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: '« {value} » n’est pas valide pour le commentaire pyright ; true, false, error, warning, information ou none attendu',
        pyrightCommentUnknownDirective: '« {directive} » est une directive inconnue pour le commentaire pyright; « strict » ou « basic » attendu',
        readOnlyArgCount: 'Attendu un seul argument de type après "ReadOnly"',
        readOnlyNotInTypedDict: '« ReadOnly » n’est pas autorisé dans ce contexte',
        recursiveDefinition: 'Le type de "{name}" n\'a pas pu être déterminé car il fait référence à lui-même',
        relativeImportNotAllowed: 'Les importations relatives ne peuvent pas être utilisées avec le formulaire « import .a » ; utiliser « from . import a » à la place',
        requiredArgCount: 'Attendu un argument de type unique après "Required"',
        requiredNotInTypedDict: '« Required » n’est pas autorisé dans ce contexte',
        returnInAsyncGenerator: 'L\'instruction de retour avec valeur n\'est pas autorisée dans le générateur asynchrone',
        returnInExceptionGroup: '« return » n’est pas autorisé dans un bloc « except* »',
        returnMissing: 'La fonction avec le type de retour déclaré "{returnType}" doit renvoyer une valeur sur tous les chemins de code',
        returnOutsideFunction: '"return" ne peut être utilisé que dans une fonction',
        returnTypeContravariant: 'La variable de type contravariant ne peut pas être utilisée dans le type de retour',
        returnTypeMismatch: 'Le type « {exprType} » n’est pas assignable au type de retour « {returnType} »',
        returnTypePartiallyUnknown: 'Le type de retour « {returnType} » est partiellement inconnu',
        returnTypeUnknown: 'Le type de retour est inconnu',
        revealLocalsArgs: 'Aucun argument attendu pour l\'appel "reveal_locals"',
        revealLocalsNone: 'Aucun élément locals dans cette étendue',
        revealTypeArgs: 'Argument positionnel unique attendu pour l’appel « reveal_type »',
        revealTypeExpectedTextArg: 'L\'argument "expected_text" pour la fonction "reveal_type" doit être une valeur littérale str',
        revealTypeExpectedTextMismatch: 'Incompatibilité de texte de type ; « {expected} » attendu, mais a reçu « {received} »',
        revealTypeExpectedTypeMismatch: 'Incompatibilité de type; attendu "{expected}" mais reçu "{received}"',
        selfTypeContext: '« Self » n’est pas valide dans ce contexte',
        selfTypeMetaclass: '« Self » ne peut pas être utilisé dans une métaclasse (une sous-classe de « type »)',
        selfTypeWithTypedSelfOrCls: '« Self » ne peut pas être utilisé dans une fonction avec un paramètre « self » ou « cls » qui a une annotation de type autre que « Self »',
        setterGetterTypeMismatch: 'Le type valeur setter de property n’est pas assignable au type de retour getter',
        singleOverload: '« {name} » est marqué comme surcharge, mais des surcharges supplémentaires sont manquantes',
        slotsAttributeError: '"{name}" n\'est pas spécifié dans __slots__',
        slotsClassVarConflict: '"{name}" est en conflit avec la variable d\'instance déclarée dans __slots__',
        starPatternInAsPattern: 'Le modèle d’étoile ne peut pas être utilisé avec la cible « as »',
        starPatternInOrPattern: 'Le modèle d’étoile ne peut pas être supprimé dans d’autres modèles',
        starStarWildcardNotAllowed: '** ne peut pas être utilisé avec le caractère générique « _ »',
        staticClsSelfParam: 'Les méthodes statiques ne doivent pas prendre de paramètre « self » ou « cls »',
        stdlibModuleOverridden: '"{path}" remplace le module stdlib "{name}"',
        stringNonAsciiBytes: 'Caractère non-ASCII non autorisé dans le littéral de chaîne d\'octets',
        stringNotSubscriptable: 'L\'expression de chaîne ne peut pas être indexée dans une expression de type ; placez l\'expression entière entre guillemets',
        stringUnsupportedEscape: 'Séquence d\'échappement non prise en charge dans le littéral de chaîne',
        stringUnterminated: 'Le littéral de chaîne n’est pas spécifié',
        stubFileMissing: 'Fichier stub introuvable pour « {importName} »',
        stubUsesGetAttr: 'Le fichier stub de type est incomplet ; « __getattr__ » masque les erreurs de type pour le module',
        sublistParamsIncompatible: 'Les paramètres de Sublist ne sont pas pris en charge dans Python 3.x',
        superCallArgCount: 'Pas plus de deux arguments attendus pour l\'appel "super"',
        superCallFirstArg: 'Type de classe attendu en tant que premier argument de l’appel « super », mais « {type} » reçu',
        superCallSecondArg: 'Le deuxième argument de l’appel « super » doit être un objet ou une classe dérivé de « {type} »',
        superCallZeroArgForm: 'La forme sans argument d\'appel "super" n\'est valide que dans une méthode',
        superCallZeroArgFormStaticMethod: 'La forme à zéro argument de l’appel « super » n’est pas valide dans une méthode statique',
        symbolIsPossiblyUnbound: '« {name} » est peut-être indépendant',
        symbolIsUnbound: '« {name} » est indépendant',
        symbolIsUndefined: '« {name} » n’est pas défini',
        symbolOverridden: '« {name} » remplace le symbole du même nom dans la classe « {className} »',
        ternaryNotAllowed: 'Expression ternaire non autorisée dans l\'expression de type',
        totalOrderingMissingMethod: 'La classe doit définir « __lt__ », « __le__ », « __gt__ » ou « __ge__ » pour utiliser total_ordering',
        trailingCommaInFromImport: 'Virgule de fin non autorisée sans parenthèses adjacentes',
        tryWithoutExcept: 'L\'instruction try doit avoir au moins une clause except ou finally',
        tupleAssignmentMismatch: 'L\'expression avec le type "{type}" ne peut pas être assignée au tuple cible',
        tupleInAnnotation: 'Expression de tuple non autorisée dans l\'expression de type',
        tupleIndexOutOfRange: 'L’index {index} est hors limites pour le type {type}',
        typeAliasIllegalExpressionForm: 'Formulaire d’expression non valide pour la définition d’alias de type',
        typeAliasIsRecursiveDirect: 'L\'alias de type "{name}" ne peut pas s\'utiliser lui-même dans sa définition',
        typeAliasNotInModuleOrClass: 'Un TypeAlias ne peut être défini qu’au sein d’un module ou d’une étendue de classe',
        typeAliasRedeclared: '« {name} » est déclaré en tant que TypeAlias et ne peut être attribué qu’une seule fois',
        typeAliasStatementBadScope: 'Une instruction de type ne peut être utilisée que dans une étendue de module ou de classe',
        typeAliasStatementIllegal: 'L’instruction d’alias de type nécessite Python 3.12 ou version ultérieure',
        typeAliasTypeBaseClass: 'A type alias defined in a "type" statement cannot be used as a base class',
        typeAliasTypeMustBeAssigned: 'TypeAliasType doit être affecté à une variable portant le même nom que l\'alias de type',
        typeAliasTypeNameArg: 'Le premier argument de TypeAliasType doit être un littéral de chaîne représentant le nom de l\'alias de type',
        typeAliasTypeNameMismatch: 'Le nom de l’alias de type doit correspondre au nom de la variable à laquelle il est affecté',
        typeAliasTypeParamInvalid: 'La liste de paramètres de type doit être un tuple contenant uniquement TypeVar, TypeVarTuple ou ParamSpec',
        typeAnnotationCall: 'Expression d\'appel non autorisée dans l\'expression de type',
        typeAnnotationVariable: 'Variable non autorisée dans l\'expression de type',
        typeAnnotationWithCallable: 'L\'argument de type pour "type" doit être une classe ; les callables ne sont pas pris en charge',
        typeArgListExpected: 'ParamSpec, ellipse ou liste de types attendue',
        typeArgListNotAllowed: 'Expression de liste non autorisée pour cet argument de type',
        typeArgsExpectingNone: 'Aucun argument de type attendu pour la classe « {name} »',
        typeArgsMismatchOne: 'Argument de type attendu mais {received} reçu',
        typeArgsMissingForAlias: 'Arguments de type attendus pour l’alias de type générique « {name} »',
        typeArgsMissingForClass: 'Arguments de type attendus pour la classe générique "{name}"',
        typeArgsTooFew: 'Trop peu d’arguments de type fournis pour « {name} » ; {expected} attendu, mais {received} reçu',
        typeArgsTooMany: 'Trop d\'arguments de type fournis pour "{name}" ; attendu {expected} mais reçu {received}',
        typeAssignmentMismatch: 'Le type « {sourceType} » n’est pas assignable au type déclaré « {destType} »',
        typeAssignmentMismatchWildcard: 'Le symbole d’importation « {name} » a le type « {sourceType} », qui n’est pas assignable au type déclaré « {destType} »',
        typeCallNotAllowed: 'l\'appel type() ne doit pas être utilisé dans une expression de type',
        typeCheckOnly: '"{name}" est marqué comme @type_check_only et ne peut être utilisé que dans les annotations de type',
        typeCommentDeprecated: 'L’utilisation de commentaires de type est déconseillée ; utiliser l’annotation de type à la place',
        typeExpectedClass: 'Classe attendue mais « {type} » reçu',
        typeFormArgs: '« TypeForm » accepte un seul argument positionnel',
        typeGuardArgCount: 'Argument de type unique attendu après « TypeGuard » ou « TypeIs »',
        typeGuardParamCount: 'Les méthodes et fonctions de protection de type définies par l’utilisateur doivent avoir au moins un paramètre d’entrée',
        typeIsReturnType: 'Le type de retour des TypeIs (« {returnType} ») n’est pas cohérent avec le type de paramètre de valeur (« {type} »)',
        typeNotAwaitable: '« {type} » n’est pas awaitable',
        typeNotIntantiable: '« {type} » ne peut pas être instancié',
        typeNotIterable: '« {type} » n’est pas itérable',
        typeNotSpecializable: 'Impossible de spécialiser le type "{type}"',
        typeNotSubscriptable: 'L’objet de type « {type} » n’est pas sous-scriptible',
        typeNotSupportBinaryOperator: 'Opérateur "{operator}" non pris en charge pour les types "{leftType}" et "{rightType}"',
        typeNotSupportBinaryOperatorBidirectional: 'L\'opérateur "{operator}" n\'est pas pris en charge pour les types "{leftType}" et "{rightType}" lorsque le type attendu est "{expectedType}"',
        typeNotSupportUnaryOperator: 'L\'opérateur "{operator}" n\'est pas pris en charge pour le type "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'L’opérateur « {operator} » n’est pas pris en charge pour le type « {type} » quand le type attendu est « {expectedType} »',
        typeNotUsableWith: 'L’objet de type "{type}" ne peut pas être utilisé avec « with », car il n’implémente pas {method}',
        typeParameterBoundNotAllowed: 'La limite ou la contrainte ne peut pas être utilisée avec un paramètre de type variadique ou ParamSpec',
        typeParameterConstraintTuple: 'La contrainte de paramètre de type doit être un tuple de plusieurs types',
        typeParameterExistingTypeParameter: 'Le paramètre de type « {name} » est déjà utilisé',
        typeParameterNotDeclared: 'Le paramètre de type « {name} » n’est pas inclus dans la liste des paramètres de type pour « {container} »',
        typeParametersMissing: 'Au moins un paramètre de type doit être spécifié',
        typePartiallyUnknown: 'Le type de « {name} » est partiellement inconnu',
        typeUnknown: 'Le type de « {name} » est inconnu',
        typeVarAssignedName: 'TypeVar doit être affecté à une variable nommée « {name} »',
        typeVarAssignmentMismatch: 'Le type "{type}" ne peut pas être affecté à la variable de type "{name}"',
        typeVarBoundAndConstrained: 'TypeVar ne peut pas être à la fois lié et contraint',
        typeVarBoundGeneric: 'Le type lié TypeVar ne peut pas être générique',
        typeVarConstraintGeneric: 'Le type de contrainte TypeVar ne peut pas être générique',
        typeVarDefaultBoundMismatch: 'Le type par défaut TypeVar doit être un sous-type du type lié',
        typeVarDefaultConstraintMismatch: 'Le type par défaut TypeVar doit être l\'un des types contraints',
        typeVarDefaultIllegal: 'Les types de variables de type par défaut nécessitent Python 3.13 ou une version plus récente',
        typeVarDefaultInvalidTypeVar: 'Le paramètre de type « {name} » a un type par défaut qui fait référence à une ou plusieurs variables de type hors de portée',
        typeVarFirstArg: 'Nom attendu de TypeVar comme premier argument',
        typeVarInvalidForMemberVariable: 'Le type d’attribut ne peut pas utiliser de variable de type « {name} » étendue à une méthode locale',
        typeVarNoMember: 'TypeVar « {type} » n’a aucun attribut « {name} »',
        typeVarNotSubscriptable: 'TypeVar « {type} » n’est pas subscriptible',
        typeVarNotUsedByOuterScope: 'La variable de type « {name} » n’a aucune signification dans ce contexte',
        typeVarPossiblyUnsolvable: 'La variable de type "{name}" peut rester non résolue si l\'appelant ne fournit aucun argument pour le paramètre "{param}"',
        typeVarSingleConstraint: 'TypeVar doit avoir au moins deux types contraints',
        typeVarTupleConstraints: 'TypeVarTuple ne peut pas avoir de contraintes de valeur',
        typeVarTupleContext: 'TypeVarTuple n’est pas autorisé dans ce contexte',
        typeVarTupleDefaultNotUnpacked: 'Le type par défaut TypeVarTuple doit être un tuple décompressé ou TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'L\'opérateur Unpack est requis pour la valeur TypeVarTuple',
        typeVarTupleUnknownParam: '« {name} » est un paramètre inconnu de TypeVarTuple',
        typeVarUnknownParam: '"{name}" est un paramètre inconnu pour TypeVar',
        typeVarUsedByOuterScope: 'TypeVar "{name}" est déjà utilisé par une portée externe',
        typeVarUsedOnlyOnce: 'TypeVar « {name} » n’apparaît qu’une seule fois dans la signature de fonction générique',
        typeVarVariance: 'TypeVar ne peut pas être à la fois covariant et contravariant',
        typeVarWithDefaultFollowsVariadic: 'TypeVar « {typeVarName} » a une valeur par défaut et ne peut pas suivre TypeVarTuple « {variadicName} »',
        typeVarWithoutDefault: '"{name}" ne peut pas apparaître après "{other}" dans la liste des paramètres de type car il n\'a pas de type par défaut',
        typeVarsNotInGenericOrProtocol: 'Generic[] ou Protocol[] doit inclure toutes les variables de type',
        typedDictAccess: 'Impossible d’accéder à l’élément dans TypedDict',
        typedDictAssignedName: 'TypedDict doit être affecté à une variable nommée « {name} »',
        typedDictBadVar: 'Les classes TypedDict ne peuvent contenir que des annotations de type',
        typedDictBaseClass: 'Toutes les classes de base pour les classes TypedDict doivent également être des classes TypedDict',
        typedDictBoolParam: 'Paramètre « {name} » attendu avec la valeur True ou False',
        typedDictClosedExtras: 'La classe de base « {name} » est un TypedDict closed, les éléments supplémentaires doivent être de type « {type} »',
        typedDictClosedNoExtras: 'La classe de base « {name} » est un TypedDict closed, les éléments supplémentaires ne sont pas autorisés',
        typedDictDelete: 'Impossible de supprimer l’élément dans TypedDict',
        typedDictEmptyName: 'Les noms dans un TypedDict ne peuvent pas être vides',
        typedDictEntryName: 'Littéral de chaîne attendu pour le nom d’entrée du dictionnaire',
        typedDictEntryUnique: 'Les noms dans un dictionnaire doivent être uniques',
        typedDictExtraArgs: 'Arguments TypedDict supplémentaires non pris en charge',
        typedDictExtraItemsClosed: 'Un TypedDict ne peut pas être closed s’il prend en charge les éléments supplémentaires',
        typedDictFieldNotRequiredRedefinition: 'L’élément TypedDict « {name} » ne peut pas être redéfini comme étant NotRequired',
        typedDictFieldReadOnlyRedefinition: 'L’élément TypedDict « {name} » ne peut pas être redéfini comme état En ReadOnly',
        typedDictFieldRequiredRedefinition: 'L’élément TypedDict « {name} » ne peut pas être redéfini comme étant Required',
        typedDictFirstArg: 'Nom de classe TypedDict attendu comme premier argument',
        typedDictInClassPattern: 'La classe TypedDict n\'est pas autorisée dans le modèle de classe',
        typedDictInitsubclassParameter: 'TypedDict ne prend pas en charge __init_subclass__ paramètre « {name} »',
        typedDictNotAllowed: '"TypedDict" ne peut pas être utilisé dans ce contexte',
        typedDictSecondArgDict: 'Paramètre de mot clé ou de dict attendu en tant que deuxième paramètre',
        typedDictSecondArgDictEntry: 'Entrée de dictionnaire simple attendue',
        typedDictSet: 'Impossible d\'attribuer l\'élément dans TypedDict',
        unaccessedClass: 'La classe "{name}" n\'est pas accessible',
        unaccessedFunction: 'La fonction « {name} » n’est pas accessible',
        unaccessedImport: 'L’importation « {name} » n’est pas accessible',
        unaccessedSymbol: '« {name} » n’est pas accessible',
        unaccessedVariable: 'La variable « {name} » n’est pas accessible',
        unannotatedFunctionSkipped: 'L\'analyse de la fonction "{name}" est ignorée car elle n\'est pas annotée',
        unaryOperationNotAllowed: 'L\'opérateur unaire n\'est pas autorisé dans l\'expression de type',
        unexpectedAsyncToken: '« def », « with » ou « for » attendu pour suivre « async »',
        unexpectedExprToken: 'Jeton inattendu à la fin de l’expression',
        unexpectedIndent: 'Retrait inattendu',
        unexpectedUnindent: 'Unindent non attendu',
        unhashableDictKey: 'La clé du dictionnaire doit être hachable',
        unhashableSetEntry: 'L’entrée set doit être hachable',
        uninitializedAbstractVariables: 'Les variables définies dans la classe de base abstraite ne sont pas initialisées dans la classe finale « {classType} »',
        uninitializedInstanceVariable: 'La variable d’instance « {name} » n’est pas initialisée dans le corps de la classe ou dans la méthode __init__',
        unionForwardReferenceNotAllowed: 'La syntaxe Union ne peut pas être utilisée avec l’opérande de chaîne ; utiliser des guillemets autour de l’expression entière',
        unionSyntaxIllegal: 'Une autre syntaxe pour les unions nécessite Python 3.10 ou une version plus récente',
        unionTypeArgCount: 'L’Union requiert au moins deux arguments de type',
        unionUnpackedTuple: 'Union ne peut pas inclure un tuple décompressé',
        unionUnpackedTypeVarTuple: 'Union ne peut pas inclure un TypeVarTuple décompressé',
        unnecessaryCast: 'Appel "cast" inutile ; le type est déjà "{type}"',
        unnecessaryIsInstanceAlways: 'Appel d’isinstance inutile ; « {testType} » est toujours une instance de « {classType} »',
        unnecessaryIsInstanceNever: 'Appel d’isinstance inutile; « {testType} » n est jamais une instance de « {classType} »',
        unnecessaryIsSubclassAlways: 'Appel issubclass inutile ; "{testType}" est toujours une sous-classe de "{classType}"',
        unnecessaryIsSubclassNever: 'Appel issubclass inutile; « {testType} » est toujours une sous-classe de « {classType} »',
        unnecessaryPyrightIgnore: 'Commentaire "# pyright: ignore" inutile',
        unnecessaryPyrightIgnoreRule: 'Règle inutile « # pyright: ignore » : « {name} »',
        unnecessaryTypeIgnore: 'Commentaire "# type: ignore" inutile',
        unpackArgCount: 'Attendu un seul argument de type après "Unpack"',
        unpackExpectedTypeVarTuple: 'TypeVarTuple ou tuple attendu en tant qu’argument de type pour Unpack',
        unpackExpectedTypedDict: 'Argument de type TypedDict attendu pour Unpack',
        unpackIllegalInComprehension: 'Opération de décompression non autorisée dans la compréhension',
        unpackInAnnotation: 'L\'opérateur de déballage n\'est pas autorisé dans l\'expression de type',
        unpackInDict: 'Opération de décompression non autorisée dans les dictionnaires',
        unpackInSet: 'Opérateur de déballage non autorisé dans un set',
        unpackNotAllowed: 'Le Unpack n’est pas autorisé dans ce contexte',
        unpackOperatorNotAllowed: 'L’opération de décompression n’est pas autorisée dans ce contexte',
        unpackTuplesIllegal: 'Opération de décompression non autorisée dans les tuples avant Python 3.8',
        unpackedArgInTypeArgument: 'Les arguments décompressés ne peuvent pas être utilisés dans ce contexte',
        unpackedArgWithVariadicParam: 'L\'argument décompressé ne peut pas être utilisé pour le paramètre TypeVarTuple',
        unpackedDictArgumentNotMapping: 'L’expression d’argument après ** doit être un mappage avec un type de clé « str »',
        unpackedDictSubscriptIllegal: 'L’opérateur de décompression de dictionnaire dans l’indice n’est pas autorisé',
        unpackedSubscriptIllegal: 'L’opérateur de décompression en indice requiert Python 3.11 ou version ultérieure',
        unpackedTypeVarTupleExpected: 'TypeVarTuple décompressé attendu ; utiliser Unpack[{name1}] ou *{name2}',
        unpackedTypedDictArgument: 'Impossible de faire correspondre l’argument TypedDict décompressé aux paramètres',
        unreachableCode: 'Le code est inaccessible',
        unreachableCodeType: 'L’analyse de type indique que le code est inaccessible',
        unreachableExcept: 'La clause Except est inaccessible, car l’exception est déjà gérée',
        unsupportedDunderAllOperation: 'L’opération sur « __all__ » n’est pas prise en charge. Par conséquent, la liste de symboles exportée peut être incorrecte',
        unusedCallResult: 'Le résultat de l\'expression d\'appel est de type "{type}" et n\'est pas utilisé ; affecter à la variable "_" si c\'est intentionnel',
        unusedCoroutine: 'Le résultat de l’appel de fonction asynchrone n’est pas utilisé ; utiliser « await » ou affecter le résultat à la variable',
        unusedExpression: 'La valeur de l\'expression n\'est pas utilisée',
        varAnnotationIllegal: 'Les annotations de type pour les variables nécessitent Python 3.6 ou une version ultérieure ; utiliser le commentaire de type pour la compatibilité avec les versions précédentes',
        variableFinalOverride: 'La variable « {name} » est marquée comme Final et remplace la variable non-Final du même nom dans la classe « {className} »',
        variadicTypeArgsTooMany: 'La liste d’arguments de type peut avoir au plus un TypeVarTuple ou tuple décompressé',
        variadicTypeParamTooManyAlias: 'L’alias de type peut avoir au plus un paramètre de type TypeVarTuple, mais a reçu plusieurs ({names})',
        variadicTypeParamTooManyClass: 'La classe générique peut avoir au plus un paramètre de type TypeVarTuple, mais en a reçu plusieurs ({names})',
        walrusIllegal: 'L’opérateur « := » nécessite Python 3.8 ou version ultérieure',
        walrusNotAllowed: 'L’opérateur « := » n’est pas autorisé dans ce contexte sans parenthèses adjacentes',
        wildcardInFunction: 'import de caractères génériques non autorisée dans une classe ou une fonction',
        wildcardLibraryImport: 'import de caractères génériques à partir d’une bibliothèque non autorisée',
        wildcardPatternTypePartiallyUnknown: 'Le type capturé par le modèle générique est partiellement inconnu',
        wildcardPatternTypeUnknown: 'Le type capturé par le modèle générique est inconnu',
        yieldFromIllegal: 'L’utilisation de « yield from » nécessite Python 3.3 ou version ultérieure',
        yieldFromOutsideAsync: '« yield from » non autorisé dans une fonction asynchrone',
        yieldOutsideFunction: '« yield » non autorisé en dehors d’une fonction ou d’un lambda',
        yieldWithinComprehension: '« yield » n’est pas autorisé dans une compréhension de liste',
        zeroCaseStatementsFound: 'L’instruction de Match doit inclure au moins une instruction case',
        zeroLengthTupleNotAllowed: 'Le tuple de longueur nulle n’est pas autorisé dans ce contexte'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Impossible d’utiliser le formulaire spécial « Annotated » avec les vérifications d’instance et de classe',
        argParam: 'L’argument correspond au paramètre « {paramName} »',
        argParamFunction: 'L’argument correspond au paramètre « {paramName} » dans la fonction « {functionName} »',
        argsParamMissing: 'Le paramètre "*{paramName}" n\'a pas de paramètre correspondant',
        argsPositionOnly: 'Non-concordance des paramètres de position uniquement ; attendu {expected} mais reçu {received}',
        argumentType: 'Le type d’argument est « {type} »',
        argumentTypes: 'Types d\'argument : ({types})',
        assignToNone: 'Le type n’est pas assignable à « None »',
        asyncHelp: 'Vouliez-vous dire « async with » ?',
        baseClassIncompatible: 'La classe de base « {baseClass} » n’est pas compatible avec le type « {type} »',
        baseClassIncompatibleSubclass: 'La classe de base « {baseClass} » dérive de « {subclass} » qui est incompatible avec le type « {type} »',
        baseClassOverriddenType: 'La classe de base « {baseClass} » fournit le type « {type} », qui est remplacé',
        baseClassOverridesType: 'La classe de base "{baseClass}" remplace le type "{type}"',
        bytesTypePromotions: 'Définir disableBytesTypePromotions sur false pour activer le comportement de promotion de type pour « bytearray » et « memoryview »',
        conditionalRequiresBool: 'La méthode __bool__ pour le type « {operandType} » retourne le type « {boolReturnType} » plutôt que « bool »',
        dataClassFieldLocation: 'Déclaration de champ',
        dataClassFrozen: '« {name} » est figé',
        dataProtocolUnsupported: '« {name} » est un protocole de données',
        descriptorAccessBindingFailed: 'Échec de la liaison du « {name} » de méthode pour la classe de descripteur « {className} »',
        descriptorAccessCallFailed: 'Échec de l’appel du « {name} » de méthode pour la classe de descripteur « {className} »',
        finalMethod: 'Méthode Final',
        functionParamDefaultMissing: 'Le paramètre "{name}" n\'a pas d\'argument par défaut',
        functionParamName: 'Incompatibilité de nom de paramètre : « {destName} » et « {srcName} »',
        functionParamPositionOnly: 'Non-correspondance des paramètres position uniquement ; le paramètre « {name} » n’est pas en position seule',
        functionReturnTypeMismatch: 'Le type de retour de fonction "{sourceType}" est incompatible avec le type "{destType}"',
        functionTooFewParams: 'La fonction accepte trop peu de paramètres positionnels ; {expected} attendu, mais {received} reçu',
        functionTooManyParams: 'La fonction accepte trop de paramètres positionnels ; {expected} attendu, mais {received} reçu',
        genericClassNotAllowed: 'Type générique avec des arguments de type non autorisé pour les vérifications d’instance ou de classe',
        incompatibleDeleter: 'La méthode du deleter de property n’est pas compatible',
        incompatibleGetter: 'La méthode de getter de property est incompatible',
        incompatibleSetter: 'La méthode setter de property n’est pas compatible',
        initMethodLocation: 'La méthode __init__ est définie dans la classe « {type} »',
        initMethodSignature: 'La signature de __init__ est « {type} »',
        initSubclassLocation: 'La méthode __init_subclass__ est définie dans la classe « {name} »',
        invariantSuggestionDict: 'Envisagez de passer de « dict » à « Mapping », qui est covariant dans le type valeur',
        invariantSuggestionList: 'Envisagez de passer de « list » à « Sequence » qui est covariant',
        invariantSuggestionSet: 'Pensez à passer de "set" à "Container" qui est covariant',
        isinstanceClassNotSupported: '« {type} » n’est pas pris en charge pour les vérifications d’instance et de classe',
        keyNotRequired: '"{name}" n\'est pas une clé requise dans "{type}", donc l\'accès peut entraîner une exception d\'exécution',
        keyReadOnly: '« {name} » est une clé en lecture seule dans « {type} »',
        keyRequiredDeleted: '« {name} » est une clé obligatoire et ne peut pas être supprimée',
        keyUndefined: '« {name} » n’est pas une clé définie dans « {type} »',
        kwargsParamMissing: 'Le paramètre "**{paramName}" n\'a pas de paramètre correspondant',
        listAssignmentMismatch: 'Le type « {type} » n’est pas compatible avec la liste cible',
        literalAssignmentMismatch: '« {sourceType} » n’est pas assignable au type « {destType} »',
        matchIsNotExhaustiveHint: 'Si la gestion exhaustive n’est pas prévue, ajoutez « case _: pass »',
        matchIsNotExhaustiveType: 'Type non géré : « {type} »',
        memberAssignment: 'L\'expression de type « {type} » ne peut pas être attribuée à l’attribut « {name} » de la classe « {classType} »',
        memberIsAbstract: '« {type}.{name} » n’est pas implémenté',
        memberIsAbstractMore: 'et {count} autres...',
        memberIsClassVarInProtocol: '« {name} » est défini en tant que ClassVar dans le protocole',
        memberIsInitVar: '« {name} » est un champ init-only',
        memberIsInvariant: '« {name} » est invariant, car il est mutable',
        memberIsNotClassVarInClass: '« {name} » doit être défini en tant que ClassVar pour être compatible avec le protocole',
        memberIsNotClassVarInProtocol: '« {name} » n’est pas défini en tant que ClassVar dans le protocole',
        memberIsNotReadOnlyInProtocol: '« {name} » n’est pas en lecture seule dans le protocole',
        memberIsReadOnlyInProtocol: '« {name} » est en lecture seule dans le protocole',
        memberIsWritableInProtocol: '« {name} » est accessible en écriture dans le protocole',
        memberSetClassVar: 'L’attribut « {name} » ne peut pas être attribué via une instance de classe car il s’agit d’une ClassVar',
        memberTypeMismatch: '« {name} » est un type incompatible',
        memberUnknown: 'L’attribut « {name} » est inconnu',
        metaclassConflict: 'La métaclasse « {metaclass1} » est en conflit avec « {metaclass2} »',
        missingDeleter: 'La méthode de deleter de property est manquante',
        missingGetter: 'La méthode getter de property est manquante',
        missingSetter: 'setter de définition de property est manquante',
        namedParamMissingInDest: 'Paramètre supplémentaire « {name} »',
        namedParamMissingInSource: 'Paramètre de mot clé manquant « {name} »',
        namedParamTypeMismatch: 'Le paramètre de mot clé « {name} » de type « {sourceType} » est incompatible avec le type « {destType} »',
        namedTupleNotAllowed: 'NamedTuple ne peut pas être utilisé pour les vérifications d’instance ou de classe',
        newMethodLocation: 'La méthode __new__ est définie dans la classe « {type} »',
        newMethodSignature: 'La signature de __new__ est « {type} »',
        newTypeClassNotAllowed: 'La classe créée avec NewType ne peut pas être utilisée avec des vérifications de instance et de classe',
        noOverloadAssignable: 'Aucune fonction surchargée ne correspond au type « {type} »',
        noneNotAllowed: 'None ne peut être utilisé pour les vérifications de instance ou de classe',
        orPatternMissingName: 'Noms manquants : {name}',
        overloadIndex: 'La surcharge {index} est la correspondance la plus proche',
        overloadNotAssignable: 'Une ou plusieurs surcharges de « {name} » ne sont pas assignables',
        overloadSignature: 'La signature de surcharge est définie ici',
        overriddenMethod: 'Méthode substituée',
        overriddenSymbol: 'Symbole substitué',
        overrideInvariantMismatch: 'Le type de remplacement "{overrideType}" n\'est pas le même que le type de base "{baseType}"',
        overrideIsInvariant: 'La variable est mutable donc son type est invariant',
        overrideNoOverloadMatches: 'Aucune signature de surcharge dans le remplacement n’est compatible avec la méthode de base',
        overrideNotClassMethod: 'La méthode de base est déclarée en tant que classmethod, mais la substitution n’est pas',
        overrideNotInstanceMethod: 'La méthode de base est déclarée en tant que méthode d\'instance mais la substitution n\'est pas',
        overrideNotStaticMethod: 'La méthode de base est déclarée comme staticmethod, mais la substitution n’est pas',
        overrideOverloadNoMatch: 'Le remplacement ne gère pas toutes les surcharges de la méthode de base',
        overrideOverloadOrder: 'Les surcharges pour la méthode de remplacement doivent être dans le même ordre que la méthode de base',
        overrideParamKeywordNoDefault: 'Non-concordance du paramètre de mot-clé "{name}" : le paramètre de base a une valeur d\'argument par défaut, le paramètre de remplacement n\'en a pas',
        overrideParamKeywordType: 'Incompatibilité de type du paramètre de mot clé "{name}" : le paramètre de base est de type "{baseType}", le paramètre de remplacement est de type "{overrideType}"',
        overrideParamName: 'Incompatibilité de nom de paramètre {index} : le paramètre de base est nommé "{baseName}", le paramètre de remplacement est nommé "{overrideName}"',
        overrideParamNameExtra: 'Le paramètre « {name} » est manquant dans la base',
        overrideParamNameMissing: 'Le paramètre "{name}" est manquant dans le remplacement',
        overrideParamNamePositionOnly: 'Incompatibilité du paramètre {index} : le paramètre de base "{baseName}" est un paramètre de mot-clé, le paramètre de remplacement est uniquement de position',
        overrideParamNoDefault: 'Non-concordance du paramètre {index} : le paramètre de base a une valeur d\'argument par défaut, le paramètre de remplacement n\'en a pas',
        overrideParamType: 'Incompatibilité de type de paramètre {index} : le paramètre de base est de type "{baseType}", le paramètre de remplacement est de type "{overrideType}"',
        overridePositionalParamCount: 'Non-concordance du nombre de paramètres positionnels ; la méthode de base a {baseCount}, mais la substitution a {overrideCount}',
        overrideReturnType: 'Incompatibilité de type de retour : la méthode de base retourne le type « {baseType} », la substitution retourne le type « {overrideType} »',
        overrideType: 'La classe de base définit le type comme « {type} »',
        paramAssignment: 'Paramètre {index} : le type « {sourceType} » est incompatible avec le type « {destType} »',
        paramSpecMissingInOverride: 'Les paramètres ParamSpec sont manquants dans la méthode de remplacement',
        paramType: 'Le type de paramètre est « {paramType} »',
        privateImportFromPyTypedSource: 'Importer à partir de « {module} » à la place',
        propertyAccessFromProtocolClass: 'Une propriété définie dans une classe de protocole n\'est pas accessible en tant que variable de classe',
        propertyMethodIncompatible: 'La méthode de property « {name} » n’est pas compatible',
        propertyMethodMissing: 'La méthode de property « {name} » est manquante dans le remplacement',
        propertyMissingDeleter: 'La property « {name} » n’a pas de deleter défini',
        propertyMissingSetter: 'La property « {name} » n’a pas de méthode setter définie',
        protocolIncompatible: '"{sourceType}" est incompatible avec le protocole "{destType}"',
        protocolMemberMissing: '« {name} » n’est pas présent',
        protocolRequiresRuntimeCheckable: 'La classe de Protocol doit être @runtime_checkable à utiliser avec des vérifications d’instance et de classe',
        protocolSourceIsNotConcrete: '"{sourceType}" n\'est pas un type de classe concret et ne peut pas être affecté au type "{destType}"',
        protocolUnsafeOverlap: 'Les attributs de « {name} » ont les mêmes noms que le protocole',
        pyrightCommentIgnoreTip: 'Utilisez « # pyright: ignore[<diagnostic rules>] » pour supprimer les diagnostics pour une seule ligne',
        readOnlyAttribute: 'L’attribut « {name} » est en lecture seule',
        seeClassDeclaration: 'Voir la déclaration de classe',
        seeDeclaration: 'Voir la déclaration',
        seeFunctionDeclaration: 'Voir la déclaration de fonction',
        seeMethodDeclaration: 'Voir la déclaration de méthode',
        seeParameterDeclaration: 'Voir la déclaration des paramètres',
        seeTypeAliasDeclaration: 'Voir la déclaration d’alias de type',
        seeVariableDeclaration: 'Voir déclaration de variable',
        tupleAssignmentMismatch: 'Le type "{type}" est incompatible avec le tuple cible',
        tupleEntryTypeMismatch: 'Le type de l’entrée de tuple {entry} est incorrect',
        tupleSizeIndeterminateSrc: 'Incompatibilité de taille de tuple ; attendu {expected} mais reçu pour une durée indéterminée',
        tupleSizeIndeterminateSrcDest: 'Incompatibilité de taille de tuple : attente de {expected} ou plus, mais réception indéterminée',
        tupleSizeMismatch: 'Incompatibilité de taille de tuple ; attendu {expected} mais reçu {received}',
        tupleSizeMismatchIndeterminateDest: 'Incompatibilité de taille de tuple : attente de {expected} ou plus, mais réception de {received}',
        typeAliasInstanceCheck: 'L’alias de type créé avec l’instruction « type » ne peut pas être utilisé avec des vérifications d’instance et de classe',
        typeAssignmentMismatch: 'Le type « {sourceType} » n’est pas assignable au type « {destType} »',
        typeBound: 'Le type « {sourceType} » n’est pas assignable à la limite supérieure « {destType} » pour la variable de type « {name} »',
        typeConstrainedTypeVar: 'Le type « {type} » n’est pas assignable à la variable de type contrainte « {name} »',
        typeIncompatible: '« {sourceType} » n’est pas assignable à « {destType} »',
        typeNotClass: '« {type} » n’est pas une classe',
        typeNotStringLiteral: '"{type}" n\'est pas un littéral de chaîne',
        typeOfSymbol: 'Le type de "{name}" est "{type}"',
        typeParamSpec: 'Le type « {type} » n’est pas compatible avec ParamSpec « {name} »',
        typeUnsupported: 'Le type « {type} » n’est pas pris en charge',
        typeVarDefaultOutOfScope: 'La variable de type « {name} » n’est pas dans l’étendue',
        typeVarIsContravariant: 'Le paramètre de type "{name}" est contravariant, mais "{sourceType}" n\'est pas un supertype de "{destType}"',
        typeVarIsCovariant: 'Le paramètre de type "{name}" est covariant, mais "{sourceType}" n\'est pas un sous-type de "{destType}"',
        typeVarIsInvariant: 'Le paramètre de type "{name}" est invariant, mais "{sourceType}" n\'est pas le même que "{destType}"',
        typeVarNotAllowed: 'TypeVar non autorisé pour les vérifications d’instance ou de classe',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple ne peut pas être lié à un tuple de longueur inconnue',
        typeVarUnnecessarySuggestion: 'Utilisez plutôt {type}',
        typeVarUnsolvableRemedy: 'Fournir une surcharge qui spécifie le type de retour lorsque l’argument n’est pas fourni',
        typeVarsMissing: 'Variables de type manquantes : {names}',
        typedDictBaseClass: 'La classe "{type}" n\'est pas un TypedDict',
        typedDictClassNotAllowed: 'Classe TypedDict non autorisée pour les vérifications d’instance ou de classe',
        typedDictClosedExtraNotAllowed: 'Impossible d’ajouter l’élément « {name} »',
        typedDictClosedExtraTypeMismatch: 'Impossible d’ajouter l’élément « {name} » avec le type « {type} »',
        typedDictClosedFieldNotRequired: 'Impossible d’ajouter l’élément « {name} », car il doit être NotRequired',
        typedDictExtraFieldNotAllowed: '« {name} » n’est pas présent dans « {type} »',
        typedDictExtraFieldTypeMismatch: 'Le type de « {name} » est incompatible avec le type « extra_items » dans « {type} »',
        typedDictFieldMissing: '« {name} » est manquant dans « {type} »',
        typedDictFieldNotReadOnly: '« {name} » n’est pas en lecture seule dans « {type} »',
        typedDictFieldNotRequired: '« {name} » n’est pas obligatoire dans « {type} »',
        typedDictFieldRequired: '« {name} » est obligatoire dans « {type} »',
        typedDictFieldTypeMismatch: 'Le type « {type} » n\'est pas attribuable à l’élément « {name} »',
        typedDictFieldUndefined: '« {name} » est un élément non défini dans le type « {type} »',
        typedDictFinalMismatch: '« {sourceType} » n’est pas compatible avec « {destType} » en raison d’une incompatibilité de @final',
        typedDictKeyAccess: 'Utilisez [« {name} »] pour référencer l’élément dans TypedDict',
        typedDictNotAllowed: 'TypedDict ne peut pas être utilisé pour les vérifications d’instance ou de classe',
        unhashableType: 'Le type "{type}" n\'est pas hachable',
        uninitializedAbstractVariable: 'La variable d’instance « {name} » est définie dans la classe de base abstraite « {classType} » mais n’est pas initialisée',
        unreachableExcept: '« {exceptionType} » est une sous-classe de « {parentType} »',
        useDictInstead: 'Utilisez Dict[T1, T2] pour indiquer un type de dictionnaire',
        useListInstead: 'Utilisez List[T] pour indiquer un type de liste ou Union[T1, T2] pour indiquer un type d\'union',
        useTupleInstead: 'Utiliser tuple[T1, ..., Tn] pour indiquer un type de tuple ou Union[T1, T2] pour indiquer un type d’union',
        useTypeInstead: 'Utiliser le Type[T] à la place',
        varianceMismatchForClass: 'La variance de l\'argument de type "{typeVarName}" est incompatible avec la classe de base "{className}"',
        varianceMismatchForTypeAlias: 'La variance de l\'argument de type "{typeVarName}" est incompatible avec "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'L’énumération des fichiers sources de l’espace de travail prend beaucoup de temps. Envisagez plutôt d’ouvrir un sous-dossier. [En savoir plus](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  51667: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Crea Stub di tipo',
        createTypeStubFor: 'Crea Stub di tipo per "{moduleName}"',
        executingCommand: 'Esecuzione del comando',
        filesToAnalyzeCount: '{count} file da analizzare',
        filesToAnalyzeOne: '1 file da analizzare',
        findingReferences: 'Ricerca dei riferimenti in corso',
        organizeImports: 'Organizza importazioni',
        renameShadowedFile: 'Rinomina "{oldFile}" in "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Importazione automatica',
        indexValueDetail: 'Valore dell’indice'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Impossibile chiamare il metodo "{method}" perché è astratto e non implementato',
        annotatedMetadataInconsistent: 'Il tipo di metadati annotati "{metadataType}" non è compatibile con il tipo "{type}"',
        annotatedParamCountMismatch: 'Numero di annotazioni dei parametro non corrispondente: previsto {expected} ma ricevuto {received}',
        annotatedTypeArgMissing: 'Previsto un argomento di tipo e una o più annotazioni per "Annotated"',
        annotationBytesString: 'Le espressioni di tipo non possono usare valori letterali stringa byte',
        annotationFormatString: 'Le espressioni di tipo non possono usare valori letterali stringa di formato (stringhe f)',
        annotationNotSupported: 'Annotazione di tipo non supportata per questa istruzione',
        annotationRawString: 'Le espressioni di tipo non possono usare valori letterali stringa non elaborata',
        annotationSpansStrings: 'Le espressioni di tipo non possono estendersi su più valori letterali stringa',
        annotationStringEscape: 'Le espressioni di tipo non possono contenere caratteri di escape',
        argAssignment: 'Non è possibile assegnare l\'argomento di tipo "{argType}" al parametro di tipo "{paramType}"',
        argAssignmentFunction: 'Non è possibile assegnare l\'argomento di tipo "{argType}" al parametro di tipo "{paramType}" nella funzione "{functionName}"',
        argAssignmentParam: 'Non è possibile assegnare l\'argomento di tipo "{argType}" al parametro "{paramName}" di tipo "{paramType}"',
        argAssignmentParamFunction: 'Non è possibile assegnare l\'argomento di tipo "{argType}" al parametro "{paramName}" di tipo "{paramType}" nella funzione "{functionName}"',
        argMissingForParam: 'Manca l\'argomento per il parametro {name}',
        argMissingForParams: 'Argomenti mancanti per i parametri {names}',
        argMorePositionalExpectedCount: 'Sono previsti {expected} altri argomenti posizionali',
        argMorePositionalExpectedOne: 'Previsto 1 altro argomento posizionale',
        argPositional: 'Argomento posizionale previsto',
        argPositionalExpectedCount: 'Sono previsti {expected} argomenti posizionali',
        argPositionalExpectedOne: 'Previsto 1 argomento posizionale',
        argTypePartiallyUnknown: 'Tipo di argomento parzialmente sconosciuto',
        argTypeUnknown: 'Il tipo di argomento è sconosciuto',
        assertAlwaysTrue: 'L\'espressione assert restituisce sempre true',
        assertTypeArgs: '"assert_type" prevede due argomenti posizionali',
        assertTypeTypeMismatch: '"assert_type" non corrispondente: previsto "{expected}" ma ricevuto "{received}"',
        assignmentExprComprehension: 'La destinazione dell\'espressione di assegnazione "{name}" non può usare lo stesso nome della comprensione per la destinazione',
        assignmentExprContext: 'L\'espressione di assegnazione deve essere all\'interno di modulo, funzione o lambda',
        assignmentExprInSubscript: 'Le espressioni di assegnazione all\'interno di un pedice sono supportate solo in Python 3.10 e versioni successive',
        assignmentInProtocol: 'Le variabili di istanza o di classe all\'interno di una classe Protocollo devono essere dichiarate esplicitamente nel corpo della classe',
        assignmentTargetExpr: 'L\'espressione non può essere una destinazione di assegnazione',
        asyncNotInAsyncFunction: 'L\'uso di "async" non è consentito al di fuori della funzione async',
        awaitIllegal: 'L\'uso di "await" richiede Python 3.5 o versione successiva',
        awaitNotAllowed: 'Le espressioni di tipo non possono usare "await"',
        awaitNotInAsync: '"await" consentito solo all\'interno della funzione async',
        backticksIllegal: 'Le espressioni racchiuse tra backticks non sono supportate in Python 3.x; usare repr invece',
        baseClassCircular: 'La classe non può derivare da se stessa',
        baseClassFinal: 'La classe di base "{type}" è contrassegnata come finale e non può essere sottoclassata',
        baseClassIncompatible: 'Le classi di base di {type} sono incompatibili tra di loro',
        baseClassInvalid: 'L\'argomento della classe deve essere una classe base',
        baseClassMethodTypeIncompatible: 'Le classi di base per la classe "{classType}" definiscono il metodo "{name}" in modo incompatibile',
        baseClassUnknown: 'Il tipo della classe di base è sconosciuto. È in corso il tentativo di determinare il tipo della classe derivata',
        baseClassVariableTypeIncompatible: 'Le classi di base per la classe "{classType}" definiscono la variabile "{name}" in modo incompatibile',
        binaryOperationNotAllowed: 'Operatore binario non consentito nell\'espressione di tipo',
        bindTypeMismatch: 'Non è stato possibile associare il metodo "{methodName}" perché non è possibile assegnare"{type}" al parametro "{paramName}"',
        breakInExceptionGroup: '"break" non consentito in un blocco "except*"',
        breakOutsideLoop: '"break" può essere usato solo all\'interno di un ciclo',
        callableExtraArgs: 'Sono previsti solo due argomenti di tipo per "Callable"',
        callableFirstArg: 'Previsto elenco dei tipi di parametro o "..."',
        callableNotInstantiable: 'Non è possibile creare un\'istanza del tipo "{type}"',
        callableSecondArg: 'È previsto un tipo restituito come secondo argomento di tipo per "Callable"',
        casePatternIsIrrefutable: 'Il criterio inconfutabile è consentito solo per l\'ultima istruzione case',
        classAlreadySpecialized: 'Il tipo "{type}" è già specializzato',
        classDecoratorTypeUnknown: 'L\'elemento Decorator di classe non tipizzato nasconde il tipo di classe. l\'elemento Decorator verrà ignorato',
        classDefinitionCycle: 'La definizione della classe per "{name}" dipende da se stessa',
        classGetItemClsParam: '__class_getitem__ override deve accettare un parametro "cls"',
        classMethodClsParam: 'I metodi di classe devono accettare un parametro "cls"',
        classNotRuntimeSubscriptable: 'Il pedice per la classe "{name}" genererà un\'eccezione di runtime; racchiudere l\'espressione di tipo tra virgolette',
        classPatternBuiltInArgPositional: 'Il modello di classe accetta solo un sotto pattern posizionale',
        classPatternPositionalArgCount: 'Troppi modelli posizionale per la classe "{type}"; previsto {expected} ma ottenuto {received}',
        classPatternTypeAlias: '"{type}" non può essere usato in uno schema di classe, perché è un alias di tipo specializzato',
        classPropertyDeprecated: 'Le proprietà della classe sono deprecate in Python 3.11 e non saranno supportate in Python 3.13',
        classTypeParametersIllegal: 'La sintassi del parametro del tipo di classe richiede Python 3.12 o versione successiva',
        classVarFirstArgMissing: 'È previsto un argomento tipo dopo "ClassVar"',
        classVarNotAllowed: '"ClassVar" non consentito in questo contesto',
        classVarOverridesInstanceVar: 'La variabile di classe "{name}" esegue l\'override della variabile di istanza con lo stesso nome nella classe "{className}"',
        classVarTooManyArgs: 'Previsto un solo argomento tipo dopo "ClassVar"',
        classVarWithTypeVar: 'Il tipo "ClassVar" non può includere variabili di tipo',
        clsSelfParamTypeMismatch: 'Il tipo di parametro "{name}" deve essere un supertipo della relativa classe "{classType}"',
        codeTooComplexToAnalyze: 'Il codice è troppo complesso per l\'analisi. ridurre la complessità eseguendo il refactoring in subroutine o riducendo i percorsi del codice condizionale',
        collectionAliasInstantiation: 'Non è possibile creare un\'istanza del tipo "{type}". In alternativa, usare "{alias}"',
        comparisonAlwaysFalse: 'La condizione restituisce sempre False perché i tipi "{leftType}" e "{rightType}" non si sovrappongono',
        comparisonAlwaysTrue: 'La condizione restituisce sempre True perché i tipi "{leftType}" e "{rightType}" non si sovrappongono',
        comprehensionInDict: 'Non è possibile usare la comprensione con altre voci del dizionario',
        comprehensionInSet: 'Non è possibile usare la comprensione con altre voci del set',
        concatenateContext: '“Concatenate” non è consentito in questo contesto',
        concatenateParamSpecMissing: 'L\'ultimo argomento di tipo per "Concatenate" deve essere un ParamSpec o "..."',
        concatenateTypeArgsMissing: '"Concatenate" richiede almeno due argomenti di tipo',
        conditionalOperandInvalid: 'Operando condizionale non valido di tipo "{type}"',
        constantRedefinition: '"{name}" è costante (perché è in maiuscolo) e non può essere ridefinita',
        constructorParametersMismatch: 'Mancata corrispondenza tra firma di __new__ e __init__ nella classe "{classType}"',
        containmentAlwaysFalse: 'L\'espressione restituisce sempre False perché i tipi "{leftType}" e "{rightType}" non si sovrappongono',
        containmentAlwaysTrue: 'L\'espressione restituisce sempre True perché i tipi "{leftType}" e "{rightType}" non si sovrappongono',
        continueInExceptionGroup: '"continue" non consentito in un blocco "except*"',
        continueOutsideLoop: '"continue" può essere usato solo all\'interno di un ciclo',
        coroutineInConditionalExpression: 'L\'espressione condizionale fa riferimento a una coroutine che restituisce sempre True',
        dataClassBaseClassFrozen: 'Una classe non bloccata non può ereditare da una classe bloccata',
        dataClassBaseClassNotFrozen: 'Una classe bloccata non può ereditare da una classe non bloccata',
        dataClassConverterFunction: 'L\'argomento di tipo "{argType}" non è un convertitore valido per il campo "{fieldName}" di tipo "{fieldType}"',
        dataClassConverterOverloads: 'Nessun overload di "{funcName}" è un convertitore valido per il campo "{fieldName}" di tipo "{fieldType}"',
        dataClassFieldInheritedDefault: '"{fieldName}" esegue l\'override di un campo con lo stesso nome, ma manca un valore predefinito',
        dataClassFieldWithDefault: 'I campi senza valori predefiniti non possono essere visualizzati dopo i campi con valori predefiniti',
        dataClassFieldWithPrivateName: 'Il campo dataclass non può usare un nome privato',
        dataClassFieldWithoutAnnotation: 'Il campo dataclass senza annotazione del tipo causerà un\'eccezione di runtime',
        dataClassPostInitParamCount: 'Dataclass __post_init__ conteggio dei parametri non corretto; il numero di campi InitVar è {expected}',
        dataClassPostInitType: 'Dataclass __post_init__ tipo di parametro del metodo non corrispondente per il campo "{fieldName}"',
        dataClassSlotsOverwrite: '__slots__ è già definito nella classe',
        dataClassTransformExpectedBoolLiteral: 'Espressione prevista che restituisce in modo statico True o False',
        dataClassTransformFieldSpecifier: 'È prevista una tuple di classi o funzioni ma è stato ricevuto il tipo "{type}"',
        dataClassTransformPositionalParam: 'Tutti gli argomenti di "dataclass_transform" devono essere argomenti di parole chiave',
        dataClassTransformUnknownArgument: 'Argomento "{name}" non supportato da dataclass_transform',
        dataProtocolInSubclassCheck: 'I protocolli dati (che includono attributi non di metodo) non sono consentiti nelle chiamate issubclass',
        declaredReturnTypePartiallyUnknown: 'Il tipo restituito dichiarato "{returnType}" è parzialmente sconosciuto',
        declaredReturnTypeUnknown: 'Il tipo restituito dichiarato è sconosciuto',
        defaultValueContainsCall: 'Chiamate di funzione e oggetti modificabili non consentiti all\'interno dell\'espressione del valore predefinito del parametro',
        defaultValueNotAllowed: 'Il parametro con "*" o "**" non può avere un valore predefinito',
        delTargetExpr: 'Non è possibile eliminare l\'espressione',
        deprecatedClass: 'La classe "{name}" è deprecata',
        deprecatedConstructor: 'Il costruttore per la classe "{name}" è deprecato',
        deprecatedDescriptorDeleter: 'Il metodo "__delete__" per il descrittore "{name}" è deprecato',
        deprecatedDescriptorGetter: 'Il metodo "__get__" per il descrittore "{name}" è deprecato',
        deprecatedDescriptorSetter: 'Il metodo "__set__" per il descrittore "{name}" è deprecato',
        deprecatedFunction: 'La funzione "{name}" è deprecata',
        deprecatedMethod: 'Il metodo "{name}" nella classe "{className}" è deprecato',
        deprecatedPropertyDeleter: 'Il deleter per la property "{name}" è deprecato',
        deprecatedPropertyGetter: 'Il getter per la property "{name}" è deprecato',
        deprecatedPropertySetter: 'Il setter per la property "{name}" è deprecato',
        deprecatedType: 'Questo tipo è deprecato a partire da Python {version}; usa "{replacement}"',
        dictExpandIllegalInComprehension: 'Espansione del dizionario non consentita nella comprensione',
        dictInAnnotation: 'Espressione dizionario non consentita nell\'espressione di tipo',
        dictKeyValuePairs: 'Le voci del dizionario devono contenere coppie chiave-valore',
        dictUnpackIsNotMapping: 'Mapping previsto per l\'operatore di decompressione del dizionario',
        dunderAllSymbolNotPresent: '"{name}" è specificato in __all__ ma non è presente nel modulo',
        duplicateArgsParam: 'È consentito un solo parametro "*"',
        duplicateBaseClass: 'Classe di base duplicata non consentita',
        duplicateCapturePatternTarget: 'La destinazione di acquisizione "{name}" non può comparire più di una volta all\'interno dello stesso schema',
        duplicateCatchAll: 'È consentita una sola clausola catch-all except',
        duplicateEnumMember: 'Il membro di Enum "{name}" è già dichiarato',
        duplicateGenericAndProtocolBase: 'È consentita una sola classe di base Generic[...] o Protocol[...]',
        duplicateImport: '"{importName}" è stato importato più di una volta',
        duplicateKeywordOnly: 'È consentito un solo separatore "*"',
        duplicateKwargsParam: 'È consentito un solo parametro "**"',
        duplicateParam: '“{name}" parametro duplicato',
        duplicatePositionOnly: 'È consentito un solo parametro "/"',
        duplicateStarPattern: 'In una sequenza di criteri è consentito un solo criterio "*"',
        duplicateStarStarPattern: 'È consentita una sola voce "**"',
        duplicateUnpack: 'Nell list è consentita una sola operazione di decompressione',
        ellipsisAfterUnpacked: '"..." non può essere usato con un argomento TypeVarTuple non compresso o tuple',
        ellipsisContext: '"..." non è consentito in questo contesto',
        ellipsisSecondArg: '"..." è consentito solo come secondo di due argomenti',
        enumClassOverride: 'La classe di Enum "{name}" è finale e non può essere sottoclassificata',
        enumMemberDelete: 'Non è possibile eliminare il membro di Enum "{name}"',
        enumMemberSet: 'Non è possibile assegnare il membro di Enum "{name}"',
        enumMemberTypeAnnotation: 'Le annotazioni di tipo non sono consentite per i membri di enumerazione',
        exceptGroupMismatch: 'L\'istruzione Try non può includere sia "except" che "except*"',
        exceptGroupRequiresType: 'La sintassi del gruppo di eccezioni ("except*") richiede un tipo di eccezione',
        exceptionGroupIncompatible: 'La sintassi del gruppo di eccezioni ("except*") richiede Python 3.11 o versione successiva',
        exceptionGroupTypeIncorrect: 'Il tipo di eccezione in except* non può derivare da BaseGroupException',
        exceptionTypeIncorrect: '"{type}" non deriva da BaseException',
        exceptionTypeNotClass: '"{type}" non è una classe di eccezione valida',
        exceptionTypeNotInstantiable: 'Il costruttore per il tipo di eccezione "{type}" richiede uno o più argomenti',
        expectedAfterDecorator: 'Dichiarazione di funzione o classe prevista dopo l’elemento Decorator',
        expectedArrow: 'Previsto "->" seguito da un\'annotazione di tipo restituito',
        expectedAsAfterException: 'Previsto "as" dopo il tipo di eccezione',
        expectedAssignRightHandExpr: 'Espressione prevista a destra di "="',
        expectedBinaryRightHandExpr: 'Espressione prevista a destra dell\'operatore',
        expectedBoolLiteral: 'È previsto True o False',
        expectedCase: 'Prevista istruzione "case"',
        expectedClassName: 'Nome classe previsto',
        expectedCloseBrace: '"{" non è stato chiuso',
        expectedCloseBracket: '"[" non è stato chiuso',
        expectedCloseParen: '"(" non è stato chiuso',
        expectedColon: 'Previsto ":"',
        expectedComplexNumberLiteral: 'È previsto un valore letterale di numero complesso per i criteri di ricerca',
        expectedDecoratorExpr: 'Il modulo dell\'espressione non è supportato per l\'elemento Decorator precedente a Python 3.9',
        expectedDecoratorName: 'È previsto un nome di elemento Decorator',
        expectedDecoratorNewline: 'Prevista nuova riga alla fine dell\'elemento Decorator',
        expectedDelExpr: 'Espressione prevista dopo "del"',
        expectedElse: 'Previsto "else"',
        expectedEquals: 'Previsto "="',
        expectedExceptionClass: 'Classe od oggetto di eccezione non valido',
        expectedExceptionObj: 'Previsto oggetto eccezione, classe eccezione o None',
        expectedExpr: 'Espressione prevista',
        expectedFunctionAfterAsync: 'Prevista definizione di funzione dopo "async"',
        expectedFunctionName: 'È previsto un nome di funzione dopo "def"',
        expectedIdentifier: 'Identificatore previsto',
        expectedImport: 'Previsto "import"',
        expectedImportAlias: 'Simbolo previsto dopo "as"',
        expectedImportSymbols: 'Sono previsti uno o più nomi di simboli dopo “import”',
        expectedIn: 'previsto \'in\'',
        expectedInExpr: 'Espressione prevista dopo "in"',
        expectedIndentedBlock: 'Previsto un blocco rientrato',
        expectedMemberName: 'Nome dell\'attributo previsto dopo "."',
        expectedModuleName: 'Nome del modulo previsto',
        expectedNameAfterAs: 'È previsto il nome del simbolo dopo "as"',
        expectedNamedParameter: 'Il parametro della parola chiave deve seguire "*"',
        expectedNewline: 'Prevista nuova riga',
        expectedNewlineOrSemicolon: 'Le istruzioni devono essere separate da nuove righe o punti e virgola',
        expectedOpenParen: 'Previsto "("',
        expectedParamName: 'Nome del parametro previsto',
        expectedPatternExpr: 'Espressione del criterio prevista',
        expectedPatternSubjectExpr: 'Prevista espressione del soggetto del criterio',
        expectedPatternValue: 'Espressione del valore del criterio prevista nel formato "a.b"',
        expectedReturnExpr: 'Espressione prevista dopo "return"',
        expectedSliceIndex: 'Prevista espressione di indice o sezione',
        expectedTypeNotString: 'È previsto un tipo ma è stato ricevuto un valore letterale stringa',
        expectedTypeParameterName: 'Nome del parametro del tipo previsto',
        expectedYieldExpr: 'Espressione prevista nell\'istruzione yield',
        finalClassIsAbstract: 'La classe "{type}" è contrassegnata come finale e deve implementare tutti i simboli astratti',
        finalContext: '"Finale" non è consentito in questo contesto',
        finalInLoop: 'Non è possibile assegnare una variabile "Final" all\'interno di un ciclo',
        finalMethodOverride: 'Il metodo "{name}" non può eseguire l\'override del metodo finale definito nella classe "{className}"',
        finalNonMethod: 'Impossibile contrassegnare la funzione “{name}” @final perché non è un metodo',
        finalReassigned: '"{name}" è dichiarato come Finale e non può essere riassegnato',
        finalRedeclaration: '"{name}" è stato dichiarato in precedenza come Finale',
        finalRedeclarationBySubclass: 'Non è possibile ridichiarare "{name}" perché la classe padre "{className}" la dichiara come Finale',
        finalTooManyArgs: 'Previsto un singolo argomento tipo dopo "Final"',
        finalUnassigned: '"{name}" è dichiarato Final, ma il valore non è assegnato',
        formatStringBrace: 'Parentesi graffa di chiusura singola non consentita all\'interno del valore letterale f-string; usa parentesi graffa chiusa doppia',
        formatStringBytes: 'I valori letterali stringa di formato (f-string) non possono essere binari',
        formatStringDebuggingIllegal: 'L’identificatore di debug delle stringhe F "=" richiede Python 3.8 o versione successiva',
        formatStringEscape: 'Sequenza di escape (barra rovesciata) non consentita nella porzione di espressione di f-string prima di Python 3.12',
        formatStringExpectedConversion: 'È previsto un identificatore di conversione dopo "!" in f-string',
        formatStringIllegal: 'I valori letterali stringa di formato (f-string) richiedono Python 3.6 o versione successiva',
        formatStringInPattern: 'Stringa di formato non consentita nel criterio',
        formatStringNestedFormatSpecifier: 'Espressioni annidate troppo in profondità nell\'identificatore di stringa di formato',
        formatStringNestedQuote: 'Le stringhe annidate all\'interno di una stringa f non possono usare lo stesso carattere virgolette della stringa f prima di Python 3.12',
        formatStringUnicode: 'I valori letterali stringa di formato (f-string) non possono essere unicode',
        formatStringUnterminated: 'Espressione senza terminazione in f-string; previsto "}".',
        functionDecoratorTypeUnknown: 'L\'elemento Decorator della funzione non tipizzato nasconde il tipo di funzione; l\'elemento Decorator verrà ignorato',
        functionInConditionalExpression: 'L\'espressione condizionale fa riferimento a una funzione che restituisce sempre True',
        functionTypeParametersIllegal: 'La sintassi del parametro del tipo di funzione richiede Python 3.12 o versione successiva',
        futureImportLocationNotAllowed: 'Le importazioni da __future__ devono trovarsi all\'inizio del file',
        generatorAsyncReturnType: 'Il tipo restituito della funzione del generatore async deve essere compatibile con "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: 'Le espressioni del generatore devono essere racchiuse tra parentesi se non è l\'unico argomento',
        generatorSyncReturnType: 'Il tipo restituito della funzione del generatore deve essere compatibile con "Generator[{yieldType}, Any, Any]"',
        genericBaseClassNotAllowed: 'Non è possibile usare la classe di base "Generic" con la sintassi del parametro di tipo',
        genericClassAssigned: 'Non è possibile assegnare il tipo di classe generico',
        genericClassDeleted: 'Non è possibile eliminare il tipo di classe generico',
        genericInstanceVariableAccess: 'L\'accesso alla variabile di istanza generica tramite la classe è ambiguo',
        genericNotAllowed: '"Generic" non valido in questo contesto',
        genericTypeAliasBoundTypeVar: 'L\'alias di tipo generico all\'interno della classe non può usare variabili di tipo associate {names}',
        genericTypeArgMissing: '"Generico" richiede almeno un argomento di tipo',
        genericTypeArgTypeVar: 'L\'argomento di tipo per "Generic" deve essere una variabile di tipo',
        genericTypeArgUnique: 'Gli argomenti di tipo per "Generic" devono essere univoci',
        globalReassignment: '"{name}" è assegnato prima della dichiarazione globale',
        globalRedefinition: '"{name}" è già stato dichiarato globale',
        implicitStringConcat: 'Concatenazione implicita di stringhe non consentita',
        importCycleDetected: 'Ciclo rilevato nella catena di importazione',
        importDepthExceeded: 'La profondità della catena di importazione ha superato {depth}',
        importResolveFailure: 'Non è stato possibile risolvere l\'importazione "{importName}"',
        importSourceResolveFailure: 'Non è stato possibile risolvere l\'importazione "{importName}" dall’origine',
        importSymbolUnknown: '"{name}" è un simbolo di importazione sconosciuto',
        incompatibleMethodOverride: 'Il metodo "{name}" esegue l\'override della classe "{className}" in modo incompatibile',
        inconsistentIndent: 'Il valore dell\'annullamento del rientro non corrisponde al rientro precedente',
        inconsistentTabs: 'Uso incoerente di tabulazioni e spazi nel rientro',
        initMethodSelfParamTypeVar: 'L\'annotazione di tipo per il parametro "self" del metodo "__init__" non può contenere variabili di tipo con ambito classe',
        initMustReturnNone: 'Il tipo restituito di "__init__" deve essere None',
        initSubclassCallFailed: 'Argomenti di parola chiave non corretti per il metodo __init_subclass__',
        initSubclassClsParam: '__init_subclass__ override deve accettare un parametro "cls"',
        initVarNotAllowed: '"InitVar" non consentito in questo contesto',
        instanceMethodSelfParam: 'I metodi di istanza devono accettare un parametro "self"',
        instanceVarOverridesClassVar: 'La variabile di istanza "{name}" esegue l\'override della variabile di classe con lo stesso nome nella classe "{className}"',
        instantiateAbstract: 'Non è possibile creare un\'istanza di classe astratta "{type}"',
        instantiateProtocol: 'Non è possibile creare un\'istanza della classe Protocol "{type}"',
        internalBindError: 'Errore interno durante l\'associazione del file "{file}": {message}',
        internalParseError: 'Si è verificato un errore interno durante l\'analisi del file "{file}": {message}',
        internalTypeCheckingError: 'Errore interno durante il controllo del tipo del file "{file}": {message}',
        invalidIdentifierChar: 'Carattere non valido nell\'identificatore',
        invalidStubStatement: 'L\'istruzione non ha significato all\'interno di un file stub di tipo',
        invalidTokenChars: 'Carattere non valido "{text}" nel token',
        isInstanceInvalidType: 'Il secondo argomento di "isinstance" deve essere una classe o una tuple di classi',
        isSubclassInvalidType: 'Il secondo argomento di "issubclass" deve essere una classe o una tuple di classi',
        keyValueInSet: 'Le coppie chiave-valore non sono consentite all\'interno di un set',
        keywordArgInTypeArgument: 'Gli argomenti delle parole chiave non possono essere usati negli elenchi di argomenti tipo',
        keywordArgShortcutIllegal: 'Il collegamento all\'argomento della parola chiave richiede Python 3.14 o versione successiva',
        keywordOnlyAfterArgs: 'Separatore di argomenti solo parola chiave non consentito dopo il parametro "*"',
        keywordParameterMissing: 'Uno o più parametri di parole chiave devono seguire il parametro "*"',
        keywordSubscriptIllegal: 'Gli argomenti delle parole chiave all\'interno di pedici non sono supportati',
        lambdaReturnTypePartiallyUnknown: 'Il tipo restituito dell\'espressione lambda "{returnType}" è parzialmente sconosciuto',
        lambdaReturnTypeUnknown: 'Il tipo restituito di lambda è sconosciuto',
        listAssignmentMismatch: 'Non è possibile assegnare l\'espressione con tipo "{type}" all\'elenco di destinazione',
        listInAnnotation: 'Espressione List non consentita nell\'espressione type',
        literalEmptyArgs: 'Sono previsti uno o più argomenti di tipo dopo "Literal"',
        literalNamedUnicodeEscape: 'Le sequenze di escape Unicode denominate non sono supportate nelle annotazioni stringa "Literal"',
        literalNotAllowed: 'Non è possibile usare "Literal" in questo contesto senza un argomento tipo',
        literalNotCallable: 'Non è possibile creare un\'istanza del tipo Literal',
        literalUnsupportedType: 'Gli argomenti di tipo per "Literal" devono essere None, un valore letterale (int, bool, str o bytes) o un valore di enumerazione',
        matchIncompatible: 'Le istruzioni match richiedono Python 3.10 o versione successiva',
        matchIsNotExhaustive: 'I case all\'interno dell\'istruzione match non gestiscono in modo completo tutti i valori',
        maxParseDepthExceeded: 'È stata superata la profondità massima di analisi; suddividere l\'espressione in sottoespressioni più piccole',
        memberAccess: 'Non è possibile accedere all\'attributo "{name}" per la classe "{type}"',
        memberDelete: 'Non è possibile eliminare l\'attributo "{name}" per la classe "{type}"',
        memberSet: 'Non è possibile assegnare all\'attributo "{name}" per la classe "{type}"',
        metaclassConflict: 'La metaclasse di una classe derivata deve essere una sottoclasse delle metaclassi di tutte le relative classi di base',
        metaclassDuplicate: 'È possibile specificare una sola metaclasse',
        metaclassIsGeneric: 'La metaclasse non può essere generica',
        methodNotDefined: 'Metodo "{name}" non definito',
        methodNotDefinedOnType: '"{name}" metodo non definito nel tipo "{type}"',
        methodOrdering: 'Non è possibile creare un ordinamento coerente del metodo',
        methodOverridden: '"{name}" esegue l\'override del metodo con lo stesso nome nella classe "{className}" con un tipo non compatibile "{type}".',
        methodReturnsNonObject: 'Il metodo "{name}" non restituisce un oggetto',
        missingSuperCall: 'Il metodo "{methodName}" non chiama il metodo con lo stesso nome nella classe padre',
        mixingBytesAndStr: 'Bytes e valori str non possono essere concatenati',
        moduleAsType: 'Il modulo non può essere usato come tipo',
        moduleNotCallable: 'Modulo non chiamabile',
        moduleUnknownMember: '"{memberName}" non è un attributo noto del modulo "{moduleName}"',
        namedExceptAfterCatchAll: 'Una clausola except denominata non può trovarsi dopo la clausola catch-all except',
        namedParamAfterParamSpecArgs: 'Il parametro della parola chiave "{name}" non può essere visualizzato nella firma dopo il parametro ParamSpec args',
        namedTupleEmptyName: 'I nomi all\'interno di un tuple denominato non possono essere vuoti',
        namedTupleEntryRedeclared: 'Non è possibile eseguire l\'override di "{name}" perché la classe padre "{className}" è un tuple denominato',
        namedTupleFirstArg: 'È previsto il nome della classe di tuple denominata come primo argomento',
        namedTupleMultipleInheritance: 'L\'ereditarietà multipla con NamedTuple non è supportata',
        namedTupleNameKeyword: 'I nomi dei campi non possono essere una parola chiave',
        namedTupleNameType: 'È prevista una tuple a due voci che specifica il nome e il tipo della voce',
        namedTupleNameUnique: 'I nomi all\'interno di una tuple denominata devono essere univoci',
        namedTupleNoTypes: '"namedtuple" non fornisce tipi per le voci di tupla; usare invece "NamedTuple"',
        namedTupleSecondArg: 'È previsto un list di voci di tuple denominate come secondo argomento',
        newClsParam: '__new__ override deve accettare un parametro "cls"',
        newTypeAnyOrUnknown: 'Il secondo argomento di NewType deve essere una classe nota, non Any o Unknown',
        newTypeBadName: 'Il primo argomento di NewType deve essere un valore letterale stringa',
        newTypeLiteral: 'Non è possibile usare NewType con il tipo Literal',
        newTypeNameMismatch: 'NewType deve essere assegnato a una variabile con lo stesso nome',
        newTypeNotAClass: 'Classe prevista come secondo argomento di NewType',
        newTypeParamCount: 'NewType richiede due argomenti posizionali',
        newTypeProtocolClass: 'Non è possibile usare NewType con il tipo strutturale (una classe Protocol o TypedDict)',
        noOverload: 'Nessun overload per "{name}" corrisponde agli argomenti specificati',
        noReturnContainsReturn: 'La funzione con tipo return dichiarato "NoReturn" non può includere un\'istruzione return',
        noReturnContainsYield: 'La funzione con il tipo restituito dichiarato "NoReturn" non può includere un\'istruzione yield',
        noReturnReturnsNone: 'La funzione con tipo restituito dichiarato "NoReturn" non può restituire "None"',
        nonDefaultAfterDefault: 'L\'argomento non predefinito segue l\'argomento predefinito',
        nonLocalInModule: 'Dichiarazione nonlocale non consentita a livello di modulo',
        nonLocalNoBinding: 'Non è stata trovata alcuna associazione per "{name}" nonlocal',
        nonLocalReassignment: '"{name}" viene assegnato prima della dichiarazione nonlocal',
        nonLocalRedefinition: '"{name}" è già stato dichiarato nonlocal',
        noneNotCallable: 'Non è possibile chiamare l\'oggetto di tipo "None"',
        noneNotIterable: 'Impossibile utilizzare l\'oggetto di tipo "None" come valore iterabile',
        noneNotSubscriptable: 'L\'oggetto di tipo "None" non è sottoponibile a pedice',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Operatore "{operator}" non supportato per "None"',
        noneUnknownMember: '"{name}" non è un attributo noto di "None"',
        notRequiredArgCount: 'Previsto un singolo argomento tipo dopo "NotRequired"',
        notRequiredNotInTypedDict: '"NotRequired" non è consentito in questo contesto',
        objectNotCallable: 'L\'oggetto di tipo "{type}" non è chiamabile',
        obscuredClassDeclaration: 'La dichiarazione di classe "{name}" è oscurata da una dichiarazione con lo stesso nome',
        obscuredFunctionDeclaration: 'La dichiarazione della funzione "{name}" è oscurata da una dichiarazione con lo stesso nome',
        obscuredMethodDeclaration: 'La dichiarazione del metodo "{name}" è oscurata da una dichiarazione con lo stesso nome',
        obscuredParameterDeclaration: 'La dichiarazione del parametro "{name}" è oscurata da una dichiarazione con lo stesso nome',
        obscuredTypeAliasDeclaration: 'La dichiarazione dell\'alias di tipo "{name}" è nascosta da una dichiarazione con lo stesso nome',
        obscuredVariableDeclaration: 'La dichiarazione "{name}" è oscurata da una dichiarazione con lo stesso nome',
        operatorLessOrGreaterDeprecated: 'L\'operatore "<>" non è supportato in Python 3. Usare invece "!="',
        optionalExtraArgs: 'È previsto un argomento di tipo dopo "Optional"',
        orPatternIrrefutable: 'Criterio inconfutabile consentito solo come ultimo criterio secondario in un criterio "or"',
        orPatternMissingName: 'Tutti i criteri secondari all\'interno di un criterio "or" devono avere come destinazione gli stessi nomi',
        overlappingKeywordArgs: 'Il dizionario tipizzato si sovrappone al parametro della parola chiave: {names}',
        overlappingOverload: 'L\'overload {obscured} per "{name}" non verrà mai usato perché i parametri si sovrappongono all\'overload {obscuredBy}',
        overloadAbstractImplMismatch: 'Gli overload devono corrispondere allo stato astratto dell\'implementazione',
        overloadAbstractMismatch: 'Gli overload devono essere tutti astratti o no',
        overloadClassMethodInconsistent: 'Gli overload per "{name}" usano @classmethod in modo incoerente',
        overloadFinalInconsistencyImpl: 'L\'overload per “{name}” è contrassegnato @final ma l\'implementazione non lo è',
        overloadFinalInconsistencyNoImpl: 'L\'overload {index} per “{name}” è contrassegnato @final ma l\'overload 1 non lo è',
        overloadImplementationMismatch: 'L\'implementazione di overload non è coerente con la firma dell\'overload {index}',
        overloadReturnTypeMismatch: 'L\'overload {prevIndex} per "{name}" si sovrappone all\'overload {newIndex} e restituisce un tipo incompatibile',
        overloadStaticMethodInconsistent: 'Gli overload per "{name}" usano @staticmethod in modo incoerente',
        overloadWithoutImplementation: '"{name}" è contrassegnato come overload, ma non viene fornita alcuna implementazione',
        overriddenMethodNotFound: 'Il metodo "{name}" è contrassegnato come override, ma non è presente alcun metodo di base con lo stesso nome',
        overrideDecoratorMissing: 'Il metodo "{name}" non è contrassegnato come override, ma esegue l\'override di un metodo nella classe "{className}"',
        paramAfterKwargsParam: 'Il parametro non può seguire il parametro "**"',
        paramAlreadyAssigned: 'Il parametro "{name}" è già assegnato',
        paramAnnotationMissing: 'Annotazione di tipo mancante per il parametro "{name}"',
        paramAssignmentMismatch: 'Non è possibile assegnare l\'espressione di tipo "{sourceType}" al parametro di tipo "{paramType}"',
        paramNameMissing: 'Nessun parametro denominato "{name}"',
        paramSpecArgsKwargsDuplicate: 'Gli argomenti per ParamSpec "{type}" sono già stati specificati',
        paramSpecArgsKwargsUsage: 'Gli attributi "args" e "kwargs" di ParamSpec devono essere entrambi visualizzati all\'interno di una firma di funzione',
        paramSpecArgsMissing: 'Gli argomenti per ParamSpec "{type}" sono mancanti',
        paramSpecArgsUsage: 'L\'attributo "args" di ParamSpec è valido solo se usato con il parametro *args',
        paramSpecAssignedName: 'ParamSpec deve essere assegnato a una variabile denominata "{name}"',
        paramSpecContext: 'ParamSpec non è consentito in questo contesto',
        paramSpecDefaultNotTuple: 'Sono previsti puntini di sospensione, un\'espressione di tuple o ParamSpec per il valore predefinito di ParamSpec',
        paramSpecFirstArg: 'Nome previsto di ParamSpec come primo argomento',
        paramSpecKwargsUsage: 'L\'attributo "kwargs" di ParamSpec è valido solo se usato con il parametro **kwargs',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" non ha significato in questo contesto',
        paramSpecUnknownArg: 'ParamSpec non supporta più di un argomento',
        paramSpecUnknownMember: '"{name}" non è un attributo noto di ParamSpec',
        paramSpecUnknownParam: '"{name}" è un parametro sconosciuto per ParamSpec',
        paramTypeCovariant: 'Non è possibile usare la variabile di tipo covariante nel tipo di parametro',
        paramTypePartiallyUnknown: 'Tipo di parametro "{paramName}" parzialmente sconosciuto',
        paramTypeUnknown: 'Tipo di parametro "{paramName}" sconosciuto',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Il criterio non verrà mai confrontato per il tipo di oggetto "{type}"',
        positionArgAfterNamedArg: 'L\'argomento posizionale non può essere visualizzato dopo gli argomenti della parola chiave',
        positionOnlyAfterArgs: 'Separatore di parametri di sola posizione non consentito dopo il parametro "*"',
        positionOnlyAfterKeywordOnly: 'Il parametro "/" deve essere visualizzato prima del parametro "*"',
        positionOnlyAfterNon: 'Il parametro di sola posizione non è consentito dopo un parametro che non è di sola posizione',
        positionOnlyFirstParam: 'Separatore di argomenti di sola posizione non consentito come primo parametro',
        positionOnlyIncompatible: 'Il separatore di parametri di sola posizione richiede Python 3.8 o versione successiva',
        privateImportFromPyTypedModule: '"{name}" non è esportato dal modulo "{module}"',
        privateUsedOutsideOfClass: '"{name}" è privato e utilizzato all\'esterno del modulo in cui è dichiarato',
        privateUsedOutsideOfModule: '"{name}" è privato e utilizzato all\'esterno del modulo in cui è dichiarato',
        propertyOverridden: '"{name}" esegue erroneamente l’override di una property con lo stesso nome nella classe "{className}"',
        propertyStaticMethod: 'Metodi statici non consentiti per getter, setter o deleter di property',
        protectedUsedOutsideOfClass: '"{name}" è protetto e usato al di fuori della classe in cui è dichiarato',
        protocolBaseClass: 'La classe Protocol "{classType}" non può derivare dalla classe non Protocol "{baseType}"',
        protocolBaseClassWithTypeArgs: 'Gli argomenti tipo non sono consentiti con la classe Protocollo quando si usa la sintassi dei parametri tipo',
        protocolIllegal: 'L\'uso di "Protocol" richiede Python 3.7 o versione successiva',
        protocolNotAllowed: '"Protocol" non può essere usato in questo contesto',
        protocolTypeArgMustBeTypeParam: 'L\'argomento di tipo per "Protocol" deve essere un parametro di tipo',
        protocolUnsafeOverlap: 'La classe si sovrappone a "{name}" in modo non sicuro e può produrre una corrispondenza in fase di esecuzione',
        protocolVarianceContravariant: 'La variabile di tipo "{variable}" usata in "{class}" Protocol generico deve essere controvariante',
        protocolVarianceCovariant: 'La variabile di tipo "{variable}" usata in "{class}" Protocol generico deve essere covariante',
        protocolVarianceInvariant: 'La variabile di tipo "{variable}" usata in "{class}" Protocol generico deve essere invariante',
        pyrightCommentInvalidDiagnosticBoolValue: 'La direttiva di commento Pyright deve essere seguita da "=" e da un valore true o false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'La direttiva di commento Pyright deve essere seguita da "=" e da un valore true, false, error, warning, information o none',
        pyrightCommentMissingDirective: 'Il commento Pyright deve essere seguito da una direttiva (basic o strict) o da una regola di diagnostica',
        pyrightCommentNotOnOwnLine: 'I commenti Pyright usati per controllare le impostazioni a livello di file devono essere visualizzati nella propria riga',
        pyrightCommentUnknownDiagnosticRule: '"{rule}" è una regola di diagnostica sconosciuta per il commento pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" non è un valore valido per il commento pyright; previsto true, false, error, warning, information o none',
        pyrightCommentUnknownDirective: '"{directive}" è una direttiva sconosciuta per il commento pyright; previsto "strict" o "basic"',
        readOnlyArgCount: 'Previsto un singolo argomento tipo dopo "ReadOnly"',
        readOnlyNotInTypedDict: '"ReadOnly" non consentito in questo contesto',
        recursiveDefinition: 'Non è stato possibile determinare il tipo di "{name}" perché fa riferimento a se stesso',
        relativeImportNotAllowed: 'Le importazioni relative non possono essere usate con il modulo "import .a". Usare invece "from . import a"',
        requiredArgCount: 'È previsto un singolo argomento di tipo dopo "Required"',
        requiredNotInTypedDict: '"Required" non è consentito in questo contesto',
        returnInAsyncGenerator: 'L’istruzione return con valore non è consentita nel generatore async',
        returnInExceptionGroup: '"return" non consentito in un blocco "except*"',
        returnMissing: 'La funzione con tipo restituito dichiarato "{returnType}" deve restituire un valore in tutti i percorsi di codice',
        returnOutsideFunction: '"return" può essere usata solo all\'interno di una funzione.',
        returnTypeContravariant: 'Non è possibile usare la variabile di tipo controvariante nel tipo restituito',
        returnTypeMismatch: 'Il tipo "{exprType}" non è assegnabile al tipo restituito "{returnType}"',
        returnTypePartiallyUnknown: 'Il tipo restituito "{returnType}" è parzialmente sconosciuto',
        returnTypeUnknown: 'Il tipo restituito è sconosciuto',
        revealLocalsArgs: 'Non è previsto alcun argomento per la chiamata "reveal_locals"',
        revealLocalsNone: 'Non sono presenti variabili locals in questo ambito',
        revealTypeArgs: 'Previsto un singolo argomento posizionale per la chiamata "reveal_type"',
        revealTypeExpectedTextArg: 'L\'argomento "expected_text" per la funzione "reveal_type" deve essere un valore letterale str',
        revealTypeExpectedTextMismatch: 'Testo di tipo non corrispondente; previsto "{expected}" ma ricevuto "{received}"',
        revealTypeExpectedTypeMismatch: 'Tipo non corrispondente; previsto "{expected}" ma ricevuto "{received}"',
        selfTypeContext: '"Self" non è valido in questo contesto',
        selfTypeMetaclass: 'Impossibile utilizzare “Self” all\'interno di una metaclasse (una sottoclasse di “type”)',
        selfTypeWithTypedSelfOrCls: 'Non è possibile usare "Self" in una funzione con un parametro \'self\' o \'cls\' con un\'annotazione di tipo diversa da "Self"',
        setterGetterTypeMismatch: 'Il tipo di valore del setter di Property non è assegnabile al tipo restituito del getter',
        singleOverload: '"{name}" è contrassegnato come overload, ma mancano altri overload',
        slotsAttributeError: '"{name}" non è specificato in __slots__',
        slotsClassVarConflict: '"{name}" è in conflitto con la variabile di istanza dichiarata in __slots__',
        starPatternInAsPattern: 'Il modello a stella non può essere usato con la destinazione "as"',
        starPatternInOrPattern: 'Il modello a stella non può essere ORed all\'interno di altri modelli',
        starStarWildcardNotAllowed: '** non può essere usato con il carattere jolly "_"',
        staticClsSelfParam: 'I metodi statici non devono accettare un parametro "self" o "cls"',
        stdlibModuleOverridden: '"{path}" sta eseguendo l\'override del modulo stdlib "{name}"',
        stringNonAsciiBytes: 'Carattere non ASCII non consentito nel valore letterale stringa dei byte',
        stringNotSubscriptable: 'L\'espressione stringa non può essere in pedice nell\'espressione di tipo. Racchiudere l\'intera espressione tra virgolette',
        stringUnsupportedEscape: 'Sequenza di escape non supportata nel valore letterale stringa',
        stringUnterminated: 'Il valore letterale stringa non è terminato',
        stubFileMissing: 'File di stub non trovato per "{importName}"',
        stubUsesGetAttr: 'Il file dello stub di tipo è incompleto; "__getattr__" nasconde gli errori di tipo per il modulo',
        sublistParamsIncompatible: 'I parametri di sublist non sono supportati in Python 3.x',
        superCallArgCount: 'Non sono previsti più di due argomenti per la chiamata "super".',
        superCallFirstArg: 'È previsto un tipo di classe come primo argomento della chiamata "super", ma è stato ricevuto "{type}"',
        superCallSecondArg: 'Il secondo argomento della chiamata "super" deve essere un oggetto o una classe che deriva da "{type}"',
        superCallZeroArgForm: 'Il modulo zero-argument della chiamata "super" è valido solo all\'interno di un metodo',
        superCallZeroArgFormStaticMethod: 'Il modulo zero-argument della chiamata "super" non è valido all\'interno di un metodo statico',
        symbolIsPossiblyUnbound: '"{name}" potrebbe non essere associato',
        symbolIsUnbound: '"{name}" non associato',
        symbolIsUndefined: '"{name}" non è definito',
        symbolOverridden: '"{name}" esegue l\'override del simbolo con lo stesso nome nella classe "{className}"',
        ternaryNotAllowed: 'Espressione ternaria non consentita nell\'espressione di tipo',
        totalOrderingMissingMethod: 'La classe deve definire uno dei valori di "__lt__", "__le__", "__gt__" o "__ge__" per usare total_ordering',
        trailingCommaInFromImport: 'Virgola finale non consentita senza parentesi circostanti',
        tryWithoutExcept: 'L\'istruzione Try deve contenere almeno una clausola except or finally',
        tupleAssignmentMismatch: 'Non è possibile assegnare l\'espressione con tipo "{type}" al tuple di destinazione',
        tupleInAnnotation: 'Espressione di tuple non consentita nell\'espressione del tipo',
        tupleIndexOutOfRange: 'L\'indice {index} non è compreso nell\'intervallo per il tipo {type}',
        typeAliasIllegalExpressionForm: 'Modulo di espressione non valido per la definizione dell\'alias di tipo',
        typeAliasIsRecursiveDirect: 'L\'alias di tipo "{name}" non può usare se stesso nella relativa definizione',
        typeAliasNotInModuleOrClass: 'TypeAlias può essere definito solo all\'interno di un modulo o di una classe',
        typeAliasRedeclared: '"{name}" è dichiarato come TypeAlias e può essere assegnato una sola volta',
        typeAliasStatementBadScope: 'Un\'istruzione type può essere usata solo all\'interno di un modulo o di un ambito della classe',
        typeAliasStatementIllegal: 'L\'istruzione alias di tipo richiede Python 3.12 o versione successiva',
        typeAliasTypeBaseClass: 'Impossibile utilizzare come classe di base un alias di tipo definito in un\'istruzione "type"',
        typeAliasTypeMustBeAssigned: 'TypeAliasType deve essere assegnato a una variabile con lo stesso nome dell\'alias di tipo',
        typeAliasTypeNameArg: 'Il primo argomento di TypeAliasType deve essere un valore letterale stringa che rappresenta il nome dell\'alias di tipo',
        typeAliasTypeNameMismatch: 'Il nome dell\'alias di tipo deve corrispondere al nome della variabile a cui è assegnato',
        typeAliasTypeParamInvalid: 'L\'elenco dei parametri di tipo deve essere un tuple contenente solo TypeVar, TypeVarTuple o ParamSpec.',
        typeAnnotationCall: 'Espressione di chiamata non consentita nell\'espressione di tipo',
        typeAnnotationVariable: 'Variabile non consentita nell\'espressione di tipo',
        typeAnnotationWithCallable: 'L\'argomento di tipo per "type" deve essere una classe. I callable non sono supportati',
        typeArgListExpected: 'Sono previsti ParamSpec, puntini di sospensione o elenco di list',
        typeArgListNotAllowed: 'Espressione di List non consentita per questo argomento di tipo',
        typeArgsExpectingNone: 'Non sono previsti argomenti di tipo per la classe "{name}"',
        typeArgsMismatchOne: 'Previsto un argomento di tipo, ricevuto {received}',
        typeArgsMissingForAlias: 'Sono previsti argomenti di tipo per l\'alias di tipo generico "{name}"',
        typeArgsMissingForClass: 'Argomenti tipo previsti per la classe generica "{name}"',
        typeArgsTooFew: 'Troppo pochi argomenti tipo forniti per "{name}"; previsto {expected} ma ricevuto {received}',
        typeArgsTooMany: 'Troppi argomenti tipo forniti per "{name}"; previsto {expected} ma ricevuto {received}',
        typeAssignmentMismatch: 'Il tipo "{sourceType}" non è assegnabile al tipo dichiarato "{destType}"',
        typeAssignmentMismatchWildcard: 'Il simbolo di importazione "{name}" ha il tipo "{sourceType}", che non è assegnabile al tipo dichiarato "{destType}"',
        typeCallNotAllowed: 'la chiamata type() non deve essere usata nell\'espressione di tipo',
        typeCheckOnly: '"{name}" è contrassegnato come @type_check_only e può essere utilizzato solo nelle annotazioni tipo',
        typeCommentDeprecated: 'L\'uso dei commenti di type è deprecato. Usare invece l\'annotazione type',
        typeExpectedClass: 'Classe prevista ma ricevuta "{type}"',
        typeFormArgs: '"TypeForm" accetta un singolo argomento posizionale',
        typeGuardArgCount: 'È previsto un singolo argomento di tipo dopo "TypeGuard" o "TypeIs"',
        typeGuardParamCount: 'Le funzioni e i metodi di protezione dei tipi definiti dall\'utente devono avere almeno un parametro di input',
        typeIsReturnType: 'Il tipo restituito di TypeIs ("{returnType}") non è coerente con il tipo di parametro di valore ("{type}")',
        typeNotAwaitable: '"{type}" non è awaitable',
        typeNotIntantiable: 'Non è possibile creare un\'istanza di "{type}"',
        typeNotIterable: '"{type}" non è iterabile',
        typeNotSpecializable: 'Non è stato possibile specializzare il tipo "{type}"',
        typeNotSubscriptable: 'L\'oggetto di tipo "{type}" non è sottoponibile a script',
        typeNotSupportBinaryOperator: 'L\'operatore "{operator}" non è supportato per i tipi "{leftType}" e "{rightType}".',
        typeNotSupportBinaryOperatorBidirectional: 'L\'operatore "{operator}" non è supportato per i tipi "{leftType}" e "{rightType}" quando il tipo previsto è "{expectedType}"',
        typeNotSupportUnaryOperator: 'Operatore "{operator}" non supportato per il tipo "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'L\'operatore "{operator}" non è supportato per il tipo "{type}" quando il tipo previsto è "{expectedType}"',
        typeNotUsableWith: 'Impossibile utilizzare l\'oggetto di tipo "{type}" con "with" perché non implementa {method}',
        typeParameterBoundNotAllowed: 'Il vincolo o il binding non possono essere usati con un parametro di tipo variadic o ParamSpec',
        typeParameterConstraintTuple: 'Il vincolo del parametro di tipo deve essere una tupla di due o più tipi',
        typeParameterExistingTypeParameter: 'Il parametro di tipo "{name}" è già in uso',
        typeParameterNotDeclared: 'Il parametro di tipo "{name}" non è incluso nell\'elenco dei parametri di tipo per "{container}"',
        typeParametersMissing: 'È necessario specificare almeno un parametro di tipo',
        typePartiallyUnknown: 'Tipo di "{name}" parzialmente sconosciuto',
        typeUnknown: 'Il tipo di "{name}" è sconosciuto',
        typeVarAssignedName: 'TypeVar deve essere assegnato a una variabile denominata "{name}"',
        typeVarAssignmentMismatch: 'Non è possibile assegnare il tipo "{type}" alla variabile di tipo "{name}"',
        typeVarBoundAndConstrained: 'TypeVar non può essere contemporaneamente associato e vincolato',
        typeVarBoundGeneric: 'Il tipo associato a TypeVar non può essere generico',
        typeVarConstraintGeneric: 'Il tipo di vincolo TypeVar non può essere generico',
        typeVarDefaultBoundMismatch: 'Il tipo predefinito TypeVar deve essere un sottotipo del tipo associato',
        typeVarDefaultConstraintMismatch: 'Il tipo predefinito TypeVar deve essere uno dei tipi vincolati',
        typeVarDefaultIllegal: 'I tipi predefiniti delle variabili di tipo richiedono Python 3.13 o versione successiva',
        typeVarDefaultInvalidTypeVar: 'Il parametro di tipo "{name}" ha un tipo predefinito che fa riferimento a una o più variabili di tipo non compreso nell\'ambito',
        typeVarFirstArg: 'Nome previsto di TypeVar come primo argomento',
        typeVarInvalidForMemberVariable: 'Il tipo di attributo non può usare la variabile di tipo "{name}" con ambito del metodo locale',
        typeVarNoMember: 'TypeVar "{type}" non ha alcun attributo "{name}"',
        typeVarNotSubscriptable: 'TypeVar "{type}" non sottoponibile a script',
        typeVarNotUsedByOuterScope: 'La variabile di tipo "{name}" non ha significato in questo contesto',
        typeVarPossiblyUnsolvable: 'La variabile di tipo "{name}" potrebbe non essere risolta se il chiamante non fornisce alcun argomento per il parametro "{param}"',
        typeVarSingleConstraint: 'TypeVar deve contenere almeno due tipi vincolati',
        typeVarTupleConstraints: 'TypeVarTuple non può avere vincoli di valore',
        typeVarTupleContext: 'TypeVarTuple non è consentito in questo contesto',
        typeVarTupleDefaultNotUnpacked: 'Il tipo predefinito TypeVarTuple deve essere un tuple non compresso o TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'L\'operatore Decomprimi è obbligatorio per il valore TypeVarTuple',
        typeVarTupleUnknownParam: '"{name}" è un parametro sconosciuto per TypeVarTuple',
        typeVarUnknownParam: '"{name}" è un parametro sconosciuto per TypeVar',
        typeVarUsedByOuterScope: 'TypeVar "{name}" già in uso da un ambito esterno',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" viene visualizzato una sola volta nella firma della funzione generica',
        typeVarVariance: 'TypeVar non può essere covariante e controvariante',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}" ha un valore predefinito e non può seguire TypeVarTuple "{variadicName}"',
        typeVarWithoutDefault: '"{name}" non può essere visualizzato dopo "{other}" nell\'elenco dei parametri del tipo, perché non ha un tipo predefinito',
        typeVarsNotInGenericOrProtocol: 'Generic[] o Protocol[] deve includere tutte le variabili di tipo',
        typedDictAccess: 'Non è stato possibile accedere all\'elemento in TypedDict',
        typedDictAssignedName: 'TypedDict deve essere assegnato a una variabile denominata "{name}"',
        typedDictBadVar: 'Le classi TypedDict possono contenere solo annotazioni di tipo',
        typedDictBaseClass: 'Anche tutte le classi di base per le classi TypedDict devono essere classi TypedDict',
        typedDictBoolParam: 'È previsto che il parametro "{name}" abbia il valore True o False',
        typedDictClosedExtras: 'La classe di base "{name}" è un TypedDict closed; gli elementi aggiuntivi devono essere di tipo "{type}"',
        typedDictClosedNoExtras: 'La classe di base "{name}" è un TypedDict closed; elementi aggiuntivi non consentiti',
        typedDictDelete: 'Non è stato possibile eliminare l\'elemento in TypedDict',
        typedDictEmptyName: 'I nomi all\'interno di un TypedDict non possono essere vuoti',
        typedDictEntryName: 'Valore letterale stringa previsto per il nome della voce del dizionario',
        typedDictEntryUnique: 'I nomi all\'interno di un dizionario devono essere univoci',
        typedDictExtraArgs: 'Argomenti TypedDict aggiuntivi non supportati',
        typedDictExtraItemsClosed: 'TypedDict non può avere il valore “closed” se supporta elementi aggiuntivi',
        typedDictFieldNotRequiredRedefinition: 'Non è possibile ridefinire il campo TypedDict "{name}" come NotRequired',
        typedDictFieldReadOnlyRedefinition: 'Non è possibile ridefinire l’elemento TypedDict "{name}" come ReadOnly',
        typedDictFieldRequiredRedefinition: 'Non è possibile ridefinire il campo TypedDict "{name}" come Required',
        typedDictFirstArg: 'È previsto il nome della classe TypedDict come primo argomento',
        typedDictInClassPattern: 'Classe TypedDict non consentita nel modello di classe',
        typedDictInitsubclassParameter: 'TypedDict non supporta __init_subclass__ parametro “{name}”',
        typedDictNotAllowed: '"TypedDict" non può essere usato in questo contesto',
        typedDictSecondArgDict: 'Previsto parametro dict o keyword come secondo parametro',
        typedDictSecondArgDictEntry: 'Voce di dizionario semplice prevista',
        typedDictSet: 'Non è stato possibile assegnare l\'elemento in TypedDict',
        unaccessedClass: 'La classe "{name}" non è accessibile',
        unaccessedFunction: 'La classe "{name}" non è accessibile',
        unaccessedImport: 'Non è possibile accedere all\'importazione "{name}"',
        unaccessedSymbol: 'Non è possibile accedere a "{name}"',
        unaccessedVariable: 'La variabile "{name}" non è accessibile',
        unannotatedFunctionSkipped: 'L\'analisi della funzione "{name}" è stata ignorata perché non è annotata',
        unaryOperationNotAllowed: 'Operatore unario non consentito nell\'espressione di tipo',
        unexpectedAsyncToken: 'È previsto che "def", "with" o "for" seguano "async"',
        unexpectedExprToken: 'Token imprevisto alla fine dell\'espressione',
        unexpectedIndent: 'Rientro imprevisto',
        unexpectedUnindent: 'Riduci rientro non previsto',
        unhashableDictKey: 'La chiave del dizionario deve essere hashable',
        unhashableSetEntry: 'La voce set deve essere hashable',
        uninitializedAbstractVariables: 'Le variabili definite nella classe di base astratta non vengono inizializzate nella classe finale "{classType}"',
        uninitializedInstanceVariable: 'La variabile di istanza "{name}" non è inizializzata nel corpo della classe o nel metodo __init__',
        unionForwardReferenceNotAllowed: 'Impossibile utilizzare la sintassi di Union con l\'operando stringa. Usare virgolette intorno all\'intera espressione',
        unionSyntaxIllegal: 'La sintassi alternativa per le unioni richiede Python 3.10 o versione successiva',
        unionTypeArgCount: 'Unione richiede due o più argomenti di tipo',
        unionUnpackedTuple: 'Union non può includere un tuple decompresso',
        unionUnpackedTypeVarTuple: 'Union non può includere un TypeVarTuple non compresso',
        unnecessaryCast: 'Chiamata "cast" non necessaria; il tipo è già "{type}"',
        unnecessaryIsInstanceAlways: 'Chiamata isinstance non necessaria; "{testType}" è sempre un\'istanza di "{classType}"',
        unnecessaryIsInstanceNever: 'Chiamata isinstance non necessaria; "{testType}" non è mai un\'istanza di "{classType}"',
        unnecessaryIsSubclassAlways: 'Chiamata issubclass non necessaria; "{testType}" è sempre una sottoclasse di "{classType}"',
        unnecessaryIsSubclassNever: 'Chiamata issubclass non necessaria; "{testType}" non è mai una sottoclasse di "{classType}"',
        unnecessaryPyrightIgnore: 'Commento "# pyright: ignore" non necessario',
        unnecessaryPyrightIgnoreRule: 'Regola "# pyright: ignore" non necessaria: "{name}"',
        unnecessaryTypeIgnore: 'Commento "# type: ignore" non necessario',
        unpackArgCount: 'Previsto un singolo argomento di tipo dopo "Unpack"',
        unpackExpectedTypeVarTuple: 'È previsto TypeVarTuple o tuple come argomento di tipo per Unpack',
        unpackExpectedTypedDict: 'Previsto argomento di tipo TypedDict per Unpack',
        unpackIllegalInComprehension: 'Operazione di decompressione non consentita nella comprensione',
        unpackInAnnotation: 'Operatore di decompressione non consentito nell\'espressione di tipo',
        unpackInDict: 'Operazione di decompressione non consentita nei dizionari',
        unpackInSet: 'Operatore di decompressione non consentito all’interno di un set',
        unpackNotAllowed: 'Unpack non è consentito in questo contesto',
        unpackOperatorNotAllowed: 'L’operazione di decompressione non è consentita in questo contesto',
        unpackTuplesIllegal: 'L\'operazione di decompressione non è consentita nelle tuple precedenti a Python 3.8',
        unpackedArgInTypeArgument: 'Non è possibile usare argomenti decompressi in questo contesto',
        unpackedArgWithVariadicParam: 'Non è possibile usare l\'argomento decompresso per il parametro TypeVarTuple',
        unpackedDictArgumentNotMapping: 'L\'espressione dell\'argomento dopo ** deve essere un mapping con un tipo di chiave "str"',
        unpackedDictSubscriptIllegal: 'L\'operatore di decompressione del dizionario nel pedice non è consentito',
        unpackedSubscriptIllegal: 'L\'operatore di decompressione nel pedice richiede Python 3.11 o versione successiva',
        unpackedTypeVarTupleExpected: 'Previsto TypeVarTuple decompresso; usa Unpack[{name1}] o *{name2}',
        unpackedTypedDictArgument: 'Impossibile trovare una corrispondenza tra l\'argomento TypedDict non compresso e i parametri',
        unreachableCode: 'Il codice non è raggiungibile',
        unreachableCodeType: 'L’analisi dei tipi indica che il codice non è raggiungibile.',
        unreachableExcept: 'La clausola Except non è raggiungibile perché l\'eccezione è già gestita',
        unsupportedDunderAllOperation: 'L\'operazione su "__all__" non è supportata, di conseguenza l\'elenco dei simboli esportati potrebbe non essere corretto',
        unusedCallResult: 'Il risultato dell\'espressione di chiamata è di tipo "{type}" e non è usato. Assegnare alla variabile "_" se è intenzionale',
        unusedCoroutine: 'Il risultato della chiamata alla funzione async non viene usato. Usare "await" o assegnare il risultato alla variabile',
        unusedExpression: 'Il valore dell\'espressione non è utilizzato',
        varAnnotationIllegal: 'Le annotazioni type per le variabili richiedono Python 3.6 o versione successiva. Usare il commento di type per la compatibilità con le versioni precedenti',
        variableFinalOverride: 'La variabile "{name}" è contrassegnata come Final ed esegue l\'override della variabile non Final con lo stesso nome nella classe "{className}"',
        variadicTypeArgsTooMany: 'L\'elenco di argomenti del tipo può contenere al massimo un tuple o TypeVarTuple non compresso',
        variadicTypeParamTooManyAlias: 'L\'alias di tipo può avere al massimo un parametro di tipo TypeVarTuple, ma ne ha ricevuti più ({names})',
        variadicTypeParamTooManyClass: 'La classe generica può avere al massimo un parametro di tipo TypeVarTuple, ma ne ha ricevuti più ({names})',
        walrusIllegal: 'L\'operatore ":=" richiede Python 3.8 o versione successiva',
        walrusNotAllowed: 'L\'operatore ":=" non è consentito in questo contesto senza parentesi circostanti',
        wildcardInFunction: 'Wildcard import non consentito all\'interno di una classe o di una funzione',
        wildcardLibraryImport: 'Wildcard import da una libreria non consentito',
        wildcardPatternTypePartiallyUnknown: 'Il tipo acquisito dal modello con caratteri jolly è parzialmente sconosciuto',
        wildcardPatternTypeUnknown: 'Il tipo acquisito dal criterio con caratteri jolly è sconosciuto',
        yieldFromIllegal: 'L\'uso di "yield from" richiede Python 3.3 o versione successiva',
        yieldFromOutsideAsync: '"yield from" non consentito in una funzione async',
        yieldOutsideFunction: '"yield" non consentito all\'esterno di una funzione o di un\'espressione lambda',
        yieldWithinComprehension: '"yield" non consentito all\'interno di una comprensione',
        zeroCaseStatementsFound: 'L’istruzione Match deve includere almeno un’istruzione case',
        zeroLengthTupleNotAllowed: 'Zero-length tuple is not allowed in this context'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Non è possibile usare il modulo speciale "Annotated" con controlli di istanza e classe',
        argParam: 'L\'argomento corrisponde al parametro "{paramName}"',
        argParamFunction: 'L\'argomento corrisponde al parametro "{paramName}" nella funzione "{functionName}"',
        argsParamMissing: 'Il parametro "*{paramName}" non ha un parametro corrispondente',
        argsPositionOnly: 'Parametro di sola posizione non corrispondente; previsto {expected} ma ricevuto {received}',
        argumentType: 'Il tipo di argomento è "{type}"',
        argumentTypes: 'Tipi di argomento: ({types})',
        assignToNone: 'Il tipo non è assegnabile a "None"',
        asyncHelp: 'Intendevi "async with"?',
        baseClassIncompatible: 'La classe base "{baseClass}" non è compatibile con il tipo "{type}"',
        baseClassIncompatibleSubclass: 'La classe base "{baseClass}" deriva da "{subclass}", che non è compatibile con il tipo "{type}"',
        baseClassOverriddenType: 'La classe di base "{baseClass}" fornisce il tipo "{type}", di cui viene eseguito l\'override',
        baseClassOverridesType: 'Override della classe base "{baseClass}" con tipo "{type}"',
        bytesTypePromotions: 'Imposta disableBytesTypePromotions su false per abilitare il comportamento di innalzamento di livello del tipo per "bytearray" e "memoryview"',
        conditionalRequiresBool: 'Il metodo __bool__ per il tipo "{operandType}" restituisce il tipo "{boolReturnType}" anziché "bool"',
        dataClassFieldLocation: 'Dichiarazione di campo',
        dataClassFrozen: '"{name}" è bloccato',
        dataProtocolUnsupported: '“{name}” è un protocollo dati',
        descriptorAccessBindingFailed: 'Impossibile associare il metodo "{name}" per la classe descrittore "{className}"',
        descriptorAccessCallFailed: 'Impossibile chiamare il metodo "{name}" per la classe descrittore "{className}"',
        finalMethod: 'Metodo Final',
        functionParamDefaultMissing: 'Nel parametro "{name}" manca un argomento predefinito',
        functionParamName: 'Nome del parametro non corrispondente: "{destName}" rispetto a "{srcName}"',
        functionParamPositionOnly: 'Parametro di sola posizione non corrispondente; il parametro “{name}” non è di sola posizione',
        functionReturnTypeMismatch: 'Il tipo restituito della funzione"{sourceType}" non è compatibile con il tipo "{destType}"',
        functionTooFewParams: 'La funzione accetta un numero insufficiente di parametri posizionale. Previsto {expected} ma ricevuto {received}',
        functionTooManyParams: 'La funzione accetta un numero eccessivo di parametri posizionale. Previsto {expected} ma ricevuto {received}',
        genericClassNotAllowed: 'Tipo generico con argomenti di tipo non consentiti per i controlli di istanza o classe',
        incompatibleDeleter: 'Il metodo deleter di Property non è compatibile',
        incompatibleGetter: 'Il metodo getter di Property non è compatibile',
        incompatibleSetter: 'Il metodo setter di Property non è compatibile',
        initMethodLocation: 'Il metodo __init__ è definito nella classe "{type}"',
        initMethodSignature: 'Firma del __init__ "{type}"',
        initSubclassLocation: 'Il metodo __init_subclass__ è definito nella classe "{name}"',
        invariantSuggestionDict: 'Prova a passare da "dict" a "Mapping", che è covariante nel tipo di valore',
        invariantSuggestionList: 'Prova a passare da "list" a "Sequence", che è covariante',
        invariantSuggestionSet: 'Prova a passare da "set" a "Container", che è covariante',
        isinstanceClassNotSupported: '"{type}" non è supportata per i controlli delle istanze e delle classi',
        keyNotRequired: '"{name}" non è una chiave obbligatoria in "{type}", quindi l\'accesso potrebbe causare un\'eccezione di runtime',
        keyReadOnly: '"{name}" è una chiave di sola lettura in "{type}"',
        keyRequiredDeleted: '"{name}" è una chiave obbligatoria e non può essere eliminata',
        keyUndefined: '"{name}" non è una chiave definita in "{type}"',
        kwargsParamMissing: 'Il parametro "**{paramName}" non ha un parametro corrispondente',
        listAssignmentMismatch: 'Il tipo "{type}" non è compatibile con l\'elenco di destinazione',
        literalAssignmentMismatch: '"{sourceType}" non è assegnabile al tipo "{destType}"',
        matchIsNotExhaustiveHint: 'Se la gestione completa non è prevista, aggiungere "case _: pass"',
        matchIsNotExhaustiveType: 'Tipo non gestito: "{type}"',
        memberAssignment: 'L\'espressione di tipo "{type}" non può essere assegnata all\'attributo "{name}" della classe "{classType}".',
        memberIsAbstract: '"{type}.{name}" non implementato',
        memberIsAbstractMore: 'e {{count}} altro...',
        memberIsClassVarInProtocol: '“{name}” è definito come ClassVar nel protocollo',
        memberIsInitVar: '"{name}" è un campo di init-only',
        memberIsInvariant: '"{name}" è invariante perché modificabile',
        memberIsNotClassVarInClass: '"{name}" deve essere definito come ClassVar per essere compatibile con il protocollo',
        memberIsNotClassVarInProtocol: '“{name}” non è definito come ClassVar nel protocollo',
        memberIsNotReadOnlyInProtocol: '"{name}" non è di sola lettura nel protocollo',
        memberIsReadOnlyInProtocol: '"{name}" è di sola lettura nel protocollo',
        memberIsWritableInProtocol: '"{name}" è scrivibile nel protocollo',
        memberSetClassVar: 'Non è possibile assegnare l\'attributo "{name}" tramite un\'istanza di classe perché è una ClassVar',
        memberTypeMismatch: '"{name}" è un tipo non compatibile',
        memberUnknown: 'L\'attributo "{name}" è sconosciuto',
        metaclassConflict: 'La metaclasse "{metaclass1}" è in conflitto con "{metaclass2}"',
        missingDeleter: 'Metodo deleter di Property mancante',
        missingGetter: 'Metodo getter di Property mancante',
        missingSetter: 'Metodo setter di Property mancante',
        namedParamMissingInDest: 'Parametro aggiuntivo “{name}”',
        namedParamMissingInSource: 'Parametro della parola chiave “{name}” mancante',
        namedParamTypeMismatch: 'Il parametro "{name}" della parola chiave di tipo "{sourceType}" non è compatibile con il tipo "{destType}"',
        namedTupleNotAllowed: 'Non è possibile usare NamedTuple per i controlli di istanze o classi',
        newMethodLocation: 'Il metodo __new__ è definito nella classe "{type}"',
        newMethodSignature: 'La firma del __new__ è "{type}"',
        newTypeClassNotAllowed: 'Impossibile utilizzare la classe creata con NewType con controlli di classe e di istanza',
        noOverloadAssignable: 'Nessuna funzione di overload corrisponde al tipo "{type}"',
        noneNotAllowed: 'Non è possibile usare None per i controlli di istanze o classi',
        orPatternMissingName: 'Nomi mancanti: {name}',
        overloadIndex: 'L\'overload {index} è la corrispondenza più vicina',
        overloadNotAssignable: 'Uno o più overload di "{name}" non sono assegnabili',
        overloadSignature: 'La firma di overload è definita qui',
        overriddenMethod: 'Metodo sottoposto a override',
        overriddenSymbol: 'Simbolo sottoposto a override',
        overrideInvariantMismatch: 'Il tipo di override "{overrideType}" non è uguale al tipo di base "{baseType}"',
        overrideIsInvariant: 'La variabile è modificabile, quindi il relativo tipo è invariante',
        overrideNoOverloadMatches: 'Nessuna firma di overload nell\'override è compatibile con il metodo di base',
        overrideNotClassMethod: 'Il metodo di base viene dichiarato come classmethod, ma l\'override non lo è',
        overrideNotInstanceMethod: 'Il metodo di base è dichiarato come metodo di istanza, ma l’override non lo è',
        overrideNotStaticMethod: 'Il metodo di base viene dichiarato come staticmethod, ma l\'override non lo è',
        overrideOverloadNoMatch: 'La sostituzione non gestisce tutti gli overload del metodo di base',
        overrideOverloadOrder: 'Gli overload per il metodo di override devono essere nello stesso ordine del metodo di base',
        overrideParamKeywordNoDefault: 'Parametro della parola chiave "{name}" non corrispondente: il parametro di base ha un valore di argomento predefinito, il parametro di override non è',
        overrideParamKeywordType: 'Tipo del parametro della parola chiave "{name}" non corrispondente: il parametro di base è di tipo "{baseType}", il parametro di override è di tipo "{overrideType}"',
        overrideParamName: 'Nome del parametro {index} non corrispondente: il parametro di base è denominato "{baseName}", il parametro di override è denominato "{overrideName}"',
        overrideParamNameExtra: 'Parametro "{name}" mancante nella base',
        overrideParamNameMissing: 'Parametro "{name}" mancante nell\'override',
        overrideParamNamePositionOnly: 'Mancata corrispondenza del parametro {index}: il parametro di base "{baseName}" è un parametro di parola chiave, il parametro di override è di sola posizione',
        overrideParamNoDefault: 'Parametro "{index}" non corrispondente: il parametro di base ha un valore di argomento predefinito, il parametro di override non è',
        overrideParamType: 'Tipo di parametro {index} non corrispondente: il parametro di base è di tipo "{baseType}", il parametro di override è di tipo "{overrideType}"',
        overridePositionalParamCount: 'Numero di parametri posizionali non corrispondente. Il metodo di base ne ha {baseCount}, ma l\'override ne ha {overrideCount}',
        overrideReturnType: 'Tipo restituito non corrispondente: il metodo di base restituisce il tipo "{baseType}", l\'override restituisce il tipo "{overrideType}"',
        overrideType: 'La classe di base definisce il tipo come "{type}"',
        paramAssignment: 'Parametro {index}: il tipo "{sourceType}" non è compatibile con il tipo "{destType}"',
        paramSpecMissingInOverride: 'Parametri ParamSpec mancanti nel metodo di override',
        paramType: 'Tipo di parametro "{paramType}"',
        privateImportFromPyTypedSource: 'Importa da "{module}"',
        propertyAccessFromProtocolClass: 'Non è possibile accedere a una proprietà definita all\'interno di una classe di protocollo come variabile di classe',
        propertyMethodIncompatible: 'Il metodo di Property "{name}" non è compatibile',
        propertyMethodMissing: 'Metodo di Property "{name}" mancante nell\'override',
        propertyMissingDeleter: 'Property "{name}" non dispone di un deleter definito',
        propertyMissingSetter: 'Property "{name}" non dispone di un setter definito',
        protocolIncompatible: '"{sourceType}" non è compatibile con il protocollo "{destType}"',
        protocolMemberMissing: '"{name}" non è presente',
        protocolRequiresRuntimeCheckable: 'La classe di Protocol deve essere @runtime_checkable in modo che sia possibile usarla con i controlli di istanza e classe',
        protocolSourceIsNotConcrete: '"{sourceType}" non è un tipo di classe concreto e non può essere assegnato al tipo "{destType}"',
        protocolUnsafeOverlap: 'Gli attributi di “{name}” hanno gli stessi nomi del protocollo',
        pyrightCommentIgnoreTip: 'Usa "# pyright: ignore[<diagnostic rules>]" per eliminare la diagnostica per una singola riga',
        readOnlyAttribute: 'L\'attributo "{name}" è di sola lettura',
        seeClassDeclaration: 'Vedere la dichiarazione di classe',
        seeDeclaration: 'Vedere la dichiarazione',
        seeFunctionDeclaration: 'Vedere la dichiarazione di funzione',
        seeMethodDeclaration: 'Vedere la dichiarazione del metodo',
        seeParameterDeclaration: 'Vedere la dichiarazione del parametro',
        seeTypeAliasDeclaration: 'Vedere la dichiarazione di alias di tipo',
        seeVariableDeclaration: 'Vedere la dichiarazione di variabile',
        tupleAssignmentMismatch: 'Il tipo "{type}" non è compatibile con il tuple di destinazione',
        tupleEntryTypeMismatch: 'Il tipo della voce di Tuple {entry} non è corretto',
        tupleSizeIndeterminateSrc: 'Dimensioni del tuple non corrispondenti; previsto {expected} ma ricevuto indeterminato',
        tupleSizeIndeterminateSrcDest: 'Dimensioni del tuple non corrispondenti; previsto {expected} o più, ma ricevuto indeterminato',
        tupleSizeMismatch: 'Dimensioni tuple non corrispondenti; previsto {expected} ma ricevuto {received}',
        tupleSizeMismatchIndeterminateDest: 'Dimensioni del tuple non corrispondenti; previsto {expected} o più ma ricevuto {received}',
        typeAliasInstanceCheck: 'Non è possibile usare l\'alias di tipo creato con l\'istruzione "type" con controlli di classe e istanza',
        typeAssignmentMismatch: 'Il tipo "{sourceType}" non è assegnabile al tipo "{destType}"',
        typeBound: 'Il tipo "{sourceType}" non è assegnabile al limite superiore "{destType}" per la variabile di tipo "{name}"',
        typeConstrainedTypeVar: 'Il tipo "{type}" non è assegnabile alla variabile di tipo vincolato "{name}"',
        typeIncompatible: '"{sourceType}" non è assegnabile a "{destType}"',
        typeNotClass: '"{type}" non è una classe',
        typeNotStringLiteral: '"{type}" non è un valore letterale stringa',
        typeOfSymbol: 'Il tipo di "{name}" è "{type}"',
        typeParamSpec: 'Il tipo "{type}" non è compatibile con il "{name}" ParamSpec',
        typeUnsupported: 'Il tipo "{type}" non è supportato',
        typeVarDefaultOutOfScope: 'La variabile di tipo "{name}" non è nell\'ambito',
        typeVarIsContravariant: 'Il parametro di tipo "{name}" è controvariante, ma "{sourceType}" non è un supertipo di "{destType}"',
        typeVarIsCovariant: 'Il parametro di tipo "{name}" è covariante, ma "{sourceType}" non è un sottotipo di "{destType}"',
        typeVarIsInvariant: 'Il parametro di tipo "{name}" è invariante, ma "{sourceType}" non è uguale a "{destType}"',
        typeVarNotAllowed: 'TypeVar non consentito per i controlli di istanze o classi',
        typeVarTupleRequiresKnownLength: 'Non è possibile associare TypeVarTuple a un tuple di lunghezza sconosciuta',
        typeVarUnnecessarySuggestion: 'Usare invece {type}',
        typeVarUnsolvableRemedy: 'Specificare un overload che specifica il tipo restituito quando l\'argomento non viene fornito',
        typeVarsMissing: 'Variabili di tipo mancanti: {names}',
        typedDictBaseClass: 'La classe "{type}" non è un TypedDict',
        typedDictClassNotAllowed: 'Classe TypedDict non consentita per i controlli di istanze o classi',
        typedDictClosedExtraNotAllowed: 'Non è possibile aggiungere l\'elemento "{name}"',
        typedDictClosedExtraTypeMismatch: 'Non è possibile aggiungere l\'elemento "{name}" con tipo "{type}"',
        typedDictClosedFieldNotRequired: 'Non è possibile aggiungere l\'elemento "{name}" perché deve essere NotRequired',
        typedDictExtraFieldNotAllowed: '"{name}" non è presente in "{type}"',
        typedDictExtraFieldTypeMismatch: 'Il tipo di "{name}" non è compatibile con il tipo ""extra_items" in "{type}"',
        typedDictFieldMissing: '"{name}" mancante nel "{type}"',
        typedDictFieldNotReadOnly: '"{name}" non è di sola lettura in "{type}"',
        typedDictFieldNotRequired: '"{name}" non è obbligatorio in "{type}"',
        typedDictFieldRequired: '"{name}" è obbligatorio in "{type}"',
        typedDictFieldTypeMismatch: 'Il tipo "{type}" non può essere assegnato all’elemento "{name}"',
        typedDictFieldUndefined: '"{name}" è un elemento non definito nel tipo "{type}"',
        typedDictFinalMismatch: '"{sourceType}" non è compatibile con "{destType}" a causa di una @final mancata corrispondenza',
        typedDictKeyAccess: 'Usare ["{name}"] per fare riferimento all\'elemento in TypedDict',
        typedDictNotAllowed: 'Non è possibile usare TypedDict per i controlli di istanze o classi',
        unhashableType: 'Il tipo "{type}" non è hashable',
        uninitializedAbstractVariable: 'La variabile di istanza "{name}" è definita nella classe di base astratta "{classType}" ma non è inizializzata',
        unreachableExcept: '"{exceptionType}" è una sottoclasse di "{parentType}"',
        useDictInstead: 'Usare Dict[T1, T2] per indicare un tipo di dizionario',
        useListInstead: 'Usare List[T] per indicare un tipo di list o Union[T1, T2] per indicare un tipo di unione',
        useTupleInstead: 'Usare tuple[T1, ..., Tn] per indicare un tipo di tuple o Union[T1, T2] per indicare un tipo di unione',
        useTypeInstead: 'In alternativa, usare Type[T]',
        varianceMismatchForClass: 'La varianza dell\'argomento tipo "{typeVarName}" non è compatibile con la classe di base "{className}"',
        varianceMismatchForTypeAlias: 'La varianza dell\'argomento tipo "{typeVarName}" non è compatibile con "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'L’enumerazione dei file di origine dell’area di lavoro sta richiedendo tempo. Provare ad aprire una sottocartella. [Altre informazioni](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  3879: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: '型 Stub を作成する',
        createTypeStubFor: '"{moduleName}" の型 Stub を作成する',
        executingCommand: 'コマンドの実行中',
        filesToAnalyzeCount: '分析する {count} 個のファイル',
        filesToAnalyzeOne: '分析する 1 つのファイル',
        findingReferences: '参照を検索しています',
        organizeImports: 'インポートを整理',
        renameShadowedFile: '"{oldFile}" の名前を "{newFile}" に変更します'
      },
      Completion: {
        autoImportDetail: '自動インポート',
        indexValueDetail: 'インデックス値'
      },
      Diagnostic: {
        abstractMethodInvocation: 'メソッド "{method}" は抽象メソッドであり、実装されていないため、呼び出すことができません',
        annotatedMetadataInconsistent: '注釈付きのメタデータ型 "{metadataType}" は型 "{type}" と互換性がありません',
        annotatedParamCountMismatch: 'パラメーター注釈数の不一致: {expected} が必要ですが、{received} を受信しました',
        annotatedTypeArgMissing: '"Annotated" には 1 つの型引数と 1 つ以上の注釈が必要です',
        annotationBytesString: '型式では、バイト文字列リテラルは使用できません',
        annotationFormatString: '型式では、書式指定文字列リテラル (f 文字列) を使用できません',
        annotationNotSupported: 'このステートメントでは型注釈はサポートされていません',
        annotationRawString: '型式では、生文字列リテラルは使用できません',
        annotationSpansStrings: '型式は複数の文字列リテラルにまたがることはできません',
        annotationStringEscape: '型式にエスケープ文字を含めることはできません',
        argAssignment: '型 "{argType}" の引数を型 "{paramType}" のパラメーターに割り当てることはできません',
        argAssignmentFunction: '型 "{argType}" の引数を関数 "{functionName}" の型 "{paramType}" のパラメーターに割り当てることはできません',
        argAssignmentParam: '型 "{argType}" の引数を型 "{paramType}" のパラメーター "{paramName}" に割り当てることはできません',
        argAssignmentParamFunction: '型 "{argType}" の引数を、関数 "{functionName}" の型 "{paramType}" のパラメーター "{paramName}" に割り当てることはできません',
        argMissingForParam: 'パラメーター {name} に引数がありません',
        argMissingForParams: 'パラメーター {names} に引数がありません',
        argMorePositionalExpectedCount: 'さらに {expected} 個の位置引数が必要です',
        argMorePositionalExpectedOne: 'さらに 1 つの位置引数が必要です',
        argPositional: '必要な位置引数',
        argPositionalExpectedCount: '{expected} 個の位置引数が必要です',
        argPositionalExpectedOne: '1 個の位置引数が必要です',
        argTypePartiallyUnknown: '引数の型が部分的に不明です',
        argTypeUnknown: '引数の型が不明です',
        assertAlwaysTrue: 'Assert 式は常に true に評価されます',
        assertTypeArgs: '"assert_type" には 2 つの位置引数が必要です',
        assertTypeTypeMismatch: '"assert_type" の不一致: "{expected}" が必要ですが、"{received}" を受信しました',
        assignmentExprComprehension: '代入式のターゲット "{name}" は、ターゲットの理解と同じ名前を使用できません',
        assignmentExprContext: '代入式は、モジュール、関数、またはラムダ内に存在する必要があります',
        assignmentExprInSubscript: '下付き文字内の代入式は、Python 3.10 以降でのみサポートされます',
        assignmentInProtocol: 'Protocol クラス内のインスタンス変数またはクラス変数は、クラス本体内で明示的に宣言する必要があります',
        assignmentTargetExpr: '式を代入先にすることはできません',
        asyncNotInAsyncFunction: 'async 関数の外部では "async" の使用は許可されていません',
        awaitIllegal: '"await" を使用するには Python 3.5 以降が必要です',
        awaitNotAllowed: '型式では、"await" は使用できません',
        awaitNotInAsync: '"await" は async 関数内でのみ許可されます',
        backticksIllegal: 'バッククォートで囲まれた式は、Python 3.x ではサポートされていません。代わりに repr を使用してください',
        baseClassCircular: 'クラス自体から派生することはできません',
        baseClassFinal: '基底クラス "{type}" は final とマークされており、サブクラス化できません',
        baseClassIncompatible: '{type} の基底クラスは相互に互換性がありません',
        baseClassInvalid: 'クラスへの引数は基底クラスである必要があります',
        baseClassMethodTypeIncompatible: '"{classType}" の基底クラスは、互換性のない方法でメソッド "{name}" を定義します',
        baseClassUnknown: '基底クラスの型が不明で、派生クラスの型が不明です',
        baseClassVariableTypeIncompatible: 'クラス "{classType}" の基底クラスは、互換性のない方法で変数 "{name}" を定義します',
        binaryOperationNotAllowed: '2 項演算子は型式では使用できません',
        bindTypeMismatch: '"{type}" がパラメーター "{paramName}" に割り当てできないため、メソッド "{methodName}" をバインドできませんでした',
        breakInExceptionGroup: '"except*" ブロックでは "break" を使用できません',
        breakOutsideLoop: '"break" はループ内でのみ使用できます',
        callableExtraArgs: '"Callable" に必要な型引数は 2 つだけです',
        callableFirstArg: 'パラメーターの型リストまたは "..." が必要です。',
        callableNotInstantiable: '型 "{type}" をインスタンス化できません',
        callableSecondArg: '"Callable" の 2 番目の型引数として戻り値の型が必要です',
        casePatternIsIrrefutable: '参照不可能なパターンは、最後の case ステートメントに対してのみ許可されます',
        classAlreadySpecialized: '型 "{type}" は既に特殊化されています',
        classDecoratorTypeUnknown: '型指定されていないクラス デコレーターはクラスの型を隠します。デコレーターを無視する',
        classDefinitionCycle: '"{name}" のクラス定義は、それ自体に依存します',
        classGetItemClsParam: '__class_getitem__ override は "cls" パラメーターを受け取る必要があります',
        classMethodClsParam: 'クラス メソッドは "cls" パラメーターを受け取る必要があります',
        classNotRuntimeSubscriptable: 'クラス "{name}" の添字はランタイム例外を生成します。型式を引用符で囲んでください',
        classPatternBuiltInArgPositional: 'クラス パターンは位置指定サブパターンのみを受け入れます',
        classPatternPositionalArgCount: 'クラス "{type}" の位置指定パターンが多すぎます。{expected} が必要ですが、{received} を受信しました',
        classPatternTypeAlias: '"{type}" は特殊な型エイリアスであるため、クラス パターンでは使用できません',
        classPropertyDeprecated: 'クラス プロパティは Python 3.11 では非推奨であり、Python 3.13 ではサポートされなくなります',
        classTypeParametersIllegal: 'クラス型パラメーターの構文には Python 3.12 以降が必要です',
        classVarFirstArgMissing: '"ClassVar" の後に型引数が必要です',
        classVarNotAllowed: '"ClassVar" はこのコンテキストでは許可されていません',
        classVarOverridesInstanceVar: 'クラス変数 "{name}" は、クラス "{className}" の同じ名前のインスタンス変数をオーバーライドします',
        classVarTooManyArgs: '"ClassVar" の後に必要な型引数は 1 つだけです',
        classVarWithTypeVar: '"ClassVar" 型に型変数を含めることはできません',
        clsSelfParamTypeMismatch: 'パラメーター "{name}" の型は、そのクラス "{classType}" のスーパータイプである必要があります',
        codeTooComplexToAnalyze: 'コードが複雑すぎるため、分析できません。サブルーチンにリファクタリングするか、条件付きコード パスを減らすことで複雑さを軽減してください',
        collectionAliasInstantiation: '型 "{type}" はインスタンス化できません。代わりに "{alias}" を使用してください',
        comparisonAlwaysFalse: '型 "{leftType}" と "{rightType}" に重複がないため、条件は常に False に評価されます',
        comparisonAlwaysTrue: '型 "{leftType}" と "{rightType}" に重複がないため、条件は常に True に評価されます',
        comprehensionInDict: '他の辞書エントリと共に理解することはできません',
        comprehensionInSet: '読解は他の set エントリと併用できません。',
        concatenateContext: '"Concatenate" はこのコンテキストで許可されていません',
        concatenateParamSpecMissing: '"Concatenate" の最後の型引数は ParamSpec または "..." である必要があります',
        concatenateTypeArgsMissing: '"Concatenate" には少なくとも 2 つの型引数が必要です',
        conditionalOperandInvalid: '型 "{type}" の条件オペランドが無効です',
        constantRedefinition: '"{name}" は定数であり (大文字であるため)、再定義できません',
        constructorParametersMismatch: 'クラス "{classType}" の__new__と__init__のシグネチャの不一致',
        containmentAlwaysFalse: '型 "{leftType}" と "{rightType}" に重複がないため、式は常に False に評価されます',
        containmentAlwaysTrue: '型 "{leftType}" と "{rightType}" に重複がないため、式は常に True に評価されます',
        continueInExceptionGroup: '"except*" ブロックでは "continue" を使用できません',
        continueOutsideLoop: '"continue" はループ内でのみ使用できます',
        coroutineInConditionalExpression: '常に True に評価される条件式参照コルーチン',
        dataClassBaseClassFrozen: '固定されていないクラスは、固定されているクラスから継承できません',
        dataClassBaseClassNotFrozen: '固定されたクラスは、固定されていないクラスから継承できません',
        dataClassConverterFunction: '型 "{argType}" の引数は、型 "{fieldType}" のフィールド "{fieldName}" の有効なコンバーターではありません',
        dataClassConverterOverloads: '{funcName}" のオーバーロードは、型 "{fieldType}" のフィールド "{fieldName}" に対して有効なコンバーターではありません',
        dataClassFieldInheritedDefault: '"{fieldName}" は同じ名前のフィールドをオーバーライドしますが、既定値がありません',
        dataClassFieldWithDefault: '既定値のないフィールドは、既定値を持つフィールドの後に表示できません',
        dataClassFieldWithPrivateName: 'データクラス フィールドはプライベート名を使用できません',
        dataClassFieldWithoutAnnotation: '型注釈のないデータクラス フィールドが原因でランタイム例外が発生する',
        dataClassPostInitParamCount: 'Dataclass __post_init__ パラメーター数が正しくありません。InitVar フィールドの数は {expected} です',
        dataClassPostInitType: 'フィールド "{fieldName}" の Dataclass __post_init__ メソッド パラメーターの型が一致しません',
        dataClassSlotsOverwrite: '__slots__はクラスで既に定義されています',
        dataClassTransformExpectedBoolLiteral: '静的に True または False に評価される式が必要です',
        dataClassTransformFieldSpecifier: 'クラスまたは関数の tuple が必要ですが、型 "{type}" を受け取りました',
        dataClassTransformPositionalParam: '"dataclass_transform" に対するすべての引数はキーワード引数である必要があります',
        dataClassTransformUnknownArgument: '引数 "{name}" はdataclass_transform でサポートされていません',
        dataProtocolInSubclassCheck: 'データ プロトコル (メソッド以外の属性を含む) は、issubclass 呼び出しで使用できません',
        declaredReturnTypePartiallyUnknown: '宣言された戻り値の型 "{returnType}" は部分的に不明です',
        declaredReturnTypeUnknown: '宣言された戻り値の型が不明です',
        defaultValueContainsCall: 'パラメーターの既定値の式内では、関数呼び出しと変更可能なオブジェクトは許可されません',
        defaultValueNotAllowed: '"*" または "**" のパラメーターに既定値を指定することはできません',
        delTargetExpr: '式を削除できません',
        deprecatedClass: 'クラス "{name}" は非推奨です',
        deprecatedConstructor: 'クラス "{name}" のコンストラクターは非推奨です',
        deprecatedDescriptorDeleter: '記述子 "{name}" の "__delete__" メソッドは非推奨です',
        deprecatedDescriptorGetter: '記述子 "{name}" の "__get__" メソッドは非推奨です',
        deprecatedDescriptorSetter: '記述子 "{name}" の "__set__" メソッドは非推奨です',
        deprecatedFunction: '関数 "{name}" は非推奨です',
        deprecatedMethod: 'クラス "{className}" のメソッド "{name}" は非推奨です',
        deprecatedPropertyDeleter: 'The deleter for property "{name}" is deprecated',
        deprecatedPropertyGetter: 'The getter for property "{name}" is deprecated',
        deprecatedPropertySetter: 'The setter for property "{name}" is deprecated',
        deprecatedType: 'この型は Python {version} では非推奨です。代わりに"{replacement}"を使用してください',
        dictExpandIllegalInComprehension: '辞書の展開は理解できません',
        dictInAnnotation: '辞書式は型式では使用できません',
        dictKeyValuePairs: '辞書エントリにはキー/値のペアが含まれている必要があります',
        dictUnpackIsNotMapping: 'ディクショナリ アンパック演算子に必要なマッピング',
        dunderAllSymbolNotPresent: '"{name}" は __all__ で指定されていますが、モジュールには存在しません',
        duplicateArgsParam: '許可される "*" パラメーターは 1 つだけです',
        duplicateBaseClass: '重複する基底クラスは許可されていません',
        duplicateCapturePatternTarget: 'Capture ターゲット "{name}" を同じパターン内に複数回出現させることはできません',
        duplicateCatchAll: '許可される catch-all except 句は 1 つだけです',
        duplicateEnumMember: 'Enum メンバー "{name}" は既に宣言されています',
        duplicateGenericAndProtocolBase: '許可される Generic[...] または Protocol[...] 基底クラスは 1 つだけです',
        duplicateImport: '"{importName}" が複数回インポートされています',
        duplicateKeywordOnly: '"*" 区切り記号を 1 つだけ使用できます',
        duplicateKwargsParam: '許可される "**" パラメーターは 1 つだけです',
        duplicateParam: 'パラメーター "{name}" が重複しています',
        duplicatePositionOnly: '許可される "/" パラメーターは 1 つだけです',
        duplicateStarPattern: 'パターン シーケンスで使用できる "*" パターンは 1 つだけです',
        duplicateStarStarPattern: '許可されている "**" エントリは 1 つだけです',
        duplicateUnpack: 'list 内で許可されるアンパック操作は 1 つのみです',
        ellipsisAfterUnpacked: '"..." はアンパックされた TypeVarTuple または tuple と共に使用することはできません',
        ellipsisContext: '"..." はこのコンテキストでは許可されていません',
        ellipsisSecondArg: '"..." は2 つの引数の 2 番目の引数としてのみ使用できます',
        enumClassOverride: 'Enum クラス "{name}" は final であり、サブクラス化できません',
        enumMemberDelete: 'Enum メンバー "{name}" を削除できません',
        enumMemberSet: 'Enum メンバー "{name}" を割り当てることはできません',
        enumMemberTypeAnnotation: 'Type annotations are not allowed for enum members',
        exceptGroupMismatch: 'Try ステートメントに "except" と "except*" の両方を含めることはできません',
        exceptGroupRequiresType: '例外グループ構文 ("except*") には例外の種類が必要です',
        exceptionGroupIncompatible: '例外グループの構文 ("except*") には Python 3.11 以降が必要です',
        exceptionGroupTypeIncorrect: 'except* の例外型は BaseGroupException から派生できません',
        exceptionTypeIncorrect: '"{type}" は BaseException から派生していません',
        exceptionTypeNotClass: '"{type}" は有効な例外クラスではありません',
        exceptionTypeNotInstantiable: '例外の種類 "{type}" のコンストラクターには 1 つ以上の引数が必要です',
        expectedAfterDecorator: 'デコレーターの後に必要な関数またはクラス宣言',
        expectedArrow: '"->" の後に戻り値の型注釈が続く必要があります',
        expectedAsAfterException: '例外の種類の後に "as" が必要です',
        expectedAssignRightHandExpr: '"=" の右側に式が必要です',
        expectedBinaryRightHandExpr: '演算子の右側に式が必要です',
        expectedBoolLiteral: 'True または False が必要です',
        expectedCase: '"case" ステートメントが必要です',
        expectedClassName: '必要なクラス名',
        expectedCloseBrace: '"{" は閉じられていません',
        expectedCloseBracket: '"[" は閉じられていません',
        expectedCloseParen: '"(" が閉じられませんでした',
        expectedColon: '":" が必要です',
        expectedComplexNumberLiteral: 'パターン マッチングに必要な複素数リテラル',
        expectedDecoratorExpr: 'Python 3.9 より前のデコレーターでは、式フォームはサポートされていません',
        expectedDecoratorName: 'デコレーター名が必要です',
        expectedDecoratorNewline: 'デコレーターの末尾に新しい行が必要です',
        expectedDelExpr: '"del" の後に式が必要です',
        expectedElse: '"else" が必要です',
        expectedEquals: '"=" が必要です',
        expectedExceptionClass: '例外クラスまたはオブジェクトが無効です',
        expectedExceptionObj: '例外オブジェクト、例外クラス、または None が必要です',
        expectedExpr: '式が必要です',
        expectedFunctionAfterAsync: '"async" の後に必要な関数定義',
        expectedFunctionName: '"def" の後に関数名が必要です',
        expectedIdentifier: '必要な識別子',
        expectedImport: '"import" が必要です',
        expectedImportAlias: '"as" の後にシンボルが必要です',
        expectedImportSymbols: '"import" の後に 1 つ以上のシンボル名が必要です',
        expectedIn: '\'in\' が必要です',
        expectedInExpr: '"in" の後に式が必要です',
        expectedIndentedBlock: 'インデントされたブロックが必要です',
        expectedMemberName: '"" の後に属性名が必要です。',
        expectedModuleName: '必要なモジュール名',
        expectedNameAfterAs: '"as" の後にシンボル名が必要です',
        expectedNamedParameter: 'キーワード パラメーターは "*" の後に続く必要があります',
        expectedNewline: '改行が必要です',
        expectedNewlineOrSemicolon: 'ステートメントは改行またはセミコロンで区切る必要があります',
        expectedOpenParen: '"(" が必要です',
        expectedParamName: '必要なパラメーター名',
        expectedPatternExpr: '必要なパターン式',
        expectedPatternSubjectExpr: '必要なパターンの件名の式',
        expectedPatternValue: '"a.b" 形式のパターン値式が必要です',
        expectedReturnExpr: '"return" の後に式が必要です',
        expectedSliceIndex: 'インデックスまたはスライス式が必要です',
        expectedTypeNotString: '必要な型ですが、文字列リテラルを受け取りました',
        expectedTypeParameterName: '必要な型パラメーター名',
        expectedYieldExpr: 'yield ステートメントで必要な式',
        finalClassIsAbstract: 'クラス "{type}" は final とマークされており、すべての抽象なシンボルを実装する必要があります',
        finalContext: '"Final" はこのコンテキストでは許可されていません',
        finalInLoop: '"Final" 変数をループ内で割り当てることはできません',
        finalMethodOverride: 'メソッド "{name}" は、クラス "{className}" で定義されている final メソッドをオーバーライドできません',
        finalNonMethod: '関数 "{name}" はメソッドではないため、@final としてマークできません',
        finalReassigned: '"{name}" は Final として宣言されており、再割り当てできません',
        finalRedeclaration: '"{name}" は以前に Final として宣言されました',
        finalRedeclarationBySubclass: '親クラス "{className}" が Final として宣言しているため、"{name}" を再宣言できません',
        finalTooManyArgs: '"Final" の後に 1 つの型引数が必要です',
        finalUnassigned: '"{name}" は Final と宣言されていますが、値は割り当てされていません',
        formatStringBrace: 'f-string リテラル内では、1 つの閉じかっこは使用できません。二重閉じかっこを使用してください',
        formatStringBytes: '書式指定文字列リテラル (f 文字列) をバイナリにすることはできません',
        formatStringDebuggingIllegal: 'F-string デバッグ指定子 "=" には Python 3.8 以降が必要です',
        formatStringEscape: 'Python 3.12 より前の f-string の式部分ではエスケープ シーケンス (バックスラッシュ) は使用できません',
        formatStringExpectedConversion: 'f-string の "!" の後に変換指定子が必要です',
        formatStringIllegal: '書式文字列リテラル (f 文字列) には Python 3.6 以降が必要です',
        formatStringInPattern: '書式指定文字列はパターンでは使用できません',
        formatStringNestedFormatSpecifier: '書式指定子内で入れ子になった式が深すぎます',
        formatStringNestedQuote: 'f-string 内で入れ子になった文字列は、Python 3.12 より前の f-string と同じ引用符文字を使用できません',
        formatStringUnicode: '書式指定文字列リテラル (f 文字列) を Unicode にすることはできません',
        formatStringUnterminated: 'f-string の式が終了していません。"}" が必要です',
        functionDecoratorTypeUnknown: '型指定されていない関数デコレーターは、関数の型を隠します。デコレーターを無視しています',
        functionInConditionalExpression: '常に True に評価される条件式参照関数',
        functionTypeParametersIllegal: '関数型パラメーターの構文には Python 3.12 以降が必要です',
        futureImportLocationNotAllowed: '__future__ からのインポートは、ファイルの先頭にある必要があります',
        generatorAsyncReturnType: 'async ジェネレーター関数の戻り値の型は、"AsyncGenerator[{yieldType}, Any]" と互換性がある必要があります',
        generatorNotParenthesized: 'ジェネレーター式は、唯一の引数でない場合はかっこで囲む必要があります',
        generatorSyncReturnType: 'ジェネレーター関数の戻り値の型は、"Generator[{yieldType}, Any, Any]" と互換性がある必要があります',
        genericBaseClassNotAllowed: '"Generic" 基底クラスを型パラメーター構文と共に使用することはできません',
        genericClassAssigned: 'ジェネリック クラス型を割り当てることはできません',
        genericClassDeleted: 'ジェネリック クラス型を削除できません',
        genericInstanceVariableAccess: 'クラスを介したジェネリック インスタンス変数へのアクセスがあいまいです',
        genericNotAllowed: '"Generic" はこのコンテキストでは無効です',
        genericTypeAliasBoundTypeVar: 'クラス内のジェネリック型エイリアスはバインドされた型変数 {names} を使用できません',
        genericTypeArgMissing: '"Generic" には少なくとも 1 つの型引数が必要です',
        genericTypeArgTypeVar: '"Generic" の型引数は型変数である必要があります',
        genericTypeArgUnique: '"Generic" の型引数は一意である必要があります',
        globalReassignment: '"{name}" は global 宣言の前に割り当てられます',
        globalRedefinition: '"{name}" は既に global として宣言されています',
        implicitStringConcat: '暗黙的な文字列連結は許可されていません',
        importCycleDetected: 'インポート チェーンで循環が検出されました',
        importDepthExceeded: 'インポート チェーンの深さが {depth} を超えました',
        importResolveFailure: 'インポート "{importName}" を解決できませんでした',
        importSourceResolveFailure: 'インポート "{importName}" をソースから解決できませんでした',
        importSymbolUnknown: '"{name}" は不明なインポート シンボルです',
        incompatibleMethodOverride: 'メソッド "{name}" は互換性のない方法でクラス "{className}" をオーバーライドします',
        inconsistentIndent: '元のサイズが前のインデントと一致しません',
        inconsistentTabs: 'インデントでのタブとスペースの一貫性のない使用',
        initMethodSelfParamTypeVar: '"__init__" メソッドの "self" パラメーターの型注釈に、クラス スコープ型の変数を含めることはできません',
        initMustReturnNone: '"__init__" の戻り値の型は None でなければなりません',
        initSubclassCallFailed: '__init_subclass__ メソッドのキーワード引数が正しくありません',
        initSubclassClsParam: '__init_subclass__ オーバーライドは "cls" パラメーターを受け取る必要があります',
        initVarNotAllowed: '"InitVar" はこのコンテキストでは許可されていません',
        instanceMethodSelfParam: 'インスタンス メソッドは "self" パラメーターを受け取る必要があります',
        instanceVarOverridesClassVar: 'インスタンス変数 "{name}" は、クラス "{className}" の同じ名前のクラス変数をオーバーライドします',
        instantiateAbstract: '抽象クラス "{type}" をインスタンス化できません',
        instantiateProtocol: 'Protocol クラス "{type}" をインスタンス化できません',
        internalBindError: 'ファイル "{file}" のバインド中に内部エラーが発生しました: {message}',
        internalParseError: 'ファイル "{file}" の解析中に内部エラーが発生しました: {message}',
        internalTypeCheckingError: 'ファイル "{file}" の種類チェック中に内部エラーが発生しました: {message}',
        invalidIdentifierChar: '識別子の無効な文字',
        invalidStubStatement: 'ステートメントは、型 stub ファイル内では意味がありません',
        invalidTokenChars: 'トークン内の無効な文字 "{text}"',
        isInstanceInvalidType: '"isinstance" の 2 番目の引数は、クラスまたはクラスの tuple である必要があります',
        isSubclassInvalidType: '"issubclass" の 2 番目の引数は、クラスまたはクラスの tuple である必要があります',
        keyValueInSet: 'キーと値のペアは set 内では使用できません',
        keywordArgInTypeArgument: 'キーワード引数は型引数リストでは使用できません',
        keywordArgShortcutIllegal: 'キーワード引数のショートカットには Python 3.14 以降が必要です',
        keywordOnlyAfterArgs: 'キーワードのみの引数の区切り記号は、"*" パラメーターの後には使用できません',
        keywordParameterMissing: '1 つ以上のキーワード パラメーターが "*" パラメーターの後に続く必要があります',
        keywordSubscriptIllegal: '添字内のキーワード引数はサポートされていません',
        lambdaReturnTypePartiallyUnknown: 'ラムダの戻り値の型、"{returnType}" が部分的に不明です',
        lambdaReturnTypeUnknown: 'ラムダの戻り値の型が不明です',
        listAssignmentMismatch: '型 "{type}" の式をターゲット リストに割り当てることはできません',
        listInAnnotation: 'List 式は型式では使用できません',
        literalEmptyArgs: '"Literal" の後に 1 つ以上の型引数が必要です',
        literalNamedUnicodeEscape: '名前付き Unicode エスケープ シーケンスは、"Literal" 文字列注釈ではサポートされていません',
        literalNotAllowed: '"Literal" は、型引数なしでこのコンテキストでは使用できません',
        literalNotCallable: 'Literal 型はインスタンス化できません',
        literalUnsupportedType: '"Literal" の型引数は None、literal 値 (int、bool、str、または bytes)、または enum 値である必要があります',
        matchIncompatible: 'Match ステートメントには Python 3.10 以降が必要です',
        matchIsNotExhaustive: 'match ステートメント内のケースでは、すべての値が完全に処理されるわけではありません',
        maxParseDepthExceeded: '解析の最大深さを超えました。式を小さい部分式に分割する',
        memberAccess: 'クラス "{type}" の属性 "{name}" にアクセスできません',
        memberDelete: 'クラス "{type}" の属性 "{name}" を削除できません',
        memberSet: 'クラス "{type}" の属性 "{name}" に割り当てることはできません',
        metaclassConflict: '派生クラスのメタクラスは、そのすべての基底クラスのメタクラスのサブクラスである必要があります',
        metaclassDuplicate: '指定できるメタクラスは 1 つだけです',
        metaclassIsGeneric: 'メタクラスをジェネリックにすることはできません',
        methodNotDefined: '"{name}" メソッドが定義されていません',
        methodNotDefinedOnType: '型 "{type}" に "{name}" メソッドが定義されていません',
        methodOrdering: '一貫性のあるメソッドの順序を作成できません',
        methodOverridden: '"{name}" は、クラス "{className}" の同じ名前のメソッドを互換性のない型 "{type}" でオーバーライドします',
        methodReturnsNonObject: '"{name}" メソッドはオブジェクトを返しません',
        missingSuperCall: 'メソッド "{methodName}" は親クラスで同じ名前のメソッドを呼び出しません',
        mixingBytesAndStr: 'Bytes 値と str 値を連結することはできません',
        moduleAsType: 'モジュールを型として使用することはできません',
        moduleNotCallable: 'モジュールは呼び出し可能ではありません',
        moduleUnknownMember: '"{memberName}" はモジュール "{moduleName}" の既知の属性ではありません',
        namedExceptAfterCatchAll: '名前付き except 句は、catch-all except 句の後には使用できません',
        namedParamAfterParamSpecArgs: 'ParamSpec args パラメーターの後にキーワード パラメーター "{name}" をシグネチャに含めることはできません',
        namedTupleEmptyName: '名前付き tuple 内の名前を空にすることはできません',
        namedTupleEntryRedeclared: '親クラス "{className}" が名前付き tuple であるため、"{name}" をオーバーライドできません',
        namedTupleFirstArg: '最初の引数として名前付き tuple クラス名が必要です',
        namedTupleMultipleInheritance: 'NamedTuple による複数の継承はサポートされていません',
        namedTupleNameKeyword: 'フィールド名をキーワードにすることはできません',
        namedTupleNameType: 'エントリ名と型を指定する 2 エントリの tuple が必要です',
        namedTupleNameUnique: '名前付き tuple 内の名前は一意である必要があります',
        namedTupleNoTypes: '"namedtuple" はタプル エントリに型を提供しません。代わりに "NamedTuple" を使用してください',
        namedTupleSecondArg: '2 番目の引数として名前付き tuple エントリ list が必要です',
        newClsParam: '__new__ override は "cls" パラメーターを受け取る必要があります',
        newTypeAnyOrUnknown: 'NewType の 2 番目の引数は、Any や Unknown ではなく、既知のクラスでなければなりません',
        newTypeBadName: 'NewType の最初の引数は文字列リテラルである必要があります',
        newTypeLiteral: 'NewType は Literal 型では使用できません',
        newTypeNameMismatch: 'NewType は同じ名前の変数に割り当てる必要があります',
        newTypeNotAClass: 'NewType の 2 番目の引数としてクラスが必要です',
        newTypeParamCount: 'NewType には 2 つの位置引数が必要です',
        newTypeProtocolClass: 'NewType は構造型 (Protocolまたは TypedDict クラス) では使用できません',
        noOverload: '指定された引数に一致する "{name}" のオーバーロードがありません',
        noReturnContainsReturn: 'Function with declared return type "NoReturn" cannot include a return statement',
        noReturnContainsYield: '戻り値の型 "NoReturn" を宣言した関数に yield ステートメントを含めることはできません',
        noReturnReturnsNone: '戻り値の型が "NoReturn" として宣言されている関数は "None" を返すことができません',
        nonDefaultAfterDefault: '既定以外の引数は既定の引数の後に続きます',
        nonLocalInModule: 'モジュール レベルでは nonlocal 宣言は許可されません',
        nonLocalNoBinding: 'nonlocal "{name}" のバインドが見つかりません',
        nonLocalReassignment: '"{name}" は nonlocal 宣言の前に割り当てられます',
        nonLocalRedefinition: '"{name}" は既に nonlocal として宣言されています',
        noneNotCallable: '"None" 型のオブジェクトを呼び出すことはできません',
        noneNotIterable: '型 "None" のオブジェクトを反復可能な値として使用することはできません',
        noneNotSubscriptable: '"None" 型のオブジェクトは添字可能ではありません',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: '演算子 "{operator}" は "None" ではサポートされていません',
        noneUnknownMember: '"{name}" は "None" の既知の属性ではありません',
        notRequiredArgCount: '"NotRequired" の後に 1 つの型引数が必要です',
        notRequiredNotInTypedDict: '"NotRequired" はこのコンテキストでは許可されていません',
        objectNotCallable: '型 "{type}" のオブジェクトは呼び出し可能ではありません',
        obscuredClassDeclaration: 'クラス宣言 "{name}" は、同じ名前の宣言によって隠されています',
        obscuredFunctionDeclaration: '関数宣言 "{name}" は、同じ名前の宣言によって隠されています',
        obscuredMethodDeclaration: 'メソッド宣言 "{name}" は、同じ名前の宣言によって隠されています',
        obscuredParameterDeclaration: 'パラメーター宣言 "{name}" は、同じ名前の宣言によって隠されています',
        obscuredTypeAliasDeclaration: '型エイリアス宣言 "{name}" は、同じ名前の宣言によって隠されています',
        obscuredVariableDeclaration: '宣言 "{name}" は、同じ名前の宣言によって隠されています',
        operatorLessOrGreaterDeprecated: '演算子 "<>" は Python 3 ではサポートされていません。代わりに "!=" を使用してください',
        optionalExtraArgs: '"Optional" の後に 1 つの型引数が必要です',
        orPatternIrrefutable: '参照不可能なパターンは、"or" パターンの最後のサブパターンとしてのみ許可されます',
        orPatternMissingName: '"or" パターン内のすべてのサブパターンは、同じ名前をターゲットにする必要があります',
        overlappingKeywordArgs: '入力された辞書はキーワード パラメーターと重複しています: {names}',
        overlappingOverload: 'パラメーターがオーバーロード {obscuredBy} と重複しているため、"{name}" のオーバーロード {obscured} は使用されません',
        overloadAbstractImplMismatch: 'オーバーロードは実装の抽象状態と一致する必要があります',
        overloadAbstractMismatch: 'オーバーロードはすべて抽象であるか抽象でない必要があります',
        overloadClassMethodInconsistent: '"{name}" のオーバーロードでは、@classmethod を不整合に使用します',
        overloadFinalInconsistencyImpl: '"{name}" のオーバーロードは @final としてマークされていますが、実装は @final としてマークされていません',
        overloadFinalInconsistencyNoImpl: '"{name}" のオーバーロード {index} は @final としてマークされていますが、オーバーロード 1 は @final としてマークされていません',
        overloadImplementationMismatch: 'オーバーロードされた実装がオーバーロード {index} のシグネチャと一致しません',
        overloadReturnTypeMismatch: '"{name}" のオーバーロード {prevIndex} はオーバーロード {newIndex} と重複し、互換性のない型を返します',
        overloadStaticMethodInconsistent: '"{name}" のオーバーロードでは、@staticmethod を不整合に使用します',
        overloadWithoutImplementation: '"{name}" は overload としてマークされていますが、実装が提供されていません',
        overriddenMethodNotFound: 'メソッド "{name}" は override としてマークされていますが、同じ名前の基本メソッドが存在しません',
        overrideDecoratorMissing: 'メソッド "{name}" は override としてマークされていませんが、クラス "{className}" のメソッドをオーバーライドしています',
        paramAfterKwargsParam: 'パラメーターは "**" パラメーターの後に続けることはできません',
        paramAlreadyAssigned: 'パラメーター "{name}" は既に割り当て済みです',
        paramAnnotationMissing: 'パラメーター "{name}" に型注釈がありません',
        paramAssignmentMismatch: '型 "{sourceType}" の式を型 "{paramType}" のパラメーターに割り当てることはできません',
        paramNameMissing: '"{name}" という名前のパラメーターがありません',
        paramSpecArgsKwargsDuplicate: 'ParamSpec "{type}" の引数は既に指定されています',
        paramSpecArgsKwargsUsage: 'ParamSpec の "args" 属性と "kwargs" 属性の両方が関数シグネチャ内に含まれている必要があります',
        paramSpecArgsMissing: 'ParamSpec "{type}" の引数がありません',
        paramSpecArgsUsage: 'ParamSpec の "args" 属性は、*args パラメーターと共に使用する場合にのみ有効です',
        paramSpecAssignedName: 'ParamSpec は 、"{name}" という名前の変数に割り当てる必要があります',
        paramSpecContext: 'ParamSpec はこのコンテキストでは許可されていません',
        paramSpecDefaultNotTuple: 'ParamSpec の既定値には、省略記号、tuple 式、または ParamSpec が必要です',
        paramSpecFirstArg: '最初の引数として ParamSpec の名前が必要です',
        paramSpecKwargsUsage: 'ParamSpec の "kwargs" 属性は、**kwargs パラメーターと共に使用する場合にのみ有効です',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" はこのコンテキストでは意味がありません',
        paramSpecUnknownArg: 'ParamSpec は複数の引数をサポートしていません',
        paramSpecUnknownMember: '"{name}" は ParamSpec の既知の属性ではありません',
        paramSpecUnknownParam: '"{name}" は ParamSpec に対する不明なパラメーターです',
        paramTypeCovariant: '共変の型変数はパラメーター型では使用できません',
        paramTypePartiallyUnknown: 'パラメーター "{paramName}" の型が部分的に不明です',
        paramTypeUnknown: 'パラメーター "{paramName}" の型が不明です',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'サブジェクトの種類 "{type}" のパターンは一致しません',
        positionArgAfterNamedArg: 'キーワード引数の後に位置引数を指定することはできません',
        positionOnlyAfterArgs: '"*" パラメーターの後に位置のみのパラメーターの区切り文字を使用することはできません',
        positionOnlyAfterKeywordOnly: '"/" パラメーターは 、"*" パラメーターの前に指定する必要があります',
        positionOnlyAfterNon: '位置のみのパラメーターの後に位置のみのパラメーターを指定することはできません',
        positionOnlyFirstParam: '位置のみのパラメーターの区切り記号を最初のパラメーターとして使用することはできません',
        positionOnlyIncompatible: '位置のみのパラメーターの区切り文字には Python 3.8 以降が必要です',
        privateImportFromPyTypedModule: '"{name}" はモジュール "{module}" からエクスポートされていません',
        privateUsedOutsideOfClass: '"{name}" はプライベートであり、宣言されているクラスの外部で使用されます',
        privateUsedOutsideOfModule: '"{name}" はプライベートであり、それが宣言されているモジュールの外部で使用されています',
        propertyOverridden: '"{name}" は、クラス "{className}" の同じ名前の property を誤ってオーバーライドします',
        propertyStaticMethod: '静的メソッドは、property の getter、setter または deleter に対して許可されません',
        protectedUsedOutsideOfClass: '"{name}" は保護され、宣言されているクラスの外部で使用されます',
        protocolBaseClass: 'Protocol クラス "{classType}" は非 Protocol クラス "{baseType}" から派生できません',
        protocolBaseClassWithTypeArgs: '型パラメーター構文を使用する場合、Protocol クラスでは型引数を使用できません',
        protocolIllegal: '"Protocol" を使用するには Python 3.7 以降が必要です',
        protocolNotAllowed: '"Protocol" はこのコンテキストでは使用できません',
        protocolTypeArgMustBeTypeParam: '"Protocol" の型引数は型パラメーターである必要があります',
        protocolUnsafeOverlap: 'クラスが安全でない方法で "{name}" と重複しており、実行時に一致する可能性があります',
        protocolVarianceContravariant: 'ジェネリック Protocol "{class}" で使用される型変数 "{variable}" は反変である必要があります',
        protocolVarianceCovariant: 'ジェネリック Protocol "{class}" で使用される型変数 "{variable}" は共変である必要があります',
        protocolVarianceInvariant: 'ジェネリック Protocol "{class}" で使用される型変数 "{variable}" は不変である必要があります',
        pyrightCommentInvalidDiagnosticBoolValue: 'Pyright コメント ディレクティブの後には "=" と値 true または false を指定する必要があります',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Pyright コメント ディレクティブの後に "=" と true、false、error、warning、information または none の値を指定する必要があります',
        pyrightCommentMissingDirective: 'Pyright コメントの後にディレクティブ (basic または strict) または診断規則を指定する必要があります',
        pyrightCommentNotOnOwnLine: 'ファイル レベルの設定を制御するために使用する Pyright コメントは、独自の行に表示する必要があります',
        pyrightCommentUnknownDiagnosticRule: '"{rule}" は pyright コメントの不明な診断規則です',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" は、pyright コメントの無効な値です。true、false、error、warning、information または none が必要です',
        pyrightCommentUnknownDirective: '"{directive}" は、pyright コメントの不明なディレクティブです。"strict" または "basic" が必要です',
        readOnlyArgCount: '"ReadOnly" の後に 1 つの型引数が必要です',
        readOnlyNotInTypedDict: '"ReadOnly" はこのコンテキストでは許可されていません',
        recursiveDefinition: '"{name}" の型は、それ自体を参照しているため、特定できませんでした',
        relativeImportNotAllowed: '相対インポートは、"import .a" フォームでは使用できません。代わりに "from . import a" を使用します。',
        requiredArgCount: '"Required" の後に 1 つの型引数が必要です',
        requiredNotInTypedDict: 'このコンテキストでは "Required" は許可されません',
        returnInAsyncGenerator: '値を持つ return ステートメントは、async ジェネレーターでは使用できません',
        returnInExceptionGroup: '"except*" ブロックでは "return" を使用できません',
        returnMissing: '戻り値の型が "{returnType}" として宣言されている関数は、すべてのコード パスで値を返す必要があります',
        returnOutsideFunction: '"return" は関数内でのみ使用できます',
        returnTypeContravariant: '反変の型変数は戻り値の型では使用できません',
        returnTypeMismatch: '型 "{exprType}" は戻り値の型 "{returnType}" に割り当てできません',
        returnTypePartiallyUnknown: '戻り値の型 "{returnType}" は部分的に不明です',
        returnTypeUnknown: '戻り値の型が不明です',
        revealLocalsArgs: '"reveal_locals" 呼び出しに引数が必要ありません',
        revealLocalsNone: 'このスコープには locals がありません',
        revealTypeArgs: '"reveal_type" 呼び出しに 1 つの位置引数が必要です',
        revealTypeExpectedTextArg: '関数 "reveal_type" の "expected_text" 引数は、str リテラル値である必要があります',
        revealTypeExpectedTextMismatch: '入力テキストの不一致;"{expected}" が必要ですが、"{received}" を受信しました',
        revealTypeExpectedTypeMismatch: '型が一致しません。"{expected}" が必要ですが、"{received}" を受信しました',
        selfTypeContext: '"Self" はこのコンテキストでは無効です',
        selfTypeMetaclass: '"Self" はメタクラス ("type" のサブクラス) 内では使用できません',
        selfTypeWithTypedSelfOrCls: '"Self" は、"Self" 以外の型注釈を持つ \'self\' または \'cls\' パラメーターを持つ関数では使用できません',
        setterGetterTypeMismatch: 'property setter 値の型は、getter の戻り値の型に割り当てることができません',
        singleOverload: '"{name}" はオーバーロードとしてマークされていますが、追加のオーバーロードがありません',
        slotsAttributeError: '__slots__で "{name}" が指定されていません',
        slotsClassVarConflict: '"{name}" が __slots__ で宣言されたインスタンス変数と競合しています',
        starPatternInAsPattern: 'スター パターンを "as" ターゲットと共に使用することはできません',
        starPatternInOrPattern: 'スター パターンを他のパターン内で OR 化することはできません',
        starStarWildcardNotAllowed: '** はワイルドカード "_" と共に使用できません',
        staticClsSelfParam: '静的メソッドに "self" または "cls" パラメーターを指定することはできません',
        stdlibModuleOverridden: '"{path}" は stdlib モジュール "{name}" をオーバーライドしています',
        stringNonAsciiBytes: '非 ASCII 文字はバイト文字列リテラルでは使用できません',
        stringNotSubscriptable: '型式では文字列式を添字にすることはできません。式全体を引用符で囲んでください',
        stringUnsupportedEscape: '文字列リテラルでサポートされていないエスケープ シーケンス',
        stringUnterminated: '文字列リテラルが未終了です',
        stubFileMissing: '"{importName}" の stub ファイルが見つかりません',
        stubUsesGetAttr: '型 stub ファイルが不完全です。"__getattr__" はモジュールの型エラーを隠します',
        sublistParamsIncompatible: 'Python 3.x では sublist パラメーターはサポートされていません',
        superCallArgCount: '"super" 呼び出しには 2 つ以下の引数が必要です',
        superCallFirstArg: '"super" 呼び出しの最初の引数としてクラス型が必要ですが、"{type}" を受け取りました',
        superCallSecondArg: '"super" 呼び出しの 2 番目の引数は、"{type}" から派生したオブジェクトまたはクラスである必要があります',
        superCallZeroArgForm: '"super" 呼び出しの 0 引数形式は、メソッド内でのみ有効です',
        superCallZeroArgFormStaticMethod: '"super" 呼び出しの 0 引数形式は、静的メソッド内では有効ではありません',
        symbolIsPossiblyUnbound: '"{name}" はバインドされていない可能性があります',
        symbolIsUnbound: '"{name}" はバインドされていません',
        symbolIsUndefined: '"{name}" が定義されていません',
        symbolOverridden: '"{name}" はクラス "{className}" の同じ名前のシンボルをオーバーライドします',
        ternaryNotAllowed: '3 項式は型式では使用できません',
        totalOrderingMissingMethod: 'total_orderingを使用するには、クラスで "__lt__"、"__le__"、"__gt__"、または "__ge__" のいずれかを定義する必要があります',
        trailingCommaInFromImport: '末尾のコンマはかっこで囲まずには使用できません',
        tryWithoutExcept: 'Try ステートメントには、少なくとも 1 つの except 句または finally 句が必要です',
        tupleAssignmentMismatch: '型 "{type}" の式はターゲット tuple に割り当てることができません',
        tupleInAnnotation: 'tuple 式は型式では使用できません',
        tupleIndexOutOfRange: 'インデックス {index} が型 {type} の範囲外です',
        typeAliasIllegalExpressionForm: '型エイリアス定義の式フォームが無効です',
        typeAliasIsRecursiveDirect: '型エイリアス "{name}" は、その定義でそれ自体を使用できません',
        typeAliasNotInModuleOrClass: 'TypeAlias は、モジュールまたはクラススコープ内でのみ定義できます',
        typeAliasRedeclared: '"{name}" は TypeAlias として宣言されており、1 回だけ割り当てることができます',
        typeAliasStatementBadScope: 'type ステートメントは、モジュールまたはクラススコープ内でのみ使用できます',
        typeAliasStatementIllegal: '型エイリアス ステートメントには Python 3.12 以降が必要です',
        typeAliasTypeBaseClass: '"type" ステートメントで定義された型エイリアスを基底クラスとして使用することはできません',
        typeAliasTypeMustBeAssigned: 'TypeAliasType は、型エイリアスと同じ名前の変数に割り当てる必要があります',
        typeAliasTypeNameArg: 'TypeAliasType の最初の引数は、型エイリアスの名前を表す文字列リテラルである必要があります',
        typeAliasTypeNameMismatch: '型エイリアスの名前は、それが割り当てられている変数の名前と一致する必要があります',
        typeAliasTypeParamInvalid: '型パラメーター リストは、TypeVar、TypeVarTuple、または ParamSpec のみを含む tuple である必要があります',
        typeAnnotationCall: '型式では呼び出し式を使用できません',
        typeAnnotationVariable: '型式では変数を使用できません',
        typeAnnotationWithCallable: '"type" の型引数はクラスである必要があります。呼び出し可能関数はサポートされていません',
        typeArgListExpected: 'ParamSpec、省略記号、または型の list が必要です',
        typeArgListNotAllowed: 'この型引数には list 式は使用できません',
        typeArgsExpectingNone: 'クラス "{name}" に型引数が必要ありません',
        typeArgsMismatchOne: '1 つの型引数が必要ですが、{received} を受け取りました',
        typeArgsMissingForAlias: 'ジェネリック型エイリアス "{name}" に必要な型引数',
        typeArgsMissingForClass: 'ジェネリック クラス "{name}" に必要な型引数',
        typeArgsTooFew: '"{name}" に指定された型引数が少なすぎます。{expected} が必要ですが、{received} を受信しました',
        typeArgsTooMany: '"{name}" に指定された型引数が多すぎます。{expected} が必要ですが、{received} を受信しました',
        typeAssignmentMismatch: '型 "{sourceType}" は宣言された型 "{destType}" に割り当てできません',
        typeAssignmentMismatchWildcard: 'インポート シンボル "{name}" には型 "{sourceType}" があり、宣言された型 "{destType}" には割り当てできません',
        typeCallNotAllowed: 'type() 呼び出しは型式で使用しないでください',
        typeCheckOnly: '"{name}" は@type_check_onlyとしてマークされており、型注釈でのみ使用できます',
        typeCommentDeprecated: 'type コメントの使用は非推奨です。代わりに type 注釈を使用してください',
        typeExpectedClass: 'クラスが必要ですが、"{type}" を受け取りました',
        typeFormArgs: '"TypeForm" は 1 つの位置引数を受け取ります',
        typeGuardArgCount: '"TypeGuard" または "TypeIs" の後に 1 つの型引数が必要です',
        typeGuardParamCount: 'ユーザー定義型ガード関数とメソッドには、少なくとも 1 つの入力パラメーターが必要です',
        typeIsReturnType: 'TypeIs の戻り値の型 ("{returnType}") と値パラメーターの型 ("{type}") が一致しません',
        typeNotAwaitable: '"{type}" は awaitable ではありません',
        typeNotIntantiable: '"{type}" をインスタンス化できません',
        typeNotIterable: '"{type}" は反復できません',
        typeNotSpecializable: '型 "{type}" を特殊化できませんでした',
        typeNotSubscriptable: '型 "{type}" のオブジェクトは添字可能ではありません',
        typeNotSupportBinaryOperator: '演算子 "{operator}" は型 "{leftType}" と "{rightType}" ではサポートされていません',
        typeNotSupportBinaryOperatorBidirectional: '型 "{leftType}" と "{rightType}" に対して演算子 "{operator}" はサポートされていません。予期された型が "{expectedType}" の場合',
        typeNotSupportUnaryOperator: '演算子 "{operator}" は型 "{type}" ではサポートされていません',
        typeNotSupportUnaryOperatorBidirectional: '型 "{type}" が "{expectedType}" の場合、演算子 "{operator}" はサポートされていません',
        typeNotUsableWith: '型 "{type}" のオブジェクトは 、{method} を実装していないため、"with" と共に使用できません',
        typeParameterBoundNotAllowed: 'バインドまたは制約を可変個引数型パラメーターまたは ParamSpec と共に使用することはできません',
        typeParameterConstraintTuple: '型パラメーター制約は、2 つ以上の型のタプルである必要があります',
        typeParameterExistingTypeParameter: '型パラメーター "{name}" は既に使用されています',
        typeParameterNotDeclared: '型パラメーター "{name}" は、"{container}" の型パラメーターリストに含まれていません',
        typeParametersMissing: '少なくとも 1 つの型パラメーターを指定する必要があります',
        typePartiallyUnknown: '"{name}" の種類が部分的に不明です',
        typeUnknown: '"{name}" の種類が不明です',
        typeVarAssignedName: 'TypeVar は 、"{name}" という名前の変数に割り当てる必要があります',
        typeVarAssignmentMismatch: '型 "{type}" を型変数 "{name}" に割り当てることはできません',
        typeVarBoundAndConstrained: 'TypeVar をバインドと制約の両方にすることはできません',
        typeVarBoundGeneric: 'TypeVar バインド型をジェネリックにすることはできません',
        typeVarConstraintGeneric: 'TypeVar 制約型をジェネリックにすることはできません',
        typeVarDefaultBoundMismatch: 'TypeVar の既定の型はバインドされた型のサブタイプである必要があります',
        typeVarDefaultConstraintMismatch: 'TypeVar の既定の型は、制約付き型のいずれかである必要があります',
        typeVarDefaultIllegal: '型変数の既定の型には Python 3.13 以降が必要です',
        typeVarDefaultInvalidTypeVar: '型パラメーター "{name}" には、スコープ外の 1 つ以上の型変数を参照する既定の型があります',
        typeVarFirstArg: '最初の引数として TypeVar の名前が必要です',
        typeVarInvalidForMemberVariable: '属性型は、ローカル メソッドにスコープ指定された型変数 "{name}" を使用できません',
        typeVarNoMember: 'TypeVar "{type}" には属性 "{name}" がありません',
        typeVarNotSubscriptable: 'TypeVar "{type}" は添字可能ではありません',
        typeVarNotUsedByOuterScope: '型変数 "{name}" は、このコンテキストでは意味がありません',
        typeVarPossiblyUnsolvable: '呼び出し元がパラメーター "{param}" に引数を指定しない場合、型変数 "{name}" は解決されない可能性があります',
        typeVarSingleConstraint: 'TypeVar には少なくとも 2 つの制約付き型が必要です',
        typeVarTupleConstraints: 'TypeVarTuple に値制約を持たせることはできません',
        typeVarTupleContext: 'TypeVarTuple はこのコンテキストでは許可されていません',
        typeVarTupleDefaultNotUnpacked: 'TypeVarTuple の既定の型は、アンパックされた tuple または TypeVarTuple である必要があります',
        typeVarTupleMustBeUnpacked: 'TypeVarTuple 値にはアンパック演算子が必要です',
        typeVarTupleUnknownParam: '"{name}" は TypeVarTuple に対する不明なパラメーターです',
        typeVarUnknownParam: '"{name}" は TypeVar に対する不明なパラメーターです',
        typeVarUsedByOuterScope: 'TypeVar "{name}" は外部スコープで既に使用されています',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" はジェネリック関数シグネチャに 1 回だけ出現します',
        typeVarVariance: 'TypeVar を共変と反変の両方にすることはできません',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}" には既定値があり、TypeVarTuple "{variadicName}" の後に続けることはできません',
        typeVarWithoutDefault: '"{name}" は既定の型がないため、型パラメーター リストの "{other}" の後に表示できません',
        typeVarsNotInGenericOrProtocol: 'Generic[] または Protocol[] には、すべての型変数を含める必要があります',
        typedDictAccess: 'TypedDict の項目にアクセスできませんでした',
        typedDictAssignedName: 'TypedDict は "{name}" という名前の変数に割り当てる必要があります',
        typedDictBadVar: 'TypedDict クラスには型注釈のみを含めることができます',
        typedDictBaseClass: 'TypedDict クラスのすべての基底クラスも TypedDict クラスである必要があります',
        typedDictBoolParam: '"{name}" パラメーターの値は True または False である必要があります',
        typedDictClosedExtras: '基底クラス "{name}" は closed した TypedDict です。追加の項目は型 "{type}" である必要があります',
        typedDictClosedNoExtras: '基底クラス "{name}" は closed した TypedDict です。追加の項目は許可されていません',
        typedDictDelete: 'TypedDict の項目を削除できませんでした',
        typedDictEmptyName: 'TypedDict 内の名前を空にすることはできません',
        typedDictEntryName: '辞書エントリ名に文字列リテラルが必要です',
        typedDictEntryUnique: 'ディクショナリ内の名前は一意である必要があります',
        typedDictExtraArgs: '追加の TypedDict 引数はサポートされていません',
        typedDictExtraItemsClosed: '追加の項目がサポートされている場合、TypedDict を closed にすることはできません',
        typedDictFieldNotRequiredRedefinition: 'TypedDict アイテム "{name}" を NotRequired として再定義することはできません',
        typedDictFieldReadOnlyRedefinition: 'TypedDict アイテム "{name}" を ReadOnly として再定義することはできません',
        typedDictFieldRequiredRedefinition: 'TypedDict アイテム "{name}" を Required として再定義することはできません',
        typedDictFirstArg: '最初の引数として TypedDict クラス名が必要です',
        typedDictInClassPattern: 'TypedDict クラスはクラス パターンでは使用できません',
        typedDictInitsubclassParameter: 'TypedDict は __init_subclass__パラメーター "{name}" をサポートしていません',
        typedDictNotAllowed: '"TypedDict" はこのコンテキストでは使用できません',
        typedDictSecondArgDict: '2 番目のパラメーターとして dict パラメーターまたはキーワード パラメーターが必要です',
        typedDictSecondArgDictEntry: '単純な辞書エントリが必要です',
        typedDictSet: 'TypedDict で項目を割り当てることができませんでした',
        unaccessedClass: 'クラス "{name}" は参照されていません',
        unaccessedFunction: '関数 "{name}" は参照されていません',
        unaccessedImport: 'インポート "{name}" は参照されていません',
        unaccessedSymbol: '"{name}" は参照されていません',
        unaccessedVariable: '変数 "{name}" は参照されていません',
        unannotatedFunctionSkipped: '関数 "{name}" の分析は、表示されないためスキップされます',
        unaryOperationNotAllowed: '単項演算子は型式では使用できません',
        unexpectedAsyncToken: '"def"、"with"、または "for" が "async" の後に続く必要があります',
        unexpectedExprToken: '式の最後に予期しないトークンが含まれています',
        unexpectedIndent: '予期しないインデント',
        unexpectedUnindent: 'インデント解除は予期されていません',
        unhashableDictKey: '辞書キーはハッシュ可能である必要があります',
        unhashableSetEntry: 'set エントリはハッシュ可能である必要があります',
        uninitializedAbstractVariables: '抽象基底クラスで定義された変数が、final クラス "{classType}" で初期化されていません',
        uninitializedInstanceVariable: 'インスタンス変数 "{name}" は、クラス本体または__init__ メソッドで初期化されていません',
        unionForwardReferenceNotAllowed: 'Union 構文は文字列オペランドで使用できません。式全体を引用符で囲んでください',
        unionSyntaxIllegal: '共用体の代替構文には Python 3.10 以降が必要です',
        unionTypeArgCount: 'Union には 2 つ以上の型引数が必要です',
        unionUnpackedTuple: 'Union cannot include an unpacked tuple',
        unionUnpackedTypeVarTuple: 'Union cannot include an unpacked TypeVarTuple',
        unnecessaryCast: '不要な "cast" 呼び出し。型は既に "{type}" です',
        unnecessaryIsInstanceAlways: '不要な isinstance 呼び出し。"{testType}" は常に "{classType}" のインスタンスです',
        unnecessaryIsInstanceNever: '不要な isinstance 呼び出し; "{testType}" は"{classType}" のインスタンスであったことはありません',
        unnecessaryIsSubclassAlways: '不要な issubclass 呼び出し。"{testType}" は常に "{classType}" のサブクラスです',
        unnecessaryIsSubclassNever: '不要な issubclass 呼び出し; "{testType}" は "{classType}" のサブクラスであったことはありません',
        unnecessaryPyrightIgnore: '不要な "# pyright: ignore" コメント',
        unnecessaryPyrightIgnoreRule: '不要な "# pyright: ignore" ルール: "{name}"',
        unnecessaryTypeIgnore: '不要な "# type: ignore" コメント',
        unpackArgCount: '"Unpack" の後に 1 つの型引数が必要です',
        unpackExpectedTypeVarTuple: 'Unpack の型引数として TypeVarTuple または tuple が必要です',
        unpackExpectedTypedDict: 'Unpack に必要な TypedDict 型引数',
        unpackIllegalInComprehension: 'アンパック操作は理解できません',
        unpackInAnnotation: 'アンパック演算子は型式では使用できません',
        unpackInDict: 'アンパック操作はディクショナリで許可されていません',
        unpackInSet: 'アンパック演算子は set 内では使用できません',
        unpackNotAllowed: 'Unpack はこのコンテキストでは許可されていません',
        unpackOperatorNotAllowed: 'このコンテキストではアンパック操作は許可されていません',
        unpackTuplesIllegal: 'Python 3.8 より前のタプルではアンパック操作は許可されていません',
        unpackedArgInTypeArgument: 'アンパックされた引数は、このコンテキストでは使用できません',
        unpackedArgWithVariadicParam: 'アンパックされた引数は TypeVarTuple パラメーターには使用できません',
        unpackedDictArgumentNotMapping: '** の後の引数式は、"str" キー型のマッピングである必要があります',
        unpackedDictSubscriptIllegal: '下付き文字の辞書アンパック演算子は使用できません',
        unpackedSubscriptIllegal: '下付き文字の Unpack 演算子には Python 3.11 以降が必要です',
        unpackedTypeVarTupleExpected: 'アンパックされた TypeVarTuple が必要です。Unpack[{name1}] または *{name2} を使用してください',
        unpackedTypedDictArgument: 'アンパックされた TypedDict 引数をパラメーターと一致させることはできません',
        unreachableCode: 'コードに到達できません',
        unreachableCodeType: '型分析はコードに到達不能であることを示します',
        unreachableExcept: '例外が既に処理されているため、Except 句に到達できません',
        unsupportedDunderAllOperation: '"__all__" に対する操作はサポートされていないため、エクスポートされたシンボル リストが正しくない可能性があります',
        unusedCallResult: '呼び出し式の結果は "{type}" 型であり、使用されません。これが意図的な場合は変数 "_" に代入する',
        unusedCoroutine: 'async 関数呼び出しの結果が使用されていません。"await" を使用するか、結果を変数に代入してください。',
        unusedExpression: '式の値が使用されていません',
        varAnnotationIllegal: '変数の type 注釈には Python 3.6 以降が必要です。以前のバージョンとの互換性を保つために type コメントを使用してください',
        variableFinalOverride: '変数 "{name}" は Final とマークされ、クラス "{className}" の同じ名前の Final 以外の変数をオーバーライドします',
        variadicTypeArgsTooMany: '型引数リストには、アンパックされた TypeVarTuple または tuple を最大 1 つ含めることができます',
        variadicTypeParamTooManyAlias: '型エイリアスには TypeVarTuple 型パラメーターを最大 1 つ含めることができますが、複数の ({names}) を受け取りました',
        variadicTypeParamTooManyClass: 'ジェネリック クラスには最大 1 つの TypeVarTuple 型パラメーターを指定できますが、複数の ({names}) を受け取りました',
        walrusIllegal: '演算子 ":=" には Python 3.8 以降が必要です',
        walrusNotAllowed: '演算子 ":=" は、かっこを囲まないこのコンテキストでは使用できません',
        wildcardInFunction: 'ワイルドカードの import は、クラス内または関数内では許可されません',
        wildcardLibraryImport: 'ライブラリからのワイルドカードの import は許可されていません',
        wildcardPatternTypePartiallyUnknown: 'ワイルドカード パターンによってキャプチャされた型は部分的に不明です',
        wildcardPatternTypeUnknown: 'ワイルドカード パターンによってキャプチャされた型が不明です',
        yieldFromIllegal: '"yield from" を使用するには Python 3.3 以降が必要です',
        yieldFromOutsideAsync: 'async 関数では "yield from" は使用できません',
        yieldOutsideFunction: '関数またはラムダの外部では "yield" は許可されません',
        yieldWithinComprehension: '"yield" は内包表記内では使用できません',
        zeroCaseStatementsFound: 'Match ステートメントには、少なくとも 1 つの case ステートメントを含める必要があります',
        zeroLengthTupleNotAllowed: 'このコンテキストでは長さ 0 の tuple は使用できません'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '"Annotated" 特殊フォームは、インスタンスおよびクラスのチェックでは使用できません',
        argParam: '引数はパラメーター "{paramName}" に対応します',
        argParamFunction: '引数は関数 "{functionName}" のパラメーター "{paramName}" に対応します',
        argsParamMissing: 'パラメーター "*{paramName}" に対応するパラメーターがありません',
        argsPositionOnly: '位置のみのパラメーターの不一致。{expected} が必要ですが、{received} を受信しました',
        argumentType: '引数の型は "{type}" です',
        argumentTypes: '引数の型: ({types})',
        assignToNone: '型は "None" に割り当てできません',
        asyncHelp: '"async with" を意味しましたか?',
        baseClassIncompatible: '基底クラス "{baseClass}" は型 "{type}" と互換性がありません',
        baseClassIncompatibleSubclass: '基底クラス "{baseClass}" は、型 "{type}" と互換性のない "{subclass}" から派生しています',
        baseClassOverriddenType: '基底クラス "{baseClass}" は、オーバーライドされる型 "{type}" を提供します',
        baseClassOverridesType: '基底クラス "{baseClass}" は型 "{type}" でオーバーライドします',
        bytesTypePromotions: 'disableBytesTypePromotions を false に設定して、"bytearray" と "memoryview" の型昇格動作を有効にします',
        conditionalRequiresBool: '型 "{operandType}" のメソッド __bool__は、"bool" ではなく型 "{boolReturnType}" を返します',
        dataClassFieldLocation: 'フィールド宣言',
        dataClassFrozen: '"{name}" は固定されています',
        dataProtocolUnsupported: '"{name}" はデータ プロトコルです',
        descriptorAccessBindingFailed: '記述子クラス "{className}" のメソッド "{name}" をバインドできませんでした',
        descriptorAccessCallFailed: '記述子クラス "{className}" のメソッド "{name}" を呼び出せませんでした',
        finalMethod: 'Final メソッド',
        functionParamDefaultMissing: 'パラメーター "{name}" に既定の引数がありません',
        functionParamName: 'パラメーター名の不一致: "{destName}" と "{srcName}"',
        functionParamPositionOnly: '位置のみのパラメーターの不一致; パラメーター "{name}" は位置のみではありません',
        functionReturnTypeMismatch: '関数の戻り値の型 "{sourceType}" は型 "{destType}" と互換性がありません',
        functionTooFewParams: '関数が受け入れる位置指定パラメーターが少なすぎます。{expected} が必要ですが、{received} を受信しました',
        functionTooManyParams: '関数が受け入れる位置指定パラメーターが多すぎます。{expected} が必要ですが、{received} を受信しました',
        genericClassNotAllowed: 'インスタンスまたはクラスのチェックでは、型引数を含むジェネリック型は使用できません',
        incompatibleDeleter: 'property deleter メソッドは互換性がありません',
        incompatibleGetter: 'property getter メソッドは互換性がありません',
        incompatibleSetter: 'property setter メソッドは互換性がありません',
        initMethodLocation: '__init__ メソッドはクラス "{type}" で定義されています',
        initMethodSignature: '__init__の署名は "{type}" です',
        initSubclassLocation: '__init_subclass__ メソッドはクラス "{name}" で定義されています',
        invariantSuggestionDict: '"dict" から値の型の共変である "Mapping" への切り替えを検討してください',
        invariantSuggestionList: '"list" から共変である "Sequence" への切り替えを検討してください',
        invariantSuggestionSet: '"set" から共変である "Container" への切り替えを検討してください',
        isinstanceClassNotSupported: 'インスタンスとクラスのチェックでは、"{type}" はサポートされていません',
        keyNotRequired: '"{name}" は "{type}" の必須キーではないため、アクセスすると実行時例外が発生する可能性があります',
        keyReadOnly: '"{name}" は "{type}" の読み取り専用キーです',
        keyRequiredDeleted: '"{name}" は必須キーであり、削除できません',
        keyUndefined: '"{name}" は "{type}" で定義されたキーではありません',
        kwargsParamMissing: 'パラメーター "**{paramName}" に対応するパラメーターがありません',
        listAssignmentMismatch: '型 "{type}" はターゲット リストと互換性がありません',
        literalAssignmentMismatch: '"{sourceType}" は型 "{destType}" に割り当てできません',
        matchIsNotExhaustiveHint: '完全な処理が意図されていない場合は、"case _: pass" を追加します',
        matchIsNotExhaustiveType: 'ハンドルされない型: "{type}"',
        memberAssignment: '型 "{type}" の式をクラス "{classType}" の属性 "{name}" に割り当てることはできません',
        memberIsAbstract: '"{type}.{name}" は実装されていません',
        memberIsAbstractMore: 'その他 {count} 件...',
        memberIsClassVarInProtocol: '"{name}" はプロトコルで ClassVar として定義されています',
        memberIsInitVar: '"{name}" は init-only フィールドです',
        memberIsInvariant: '"{name}" は変更可能であるため、不変です',
        memberIsNotClassVarInClass: 'プロトコルと互換性を持たせるには、"{name}" を ClassVar として定義する必要があります',
        memberIsNotClassVarInProtocol: '"{name}" はプロトコルで ClassVar として定義されていません',
        memberIsNotReadOnlyInProtocol: '"{name}" はプロトコルで読み取り専用ではありません',
        memberIsReadOnlyInProtocol: '"{name}" はプロトコルで読み取り専用です',
        memberIsWritableInProtocol: '"{name}" はプロトコルで書き込み可能です',
        memberSetClassVar: '属性 "{name}" は ClassVar であるため、クラス インスタンスを介して割り当てることはできません',
        memberTypeMismatch: '"{name}" は互換性のない型です',
        memberUnknown: '属性 "{name}" が不明です',
        metaclassConflict: 'メタクラス "{metaclass1}" が "{metaclass2}" と競合しています',
        missingDeleter: 'property deleter メソッドがありません',
        missingGetter: 'property getter メソッドがありません',
        missingSetter: 'property setter メソッドがありません',
        namedParamMissingInDest: '余分なパラメーター "{name}"',
        namedParamMissingInSource: 'キーワード パラメーター "{name}" が見つかりません',
        namedParamTypeMismatch: '型 "{sourceType}" のキーワード パラメーター "{name}" は型 "{destType}" と互換性がありません',
        namedTupleNotAllowed: 'NamedTuple はインスタンスまたはクラスのチェックには使用できません',
        newMethodLocation: '__new__ メソッドはクラス "{type}" で定義されています',
        newMethodSignature: '__new__の署名は "{type}" です',
        newTypeClassNotAllowed: 'NewType で作成されたクラスは、インスタンスおよびクラスのチェックでは使用できません',
        noOverloadAssignable: '型 "{type}" に一致するオーバーロードされた関数はありません',
        noneNotAllowed: 'インスタンスまたはクラスのチェックには None 使用できません',
        orPatternMissingName: '名前がありません: {name}',
        overloadIndex: 'オーバーロード {index} が最も近い一致です',
        overloadNotAssignable: '"{name}" の 1 つ以上のオーバーロードが割り当て可能ではありません',
        overloadSignature: 'オーバーロードシグネチャはここで定義されています',
        overriddenMethod: 'オーバーライドされたメソッド',
        overriddenSymbol: 'オーバーライドされたシンボル',
        overrideInvariantMismatch: 'オーバーライドの型 "{overrideType}" が基本データ型 "{baseType}" と同じではありません',
        overrideIsInvariant: '変数は変更可能であるため、その型は不変です',
        overrideNoOverloadMatches: 'オーバーライドのオーバーロード シグネチャが基本メソッドと互換性がありません',
        overrideNotClassMethod: '基本メソッドは classmethod として宣言されていますが、オーバーライドはされていません',
        overrideNotInstanceMethod: '基本メソッドはインスタンス メソッドとして宣言されていますが、オーバーライドは宣言されていません',
        overrideNotStaticMethod: '基本メソッドは staticmethod として宣言されていますが、オーバーライドは宣言されていません',
        overrideOverloadNoMatch: 'オーバーライドは基本メソッドのすべてのオーバーロードを処理しません',
        overrideOverloadOrder: 'オーバーライド メソッドのオーバーロードは、基本メソッドと同じ順序にする必要があります',
        overrideParamKeywordNoDefault: 'キーワード パラメーター "{name}" の不一致: 基本パラメーターに既定の引数値があり、オーバーライド パラメーターにはありません',
        overrideParamKeywordType: 'キーワード パラメーター "{name}" の型が一致しません: 基本パラメーターは型 "{baseType}"、オーバーライド パラメーターは型 "{overrideType}" です',
        overrideParamName: 'パラメーター {index} 名が一致しません: ベース パラメーターの名前は "{baseName}"、オーバーライド パラメーターは "{overrideName}" です',
        overrideParamNameExtra: 'パラメーター "{name}" が ベース に見つかりません',
        overrideParamNameMissing: 'パラメーター "{name}" がオーバーライドに見つかりません',
        overrideParamNamePositionOnly: 'パラメーター {index} の不一致: ベース パラメーター "{baseName}" はキーワード パラメーターで、オーバーライド パラメーターは位置のみです',
        overrideParamNoDefault: 'パラメーター {index} の不一致: 基本パラメーターに既定の引数値があり、オーバーライド パラメーターが指定されていません',
        overrideParamType: 'パラメーター {index} の型が一致しません: 基本パラメーターは型 "{baseType}"、オーバーライド パラメーターは型 "{overrideType}" です',
        overridePositionalParamCount: '位置指定パラメーター数が一致しません。基本メソッドには {baseCount} がありますが、オーバーライドには {overrideCount} があります',
        overrideReturnType: '戻り値の型の不一致: 基本メソッドは型 "{baseType}" を返し、オーバーライドは型 "{overrideType}" を返します',
        overrideType: '基底クラスは型を "{type}" として定義します',
        paramAssignment: 'パラメーター {index}: 型 "{sourceType}" は型 "{destType}" と互換性がありません',
        paramSpecMissingInOverride: 'ParamSpec パラメーターが override メソッドに見つかりません',
        paramType: 'パラメーターの型は "{paramType}" です',
        privateImportFromPyTypedSource: '代わりに "{module}" からインポートする',
        propertyAccessFromProtocolClass: 'プロトコル クラス内で定義されたプロパティにクラス変数としてアクセスできない',
        propertyMethodIncompatible: 'property メソッド "{name}" は互換性がありません',
        propertyMethodMissing: 'property メソッド "{name}" がオーバーライドにありません',
        propertyMissingDeleter: 'property "{name}" に定義された deleter がありません',
        propertyMissingSetter: 'property "{name}" に定義された setter がありません',
        protocolIncompatible: '"{sourceType}" はプロトコル "{destType}" と互換性がありません',
        protocolMemberMissing: '"{name}" が存在しません',
        protocolRequiresRuntimeCheckable: 'インスタンスとクラスのチェックで使用するには、Protocol クラスが @runtime_checkable である必要があります',
        protocolSourceIsNotConcrete: '"{sourceType}" は具象クラス型ではないため、型 "{destType}" に割り当てることはできません',
        protocolUnsafeOverlap: '"{name}" の属性の名前がプロトコルの名前と同じです',
        pyrightCommentIgnoreTip: '"# pyright: ignore[<diagnostic rules>] を使用して 1 行の診断を抑制します',
        readOnlyAttribute: '属性 "{name}" は読み取り専用です',
        seeClassDeclaration: 'クラス宣言を参照してください',
        seeDeclaration: '宣言を参照してください',
        seeFunctionDeclaration: '関数の宣言を参照してください',
        seeMethodDeclaration: 'メソッド宣言を参照してください',
        seeParameterDeclaration: 'パラメーター宣言を参照してください',
        seeTypeAliasDeclaration: '型のエイリアス宣言を参照してください',
        seeVariableDeclaration: '変数宣言を参照してください',
        tupleAssignmentMismatch: '型 "{type}" はターゲット tuple と互換性がありません',
        tupleEntryTypeMismatch: 'tuple エントリ {entry} の型が正しくありません',
        tupleSizeIndeterminateSrc: 'Tuple のサイズが一致しません。{expected} が必要ですが、受け取りは不確定です',
        tupleSizeIndeterminateSrcDest: 'Tuple のサイズが一致しません。{expected} 以上が必要ですが、受け取りは不確定です',
        tupleSizeMismatch: 'tuple のサイズが一致しません。{expected} が必要ですが、{received} を受信しました',
        tupleSizeMismatchIndeterminateDest: 'Tuple のサイズが一致しません。{expected} 以上が必要ですが、{received} を受信しました',
        typeAliasInstanceCheck: '"type" ステートメントで作成された型エイリアスは、インスタンスとクラスのチェックでは使用できません',
        typeAssignmentMismatch: '型 "{sourceType}" は型 "{destType}" に割り当てできません',
        typeBound: '型 "{sourceType}" は、型変数 "{name}" の上限 "{destType}" に割り当てできません',
        typeConstrainedTypeVar: '型 "{type}" は制約付き型変数 "{name}" に割り当てできません',
        typeIncompatible: '"{sourceType}" は "{destType}" に割り当てできません',
        typeNotClass: '"{type}" はクラスではありません',
        typeNotStringLiteral: '"{type}" は文字列リテラルではありません',
        typeOfSymbol: '"{name}" の型は "{type}" です',
        typeParamSpec: '型 "{type}" は ParamSpec "{name}" と互換性がありません',
        typeUnsupported: '型 "{type}" はサポートされていません',
        typeVarDefaultOutOfScope: '型変数 "{name}" はスコープ内にありません',
        typeVarIsContravariant: '型パラメーター "{name}" は反変ですが、"{sourceType}" は "{destType}" のスーパータイプではありません',
        typeVarIsCovariant: '型パラメーター "{name}" は共変ですが、"{sourceType}" は "{destType}" のサブタイプではありません',
        typeVarIsInvariant: '型パラメーター "{name}" は不変ですが、"{sourceType}" は "{destType}" と同じではありません',
        typeVarNotAllowed: 'TypeVar は、インスタンスまたはクラスのチェックには使用できません',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple を不明な長さの tuple にバインドすることはできません',
        typeVarUnnecessarySuggestion: '代わりに {type} を使用してください',
        typeVarUnsolvableRemedy: '引数が指定されていない場合に戻り値の型を指定するオーバーロードを指定します',
        typeVarsMissing: '型変数がありません: {names}',
        typedDictBaseClass: 'クラス "{type}" は TypedDict ではありません',
        typedDictClassNotAllowed: 'TypedDict クラスはインスタンスまたはクラスのチェックには使用できません',
        typedDictClosedExtraNotAllowed: 'アイテム "{name}" を追加できません',
        typedDictClosedExtraTypeMismatch: '型 "{type}" のアイテム "{name}" を追加できません',
        typedDictClosedFieldNotRequired: 'アイテム "{name}" を追加できません。これは NotRequired である必要があるためです。',
        typedDictExtraFieldNotAllowed: '"{name}" は "{type}" に存在しません',
        typedDictExtraFieldTypeMismatch: '"{name}" の型は、"{type}" の "extra_items" 型と互換性がありません',
        typedDictFieldMissing: '"{name}" が "{type}" に見つかりません',
        typedDictFieldNotReadOnly: '"{name}" は "{type}" では読み取り専用ではありません',
        typedDictFieldNotRequired: '"{name}" は "{type}" には必要ありません',
        typedDictFieldRequired: '"{name}" は "{type}" に必要です',
        typedDictFieldTypeMismatch: '型 "{type}" は、アイテム "{name}" に割り当てできません',
        typedDictFieldUndefined: '"{name}" は型 "{type}" の未定義のアイテムです',
        typedDictFinalMismatch: '@final が一致しないため、"{sourceType}" は "{destType}" と互換性がありません',
        typedDictKeyAccess: '["{name}"] を使用して TypedDict の項目を参照する',
        typedDictNotAllowed: 'TypedDict はインスタンスまたはクラスのチェックには使用できません',
        unhashableType: '型 "{type}" はハッシュ可能ではありません',
        uninitializedAbstractVariable: 'インスタンス変数 "{name}" は抽象基本クラス "{classType}" で定義されていますが、初期化されていません',
        unreachableExcept: '"{exceptionType}" は "{parentType}" のサブクラスです',
        useDictInstead: '辞書の種類を示すには、Dict[T1, T2] を使用します',
        useListInstead: 'List[T] を使用して list 型を示すか、Union[T1, T2] を使用して union 型を示します',
        useTupleInstead: 'tuple[T1, ..., Tn] を使用して tuple 型を示すか、Union[T1, T2] を使用して union 型を示します',
        useTypeInstead: '代わりに Type[T] を使用する',
        varianceMismatchForClass: '型引数 "{typeVarName}" の分散は、基底クラス "{className}" と互換性がありません',
        varianceMismatchForTypeAlias: '型引数 "{typeVarName}" の分散は "{typeAliasParam}" と互換性がありません'
      },
      Service: {
        longOperation: 'ワークスペース ソース ファイルの列挙に時間がかかっています。代わりにサブフォルダーを開く方法を検討してください。[詳細情報](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  83472: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: '형식 Stub 만들기',
        createTypeStubFor: '"{moduleName}"에 대한 형식 Stub 만들기',
        executingCommand: '명령 실행',
        filesToAnalyzeCount: '분석할 파일 {count}개',
        filesToAnalyzeOne: '분석할 파일 1개',
        findingReferences: '참조 찾기',
        organizeImports: '가져오기 구성',
        renameShadowedFile: '‘{oldFile}’에서 ‘{newFile}’(으)로 이름 바꾸기'
      },
      Completion: {
        autoImportDetail: '자동 가져오기',
        indexValueDetail: '인덱스 값'
      },
      Diagnostic: {
        abstractMethodInvocation: '메서드 "{method}"은(는) 추상적이고 구현되지 않았으므로 호출할 수 없습니다.',
        annotatedMetadataInconsistent: '주석이 추가된 "{metadataType}" 메타데이터 형식이 "{type}" 형식과 호환되지 않습니다.',
        annotatedParamCountMismatch: '매개 변수 주석 개수가 일치하지 않습니다. {expected}이)(가) 필요하지만 {received}을(를) 받았습니다.',
        annotatedTypeArgMissing: '"Annotated"에 대해 하나의 형식 인수와 하나 이상의 주석이 필요합니다.',
        annotationBytesString: '형식 식은 바이트 문자열 리터럴을 사용할 수 없습니다.',
        annotationFormatString: '형식 식은 형식 문자열 리터럴(f 문자열)을 사용할 수 없습니다.',
        annotationNotSupported: '이 문에는 형식 주석이 지원되지 않습니다.',
        annotationRawString: '형식 식은 원시 문자열 리터럴을 사용할 수 없습니다.',
        annotationSpansStrings: '형식 식은 여러 문자열 리터럴에 걸쳐 사용할 수 없습니다.',
        annotationStringEscape: '형식 식에는 이스케이프 문자를 포함할 수 없습니다.',
        argAssignment: '"{argType}" 형식의 인수를 "{paramType}" 형식의 매개 변수에 할당할 수 없습니다.',
        argAssignmentFunction: '"{argType}" 형식의 인수를 "{functionName}" 함수의 "{paramType}" 형식의 매개 변수에 할당할 수 없습니다.',
        argAssignmentParam: '"{argType}" 형식의 인수를 "{paramType}" 형식의 "{paramName}" 매개 변수에 할당할 수 없습니다.',
        argAssignmentParamFunction: '"{argType}" 형식의 인수를 "{functionName}" 함수에서 "{paramType}" 형식의 "{paramName}" 매개 변수에 할당할 수 없습니다.',
        argMissingForParam: '매개 변수 {name}에 대한 인수가 없습니다.',
        argMissingForParams: '매개 변수 {names}에 대한 인수가 없습니다.',
        argMorePositionalExpectedCount: '{expected}개 이상의 위치 인수가 필요합니다.',
        argMorePositionalExpectedOne: '1개의 위치 인수가 더 필요합니다.',
        argPositional: '위치 인수가 필요합니다.',
        argPositionalExpectedCount: '{expected} 위치 인수가 필요합니다.',
        argPositionalExpectedOne: '1개의 위치 인수가 필요합니다.',
        argTypePartiallyUnknown: '인수 형식을 부분적으로 알 수 없습니다.',
        argTypeUnknown: '인수 형식을 알 수 없습니다.',
        assertAlwaysTrue: '어설션 식은 항상 true로 평가됩니다.',
        assertTypeArgs: '"assert_type"에는 두 개의 위치 인수가 필요합니다.',
        assertTypeTypeMismatch: '"assert_type" 불일치: "{expected}"이(가) 필요하지만 "{received}"을(를) 받았습니다.',
        assignmentExprComprehension: '‘{name}’ 할당 식 대상은 대상에 대한 이해력과 같은 이름을 사용할 수 없습니다.',
        assignmentExprContext: '할당 식은 모듈, 함수 또는 람다 내에 있어야 합니다.',
        assignmentExprInSubscript: '아래 첨자 내의 할당 식은 Python 3.10 이상에서만 지원됩니다.',
        assignmentInProtocol: 'Protocol 클래스 내의 인스턴스 또는 클래스 변수는 클래스 본문 내에서 명시적으로 선언해야 합니다.',
        assignmentTargetExpr: '식은 할당 대상이 될 수 없습니다.',
        asyncNotInAsyncFunction: 'async 함수 외부에서는 “async”가 허용되지 않습니다.',
        awaitIllegal: '"await"를 사용하려면 Python 3.5 이상이 필요합니다.',
        awaitNotAllowed: '형식 식은 "await"를 사용할 수 없습니다.',
        awaitNotInAsync: '"await" allowed only within async function',
        backticksIllegal: '백틱으로 묶인 식은 Python 3.x에서 지원되지 않습니다. 대신 repr 사용',
        baseClassCircular: '클래스는 스스로에서 파생될 수 없습니다.',
        baseClassFinal: '기본 클래스 "{type}"이(가) final로 표시되어 서브클래스할 수 없습니다.',
        baseClassIncompatible: '{type}의 기본 클래스는 상호 호환되지 않습니다.',
        baseClassInvalid: '클래스에 대한 인수는 기본 클래스여야 합니다.',
        baseClassMethodTypeIncompatible: '"{classType}" 클래스의 기본 클래스가 호환되지 않는 방식으로 "{name}" 메서드를 정의합니다.',
        baseClassUnknown: '기본 클래스 형식을 알 수 없으므로 파생 클래스의 형식이 모호합니다.',
        baseClassVariableTypeIncompatible: '"{classType}" 클래스의 기본 클래스가 "{name}" 변수를 호환되지 않는 방식으로 정의합니다.',
        binaryOperationNotAllowed: '형식 식에는 이항 연산자를 사용할 수 없습니다.',
        bindTypeMismatch: '‘{type}’을(를) 매개 변수 ‘{paramName}’에 할당할 수 없으므로 ‘{methodName}’ 메서드를 바인딩할 수 없습니다.',
        breakInExceptionGroup: '"except*" 블록에는 "break"를 사용할 수 없습니다',
        breakOutsideLoop: '‘break’는 루프 내에서만 사용할 수 있습니다.',
        callableExtraArgs: '"Callable"에 두 개의 형식 인수만 필요합니다.',
        callableFirstArg: '매개 변수 형식 목록 또는 "..."가 필요합니다.',
        callableNotInstantiable: '"{type}" 형식을 인스턴스화할 수 없습니다.',
        callableSecondArg: '반환 형식이 "Callable"에 대한 두 번째 형식 인수로 필요합니다.',
        casePatternIsIrrefutable: '되돌릴 수 없는 패턴은 마지막 case 문에만 사용할 수 있습니다.',
        classAlreadySpecialized: '"{type}" 형식이 이미 특수화되어 있습니다.',
        classDecoratorTypeUnknown: '형식화되지 않은 클래스 데코레이터는 클래스 형식을 모호하게 합니다. 데코레이터를 무시합니다.',
        classDefinitionCycle: '‘{name}’에 대한 클래스 정의가 스스로에 종속됩니다.',
        classGetItemClsParam: '__class_getitem__ 재정의는 "cls" 매개 변수를 사용해야 합니다.',
        classMethodClsParam: '클래스 메서드는 ‘cls’ 매개 변수를 사용해야 합니다.',
        classNotRuntimeSubscriptable: '클래스 "{name}"에 대한 첨자는 런타임 예외를 생성합니다. 형식 식을 따옴표로 묶습니다.',
        classPatternBuiltInArgPositional: '클래스 패턴은 위치 하위 패턴만 허용합니다.',
        classPatternPositionalArgCount: '클래스 "{type}"에 대한 위치 패턴이 너무 많습니다. {expected}이(가) 필요하지만 {received}을(를) 받았습니다.',
        classPatternTypeAlias: '‘{type}’은(는) 특수 형식 별칭이므로 클래스 패턴에서 사용할 수 없습니다.',
        classPropertyDeprecated: '클래스 속성은 Python 3.11에서 더 이상 사용되지 않으며 Python 3.13에서 지원되지 않습니다.',
        classTypeParametersIllegal: '클래스 형식 매개 변수 구문에는 Python 3.12 이상이 필요합니다.',
        classVarFirstArgMissing: '‘ClassVar’ 뒤에 형식 인수가 필요합니다.',
        classVarNotAllowed: '이 컨텍스트에서는 "ClassVar"를 사용할 수 없습니다.',
        classVarOverridesInstanceVar: '클래스 변수 "{name}"이(가) "{className}" 클래스에서 같은 이름의 인스턴스 변수를 재정의합니다.',
        classVarTooManyArgs: '‘ClassVar’ 뒤에는 형식 인수가 하나만 필요합니다.',
        classVarWithTypeVar: '‘ClassVar’ 형식에는 형식 변수를 포함할 수 없습니다.',
        clsSelfParamTypeMismatch: '‘{name}’ 매개 변수의 형식은 해당 ‘{classType}’ 클래스의 상위 형식이어야 합니다.',
        codeTooComplexToAnalyze: '코드가 너무 복잡하여 분석할 수 없습니다. 하위 경로로 리팩터링하거나 조건부 코드 경로를 줄여 복잡성 감소',
        collectionAliasInstantiation: '‘{type}’ 형식을 인스턴스화할 수 없습니다. 대신 ‘{alias}’을(를) 사용하세요.',
        comparisonAlwaysFalse: '"{leftType}" 및 "{rightType}" 형식이 겹치지 않으므로 조건은 항상 False로 평가됩니다.',
        comparisonAlwaysTrue: '"{leftType}" 및 "{rightType}" 형식이 겹치지 않으므로 조건은 항상 True로 평가됩니다.',
        comprehensionInDict: '이해력은 다른 사전 항목과 함께 사용할 수 없습니다.',
        comprehensionInSet: '이해력은 다른 set 항목과 함께 사용할 수 없습니다.',
        concatenateContext: '이 컨텍스트에서는 "Concatenate"를 사용할 수 없습니다.',
        concatenateParamSpecMissing: '"Concatenate"의 마지막 형식 인수는 ParamSpec 또는 "..."이어야 합니다.',
        concatenateTypeArgsMissing: '"Concatenate"에는 적어도 두 개의 형식 인수가 필요합니다.',
        conditionalOperandInvalid: '’{type}’ 형식의 조건부 피연산자입니다.',
        constantRedefinition: '‘{name}’은(는) 대문자이므로 상수이고 다시 정의할 수 없습니다.',
        constructorParametersMismatch: '‘{classType}’ 클래스에서 __new__ 서명과 __init__가 불일치합니다.',
        containmentAlwaysFalse: '‘{leftType}’ 및 ‘{rightType}’ 형식이 겹치지 않으므로 식은 항상 False로 평가됩니다.',
        containmentAlwaysTrue: '‘{leftType}’ 및 ‘{rightType}’ 형식이 겹치지 않으므로 식은 항상 True로 평가됩니다.',
        continueInExceptionGroup: '"except*" 블록에는 "continue"를 사용할 수 없습니다',
        continueOutsideLoop: '"continue"는 루프 내에서만 사용할 수 있습니다.',
        coroutineInConditionalExpression: '조건식은 항상 True로 평가되는 코루틴을 참조합니다.',
        dataClassBaseClassFrozen: '고정되지 않은 클래스는 고정된 클래스에서 상속할 수 없습니다.',
        dataClassBaseClassNotFrozen: '고정 클래스는 고정되지 않은 클래스에서 상속할 수 없습니다.',
        dataClassConverterFunction: '"{argType}" 형식의 인수는 "{fieldType}" 형식의 "{fieldName}" 필드에 유효한 변환기가 아닙니다.',
        dataClassConverterOverloads: '"{funcName}"의 오버로드는 "{fieldType}" 형식의 "{fieldName}" 필드에 유효한 변환기가 아닙니다.',
        dataClassFieldInheritedDefault: '"{fieldName}"이(가) 같은 이름의 필드를 재정의하지만 기본값이 없음',
        dataClassFieldWithDefault: '기본값이 없는 필드는 기본값이 있는 필드 뒤에 나타날 수 없습니다.',
        dataClassFieldWithPrivateName: '데이터 클래스 필드는 프라이빗 이름을 사용할 수 없습니다.',
        dataClassFieldWithoutAnnotation: '형식 주석이 없는 데이터 클래스 필드를 사용하면 런타임 예외가 발생합니다.',
        dataClassPostInitParamCount: '데이터 클래스 __post_init__의 잘못된 매개 변수 수입니다. InitVar 필드 수가 {expected}개입니다.',
        dataClassPostInitType: '데이터 클래스 __post_init__ 메서드 매개 변수 형식이 필드 "{fieldName}"에 대해 일치하지 않습니다.',
        dataClassSlotsOverwrite: '__slots__ 클래스에 이미 정의되어 있습니다.',
        dataClassTransformExpectedBoolLiteral: '정적으로 True 또는 False로 계산되는 식이 필요합니다.',
        dataClassTransformFieldSpecifier: '클래스 또는 함수의 tuple이 필요하지만 “{type}” 형식을 받았습니다.',
        dataClassTransformPositionalParam: '"dataclass_transform"에 대한 모든 인수는 키워드 인수여야 합니다.',
        dataClassTransformUnknownArgument: 'dataclass_transform은 "{name}" 인수를 지원하지 않습니다.',
        dataProtocolInSubclassCheck: '데이터 프로토콜(비 메서드 특성 포함)은 issubclass 호출에서 허용되지 않습니다.',
        declaredReturnTypePartiallyUnknown: '선언된 반환 형식 "{returnType}"을(를) 부분적으로 알 수 없습니다.',
        declaredReturnTypeUnknown: '선언된 반환 형식을 알 수 없습니다.',
        defaultValueContainsCall: '매개 변수 기본값 식 내에서는 함수 호출 및 변경 가능한 개체를 사용할 수 없습니다.',
        defaultValueNotAllowed: '"*" 또는 "**"가 있는 매개 변수는 기본값을 가질 수 없습니다.',
        delTargetExpr: '식을 삭제할 수 없습니다.',
        deprecatedClass: '‘{name}’ 클래스는 사용되지 않습니다.',
        deprecatedConstructor: '클래스 "{name}"의 생성자는 더 이상 사용되지 않습니다.',
        deprecatedDescriptorDeleter: '"{name}" 설명자에 대한 "____delete____" 메서드는 사용되지 않습니다.',
        deprecatedDescriptorGetter: '"{name}" 설명자에 대한 "__get__" 메서드는 사용되지 않습니다.',
        deprecatedDescriptorSetter: '"{name}" 설명자에 대한 "__set__" 메서드는 사용되지 않습니다.',
        deprecatedFunction: '"{name}" 함수는 더 이상 사용되지 않습니다.',
        deprecatedMethod: '"{className}" 클래스의 "{name}" 메서드는 더 이상 사용되지 않습니다.',
        deprecatedPropertyDeleter: '"{name}" property에 대한 deleter는 사용되지 않습니다.',
        deprecatedPropertyGetter: '"{name}" property에 대한 getter는 사용되지 않습니다.',
        deprecatedPropertySetter: '"{name}" property에 대한 setter는 사용되지 않습니다.',
        deprecatedType: '이 형식은 Python {version}부터 사용되지 않습니다. 대신 "{replacement}"을(를) 사용하세요.',
        dictExpandIllegalInComprehension: '사전 확장은 이해에 사용할 수 없습니다.',
        dictInAnnotation: '형식 식에는 사전 식을 사용할 수 없습니다.',
        dictKeyValuePairs: '사전 항목은 키/값 쌍을 포함해야 합니다.',
        dictUnpackIsNotMapping: '사전 압축 풀기 연산자에 대한 매핑이 필요합니다.',
        dunderAllSymbolNotPresent: '"{name}"이(가) __all__에 지정되었지만 모듈에 없습니다.',
        duplicateArgsParam: '"*" 매개 변수 하나만 허용됨',
        duplicateBaseClass: '중복 기본 클래스는 허용되지 않습니다.',
        duplicateCapturePatternTarget: '‘{name}’ 캡처 대상이 동일한 패턴 내에 두 번 이상 나타날 수 없습니다.',
        duplicateCatchAll: '하나의 catch-all except 절만 허용됨',
        duplicateEnumMember: 'Enum 멤버 "{name}"이(가) 이미 선언되었습니다.',
        duplicateGenericAndProtocolBase: '하나의 Generic[...] 또는 Protocol[...] 기본 클래스만 허용됩니다.',
        duplicateImport: '"{importName}"을(를) 두 번 이상 가져왔습니다.',
        duplicateKeywordOnly: '"*" 구분 기호는 하나만 사용할 수 있습니다.',
        duplicateKwargsParam: '"**" 매개 변수 하나만 허용됨',
        duplicateParam: '매개 변수 "{name}"이(가) 중복되었습니다.',
        duplicatePositionOnly: '‘/’ 매개 변수 하나민 허용됩니다.',
        duplicateStarPattern: '패턴 시퀀스에는 ‘*’ 패턴을 하나만 사용할 수 있습니다.',
        duplicateStarStarPattern: '‘**’ 항목 하나만 허용됩니다.',
        duplicateUnpack: 'list에서는 한 개의 압축 풀기 작업만 허용됩니다.',
        ellipsisAfterUnpacked: '"..." 압축을 풀고 있는 TypeVarTuple 또는 tuple과 함께 사용할 수 없습니다.',
        ellipsisContext: '"..."는 이 컨텍스트에서는 허용되지 않습니다.',
        ellipsisSecondArg: '"..."는 두 인수 중 두 번째 인수로만 허용됩니다.',
        enumClassOverride: 'Enum 클래스 "{name}"은(는) final 클래스이며 서브클래스할 수 없습니다.',
        enumMemberDelete: 'Enum 멤버 "{name}"을(를) 삭제할 수 없음',
        enumMemberSet: 'Enum 멤버 "{name}"을(를) 할당할 수 없음',
        enumMemberTypeAnnotation: 'Type annotations are not allowed for enum members',
        exceptGroupMismatch: 'Try 문에는 "except"와 "except*"를 둘 다 포함할 수 없습니다',
        exceptGroupRequiresType: '예외 그룹 구문("except*")에는 예외 형식이 필요합니다',
        exceptionGroupIncompatible: '예외 그룹 구문("except*")에는 Python 3.11 이상이 필요합니다.',
        exceptionGroupTypeIncorrect: 'except*의 예외 형식은 BaseGroupException에서 파생될 수 없습니다.',
        exceptionTypeIncorrect: '‘{type}’은 BaseException에서 파생되지 않습니다.',
        exceptionTypeNotClass: '"{type}"은(는) 올바른 예외 클래스가 아닙니다.',
        exceptionTypeNotInstantiable: '예외 형식 "{type}"에 대한 생성자에는 하나 이상의 인수가 필요합니다.',
        expectedAfterDecorator: '데코레이터 다음에 함수 또는 클래스 선언이 필요합니다.',
        expectedArrow: '"->" 다음에 반환 형식 주석이 와야 합니다.',
        expectedAsAfterException: '예외 형식 뒤에 ‘as’가 필요합니다.',
        expectedAssignRightHandExpr: '"=" 오른쪽에 식이 필요합니다.',
        expectedBinaryRightHandExpr: '연산자 오른쪽에 식이 필요합니다.',
        expectedBoolLiteral: 'True 또는 False가 필요합니다.',
        expectedCase: '"case" 문이 필요합니다.',
        expectedClassName: '클래스 이름이 필요합니다.',
        expectedCloseBrace: '"{"가 닫혀 있지 않습니다.',
        expectedCloseBracket: '"[{0}"이(가) 닫혀 있지 않습니다.',
        expectedCloseParen: '"("가 닫혀 있지 않음',
        expectedColon: '\':\'가 필요합니다.',
        expectedComplexNumberLiteral: '패턴 일치에 복소수 리터럴이 필요합니다.',
        expectedDecoratorExpr: 'Python 3.9 이전의 데코레이터에는 식 형식이 지원되지 않습니다.',
        expectedDecoratorName: '데코레이터 이름이 필요합니다.',
        expectedDecoratorNewline: '데코레이터 끝에 새 줄이 필요합니다.',
        expectedDelExpr: '"del" 뒤에 식이 필요합니다.',
        expectedElse: '"else"가 필요합니다.',
        expectedEquals: '"="가 필요합니다.',
        expectedExceptionClass: '잘못된 예외 클래스 또는 개체',
        expectedExceptionObj: '필요한 예외 개체, 예외 클래스 또는 None',
        expectedExpr: '식이 필요합니다.',
        expectedFunctionAfterAsync: '‘async’ 다음에 함수 정의가 필요합니다.',
        expectedFunctionName: '"def" 뒤에 함수 이름이 필요합니다.',
        expectedIdentifier: '식별자가 필요합니다.',
        expectedImport: '"import"가 필요합니다.',
        expectedImportAlias: '"as" 뒤에 기호가 필요합니다.',
        expectedImportSymbols: '"import" 뒤에 하나 이상의 기호 이름이 필요합니다.',
        expectedIn: '"in"이 필요합니다.',
        expectedInExpr: '"in" 뒤에 식이 필요합니다.',
        expectedIndentedBlock: '들여쓰기 블록이 필요합니다.',
        expectedMemberName: '"." 뒤에 특성 이름 필요',
        expectedModuleName: '필요한 모듈 이름',
        expectedNameAfterAs: '‘as’ 뒤에는 기호 이름이 와야 합니다.',
        expectedNamedParameter: '키워드 매개 변수는 "*"를 따라야 합니다.',
        expectedNewline: '줄 바꿈이 필요합니다.',
        expectedNewlineOrSemicolon: '문은 줄 바꿈 또는 세미콜론으로 구분해야 합니다.',
        expectedOpenParen: '’(‘가 필요합니다.',
        expectedParamName: '매개 변수 이름이 필요합니다.',
        expectedPatternExpr: '패턴 식이 필요합니다.',
        expectedPatternSubjectExpr: '패턴 제목 식이 필요합니다.',
        expectedPatternValue: '"a.b" 형식의 패턴 값 식이 필요합니다.',
        expectedReturnExpr: '"return" 뒤에 식이 필요합니다.',
        expectedSliceIndex: '인덱스 또는 조각 식이 필요합니다.',
        expectedTypeNotString: '형식이 필요하지만 문자열 리터럴을 받았습니다.',
        expectedTypeParameterName: '형식 매개 변수 이름이 필요합니다.',
        expectedYieldExpr: 'yield 문에 식이 필요합니다.',
        finalClassIsAbstract: '"{type}" 클래스가 final로 표시되어 있으며 모든 추상 기호를 구현해야 합니다.',
        finalContext: '"Final"은 이 컨텍스트에서 허용되지 않습니다.',
        finalInLoop: '루프 내에는 "Final" 변수를 할당할 수 없습니다.',
        finalMethodOverride: '"{name}" 메서드는 "{className}" 클래스에 정의된 final 메서드를 재정의할 수 없습니다.',
        finalNonMethod: '함수 "{name}"은(는) 메서드가 아니므로 @final로 표시할 수 없습니다.',
        finalReassigned: '‘{name}’이 Final로 선언되었으므로 다시 할당할 수 없습니다.',
        finalRedeclaration: '"{name}"이(가) 이전에 Final로 선언되었습니다.',
        finalRedeclarationBySubclass: '부모 클래스 "{className}"이(가) Final로 선언하므로 "{name}"을(를) 다시 선언할 수 없습니다.',
        finalTooManyArgs: '"Final" 뒤에 단일 형식 인수가 필요합니다.',
        finalUnassigned: '"{name}"이(가) Final로 선언되었지만 값이 할당되지 않았습니다.',
        formatStringBrace: 'f-string 리터럴 내에서는 단일 닫는 중괄호를 사용할 수 없습니다. 이중 닫는 중괄호를 사용하세요.',
        formatStringBytes: '형식 문자열 리터럴(f-strings)은 이진일 수 없습니다.',
        formatStringDebuggingIllegal: 'F-string 디버깅 지정자인 ‘=’는 Python 3.8 이상이 필요합니다.',
        formatStringEscape: 'Python 3.12 이전의 f-string의 식 부분에 이스케이프 시퀀스(백슬래시)를 사용할 수 없습니다.',
        formatStringExpectedConversion: 'f-string에서 "!" 뒤에 변환 지정자가 필요합니다.',
        formatStringIllegal: '형식 문자열 리터럴(f-strings)은 Python 3.6 이상이 필요합니다.',
        formatStringInPattern: '패턴에서 형식 문자열을 사용할 수 없습니다.',
        formatStringNestedFormatSpecifier: '형식 문자열 지정자 내에 너무 깊게 중첩된 식',
        formatStringNestedQuote: 'f-string 내에 중첩된 문자열은 Python 3.12 이전의 f-string과 같은 따옴표를 사용할 수 없습니다.',
        formatStringUnicode: '형식 문자열 리터럴(f-문자열)은 유니코드일 수 없습니다.',
        formatStringUnterminated: 'f-string에 종결되지 않은 식이 있습니다. ‘}‘가 필요합니다.',
        functionDecoratorTypeUnknown: '형식화되지 않은 함수 데코레이터는 함수 형식을 모호하게 합니다. 데코레이터 무시',
        functionInConditionalExpression: '조건식은 항상 True로 평가되는 함수를 참조합니다.',
        functionTypeParametersIllegal: '함수 형식 매개 변수 구문에는 Python 3.12 이상이 필요합니다.',
        futureImportLocationNotAllowed: '__future__ 가져오기는 파일의 시작 부분에 있어야 합니다.',
        generatorAsyncReturnType: 'async 생성기 함수의 반환 형식은 "AsyncGenerator[{yieldType}, Any]"와 호환되어야 합니다.',
        generatorNotParenthesized: '생성기 식은 단독 인수가 아닌 경우 괄호로 지정해야 합니다.',
        generatorSyncReturnType: '생성기 함수의 반환 형식은 "Generator[{yieldType}, Any, Any]"와 호환되어야 합니다.',
        genericBaseClassNotAllowed: '"Generic" 기본 클래스는 형식 매개 변수 구문과 함께 사용할 수 없습니다.',
        genericClassAssigned: '제네릭 클래스 형식을 할당할 수 없습니다.',
        genericClassDeleted: '제네릭 클래스 형식을 삭제할 수 없습니다.',
        genericInstanceVariableAccess: '클래스를 통한 제네릭 인스턴스 변수에 대한 액세스가 모호합니다.',
        genericNotAllowed: '이 컨텍스트에서 "Generic"이 잘못되었습니다.',
        genericTypeAliasBoundTypeVar: '클래스 내의 제네릭 형식 별칭은 바인딩된 형식 변수 {names}을(를) 사용할 수 없습니다.',
        genericTypeArgMissing: '"Generic"에는 하나 이상의 형식 인수가 필요합니다.',
        genericTypeArgTypeVar: '"Generic"의 형식 인수는 형식 변수여야 합니다.',
        genericTypeArgUnique: '"Generic"의 형식 인수는 고유해야 합니다.',
        globalReassignment: 'global 선언 전에 "{name}"이(가) 할당되었습니다.',
        globalRedefinition: '"{name}"이(가) 이미 global로 선언되었습니다.',
        implicitStringConcat: '암시적 문자열 연결이 허용되지 않습니다.',
        importCycleDetected: '가져오기 체인에서 순환이 검색되었습니다.',
        importDepthExceeded: '가져오기 체인 깊이가 {depth}을(를) 초과했습니다.',
        importResolveFailure: '가져오기 "{importName}"을(를) 확인할 수 없습니다.',
        importSourceResolveFailure: '원본에서 가져오기 "{importName}"을(를) 확인할 수 없습니다.',
        importSymbolUnknown: '"{name}"은(는) 알 수 없는 가져오기 기호입니다.',
        incompatibleMethodOverride: '"{name}" 메서드가 호환되지 않는 방식으로 "{className}" 클래스를 재정의합니다.',
        inconsistentIndent: '들여쓰기하지 않은 양이 이전 들여쓰기와 일치하지 않습니다.',
        inconsistentTabs: '들여쓰기에서 탭 및 공백의 일관성 없는 사용',
        initMethodSelfParamTypeVar: '"__init__" 메서드의 "self" 매개 변수에 대한 형식 주석에는 클래스 범위 형식 변수를 포함할 수 없음',
        initMustReturnNone: '"__init__"의 반환 형식은 None이어야 합니다.',
        initSubclassCallFailed: '__init_subclass__ 메서드의 키워드 인수가 잘못됨',
        initSubclassClsParam: '__init_subclass__ 재정의는 "cls" 매개 변수를 사용해야 합니다.',
        initVarNotAllowed: '이 컨텍스트에서는 "InitVar"가 허용되지 않습니다.',
        instanceMethodSelfParam: '인스턴스 메서드는 "self" 매개 변수를 사용해야 합니다.',
        instanceVarOverridesClassVar: '‘{name}’ 인스턴스 변수가 ‘{className}’ 클래스에서 같은 이름의 클래스 변수를 재정의합니다.',
        instantiateAbstract: '\'{type}\' 추상 클래스를 인스턴스화할 수 없습니다.',
        instantiateProtocol: 'Protocol 클래스 "{type}"을(를) 인스턴스화할 수 없습니다.',
        internalBindError: '파일 "{file}"을(를) 바인딩하는 동안 내부 오류가 발생했습니다. {message}',
        internalParseError: '파일 "{file}"을(를) 구문 분석하는 동안 내부 오류가 발생했습니다. {message}',
        internalTypeCheckingError: '파일 "{file}"의 형식을 확인하는 동안 내부 오류가 발생했습니다. {message}',
        invalidIdentifierChar: '식별자에 잘못된 문자가 있습니다.',
        invalidStubStatement: '형식 stub 파일 내에서는 문이 의미가 없습니다.',
        invalidTokenChars: '토큰에 잘못된 문자 ‘{text}’이(가) 있습니다.',
        isInstanceInvalidType: '"isinstance"에 대한 두 번째 인수는 클래스 또는 클래스의 tuple이어야 합니다.',
        isSubclassInvalidType: '"issubclass"에 대한 두 번째 인수는 클래스 또는 클래스의 tuple이어야 합니다.',
        keyValueInSet: 'set 내에서 키/값 쌍을 사용할 수 없습니다.',
        keywordArgInTypeArgument: '키워드 인수는 형식 인수 목록에서 사용할 수 없습니다.',
        keywordArgShortcutIllegal: '키워드 인수 바로 가기에는 Python 3.14 이상 필요',
        keywordOnlyAfterArgs: '키워드 전용 인수 구분 기호는 "*" 매개 변수 뒤에 사용할 수 없습니다.',
        keywordParameterMissing: '하나 이상의 키워드 매개 변수는 ’*‘ 매개 변수 뒤에 와야 합니다.',
        keywordSubscriptIllegal: '아래 첨자 내의 키워드 인수는 지원되지 않습니다.',
        lambdaReturnTypePartiallyUnknown: '람다의 반환 형식 "{returnType}"을(를) 부분적으로 알 수 없습니다.',
        lambdaReturnTypeUnknown: '람다의 반환 형식을 알 수 없습니다.',
        listAssignmentMismatch: '형식이 "{type}"인 식을 대상 목록에 할당할 수 없습니다.',
        listInAnnotation: '형식 식에는 List 식을 사용할 수 없습니다.',
        literalEmptyArgs: '‘Literal’ 뒤에 하나 이상의 형식 인수가 필요합니다.',
        literalNamedUnicodeEscape: '명명된 유니코드 이스케이프 시퀀스는 "Literal" 문자열 주석에서 지원되지 않습니다.',
        literalNotAllowed: '형식 인수가 없으면 이 컨텍스트에서 "Literal"을 사용할 수 없습니다.',
        literalNotCallable: 'Literal 형식은 인스턴스화할 수 없습니다.',
        literalUnsupportedType: '"Literal"의 형식 인수는 None, 리터럴 값(int, bool, str 또는 bytes) 또는 enum 값이어야 합니다.',
        matchIncompatible: 'Match 문에는 Python 3.10 이상이 필요합니다.',
        matchIsNotExhaustive: 'match 문 내의 사례는 모든 값을 완전히 처리하지 않습니다.',
        maxParseDepthExceeded: '최대 구문 분석 깊이를 초과했습니다. 식을 더 작은 하위 식으로 나누기',
        memberAccess: '"{type}" 클래스의 "{name}" 특성에 액세스할 수 없음',
        memberDelete: '"{type}" 클래스의 "{name}" 특성을 삭제할 수 없음',
        memberSet: '"{type}" 클래스의 "{name}" 특성에 할당할 수 없음',
        metaclassConflict: '파생 클래스의 메타클래스는 모든 기본 클래스의 메타클래스의 서브클래스여야 합니다.',
        metaclassDuplicate: '메타클래스를 하나만 제공할 수 있습니다.',
        metaclassIsGeneric: '메타클래스는 제네릭일 수 없습니다.',
        methodNotDefined: '"{name}" 메서드가 정의되지 않았습니다.',
        methodNotDefinedOnType: '"{name}" 메서드가 "{type}" 형식에 정의되지 않았습니다.',
        methodOrdering: '일관된 메서드 순서를 만들 수 없습니다.',
        methodOverridden: '‘{name}’은(는) ‘{className}’ 클래스에서 같은 이름의 메서드를 호환되지 않는 ‘{type}’ 형식으로 재정의합니다.',
        methodReturnsNonObject: '"{name}" 메서드가 개체를 반환하지 않습니다.',
        missingSuperCall: '"{methodName}" 메서드가 부모 클래스에서 같은 이름의 메서드를 호출하지 않습니다.',
        mixingBytesAndStr: 'Bytes 및 str 값을 연결할 수 없습니다.',
        moduleAsType: '모듈은 형식으로 사용할 수 없습니다.',
        moduleNotCallable: '모듈을 호출할 수 없습니다.',
        moduleUnknownMember: '‘{memberName}’은(는) ‘{moduleName}’ 모듈의 알려진 특성이 아님',
        namedExceptAfterCatchAll: '명명된 except 절은 catch-all except 절 뒤에 나타날 수 없습니다.',
        namedParamAfterParamSpecArgs: 'ParamSpec args 매개 변수 뒤에 키워드 매개 변수 "{name}"을(를) 시그니처에 표시할 수 없습니다.',
        namedTupleEmptyName: '명명된 tuple 내의 이름은 비워 둘 수 없습니다.',
        namedTupleEntryRedeclared: '부모 클래스 "{className}"이(가) 명명된 tuple이므로 "{name}"을(를) 재정의할 수 없습니다.',
        namedTupleFirstArg: '명명된 tuple 클래스 이름이 첫 번째 인수로 필요합니다.',
        namedTupleMultipleInheritance: 'NamedTuple을 사용한 여러 상속은 지원되지 않습니다.',
        namedTupleNameKeyword: '필드 이름은 키워드일 수 없습니다.',
        namedTupleNameType: '항목 이름 및 형식을 지정하는 2개 항목 tuple이 필요합니다.',
        namedTupleNameUnique: '명명된 tuple 내의 이름은 고유해야 합니다.',
        namedTupleNoTypes: '"namedtuple"은 튜플 항목에 대한 형식을 제공하지 않습니다. 대신 "NamedTuple" 사용',
        namedTupleSecondArg: '두 번째 인수로 명명된 tuple 항목 list가 필요합니다.',
        newClsParam: '__new__ 재정의는 "cls" 매개 변수를 사용해야 합니다.',
        newTypeAnyOrUnknown: 'NewType에 대한 두 번째 인수는 Any 또는 Unknown이 아닌 알려진 클래스여야 합니다.',
        newTypeBadName: 'NewType의 첫 번째 인수는 문자열 리터럴이어야 합니다.',
        newTypeLiteral: 'NewType은 Literal 형식과 함께 사용할 수 없습니다.',
        newTypeNameMismatch: 'NewType은 이름이 같은 변수에 할당되어야 합니다.',
        newTypeNotAClass: 'NewType에 대한 두 번째 인수로 클래스가 필요합니다.',
        newTypeParamCount: 'NewType에는 두 개의 위치 인수가 필요합니다.',
        newTypeProtocolClass: '구조 형식(Protocol 또는 TypedDict 클래스)과 함께 NewType을 사용할 수 없습니다.',
        noOverload: '제공된 인수와 일치하는 "{name}"에 대한 오버로드가 없습니다.',
        noReturnContainsReturn: '선언된 return 형식이 "NoReturn"인 함수는 return 문을 포함할 수 없습니다.',
        noReturnContainsYield: '선언된 반환 형식이 "NoReturn"인 함수는 yield 문을 포함할 수 없습니다.',
        noReturnReturnsNone: '선언된 반환 형식이 "NoReturn"인 함수는 "None"을 반환할 수 없습니다.',
        nonDefaultAfterDefault: '기본값이 아닌 인수가 기본 인수를 따릅니다.',
        nonLocalInModule: '모듈 수준에서는 Nonlocal 선언을 사용할 수 없습니다.',
        nonLocalNoBinding: 'No binding for nonlocal "{name}" found',
        nonLocalReassignment: '"{name}" is assigned before nonlocal declaration',
        nonLocalRedefinition: '"{name}"이(가) 이미 nonlocal로 선언되었습니다.',
        noneNotCallable: '‘None’ 유형의 개체를 호출할 수 없습니다.',
        noneNotIterable: '"None" 형식의 개체는 반복 가능한 값으로 사용할 수 없습니다.',
        noneNotSubscriptable: '’None’ 유형의 개체는 아래 첨자를 사용할 수 없습니다.',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: '"None"에 대해 연산자 "{operator}"이(가) 지원되지 않습니다.',
        noneUnknownMember: '"{name}"은(는) "None"의 알려진 특성이 아님',
        notRequiredArgCount: '"NotRequired" 뒤에 단일 형식 인수가 필요합니다.',
        notRequiredNotInTypedDict: '이 컨텍스트에서는 "NotRequired"를 사용할 수 없습니다.',
        objectNotCallable: '"{type}" 형식의 개체를 호출할 수 없습니다.',
        obscuredClassDeclaration: '클래스 선언 "{name}"이(가) 같은 이름의 선언으로 가려져 있습니다.',
        obscuredFunctionDeclaration: '함수 선언 "{name}"이(가) 동일한 이름의 선언으로 가려집니다.',
        obscuredMethodDeclaration: '메서드 선언 "{name}"이(가) 동일한 이름의 선언으로 가려집니다.',
        obscuredParameterDeclaration: '매개 변수 선언 "{name}"이(가) 동일한 이름의 선언으로 가려집니다.',
        obscuredTypeAliasDeclaration: '형식 별칭 선언 "{name}"이(가) 동일한 이름의 선언으로 가려집니다.',
        obscuredVariableDeclaration: '"{name}" 선언이 같은 이름의 선언으로 가려집니다.',
        operatorLessOrGreaterDeprecated: '"<>" 연산자는 Python 3에서 지원되지 않습니다. 대신 "!="를 사용하세요.',
        optionalExtraArgs: '"Optional" 뒤에 1개의 형식 인수가 필요합니다.',
        orPatternIrrefutable: '되돌릴 수 없는 패턴은 ‘or’ 패턴의 마지막 하위 페이지로만 허용됩니다.',
        orPatternMissingName: '"or" 패턴 내의 모든 하위 패턴은 동일한 이름을 대상으로 해야 합니다.',
        overlappingKeywordArgs: '형식화된 사전이 키워드 매개 변수 {names}과(와) 겹칩니다.',
        overlappingOverload: '매개 변수가 오버로드 {obscuredBy}과(와) 겹치므로 "{name}"에 대한 오버로드 {obscured}이(가) 사용되지 않습니다.',
        overloadAbstractImplMismatch: '오버로드는 구현의 추상 상태와 일치해야 합니다.',
        overloadAbstractMismatch: '오버로드는 모두 추상이거나 아니어야 합니다',
        overloadClassMethodInconsistent: '"{name}"의 오버로드가 @classmethod를 일관되지 않게 사용합니다.',
        overloadFinalInconsistencyImpl: '"{name}"에 대한 오버로드가 @final로 표시되었지만 구현은 아닙니다.',
        overloadFinalInconsistencyNoImpl: '"{name}"에 대한 오버로드 {index}는 @final로 표시되지만 오버로드 1은 표시되지 않습니다.',
        overloadImplementationMismatch: '오버로드된 구현이 오버로드 {index}의 시그니처와 일치하지 않습니다.',
        overloadReturnTypeMismatch: '"{name}"에 대한 {prevIndex} 오버로드가 오버로드 {newIndex}과(와) 겹치고 호환되지 않는 형식을 반환합니다.',
        overloadStaticMethodInconsistent: '"{name}"의 오버로드가 @staticmethod를 일관되지 않게 사용합니다.',
        overloadWithoutImplementation: '“{name}“이(가) overload로 표시되어 있지만 구현이 제공되지 않았습니다.',
        overriddenMethodNotFound: '“{name}“ 메서드가 override로 표시되어 있지만 이름이 같은 기본 메서드가 없습니다.',
        overrideDecoratorMissing: '“{name}“ 메서드가 override로 표시되지 않았지만 “{className}“ 클래스에서 메서드를 재정의하고 있습니다.',
        paramAfterKwargsParam: '매개 변수는 ‘**’ 매개 변수 다음에 와야 합니다.',
        paramAlreadyAssigned: '매개 변수 "{name}"이(가) 이미 할당되었습니다.',
        paramAnnotationMissing: '‘{name}’ 매개 변수에 대한 형식 주석이 없습니다.',
        paramAssignmentMismatch: '‘{sourceType}’ 형식의 식을 ‘{paramType}’ 형식의 매개 변수에 할당할 수 없습니다.',
        paramNameMissing: '이름이 "{name}"인 매개 변수가 없습니다.',
        paramSpecArgsKwargsDuplicate: 'ParamSpec "{type}" 인수가 이미 제공되었습니다.',
        paramSpecArgsKwargsUsage: 'ParamSpec의 "args" 및 "kwargs" 특성은 모두 함수 서명 내에 나타나야 함',
        paramSpecArgsMissing: 'ParamSpec "{type}"에 대한 인수가 없습니다.',
        paramSpecArgsUsage: 'ParamSpec의 "args" 특성은 *args 매개 변수와 함께 사용할 경우에만 유효함',
        paramSpecAssignedName: 'ParamSpec을 "{name}"이라는 변수에 할당해야 합니다.',
        paramSpecContext: 'ParamSpec은 이 컨텍스트에서 허용되지 않습니다.',
        paramSpecDefaultNotTuple: 'ParamSpec의 기본값에는 줄임표, tuple 식 또는 ParamSpec이 필요합니다.',
        paramSpecFirstArg: '첫 번째 인수로 ParamSpec의 이름이 필요합니다.',
        paramSpecKwargsUsage: 'ParamSpec의 "kwargs" 특성은 **kwargs 매개 변수와 함께 사용할 경우에만 유효함',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}"은(는) 이 컨텍스트에서 의미가 없습니다.',
        paramSpecUnknownArg: 'ParamSpec은 한 개 이상의 인수를 지원하지 않습니다.',
        paramSpecUnknownMember: '"{name}"은(는) ParamSpec의 알려진 특성이 아님',
        paramSpecUnknownParam: '‘{name}’은(는) ParamSpec에 대한 알 수 없는 매개 변수입니다.',
        paramTypeCovariant: '공변(Covariant) 형식 변수는 매개 변수 형식에 사용할 수 없습니다.',
        paramTypePartiallyUnknown: '매개 변수 "{paramName}"의 형식을 부분적으로 알 수 없습니다.',
        paramTypeUnknown: '매개 변수 "{paramName}"의 형식을 알 수 없습니다.',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: '제목 형식 "{type}"에 대해 패턴이 일치하지 않습니다.',
        positionArgAfterNamedArg: '위치 인수는 키워드 인수 뒤에 나타날 수 없습니다.',
        positionOnlyAfterArgs: '위치 전용 매개 변수 구분 기호는 "*" 매개 변수 뒤에 사용할 수 없습니다.',
        positionOnlyAfterKeywordOnly: '"/" 매개 변수는 "*" 매개 변수 앞에 나타나야 합니다.',
        positionOnlyAfterNon: '위치 전용이 아닌 매개 변수 다음에는 위치 전용 매개 변수를 사용할 수 없습니다.',
        positionOnlyFirstParam: '위치 전용 매개 변수 구분 기호는 첫 번째 매개 변수로 허용되지 않습니다.',
        positionOnlyIncompatible: '위치 전용 매개 변수 구분 기호에는 Python 3.8 이상이 필요합니다.',
        privateImportFromPyTypedModule: '"{name}"은(는) "{module}" 모듈에서 내보내지지 않습니다.',
        privateUsedOutsideOfClass: '"{name}"은(는) 프라이빗이며 선언된 클래스 외부에서 사용됩니다.',
        privateUsedOutsideOfModule: '"{name}"은(는) 프라이빗이며 선언된 모듈 외부에서 사용됩니다.',
        propertyOverridden: '“{name}“은(는) “{className}“ 클래스에서 같은 이름의 property를 잘못 재정의합니다.',
        propertyStaticMethod: 'Static methods not allowed for property getter, setter or deleter',
        protectedUsedOutsideOfClass: '‘{name}’은(는) 선언된 클래스 외부에서 보호되고 사용됩니다.',
        protocolBaseClass: 'Protocol 클래스 "{classType}"은(는) Protocol 아닌 클래스 "{baseType}"에서 파생될 수 없습니다.',
        protocolBaseClassWithTypeArgs: '형식 매개 변수 구문을 사용할 때는 Protocol 클래스에 형식 인수가 허용되지 않습니다.',
        protocolIllegal: '"Protocol"을 사용하려면 Python 3.7 이상이 필요합니다.',
        protocolNotAllowed: '이 컨텍스트에서는 "Protocol"을 사용할 수 없습니다.',
        protocolTypeArgMustBeTypeParam: '"Protocol"의 형식 인수는 형식 매개 변수여야 합니다.',
        protocolUnsafeOverlap: '클래스가 "{name}"과(와) 안전하지 않게 겹치며 런타임에 일치 항목을 생성할 수 있습니다.',
        protocolVarianceContravariant: '제네릭 Protocol "{class}"에 사용되는 형식 변수 "{variable}"은(는) 반공변이어야 합니다.',
        protocolVarianceCovariant: '제네릭 Protocol "{class}"에 사용되는 형식 변수 "{variable}"은(는) 공변(covariant)이어야 합니다.',
        protocolVarianceInvariant: '제네릭 Protocol "{class}"에 사용되는 형식 변수 "{variable}"은(는) 고정되어야 합니다.',
        pyrightCommentInvalidDiagnosticBoolValue: 'Pyright 주석 지시문 뒤에는 "="와 true 또는 false 값이 와야 합니다.',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Pyright 주석 지시문 뒤에는 "="와 true, false, error, warning, information 또는 none 값이 와야 합니다.',
        pyrightCommentMissingDirective: 'Pyright 메모 뒤에는 지시문(basic 또는 strict) 또는 진단 규칙이 있어야 합니다.',
        pyrightCommentNotOnOwnLine: '파일 수준 설정을 제어하는 데 사용되는Pyright 주석은 고유의 줄에 표시되어야 합니다.',
        pyrightCommentUnknownDiagnosticRule: '"{rule}"은(는) pyright 주석에 대한 알 수 없는 진단 규칙입니다.',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}"이(가) pyright 주석에 대해 잘못된 값입니다. true, false, error, warning, information 또는 none이 필요합니다.',
        pyrightCommentUnknownDirective: '"{directive}"은(는) pyright 주석에 대한 알 수 없는 지시문입니다. "strict" 또는 "basic"이 필요합니다.',
        readOnlyArgCount: '‘ReadOnly‘ 뒤에는 단일 형식 인수가 필요합니다.',
        readOnlyNotInTypedDict: '이 컨텍스트에서는 "ReadOnly"를 사용할 수 없습니다.',
        recursiveDefinition: '‘{name}’ 형식이 스스로를 참조하므로 확인할 수 없습니다.',
        relativeImportNotAllowed: '상대 가져오기는 "import .a" 양식과 함께 사용할 수 없습니다. 대신 "from . import a"을(를) 사용합니다.',
        requiredArgCount: '‘Required’ 뒤에 단일 형식 인수가 필요합니다.',
        requiredNotInTypedDict: '이 컨텍스트에서는 "Required"를 사용할 수 없습니다.',
        returnInAsyncGenerator: '값이 있는 Return 문은 async 생성기에서 사용할 수 없습니다.',
        returnInExceptionGroup: '"except*" 블록에는 "return"을 사용할 수 없습니다',
        returnMissing: '선언된 반환 형식이 "{returnType}"인 함수는 모든 코드 경로에서 값을 반환해야 합니다.',
        returnOutsideFunction: '‘return’은 함수 내에서만 사용할 수 있습니다.',
        returnTypeContravariant: '반공변 유형 변수는 반환 형식에 사용할 수 없습니다.',
        returnTypeMismatch: '형식 "{exprType}"을 형식 "{returnType}"에 반환하도록 할당할 수 없습니다.',
        returnTypePartiallyUnknown: '반환 형식 "{returnType}"을(를) 부분적으로 알 수 없습니다.',
        returnTypeUnknown: '반환 유형을 알 수 없습니다.',
        revealLocalsArgs: '‘reveal_locals’ 호출은 인수가 필요하지 않습니다.',
        revealLocalsNone: '이 범위에 locals가 없습니다.',
        revealTypeArgs: '"reveal_type" 호출에는 단일 위치 인수가 필요합니다.',
        revealTypeExpectedTextArg: '‘reveal_type’ 함수의 ‘expected_text’ 인수는 str 리터럴 값이어야 합니다.',
        revealTypeExpectedTextMismatch: '텍스트 형식이 일치하지 않습니다. "{expected}"이(가) 필요하지만 "{received}"을(를) 받았습니다.',
        revealTypeExpectedTypeMismatch: '텍스트 형식이 일치하지 않습니다. ‘{expected}’이(가) 필요하지만 ‘{received}’을(를) 받았습니다.',
        selfTypeContext: '이 컨텍스트에서는 "Self"가 잘못되었습니다.',
        selfTypeMetaclass: '메타클래스("type"의 서브클래스) 내에서 "Self"를 사용할 수 없습니다.',
        selfTypeWithTypedSelfOrCls: '"Self"는 "Self" 이외의 형식 주석이 있는 \'self\' 또는 \'cls\' 매개 변수가 있는 함수에서 사용할 수 없습니다.',
        setterGetterTypeMismatch: 'Property setter 값 형식을 getter 반환 형식에 할당할 수 없습니다.',
        singleOverload: '"{name}"이(가) 오버로드로 표시되었지만 추가 오버로드가 없습니다.',
        slotsAttributeError: '__slots__에서 ‘{name}’이(가) 지정되지 않았습니다.',
        slotsClassVarConflict: '‘{name}‘이(가) __slots__에 선언된 instance 변수와 충돌합니다.',
        starPatternInAsPattern: '별 무늬는 "as" 대상과 함께 사용할 수 없습니다.',
        starPatternInOrPattern: '별 무늬는 다른 패턴 내에서 ORed할 수 없습니다.',
        starStarWildcardNotAllowed: '**는 와일드카드 "_"와 함께 사용할 수 없습니다.',
        staticClsSelfParam: '정적 메서드는 "self" 또는 "cls" 매개 변수를 사용하면 안 됩니다.',
        stdlibModuleOverridden: '‘{path}’이(가) ‘{name}’ stdlib 모듈을 재정의하고 있습니다.',
        stringNonAsciiBytes: 'ASCII가 아닌 문자는 바이트 문자열 리터럴에 허용되지 않습니다.',
        stringNotSubscriptable: '형식 식에서는 문자열 식을 첨자할 수 없습니다. 전체 식을 따옴표로 묶습니다.',
        stringUnsupportedEscape: '문자열 리터럴에 지원되지 않는 이스케이프 시퀀스가 있습니다.',
        stringUnterminated: '문자열 리터럴이 종료되지 않았습니다.',
        stubFileMissing: '"{importName}"에 대한 stub 파일을 찾을 수 없습니다.',
        stubUsesGetAttr: '형식 stub 파일이 불완전합니다. "__getattr__"는 모듈에 대한 형식 오류를 모호하게 합니다.',
        sublistParamsIncompatible: 'Sublist 매개 변수는 Python 3.x에서 지원되지 않습니다.',
        superCallArgCount: '‘super’ 호출에는 인수가 2개 이하여야 합니다.',
        superCallFirstArg: '"super" 호출에 대한 첫 번째 인수로 클래스 형식이 필요하지만 "{type}"을(를) 받았습니다.',
        superCallSecondArg: '"super" 호출에 대한 두 번째 인수는 "{type}"에서 파생된 개체 또는 클래스여야 합니다.',
        superCallZeroArgForm: '"super" 호출의 인수가 0인 형식은 메서드 내에서만 유효합니다.',
        superCallZeroArgFormStaticMethod: '"super" 호출의 인수가 0인 형식은 정적 메서드 내에서 유효하지 않습니다.',
        symbolIsPossiblyUnbound: '"{name}"은(는) 바인딩되지 않은 것일 수 있습니다.',
        symbolIsUnbound: '"{name}"의 바인딩이 해제되었습니다.',
        symbolIsUndefined: '"{name}"이(가) 정의되지 않았습니다.',
        symbolOverridden: '"{name}"이(가) 클래스 "{className}"에서 동일한 이름의 기호를 재정의합니다.',
        ternaryNotAllowed: '형식 식에는 3항 식이 허용되지 않습니다.',
        totalOrderingMissingMethod: '클래스는 total_ordering을 사용하려면 "__lt__", "__le__", "__gt__" 또는 "__ge__" 중 하나를 정의해야 합니다.',
        trailingCommaInFromImport: '주변 괄호 없이는 후행 쉼표를 사용할 수 없습니다.',
        tryWithoutExcept: 'try 문에는 except 또는 finally 절이 하나 이상 있어야 합니다.',
        tupleAssignmentMismatch: '형식이 “{type}“인 식을 대상 tuple에 할당할 수 없습니다.',
        tupleInAnnotation: '형식 식에는 tuple 식을 사용할 수 없습니다.',
        tupleIndexOutOfRange: '{index} 인덱스가 {type} 형식의 범위를 벗어났습니다.',
        typeAliasIllegalExpressionForm: '형식 별칭 정의에 대한 식 양식이 잘못되었습니다.',
        typeAliasIsRecursiveDirect: '형식 별칭 ‘{name}’의 정의에서 스스로를 사용할 수 없습니다.',
        typeAliasNotInModuleOrClass: 'TypeAlias는 모듈 또는 클래스 범위 내에서만 정의할 수 있습니다.',
        typeAliasRedeclared: '"{name}"은(는) TypeAlias로 선언되며 한 번만 할당할 수 있습니다.',
        typeAliasStatementBadScope: 'type 문은 모듈 또는 클래스 범위 내에서만 사용할 수 있습니다.',
        typeAliasStatementIllegal: '형식 별칭 문에는 Python 3.12 이상이 필요합니다.',
        typeAliasTypeBaseClass: '"type" 문에 정의된 형식 별칭은 기본 클래스로 사용할 수 없습니다.',
        typeAliasTypeMustBeAssigned: 'TypeAliasType은 형식 별칭과 이름이 같은 변수에 할당해야 합니다.',
        typeAliasTypeNameArg: 'TypeAliasType의 첫 번째 인수는 형식 별칭의 이름을 나타내는 문자열 리터럴이어야 합니다.',
        typeAliasTypeNameMismatch: '형식 별칭의 이름은 할당된 변수의 이름과 일치해야 합니다.',
        typeAliasTypeParamInvalid: '형식 매개 변수 목록은 TypeVar, TypeVarTuple 또는 ParamSpec만 포함하는 tuple이어야 합니다.',
        typeAnnotationCall: '형식 식에는 호출 식을 사용할 수 없습니다.',
        typeAnnotationVariable: '형식 식에는 변수를 사용할 수 없습니다.',
        typeAnnotationWithCallable: '"type"에 대한 형식 인수는 클래스여야 합니다. 콜러블은 지원되지 않습니다.',
        typeArgListExpected: 'ParamSpec, 줄임표 또는 형식의 list가 필요합니다.',
        typeArgListNotAllowed: '이 형식 인수에는 list 식을 사용할 수 없습니다.',
        typeArgsExpectingNone: '클래스 "{name}"에 형식 인수가 필요하지 않습니다.',
        typeArgsMismatchOne: '하나의 형식 인수가 필요하지만 {received}을(를) 받았습니다.',
        typeArgsMissingForAlias: '제네릭 형식 별칭 "{name}"에 대한 형식 인수가 필요합니다.',
        typeArgsMissingForClass: '‘{name}’ 제네릭 클래스에 대한 형식 인수가 필요합니다.',
        typeArgsTooFew: '"{name}"에 대해 제공된 형식 인수가 너무 적습니다. {expected}이(가) 필요하지만 {received}을(를) 받았습니다.',
        typeArgsTooMany: '‘{name}’에 대한 형식 인수가 너무 많습니다. {expected}이(가) 필요하지만 {received}을(를) 받았습니다.',
        typeAssignmentMismatch: '형식 "{sourceType}"을 선언된 형식 "{destType}"에 할당할 수 없습니다.',
        typeAssignmentMismatchWildcard: '가져오기 기호 "{name}"에 선언된 형식 "{destType}"에 할당할 수 없는 "{sourceType}" 형식이 있습니다.',
        typeCallNotAllowed: 'type() 호출은 형식 식에 사용하면 안 됩니다.',
        typeCheckOnly: '"{name}"이(가) @type_check_only로 표시되어 있으므로 형식 주석에서만 사용할 수 있습니다.',
        typeCommentDeprecated: 'type 메모는 더 이상 사용되지 않습니다. 대신 type 주석 사용',
        typeExpectedClass: '클래스가 필요하지만 "{type}"이(가) 수신됨',
        typeFormArgs: '"TypeForm"은 단일 위치 인수를 허용합니다.',
        typeGuardArgCount: '"TypeGuard" 또는 "TypeIs" 뒤에 단일 형식 인수가 필요합니다.',
        typeGuardParamCount: '사용자 정의 type guard 함수 및 메서드에는 하나 이상의 입력 매개 변수가 있어야 합니다.',
        typeIsReturnType: 'TypeIs의 반환 형식("{returnType}")이 값 매개 변수 형식("{type}")과 일치하지 않습니다.',
        typeNotAwaitable: '“{type}“은(는) awaitable이 아닙니다.',
        typeNotIntantiable: '"{type}"을(를) 인스턴스화할 수 없습니다.',
        typeNotIterable: '"{type}" 반복할 수 없습니다.',
        typeNotSpecializable: '‘{type}’ 형식을 특수화할 수 없습니다.',
        typeNotSubscriptable: '"{type}" 형식의 개체를 첨자할 수 없습니다.',
        typeNotSupportBinaryOperator: '‘{operator}’ 연산자는 ‘{leftType}’ 및 ‘{rightType}’ 형식에 대해 지원되지 않습니다.',
        typeNotSupportBinaryOperatorBidirectional: '예상 형식이 ‘{expectedType}’인 경우 ‘{leftType}’ 및 ‘{rightType}’ 형식에 대해 ‘{operator}’ 연산자가 지원되지 않습니다.',
        typeNotSupportUnaryOperator: '‘{type}’‘에 대해 ’{operator}‘ 연산자가 지원되지 않습니다.',
        typeNotSupportUnaryOperatorBidirectional: '예상 형식이 "{expectedType}" 경우 형식 "{type}"에 대해 연산자 "{operator}"이(가) 지원되지 않습니다.',
        typeNotUsableWith: '"{type}" 형식의 개체는 {method}을(를) 구현하지 않으므로 "with"와 함께 사용할 수 없습니다.',
        typeParameterBoundNotAllowed: '바운드 또는 제약 조건은 가변 인자 형식 매개 변수 또는 ParamSpec와 함께 사용할 수 없습니다.',
        typeParameterConstraintTuple: '형식 매개 변수 제약 조건은 두 개 이상의 형식 튜플이어야 합니다.',
        typeParameterExistingTypeParameter: '형식 매개 변수 "{name}"이(가) 이미 사용 중입니다.',
        typeParameterNotDeclared: '형식 매개 변수 "{name}"이(가) "{container}"의 형식 매개 변수 목록에 포함되어 있지 않습니다.',
        typeParametersMissing: '하나 이상의 형식 매개 변수를 지정해야 합니다.',
        typePartiallyUnknown: '"{name}"의 형식을 부분적으로 알 수 없습니다.',
        typeUnknown: '"{name}" 유형을 알 수 없습니다.',
        typeVarAssignedName: 'TypeVar을 "{name}"이라는 변수에 할당해야 합니다.',
        typeVarAssignmentMismatch: '‘{type}’ 형식을 ‘{name}’ 형식 변수에 할당할 수 없습니다.',
        typeVarBoundAndConstrained: 'TypeVar는 바인딩되고 제한될 수 없습니다.',
        typeVarBoundGeneric: 'TypeVar 바인딩 형식은 제네릭일 수 없습니다.',
        typeVarConstraintGeneric: 'TypeVar 제약 조건 형식은 제네릭일 수 없습니다.',
        typeVarDefaultBoundMismatch: 'TypeVar 기본 형식은 바인딩된 형식의 하위 형식이어야 합니다.',
        typeVarDefaultConstraintMismatch: 'TypeVar 기본 형식은 제약이 있는 형식 중 하나여야 합니다.',
        typeVarDefaultIllegal: '형식 변수 기본 형식은 Python 3.13 이상이 필요합니다.',
        typeVarDefaultInvalidTypeVar: '형식 매개 변수 "{name}"에 범위를 벗어난 하나 이상의 형식 변수를 참조하는 기본 형식이 있습니다.',
        typeVarFirstArg: 'TypeVar의 이름이 첫 번째 인수로 필요합니다.',
        typeVarInvalidForMemberVariable: '특성 형식은 로컬 메서드로 범위가 지정된 "{name}" 형식 변수를 사용할 수 없음',
        typeVarNoMember: 'TypeVar "{type}"에 특성 "{name}"이(가) 없음',
        typeVarNotSubscriptable: 'TypeVar "{type}"을(를) 첨자할 수 없습니다.',
        typeVarNotUsedByOuterScope: '형식 변수 "{name}"은(는) 이 컨텍스트에서 의미가 없습니다.',
        typeVarPossiblyUnsolvable: '호출자가 ‘{param}’ 매개 변수에 대한 인수를 제공하지 않으면 ‘{name}’ 형식 변수가 확인되지 않을 수 있습니다.',
        typeVarSingleConstraint: 'TypeVar에는 두 개 이상의 제한된 형식이 있어야 합니다.',
        typeVarTupleConstraints: 'TypeVarTuple에는 값 제약 조건이 있을 수 없습니다.',
        typeVarTupleContext: 'TypeVarTuple은 이 컨텍스트에서 허용되지 않습니다.',
        typeVarTupleDefaultNotUnpacked: 'TypeVarTuple 기본 형식은 압축을 푼 tuple 또는 TypeVarTuple이어야 합니다.',
        typeVarTupleMustBeUnpacked: 'TypeVarTuple 값에는 압축 풀기 연산자가 필요합니다.',
        typeVarTupleUnknownParam: '"{name}"은(는) TypeVarTuple에 대한 알 수 없는 매개 변수입니다.',
        typeVarUnknownParam: '‘{name}’은(는) TypeVar에 대한 알 수 없는 매개 변수입니다.',
        typeVarUsedByOuterScope: 'TypeVar ‘{name}’은(는) 외부 범위에서 이미 사용 중입니다.',
        typeVarUsedOnlyOnce: 'TypeVar "{name}"이(가) 제네릭 함수 시그니처에 한 번만 나타납니다.',
        typeVarVariance: 'TypeVar는 공변이면서 반공변일 수 없습니다.',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}"에 기본값이 있으며 TypeVarTuple "{variadicName}"을(를) 따를 수 없습니다.',
        typeVarWithoutDefault: '‘{name}’은 기본 형식이 없으므로 형식 매개 변수 목록에서 ‘{other}’ 뒤에 나타날 수 없습니다.',
        typeVarsNotInGenericOrProtocol: 'Generic[] 또는 Protocol[]에는 모든 형식 변수가 포함되어야 합니다.',
        typedDictAccess: 'TypedDict의 항목에 액세스할 수 없습니다.',
        typedDictAssignedName: 'TypedDict를 "{name}"이라는 변수에 할당해야 합니다.',
        typedDictBadVar: 'TypedDict 클래스는 형식 주석만 포함할 수 있습니다.',
        typedDictBaseClass: 'TypedDict 클래스의 모든 기본 클래스도 TypedDict 클래스여야 합니다.',
        typedDictBoolParam: '"{name}" 매개 변수에 True 또는 False 값이 있어야 합니다.',
        typedDictClosedExtras: '기본 클래스 "{name}"은(는) closed TypedDict입니다. 추가 항목은 "{type}" 형식이어야 합니다.',
        typedDictClosedNoExtras: '기본 클래스 "{name}"은(는) closed TypedDict입니다. 추가 항목은 허용되지 않습니다.',
        typedDictDelete: 'TypedDict에서 항목을 삭제할 수 없습니다.',
        typedDictEmptyName: 'TypedDict 내의 이름은 비워 둘 수 없습니다.',
        typedDictEntryName: '사전 항목 이름에 필요한 문자열 리터럴',
        typedDictEntryUnique: '사전 내의 이름은 고유해야 합니다.',
        typedDictExtraArgs: '추가 TypedDict 인수가 지원되지 않음',
        typedDictExtraItemsClosed: '추가 항목을 지원하는 경우 TypedDict를 closed 수 없습니다.',
        typedDictFieldNotRequiredRedefinition: 'TypedDict 항목 "{name}"은(는) NotRequired로 재정의될 수 없습니다.',
        typedDictFieldReadOnlyRedefinition: 'TypedDict 항목 "{name}"은(는) ReadOnly로 재정의될 수 없습니다.',
        typedDictFieldRequiredRedefinition: 'TypedDict 항목 "{name}"은(는) Required로 재정의될 수 없습니다.',
        typedDictFirstArg: 'TypedDict 클래스 이름이 첫 번째 인수로 필요합니다.',
        typedDictInClassPattern: 'TypedDict 클래스는 클래스 패턴에서 사용할 수 없습니다.',
        typedDictInitsubclassParameter: 'TypedDict는 __init_subclass__ 매개 변수 "{name}"을(를) 지원하지 않습니다.',
        typedDictNotAllowed: '이 컨텍스트에서는 "TypedDict"를 사용할 수 없습니다.',
        typedDictSecondArgDict: '두 번째 매개 변수로 dict 또는 키워드 매개 변수가 필요합니다.',
        typedDictSecondArgDictEntry: '단순 사전 항목이 필요합니다.',
        typedDictSet: 'TypedDict에서 항목을 할당할 수 없습니다.',
        unaccessedClass: '‘{name}’ 클래스에 액세스할 수 없습니다.',
        unaccessedFunction: '함수 "{name}"에 액세스할 수 없습니다.',
        unaccessedImport: '가져오기 "{name}"에 액세스할 수 없습니다.',
        unaccessedSymbol: '"{name}"에 액세스할 수 없습니다.',
        unaccessedVariable: '변수 "{name}"에 액세스할 수 없습니다.',
        unannotatedFunctionSkipped: '주석이 없으므로 ‘{name}’ 함수 분석을 건너뜁니다.',
        unaryOperationNotAllowed: '단항 연산자는 형식 식에 사용할 수 없습니다.',
        unexpectedAsyncToken: '"async"를 따르려면 "def", "with" 또는 "for"가 필요합니다.',
        unexpectedExprToken: '식 끝에 예기치 않은 토큰이 있습니다.',
        unexpectedIndent: '예기치 않은 들여쓰기',
        unexpectedUnindent: '들여쓰기가 필요 없음',
        unhashableDictKey: '사전 키는 해시 가능해야 합니다.',
        unhashableSetEntry: 'Set 항목은 해시가 가능해야 합니다.',
        uninitializedAbstractVariables: '추상 기본 클래스에 정의된 변수가 final 클래스 "{classType}"에서 초기화되지 않았습니다.',
        uninitializedInstanceVariable: '인스턴스 변수 "{name}"이(가) 클래스 본문 또는 __init__ 메서드에서 초기화되지 않았습니다.',
        unionForwardReferenceNotAllowed: 'Union 구문은 문자열 피연산자에서 사용할 수 없습니다. 전체 식 주위에 따옴표 사용',
        unionSyntaxIllegal: '공용 구조체에 대한 대체 구문에는 Python 3.10 이상이 필요합니다.',
        unionTypeArgCount: 'Union에는 둘 이상의 형식 인수가 필요합니다.',
        unionUnpackedTuple: 'Union은 압축을 푼 tuple을 포함할 수 없습니다.',
        unionUnpackedTypeVarTuple: 'Union은 압축을 푼 TypeVarTuple을 포함할 수 없습니다.',
        unnecessaryCast: '불필요한 "cast" 호출입니다. 형식이 이미 “{type}“입니다.',
        unnecessaryIsInstanceAlways: '불필요한 isinstance 호출입니다. "{testType}"은(는) 항상 "{classType}"의 인스턴스입니다.',
        unnecessaryIsInstanceNever: '불필요한 isinstance 호출입니다. "{testType}"은(는) 항상 "{classType}"의 인스턴스입니다.',
        unnecessaryIsSubclassAlways: '불필요한 issubclass 호출입니다. ’{testType}‘은(는) 항상 ’{classType}‘의 하위 클래스입니다.',
        unnecessaryIsSubclassNever: '불필요한 issubclass 호출입니다. ’{testType}‘은(는) 항상 ’{classType}‘의 하위 클래스입니다.',
        unnecessaryPyrightIgnore: '불필요한 "# pyright: ignore" 메모입니다.',
        unnecessaryPyrightIgnoreRule: '불필요한 "# pyright: ignore" 규칙: "{name}"',
        unnecessaryTypeIgnore: '불필요한 "# type: ignore" 메모입니다.',
        unpackArgCount: '"Unpack" 뒤에는 단일 형식 인수가 필요합니다.',
        unpackExpectedTypeVarTuple: 'Unpack에 대한 형식 인수로 TypeVarTuple 또는 tuple이 필요합니다.',
        unpackExpectedTypedDict: 'Unpack을 위해서는 TypedDict 형식 인수가 필요합니다.',
        unpackIllegalInComprehension: '압축 풀기 작업은 이해에서 사용할 수 없습니다.',
        unpackInAnnotation: '형식 식에는 Unpack 연산자를 사용할 수 없습니다.',
        unpackInDict: '사전에서 압축 풀기 작업이 허용되지 않음',
        unpackInSet: 'set 내에서는 압축 풀기 연산자를 사용할 수 없습니다.',
        unpackNotAllowed: '이 컨텍스트에서는 Unpack이 허용되지 않습니다.',
        unpackOperatorNotAllowed: '이 컨텍스트에서는 압축 풀기 작업이 허용되지 않습니다.',
        unpackTuplesIllegal: 'Python 3.8 이전의 튜플에서는 압축 풀기 작업이 허용되지 않습니다.',
        unpackedArgInTypeArgument: '압축을 푼 인수는 이 컨텍스트에서 사용할 수 없음',
        unpackedArgWithVariadicParam: '압축을 푼 인수는 TypeVarTuple 매개 변수에 사용할 수 없습니다.',
        unpackedDictArgumentNotMapping: '** 뒤의 인수 식은 "str" 키 형식의 매핑이어야 합니다.',
        unpackedDictSubscriptIllegal: '아래 첨자에서 사전 압축 풀기 연산자는 사용할 수 없습니다.',
        unpackedSubscriptIllegal: '아래 첨자의 압축 풀기 연산자에는 Python 3.11 이상이 필요합니다.',
        unpackedTypeVarTupleExpected: '압축 해제된 TypeVarTuple이 필요합니다. Unpack[{name1}] 또는 *{name2} 사용',
        unpackedTypedDictArgument: '압축되지 않은 TypedDict 인수를 매개 변수와 일치시킬 수 없습니다.',
        unreachableCode: '코드에 접근할 수 없습니다.',
        unreachableCodeType: '형식 분석을 통해 코드에 연결할 수 없음을 나타냅니다.',
        unreachableExcept: '예외가 이미 처리되었으므로 Except 절에 연결할 수 없습니다.',
        unsupportedDunderAllOperation: '"__all__"에 대한 작업이 지원되지 않으므로 내보낸 기호 목록이 잘못되었을 수 있습니다.',
        unusedCallResult: '호출 식의 결과가 ‘{type}’ 형식이므로 사용되지 않습니다. 의도적인 경우 변수 ‘_’에 할당하세요.',
        unusedCoroutine: 'async 함수 호출의 결과가 사용되지 않습니다. "await"를 사용하거나 변수에 결과 할당',
        unusedExpression: '식 값은 사용되지 않습니다.',
        varAnnotationIllegal: '변수에 대한 type 주석에는 Python 3.6 이상이 필요합니다. 이전 버전과의 호환성을 위해 type 메모 사용',
        variableFinalOverride: '변수 "{name}"이(가) Final로 표시되고 "{className}" 클래스에서 이름이 같은 비-Final 변수를 재정의합니다.',
        variadicTypeArgsTooMany: '형식 인수 목록에는 압축을 풀고 있는 TypeVarTuple 또는 tuple이 하나만 있을 수 있습니다.',
        variadicTypeParamTooManyAlias: '형식 별칭에는 TypeVarTuple 형식 매개 변수가 최대 하나만 있을 수 있지만 여러 ({names})가 수신되었습니다.',
        variadicTypeParamTooManyClass: '제네릭 클래스에는 TypeVarTuple 형식 매개 변수가 하나만 있을 수 있지만 여러 ({names})을(를) 받았습니다.',
        walrusIllegal: '연산자 ":="에는 Python 3.8 이상이 필요합니다.',
        walrusNotAllowed: '주변 괄호 없이는 이 컨텍스트에서 ":=" 연산자를 사용할 수 없습니다.',
        wildcardInFunction: '클래스 또는 함수 내에서 와일드카드 import가 허용되지 않음',
        wildcardLibraryImport: '라이브러리에서 와일드카드 import가 허용되지 않습니다.',
        wildcardPatternTypePartiallyUnknown: '와일드카드 패턴으로 캡처된 형식을 부분적으로 알 수 없습니다.',
        wildcardPatternTypeUnknown: '와일드카드 패턴으로 캡처된 형식을 부분적으로 알 수 없습니다.',
        yieldFromIllegal: '"yield from"을 사용하려면 Python 3.3 이상이 필요합니다.',
        yieldFromOutsideAsync: 'async 함수에서는 "yield from"을 사용할 수 없습니다.',
        yieldOutsideFunction: '함수 또는 람다 외부에서는 ‘yield’를 사용할 수 없습니다.',
        yieldWithinComprehension: 'comprehension 내에서는 "yield"를 사용할 수 없습니다.',
        zeroCaseStatementsFound: 'Match 문에는 case 문이 하나 이상 포함되어야 합니다.',
        zeroLengthTupleNotAllowed: '길이가 0인 tuple은 이 컨텍스트에서 허용되지 않습니다.'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '"Annotated" 특수 양식은 인스턴스 및 클래스 검사와 함께 사용할 수 없습니다.',
        argParam: '인수가 "{paramName}" 매개 변수에 해당합니다.',
        argParamFunction: '인수가 "{functionName}" 함수의 "{paramName}" 매개 변수에 해당합니다.',
        argsParamMissing: '‘*{paramName}’ 매개 변수에 해당하는 매개 변수가 없습니다.',
        argsPositionOnly: '위치 전용 매개 변수가 일치하지 않습니다. {expected}이)(가) 필요하지만 {received}을(를) 받았습니다.',
        argumentType: '인수 형식이 "{type}"입니다.',
        argumentTypes: '인수 형식: ({types})',
        assignToNone: '형식을 "None"에 할당할 수 없습니다.',
        asyncHelp: '‘async with’를 사용하시겠습니까?',
        baseClassIncompatible: '기본 클래스 "{baseClass}"은(는) "{type}" 유형과 호환되지 않습니다.',
        baseClassIncompatibleSubclass: '기본 클래스 "{baseClass}"은(는) "{type}" 유형과 호환되지 않는 "{subclass}"에서 파생됩니다.',
        baseClassOverriddenType: '기본 클래스 "{baseClass}"이(가) 재정의된 "{type}" 형식을 제공합니다.',
        baseClassOverridesType: '‘{baseClass}’ 기본 클래스가 ‘{type}’ 형식을 재정의합니다.',
        bytesTypePromotions: 'disableBytesTypePromotions를 false로 설정하여 "bytearray" 및 "memoryview"에 대한 형식 승격 동작을 사용하도록 설정합니다.',
        conditionalRequiresBool: '"{operandType}" 형식에 대한 메서드 __bool__에서 "bool" 대신 "{boolReturnType}" 형식을 반환합니다.',
        dataClassFieldLocation: '필드 선언',
        dataClassFrozen: '"{name}"이(가) 고정되어 있습니다.',
        dataProtocolUnsupported: '"{name}"은(는) 데이터 프로토콜입니다.',
        descriptorAccessBindingFailed: '설명자 클래스 "{className}"에 대한 메서드 "{name}"을(를) 바인딩하지 못했습니다.',
        descriptorAccessCallFailed: '설명자 클래스 "{className}"에 대한 메서드 "{name}"을(를) 호출하지 못했습니다.',
        finalMethod: 'Final 메서드',
        functionParamDefaultMissing: '‘{name}’ 매개 변수에 기본 인수가 없습니다.',
        functionParamName: '매개 변수 이름 불일치: "{destName}" 및 "{srcName}"',
        functionParamPositionOnly: '위치 전용 매개 변수가 일치하지 않습니다. 매개 변수 "{name}"은(는) 위치 전용이 아닙니다.',
        functionReturnTypeMismatch: '‘{sourceType}’ 함수 반환 형식은 ‘{destType}’ 형식과 호환되지 않습니다.',
        functionTooFewParams: '함수가 너무 적은 위치 매개 변수를 허용합니다. {expected}이(가) 필요하지만 {received}을(를) 받았습니다.',
        functionTooManyParams: '함수가 너무 많은 위치 매개 변수를 허용합니다. {expected}이(가) 필요하지만 {received}을(를) 받았습니다.',
        genericClassNotAllowed: '인스턴스 또는 클래스 검사에 형식 인수가 허용되지 않는 제네릭 형식',
        incompatibleDeleter: 'Property deleter 메서드가 호환되지 않습니다.',
        incompatibleGetter: 'Property getter 메서드가 호환되지 않습니다.',
        incompatibleSetter: 'Property setter 메서드가 호환되지 않습니다.',
        initMethodLocation: '__init__ 메서드가 "{type}" 클래스에 정의되어 있습니다.',
        initMethodSignature: '__init__의 서명은 "{type}"입니다.',
        initSubclassLocation: '__init_subclass__ 메서드는 "{name}" 클래스에 정의되어 있음',
        invariantSuggestionDict: '값 형식에서 공변(covariant)인 "dict"에서 "Mapping"(매핑)으로 전환하는 것이 좋습니다.',
        invariantSuggestionList: '공변(covariant)인 "list"에서 "Sequence"로 전환하는 것이 좋습니다.',
        invariantSuggestionSet: '공변(covariant)인 "set"에서 "Container"로 전환하는 것이 좋습니다.',
        isinstanceClassNotSupported: '"{type}"은(는) 인스턴스 및 클래스 검사에 지원되지 않음',
        keyNotRequired: '‘{name}’은(는) ‘{type}’에서 필수 키가 아니므로 액세스로 인해 런타임 예외가 발생할 수 있습니다.',
        keyReadOnly: '"{name}"은(는) "{type}"의 읽기 전용 키입니다.',
        keyRequiredDeleted: '"{name}"은(는) 필수 키이므로 삭제할 수 없습니다.',
        keyUndefined: '"{name}"이 "{type}"에 정의된 키가 아닙니다.',
        kwargsParamMissing: '‘**{paramName}’ 매개 변수에 해당하는 매개 변수가 없습니다.',
        listAssignmentMismatch: '"{type}" 형식이 대상 목록과 호환되지 않습니다.',
        literalAssignmentMismatch: '"{sourceType}"은 형식 "{destType}"에 할당할 수 없습니다.',
        matchIsNotExhaustiveHint: '전체 처리가 의도되지 않은 경우 "case _: pass"를 추가합니다.',
        matchIsNotExhaustiveType: '처리되지 않은 형식: "{type}"',
        memberAssignment: '"{type}" 형식의 식을 "{classType}" 클래스의 "{name}" 특성에 할당할 수 없음',
        memberIsAbstract: '"{type}.{name}"이(가) 구현되지 않았습니다.',
        memberIsAbstractMore: '{count}개 더...',
        memberIsClassVarInProtocol: '"{name}"은(는) 프로토콜에서 ClassVar로 정의됩니다.',
        memberIsInitVar: '"{name}"은(는) init-only 필드임',
        memberIsInvariant: '"{name}"은(는) 변경 가능하므로 고정되지 않습니다.',
        memberIsNotClassVarInClass: '"{name}"은(는) 프로토콜과 호환되려면 ClassVar로 정의해야 합니다.',
        memberIsNotClassVarInProtocol: '"{name}"이(가) 프로토콜에서 ClassVar로 정의되지 않았습니다.',
        memberIsNotReadOnlyInProtocol: '"{name}"(이)가 프로토콜에서 읽기 전용이 아닙니다.',
        memberIsReadOnlyInProtocol: '"{name}"은(는) 프로토콜에서 읽기 전용입니다.',
        memberIsWritableInProtocol: '"{name}"은(는) 프로토콜에서 쓸 수 있습니다.',
        memberSetClassVar: '"{name}" 특성은 ClassVar이므로 클래스 인스턴스를 통해 할당할 수 없음',
        memberTypeMismatch: '"{name}"은(는) 호환되지 않는 형식입니다.',
        memberUnknown: '특성 "{name}" 알 수 없음',
        metaclassConflict: '메타클래스 "{metaclass1}"이(가) "{metaclass2}"과(와) 충돌합니다.',
        missingDeleter: 'Property deleter 메서드가 없습니다.',
        missingGetter: 'Property getter 메서드가 없습니다.',
        missingSetter: 'Property setter 메서드가 없습니다.',
        namedParamMissingInDest: '"{name}" 추가 매개 변수',
        namedParamMissingInSource: '"{name}" 키워드 매개 변수 누락',
        namedParamTypeMismatch: '"{sourceType}" 형식의 키워드 매개 변수 "{name}"이(가) "{destType}" 형식과 호환되지 않음',
        namedTupleNotAllowed: '인스턴스 또는 클래스 검사에는 NamedTuple을 사용할 수 없습니다.',
        newMethodLocation: '__new__ 메서드가 "{type}" 클래스에 정의되어 있습니다.',
        newMethodSignature: '__new__ 의 서명은 "{type}"입니다.',
        newTypeClassNotAllowed: 'NewType으로 만든 클래스는 인스턴스 및 클래스 검사에 사용할 수 없습니다.',
        noOverloadAssignable: '"{type}" 형식과 일치하는 오버로드된 함수가 없습니다.',
        noneNotAllowed: '인스턴스 또는 클래스 검사에는 None을 사용할 수 없음',
        orPatternMissingName: '누락된 이름: {name}',
        overloadIndex: '오버로드 {index}이(가) 가장 가까운 일치 항목입니다.',
        overloadNotAssignable: '"{name}"의 오버로드를 하나 이상 할당할 수 없습니다.',
        overloadSignature: '오버로드 서명은 여기에 정의되어 있습니다.',
        overriddenMethod: '재정의된 메서드',
        overriddenSymbol: '재정의된 기호',
        overrideInvariantMismatch: '"{overrideType}" 재정의 형식이 "{baseType}" 기본 형식과 같지 않습니다.',
        overrideIsInvariant: '변수를 변경할 수 있으므로 해당 형식은 고정됩니다.',
        overrideNoOverloadMatches: '재정의의 오버로드 서명이 기본 메서드와 호환되지 않습니다.',
        overrideNotClassMethod: '기본 메서드가 classmethod로 선언되었지만 재정의는 그렇지 않은 경우',
        overrideNotInstanceMethod: '기본 메서드가 instance 메서드로 선언되었지만 재정의가',
        overrideNotStaticMethod: '기본 메서드가 staticmethod로 선언되었지만 재정의는 그렇지 않습니다.',
        overrideOverloadNoMatch: '재정의는 기본 메서드의 모든 오버로드를 처리하지 않습니다.',
        overrideOverloadOrder: '재정의 메서드에 대한 오버로드는 기본 메서드와 동일한 순서여야 합니다.',
        overrideParamKeywordNoDefault: '‘{name}’ 키워드 매개 변수가 불일치합니다. 기본 매개 변수에 기본 인수 값이 있습니다. 재정의 매개 변수에는 없습니다.',
        overrideParamKeywordType: '‘{name}’ 키워드 매개 변수 형식이 일치하지 않습니다. 기본 매개 변수는 형식이 ‘{baseType}’, 재정의 매개 변수는 형식이 ‘{overrideType}’입니다.',
        overrideParamName: '{index} 매개 변수 이름이 일치하지 않습니다. 기본 매개 변수는 이름이 ‘{baseName}’입니다. 재정의 매개 변수는 이름이 ‘{overrideName}’입니다.',
        overrideParamNameExtra: '기본에 매개 변수 "{name}"이(가) 없습니다.',
        overrideParamNameMissing: '재정의에 ‘{name}’ 매개 변수가 없습니다.',
        overrideParamNamePositionOnly: '매개 변수 {index} 불일치: 기본 매개 변수 "{baseName}"은(는) 키워드 매개 변수이며 재정의 매개 변수는 위치 전용임',
        overrideParamNoDefault: '{index} 매개 변수가 불일치합니다. 기본 매개 변수에 기본 인수 값이 있습니다. 재정의 매개 변수에는 없습니다.',
        overrideParamType: '‘{index}’ 매개 변수 형식이 일치하지 않습니다. 기본 매개 변수는 형식이 ‘{baseType}’, 재정의 매개 변수는 형식이 ‘{overrideType}’입니다.',
        overridePositionalParamCount: '위치 매개 변수 개수가 일치하지 않습니다. 기본 메서드에 {baseCount}개가 있지만 재정의에는 {overrideCount}개가 있습니다.',
        overrideReturnType: '반환 형식 불일치: 기본 메서드는 "{baseType}" 형식을 반환하고 재정의는 "{overrideType}" 형식을 반환합니다.',
        overrideType: '기본 클래스는 형식을 "{type}"으로 정의합니다.',
        paramAssignment: '매개 변수 {index}: "{sourceType}" 형식이 "{destType}" 형식과 호환되지 않음',
        paramSpecMissingInOverride: '재정의 메서드에 ParamSpec 매개 변수가 없습니다.',
        paramType: '매개 변수 형식은 "{paramType}"입니다.',
        privateImportFromPyTypedSource: '대신 "{module}"에서 가져오기',
        propertyAccessFromProtocolClass: '프로토콜 클래스 내에 정의된 속성은 클래스 변수로 액세스할 수 없습니다.',
        propertyMethodIncompatible: 'Property 메서드 "{name}"이(가) 호환되지 않습니다.',
        propertyMethodMissing: 'Property 메서드 “{name}”에 재정의가 없습니다.',
        propertyMissingDeleter: '"{name}" property에 정의된 deleter가 없습니다.',
        propertyMissingSetter: '"{name}" property에 정의된 setter가 없습니다.',
        protocolIncompatible: '‘{sourceType}’은(는) ‘{destType}’ 프로토콜과 호환되지 않습니다.',
        protocolMemberMissing: '"{name}"이(가) 없습니다.',
        protocolRequiresRuntimeCheckable: '인스턴스 및 클래스 검사와 함께 사용하려면 Protocol 클래스를 @runtime_checkable 합니다.',
        protocolSourceIsNotConcrete: '‘{sourceType}’은(는) 구체적인 클래스 형식이 아니므로 ‘{destType}’ 형식에 할당할 수 없습니다.',
        protocolUnsafeOverlap: '"{name}"의 특성은 프로토콜과 이름이 같습니다.',
        pyrightCommentIgnoreTip: '"# pyright: ignore[<diagnostic rules>]"을 사용하여 한 줄에 대한 진단을 표시하지 않습니다.',
        readOnlyAttribute: '특성 "{name}"은(는) 읽기 전용입니다.',
        seeClassDeclaration: '클래스 선언 참조',
        seeDeclaration: '선언 참조',
        seeFunctionDeclaration: '함수 선언 참조',
        seeMethodDeclaration: '메서드 선언 참조',
        seeParameterDeclaration: '매개 변수 선언 보기',
        seeTypeAliasDeclaration: '형식 별칭 선언 참조',
        seeVariableDeclaration: '변수 선언 보기',
        tupleAssignmentMismatch: '"{type}" 형식이 대상 tuple과 호환되지 않습니다.',
        tupleEntryTypeMismatch: 'Tuple 항목 {entry}이(가) 잘못된 형식입니다.',
        tupleSizeIndeterminateSrc: 'Tuple 크기 불일치: {expected}이(가) 필요하지만 미정을 받았습니다.',
        tupleSizeIndeterminateSrcDest: 'Tuple 크기 불일치: {expected} 이상이 필요하지만 미정을 받았습니다.',
        tupleSizeMismatch: 'Tuple 크기 불일치: {expected}이(가) 필요하지만 {received}을(를) 받았습니다.',
        tupleSizeMismatchIndeterminateDest: 'Tuple 크기 불일치: {expected} 이상이 필요하지만 {received}을(를) 받았습니다.',
        typeAliasInstanceCheck: '"type" 문을 사용해 만든 형식 별칭은 인스턴스 및 클래스 검사에 사용할 수 없습니다.',
        typeAssignmentMismatch: '형식 "{sourceType}"은 형식 "{destType}"에 할당할 수 없습니다.',
        typeBound: '형식 변수 "{name}"에 대한 상한 "{destType}"에 형식 "{sourceType}"을 할당할 수 없습니다.',
        typeConstrainedTypeVar: '형식 "{type}"을 제한된 형식 변수 "{name}"에 할당할 수 없습니다.',
        typeIncompatible: '"{sourceType}"은 "{destType}"에 할당할 수 없습니다.',
        typeNotClass: '"{type}"이 클래스가 아닙니다.',
        typeNotStringLiteral: '‘{type}’은(는) 문자열 리터럴이 아닙니다.',
        typeOfSymbol: '‘{name}’의 유형이 ‘{type}’입니다.',
        typeParamSpec: '"{type}" 형식이 ParamSpec "{name}"과(와) 호환되지 않습니다.',
        typeUnsupported: '"{type}" 형식은 지원되지 않습니다.',
        typeVarDefaultOutOfScope: '형식 변수 "{name}"이(가) 범위에 없습니다.',
        typeVarIsContravariant: '"{name}" 형식 매개 변수는 반공변형식 매개 변수)이지만 "{sourceType}"은(는) "{destType}"의 상위 형식이 아닙니다.',
        typeVarIsCovariant: '"{name}" 형식 매개 변수는 공변(covariant)이지만 "{sourceType}"은(는) "{destType}"의 하위 형식이 아닙니다.',
        typeVarIsInvariant: '"{name}" 형식 매개 변수는 고정이지만 "{sourceType}"은(는) "{destType}"와 같지 않습니다.',
        typeVarNotAllowed: '인스턴스 또는 클래스 검사에 TypeVar가 허용되지 않음',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple을 알 수 없는 길이의 tuple에 바인딩할 수 없습니다.',
        typeVarUnnecessarySuggestion: '대신 {type}을(를) 사용하세요.',
        typeVarUnsolvableRemedy: '인수가 제공되지 않을 때 반환 형식을 지정하는 오버로드를 제공합니다.',
        typeVarsMissing: '누락된 형식 변수: {names}',
        typedDictBaseClass: '"{type}" 클래스는 TypedDict가 아닙니다.',
        typedDictClassNotAllowed: '인스턴스 또는 클래스 검사에 TypedDict 클래스를 사용할 수 없습니다.',
        typedDictClosedExtraNotAllowed: '항목 "{name}"을(를) 추가할 수 없음',
        typedDictClosedExtraTypeMismatch: '형식이 "{type}"인 항목 "{name}"을(를) 추가할 수 없음',
        typedDictClosedFieldNotRequired: '"{name}" 항목은 NotRequired여야 하므로 추가할 수 없습니다.',
        typedDictExtraFieldNotAllowed: '"{name}"이(가) "{type}"에 없음',
        typedDictExtraFieldTypeMismatch: '"{name}" 형식은 "{type}"의 "extra_items" 형식과 호환되지 않습니다.',
        typedDictFieldMissing: '"{name}"이(가) "{type}"에 없습니다.',
        typedDictFieldNotReadOnly: '"{name}"은(는) "{type}"에서 읽기 전용이 아닙니다.',
        typedDictFieldNotRequired: '"{name}"은(는) "{type}"에 필요하지 않습니다.',
        typedDictFieldRequired: '"{type}"에 "{name}"이(가) 필요합니다.',
        typedDictFieldTypeMismatch: '"{type}" 형식은 "{name}" 항목에 할당할 수 없습니다.',
        typedDictFieldUndefined: '"{name}"은(는) "{type}" 형식의 정의되지 않은 항목입니다.',
        typedDictFinalMismatch: '@final 불일치로 인해 "{sourceType}"이(가) "{destType}"과(와) 호환되지 않습니다.',
        typedDictKeyAccess: 'TypedDict에서 항목을 참조하려면 ["{name}"]을(를) 사용하세요.',
        typedDictNotAllowed: 'TypedDict는 인스턴스 또는 클래스 검사에 사용할 수 없습니다.',
        unhashableType: '‘{type}’ 형식을 해시할 수 없습니다.',
        uninitializedAbstractVariable: '인스턴스 변수 "{name}"이(가) 추상 기본 클래스 "{classType}"에 정의되어 있지만 초기화되지 않았습니다.',
        unreachableExcept: '"{exceptionType}"은(는) "{parentType}"의 서브클래스입니다.',
        useDictInstead: '사전 형식을 나타내려면 Dict[T1, T2]를 사용하세요.',
        useListInstead: 'List[T]를 사용하여 list 형식을 나타내거나 Union[T1, T2]를 사용하여 union 형식을 나타내세요.',
        useTupleInstead: 'tuple[T1, ..., Tn]을 사용하여 tuple 형식을 나타내거나 Union[T1, T2]을 사용하여 union 형식을 나타냅니다.',
        useTypeInstead: '대신 Type[T] 사용',
        varianceMismatchForClass: '‘{typeVarName}’ 형식 인수의 차이는 ‘{className}’ 기본 클래스와 호환되지 않습니다.',
        varianceMismatchForTypeAlias: '‘{typeVarName}’ 형식 인수의 차이는 ‘{typeAliasParam}’와(과) 호환되지 않습니다.'
      },
      Service: {
        longOperation: '작업 영역 소스 파일을 열거하는 데는 시간이 오래 걸립니다. 대신 하위 폴더를 여는 것이 좋습니다. [자세히 알아보기](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  96838: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Utwórz typ zastępczy Stub',
        createTypeStubFor: 'Utwórz typ Stub dla „{moduleName}”',
        executingCommand: 'Wykonywanie polecenia',
        filesToAnalyzeCount: 'Pliki do przeanalizowania: {count}',
        filesToAnalyzeOne: '1 plik do analizy',
        findingReferences: 'Znajdowanie odwołań',
        organizeImports: 'Organizuj dyrektywy Import',
        renameShadowedFile: 'Zmień nazwę „{oldFile}” na „{newFile}”'
      },
      Completion: {
        autoImportDetail: 'Automatyczne importowanie',
        indexValueDetail: 'Wartość indeksu'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Nie można wywołać metody „{method}”, ponieważ jest abstrakcyjna i niezaimplementowana',
        annotatedMetadataInconsistent: 'Opisany typ metadanych „{metadataType}” nie jest zgodny z typem „{type}”',
        annotatedParamCountMismatch: 'Niezgodność liczby adnotacji parametru; oczekiwano {expected}, a uzyskano {received}',
        annotatedTypeArgMissing: 'Oczekiwano jednego argumentu typu i co najmniej jednej adnotacji dla wartości „Annotated”',
        annotationBytesString: 'Wyrażenia typu nie mogą używać literałów ciągu bajtów',
        annotationFormatString: 'Wyrażenia typu nie mogą używać literałów ciągów formatu (ciągów f)',
        annotationNotSupported: 'Adnotacja typu nie jest obsługiwana dla tej instrukcji',
        annotationRawString: 'Wyrażenia typu nie mogą używać nieprzetworzonych literałów ciągów',
        annotationSpansStrings: 'Wyrażenia typu nie mogą obejmować wielu literałów ciągów',
        annotationStringEscape: 'Wyrażenia typu nie mogą zawierać znaków ucieczki',
        argAssignment: 'Argumentu typu „{argType}” nie można przypisać do parametru typu „{paramType}”',
        argAssignmentFunction: 'Argumentu typu „{argType}” nie można przypisać do parametru typu „{paramType}” w funkcji „{functionName}”',
        argAssignmentParam: 'Argumentu typu „{argType}” nie można przypisać do parametru „{paramName}” typu „{paramType}”',
        argAssignmentParamFunction: 'Argumentu typu „{argType}” nie można przypisać do parametru „{paramName}” typu „{paramType}” w funkcji „{functionName}”',
        argMissingForParam: 'Brak argumentu dla parametru {name}',
        argMissingForParams: 'Brak argumentów dla parametrów {names}',
        argMorePositionalExpectedCount: 'Oczekiwano większej liczby argumentów pozycyjnych: {expected}',
        argMorePositionalExpectedOne: 'Oczekiwano jeszcze 1 argumentu pozycyjnego',
        argPositional: 'Oczekiwano argumentu pozycyjnego',
        argPositionalExpectedCount: 'Oczekiwano liczby argumentów pozycyjnych: {expected}',
        argPositionalExpectedOne: 'Oczekiwano 1 argumentu pozycyjnego',
        argTypePartiallyUnknown: 'Typ argumentu jest częściowo nieznany',
        argTypeUnknown: 'Typ argumentu jest nieznany',
        assertAlwaysTrue: 'Wyrażenie Assert zawsze ma wartość true',
        assertTypeArgs: 'Typ „assert_type” oczekuje dwóch argumentów pozycyjnych',
        assertTypeTypeMismatch: 'Niezgodność „assert_type”; oczekiwano „{expected}”, ale otrzymano „{received}”',
        assignmentExprComprehension: 'Element docelowy wyrażenia przypisania „{name}” nie może używać tej samej nazwy co zrozumienie dla elementu docelowego',
        assignmentExprContext: 'Wyrażenie przypisania musi należeć do modułu, funkcji lub wyrażenia lambda',
        assignmentExprInSubscript: 'Wyrażenia przypisania w indeksie dolnym są obsługiwane tylko w języku Python w wersji 3.10 i nowszej',
        assignmentInProtocol: 'Zmienne wystąpienia lub klasy w klasie Protocol muszą być jawnie zadeklarowane w treści klasy',
        assignmentTargetExpr: 'Wyrażenie nie może być elementem docelowym przypisania',
        asyncNotInAsyncFunction: 'Użycie wartość „async” jest niedozwolone poza funkcją asynchroniczną',
        awaitIllegal: 'Użycie „await” wymaga języka Python w wersji 3.5 lub nowszej',
        awaitNotAllowed: 'Wyrażenia typu nie mogą używać instrukcji „await”',
        awaitNotInAsync: 'Wartość „await” jest dozwolona tylko w ramach funkcji asynchronicznej',
        backticksIllegal: 'Wyrażenia otoczone znakami wstecznymi nie są obsługiwane w języku Python w wersji 3.x; zamiast tego użyj wyrażenia repr',
        baseClassCircular: 'Klasa nie może pochodzić od samej siebie',
        baseClassFinal: 'Klasa bazowa „{type}” jest oznaczona jako final i nie można jej podzielić na podklasy',
        baseClassIncompatible: 'Klasy bazowe typu {type} są wzajemnie niezgodne',
        baseClassInvalid: 'Argument klasy musi być klasą bazową',
        baseClassMethodTypeIncompatible: 'Klasy bazowe dla klasy „{classType}” definiują metodę „{name}” w niezgodny sposób',
        baseClassUnknown: 'Typ klasy bazowej jest nieznany, zasłaniając typ klasy pochodnej',
        baseClassVariableTypeIncompatible: 'Klasy bazowe dla klasy „{classType}” definiują zmienną „{name}” w niezgodny sposób',
        binaryOperationNotAllowed: 'Operator binarny nie jest dozwolony w wyrażeniu typu',
        bindTypeMismatch: 'Nie można powiązać metody „{methodName}”, ponieważ nie można przypisać typu „{type}” do parametru „{paramName}”',
        breakInExceptionGroup: '„break” nie jest dozwolone w bloku „except*”',
        breakOutsideLoop: 'Wartość „break” może być używana tylko w pętli',
        callableExtraArgs: 'Oczekiwano tylko dwóch argumentów typu „Callable”',
        callableFirstArg: 'Oczekiwano listy typów parametrów lub znaków „...”',
        callableNotInstantiable: 'Nie można utworzyć wystąpienia typu „{type}”',
        callableSecondArg: 'Oczekiwano zwracanego typu jako drugiego argumentu typu dla elementu „Callable”',
        casePatternIsIrrefutable: 'Niepodważalny wzorzec jest dozwolony tylko dla ostatniej instrukcji dotyczącej wielkości liter',
        classAlreadySpecialized: 'Typ „{type}” jest już wyspecjalizowany',
        classDecoratorTypeUnknown: 'Dekorator klasy bez typu przesłania typ klasy; ignorowanie dekoratora',
        classDefinitionCycle: 'Definicja klasy dla „{name}” zależy od niej samej',
        classGetItemClsParam: 'Przesłonięcie __class_getitem__ powinno przyjmować parametr „cls”.',
        classMethodClsParam: 'Metody klasy powinny przyjmować parametr „cls”',
        classNotRuntimeSubscriptable: 'Indeks dolny dla klasy „{name}” wygeneruje wyjątek środowiska uruchomieniowego; umieścić wyrażenie typu w cudzysłowy',
        classPatternBuiltInArgPositional: 'Wzorzec klasy akceptuje tylko podwzorzec pozycyjny',
        classPatternPositionalArgCount: 'Zbyt wiele wzorców pozycyjnych dla klasy „{type}”; oczekiwano {expected}, ale otrzymano {received}',
        classPatternTypeAlias: '„{type}” nie może być używany we wzorcu klasy, ponieważ jest to alias typu specjalnego',
        classPropertyDeprecated: 'Właściwości klasy są przestarzałe w języku Python 3.11 i nie będą obsługiwane w języku Python 3.13',
        classTypeParametersIllegal: 'Składnia parametru typu klasy wymaga języka Python w wersji 3.12 lub nowszej',
        classVarFirstArgMissing: 'Oczekiwano argumentu typu po wartości „ClassVar”',
        classVarNotAllowed: 'Element „ClassVar” jest niedozwolony w tym kontekście',
        classVarOverridesInstanceVar: 'Zmienna klasy „{name}” przesłania zmienną wystąpienia o tej samej nazwie w klasie „{className}”',
        classVarTooManyArgs: 'Oczekiwano tylko jednego argumentu typu po wartości „ClassVar”',
        classVarWithTypeVar: 'Typ „ClassVar” nie może zawierać zmiennych typu',
        clsSelfParamTypeMismatch: 'Typ parametru „{name}” musi być nadtypem jego klasy „{classType}”',
        codeTooComplexToAnalyze: 'Kod jest zbyt złożony, aby go analizować; zmniejsz złożoność przez refaktoryzację w podprocedury lub poprzez zmniejszenie ścieżek kodu warunkowego',
        collectionAliasInstantiation: 'Nie można utworzyć wystąpienia typu „{type}”. Zamiast niego użyj „{alias}”',
        comparisonAlwaysFalse: 'Warunek zawsze będzie miał wartość False, ponieważ typy „{leftType}” i „{rightType}” nie nakładają się',
        comparisonAlwaysTrue: 'Warunek zawsze będzie miał wartość True, ponieważ typy „{leftType}” i „{rightType}” nie nakładają się',
        comprehensionInDict: 'Zrozumienia nie można używać z innymi wpisami słownika',
        comprehensionInSet: 'Nie można używać rozumienia z innymi wpisami set',
        concatenateContext: 'Klasa „Concatenate” jest niedozwolona w tym kontekście',
        concatenateParamSpecMissing: 'Ostatni argument typu dla elementu „Concatenate” musi mieć wartość ParamSpec lub „...”',
        concatenateTypeArgsMissing: 'Element „Concatenate” wymaga co najmniej dwóch argumentów typu',
        conditionalOperandInvalid: 'Nieprawidłowy warunkowy argument operacji typu „{type}”',
        constantRedefinition: 'Nazwa „{name}” jest stałą (ponieważ jest pisana wielkimi literami) i nie można jej ponownie zdefiniować',
        constructorParametersMismatch: 'Niezgodność między sygnaturą „__new__” i „__init__” w klasie „{classType}”',
        containmentAlwaysFalse: 'Warunek zawsze będzie miał wartość False, ponieważ typy „{leftType}” i „{rightType}” nie nakładają się na siebie',
        containmentAlwaysTrue: 'Warunek zawsze będzie miał wartość „True”, ponieważ typy „{leftType}” i „{rightType}” nie nakładają się na siebie',
        continueInExceptionGroup: '„continue” nie jest dozwolone w bloku „except*”',
        continueOutsideLoop: 'Wartość „continue” może być używana tylko w pętli',
        coroutineInConditionalExpression: 'Wyrażenie warunkowe odwołuje się do koprocedury, która zawsze wyznacza wartość True',
        dataClassBaseClassFrozen: 'Klasa niezablokowana nie może dziedziczyć po klasie zablokowanej',
        dataClassBaseClassNotFrozen: 'Zamrożona klasa nie może dziedziczyć po klasie niezamrożonej',
        dataClassConverterFunction: 'Argument typu „{argType}” nie jest prawidłowym konwerterem pola „{fieldName}” typu „{fieldType}”',
        dataClassConverterOverloads: 'Żadne przeciążenia „{funcName}” nie są prawidłowymi konwerterami dla pola „{fieldName}” typu „{fieldType}”',
        dataClassFieldInheritedDefault: 'Pole „{fieldName}” zastępuje pole o tej samej nazwie, ale brakuje wartości domyślnej',
        dataClassFieldWithDefault: 'Pola bez wartości domyślnych nie mogą występować po polach z wartościami domyślnymi',
        dataClassFieldWithPrivateName: 'Pole klasy danych nie może używać nazwy prywatnej',
        dataClassFieldWithoutAnnotation: 'Pole klasy danych bez adnotacji typu spowoduje wyjątek środowiska uruchomieniowego',
        dataClassPostInitParamCount: 'Klasa danych __post_init__ ma niepoprawną liczbę parametrów; oczekiwana liczba pól InitVar to: {expected}',
        dataClassPostInitType: 'Klasa danych __post_init__ ma niezgodność typu parametru metody dla pola „{fieldName}”',
        dataClassSlotsOverwrite: 'Element __slots__ jest już zdefiniowany w klasie',
        dataClassTransformExpectedBoolLiteral: 'Oczekiwano wyrażenia, które statycznie daje w wyniku wartość True lub False',
        dataClassTransformFieldSpecifier: 'Oczekiwano spójnej kolekcji (tuple) klas lub funkcji, a uzyskano typ „{type}”',
        dataClassTransformPositionalParam: 'Wszystkie argumenty elementu „dataclass_transform” muszą być argumentami słów kluczowych',
        dataClassTransformUnknownArgument: 'Argument „{name}” nie jest obsługiwany przez dataclass_transform',
        dataProtocolInSubclassCheck: 'Protokoły danych (które zawierają atrybuty niebędące atrybutami metody) są niedozwolone w wywołaniach klasy issubclass',
        declaredReturnTypePartiallyUnknown: 'Zadeklarowany zwracany typ „{returnType}” jest częściowo nieznany',
        declaredReturnTypeUnknown: 'Deklarowany zwracany typ jest nieznany',
        defaultValueContainsCall: 'Wywołania funkcji i modyfikowalne obiekty są niedozwolone w wyrażeniu wartości domyślnej parametru',
        defaultValueNotAllowed: 'Parametr o wartości „*” lub „**” nie może mieć wartości domyślnej',
        delTargetExpr: 'Nie można usunąć wyrażenia',
        deprecatedClass: 'Klasa „{name}” jest przestarzała',
        deprecatedConstructor: 'Konstruktor klasy „{name}” jest przestarzały',
        deprecatedDescriptorDeleter: 'Metoda „__set__” dla deskryptora „{name}” jest przestarzała',
        deprecatedDescriptorGetter: 'Metoda „__set__” dla deskryptora „{name}” jest przestarzała',
        deprecatedDescriptorSetter: 'Metoda „__set__” dla deskryptora „{name}” jest przestarzała',
        deprecatedFunction: 'Ta funkcja „{name}” jest przestarzała',
        deprecatedMethod: 'Metoda „{name}” w klasie „{className}” jest przestarzała',
        deprecatedPropertyDeleter: 'deleter dla property „{name}” jest przestarzała',
        deprecatedPropertyGetter: 'getter dla property „{name}” jest przestarzała',
        deprecatedPropertySetter: 'setter dla property „{name}” jest przestarzała',
        deprecatedType: 'Ten typ jest przestarzały dla języka Python w wersji {version}; zamiast tego użyj „{replacement}”.',
        dictExpandIllegalInComprehension: 'Rozszerzanie słownika jest niedozwolone w rozumieniu',
        dictInAnnotation: 'Wyrażenie słownika jest niedozwolone w wyrażeniu typu',
        dictKeyValuePairs: 'Wpisy słownika muszą zawierać pary klucz/wartość',
        dictUnpackIsNotMapping: 'Oczekiwano mapowania dla operatora rozpakowywania słownika',
        dunderAllSymbolNotPresent: 'Nazwa „{name}” jest określona w wartości __all__, ale nie występuje w module',
        duplicateArgsParam: 'Dozwolony tylko jeden parametr „*”',
        duplicateBaseClass: 'Zduplikowana klasa bazowa jest niedozwolona',
        duplicateCapturePatternTarget: 'Element docelowy przechwytywania „{name}” nie może występować więcej niż raz w obrębie tego samego wzorca',
        duplicateCatchAll: 'Dozwolona jest tylko jedna klauzula typu catch-all except klauzuli',
        duplicateEnumMember: 'Składowa Enum „{name}” jest już zadeklarowana',
        duplicateGenericAndProtocolBase: 'Dozwolona jest tylko jedna klasa bazowa Generic[...] lub Protocol[...].',
        duplicateImport: 'Nazwa „{importName}” została zaimportowana więcej niż raz',
        duplicateKeywordOnly: 'Dozwolony tylko jeden separator „*”.',
        duplicateKwargsParam: 'Dozwolony tylko jeden parametr „**”.',
        duplicateParam: 'Duplikuj parametr „{name}”',
        duplicatePositionOnly: 'Dozwolony tylko jeden parametr „/”',
        duplicateStarPattern: 'W sekwencji wzorca dozwolony jest tylko jeden wzorzec „*”',
        duplicateStarStarPattern: 'Dozwolony jest tylko jeden wpis „**”',
        duplicateUnpack: 'Na list dozwolona jest tylko jedna operacja rozpakowywania',
        ellipsisAfterUnpacked: 'Nie można używać „...” z rozpakowanym parametrem TypeVarTuple lub kolekcją tuple',
        ellipsisContext: 'Wartość „...” jest niedozwolona w tym kontekście',
        ellipsisSecondArg: 'Wartość „...” jest dozwolona tylko jako drugi z dwóch argumentów',
        enumClassOverride: 'Klasa Enum „{name}” jest final i nie można jej podzielić na podklasy',
        enumMemberDelete: 'Nie można usunąć składowej Enum "{name}"',
        enumMemberSet: 'Nie można przypisać składowej Enum „{name}”',
        enumMemberTypeAnnotation: 'Adnotacje typu nie są dozwolone dla składowych enum',
        exceptGroupMismatch: 'Instrukcja Try nie może zawierać jednocześnie „except” i „except*”',
        exceptGroupRequiresType: 'Składnia grupy wyjątków ("except*") wymaga typu wyjątku',
        exceptionGroupIncompatible: 'Składnia grupy wyjątków („except*”) wymaga języka Python w wersji 3.11 lub nowszej',
        exceptionGroupTypeIncorrect: 'Typ wyjątku w wyrażeniu except* nie może pochodzić z grupy BaseGroupException',
        exceptionTypeIncorrect: 'Typ „{type}” nie pochodzi od parametru BaseException',
        exceptionTypeNotClass: 'Typ „{type}” nie jest prawidłową klasą wyjątku',
        exceptionTypeNotInstantiable: 'Konstruktor typu wyjątku „{type}” wymaga co najmniej jednego argumentu',
        expectedAfterDecorator: 'Oczekiwano deklaracji funkcji lub klasy po dekoratorze',
        expectedArrow: 'Oczekiwano wartości „->”, po której następuje adnotacja zwracanego typu',
        expectedAsAfterException: 'Oczekiwano wartości „as” po typie wyjątku',
        expectedAssignRightHandExpr: 'Oczekiwano wyrażenia po prawej stronie znaku „=”',
        expectedBinaryRightHandExpr: 'Oczekiwano wyrażenia po prawej stronie operatora',
        expectedBoolLiteral: 'Oczekiwano wartości True lub False',
        expectedCase: 'Oczekiwano instrukcji „case”',
        expectedClassName: 'Oczekiwano nazwy klasy',
        expectedCloseBrace: 'Brak zamknięcia dla: „{”',
        expectedCloseBracket: 'Brak zamknięcia dla: „[”',
        expectedCloseParen: 'Brak zamknięcia dla: „(”',
        expectedColon: 'Oczekiwano „:”',
        expectedComplexNumberLiteral: 'Oczekiwano literału liczby zespolonej na potrzeby dopasowywania wzorca',
        expectedDecoratorExpr: 'Formularz wyrażenia nie jest obsługiwany przez dekorator w wersji wcześniejszej niż Python 3.9',
        expectedDecoratorName: 'Oczekiwano nazwy dekoratora',
        expectedDecoratorNewline: 'Oczekiwano nowego wiersza na końcu dekoratora',
        expectedDelExpr: 'Oczekiwano wyrażenia po „del”',
        expectedElse: 'Oczekiwano elementu „else”',
        expectedEquals: 'Oczekiwano „=”',
        expectedExceptionClass: 'Nieprawidłowa klasa lub obiekt wyjątku',
        expectedExceptionObj: 'Oczekiwano obiektu wyjątku, klasy wyjątku lub wartości None',
        expectedExpr: 'Oczekiwano wyrażenia',
        expectedFunctionAfterAsync: 'Oczekiwano definicji funkcji po wartości „async”',
        expectedFunctionName: 'Oczekiwano nazwy funkcji po wyrażeniu „def”',
        expectedIdentifier: 'Oczekiwany identyfikator',
        expectedImport: 'Oczekiwano wartości „import”',
        expectedImportAlias: 'Oczekiwano symbolu po parametrze „as”',
        expectedImportSymbols: 'Oczekiwano jednej lub więcej nazw symboli po wyrażeniu „import”',
        expectedIn: 'Oczekiwano parametru „in”',
        expectedInExpr: 'Oczekiwano wyrażenia po „in”',
        expectedIndentedBlock: 'Oczekiwano wciętego bloku',
        expectedMemberName: 'Oczekiwano nazwy atrybutu po „.”',
        expectedModuleName: 'Oczekiwana nazwa modułu',
        expectedNameAfterAs: 'Oczekiwano nazwy symbolu po wartości „as”',
        expectedNamedParameter: 'Parametr słowa kluczowego musi następować po znaku „*”',
        expectedNewline: 'Oczekiwano nowego wiersza',
        expectedNewlineOrSemicolon: 'Instrukcje muszą być oddzielone znakami nowych wierszy lub średnikami',
        expectedOpenParen: 'Oczekiwano „(”',
        expectedParamName: 'Oczekiwano nazwy parametru',
        expectedPatternExpr: 'Oczekiwano wyrażenia wzorca',
        expectedPatternSubjectExpr: 'Oczekiwano wyrażenia tematu wzorca',
        expectedPatternValue: 'Oczekiwano wyrażenia wartości wzorca w postaci „a.b”',
        expectedReturnExpr: 'Oczekiwano wyrażenia po „return”.',
        expectedSliceIndex: 'Oczekiwano wyrażenia indeksu lub wycinka',
        expectedTypeNotString: 'Oczekiwano typu, ale otrzymano literał ciągu',
        expectedTypeParameterName: 'Oczekiwano nazwy parametru typu',
        expectedYieldExpr: 'Oczekiwano wyrażenia w instrukcji yield',
        finalClassIsAbstract: 'Klasa „{type}” jest oznaczona jako final i musi implementować wszystkie symbole abstrakcyjne',
        finalContext: 'Wartość „Final” jest niedozwolona w tym kontekście',
        finalInLoop: 'Nie można przypisać zmiennej „Final” w pętli',
        finalMethodOverride: 'Metoda „{name}” nie może przesłonić metody final zdefiniowanej w klasie „{className}”',
        finalNonMethod: 'Nie można oznaczyć funkcji „{name}” jako @final, ponieważ nie jest to metoda',
        finalReassigned: 'Element „{name}” jest zadeklarowany jako wersja Final i nie można go ponownie przypisać',
        finalRedeclaration: 'Nazwa „{name}” została wcześniej zadeklarowana jako Final',
        finalRedeclarationBySubclass: 'Nie można ponownie zadeklarować nazwy „{name}”, ponieważ klasa nadrzędna „{className}” deklaruje ją jako Final',
        finalTooManyArgs: 'Oczekiwano jednego argumentu typu po wartości „Final”',
        finalUnassigned: 'Nazwa „{name}” jest zadeklarowana jako wartość Final, ale wartość nie jest przypisana',
        formatStringBrace: 'Pojedynczy zamykający nawias klamrowy jest niedozwolony w literale ciągu f; użyj podwójnego zamykającego nawiasu klamrowego',
        formatStringBytes: 'Literały ciągów formatu (ciągi f) nie mogą być binarne',
        formatStringDebuggingIllegal: 'Specyfikator debugowania ciągu f „=” wymaga wersji języka Python 3.8 lub nowszej',
        formatStringEscape: 'Sekwencja ucieczki (ukośnik odwrotny) jest niedozwolona w części wyrażenia ciągu f w wersji języka wcześniejszej niż Python 3.12',
        formatStringExpectedConversion: 'Oczekiwano specyfikatora konwersji po znaku „!” w ciągu f-string',
        formatStringIllegal: 'Literały ciągów formatu (ciągi f) wymagają wersji języka Python 3.6 lub nowszej',
        formatStringInPattern: 'Ciąg formatu jest niedozwolony we wzorcu',
        formatStringNestedFormatSpecifier: 'Wyrażenia zagnieżdżone zbyt głęboko w specyfikatorze ciągu formatu',
        formatStringNestedQuote: 'Ciągi zagnieżdżone w ciągu f nie mogą używać tego samego znaku cudzysłowu co ciąg f w wersji języka wcześniejszej niż Python 3.12',
        formatStringUnicode: 'Literały ciągu formatu (f-strings) nie mogą być formatu unicode',
        formatStringUnterminated: 'Niezakończone wyrażenie w ciągu f; oczekiwano znaku „}”',
        functionDecoratorTypeUnknown: 'Nietypowany dekorator funkcji zasłania typ funkcji; ignorując dekoratora',
        functionInConditionalExpression: 'Wyrażenie warunkowe odwołuje się do funkcji, której wynikiem zawsze jest wartość True',
        functionTypeParametersIllegal: 'Składnia parametru typu klasy wymaga wersji języka Python 3.12 lub nowszej',
        futureImportLocationNotAllowed: 'Importy z __future__ muszą znajdować się na początku pliku',
        generatorAsyncReturnType: 'Zwracany typ funkcji generatora asynchronicznego musi być zgodny z elementem „AsyncGenerator[{yieldType}, Any]”',
        generatorNotParenthesized: 'Wyrażenia generatora muszą być ujęte w nawiasy, jeśli nie są jedynym argumentem',
        generatorSyncReturnType: 'Zwracany typ funkcji generatora musi być zgodny z elementem „Generator[{yieldType}, Any, Any]”',
        genericBaseClassNotAllowed: 'Nie można użyć klasy bazowej „Generic” ze składnią parametru typu',
        genericClassAssigned: 'Nie można przypisać ogólnego typu klasy',
        genericClassDeleted: 'Nie można usunąć ogólnego typu klasy',
        genericInstanceVariableAccess: 'Dostęp do ogólnej zmiennej wystąpienia za pośrednictwem klasy jest niejednoznaczny',
        genericNotAllowed: 'Element „Generic” jest nieprawidłowy w tym kontekście',
        genericTypeAliasBoundTypeVar: 'Alias typu ogólnego w klasie nie może używać zmiennych typu powiązanego {names}',
        genericTypeArgMissing: 'Wartość „Generic” wymaga co najmniej jednego argumentu typu',
        genericTypeArgTypeVar: 'Argument typu dla wartości „Generic” musi być zmienną typu',
        genericTypeArgUnique: 'Argumenty typu dla elementu „Generic” muszą być unikatowe',
        globalReassignment: 'Nazwa „{name}” jest przypisywana przed deklaracją globalną',
        globalRedefinition: 'Nazwa „{name}” została już zadeklarowana jako globalna',
        implicitStringConcat: 'Niejawne łączenie ciągów jest niedozwolone',
        importCycleDetected: 'Wykryto cykl w łańcuchu importu',
        importDepthExceeded: 'Głębokość łańcucha importu przekroczyła {depth}',
        importResolveFailure: 'Nie można rozpoznać importu „{importName}”.',
        importSourceResolveFailure: 'Nie można rozpoznać importu „{importName}” ze źródła',
        importSymbolUnknown: 'Nazwa „{name}” jest nieznanym symbolem importu',
        incompatibleMethodOverride: 'Metoda „{name}” przesłania klasę „{className}” w niezgodny sposób',
        inconsistentIndent: 'Wartość zmniejszenia wcięcia jest niezgodna z poprzednim wcięciem',
        inconsistentTabs: 'Niespójne użycie tabulatorów i spacji we wcięciach',
        initMethodSelfParamTypeVar: 'Adnotacja typu dla parametru „self” metody „__init__” nie może zawierać zmiennych typu o zakresie klasy',
        initMustReturnNone: 'Zwracany typ „__init__” musi mieć wartość None',
        initSubclassCallFailed: 'Nieprawidłowe argumenty słów kluczowych dla metody __init_subclass__',
        initSubclassClsParam: 'Przesłonięcie __init_subclass__ powinno przyjmować parametr „cls”.',
        initVarNotAllowed: 'Element „InitVar” jest niedozwolony w tym kontekście',
        instanceMethodSelfParam: 'Metody wystąpienia powinny przyjmować parametr „self”',
        instanceVarOverridesClassVar: 'Zmienna wystąpienia „{name}” zastępuje zmienną klasy o tej samej nazwie w klasie „{className}”',
        instantiateAbstract: 'Nie można utworzyć wystąpienia klasy abstrakcyjnej „{type}”',
        instantiateProtocol: 'Nie można utworzyć wystąpienia klasy Protocol typu „{type}”',
        internalBindError: 'Wystąpił błąd wewnętrzny podczas wiązania pliku „{file}”: {message}',
        internalParseError: 'Wystąpił błąd wewnętrzny podczas analizowania pliku „{file}”: {message}',
        internalTypeCheckingError: 'Wystąpił błąd wewnętrzny podczas sprawdzania typu pliku „{file}”: {message}',
        invalidIdentifierChar: 'Nieprawidłowy znak w identyfikatorze',
        invalidStubStatement: 'Instrukcja nie ma znaczenia w pliku stub typu',
        invalidTokenChars: 'Nieprawidłowy znak „{text}” w tokenie',
        isInstanceInvalidType: 'Drugi argument instrukcji „isinstance” musi być klasą lub tuple',
        isSubclassInvalidType: 'Drugi argument „issubclass” musi być klasą lub tuple',
        keyValueInSet: 'Pary klucz/wartość nie są dozwolone w set',
        keywordArgInTypeArgument: 'Argumentów słów kluczowych nie można używać na listach argumentów typu',
        keywordArgShortcutIllegal: 'Skrót do argumentu słowa kluczowego wymaga języka Python 3.14 lub nowszego',
        keywordOnlyAfterArgs: 'Separator argumentów tylko ze słowami kluczowymi jest niedozwolony po parametrze „*”',
        keywordParameterMissing: 'Co najmniej jeden parametr słowa kluczowego musi występować po parametrze „*”',
        keywordSubscriptIllegal: 'Argumenty słów kluczowych w indeksach podrzędnych nie są obsługiwane',
        lambdaReturnTypePartiallyUnknown: 'Zwracany typ wyrażenia lambda „{returnType}” jest częściowo nieznany',
        lambdaReturnTypeUnknown: 'Zwracany typ wyrażenia lambda jest nieznany',
        listAssignmentMismatch: 'Wyrażenia typu „{type}” nie można przypisać do listy docelowej',
        listInAnnotation: 'Wyrażenie List jest niedozwolone w wyrażeniu typu',
        literalEmptyArgs: 'Oczekiwano co najmniej jednego argumentu typu po wartości „Literal”',
        literalNamedUnicodeEscape: 'Nazwane sekwencje ucieczki Unicode nie są obsługiwane w adnotacjach ciągów „Literal”',
        literalNotAllowed: 'Klasa „Literal” nie może być używana w tym kontekście bez argumentu typu',
        literalNotCallable: 'Nie można utworzyć wystąpienia typu Literal',
        literalUnsupportedType: 'Argumenty typu dla elementu „Literal” muszą mieć wartość None, wartość literału (int, bool, str lub bytes) lub wartość enum',
        matchIncompatible: 'Instrukcje Match wymagają języka Python w wersji 3.10 lub nowszej',
        matchIsNotExhaustive: 'Przypadki w instrukcji match nie obsługują wyczerpująco wszystkich wartości',
        maxParseDepthExceeded: 'Przekroczono maksymalną głębokość analizy; podziel wyrażenie na mniejsze wyrażenia podrzędne',
        memberAccess: 'Nie można uzyskać dostępu do atrybutu „{name}” dla klasy „{type}”',
        memberDelete: 'Nie można usunąć atrybutu „{name}” dla klasy „{type}”',
        memberSet: 'Nie można przypisać atrybutu „{name}” dla klasy „{type}”',
        metaclassConflict: 'Metaklasa klasy pochodnej musi być podklasą metaklas wszystkich jej klas bazowych',
        metaclassDuplicate: 'Można podać tylko jedną metaklasę',
        metaclassIsGeneric: 'Metaklasa nie może być ogólna',
        methodNotDefined: 'Nie zdefiniowano metody „{name}”.',
        methodNotDefinedOnType: 'Metoda „{name}” nie została zdefiniowana dla typu „{type}”',
        methodOrdering: 'Nie można utworzyć spójnej kolejności metod',
        methodOverridden: '„{name}” przesłania metodę o tej samej nazwie w klasie „{className}” o niezgodnym typie „{type}”',
        methodReturnsNonObject: 'Metoda „{name}” nie zwraca obiektu',
        missingSuperCall: 'Metoda „{methodName}” nie wywołuje metody o tej samej nazwie w klasie nadrzędnej',
        mixingBytesAndStr: 'Nie można łączyć wartości bytes i str',
        moduleAsType: 'Nie można użyć modułu jako typu',
        moduleNotCallable: 'Moduł nie jest wywoływalny',
        moduleUnknownMember: '„{memberName}” nie jest znanym atrybutem modułu „{moduleName}”',
        namedExceptAfterCatchAll: 'Nazwana klauzula „except” nie może występować po klauzuli „catch-all except”',
        namedParamAfterParamSpecArgs: 'Parametr słowa kluczowego „{name}” nie może występować w sygnaturze po parametrze ParamSpec args',
        namedTupleEmptyName: 'Nazwy w ramach nazwanej kolekcji tuple nie mogą być puste',
        namedTupleEntryRedeclared: 'Nie można nadpisać nazwy „{name}”, ponieważ klasa nadrzędna „{className}” jest nazwaną kolekcją tuple',
        namedTupleFirstArg: 'Oczekiwano nazwanej nazwy klasy tuple jako pierwszego argumentu',
        namedTupleMultipleInheritance: 'Wielokrotne dziedziczenie z kotki NamedTuple nie jest obsługiwane',
        namedTupleNameKeyword: 'Nazwy pól nie mogą być słowem kluczowym',
        namedTupleNameType: 'Oczekiwano tuple z dwoma wpisami określającej nazwę i typ wpisu',
        namedTupleNameUnique: 'Nazwy w nazwanej tuple muszą być unikatowe',
        namedTupleNoTypes: 'Krotka „namedtuple” nie zapewnia typów wpisów krotki; zamiast tego użyj „NamedTuple”.',
        namedTupleSecondArg: 'Oczekiwano nazwanej listy wpisów kolekcji tuple jako drugiego argumentu',
        newClsParam: 'Przesłonięcie __new__ powinno przyjmować parametr „cls”.',
        newTypeAnyOrUnknown: 'Drugi argument parametru NewType musi być znaną klasą, a nie wartością Any lub Unknown',
        newTypeBadName: 'Pierwszy argument elementu NewType musi być literałem ciągu',
        newTypeLiteral: 'Typ NewType nie może być używany z typem Literal',
        newTypeNameMismatch: 'Element NewType musi być przypisany do zmiennej o tej samej nazwie',
        newTypeNotAClass: 'Oczekiwano klasy jako drugiego argumentu dla elementu NewType',
        newTypeParamCount: 'Typ NewType wymaga dwóch argumentów pozycyjnych',
        newTypeProtocolClass: 'Elementu NewType nie można używać z typem strukturalnym (klasy Protocol lub TypedDict)',
        noOverload: 'Żadne przeciążenia dla nazwy „{name}” nie pasują do podanych argumentów',
        noReturnContainsReturn: 'Funkcja z zadeklarowanym return typem „NoReturn” nie może zawierać instrukcji return',
        noReturnContainsYield: 'Funkcja z zadeklarowanym zwracanym typem „NoReturn” nie może zawierać instrukcji yield',
        noReturnReturnsNone: 'Funkcja z zadeklarowanym typem zwracanym „NoReturn” nie może zwracać wartości „None”',
        nonDefaultAfterDefault: 'Argument inny niż domyślny następuje po argumencie domyślnym',
        nonLocalInModule: 'Deklaracja nonlocal nie jest dozwolona na poziomie modułu',
        nonLocalNoBinding: 'Nie znaleziono powiązania dla nonlocal „{name}”.',
        nonLocalReassignment: 'Nazwa „{name}” jest przypisywana przed deklaracją nonlocal',
        nonLocalRedefinition: 'Nazwa „{name}” została już zadeklarowana jako nonlocal',
        noneNotCallable: 'Nie można wywołać obiektu typu „None”',
        noneNotIterable: 'Obiekt typu „None” nie może być używany jako wartość iterowalna',
        noneNotSubscriptable: 'Obiekt typu „None” nie może być użyty w indeksie dolnym',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Operator „{operator}” nie jest obsługiwany dla wartości „None”',
        noneUnknownMember: 'Nazwa „{name}” nie jest znanym atrybutem „None”',
        notRequiredArgCount: 'Oczekiwano jednego argumentu typu po wartości „NotRequired”',
        notRequiredNotInTypedDict: 'Element „NotRequired” jest niedozwolony w tym kontekście',
        objectNotCallable: 'Obiekt typu „{type}” nie jest wywoływalny',
        obscuredClassDeclaration: 'Deklaracja klasy „{name}” jest zasłonięta przez deklarację o tej samej nazwie',
        obscuredFunctionDeclaration: 'Deklaracja funkcji „{name}” jest zasłonięta przez deklarację o tej samej nazwie',
        obscuredMethodDeclaration: 'Deklaracja metody „{name}” jest zasłonięta przez deklarację o tej samej nazwie',
        obscuredParameterDeclaration: 'Deklaracja parametru „{name}” jest zasłonięta przez deklarację o tej samej nazwie',
        obscuredTypeAliasDeclaration: 'Deklaracja aliasu typu „{name}” jest zasłonięta przez deklarację o tej samej nazwie',
        obscuredVariableDeclaration: 'Deklaracja „{name}” jest zasłonięta przez deklarację o tej samej nazwie',
        operatorLessOrGreaterDeprecated: 'Operator „<>” nie jest obsługiwany w języku Python w wersji 3; zamiast tego użyj „!=”.',
        optionalExtraArgs: 'Oczekiwano jednego argumentu typu po parametrze „Optional”',
        orPatternIrrefutable: 'Niepodważalny wzorzec jest dozwolony tylko jako ostatni podwzorzec we wzorcu „or”',
        orPatternMissingName: 'Wszystkie wzorce podrzędne we wzorcu „or” muszą dotyczyć tych samych nazw',
        overlappingKeywordArgs: 'Wpisany słownik nakłada się na parametr słowa kluczowego: {names}',
        overlappingOverload: 'Przeciążenie {obscured} dla nazwy „{name}” nigdy nie zostanie użyte, ponieważ jego parametry nakładają się na przeciążenie {obscuredBy}',
        overloadAbstractImplMismatch: 'Przeciążenia muszą być zgodne ze stanem abstrakcyjnym implementacji',
        overloadAbstractMismatch: 'Przeciążenia muszą być abstrakcyjne lub nieabstrakcyjne',
        overloadClassMethodInconsistent: 'Przeciążenia dla nazwy „{name}” używają metody @classmethod niekonsekwentnie',
        overloadFinalInconsistencyImpl: 'Przeciążenie elementu „{name}” jest oznaczone @final, ale implementacja nie jest',
        overloadFinalInconsistencyNoImpl: 'Przeciążenie {index} dla elementu „{name}” jest oznaczone @final, ale przeciążenie 1 nie jest',
        overloadImplementationMismatch: 'Przeciążone wdrożenie jest niespójne z sygnaturą przeciążenia {index}',
        overloadReturnTypeMismatch: 'Przeciążenie {prevIndex} dla nazwy „{name}” nakłada się na przeciążenie {newIndex} i zwraca niezgodny typ',
        overloadStaticMethodInconsistent: 'Przeciążenia dla nazwy „{name}” używają metody @staticmethod niekonsekwentnie',
        overloadWithoutImplementation: 'Nazwa „{name}” jest oznaczona jako overload, ale nie zapewniono implementacji',
        overriddenMethodNotFound: 'Metoda „{name}” jest oznaczona jako override, ale nie istnieje metoda bazowa o tej samej nazwie',
        overrideDecoratorMissing: 'Metoda „{name}” nie jest oznaczona jako override, ale zastępuje metodę w klasie „{className}”',
        paramAfterKwargsParam: 'Parametr nie może następować po parametrze „**”',
        paramAlreadyAssigned: 'Parametr „{name}” jest już przypisany',
        paramAnnotationMissing: 'Brak adnotacji typu dla parametru „{name}”',
        paramAssignmentMismatch: 'Wyrażenia typu „{sourceType}” nie można przypisać do parametru typu „{paramType}”',
        paramNameMissing: 'Brak parametru o nazwie „{name}”',
        paramSpecArgsKwargsDuplicate: 'Argumenty parametru ParamSpec „{type}” zostały już podane',
        paramSpecArgsKwargsUsage: 'Atrybuty „args” i „kwargs” specyfikacji ParamSpec muszą znajdować się w sygnaturze funkcji',
        paramSpecArgsMissing: 'Brak argumentów dla parametru ParamSpec „{type}”.',
        paramSpecArgsUsage: 'Atrybut „args” parametru ParamSpec jest ważna tylko wtedy, gdy jest używana z parametrem *args',
        paramSpecAssignedName: 'Parametr ParamSpec musi być przypisany do zmiennej o nazwie „{name}”',
        paramSpecContext: 'Wartość ParamSpec jest niedozwolona w tym kontekście',
        paramSpecDefaultNotTuple: 'Oczekiwano wielokropka, wyrażenia kolekcji tuple lub parametru ParamSpec dla wartości domyślnej ParamSpec',
        paramSpecFirstArg: 'Oczekiwano nazwy parametru ParamSpec jako pierwszego argumentu',
        paramSpecKwargsUsage: 'Atrybut „kwargs” parametru ParamSpec jest ważna tylko wtedy, gdy jest używana z parametrem **kwargs',
        paramSpecNotUsedByOuterScope: 'Element ParamSpec „{name}” nie ma znaczenia w tym kontekście',
        paramSpecUnknownArg: 'Parametr ParamSpec nie obsługuje więcej niż jednego argumentu',
        paramSpecUnknownMember: '„{name}” nie jest znanym atrybutem parametru ParamSpec',
        paramSpecUnknownParam: '„{name}” jest nieznanym parametrem dla parametru ParamSpec',
        paramTypeCovariant: 'Zmienna typu kowariantnego nie może być używana w typie parametru',
        paramTypePartiallyUnknown: 'Typ parametru „{paramName}” jest częściowo nieznany',
        paramTypeUnknown: 'Typ parametru „{paramName}” jest nieznany',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Wzorzec nigdy nie zostanie dopasowany do typu podmiotu „{type}”',
        positionArgAfterNamedArg: 'Argument pozycyjny nie może występować po argumentach słów kluczowych',
        positionOnlyAfterArgs: 'Separator parametru tylko do pozycjonowania jest niedozwolony po parametrze „*”',
        positionOnlyAfterKeywordOnly: 'Parametr „/” musi występować przed parametrem „*”.',
        positionOnlyAfterNon: 'Parametr tylko do pozycjonowania jest niedozwolony po parametrze, który nie jest tylko do pozycjonowania',
        positionOnlyFirstParam: 'Separator parametrów tylko do pozycjonowania nie jest dozwolony jako pierwszy parametr',
        positionOnlyIncompatible: 'Separator parametrów tylko do pozycjonowania wymaga języka Python 3.8 lub nowszego',
        privateImportFromPyTypedModule: 'Nazwa „{name}” nie jest eksportowana z modułu „{module}”',
        privateUsedOutsideOfClass: 'Nazwa „{name}” jest prywatna i używana poza klasą, w której została zadeklarowana',
        privateUsedOutsideOfModule: 'Nazwa „{name}” jest prywatna i używana poza modułem, w którym została zadeklarowana',
        propertyOverridden: 'Nazwa „{name}” nieprawidłowo zastępuje property o tej samej nazwie w klasie „{className}”',
        propertyStaticMethod: 'Metody statyczne nie są dozwolone w przypadku getter, setter lub deleter property',
        protectedUsedOutsideOfClass: 'Nazwa „{name}” jest chroniona i używana poza klasą, w której została zadeklarowana',
        protocolBaseClass: 'Klasa Protocol typu „{classType}” nie może pochodzić od klasy niebędącej klasą Protocol typu „{baseType}”',
        protocolBaseClassWithTypeArgs: 'Argumenty typu są niedozwolone z klasą Protocol, gdy jest używana składnia parametru typu',
        protocolIllegal: 'Użycie elementu „Protocol” wymaga języka Python w wersji 3.7 lub nowszej',
        protocolNotAllowed: 'Klasa „Protocol” nie może być używana w tym kontekście',
        protocolTypeArgMustBeTypeParam: 'Argument typu dla elementy „Protocol” musi być parametrem typu',
        protocolUnsafeOverlap: 'Klasa nakłada się niebezpiecznie na element „{name}” i może utworzyć dopasowanie w czasie wykonywania',
        protocolVarianceContravariant: 'Zmienna typu „{variable}” używana w klasie ogólnej Protocol „{class}” powinna być kontrawariantna',
        protocolVarianceCovariant: 'Zmienna typu „{variable}” używana w klasie ogólnej Protocol „{class}” powinna być kowariantna',
        protocolVarianceInvariant: 'Zmienna typu „{variable}” używana w klasie ogólnego Protocol „{class}” powinna być niezmienna',
        pyrightCommentInvalidDiagnosticBoolValue: 'Po dyrektywie komentarza Pyright musi następować znak „=” oraz wartość true lub false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Po dyrektywie komentarza Pyright musi następować znak „=” oraz wartość true, false, error, warning, information lub none',
        pyrightCommentMissingDirective: 'Po komentarzu Pyright musi następować dyrektywa (basic lub strict) lub reguła diagnostyczna',
        pyrightCommentNotOnOwnLine: 'Komentarze Pyright używane do kontrolowania ustawień na poziomie plików muszą pojawiać się w oddzielnych wierszach',
        pyrightCommentUnknownDiagnosticRule: 'Reguła „{rule}” jest nieznaną regułą diagnostyczną dla komentarza pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: 'Wartość „{value}” jest nieprawidłowa dla komentarza pyright; oczekiwano wartości: true, false, error, warning, information lub none',
        pyrightCommentUnknownDirective: 'Wartość „{directive}” jest nieznaną dyrektywą dla komentarza pyright; oczekiwano wartości „strict” lub „basic”',
        readOnlyArgCount: 'Oczekiwano jednego argumentu typu po wartości „ReadOnly”',
        readOnlyNotInTypedDict: 'Element „ReadOnly” jest niedozwolony w tym kontekście',
        recursiveDefinition: 'Nie można określić typu „{name}”, ponieważ odwołuje się on do samego siebie',
        relativeImportNotAllowed: 'Importy względne nie mogą być używane z formularzem „import .a”; zamiast tego użyj „from . import a”.',
        requiredArgCount: 'Oczekiwano jednego argumentu typu po wartości „Required”',
        requiredNotInTypedDict: 'Element „Required” jest niedozwolony w tym kontekście',
        returnInAsyncGenerator: 'Instrukcja „return” z wartością jest niedozwolona w generatorze asynchronicznym',
        returnInExceptionGroup: '„return” nie jest dozwolone w bloku „except*”',
        returnMissing: 'Funkcja z zadeklarowanym typem zwracanym „{returnType}” musi zwracać wartość we wszystkich ścieżkach kodu',
        returnOutsideFunction: 'Instrukcja „return” może być używana tylko w ramach funkcji',
        returnTypeContravariant: 'Kontrawariantna zmienna typu nie może być używana w zwracanym typie',
        returnTypeMismatch: 'Nie można przypisać typu „{exprType}” do zwracanego typu „{returnType}”',
        returnTypePartiallyUnknown: 'Zwracany typ „{returnType}” jest częściowo nieznany',
        returnTypeUnknown: 'Zwracany typ jest nieznany',
        revealLocalsArgs: 'Oczekiwano braku argumentów dla wywołania „reveal_locals”',
        revealLocalsNone: 'Brak locals w tym zakresie',
        revealTypeArgs: 'Oczekiwano pojedynczego argumentu pozycyjnego dla wywołania „reveal_type”',
        revealTypeExpectedTextArg: 'Argument „expected_text” dla funkcji „reveal_type” musi być wartością literału str',
        revealTypeExpectedTextMismatch: 'Wpisz niezgodność tekstu; oczekiwano „{expected}”, ale otrzymano „{received}”',
        revealTypeExpectedTypeMismatch: 'Niezgodność typu; oczekiwano wartości „{expected}”, a uzyskano „{received}”',
        selfTypeContext: 'Wartość „Self” jest nieprawidłowa w tym kontekście',
        selfTypeMetaclass: 'Nie można użyć elementu „Self” w ramach metaklasy (podklasy elementu „type”)',
        selfTypeWithTypedSelfOrCls: 'Nie można użyć wartości „Self” w funkcji z parametrem „self” lub „cls”, która ma adnotację typu inną niż „Self”',
        setterGetterTypeMismatch: 'Typu wartości setter property nie można przypisać do zwracanego typu getter',
        singleOverload: 'Nazwa „{name}” jest oznaczona jako przeciążona, ale brakuje dodatkowych przeciążeń',
        slotsAttributeError: 'Nie określono atrybutu „{name}” w elemencie __slots__',
        slotsClassVarConflict: '„{name}” powoduje konflikt ze zmienną wystąpienia zadeklarowaną w elemencie „__slots__”',
        starPatternInAsPattern: 'Wzór gwiazdy nie może być użyty z miejscem docelowym parametru „as”.',
        starPatternInOrPattern: 'Wzór gwiazdy nie może mieć wartości ORed w ramach innych wzorów',
        starStarWildcardNotAllowed: 'Symbolu ** nie można używać z symbolem wieloznacznym „_”',
        staticClsSelfParam: 'Metody statyczne nie powinny przyjmować parametru „self” ani „cls”.',
        stdlibModuleOverridden: 'Ścieżka „{path}” zastępuje moduł stdlib „{name}”',
        stringNonAsciiBytes: 'Znak inny niż ASCII jest niedozwolony w literale ciągu bajtów',
        stringNotSubscriptable: 'Wyrażenie ciągu nie może być indeksowane w wyrażeniu typu; ujmij całe wyrażenie w cudzysłowy',
        stringUnsupportedEscape: 'Nieobsługiwana sekwencja ucieczki w literale ciągu',
        stringUnterminated: 'Literał ciągu jest niezakończony',
        stubFileMissing: 'Nie znaleziono pliku stub dla nazwy „{importName}”',
        stubUsesGetAttr: 'Plik stub typu jest niekompletny; element „__getattr__” przesłania błędy w przypadku modułu',
        sublistParamsIncompatible: 'Parametry sublisty nie są obsługiwane w wersji języka Python 3.x',
        superCallArgCount: 'Oczekiwano nie więcej niż dwóch argumentów wywołania „super”',
        superCallFirstArg: 'Oczekiwano typu klasy jako pierwszego argumentu wywołania „super”, ale otrzymano „{type}”',
        superCallSecondArg: 'Drugi argument wywołania „super” musi być obiektem lub klasą wywodzącą się z typu „{type}”',
        superCallZeroArgForm: 'Forma bez argumentów wywołania „super” jest prawidłowa tylko w ramach metody',
        superCallZeroArgFormStaticMethod: 'Forma z zerowym argumentem wywołania „super” jest nieprawidłowa w metodzie statycznej',
        symbolIsPossiblyUnbound: 'Nazwa „{name}” jest prawdopodobnie niepowiązana',
        symbolIsUnbound: 'Nazwa „{name}” jest niepowiązana',
        symbolIsUndefined: 'Nazwa „{name}” nie jest zdefiniowana',
        symbolOverridden: 'Nazwa „{name}” przesłania symbol o tej samej nazwie w klasie „{className}”',
        ternaryNotAllowed: 'Wyrażenie trójskładnikowe nie jest dozwolone w wyrażeniu typu',
        totalOrderingMissingMethod: 'Klasa musi definiować jedną z następujących wartości: „__lt__”, „__le__”, „__gt__” lub „__ge__”, aby użyć parametru total_ordering',
        trailingCommaInFromImport: 'Końcowy przecinek nie jest dozwolony bez otaczających nawiasów',
        tryWithoutExcept: 'Instrukcja „Try” musi mieć co najmniej jedną klauzulę „except” lub „finally”',
        tupleAssignmentMismatch: 'Nie można przypisywać wyrażenia w ramach typu „{type}” do docelowej kolekcji tuple',
        tupleInAnnotation: 'Wyrażenie kolekcji tuple jest niedozwolone w wyrażeniu typu',
        tupleIndexOutOfRange: 'Indeks {index} jest poza zakresem dla typu {type}',
        typeAliasIllegalExpressionForm: 'Nieprawidłowy formularz wyrażenia dla definicji aliasu typu',
        typeAliasIsRecursiveDirect: 'Alias typu „{name}” nie może używać samego siebie w swojej definicji',
        typeAliasNotInModuleOrClass: 'Typ TypeAlias można zdefiniować tylko w zakresie modułu lub klasy',
        typeAliasRedeclared: 'Nazwa „{name}” jest zadeklarowana jako TypeAlias i może być przypisana tylko raz',
        typeAliasStatementBadScope: 'Instrukcja type może być użyta tylko w zakresie modułu lub klasy',
        typeAliasStatementIllegal: 'Instrukcja typu alias wymaga języka Python w wersji 3.12 lub nowszej',
        typeAliasTypeBaseClass: 'A type alias defined in a "type" statement cannot be used as a base class',
        typeAliasTypeMustBeAssigned: 'Typ TypeAliasType musi być przypisany do zmiennej o takiej samej nazwie jak alias typu',
        typeAliasTypeNameArg: 'Pierwszy argument dla typu TypeAliasType musi być literałem ciągu reprezentującym nazwę aliasu typu',
        typeAliasTypeNameMismatch: 'Nazwa aliasu typu musi być zgodna z nazwą zmiennej, do której jest przypisana',
        typeAliasTypeParamInvalid: 'Lista parametrów typu musi być kolekcją tuple zawierającą tylko parametry TypeVar, TypeVarTuple lub ParamSpec',
        typeAnnotationCall: 'Wyrażenie wywołania jest niedozwolone w wyrażeniu typu',
        typeAnnotationVariable: 'Zmienna niedozwolona w wyrażeniu typu',
        typeAnnotationWithCallable: 'Argument typu „type” musi być klasą; elementy wywoływane nie są obsługiwane',
        typeArgListExpected: 'Oczekiwano parametru ParamSpec, wielokropka lub listy typów',
        typeArgListNotAllowed: 'Wyrażenie listy jest niedozwolone dla tego argumentu typu',
        typeArgsExpectingNone: 'Oczekiwano braku argumentów typu dla klasy „{name}”',
        typeArgsMismatchOne: 'Oczekiwano jednego argumentu typu, ale otrzymano {received}',
        typeArgsMissingForAlias: 'Oczekiwano argumentów typu dla aliasu typu ogólnego „{name}”',
        typeArgsMissingForClass: 'Oczekiwano argumentów typu dla ogólnej klasy „{name}”',
        typeArgsTooFew: 'Podano zbyt mało argumentów typu dla „{name}”; oczekiwano wartości {expected}, ale otrzymano {received}',
        typeArgsTooMany: 'Podano zbyt wiele argumentów typu dla nazwy „{name}”; oczekiwano {expected}, a uzyskano {received}',
        typeAssignmentMismatch: 'Nie można przypisać typu „{sourceType}” do zadeklarowanego typu „{destType}”',
        typeAssignmentMismatchWildcard: 'Symbol importu „{name}” ma typ „{sourceType}”, którego nie można przypisać do zadeklarowanego typu „{destType}”',
        typeCallNotAllowed: 'wywołanie type() nie powinno być używane w wyrażeniu typu',
        typeCheckOnly: 'Nazwa „{name}” jest oznaczona jako @type_check_only i może być używana tylko w adnotacjach typu',
        typeCommentDeprecated: 'Use of type comments is deprecated; use type annotation instead',
        typeExpectedClass: 'Oczekiwano klasy, ale odebrano typ „{type}”',
        typeFormArgs: '„TypeForm” akceptuje pojedynczy argument pozycyjny',
        typeGuardArgCount: 'Oczekiwano pojedynczego argumentu typu po parametrze „TypeGuard” lub „TypeIs”',
        typeGuardParamCount: 'Funkcje i metody zabezpieczające typu zdefiniowane przez użytkownika muszą mieć co najmniej jeden parametr wejściowy',
        typeIsReturnType: 'Zwracany typ TypeIs („{returnType}”) jest niezgodny z typem parametru wartości („{type}”)',
        typeNotAwaitable: '"{type}" is not awaitable',
        typeNotIntantiable: 'Nie można utworzyć wystąpienia „{type}”',
        typeNotIterable: 'Typ „{type}” nie jest iterowalny',
        typeNotSpecializable: 'Nie można specjalizować typu „{type}”',
        typeNotSubscriptable: 'Obiekt typu „{type}” nie może być użyty w indeksie dolnym',
        typeNotSupportBinaryOperator: 'Operator „{operator}” nieobsługiwany dla typów „{leftType}” i „{rightType}”',
        typeNotSupportBinaryOperatorBidirectional: 'Operator „{operator}” nie jest obsługiwany dla typów „{leftType}” i „{rightType}”, gdy oczekiwanym typem jest „{expectedType}”',
        typeNotSupportUnaryOperator: 'Operator „{operator}” nie jest obsługiwany dla typu „{type}”',
        typeNotSupportUnaryOperatorBidirectional: 'Operator „{operator}” nie jest obsługiwany dla typu „{type}”, gdy oczekiwanym typem jest „{expectedType}”',
        typeNotUsableWith: 'Obiekt typu „{type}” nie może być używany z parametrem „with”, ponieważ nie wdraża metody {method}',
        typeParameterBoundNotAllowed: 'Powiązanie lub ograniczenie nie może być używane z parametrem typu ze zmienną liczbą argumentów lub parametrem ParamSpec',
        typeParameterConstraintTuple: 'Ograniczenie parametru typu musi być krotką dwóch lub więcej typów',
        typeParameterExistingTypeParameter: 'Parametr typu „{name}” jest już używany',
        typeParameterNotDeclared: 'Parametr typu „{name}” nie znajduje się na liście parametrów typu dla „{container}”',
        typeParametersMissing: 'Należy określić co najmniej jeden parametr typu',
        typePartiallyUnknown: 'Typ „{name}” jest częściowo nieznany',
        typeUnknown: 'Typ „{name}” jest nieznany',
        typeVarAssignedName: 'Typ TypeVar musi być przypisany do zmiennej o nazwie „{name}”',
        typeVarAssignmentMismatch: 'Nie można przypisać typu „{type}” do zmiennej typu „{name}”',
        typeVarBoundAndConstrained: 'Typ TypeVar nie może być jednocześnie powiązany i ograniczony',
        typeVarBoundGeneric: 'Typ powiązany TypeVar nie może być ogólny',
        typeVarConstraintGeneric: 'Typ ograniczenia TypeVar nie może być ogólny',
        typeVarDefaultBoundMismatch: 'Domyślny typ TypeVar musi być podtypem powiązanego typu',
        typeVarDefaultConstraintMismatch: 'Typ domyślny TypeVar musi być jednym z typów z ograniczeniami',
        typeVarDefaultIllegal: 'Typy domyślne zmiennych typów wymagają wersji języka Python 3.13 lub nowszej',
        typeVarDefaultInvalidTypeVar: 'Parametr typu „{name}” ma typ domyślny, który odnosi się do co najmniej jednej zmiennej typu, która jest poza zakresem',
        typeVarFirstArg: 'Oczekiwano nazwy TypeVar jako pierwszego argumentu',
        typeVarInvalidForMemberVariable: 'Typ atrybutu nie może używać zmiennej typu „{name}” w zakresie metody lokalnej',
        typeVarNoMember: 'Typ atrybutu TypeVar „{type}” nie ma atrybutu „{name}”',
        typeVarNotSubscriptable: 'Typ TypeVar „{type}” nie może być subskrybowany',
        typeVarNotUsedByOuterScope: 'Zmienna typu „{name}” nie ma w tym kontekście żadnego znaczenia',
        typeVarPossiblyUnsolvable: 'Zmienna typu „{name}” może zostać nierozwiązana, jeśli obiekt wywołujący nie poda argumentu dla parametru „{param}”',
        typeVarSingleConstraint: 'Typ TypeVar musi mieć co najmniej dwa typy ograniczone',
        typeVarTupleConstraints: 'Element TypeVarTuple nie może mieć ograniczeń wartości',
        typeVarTupleContext: 'Wartość TypeVarTuple jest niedozwolona w tym kontekście',
        typeVarTupleDefaultNotUnpacked: 'Typ domyślny TypeVarTuple musi być nierozpakowaną kolekcją tuple lub parametrem TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'Operator rozpakowywania jest wymagany dla wartości parametru TypeVarTuple',
        typeVarTupleUnknownParam: 'Nazwa „{name}” jest nieznanym parametrem typu TypeVarTuple',
        typeVarUnknownParam: '„{name}” jest nieznanym parametrem dla argumentu TypeVar',
        typeVarUsedByOuterScope: 'Argument TypeVar „{name}” jest już używany przez zakres zewnętrzny',
        typeVarUsedOnlyOnce: 'Typ TypeVar „{name}” pojawia się tylko raz w sygnaturze funkcji ogólnej',
        typeVarVariance: 'Zmienna typu TypeVar nie może być jednocześnie kowariantna i kontrawariantna',
        typeVarWithDefaultFollowsVariadic: 'Wartość TypeVar „{typeVarName}” ma wartość domyślną i nie może następować po wartości TypeVarTuple „{variadicName}”.',
        typeVarWithoutDefault: 'Element „{name}” nie może występować po elemencie „{other}” na liście parametrów typu, ponieważ nie ma typu domyślnego',
        typeVarsNotInGenericOrProtocol: 'Elementy Generic[] lub Protocol[] muszą zawierać wszystkie zmienne typu',
        typedDictAccess: 'Nie można uzyskać dostępu do elementu w TypedDict',
        typedDictAssignedName: 'Element TypedDict musi być przypisany do zmiennej o nazwie „{name}”',
        typedDictBadVar: 'Klasy TypedDict mogą zawierać tylko adnotacje typu',
        typedDictBaseClass: 'Wszystkie klasy bazowe dla klas TypedDict muszą być również klasami TypedDict',
        typedDictBoolParam: 'Oczekiwano, że parametr „{name}” będzie miał wartość True lub False',
        typedDictClosedExtras: 'Klasa bazowa „{name}” jest closed TypedDict; dodatkowe elementy muszą być typu „{type}”',
        typedDictClosedNoExtras: 'Klasa bazowa „{name}” jest closed TypedDict; dodatkowe elementy są niedozwolone',
        typedDictDelete: 'Nie można usunąć elementu w typie TypedDict',
        typedDictEmptyName: 'Nazwy w elemencie TypedDict nie mogą być puste',
        typedDictEntryName: 'Oczekiwano literału ciągu dla nazwy wpisu słownika',
        typedDictEntryUnique: 'Nazwy w słowniku muszą być unikatowe',
        typedDictExtraArgs: 'Dodatkowe argumenty TypedDict nie są obsługiwane',
        typedDictExtraItemsClosed: 'Element TypedDict nie może być „closed”, jeśli obsługuje dodatkowe elementy',
        typedDictFieldNotRequiredRedefinition: 'Element TypedDict „{name}” nie może zostać przedefiniowany jako NotRequired',
        typedDictFieldReadOnlyRedefinition: 'Element TypedDict „{name}” nie może być przedefiniowany jako ReadOnly.',
        typedDictFieldRequiredRedefinition: 'Element TypedDict „{name}” nie może zostać przedefiniowany jako Required',
        typedDictFirstArg: 'Oczekiwano nazwy klasy TypedDict jako pierwszego argumentu',
        typedDictInClassPattern: 'klasa TypedDict nie jest dozwolona we wzorcu klasy',
        typedDictInitsubclassParameter: 'Element TypedDict nie obsługuje parametru __init_subclass__ „{name}”',
        typedDictNotAllowed: 'Nie można użyć elementu „TypedDict” w tym kontekście',
        typedDictSecondArgDict: 'Oczekiwano parametru dict lub słowa kluczowego jako drugiego parametru',
        typedDictSecondArgDictEntry: 'Oczekiwano prostego wpisu słownika',
        typedDictSet: 'Nie można przypisać elementu w TypedDict',
        unaccessedClass: 'Nie uzyskano dostępu do klasy „{name}”',
        unaccessedFunction: 'Brak dostępu do funkcji „{name}”.',
        unaccessedImport: 'Import „{name}” nie jest dostępny',
        unaccessedSymbol: 'Brak dostępu do „{name}”.',
        unaccessedVariable: 'Brak dostępu do zmiennej „{name}”.',
        unannotatedFunctionSkipped: 'Analiza funkcji „{name}” została pominięta, ponieważ nie ma adnotacji',
        unaryOperationNotAllowed: 'Operator jednoargumentowy nie jest dozwolony w wyrażeniu typu',
        unexpectedAsyncToken: 'Oczekiwano wartości „def”, „with” lub „for” po „async”',
        unexpectedExprToken: 'Nieoczekiwany token na końcu wyrażenia',
        unexpectedIndent: 'Nieoczekiwane wcięcie',
        unexpectedUnindent: 'Nieoczekiwany brak wcięcia',
        unhashableDictKey: 'Klucz słownika musi być wartością skrótu',
        unhashableSetEntry: 'Set wpis musi być wartością skrótu',
        uninitializedAbstractVariables: 'Zmienne zdefiniowane w abstrakcyjnej klasie bazowej nie są inicjowane w klasie final „{classType}”',
        uninitializedInstanceVariable: 'Zmienna wystąpienia „{name}” nie została zainicjowana w treści klasy ani w metodzie __init__',
        unionForwardReferenceNotAllowed: 'Składnia elementu Union nie może być używana z operandem ciągu; użyj cudzysłowów wokół całego wyrażenia',
        unionSyntaxIllegal: 'Alternatywna składnia unii wymaga języka Python w wersji 3.10 lub nowszej',
        unionTypeArgCount: 'Element Union wymaga co najmniej dwóch argumentów typu',
        unionUnpackedTuple: 'Typ Union nie może zawierać niespakowanej kolekcji tuple',
        unionUnpackedTypeVarTuple: 'Typ Union nie może zawierać niespakowanego parametru TypeVarTuple',
        unnecessaryCast: 'Niepotrzebne wywołanie „cast”; typ jest już „{type}”',
        unnecessaryIsInstanceAlways: 'Niepotrzebne wywołanie elementu isinstance; „{testType}” jest zawsze wystąpieniem „{classType}”',
        unnecessaryIsInstanceNever: 'Niepotrzebne wywołanie funkcji isinstance; „{testType}” nigdy nie jest instancją „{classType}”',
        unnecessaryIsSubclassAlways: 'Niepotrzebne wywołanie „issubclass”; „{testType}” jest zawsze podklasą klasy „{classType}”',
        unnecessaryIsSubclassNever: 'Niepotrzebne wywołanie funkcji issubclass; „{testType}” nigdy nie jest podklasą „{classType}”',
        unnecessaryPyrightIgnore: 'Niepotrzebny komentarz „# pyright: ignore”',
        unnecessaryPyrightIgnoreRule: 'Niepotrzebna reguła „# pyright: ignore”: „{name}”',
        unnecessaryTypeIgnore: 'Niepotrzebny komentarz „# type: ignore”',
        unpackArgCount: 'Oczekiwano jednego argumentu typu po wartości „Unpack”',
        unpackExpectedTypeVarTuple: 'Oczekiwano typu TypeVarTuple lub tuple jako argumentu typu dla elementu Unpack',
        unpackExpectedTypedDict: 'Oczekiwano argumentu typu TypedDict dla elementu Unpack',
        unpackIllegalInComprehension: 'Operacja rozpakowywania nie jest dozwolona w rozumieniu',
        unpackInAnnotation: 'Operator rozpakowywania nie jest dozwolony w wyrażeniu typu',
        unpackInDict: 'Operacja rozpakowywania nie jest dozwolona w słownikach',
        unpackInSet: 'Rozpakowywanie operatora jest niedozwolone w set',
        unpackNotAllowed: 'Element Unpack jest niedozwolony w tym kontekście',
        unpackOperatorNotAllowed: 'Operacja rozpakowywania jest niedozwolona w tym kontekście',
        unpackTuplesIllegal: 'Operacja rozpakowywania nie jest dozwolona w krotkach przed językiem Python w wersji 3.8',
        unpackedArgInTypeArgument: 'Nie można użyć nierozpakowanych argumentów w tym kontekście',
        unpackedArgWithVariadicParam: 'Nie można użyć nierozpakowanego argumentu dla parametru TypeVarTuple',
        unpackedDictArgumentNotMapping: 'Wyrażenie argumentu po znakach ** musi być mapowaniem z typem klucza „str”',
        unpackedDictSubscriptIllegal: 'Operator rozpakowywania słownika w indeksie dolnym jest niedozwolony',
        unpackedSubscriptIllegal: 'Operator rozpakowywania w indeksie dolnym wymaga języka Python w wersji 3.11 lub nowszej',
        unpackedTypeVarTupleExpected: 'Oczekiwano nierozpakowanego typu TypeVarTuple; użyj Unpack[{name1}] lub *{name2}',
        unpackedTypedDictArgument: 'Nie można dopasować nierozpakowanego argumentu TypedDict do parametrów',
        unreachableCode: 'Kod jest nieosiągalny',
        unreachableCodeType: 'Analiza typów wskazuje, że kod jest nieosiągalny',
        unreachableExcept: 'Klauzula Except jest nieosiągalna, ponieważ wyjątek jest już obsługiwany',
        unsupportedDunderAllOperation: 'Operacja na elemencie „__all__” nie jest obsługiwana, więc wyeksportowana lista symboli może być nieprawidłowa',
        unusedCallResult: 'Wynik wyrażenia wywołania jest typu „{type}” i nie jest używany; przypisz do zmiennej „_”, jeśli jest to zamierzone',
        unusedCoroutine: 'Wynik wywołania funkcji asynchronicznej nie jest używany; użyj wartości „await” lub przypisz wynik do zmiennej',
        unusedExpression: 'Wartość wyrażenia jest nieużywana',
        varAnnotationIllegal: 'Type annotations for variables requires Python 3.6 or newer; use type comment for compatibility with previous versions',
        variableFinalOverride: 'Zmienna „{name}” jest oznaczona jako Final i zastępuje zmienną inną non-Final o tej samej nazwie w klasie „{className}”',
        variadicTypeArgsTooMany: 'Lista argumentów typu może zawierać co najwyżej jeden nierozpakowany typ TypeVarTuple lub tuple',
        variadicTypeParamTooManyAlias: 'Alias typu może mieć co najwyżej jeden parametr typu TypeVarTuple, ale otrzymał wiele ({names})',
        variadicTypeParamTooManyClass: 'Klasa ogólna może mieć co najwyżej jeden parametr typu TypeVarTuple, ale otrzymał wiele ({names})',
        walrusIllegal: 'Operator „:=” wymaga języka Python w wersji 3.8 lub nowszej',
        walrusNotAllowed: 'Operator „:=” jest niedozwolony w tym kontekście bez otaczających nawiasów',
        wildcardInFunction: 'Wildcard import not allowed within a class or function',
        wildcardLibraryImport: 'Wildcard import from a library not allowed',
        wildcardPatternTypePartiallyUnknown: 'Typ przechwycony przez wzorzec symboli wieloznacznych jest częściowo nieznany',
        wildcardPatternTypeUnknown: 'Typ przechwycony przez wzorzec symboli wieloznacznych jest nieznany',
        yieldFromIllegal: 'Użycie wartości „yield from” wymaga języka Python w wersji 3.3 lub nowszej',
        yieldFromOutsideAsync: 'Instrukcja „yield from” jest niedozwolona w funkcji asynchronicznej',
        yieldOutsideFunction: 'Instrukcja „yield” jest niedozwolona poza funkcją lub wyrażeniem lambda',
        yieldWithinComprehension: 'Instrukcja „yield” nie jest dozwolona w rozumieniu',
        zeroCaseStatementsFound: 'Match statement must include at least one case statement',
        zeroLengthTupleNotAllowed: 'Zero-length tuple is not allowed in this context'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Formularza specjalnego „Annotated” nie można używać z kontrolami wystąpień i klas',
        argParam: 'Argument odpowiada parametrowi „{paramName}”',
        argParamFunction: 'Argument odpowiada parametrowi „{paramName}” w funkcji „{functionName}”',
        argsParamMissing: 'Parametr „*{paramName}” nie ma odpowiadającego mu parametru',
        argsPositionOnly: 'Niezgodność parametrów tylko dla pozycji; oczekiwano wartości „{expected}”, a uzyskano „{received}”',
        argumentType: 'Typ argumentu to „{type}”',
        argumentTypes: 'Typy argumentów: ({types})',
        assignToNone: 'Nie można przypisać typu do elementu „None”',
        asyncHelp: 'Czy chodziło o wartość „async with”?',
        baseClassIncompatible: 'Klasa bazowa „{baseClass}” jest niezgodna z typem „{type}”',
        baseClassIncompatibleSubclass: 'Klasa bazowa „{baseClass}” pochodzi od klasy podrzędnej „{subclass}”, która jest niezgodna z typem „{type}”',
        baseClassOverriddenType: 'Klasa bazowa „{baseClass}” udostępnia typ „{type}”, który jest przesłonięty',
        baseClassOverridesType: 'Zastąpienie klasy bazowej „{baseClass}” typem „{type}”',
        bytesTypePromotions: 'Ustaw właściwość disableBytesTypePromotions na wartość false, aby włączyć zachowanie promocji typu dla elementów „bytearray” i „memoryview”',
        conditionalRequiresBool: 'Metoda __bool__ dla typu „{operandType}” zwraca typ "{boolReturnType}" zamiast „bool”',
        dataClassFieldLocation: 'Deklaracja pola',
        dataClassFrozen: 'Nazwa „{name}” jest zamrożona',
        dataProtocolUnsupported: 'Element „{name}” to protokół danych',
        descriptorAccessBindingFailed: 'Nie można powiązać metody „{name}” dla klasy deskryptora „{className}”',
        descriptorAccessCallFailed: 'Nie można wywołać metody „{name}” dla klasy deskryptora „{className}”',
        finalMethod: 'Final method',
        functionParamDefaultMissing: 'Brak domyślnego argumentu dla parametru „{name}”',
        functionParamName: 'Niezgodność nazw parametrów: „{destName}” a „{srcName}”',
        functionParamPositionOnly: 'Niezgodność parametrów tylko do położenia; parametr „{name}” nie jest tylko pozycją',
        functionReturnTypeMismatch: 'Typ zwracanego typu funkcji „{sourceType}” jest niezgodny z typem „{destType}”',
        functionTooFewParams: 'Funkcja akceptuje zbyt mało parametrów pozycyjnych; oczekiwano {expected}, ale otrzymano {received}',
        functionTooManyParams: 'Funkcja akceptuje zbyt wiele parametrów pozycyjnych; oczekiwano {expected}, ale otrzymano {received}',
        genericClassNotAllowed: 'Typ ogólny z argumentami typu jest niedozwolony dla sprawdzania wystąpienia lub klasy',
        incompatibleDeleter: 'Property deleter method is incompatible',
        incompatibleGetter: 'Property getter method is incompatible',
        incompatibleSetter: 'Property setter method is incompatible',
        initMethodLocation: 'Metoda __init__ jest zdefiniowana w klasie „{type}”',
        initMethodSignature: 'Sygnatura __init__ to typ „{type}”',
        initSubclassLocation: 'Metoda __init_subclass__ jest zdefiniowana w klasie „{name}”',
        invariantSuggestionDict: 'Rozważ przełączenie z wartości „dict” na „Mapping”, która jest kowariantna w typie wartości',
        invariantSuggestionList: 'Rozważ zmianę wartości „list” na „Sequence”, która jest kowariantna',
        invariantSuggestionSet: 'Rozważ przełączenie z wartości „set” na „Container”, która jest kowariantna',
        isinstanceClassNotSupported: 'Typ „{type}” nie jest obsługiwany w przypadku kontroli wystąpień i klas',
        keyNotRequired: '„{name}” nie jest wymaganym kluczem w typie „{type}”, więc dostęp może spowodować wyjątek środowiska uruchomieniowego',
        keyReadOnly: 'Nazwa „{name}” jest kluczem tylko do odczytu w typie „{type}”',
        keyRequiredDeleted: 'Nazwa „{name}” jest wymaganym kluczem i nie można go usunąć',
        keyUndefined: 'Nazwa „{name}” nie jest zdefiniowanym kluczem w typie „{type}”',
        kwargsParamMissing: 'Parametr „**{paramName}” nie ma odpowiadającego mu parametru',
        listAssignmentMismatch: 'Typ „{type}” jest niezgodny z listą docelową',
        literalAssignmentMismatch: 'Nie można przypisać typu „{sourceType}” do typu „{destType}”',
        matchIsNotExhaustiveHint: 'Jeśli kompleksowa obsługa nie jest zamierzona, dodaj „case _: pass”',
        matchIsNotExhaustiveType: 'Nieobsługiwany typ: „{type}”',
        memberAssignment: 'Wyrażenia typu „{type}” nie można przypisać do atrybutu „{name}” klasy „{classType}”',
        memberIsAbstract: '„{type}.{name}” nie zostało zaimplementowane',
        memberIsAbstractMore: 'i jeszcze {count}...',
        memberIsClassVarInProtocol: 'Element „{name}” jest zdefiniowany jako element ClassVar w protokole',
        memberIsInitVar: 'Składowa „{name}” jest polem do operacji init-only',
        memberIsInvariant: 'Nazwa „{name}” jest niezmienna, ponieważ jest modyfikowalna',
        memberIsNotClassVarInClass: 'Element „{name}” musi być zdefiniowany jako ClassVar, aby był zgodny z protokołem',
        memberIsNotClassVarInProtocol: 'Element „{name}” nie jest zdefiniowany jako ClassVar w protokole',
        memberIsNotReadOnlyInProtocol: '„{name}” nie jest tylko do odczytu w protokole',
        memberIsReadOnlyInProtocol: '„{name}” jest tylko do odczytu w protokole',
        memberIsWritableInProtocol: 'Nazwa „{name}” jest zapisywalna w protokole',
        memberSetClassVar: 'Atrybut „{name}” nie może zostać przypisany przez wystąpienie klasy, ponieważ jest to element ClassVar',
        memberTypeMismatch: 'Nazwa „{name}” jest niezgodnym typem',
        memberUnknown: 'Atrybut „{name}” jest nieznany',
        metaclassConflict: 'Metaklasa „{metaclass1}” powoduje konflikt z „{metaclass2}”',
        missingDeleter: 'Property deleter method is missing',
        missingGetter: 'Property getter method is missing',
        missingSetter: 'Property setter method is missing',
        namedParamMissingInDest: 'Dodatkowy parametr „{name}”',
        namedParamMissingInSource: 'Brak parametru słowa kluczowego „{name}”',
        namedParamTypeMismatch: 'Parametr słowa kluczowego „{name}” typu „{sourceType}” jest niezgodny z typem „{destType}”',
        namedTupleNotAllowed: 'Funkcja NamedTuple nie może być używana do sprawdzania wystąpień lub klas',
        newMethodLocation: 'Metoda __new__ jest zdefiniowana w klasie „{type}”',
        newMethodSignature: 'Sygnatura __new__ to typ „{type}”',
        newTypeClassNotAllowed: 'Klasy utworzonej za pomocą elementu NewType nie można używać z sprawdzaniem wystąpień i klas',
        noOverloadAssignable: 'Żadna przeciążona funkcja nie pasuje do typu „{type}”',
        noneNotAllowed: 'Wartość None nie może być używana w przypadku kontroli wystąpień lub klas',
        orPatternMissingName: 'Brak nazw: {name}',
        overloadIndex: 'Przeciążenie {index} jest najbardziej zbliżonym dopasowaniem',
        overloadNotAssignable: 'Nie można przypisać jednego lub więcej przeciążeń „{name}”.',
        overloadSignature: 'Sygnatura przeciążenia jest zdefiniowana tutaj',
        overriddenMethod: 'Przesłonięta metoda',
        overriddenSymbol: 'Przesłonięty symbol',
        overrideInvariantMismatch: 'Typ zastąpienia „{overrideType}” nie jest taki sam jak typ podstawowy „{baseType}”',
        overrideIsInvariant: 'Zmienna podlega przeobrażeniom, dlatego jej typ jest niezmienny',
        overrideNoOverloadMatches: 'Żadna sygnatura przeciążenia w przesłonięciu nie jest zgodna z metodą bazową',
        overrideNotClassMethod: 'Metoda bazowa jest zadeklarowana jako metoda classmethod, ale przesłonięcie nie',
        overrideNotInstanceMethod: 'Metoda bazowa jest zadeklarowana jako metoda wystąpienia, ale zastąpienie nie jest',
        overrideNotStaticMethod: 'Metoda bazowa jest zadeklarowana jako staticmethod, ale przesłonięcie nie',
        overrideOverloadNoMatch: 'Zastąpienie nie obsługuje wszystkich przeciążeń metody podstawowej',
        overrideOverloadOrder: 'Przeciążenia dla metody przesłaniania muszą być w takiej samej kolejności, co metoda bazowa',
        overrideParamKeywordNoDefault: 'Niezgodność parametru słowa kluczowego „{name}”: parametr bazowy ma domyślną wartość argumentu, parametr zastąpienia nie ma jej',
        overrideParamKeywordType: 'Niezgodność typu parametru słowa kluczowego „{name}”: parametr bazowy jest typu „{baseType}”, a parametr zastąpienia jest typu „{overrideType}”',
        overrideParamName: 'Niezgodność nazwy parametru {index}: parametr podstawowy nosi nazwę „{baseName}”, a parametr zastąpienia — „{overrideName}”',
        overrideParamNameExtra: 'W bazie brakuje parametru „{name}”.',
        overrideParamNameMissing: 'Brak parametru „{name}” w zastąpieniu',
        overrideParamNamePositionOnly: 'Niezgodność parametru {index}: parametr podstawowy „{baseName}” jest parametrem słowa kluczowego, parametr przesłonięcia jest tylko w pozycji',
        overrideParamNoDefault: 'Niezgodność parametru {index}: parametr bazowy ma domyślną wartość argumentu, a parametr zastąpienia nie ma jej',
        overrideParamType: 'Niezgodność typów parametru {index}: parametr bazowy jest typu „{baseType}”, parametr zastąpienia jest typu „{overrideType}”',
        overridePositionalParamCount: 'Niezgodność liczby parametrów pozycyjnych; metoda podstawowa ma {baseCount}, a zastąpienie {overrideCount}',
        overrideReturnType: 'Niezgodność zwracanego typu: metoda podstawowa zwraca typ „{baseType}”, przesłonięcie zwraca typ „{overrideType}”',
        overrideType: 'Klasa bazowa definiuje typ jako „{type}”',
        paramAssignment: 'Parametr {index}: typ „{sourceType}” jest niezgodny z typem „{destType}”',
        paramSpecMissingInOverride: 'Brak parametrów ParamSpec w metodzie zastąpienia',
        paramType: 'Typ parametru to „{paramType}”',
        privateImportFromPyTypedSource: 'Zamiast tego importuj z modułu „{module}”.',
        propertyAccessFromProtocolClass: 'Nie można uzyskać dostępu do właściwości zdefiniowanej w klasie protokołu jako zmiennej klasy',
        propertyMethodIncompatible: 'Property method "{name}" is incompatible',
        propertyMethodMissing: 'Property method "{name}" is missing in override',
        propertyMissingDeleter: 'Property "{name}" has no defined deleter',
        propertyMissingSetter: 'Property "{name}" has no defined setter',
        protocolIncompatible: 'Protokół „{sourceType}” jest niezgodny z protokołem „{destType}”',
        protocolMemberMissing: 'Brak nazwy „{name}”.',
        protocolRequiresRuntimeCheckable: 'Klasa Protocol musi być @runtime_checkable, aby mogła być używana z kontrolami wystąpień i klas',
        protocolSourceIsNotConcrete: '„{sourceType}” nie jest typem specyficznej klasy i nie można go przypisać do typu „{destType}”',
        protocolUnsafeOverlap: 'Atrybuty „{name}” mają takie same nazwy jak protokół',
        pyrightCommentIgnoreTip: 'Użyj polecenia „# pyright: ignore[<diagnostic rules>]”, aby wyłączyć diagnostykę dla pojedynczego wiersza',
        readOnlyAttribute: 'Atrybut „{name}” jest tylko do odczytu',
        seeClassDeclaration: 'Zobacz deklarację klasy',
        seeDeclaration: 'Zobacz deklarację',
        seeFunctionDeclaration: 'Zobacz deklarację funkcji',
        seeMethodDeclaration: 'Zobacz deklarację metody',
        seeParameterDeclaration: 'Zobacz deklarację parametru',
        seeTypeAliasDeclaration: 'Zobacz deklarację aliasu typu',
        seeVariableDeclaration: 'Zobacz deklarację zmiennej',
        tupleAssignmentMismatch: 'Typ „{type}” jest niezgodny z docelową tuple',
        tupleEntryTypeMismatch: 'Wpis tuple {entry} jest nieprawidłowego typu',
        tupleSizeIndeterminateSrc: 'Niezgodność rozmiaru kolekcji tuple; oczekiwano {expected}, ale otrzymano rozmiar nieokreślony',
        tupleSizeIndeterminateSrcDest: 'Niezgodność rozmiaru kolekcji tuple; oczekiwano {expected} lub więcej, a otrzymano rozmiar nieokreślony',
        tupleSizeMismatch: 'Niezgodność rozmiaru tuple; oczekiwano {expected}, ale otrzymano {received}',
        tupleSizeMismatchIndeterminateDest: 'Niezgodność rozmiaru kolekcji tuple; oczekiwano {expected} lub więcej, a otrzymano {received}',
        typeAliasInstanceCheck: 'Alias typu utworzony za pomocą instrukcji „{type}” nie może być użyty do sprawdzania wystąpień i klas',
        typeAssignmentMismatch: 'Typu „{sourceType}” nie można przypisać do typu „{destType}”',
        typeBound: 'Typu „{sourceType}” nie można przypisać do górnej granicy „{destType}” dla zmiennej typu „{name}”',
        typeConstrainedTypeVar: 'Typu „{type}” nie można przypisać do zmiennej typu ograniczonego „{name}”',
        typeIncompatible: 'Nie można przypisać typu „{sourceType}” do typu „{destType}”',
        typeNotClass: 'Typ „{type}” nie jest klasą',
        typeNotStringLiteral: '„{type}” nie jest literałem ciągu',
        typeOfSymbol: 'Typ nazwy „{name}” jest to „{type}”',
        typeParamSpec: 'Typ „{type}” jest niezgodny ze specyfikacją ParamSpec „{name}”',
        typeUnsupported: 'Typ „{type}” nie jest obsługiwany',
        typeVarDefaultOutOfScope: 'Zmienna typu „{name}” nie wchodzi w zakres',
        typeVarIsContravariant: 'Parametr typu „{name}” jest kontrawariantny, ale „{sourceType}” nie jest nadtypem „{destType}”',
        typeVarIsCovariant: 'Parametr typu „{name}” jest kowariantny, ale „{sourceType}” nie jest podtypem „{destType}”',
        typeVarIsInvariant: 'Parametr typu „{name}” jest niezmienny, ale „{sourceType}” nie jest taki sam jak „{destType}”',
        typeVarNotAllowed: 'Typ TypeVar nie jest dozwolony dla sprawdzania wystąpienia lub klasy',
        typeVarTupleRequiresKnownLength: 'Nie można powiązać parametru TypeVarTuple ze tuple o nieznanej długości',
        typeVarUnnecessarySuggestion: 'Zamiast tego użyj elementu {type}',
        typeVarUnsolvableRemedy: 'Podaj przeciążenie, które określa zwracany typ, gdy nie podano argumentu',
        typeVarsMissing: 'Brak zmiennych typu: {names}',
        typedDictBaseClass: 'Klasa „{type}” nie jest typem TypedDict',
        typedDictClassNotAllowed: 'Klasa TypedDict nie jest dozwolona na potrzeby sprawdzania wystąpienia lub klasy',
        typedDictClosedExtraNotAllowed: 'Nie można dodać elementu "{name}"',
        typedDictClosedExtraTypeMismatch: 'Nie można dodać elementu "{name}" z typem „{type}”',
        typedDictClosedFieldNotRequired: 'Nie można dodać elementu "{name}", ponieważ musi on mieć wartość NotRequired',
        typedDictExtraFieldNotAllowed: 'Element „{name}” nie jest obecny w typie „{type}”',
        typedDictExtraFieldTypeMismatch: 'Typ „{name}” jest niezgodny z typem „extra_items” w typie „{type}”',
        typedDictFieldMissing: 'Brak nazwy „{name}” w „{type}”',
        typedDictFieldNotReadOnly: 'Nazwa „{name}” nie jest tylko do odczytu w „{type}”',
        typedDictFieldNotRequired: 'Nazwa „{name}” nie jest wymagana w typie „{type}”',
        typedDictFieldRequired: 'Nazwa „{name}” jest wymagana w typie „{type}”',
        typedDictFieldTypeMismatch: 'Nie można przypisać typu „{type}” do elementu „{name}”',
        typedDictFieldUndefined: 'Nazwa „{name}” jest niezdefiniowanym elementem w typie „{type}”',
        typedDictFinalMismatch: 'Typ „{sourceType}” jest niezgodny z typem „{destType}” z powodu niezgodności @final',
        typedDictKeyAccess: 'Użyj elementu ["{name}"], aby odwołać się do elementu w TypedDict',
        typedDictNotAllowed: 'Funkcja TypedDict nie może być używana do sprawdzania wystąpień lub klas',
        unhashableType: 'Typ „{type}” nie jest wartością skrótu',
        uninitializedAbstractVariable: 'zmienna wystąpienia „{name}” jest zdefiniowana w abstrakcyjnej klasie bazowej „{classType}” ale nie została zainicjowana',
        unreachableExcept: 'Typ „{exceptionType}” jest podklasą typu „{parentType}”',
        useDictInstead: 'Użyj funkcji Dict[T1, T2], aby wskazać typ słownika',
        useListInstead: 'Use List[T] to indicate a list type or Union[T1, T2] to indicate a union type',
        useTupleInstead: 'Use tuple[T1, ..., Tn] to indicate a tuple type or Union[T1, T2] to indicate a union type',
        useTypeInstead: 'Zamiast tego użyj typu Type[T].',
        varianceMismatchForClass: 'Wariancja argumentu typu „{typeVarName}” jest niezgodna z klasą bazową „{className}”',
        varianceMismatchForTypeAlias: 'Wariancja argumentu typu „{typeVarName}” jest niezgodna z parametrem „{typeAliasParam}”'
      },
      Service: {
        longOperation: 'Wyliczanie plików źródłowych obszaru roboczego zajmuje dużo czasu. Zamiast tego rozważ otwarcie podfolderu. [Dowiedz się więcej](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  55169: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Criar Stub de Tipo',
        createTypeStubFor: 'Criar Stub de tipo para "{moduleName}"',
        executingCommand: 'Executando comando',
        filesToAnalyzeCount: '{count} arquivos a serem analisados',
        filesToAnalyzeOne: '1 arquivo a ser analisado',
        findingReferences: 'Localizando referências',
        organizeImports: 'Organizar as importações',
        renameShadowedFile: 'Renomear "{oldFile}" para "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Importação automática',
        indexValueDetail: 'Valor do índice'
      },
      Diagnostic: {
        abstractMethodInvocation: 'O método "{method}" não pode ser chamado porque é abstrato e não está implementado',
        annotatedMetadataInconsistent: 'O tipo de metadados anotados "{metadataType}" não é compatível com o tipo "{type}"',
        annotatedParamCountMismatch: 'Incompatibilidade de contagem de anotações de parâmetro: esperado {expected}, mas recebido {received}',
        annotatedTypeArgMissing: 'Esperava-se um argumento de tipo e uma ou mais anotações para "Annotated"',
        annotationBytesString: 'Expressões de tipo não podem usar literais de cadeia de caracteres de bytes',
        annotationFormatString: 'As expressões de tipo não podem usar literais de cadeia de caracteres de formato (cadeias de caracteres f)',
        annotationNotSupported: 'Anotação de tipo sem suporte para esta instrução',
        annotationRawString: 'Expressões de tipo não podem usar literais de cadeia de caracteres brutas',
        annotationSpansStrings: 'Expressões de tipo não podem abranger vários literais de cadeia de caracteres',
        annotationStringEscape: 'Expressões de tipo não podem conter caracteres de escape',
        argAssignment: 'O argumento do tipo "{argType}" não pode ser atribuído ao parâmetro do tipo "{paramType}"',
        argAssignmentFunction: 'O argumento do tipo "{argType}" não pode ser atribuído ao parâmetro do tipo "{paramType}" na função "{functionName}"',
        argAssignmentParam: 'O argumento do tipo "{argType}" não pode ser atribuído ao parâmetro "{paramName}" do tipo "{paramType}"',
        argAssignmentParamFunction: 'O argumento do tipo "{argType}" não pode ser atribuído ao parâmetro "{paramName}" do tipo "{paramType}" na função "{functionName}"',
        argMissingForParam: 'Argumento ausente para o parâmetro {name}',
        argMissingForParams: 'Argumentos ausentes para os parâmetros {names}',
        argMorePositionalExpectedCount: 'Esperavam-se mais {expected} argumentos posicionais',
        argMorePositionalExpectedOne: 'Espera-se mais um argumento posicional',
        argPositional: 'Argumento posicional esperado',
        argPositionalExpectedCount: '{expected} argumentos posicionais esperados',
        argPositionalExpectedOne: 'Argumento posicional esperado 1',
        argTypePartiallyUnknown: 'O tipo de argumento é parcialmente desconhecido',
        argTypeUnknown: 'O tipo de argumento é desconhecido',
        assertAlwaysTrue: 'A expressão assert sempre é avaliada como true',
        assertTypeArgs: '"assert_type" espera dois argumentos posicionais',
        assertTypeTypeMismatch: 'Incompatibilidade "assert_type": esperava-se "{expected}", mas recebeu "{received}"',
        assignmentExprComprehension: 'O destino da expressão de atribuição "{name}" não pode usar o mesmo nome da compreensão para o destino',
        assignmentExprContext: 'A expressão de atribuição deve estar dentro de módulo, função ou lambda',
        assignmentExprInSubscript: 'Expressões de atribuição em um subscrito são compatíveis apenas no Python 3.10 e mais recente',
        assignmentInProtocol: 'As variáveis de instância ou classe dentro de uma classe Protocol devem ser declaradas explicitamente dentro do corpo da classe',
        assignmentTargetExpr: 'A expressão não pode ser o destino de atribuição',
        asyncNotInAsyncFunction: 'Uso de "async" não permitido fora da função async',
        awaitIllegal: 'O uso de "await" requer o Python 3.5 ou mais recente',
        awaitNotAllowed: 'Expressões de tipo não podem usar "await"',
        awaitNotInAsync: '"await" permitido somente dentro da função async',
        backticksIllegal: 'Não há suporte para expressões delimitadas por backticks no Python 3.x. Use repr em vez disso',
        baseClassCircular: 'A classe não pode derivar de si mesma',
        baseClassFinal: 'A classe base "{type}" está marcada como final e não pode ser subclasse',
        baseClassIncompatible: 'Classes base de {type} são mutuamente incompatíveis',
        baseClassInvalid: 'O argumento para a classe deve ser uma classe base',
        baseClassMethodTypeIncompatible: 'Classes base para a classe "{classType}" definem o método "{name}" de maneira incompatível',
        baseClassUnknown: 'O tipo de classe base é desconhecido, ocultando o tipo de classe derivada',
        baseClassVariableTypeIncompatible: 'Classes base para a classe "{classType}" definem a variável "{name}" de maneira incompatível',
        binaryOperationNotAllowed: 'Operador binário não permitido na expressão de tipo',
        bindTypeMismatch: 'Não foi possível associar o método "{methodName}" porque "{type}" não é atribuível ao parâmetro "{paramName}"',
        breakInExceptionGroup: '"break" não é permitido em um bloco "except*"',
        breakOutsideLoop: '"break" só pode ser usado dentro de um loop',
        callableExtraArgs: 'Esperava-se apenas dois argumentos de tipo para "Callable"',
        callableFirstArg: 'Lista de tipos de parâmetro esperado ou "..."',
        callableNotInstantiable: 'Não é possível criar uma instância do tipo "{type}"',
        callableSecondArg: 'Tipo de retorno esperado como segundo argumento de tipo para "Callable"',
        casePatternIsIrrefutable: 'O padrão irrefutável é permitido somente para a última instrução case',
        classAlreadySpecialized: 'O tipo "{type}" já é especializado',
        classDecoratorTypeUnknown: 'Um decorador de classe sem tipo obscurece o tipo de classe. Ignorando o decorador',
        classDefinitionCycle: 'A definição de classe para "{name}" depende de si mesma',
        classGetItemClsParam: 'A substituição__class_getitem__ deve usar um parâmetro "cls"',
        classMethodClsParam: 'Os métodos de classe devem usar um parâmetro "cls"',
        classNotRuntimeSubscriptable: 'O subscrito para a classe "{name}" gerará uma exceção de runtime. Coloque a expressão de tipo entre aspas',
        classPatternBuiltInArgPositional: 'O padrão de classe aceita apenas sub-padrão posicional',
        classPatternPositionalArgCount: 'Muitos padrões posicionais para a classe "{type}"; esperado {expected} mas recebido {received}',
        classPatternTypeAlias: '"{type}" não pode ser usado em um padrão de classe porque é um alias de tipo especializado',
        classPropertyDeprecated: 'As propriedades de classe foram preteridas no Python 3.11 e não terão suporte no Python 3.13',
        classTypeParametersIllegal: 'A sintaxe do parâmetro de tipo de classe requer o Python 3.12 ou mais recente',
        classVarFirstArgMissing: 'Um argumento de tipo era esperado após "ClassVar"',
        classVarNotAllowed: '"ClassVar" não é permitido neste contexto',
        classVarOverridesInstanceVar: 'A variável de classe "{name}" substitui a variável de instância do mesmo nome na classe "{className}"',
        classVarTooManyArgs: 'Espera-se apenas um argumento de tipo após "ClassVar"',
        classVarWithTypeVar: 'O tipo "ClassVar" não pode incluir variáveis de tipo',
        clsSelfParamTypeMismatch: 'O tipo de parâmetro "{name}" deve ser um supertipo de sua classe "{classType}"',
        codeTooComplexToAnalyze: 'O código é muito complexo para ser analisado. Reduza a complexidade refatorando em sub-rotinas ou reduzindo caminhos de código condicionais',
        collectionAliasInstantiation: 'O tipo "{type}" não pode ser instanciado, use "{alias}" em vez disso',
        comparisonAlwaysFalse: 'A condição sempre será avaliada como False, pois os tipos "{leftType}" e "{rightType}" não têm sobreposição',
        comparisonAlwaysTrue: 'A condição sempre será avaliada como True, pois os tipos "{leftType}" e "{rightType}" não têm sobreposição',
        comprehensionInDict: 'A compreensão não pode ser usada com outras entradas de dicionário',
        comprehensionInSet: 'A compreensão não pode ser usada com outras entradas de set',
        concatenateContext: '"Concatenate" não é permitido nesse contexto',
        concatenateParamSpecMissing: 'O último tipo de argumento para "Concatenate" deve ser um ParamSpec ou "..."',
        concatenateTypeArgsMissing: '"Concatenate" requer pelo menos dois argumentos de tipo',
        conditionalOperandInvalid: 'Operando condicional inválido do tipo "{type}"',
        constantRedefinition: '"{name}" é constante (porque está em maiúsculas) e não pode ser redefinido',
        constructorParametersMismatch: 'Incompatibilidade entre a assinatura de __new__ e __init__ na classe "{classType}"',
        containmentAlwaysFalse: 'A expressão sempre será avaliada como False, pois os tipos "{leftType}" e "{rightType}" não têm sobreposição',
        containmentAlwaysTrue: 'A expressão sempre será avaliada como True, pois os tipos "{leftType}" e "{rightType}" não têm sobreposição',
        continueInExceptionGroup: '"continue" não é permitido em um bloco "except*"',
        continueOutsideLoop: '"continue" só pode ser usado dentro de um loop',
        coroutineInConditionalExpression: 'A expressão condicional faz referência à corrotina, que sempre é avaliada como True',
        dataClassBaseClassFrozen: 'Uma classe não congelada não pode herdar de uma classe congelada',
        dataClassBaseClassNotFrozen: 'Uma classe congelada não pode herdar de uma classe que não está congelada',
        dataClassConverterFunction: 'O argumento do tipo "{argType}" não é um conversor válido para o campo "{fieldName}" do tipo "{fieldType}"',
        dataClassConverterOverloads: 'Nenhuma sobrecarga de "{funcName}" são conversores válidos para o campo "{fieldName}" do tipo "{fieldType}"',
        dataClassFieldInheritedDefault: '"{fieldName}" substitui um campo com o mesmo nome, mas não possui um valor padrão',
        dataClassFieldWithDefault: 'Campos sem valores padrão não podem aparecer após campos com valores padrão',
        dataClassFieldWithPrivateName: 'O campo Dataclass não pode usar o nome privado',
        dataClassFieldWithoutAnnotation: 'O campo Dataclass sem anotação de tipo causará uma exceção de runtime',
        dataClassPostInitParamCount: 'Contagem de parâmetros de dataclasse __post_init__ incorreta. O número de campos InitVar é {expected}',
        dataClassPostInitType: 'Incompatibilidade de tipo de parâmetro de método de dataclasse __post_init__ para o campo "{fieldName}"',
        dataClassSlotsOverwrite: '__slots__ já está definido na classe',
        dataClassTransformExpectedBoolLiteral: 'Expressão esperada que é avaliada estaticamente como True ou False',
        dataClassTransformFieldSpecifier: 'Esperava-se tuple de classes ou funções, mas recebeu o tipo "{type}"',
        dataClassTransformPositionalParam: 'Todos os argumentos para "dataclass_transform" devem ser argumentos de palavra-chave',
        dataClassTransformUnknownArgument: 'O argumento "{name}" dataclass_transform não é compatível',
        dataProtocolInSubclassCheck: 'Protocolos de dados (que incluem atributos que não são de método) não são permitidos em chamadas issubclass',
        declaredReturnTypePartiallyUnknown: 'O tipo de retorno declarado, "{returnType}", é parcialmente desconhecido',
        declaredReturnTypeUnknown: 'O tipo de retorno declarado é desconhecido',
        defaultValueContainsCall: 'Chamadas de função e objetos mutáveis não permitidos na expressão de valor padrão do parâmetro',
        defaultValueNotAllowed: 'O parâmetro com "*" ou "**" não pode ter valor padrão',
        delTargetExpr: 'A expressão não pode ser excluída',
        deprecatedClass: 'A classe "{name}" foi preterida',
        deprecatedConstructor: 'O construtor da classe "{name}" foi preterido',
        deprecatedDescriptorDeleter: 'O método "__delete__" para o descritor "{name}" está preterido',
        deprecatedDescriptorGetter: 'O método "__get__" para o descritor "{name}" está preterido',
        deprecatedDescriptorSetter: 'O método "__set__" para o descritor "{name}" está preterido',
        deprecatedFunction: 'A função "{name}" está obsoleta',
        deprecatedMethod: 'O método "{name}" na classe "{className}" está obsoleto',
        deprecatedPropertyDeleter: 'O deleter da property "{name}" foi preterido',
        deprecatedPropertyGetter: 'O getter da property "{name}" foi preterido',
        deprecatedPropertySetter: 'O setter da property "{name}" está preterido',
        deprecatedType: 'Este tipo foi preterido no Python {version}. Use "{replacement}" em vez disso',
        dictExpandIllegalInComprehension: 'Expansão de dicionário não permitida na compreensão',
        dictInAnnotation: 'Expressão de dicionário não permitida na expressão de tipo',
        dictKeyValuePairs: 'Entradas de dicionário devem conter pares chave/valor',
        dictUnpackIsNotMapping: 'Mapeamento esperado para o operador de desempacotamento de dicionário',
        dunderAllSymbolNotPresent: '"{name}" está especificado no __all__ mas não está presente no módulo',
        duplicateArgsParam: 'Somente um parâmetro "*" permitido',
        duplicateBaseClass: 'Classe base duplicada não permitida',
        duplicateCapturePatternTarget: 'O destino de captura "{name}" não pode aparecer mais de uma vez dentro do mesmo padrão',
        duplicateCatchAll: 'Somente uma cláusula de except catch-all é permitida',
        duplicateEnumMember: 'O membro de Enum "{name}" já está declarado',
        duplicateGenericAndProtocolBase: 'Somente uma classe base Generic[...] ou Protocol[...] é permitida',
        duplicateImport: '"{importName}" foi importado mais de uma vez',
        duplicateKeywordOnly: 'Somente um separador "*" permitido',
        duplicateKwargsParam: 'Somente um parâmetro "**" é permitido',
        duplicateParam: 'Nome de parâmetro "{name}" duplicado',
        duplicatePositionOnly: 'Somente um parâmetro "/" permitido',
        duplicateStarPattern: 'Somente um padrão "*" permitido em uma sequência de padrões',
        duplicateStarStarPattern: 'Somente uma entrada "**" é permitida',
        duplicateUnpack: 'Somente uma operação unpack é permitida na lista',
        ellipsisAfterUnpacked: '"..." não pode ser usado com um TypeVarTuple ou tuple descompactado',
        ellipsisContext: '"..." não é permitido neste contexto',
        ellipsisSecondArg: '"..." é permitido apenas como o segundo de dois argumentos',
        enumClassOverride: 'A classe Enum "{name}" é final e não pode ser subclasse',
        enumMemberDelete: 'O membro Enum "{name}" não pode ser excluído',
        enumMemberSet: 'O membro Enum "{name}" não pode ser atribuído',
        enumMemberTypeAnnotation: 'Anotações de tipo não são permitidas para membros de enumeração',
        exceptGroupMismatch: 'A instrução Try não pode incluir "except" e "except*"',
        exceptGroupRequiresType: 'A sintaxe do grupo de exceção ("except*") requer um tipo de exceção',
        exceptionGroupIncompatible: 'A sintaxe do grupo de exceção ("except*") requer o Python 3.11 ou mais recente',
        exceptionGroupTypeIncorrect: 'O tipo de exceção em except* não pode derivar de BaseGroupException',
        exceptionTypeIncorrect: '"{type}" não deriva de BaseException',
        exceptionTypeNotClass: '"{type}" não é uma classe de exceção válida',
        exceptionTypeNotInstantiable: 'O construtor para o tipo de exceção "{type}" requer um ou mais argumentos',
        expectedAfterDecorator: 'Função ou declaração de classe esperada após o decorador',
        expectedArrow: 'Esperava-se "->" seguido pela anotação de tipo de retorno',
        expectedAsAfterException: 'Espera-se "as" após o tipo de exceção',
        expectedAssignRightHandExpr: 'Expressão esperada à direita de "="',
        expectedBinaryRightHandExpr: 'Expressão esperada à direita do operador',
        expectedBoolLiteral: 'Espera-se True ou False',
        expectedCase: 'Instrução "case" esperada',
        expectedClassName: 'Nome de classe esperado',
        expectedCloseBrace: '"{" não foi fechado',
        expectedCloseBracket: '"[" não foi fechado',
        expectedCloseParen: '"(" não foi fechado',
        expectedColon: 'Esperava-se ":"',
        expectedComplexNumberLiteral: 'Literal de número complexo esperado para correspondência de padrões',
        expectedDecoratorExpr: 'Formulário de expressão sem suporte para decorador antes do Python 3.9',
        expectedDecoratorName: 'Nome do decorador esperado',
        expectedDecoratorNewline: 'Nova linha esperada no final do decorador',
        expectedDelExpr: 'Expressão esperada após "del"',
        expectedElse: 'Esperava-se #else',
        expectedEquals: 'Esperava-se "="',
        expectedExceptionClass: 'Classe ou objeto de exceção inválido',
        expectedExceptionObj: 'Objeto de exceção esperado: classe de exceção ou None',
        expectedExpr: 'Expressão esperada',
        expectedFunctionAfterAsync: 'Definição de função esperada após "async"',
        expectedFunctionName: 'Nome da função esperado após "def"',
        expectedIdentifier: 'Identificador esperado',
        expectedImport: '"importação" esperada',
        expectedImportAlias: 'Símbolo esperado após "as"',
        expectedImportSymbols: 'Esperado um ou mais nomes de símbolos após “importar”',
        expectedIn: 'Esperava-se "in"',
        expectedInExpr: 'Expressão esperada após "in"',
        expectedIndentedBlock: 'Bloco recuado esperado',
        expectedMemberName: 'Nome de atributo esperado após "."',
        expectedModuleName: 'Nome do módulo esperado',
        expectedNameAfterAs: 'Nome de símbolo esperado após "as"',
        expectedNamedParameter: 'O parâmetro de palavra-chave deve seguir "*"',
        expectedNewline: 'Nova linha esperada',
        expectedNewlineOrSemicolon: 'As instruções devem ser separadas por novas linhas ou ponto e vírgula',
        expectedOpenParen: 'Esperava-se "("',
        expectedParamName: 'Nome do parâmetro esperado',
        expectedPatternExpr: 'Expressão padrão esperada',
        expectedPatternSubjectExpr: 'Expressão de assunto padrão esperada',
        expectedPatternValue: 'Expressão de valor padrão esperada da forma "a.b"',
        expectedReturnExpr: 'Expressão esperada após "return" ',
        expectedSliceIndex: 'Expressão de índice ou fatia esperada',
        expectedTypeNotString: 'Tipo esperado, mas recebeu um literal de cadeia de caracteres',
        expectedTypeParameterName: 'Nome do parâmetro de tipo esperado',
        expectedYieldExpr: 'Expressão esperada na instrução yield',
        finalClassIsAbstract: 'A classe "{type}" está marcada como final e deve implementar todos os símbolos abstratos',
        finalContext: '"Final" não é permitido neste contexto',
        finalInLoop: 'Uma variável "Final" não pode ser atribuída em um loop',
        finalMethodOverride: 'O método "{name}" não pode substituir o método final definido na classe "{className}"',
        finalNonMethod: 'A função "{name}" não pode ser marcada como @final porque não é um método',
        finalReassigned: '"{name}" está declarado como Final e não pode ser reatribuído',
        finalRedeclaration: '"{name}" foi declarado anteriormente como Final',
        finalRedeclarationBySubclass: '"{name}" não pode ser redeclarado porque a classe pai "{className}" a declara como Final',
        finalTooManyArgs: 'Argumento de tipo único esperado após "Final"',
        finalUnassigned: '"{name}" está declarado como Final, mas o valor não foi atribuído',
        formatStringBrace: 'Chave de fechamento única não permitida no literal de cadeia de caracteres f. Usar chave de fechamento dupla',
        formatStringBytes: 'Literais de cadeia de caracteres de formato (cadeia de caracteres f) não podem ser binárias',
        formatStringDebuggingIllegal: 'O especificador de depuração de cadeia de caracteres f "=" requer o Python 3.8 ou mais recente',
        formatStringEscape: 'Sequência de escape (barra invertida) não permitida na parte de expressão da cadeia de caracteres f em versões anteriores ao Python 3.12',
        formatStringExpectedConversion: 'Esperava-se um especificador de conversão após "!" na cadeia de caracteres f',
        formatStringIllegal: 'Literais de cadeia de caracteres de formato (cadeias de caracteres f) exigem Python 3.6 ou mais recente',
        formatStringInPattern: 'Cadeia de caracteres de formato não permitida no padrão',
        formatStringNestedFormatSpecifier: 'Expressões aninhadas muito profundamente dentro do especificador de cadeia de caracteres de formato',
        formatStringNestedQuote: 'Cadeias de caracteres aninhadas em uma cadeia de caracteres f não podem usar o mesmo caractere de aspas que a cadeia de caracteres f antes do Python 3.12',
        formatStringUnicode: 'As literais de cadeia de caracteres de formato (f-strings) não podem ser unicode',
        formatStringUnterminated: 'Expressão não finalizada na cadeia de caracteres f. "}" era esperado',
        functionDecoratorTypeUnknown: 'Um decorador de função sem tipo obscurece o tipo de função. Ignorando o decorador',
        functionInConditionalExpression: 'Função de referências de expressão condicional que sempre é avaliada como True',
        functionTypeParametersIllegal: 'A sintaxe do parâmetro de tipo de função requer o Python 3.12 ou mais recente',
        futureImportLocationNotAllowed: 'As importações __future__ devem estar no início do arquivo',
        generatorAsyncReturnType: 'O tipo de retorno da função geradora async deve ser compatível com "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: 'As expressões de gerador devem estar entre parênteses se não forem argumentos exclusivos',
        generatorSyncReturnType: 'O tipo de retorno da função de gerador deve ser compatível com "Generator[{yieldType}, Any, Any]"',
        genericBaseClassNotAllowed: 'A classe base "Generic" não pode ser usada com sintaxe de parâmetro de tipo',
        genericClassAssigned: 'O tipo de classe genérica não pode ser atribuído',
        genericClassDeleted: 'O tipo de classe genérica não pode ser excluído',
        genericInstanceVariableAccess: 'O acesso à variável de instância genérica por meio da classe é ambíguo',
        genericNotAllowed: '"Generic" não é válido neste contexto',
        genericTypeAliasBoundTypeVar: 'O alias de tipo genérico dentro da classe não pode usar variáveis de tipo associado {names}',
        genericTypeArgMissing: '"Generic" requer pelo menos um argumento de tipo',
        genericTypeArgTypeVar: 'O argumento de tipo para "Generic" deve ser uma variável de tipo',
        genericTypeArgUnique: 'Os argumentos de tipo para "Generic" devem ser exclusivos',
        globalReassignment: '"{name}" é atribuído antes da declaração global',
        globalRedefinition: '"{name}" já foi declarado global',
        implicitStringConcat: 'Concatenação de cadeia de caracteres implícita não permitida',
        importCycleDetected: 'Ciclo detectado na cadeia de importação',
        importDepthExceeded: 'A profundidade da cadeia de importação excedeu {depth}',
        importResolveFailure: 'Não foi possível resolver a importação "{importName}"',
        importSourceResolveFailure: 'Não foi possível resolver a importação "{importName}" da origem',
        importSymbolUnknown: '"{name}" é um símbolo de importação desconhecido',
        incompatibleMethodOverride: 'O método "{name}" substitui a classe "{className}" de maneira incompatível',
        inconsistentIndent: 'O valor de recuo não corresponde ao recuo anterior',
        inconsistentTabs: 'Uso inconsistente de guias e espaços no recuo',
        initMethodSelfParamTypeVar: 'A anotação de tipo para o parâmetro "self" do método "__init__" não pode conter variáveis ​​de tipo com escopo de classe',
        initMustReturnNone: 'O tipo de retorno de "__init__" deve ser None',
        initSubclassCallFailed: 'Argumentos de palavra-chave incorretos para o método __init_subclass__',
        initSubclassClsParam: 'A substituição __init_subclass__ deve usar um parâmetro "cls"',
        initVarNotAllowed: '"InitVar" não é permitido neste contexto',
        instanceMethodSelfParam: 'Os métodos de instância devem usar um parâmetro "self"',
        instanceVarOverridesClassVar: 'A variável de instância "{name}" substitui a variável de classe de mesmo nome na classe "{className}"',
        instantiateAbstract: 'Não é possível instanciar a classe abstrata "{type}"',
        instantiateProtocol: 'Não é possível instanciar a classe Protocol "{type}"',
        internalBindError: 'Erro interno ao associar o arquivo de associação "{file}": {message}',
        internalParseError: 'Ocorreu um erro interno ao analisar o arquivo "{file}": {message}',
        internalTypeCheckingError: 'Erro interno ao digitar o arquivo de verificação "{file}": {message}',
        invalidIdentifierChar: 'Caractere inválido no identificador',
        invalidStubStatement: 'A instrução não faz sentido dentro de um arquivo stub de tipo',
        invalidTokenChars: 'Caractere inválido "{text}" no token',
        isInstanceInvalidType: 'O segundo argumento para "isinstance" deve ser uma classe ou tuple de classes',
        isSubclassInvalidType: 'O segundo argumento para "issubclass" deve ser uma classe ou tuple de classes',
        keyValueInSet: 'Pares chave/valor não são permitidos em um set',
        keywordArgInTypeArgument: 'Argumentos de palavra-chave não podem ser usados em listas de argumentos de tipo',
        keywordArgShortcutIllegal: 'O atalho do argumento de palavra-chave requer Python 3.14 ou mais recente',
        keywordOnlyAfterArgs: 'Separador de argumento somente palavra-chave não permitido após o parâmetro "*"',
        keywordParameterMissing: 'Um ou mais parâmetros de palavra-chave devem seguir o parâmetro "*"',
        keywordSubscriptIllegal: 'Não há suporte para argumentos de palavra-chave em subscritos',
        lambdaReturnTypePartiallyUnknown: 'O tipo de retorno de lambda, "{returnType}", é parcialmente desconhecido',
        lambdaReturnTypeUnknown: 'O tipo de retorno de lambda é desconhecido',
        listAssignmentMismatch: 'A expressão com o tipo "{type}" não pode ser atribuída à lista de destino',
        listInAnnotation: 'Expressão de List não permitida na expressão de tipo',
        literalEmptyArgs: 'Um ou mais argumentos de tipo esperados após "Literal"',
        literalNamedUnicodeEscape: 'Não há suporte para sequências de escape unicode nomeadas em anotações de cadeia de caracteres "Literal"',
        literalNotAllowed: '"Literal" não pode ser usado nesse contexto sem um argumento de tipo',
        literalNotCallable: 'O tipo Literal não pode ser instanciado',
        literalUnsupportedType: 'Os argumentos de tipo para "Literal" devem ser None, um valor literal (int, bool, str ou bytes) ou um valor de enumeração',
        matchIncompatible: 'As match de correspondência exigem Python 3.10 ou mais recente',
        matchIsNotExhaustive: 'Os casos dentro da instrução match não lidam exaustivamente com todos os valores',
        maxParseDepthExceeded: 'Profundidade máxima de análise excedida. Divida a expressão em subexpressões menores',
        memberAccess: 'Não é possível acessar o atributo "{name}" para a classe "{type}"',
        memberDelete: 'Não é possível excluir o atributo "{name}" para a classe "{type}"',
        memberSet: 'Não é possível atribuir o atributo "{name}" para a classe "{type}"',
        metaclassConflict: 'A metaclasse de uma classe derivada deve ser uma subclasse das metaclasses de todas as suas classes base',
        metaclassDuplicate: 'Apenas uma metaclasse pode ser fornecida',
        metaclassIsGeneric: 'A metaclasse não pode ser genérica',
        methodNotDefined: 'Método "{name}" não definido',
        methodNotDefinedOnType: 'Método "{name}" não definido no tipo "{type}"',
        methodOrdering: 'Não é possível criar ordenação de método consistente',
        methodOverridden: '"{name}" substitui o método de mesmo nome na classe "{className}" pelo tipo incompatível "{type}"',
        methodReturnsNonObject: 'O método "{name}" não retorna um objeto',
        missingSuperCall: 'O método "{methodName}" não chama o método do mesmo nome na classe pai',
        mixingBytesAndStr: 'Valores de bytes e str não podem ser concatenados',
        moduleAsType: 'O módulo não pode ser usado como um tipo.',
        moduleNotCallable: 'O módulo não pode ser chamado',
        moduleUnknownMember: '"{memberName}" não é um atributo conhecido do módulo "{moduleName}"',
        namedExceptAfterCatchAll: 'Uma cláusula except nomeada não pode aparecer após a cláusula catch-all except',
        namedParamAfterParamSpecArgs: 'O parâmetro de palavra-chave "{name}" não pode aparecer na assinatura após o parâmetro args ParamSpec',
        namedTupleEmptyName: 'Nomes dentro de uma tuple nomeada não podem ficar vazios',
        namedTupleEntryRedeclared: 'Não é possível substituir "{name}" porque a classe pai "{className}" é uma tuple nomeada',
        namedTupleFirstArg: 'Nome de classe de tuple nomeado esperado como primeiro argumento',
        namedTupleMultipleInheritance: 'Não há suporte para herança múltipla com NamedTuple',
        namedTupleNameKeyword: 'Os nomes dos campos não podem ser uma palavra-chave',
        namedTupleNameType: 'Expected two-entry tuple specifying entry name and type',
        namedTupleNameUnique: 'Os nomes dentro de uma tuple nomeada devem ser exclusivos',
        namedTupleNoTypes: '"namedtuple" não fornece tipos para entradas de tupla. Em vez disso, use "NamedTuple"',
        namedTupleSecondArg: 'Expected named tuple entry list as second argument',
        newClsParam: 'A substituição __new__ deve usar um parâmetro "cls"',
        newTypeAnyOrUnknown: 'O segundo argumento para NewType deve ser uma classe conhecida, não Any ou Unknown',
        newTypeBadName: 'O primeiro argumento para NewType deve ser um literal de cadeia de caracteres',
        newTypeLiteral: 'NewType não pode ser usado com o tipo Literal',
        newTypeNameMismatch: 'NewType deve ser atribuído a uma variável com o mesmo nome',
        newTypeNotAClass: 'Classe esperada como segundo argumento para NewType',
        newTypeParamCount: 'NewType requer dois argumentos posicionais',
        newTypeProtocolClass: 'NewType não pode ser usado com um tipo estrutural (uma classe Protocol ou TypedDict)',
        noOverload: 'Nenhuma sobrecarga para "{name}" corresponde aos argumentos fornecidos',
        noReturnContainsReturn: 'A função com o tipo de return declarado "NoReturn" não pode incluir uma instrução return',
        noReturnContainsYield: 'A função com o tipo de retorno declarado "NoReturn" não pode incluir uma instrução yield',
        noReturnReturnsNone: 'Função com tipo de retorno declarado "NoReturn" não pode retornar "None"',
        nonDefaultAfterDefault: 'O argumento não padrão segue o argumento padrão',
        nonLocalInModule: 'Declaração nonlocal não permitida no nível do módulo',
        nonLocalNoBinding: 'Nenhuma associação para "{name}" nonlocal encontrada',
        nonLocalReassignment: '"{name}" é atribuído antes da declaração nonlocal',
        nonLocalRedefinition: '"{name}" já foi declarado nonlocal',
        noneNotCallable: 'O objeto do tipo "None" não pode ser chamado',
        noneNotIterable: 'O objeto do tipo "None" não pode ser usado como valor iterável',
        noneNotSubscriptable: 'O objeto do tipo "None" não é subscrito',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Operador "{operator}" incompatível com "None"',
        noneUnknownMember: '"{name}" não é um atributo conhecido de "None"',
        notRequiredArgCount: 'Argumento de tipo único esperado após "NotRequired"',
        notRequiredNotInTypedDict: '"NotRequired" não é permitido neste contexto',
        objectNotCallable: 'O objeto do tipo "{type}" não pode ser chamado',
        obscuredClassDeclaration: 'A declaração de classe "{name}" está obscurecida por uma declaração de mesmo nome',
        obscuredFunctionDeclaration: 'A declaração de função "{name}" é obscurecida por uma declaração de mesmo nome',
        obscuredMethodDeclaration: 'A declaração de método "{name}" é obscurecida por uma declaração de mesmo nome',
        obscuredParameterDeclaration: 'A declaração de parâmetro "{name}" é obscurecida por uma declaração de mesmo nome',
        obscuredTypeAliasDeclaration: 'A declaração de alias de tipo "{name}" é obscurecida por uma declaração de mesmo nome',
        obscuredVariableDeclaration: 'A declaração "{name}" é obscurecida por uma declaração de mesmo nome',
        operatorLessOrGreaterDeprecated: 'O operador "<>" não é compatível no Python 3. Use "!=" em vez disso',
        optionalExtraArgs: 'Espera-se um argumento de tipo após "Optional"',
        orPatternIrrefutable: 'Padrão irrefutável permitido somente como o último subpadrão em um padrão "or"',
        orPatternMissingName: 'Todos os subpadrões dentro de um padrão "or" devem ter como destino os mesmos nomes',
        overlappingKeywordArgs: 'O dicionário digitado se sobrepõe ao parâmetro de palavra-chave: {names}',
        overlappingOverload: 'A sobrecarga {obscured} para "{name}" nunca será usada porque seus parâmetros se sobrepõem à sobrecarga {obscuredBy}',
        overloadAbstractImplMismatch: 'As sobrecargas devem corresponder ao status abstrato da implementação',
        overloadAbstractMismatch: 'As sobrecargas devem ser abstratas ou não',
        overloadClassMethodInconsistent: 'Sobrecargas para "{name}" usam @classmethod inconsistentemente',
        overloadFinalInconsistencyImpl: 'A sobrecarga para "{name}" está marcada como @final mas a implementação não está',
        overloadFinalInconsistencyNoImpl: 'A sobrecarga {index} para "{name}" está marcada como @final mas a sobrecarga 1 não está',
        overloadImplementationMismatch: 'A implementação sobrecarregada não é consistente com a assinatura da sobrecarga {index}',
        overloadReturnTypeMismatch: 'A sobrecarga {prevIndex} para "{name}" sobrepõe a sobrecarga {newIndex} e retorna um tipo incompatível',
        overloadStaticMethodInconsistent: 'Sobrecargas para "{name}" usam @staticmethod inconsistentemente',
        overloadWithoutImplementation: '"{name}" está marcado como overload, mas nenhuma implementação foi fornecida',
        overriddenMethodNotFound: 'O método "{name}" está marcado como override, mas nenhum método base de mesmo nome está presente',
        overrideDecoratorMissing: 'O método "{name}" não está marcado como override, mas está substituindo um método na classe "{className}"',
        paramAfterKwargsParam: 'O parâmetro não pode seguir o parâmetro "**"',
        paramAlreadyAssigned: 'O parâmetro "{name}" já está atribuído',
        paramAnnotationMissing: 'A anotação de tipo está ausente para o parâmetro "{name}"',
        paramAssignmentMismatch: 'A expressão do tipo "{sourceType}" não pode ser atribuída ao parâmetro do tipo "{paramType}"',
        paramNameMissing: 'Nenhum parâmetro chamado "{name}"',
        paramSpecArgsKwargsDuplicate: 'Os argumentos para ParamSpec "{type}" já foram fornecidos',
        paramSpecArgsKwargsUsage: 'Os atributos "args" e "kwargs" de ParamSpec devem aparecer dentro de uma assinatura de função',
        paramSpecArgsMissing: 'Argumentos para ParamSpec "{type}" estão ausentes',
        paramSpecArgsUsage: 'O atributo "args" de ParamSpec é válido somente quando usado com o parâmetro *args',
        paramSpecAssignedName: 'ParamSpec deve ser atribuído a uma variável chamada "{name}"',
        paramSpecContext: 'ParamSpec não é permitido neste contexto',
        paramSpecDefaultNotTuple: 'Reticências esperadas, uma expressão de tuple ou ParamSpec para o valor padrão de ParamSpec',
        paramSpecFirstArg: 'Nome esperado de ParamSpec como primeiro argumento',
        paramSpecKwargsUsage: 'O atributo "kwargs" de ParamSpec é válido somente quando usado com o parâmetro **kwargs',
        paramSpecNotUsedByOuterScope: 'O ParamSpec "{name}" não tem significado neste contexto',
        paramSpecUnknownArg: 'ParamSpec não é compatível com mais de um argumento',
        paramSpecUnknownMember: '"{name}" não é um atributo conhecido de ParamSpec',
        paramSpecUnknownParam: '"{name}" é um parâmetro desconhecido para ParamSpec',
        paramTypeCovariant: 'Variável de tipo covariante não pode ser usada no tipo de parâmetro',
        paramTypePartiallyUnknown: 'O tipo de parâmetro "{paramName}" é parcialmente desconhecido',
        paramTypeUnknown: 'O tipo de parâmetro "{paramName}" é desconhecido',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'O padrão nunca será correspondido para o tipo de assunto "{type}"',
        positionArgAfterNamedArg: 'O argumento posicional não pode aparecer após argumentos de palavra-chave',
        positionOnlyAfterArgs: 'Separador de parâmetro somente de posição não permitido após o parâmetro "*"',
        positionOnlyAfterKeywordOnly: 'O parâmetro "/" deve aparecer antes do parâmetro "*"',
        positionOnlyAfterNon: 'Parâmetro somente de posição não permitido após o parâmetro que não é somente posição',
        positionOnlyFirstParam: 'Separador de parâmetro somente de posição não permitido como primeiro parâmetro',
        positionOnlyIncompatible: 'O separador de parâmetro somente de posição requer o Python 3.8 ou mais recente',
        privateImportFromPyTypedModule: '"{name}" não é exportado do módulo "{module}"',
        privateUsedOutsideOfClass: '"{name}" é privado e usado fora da classe na qual é declarado',
        privateUsedOutsideOfModule: '"{name}" é privado e usado fora do módulo no qual ele é declarado',
        propertyOverridden: '"{name}" override incorretamente a property de mesmo nome na classe "{className}"',
        propertyStaticMethod: 'Métodos estáticos não permitidos para as property getter, setter ou deleter',
        protectedUsedOutsideOfClass: '"{name}" está protegido e usado fora da classe na qual está declarado',
        protocolBaseClass: 'A classe "{classType}" Protocol não pode derivar da classe não Protocol "{baseType}"',
        protocolBaseClassWithTypeArgs: 'Argumentos de tipo não são permitidos com a classe Protocol ao usar a sintaxe de parâmetro de tipo',
        protocolIllegal: 'O uso de "Protocol" requer o Python 3.7 ou mais recente',
        protocolNotAllowed: '"Protocol" não pode ser usado nesse contexto',
        protocolTypeArgMustBeTypeParam: 'O argumento de tipo para o "Protocolo" deve ser um parâmetro de tipo',
        protocolUnsafeOverlap: 'A classe se sobrepõe a "{name}" de forma não segura e pode produzir uma correspondência em runtime',
        protocolVarianceContravariant: 'A variável de tipo "{variable}" usada na "{class}" Protocol genérica deve ser contravariante',
        protocolVarianceCovariant: 'A variável de tipo "{variable}" usada na "{class}" Protocol genérica deve ser covariante',
        protocolVarianceInvariant: 'A variável de tipo "{variable}" usada na "{class}" Protocol genérica deve ser invariável',
        pyrightCommentInvalidDiagnosticBoolValue: 'A diretiva de comentário Pyright deve ser seguida por "=" e um valor true ou false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'A diretiva de comentário Pyright deve ser seguida por "=" e um valor de true, false, error, warning, information ou none',
        pyrightCommentMissingDirective: 'O comentário Pyright deve ser seguido por uma diretiva (basic ou strict) ou uma regra de diagnóstico',
        pyrightCommentNotOnOwnLine: 'Comentários Pyright usados para controlar as configurações de nível de arquivo devem aparecer em sua própria linha',
        pyrightCommentUnknownDiagnosticRule: '"{rule}" é uma regra de diagnóstico desconhecida para o comentário pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" é um valor inválido para o comentário pyright. true, false, error, warning, information ou none esperados.',
        pyrightCommentUnknownDirective: '"{directive}" é uma diretiva desconhecida para o comentário pyright. Esperava-se "strict" ou "basic"',
        readOnlyArgCount: 'Argumento de tipo único esperado após "ReadOnly"',
        readOnlyNotInTypedDict: '"ReadOnly" não é permitido neste contexto',
        recursiveDefinition: 'Não foi possível determinar o tipo de "{name}" porque ele refere-se a si mesmo',
        relativeImportNotAllowed: 'Importações relativas não podem ser usadas com o formulário "import .a". Use "from . import a" em vez disso',
        requiredArgCount: 'Argumento de tipo único esperado após "Required"',
        requiredNotInTypedDict: '"Required" não é permitido neste contexto',
        returnInAsyncGenerator: 'A instrução return com valor não é permitida no gerador async',
        returnInExceptionGroup: '"return" não é permitido em um bloco "except*"',
        returnMissing: 'Função com tipo de retorno declarado "{returnType}" deve retornar valor em todos os caminhos de código',
        returnOutsideFunction: '"return" só pode ser usado dentro de uma função',
        returnTypeContravariant: 'A variável de tipo contravariante não pode ser usada no tipo de retorno',
        returnTypeMismatch: 'O tipo "{exprType}" não pode ser atribuído ao tipo "{returnType}"',
        returnTypePartiallyUnknown: 'O tipo de retorno, "{returnType}", é parcialmente desconhecido',
        returnTypeUnknown: 'O tipo de retorno é desconhecido',
        revealLocalsArgs: 'Nenhum argumento esperado para a chamada "reveal_locals"',
        revealLocalsNone: 'Nenhum locals neste escopo',
        revealTypeArgs: 'Esperava-se um único argumento posicional para a chamada "reveal_type"',
        revealTypeExpectedTextArg: 'O argumento "expected_text" para a função "reveal_type" deve ser um valor literal str',
        revealTypeExpectedTextMismatch: 'Tipo de incompatibilidade de texto. O esperado era "{expected}", mas recebeu "{received}"',
        revealTypeExpectedTypeMismatch: 'Incompatibilidade de tipo. Esperava-se "{expected}", mas recebeu "{received}"',
        selfTypeContext: '"Self" não é válido neste contexto.',
        selfTypeMetaclass: '"Self" não pode ser usado em uma metaclasse (uma subclasse de "type")',
        selfTypeWithTypedSelfOrCls: '"Self" não pode ser usado em uma função com um parâmetro `self` ou `cls que tenha uma anotação de tipo diferente de "Self"',
        setterGetterTypeMismatch: 'O tipo de valor do setter da property não é atribuível ao tipo de retorno getter',
        singleOverload: '"{name}" está marcado como sobrecarga, mas sobrecargas adicionais estão ausentes',
        slotsAttributeError: '"{name}" não está especificado em __slots__',
        slotsClassVarConflict: '"{name}" está em conflito com a variável de instância declarada __slots__',
        starPatternInAsPattern: 'O padrão de estrela não pode ser usado com o destino "as"',
        starPatternInOrPattern: 'O padrão de estrela não pode ser ORed em outros padrões',
        starStarWildcardNotAllowed: '** não pode ser usado com curinga "_"',
        staticClsSelfParam: 'Os métodos estáticos não devem usar um parâmetro "self" ou "cls"',
        stdlibModuleOverridden: '"{path}" está substituindo o módulo stdlib "{name}"',
        stringNonAsciiBytes: 'Caractere não ASCII não permitido em literal de cadeia de caracteres de bytes',
        stringNotSubscriptable: 'A expressão de cadeia de caracteres não pode ser subscrita na expressão de tipo. Coloque toda a expressão entre aspas',
        stringUnsupportedEscape: 'Sequência de escape sem suporte no literal de cadeia de caracteres',
        stringUnterminated: 'Literal de cadeia de caracteres não finalizado',
        stubFileMissing: 'Arquivo stub não encontrado para "{importName}"',
        stubUsesGetAttr: 'O arquivo stub de tipo está incompleto. "__getattr__" obscurece erros de tipo para o módulo',
        sublistParamsIncompatible: 'parâmetros de sublista não são suportados no Python 3.x',
        superCallArgCount: 'Não mais que dois argumentos eram esperados para a chamada "super"',
        superCallFirstArg: 'Tipo de classe esperado como o primeiro argumento para a chamada "super", mas recebeu "{type}"',
        superCallSecondArg: 'O segundo argumento para a chamada "super" deve ser objeto ou classe que deriva de "{type}"',
        superCallZeroArgForm: 'A forma de chamada "super" com argumento zero é válida apenas dentro de um método',
        superCallZeroArgFormStaticMethod: 'A forma de chamada "super" com argumento zero é válida apenas dentro de um método',
        symbolIsPossiblyUnbound: '"{name}" possivelmente não está associado',
        symbolIsUnbound: '"{name}" não está associado',
        symbolIsUndefined: '"{name}" não está definido',
        symbolOverridden: '"{name}" substitui o símbolo de mesmo nome na classe "{className}"',
        ternaryNotAllowed: 'Expressão de ternário não permitida na expressão de tipo',
        totalOrderingMissingMethod: 'A classe deve definir um dos "__lt__", "__le__", "__gt__" ou "__ge__" para usar total_ordering',
        trailingCommaInFromImport: 'A vírgula à direita não é permitida sem parênteses ao redor',
        tryWithoutExcept: 'A instrução Try deve ter pelo menos uma cláusula except ou finally',
        tupleAssignmentMismatch: 'A expressão com o tipo "{type}" não pode ser atribuída à tuple de destino',
        tupleInAnnotation: 'Expressão de tuple não permitida na expressão de tipo',
        tupleIndexOutOfRange: 'O índice {index} está fora do intervalo para o tipo {type}',
        typeAliasIllegalExpressionForm: 'Formulário de expressão inválido para definição de alias de tipo',
        typeAliasIsRecursiveDirect: 'O alias de tipo "{name}" não pode usar a si mesmo em sua definição',
        typeAliasNotInModuleOrClass: 'Um TypeAlias só pode ser definido dentro de um módulo ou escopo de classe',
        typeAliasRedeclared: '"{name}" é declarado como um TypeAlias e só pode ser atribuído uma vez',
        typeAliasStatementBadScope: 'Uma instrução type só pode ser usada dentro de um módulo ou escopo de classe',
        typeAliasStatementIllegal: 'A instrução de alias de tipo requer o Python 3.12 ou mais recente',
        typeAliasTypeBaseClass: 'Um alias de tipo definido em uma instrução "type" não pode ser usado como uma classe base',
        typeAliasTypeMustBeAssigned: 'TypeAliasType deve ser atribuído a uma variável com o mesmo nome que o alias de tipo',
        typeAliasTypeNameArg: 'O primeiro argumento para TypeAliasType deve ser um literal de cadeia de caracteres que representa o nome do alias de tipo',
        typeAliasTypeNameMismatch: 'O nome do alias de tipo deve corresponder ao nome da variável à qual ela está atribuída',
        typeAliasTypeParamInvalid: 'A lista de parâmetros de tipo deve ser uma tuple contendo apenas TypeVar, TypeVarTuple ou ParamSpec',
        typeAnnotationCall: 'Expressão de chamada não permitida na expressão de tipo',
        typeAnnotationVariable: 'Variável não permitida na expressão de tipo',
        typeAnnotationWithCallable: 'O argumento de tipo para "type" deve ser uma classe; não há suporte para callables',
        typeArgListExpected: 'ParamSpec, reticências ou lista de tipos esperados',
        typeArgListNotAllowed: 'Expressão de lista não permitida para este argumento de tipo',
        typeArgsExpectingNone: 'Nenhum argumento de tipo era esperado para a classe "{name}"',
        typeArgsMismatchOne: 'Esperava-se um argumento de tipo, mas recebeu {received}',
        typeArgsMissingForAlias: 'Argumentos de tipo esperados para o alias de tipo genérico "{name}"',
        typeArgsMissingForClass: 'Argumentos de tipo esperados para a classe genérica "{name}"',
        typeArgsTooFew: 'Poucos argumentos de tipo fornecidos para "{name}". Esperava-se {expected}, mas recebeu {received}',
        typeArgsTooMany: 'Muitos argumentos de tipo fornecidos para "{name}". Esperava-se {expected}, mas recebeu {received}',
        typeAssignmentMismatch: 'O tipo "{sourceType}" não pode ser atribuído ao tipo declarado "{destType}"',
        typeAssignmentMismatchWildcard: 'O símbolo de importação "{name}" tem o tipo "{sourceType}", que não pode ser atribuído ao tipo declarado "{destType}"',
        typeCallNotAllowed: 'A chamada type() não deve ser usada na expressão de tipo',
        typeCheckOnly: '"{name}" está marcado como @type_check_only e pode ser usado apenas em anotações de tipo',
        typeCommentDeprecated: 'O uso de comentários de type foi preterido. Use anotação de type em vez disso',
        typeExpectedClass: 'Classe esperada, mas a recebida foi "{type}"',
        typeFormArgs: '"TypeForm" aceita um único argumento posicional',
        typeGuardArgCount: 'Argumento de tipo único esperado após "TypeGuard" ou "TypeIs"',
        typeGuardParamCount: 'Funções e métodos de proteção de tipo definidos pelo usuário devem ter pelo menos um parâmetro de entrada',
        typeIsReturnType: 'O tipo de retorno de TypeIs ("{returnType}") não é consistente com o tipo de parâmetro de valor ("{type}")',
        typeNotAwaitable: '"{type}" não é awaitable',
        typeNotIntantiable: '"{type}" não pode ser instanciado',
        typeNotIterable: '"{type}" não é iterável',
        typeNotSpecializable: 'Não foi possível especializar o tipo "{type}"',
        typeNotSubscriptable: 'O objeto do tipo "{type}" não é subscrito',
        typeNotSupportBinaryOperator: 'Operador "{operator}" sem suporte para os tipos "{leftType}" e "{rightType}"',
        typeNotSupportBinaryOperatorBidirectional: 'O operador "{operator}" não tem suporte para os tipos "{leftType}" e "{rightType}" quando o tipo esperado é "{expectedType}"',
        typeNotSupportUnaryOperator: 'Operador "{operator}" sem suporte para o tipo "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'O operador "{operator}" não tem suporte para o tipo "{type}" quando o tipo esperado é "{expectedType}"',
        typeNotUsableWith: 'O objeto do tipo "{type}" não pode ser usado com "with" porque não implementa {method}',
        typeParameterBoundNotAllowed: 'Associação ou restrição não pode ser usada com um parâmetro de tipo variadic ou ParamSpec',
        typeParameterConstraintTuple: 'A restrição de parâmetro de tipo deve ser uma tupla de dois ou mais tipos',
        typeParameterExistingTypeParameter: 'O parâmetro de tipo "{name}" já está em uso',
        typeParameterNotDeclared: 'O parâmetro de tipo "{name}" não está incluído na lista de parâmetros de tipo para "{container}"',
        typeParametersMissing: 'Pelo menos um parâmetro de tipo deve ser especificado',
        typePartiallyUnknown: 'O tipo de "{name}" é parcialmente desconhecido',
        typeUnknown: 'O tipo de "{name}" é desconhecido',
        typeVarAssignedName: 'TypeVar deve ser atribuído a uma variável chamada "{name}"',
        typeVarAssignmentMismatch: 'O tipo "{type}" não pode ser atribuído à variável de tipo "{name}"',
        typeVarBoundAndConstrained: 'TypeVar não pode ser associado e restrito',
        typeVarBoundGeneric: 'O tipo associado TypeVar não pode ser genérico',
        typeVarConstraintGeneric: 'O tipo de restrição TypeVar não pode ser genérico',
        typeVarDefaultBoundMismatch: 'O tipo padrão TypeVar deve ser um subtipo do tipo associado',
        typeVarDefaultConstraintMismatch: 'O tipo padrão TypeVar deve ser um dos tipos restritos',
        typeVarDefaultIllegal: 'Tipos padrão de variável de tipo exigem Python 3.13 ou mais recente',
        typeVarDefaultInvalidTypeVar: 'O parâmetro de tipo "{name}" tem um tipo padrão que se refere a uma ou mais variáveis de tipo que estão fora do escopo',
        typeVarFirstArg: 'Nome esperado de TypeVar como primeiro argumento',
        typeVarInvalidForMemberVariable: 'O tipo de atributo não pode usar a variável de tipo "{name}" com escopo para o método local',
        typeVarNoMember: 'TypeVar "{type}" não tem atributo "{name}"',
        typeVarNotSubscriptable: 'Não é possível subscrever TypeVar "{type}"',
        typeVarNotUsedByOuterScope: 'A variável de tipo "{name}" não tem significado neste contexto',
        typeVarPossiblyUnsolvable: 'A variável de tipo "{name}" pode ficar sem resolução se o chamador não fornecer nenhum argumento para o parâmetro "{param}"',
        typeVarSingleConstraint: 'TypeVar deve ter pelo menos dois tipos restritos',
        typeVarTupleConstraints: 'TypeVarTuple não pode ter restrições de valor',
        typeVarTupleContext: 'TypeVarTuple não é permitido neste contexto',
        typeVarTupleDefaultNotUnpacked: 'O tipo padrão TypeVarTuple deve ser uma tuple desempacotamento ou TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'O operador Unpack é necessário para o valor TypeVarTuple',
        typeVarTupleUnknownParam: '"{name}" é um parâmetro desconhecido para TypeVarTuple',
        typeVarUnknownParam: '"{name}" é um parâmetro desconhecido para TypeVar',
        typeVarUsedByOuterScope: 'TypeVar "{name}" já está em uso por um escopo externo',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" aparece apenas uma vez na assinatura de função genérica',
        typeVarVariance: 'TypeVar não pode ser covariante e contravariante',
        typeVarWithDefaultFollowsVariadic: 'O TypeVar "{typeVarName}" tem um valor padrão e não pode seguir TypeVarTuple "{variadicName}"',
        typeVarWithoutDefault: '"{name}" não pode aparecer após "{other}" na lista de parâmetros de tipo porque não tem nenhum tipo padrão',
        typeVarsNotInGenericOrProtocol: 'Generic[] ou Protocol[] deve incluir todas as variáveis de tipo',
        typedDictAccess: 'Não foi possível acessar o item em TypedDict',
        typedDictAssignedName: 'TypedDict deve ser atribuído a uma variável chamada "{name}"',
        typedDictBadVar: 'As classes TypedDict podem conter apenas anotações de tipo',
        typedDictBaseClass: 'Todas as classes base para classes TypedDict também devem ser classes TypedDict',
        typedDictBoolParam: 'Esperava-se que o parâmetro "{name}" tivesse um valor True ou False',
        typedDictClosedExtras: 'A classe base "{name}" é um TypedDict closed; itens extras devem ser do tipo "{type}"',
        typedDictClosedNoExtras: 'A classe base "{name}" é um TypedDict closed; itens extras não são permitidos',
        typedDictDelete: 'Não foi possível excluir o item em TypedDict',
        typedDictEmptyName: 'Os nomes dentro de um TypedDict não podem estar vazios',
        typedDictEntryName: 'Literal de cadeia de caracteres esperado para o nome da entrada do dicionário',
        typedDictEntryUnique: 'Os nomes dentro de um dicionário devem ser exclusivos',
        typedDictExtraArgs: 'Argumentos TypedDict extras são incompatíveis',
        typedDictExtraItemsClosed: 'Um TypedDict não pode ser closed se der suporte a itens extras',
        typedDictFieldNotRequiredRedefinition: 'O item TypedDict "{name}" não pode ser redefinido como NotRequired',
        typedDictFieldReadOnlyRedefinition: 'O item TypedDict "{name}" não pode ser redefinido como ReadOnly',
        typedDictFieldRequiredRedefinition: 'O item TypedDict "{name}" não pode ser redefinido como Required',
        typedDictFirstArg: 'Nome da classe TypedDict esperado como primeiro argumento',
        typedDictInClassPattern: 'A classe TypedDict não é permitida no padrão de classe',
        typedDictInitsubclassParameter: 'TypedDict não dá suporte ao parâmetro __init_subclass__ "{name}"',
        typedDictNotAllowed: '"TypedDict" não pode ser usado neste contexto',
        typedDictSecondArgDict: 'Parâmetro dict ou de palavra-chave esperado como segundo parâmetro',
        typedDictSecondArgDictEntry: 'Entrada de dicionário simples esperada',
        typedDictSet: 'Não foi possível atribuir o item em TypedDict',
        unaccessedClass: 'A classe "{name}" não foi acessada',
        unaccessedFunction: 'A função "{name}" não foi acessada',
        unaccessedImport: 'A importação "{name}" não foi acessada',
        unaccessedSymbol: '"{name}" não foi acessado',
        unaccessedVariable: 'A variável "{name}" não foi acessada',
        unannotatedFunctionSkipped: 'A análise da função "{name}" foi ignorada porque não foi anotada',
        unaryOperationNotAllowed: 'Operador unário não permitido na expressão de tipo',
        unexpectedAsyncToken: 'Esperado "def", "with" ou "for" para acompanhar "async"',
        unexpectedExprToken: 'Token inesperado no final da expressão',
        unexpectedIndent: 'Recuo inesperado',
        unexpectedUnindent: 'Recuo não esperado',
        unhashableDictKey: 'A chave do dicionário deve ser hash',
        unhashableSetEntry: 'A entrada set deve ser permitir hash',
        uninitializedAbstractVariables: 'As variáveis definidas na classe base abstrata não são inicializadas na classe final "{classType}"',
        uninitializedInstanceVariable: 'A variável de instância "{name}" não foi inicializada no corpo da classe ou no método __init__',
        unionForwardReferenceNotAllowed: 'A sintaxe de Union não pode ser usada com operando de cadeia de caracteres. Use aspas em toda a expressão',
        unionSyntaxIllegal: 'A sintaxe alternativa para uniões requer o Python 3.10 ou mais recente',
        unionTypeArgCount: 'A Union requer dois ou mais argumentos de tipo',
        unionUnpackedTuple: 'A Union não pode incluir uma tuple desempacotada',
        unionUnpackedTypeVarTuple: 'A Union não pode incluir um TypeVarTuple desempacotado',
        unnecessaryCast: 'Chamada "cast" desnecessária. O tipo já é "{type}"',
        unnecessaryIsInstanceAlways: 'Chamada de isinstance desnecessária. "{testType}" é sempre uma instância de "{classType}"',
        unnecessaryIsInstanceNever: 'Chamada de isinstance desnecessária; \'{testType}\' nunca é uma instância de \'{classType}\'',
        unnecessaryIsSubclassAlways: 'Chamada issubclass desnecessária. "{testType}" é sempre uma subclasse de "{classType}"',
        unnecessaryIsSubclassNever: 'Chamada issubclass desnecessária; \'{testType}\' nunca é uma subclasse de \'{classType}\'',
        unnecessaryPyrightIgnore: 'Comentário desnecessário "# pyright: ignore"',
        unnecessaryPyrightIgnoreRule: 'Regra desnecessária "# pyright: ignore": "{name}"',
        unnecessaryTypeIgnore: 'Comentário "# type: ignore" desnecessário',
        unpackArgCount: 'Argumento de tipo único esperado após "Unpack"',
        unpackExpectedTypeVarTuple: 'TypeVarTuple ou tuple esperado como argumento de tipo para Unpack',
        unpackExpectedTypedDict: 'Argumento de tipo TypedDict esperado para Unpack',
        unpackIllegalInComprehension: 'Operação de desempacotamento não permitida na compreensão',
        unpackInAnnotation: 'Operador de desempacotamento não permitido na expressão de tipo',
        unpackInDict: 'Operação de desempacotamento não permitida em dicionários',
        unpackInSet: 'Operador unpack não permitido em um set',
        unpackNotAllowed: 'Unpack não é permitido neste contexto',
        unpackOperatorNotAllowed: 'A operação de descompactação não é permitida neste contexto',
        unpackTuplesIllegal: 'Operação de desempacotamento não permitida em tuplas anteriores ao Python 3.8',
        unpackedArgInTypeArgument: 'Os argumentos descompactados não podem ser usados nesse contexto',
        unpackedArgWithVariadicParam: 'O argumento desempacotado não pode ser usado para o parâmetro TypeVarTuple',
        unpackedDictArgumentNotMapping: 'A expressão de argumento após ** deve ser um mapeamento com um tipo de chave "str"',
        unpackedDictSubscriptIllegal: 'O operador de desempacotamento de dicionário no subscrito não é permitido',
        unpackedSubscriptIllegal: 'O operador Unpack no subscrito requer o Python 3.11 ou mais recente',
        unpackedTypeVarTupleExpected: 'Esperava-se TypeVarTuple desempacotada. Use Unpack[{name1}] ou *{name2}',
        unpackedTypedDictArgument: 'Não é possível corresponder o argumento TypedDict desempacotado aos parâmetros',
        unreachableCode: 'O código está inacessível.',
        unreachableCodeType: 'A análise de tipo indica que o código está inacessível',
        unreachableExcept: 'A cláusula Except está inacessível porque a exceção já foi tratada',
        unsupportedDunderAllOperation: 'A operação em "__all__" não é compatível, portanto, a lista de símbolos exportada pode estar incorreta',
        unusedCallResult: 'O resultado da expressão de chamada é do tipo "{type}" e não é usado. Atribua à variável "_" se isso for intencional',
        unusedCoroutine: 'O resultado da chamada de função async não foi usado. Use "await" ou atribua o resultado à variável',
        unusedExpression: 'O valor da expressão não é usado',
        varAnnotationIllegal: 'As anotações de tipo para variáveis exigem Python 3.6 ou mais recente. Use comentário de type para compatibilidade com versões anteriores',
        variableFinalOverride: 'A variável "{name}" está marcada como Final e substitui a variável não Final de mesmo nome na classe "{className}"',
        variadicTypeArgsTooMany: 'A lista de argumentos de tipo pode ter no máximo um TypeVarTuple ou tuple descompactado',
        variadicTypeParamTooManyAlias: 'O alias de tipo pode ter no máximo um parâmetro de tipo TypeVarTuple, mas recebeu vários ({names})',
        variadicTypeParamTooManyClass: 'A classe genérica pode ter no máximo um parâmetro de tipo TypeVarTuple, mas recebeu vários ({names})',
        walrusIllegal: 'O operador ":=" requer o Python 3.8 ou mais recente',
        walrusNotAllowed: 'Operador ":=" não é permitido neste contexto sem parênteses',
        wildcardInFunction: 'Wildcard import not allowed within a class or function',
        wildcardLibraryImport: 'Wildcard import from a library not allowed',
        wildcardPatternTypePartiallyUnknown: 'O tipo capturado pelo padrão curinga é parcialmente desconhecido',
        wildcardPatternTypeUnknown: 'O tipo capturado pelo padrão curinga é desconhecido',
        yieldFromIllegal: 'O uso de "yield from" requer o Python 3.3 ou mais recente',
        yieldFromOutsideAsync: '"yield from" não é permitido em uma função async',
        yieldOutsideFunction: '"yield" não permitido fora de uma função ou lambda',
        yieldWithinComprehension: '"yield" não é permitido dentro de uma compreensão',
        zeroCaseStatementsFound: 'A instrução Match deve incluir pelo menos uma instrução case',
        zeroLengthTupleNotAllowed: 'Zero-length tuple is not allowed in this context'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'O formulário especial "Annotated" não pode ser usado com verificações de instância e classe',
        argParam: 'O argumento corresponde ao parâmetro "{paramName}"',
        argParamFunction: 'O argumento corresponde ao parâmetro "{paramName}" na função "{functionName}"',
        argsParamMissing: 'O parâmetro "*{paramName}" não tem nenhum parâmetro correspondente',
        argsPositionOnly: 'Incompatibilidade de parâmetro somente de posição; esperava-se {expected}, mas recebeu {received}',
        argumentType: 'O tipo de argumento é "{type}"',
        argumentTypes: 'Tipos de argumento: ({types})',
        assignToNone: 'O tipo não pode ser atribuído a "None"',
        asyncHelp: 'Você quis dizer "async with"?',
        baseClassIncompatible: 'A classe base "{baseClass}" é incompatível com o tipo "{type}"',
        baseClassIncompatibleSubclass: 'A classe base "{baseClass}" deriva de "{subclass}" que é incompatível com o tipo "{type}"',
        baseClassOverriddenType: 'A classe base "{baseClass}" fornece o tipo "{type}", que é substituído',
        baseClassOverridesType: 'A classe base "{baseClass}" substitui pelo tipo "{type}"',
        bytesTypePromotions: 'Defina disableBytesTypePromotions como false para habilitar o comportamento de promoção de tipo para "bytearray" e "memoryview"',
        conditionalRequiresBool: 'O método __bool__ para o tipo "{operandType}" retorna o tipo "{boolReturnType}" em vez de "bool"',
        dataClassFieldLocation: 'Declaração de campo',
        dataClassFrozen: '"{name}" está congelado',
        dataProtocolUnsupported: '"{name}" é um protocolo de dados',
        descriptorAccessBindingFailed: 'Falha ao associar o método "{name}" para a classe de descritor "{className}"',
        descriptorAccessCallFailed: 'Falha ao chamar o método "{name}" para a classe de descritor "{className}"',
        finalMethod: 'Método Final',
        functionParamDefaultMissing: 'O parâmetro "{name}" não tem um argumento padrão',
        functionParamName: 'Incompatibilidade de nome de parâmetro: "{destName}" versus "{srcName}"',
        functionParamPositionOnly: 'Incompatibilidade de parâmetro somente posição; o parâmetro "{name}" não é somente posição',
        functionReturnTypeMismatch: 'O tipo de retorno de função "{sourceType}" é incompatível com o tipo "{destType}"',
        functionTooFewParams: 'A função aceita poucos parâmetros posicionais. Esperava-se {expected}, mas recebeu {received}',
        functionTooManyParams: 'A função aceita muitos parâmetros posicionais. Esperava-se {expected}, mas recebeu {received}',
        genericClassNotAllowed: 'Tipo genérico com argumentos de tipo não permitidos para verificações de instância ou de classe',
        incompatibleDeleter: 'O método de deleter de property é incompatível',
        incompatibleGetter: 'O método getter de property é incompatível',
        incompatibleSetter: 'O método setter de property é incompatível',
        initMethodLocation: 'O método __init__ é definido na classe "{type}"',
        initMethodSignature: 'A assinatura de __init__ é "{type}"',
        initSubclassLocation: 'O método __init_subclass__ é definido na classe "{name}"',
        invariantSuggestionDict: 'Considere alternar de "dict" para "Mapping", que é covariante no tipo de valor',
        invariantSuggestionList: 'Considere alternar de "list" para "Sequence", que é covariante',
        invariantSuggestionSet: 'Considere alternar de "set" para "Container", que é covariante',
        isinstanceClassNotSupported: '"{type}" não tem suporte para verificações de instância e classe',
        keyNotRequired: '"{name}" não é uma chave necessária em "{type}", portanto, o acesso pode resultar em exceção de runtime',
        keyReadOnly: '"{name}" é uma chave somente leitura em "{type}"',
        keyRequiredDeleted: '"{name}" é uma chave obrigatória e não pode ser excluída',
        keyUndefined: '"{name}" não é uma chave definida em "{type}"',
        kwargsParamMissing: 'O parâmetro "**{paramName}" não tem nenhum parâmetro correspondente',
        listAssignmentMismatch: 'O tipo "{type}" é incompatível com a lista de destino',
        literalAssignmentMismatch: '"{sourceType}" não pode ser atribuído a o tipo"{destType}"',
        matchIsNotExhaustiveHint: 'Se não pretende usar a manipulação exaustiva, adicione "case _: pass"',
        matchIsNotExhaustiveType: 'Tipo sem tratamento: "{type}"',
        memberAssignment: 'A expressão do tipo "{type}" não pode ser atribuída ao atributo "{name}" da classe "{classType}"',
        memberIsAbstract: '"{type}.{name}" não está implementado',
        memberIsAbstractMore: 'e mais {count}...',
        memberIsClassVarInProtocol: '"{name}" é definido como um ClassVar no protocolo',
        memberIsInitVar: '"{name}" é um campo somente de init-only',
        memberIsInvariant: '"{name}" é invariável porque é mutável',
        memberIsNotClassVarInClass: '"{name}" deve ser definido como um ClassVar para ser compatível com o protocolo',
        memberIsNotClassVarInProtocol: '"{name}" não está definido como um ClassVar no protocolo',
        memberIsNotReadOnlyInProtocol: '"{name}" não é somente leitura no protocolo',
        memberIsReadOnlyInProtocol: '"{name}" é somente leitura no protocolo',
        memberIsWritableInProtocol: '"{name}" é gravável no protocolo',
        memberSetClassVar: 'O atributo "{name}" não pode ser atribuído por meio de uma instância de classe porque é um ClassVar',
        memberTypeMismatch: '"{name}" é um tipo incompatível',
        memberUnknown: 'O atributo "{name}" é desconhecido',
        metaclassConflict: 'A metaclasse "{metaclass1}" entra em conflito com "{metaclass2}"',
        missingDeleter: 'O método de deleter de property está ausente',
        missingGetter: 'O método getter da property está ausente',
        missingSetter: 'O método setter da property está ausente',
        namedParamMissingInDest: 'Parâmetro extra "{name}"',
        namedParamMissingInSource: 'Parâmetro de palavra-chave ausente "{name}"',
        namedParamTypeMismatch: 'O parâmetro de palavra-chave "{name}" do tipo "{sourceType}" é incompatível com o tipo "{destType}"',
        namedTupleNotAllowed: 'NamedTuple não pode ser usado para verificações de instância ou de classe',
        newMethodLocation: 'O método __new__ é definido na classe "{type}"',
        newMethodSignature: 'A assinatura de__new__ é "{type}"',
        newTypeClassNotAllowed: 'A classe criada com NewType não pode ser usada com verificações de instância e classe',
        noOverloadAssignable: 'Nenhuma função sobrecarregada corresponde ao tipo "{type}"',
        noneNotAllowed: 'None não pode ser usado para verificações de instância ou de classe',
        orPatternMissingName: 'Nomes ausentes: {name}',
        overloadIndex: 'Sobrecarga {index} é a correspondência mais próxima',
        overloadNotAssignable: 'Uma ou mais sobrecargas de "{name}" não podem ser atribuídas',
        overloadSignature: 'A assinatura de sobrecarga é definida aqui',
        overriddenMethod: 'Método substituído',
        overriddenSymbol: 'Símbolo substituído',
        overrideInvariantMismatch: 'O tipo da substituição "{overrideType}" não é o mesmo do tipo básico "{baseType}"',
        overrideIsInvariant: 'A variável é mutável, então seu tipo é invariável',
        overrideNoOverloadMatches: 'Nenhuma assinatura de sobrecarga na substituição é compatível com o método base',
        overrideNotClassMethod: 'O método base é declarado como um classmethod, mas a substituição não é',
        overrideNotInstanceMethod: 'O método base é declarado como um método de instância, mas a substituição não é',
        overrideNotStaticMethod: 'O método base é declarado como staticmethod, mas a substituição não é',
        overrideOverloadNoMatch: 'Override não lida com todas as sobrecargas do método base',
        overrideOverloadOrder: 'As sobrecargas para o método de substituição devem estar na mesma ordem que o método base',
        overrideParamKeywordNoDefault: 'Incompatibilidade de parâmetro de palavra-chave "{name}": o parâmetro base tem valor de argumento padrão, o parâmetro de substituição não',
        overrideParamKeywordType: 'Incompatibilidade de tipo de parâmetro de palavra-chave "{name}": o parâmetro base é do tipo "{baseType}", o parâmetro de substituição é do tipo "{overrideType}"',
        overrideParamName: 'Incompatibilidade de nome de parâmetro {index}: o parâmetro base é denominado "{baseName}", o parâmetro de substituição é denomidado "{overrideName}"',
        overrideParamNameExtra: 'O parâmetro "{name}" está ausente na base',
        overrideParamNameMissing: 'O parâmetro "{name}" está ausente na substituição',
        overrideParamNamePositionOnly: 'Incompatibilidade de parâmetro {index}: o parâmetro base "{baseName}" é o parâmetro de palavra-chave, o parâmetro de substituição é somente posição',
        overrideParamNoDefault: 'Parâmetro {index} incompatível: o parâmetro base tem valor de argumento padrão, o parâmetro de substituição não',
        overrideParamType: 'Incompatibilidade de tipo de parâmetro {index}: o parâmetro base é do tipo "{baseType}", o parâmetro de substituição é do tipo "{overrideType}"',
        overridePositionalParamCount: 'Incompatibilidade de contagem de parâmetros posicionais. O método base tem {baseCount}, mas a substituição tem {overrideCount}',
        overrideReturnType: 'Incompatibilidade de tipo de retorno: o método base retorna o tipo "{baseType}", a substituição retorna o tipo "{overrideType}"',
        overrideType: 'A classe base define o tipo como "{type}"',
        paramAssignment: 'Parâmetro {index}: o tipo "{sourceType}" é incompatível com o tipo "{destType}"',
        paramSpecMissingInOverride: 'Os parâmetros ParamSpec estão ausentes no método de substituição',
        paramType: 'O tipo de parâmetro é "{paramType}"',
        privateImportFromPyTypedSource: 'Em vez disso, importe de "{module}"',
        propertyAccessFromProtocolClass: 'Uma propriedade definida dentro de uma classe de protocolo não pode ser acessada como uma variável de classe',
        propertyMethodIncompatible: 'O método de property "{name}" é incompatível',
        propertyMethodMissing: 'O método de property "{name}" está ausente na substituição',
        propertyMissingDeleter: 'A property "{name}" não tem nenhum deleter definido',
        propertyMissingSetter: 'A property "{name}" não tem um setter definido',
        protocolIncompatible: '"{sourceType}" é incompatível com o protocolo "{destType}"',
        protocolMemberMissing: '"{name}" não está presente',
        protocolRequiresRuntimeCheckable: 'A classe do Protocol deve ser @runtime_checkable para ser usada com verificações de instância e de classe',
        protocolSourceIsNotConcrete: '"{sourceType}" não é um tipo de classe concreta e não pode ser atribuído ao tipo "{destType}"',
        protocolUnsafeOverlap: 'Os atributos de "{name}" têm os mesmos nomes que o protocolo',
        pyrightCommentIgnoreTip: 'Use "# pyright: ignore[<diagnostic rules>]" para suprimir o diagnóstico de uma única linha',
        readOnlyAttribute: 'O atributo "{name}" é somente leitura',
        seeClassDeclaration: 'Consulte a declaração de classe',
        seeDeclaration: 'Consulte a declaração',
        seeFunctionDeclaration: 'Ver declaração de função',
        seeMethodDeclaration: 'Consulte a declaração de método',
        seeParameterDeclaration: 'Consulte a declaração de parâmetro',
        seeTypeAliasDeclaration: 'Ver declaração de alias de tipo',
        seeVariableDeclaration: 'Consulte a declaração de variável',
        tupleAssignmentMismatch: 'O tipo "{type}" é incompatível com a tuple de destino',
        tupleEntryTypeMismatch: 'A entrada de tuple {entry} é do tipo incorreto',
        tupleSizeIndeterminateSrc: 'Incompatibilidade de tamanho de tuple; esperado {expected} mas recebido indeterminado',
        tupleSizeIndeterminateSrcDest: 'Incompatibilidade de tamanho de tuple; {expected} ou mais esperado, mas indeterminado recebido',
        tupleSizeMismatch: 'Incompatibilidade de tamanho de tuple; esperado {expected} mas recebido {received}',
        tupleSizeMismatchIndeterminateDest: 'Incompatibilidade de tamanho de tuple; {expected} ou mais esperado, mas {received} recebido',
        typeAliasInstanceCheck: 'O alias de tipo criado com a instrução "type" não pode ser usado com verificações de instância e de classe',
        typeAssignmentMismatch: '"{sourceType}" não pode ser atribuído ao tipo"{destType}"',
        typeBound: 'O tipo "{sourceType}" não pode ser atribuído ao limite superior "{destType}" na variável do tipo "{name}"',
        typeConstrainedTypeVar: 'O tipo "{type}" não pode ser atribuído à variável do tipo restrita "{name}"',
        typeIncompatible: '"{sourceType}" não pode ser atribuído a "{destType}"',
        typeNotClass: '"{type}" não é uma classe.',
        typeNotStringLiteral: '"{type}" não é um literal de cadeia de caracteres',
        typeOfSymbol: 'O tipo de "{name}" é "{type}"',
        typeParamSpec: 'O tipo "{type}" é incompatível com ParamSpec "{name}"',
        typeUnsupported: 'O tipo "{type}" é incompatível',
        typeVarDefaultOutOfScope: 'A variável de tipo "{name}" não está no escopo',
        typeVarIsContravariant: 'O parâmetro de tipo "{name}" é contravariante, mas "{sourceType}" não é um supertipo de "{destType}"',
        typeVarIsCovariant: 'O parâmetro de tipo "{name}" é covariante, mas "{sourceType}" não é um subtipo de "{destType}"',
        typeVarIsInvariant: 'O parâmetro de tipo "{name}" é invariável, mas "{sourceType}" não é o mesmo que "{destType}"',
        typeVarNotAllowed: 'TypeVar não permitido para verificações de instância ou de classe',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple não pode ser associado a uma tuple de comprimento desconhecido',
        typeVarUnnecessarySuggestion: 'Use {type} em vez disso',
        typeVarUnsolvableRemedy: 'Forneça uma sobrecarga que especifica o tipo de retorno quando o argumento não é fornecido',
        typeVarsMissing: 'Variáveis de tipo ausentes: {names}',
        typedDictBaseClass: 'A classe "{type}" não é um TypedDict',
        typedDictClassNotAllowed: 'A classe TypedDict não é permitida para verificações de instância ou classe',
        typedDictClosedExtraNotAllowed: 'Não é possível adicionar o item "{name}"',
        typedDictClosedExtraTypeMismatch: 'Não é possível adicionar o item "{name}" com o tipo "{type}"',
        typedDictClosedFieldNotRequired: 'Não é possível adicionar o item "{name}" porque ele deve ser NotRequired',
        typedDictExtraFieldNotAllowed: '"{name}" não está presente em "{type}"',
        typedDictExtraFieldTypeMismatch: 'Tipo de "{name}" é incompatível com tipo de "extra_items" em "{type}"',
        typedDictFieldMissing: '"{name}" está ausente de "{type}"',
        typedDictFieldNotReadOnly: '"{name}" não é somente leitura em "{type}"',
        typedDictFieldNotRequired: '"{name}" não é obrigatório em "{type}"',
        typedDictFieldRequired: '"{name}" é necessário em "{type}"',
        typedDictFieldTypeMismatch: 'O tipo "{type}" não é atribuível ao item "{name}"',
        typedDictFieldUndefined: '"{name}" é um item indefinido no tipo "{type}"',
        typedDictFinalMismatch: '"{sourceType}" é incompatível com "{destType}" devido a uma @final incompatível',
        typedDictKeyAccess: 'Usar ["{name}"] para fazer referência ao item em TypedDict',
        typedDictNotAllowed: 'TypedDict não pode ser usado para verificações de instância ou de classe',
        unhashableType: 'O tipo "{type}" não é pode fazer hash',
        uninitializedAbstractVariable: 'A variável de instância "{name}" está definida na classe base abstrata "{classType}", mas não foi inicializada',
        unreachableExcept: '"{exceptionType}" é uma subclasse de "{parentType}"',
        useDictInstead: 'Use Dict[T1, T2] para indicar um tipo de dicionário',
        useListInstead: 'Use List[T] para indicar um tipo de lista ou Union[T1, T2] para indicar um tipo de union',
        useTupleInstead: 'Use tuple[T1, ..., Tn] para indicar um tipo de tuple ou Union[T1, T2] para indicar um tipo de union',
        useTypeInstead: 'Use Type[T] em vez disso',
        varianceMismatchForClass: 'A variação do argumento de tipo "{typeVarName}" é incompatível com a classe base "{className}"',
        varianceMismatchForTypeAlias: 'A variação do argumento de tipo "{typeVarName}" é incompatível com "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'A enumeração de arquivos de origem do espaço de trabalho está demorando muito. Em vez disso, considere abrir uma subpasta. [Saiba mais](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  12957: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: '[4i3uH][นั้Çrëætë Tÿpë StubẤğ倪İЂҰนั้ढूँ]',
        createTypeStubFor: '[oXYb0][นั้Çrëætë Tÿpë Stub Før "{møðµlëÑæmë}"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        executingCommand: '[AxS1Z][นั้Ëxëçµtïñg çømmæñðẤğ倪İЂҰक्นั้ढूँ]',
        filesToAnalyzeCount: '[94Ml3][นั้{çøµñt} fïlës tø æñælÿzëẤğ倪İЂҰक्र्นั้ढूँ]',
        filesToAnalyzeOne: '[2zuMu][นั้1 fïlë tø æñælÿzëẤğ倪İЂҰक्นั้ढूँ]',
        findingReferences: '[0UmwS][นั้Fïñðïñg rëfërëñçësẤğ倪İЂҰक्นั้ढूँ]',
        organizeImports: '[KhOyl][นั้Ørgæñïzë ÏmpørtsẤğ倪İЂҰนั้ढूँ]',
        renameShadowedFile: '[E02Ab][นั้Rëñæmë "{ølðFïlë}" tø "{ñëwFïlë}"Ấğ倪İЂҰक्र्तिृนั้ढूँ]'
      },
      Completion: {
        autoImportDetail: '[WdNQG][นั้Æµtø-ïmpørtẤğ倪İนั้ढूँ]',
        indexValueDetail: '[mX94Q][นั้Ïñðëx vælµëẤğ倪İนั้ढूँ]'
      },
      Diagnostic: {
        abstractMethodInvocation: '[fE8MD][นั้Mëthøð "{mëthøð}" çæññøt þë çællëð þëçæµsë ït ïs æþstræçt æñð µñïmplëmëñtëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        annotatedMetadataInconsistent: '[iOP70][นั้Æññøtætëð mëtæðætæ tÿpë "{mëtæðætæTÿpë}" ïs ñøt çømpætïþlë wïth tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        annotatedParamCountMismatch: '[VZvZc][นั้Pæræmëtër æññøtætïøñ çøµñt mïsmætçh: ëxpëçtëð {ëxpëçtëð} þµt rëçëïvëð {rëçëïvëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        annotatedTypeArgMissing: '[mTgtG][นั้Ëxpëçtëð øñë tÿpë ærgµmëñt æñð øñë ør mørë æññøtætïøñs før "Annotated"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        annotationBytesString: '[W1g86][นั้Tÿpë ëxprëssïøñs çæññøt µsë þÿtës strïñg lïtërælsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        annotationFormatString: '[zaI8H][นั้Tÿpë ëxprëssïøñs çæññøt µsë førmæt strïñg lïtëræls (f-strïñgs)Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        annotationNotSupported: '[xYlM8][นั้Tÿpë æññøtætïøñ ñøt sµppørtëð før thïs stætëmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        annotationRawString: '[WOMum][นั้Tÿpë ëxprëssïøñs çæññøt µsë ræw strïñg lïtërælsẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        annotationSpansStrings: '[6Gg9x][นั้Tÿpë ëxprëssïøñs çæññøt spæñ mµltïplë strïñg lïtërælsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        annotationStringEscape: '[MQdsm][นั้Tÿpë ëxprëssïøñs çæññøt çøñtæïñ ësçæpë çhæræçtërsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        argAssignment: '[7pdVt][นั้Ærgµmëñt øf tÿpë "{ærgTÿpë}" çæññøt þë æssïgñëð tø pæræmëtër øf tÿpë "{pæræmTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        argAssignmentFunction: '[J08ms][นั้Ærgµmëñt øf tÿpë "{ærgTÿpë}" çæññøt þë æssïgñëð tø pæræmëtër øf tÿpë "{pæræmTÿpë}" ïñ fµñçtïøñ "{fµñçtïøñÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        argAssignmentParam: '[hEBRl][นั้Ærgµmëñt øf tÿpë "{ærgTÿpë}" çæññøt þë æssïgñëð tø pæræmëtër "{pæræmÑæmë}" øf tÿpë "{pæræmTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        argAssignmentParamFunction: '[0sIuD][นั้Ærgµmëñt øf tÿpë "{ærgTÿpë}" çæññøt þë æssïgñëð tø pæræmëtër "{pæræmÑæmë}" øf tÿpë "{pæræmTÿpë}" ïñ fµñçtïøñ "{fµñçtïøñÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        argMissingForParam: '[1oqiG][นั้Ærgµmëñt mïssïñg før pæræmëtër {ñæmë}Ấğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        argMissingForParams: '[iAF8C][นั้Ærgµmëñts mïssïñg før pæræmëtërs {ñæmës}Ấğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        argMorePositionalExpectedCount: '[q3jgC][นั้Ëxpëçtëð {ëxpëçtëð} mørë pøsïtïøñæl ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        argMorePositionalExpectedOne: '[DNcCo][นั้Ëxpëçtëð 1 mørë pøsïtïøñæl ærgµmëñtẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        argPositional: '[XBHa9][นั้Ëxpëçtëð pøsïtïøñæl ærgµmëñtẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        argPositionalExpectedCount: '[F5Y6t][นั้Ëxpëçtëð {ëxpëçtëð} pøsïtïøñæl ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        argPositionalExpectedOne: '[XW4kV][นั้Ëxpëçtëð 1 pøsïtïøñæl ærgµmëñtẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        argTypePartiallyUnknown: '[Y02o3][นั้Ærgµmëñt tÿpë ïs pærtïællÿ µñkñøwñẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        argTypeUnknown: '[l0ccD][นั้Ærgµmëñt tÿpë ïs µñkñøwñẤğ倪İЂҰक्र्นั้ढूँ]',
        assertAlwaysTrue: '[5Weld][นั้Æssërt ëxprëssïøñ ælwæÿs ëvælµætës tø trueẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        assertTypeArgs: '[QHRQ7][นั้"assert_type" ëxpëçts twø pøsïtïøñæl ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        assertTypeTypeMismatch: '[fc1Kk][นั้"assert_type" mïsmætçh: ëxpëçtëð "{ëxpëçtëð}" þµt rëçëïvëð "{rëçëïvëð}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        assignmentExprComprehension: '[F5OTr][นั้Æssïgñmëñt ëxprëssïøñ tærgët "{ñæmë}" çæññøt µsë sæmë ñæmë æs çømprëhëñsïøñ før tærgëtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        assignmentExprContext: '[U4d41][นั้Æssïgñmëñt ëxprëssïøñ mµst þë wïthïñ møðµlë, fµñçtïøñ ør læmþðæẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        assignmentExprInSubscript: '[mnJzw][นั้Æssïgñmëñt ëxprëssïøñs wïthïñ æ sµþsçrïpt ærë sµppørtëð øñlÿ ïñ Pÿthøñ 3.10 æñð ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        assignmentInProtocol: '[vey5h][นั้Ïñstæñçë ør çlæss værïæþlës wïthïñ æ Protocol çlæss mµst þë ëxplïçïtlÿ ðëçlærëð wïthïñ thë çlæss þøðÿẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        assignmentTargetExpr: '[22xbu][นั้Ëxprëssïøñ çæññøt þë æssïgñmëñt tærgëtẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        asyncNotInAsyncFunction: '[u0Y7U][นั้Üsë øf "async" ñøt ælløwëð øµtsïðë øf async fµñçtïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        awaitIllegal: '[2Wa68][นั้Üsë øf "await" rëqµïrës Pÿthøñ 3.5 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        awaitNotAllowed: '[TpX77][นั้Tÿpë ëxprëssïøñs çæññøt µsë "await"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        awaitNotInAsync: '[qau2Q][นั้"await" ælløwëð øñlÿ wïthïñ async fµñçtïøñẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        backticksIllegal: '[V1LZI][นั้Ëxprëssïøñs sµrrøµñðëð þÿ þæçktïçks ærë ñøt sµppørtëð ïñ Pÿthøñ 3.x; µsë repr ïñstëæðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        baseClassCircular: '[frqWt][นั้Çlæss çæññøt ðërïvë frøm ïtsëlfẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        baseClassFinal: '[C9i92][นั้ßæsë çlæss "{tÿpë}" ïs mærkëð final æñð çæññøt þë sµþçlæssëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        baseClassIncompatible: '[K3wZ2][นั้ßæsë çlæssës øf {tÿpë} ærë mµtµællÿ ïñçømpætïþlëẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        baseClassInvalid: '[qULQr][นั้Ærgµmëñt tø çlæss mµst þë æ þæsë çlæssẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        baseClassMethodTypeIncompatible: '[2lM0z][นั้ßæsë çlæssës før çlæss "{çlæssTÿpë}" ðëfïñë mëthøð "{ñæmë}" ïñ ïñçømpætïþlë wæÿẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        baseClassUnknown: '[QQxIX][นั้ßæsë çlæss tÿpë ïs µñkñøwñ, øþsçµrïñg tÿpë øf ðërïvëð çlæssẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        baseClassVariableTypeIncompatible: '[YmxlD][นั้ßæsë çlæssës før çlæss "{çlæssTÿpë}" ðëfïñë værïæþlë "{ñæmë}" ïñ ïñçømpætïþlë wæÿẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        binaryOperationNotAllowed: '[1lzlz][นั้ßïñærÿ øpërætør ñøt ælløwëð ïñ tÿpë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        bindTypeMismatch: '[x4sbf][นั้Çøµlð ñøt þïñð mëthøð "{mëthøðÑæmë}" þëçæµsë "{tÿpë}" ïs ñøt æssïgñæþlë tø pæræmëtër "{pæræmÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        breakInExceptionGroup: '[Kwoku][นั้"break" ïs ñøt ælløwëð ïñ æñ "except*" þløçkẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        breakOutsideLoop: '[Ca4Ip][นั้"break" çæñ þë µsëð øñlÿ wïthïñ æ løøpẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        callableExtraArgs: '[M3UIb][นั้Ëxpëçtëð øñlÿ twø tÿpë ærgµmëñts tø "Callable"Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        callableFirstArg: '[W1wTU][นั้Ëxpëçtëð pæræmëtër tÿpë lïst ør "..."Ấğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        callableNotInstantiable: '[sJ0Q8][นั้Çæññøt ïñstæñtïætë tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        callableSecondArg: '[9c1cS][นั้Ëxpëçtëð rëtµrñ tÿpë æs sëçøñð tÿpë ærgµmëñt før "Callable"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        casePatternIsIrrefutable: '[NR6tj][นั้Ïrrëfµtæþlë pættërñ ïs ælløwëð øñlÿ før thë læst çæsë stætëmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        classAlreadySpecialized: '[Puetc][นั้Tÿpë "{tÿpë}" ïs ælrëæðÿ spëçïælïzëðẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        classDecoratorTypeUnknown: '[FhL8V][นั้Üñtÿpëð çlæss ðëçørætør øþsçµrës tÿpë øf çlæss; ïgñørïñg ðëçørætørẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        classDefinitionCycle: '[21Tlp][นั้Çlæss ðëfïñïtïøñ før "{ñæmë}" ðëpëñðs øñ ïtsëlfẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        classGetItemClsParam: '[A2iHF][นั้__class_getitem__ øvërrïðë shøµlð tækë æ "cls" pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        classMethodClsParam: '[aWMN3][นั้Çlæss mëthøðs shøµlð tækë æ "cls" pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        classNotRuntimeSubscriptable: '[O9BL6][นั้§µþsçrïpt før çlæss "{ñæmë}" wïll gëñërætë rµñtïmë ëxçëptïøñ; ëñçløsë tÿpë ëxprëssïøñ ïñ qµøtësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        classPatternBuiltInArgPositional: '[DOfs5][นั้Çlæss pættërñ æççëpts øñlÿ pøsïtïøñæl sµþ-pættërñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        classPatternPositionalArgCount: '[B65y5][นั้Tøø mæñÿ pøsïtïøñæl pættërñs før çlæss "{tÿpë}"; ëxpëçtëð {ëxpëçtëð} þµt rëçëïvëð {rëçëïvëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        classPatternTypeAlias: '[AxDtv][นั้"{tÿpë}" çæññøt þë µsëð ïñ æ çlæss pættërñ þëçæµsë ït ïs æ spëçïælïzëð tÿpë ælïæsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        classPropertyDeprecated: '[Q6JgP][นั้Çlæss prøpërtïës ærë ðëprëçætëð ïñ Pÿthøñ 3.11 æñð wïll ñøt þë sµppørtëð ïñ Pÿthøñ 3.13Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        classTypeParametersIllegal: '[GybXD][นั้Çlæss tÿpë pæræmëtër sÿñtæx rëqµïrës Pÿthøñ 3.12 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        classVarFirstArgMissing: '[VtcEd][นั้Ëxpëçtëð æ tÿpë ærgµmëñt æftër "ClassVar"Ấğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        classVarNotAllowed: '[BU07G][นั้"ClassVar" ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        classVarOverridesInstanceVar: '[UEaro][นั้Çlæss værïæþlë "{ñæmë}" øvërrïðës ïñstæñçë værïæþlë øf sæmë ñæmë ïñ çlæss "{çlæssÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        classVarTooManyArgs: '[Mj1R5][นั้Ëxpëçtëð øñlÿ øñë tÿpë ærgµmëñt æftër "ClassVar"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        classVarWithTypeVar: '[6mnjY][นั้"ClassVar" tÿpë çæññøt ïñçlµðë tÿpë værïæþlësẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        clsSelfParamTypeMismatch: '[MBrCQ][นั้Tÿpë øf pæræmëtër "{ñæmë}" mµst þë æ sµpërtÿpë øf ïts çlæss "{çlæssTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        codeTooComplexToAnalyze: '[FNQd7][นั้Çøðë ïs tøø çømplëx tø æñælÿzë; rëðµçë çømplëxïtÿ þÿ rëfæçtørïñg ïñtø sµþrøµtïñës ør rëðµçïñg çøñðïtïøñæl çøðë pæthsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        collectionAliasInstantiation: '[rZb8i][นั้Tÿpë "{tÿpë}" çæññøt þë ïñstæñtïætëð, µsë "{ælïæs}" ïñstëæðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        comparisonAlwaysFalse: '[N16ve][นั้Çøñðïtïøñ wïll ælwæÿs ëvælµætë tø False sïñçë thë tÿpës "{lëftTÿpë}" æñð "{rïghtTÿpë}" hævë ñø øvërlæpẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        comparisonAlwaysTrue: '[0TOLo][นั้Çøñðïtïøñ wïll ælwæÿs ëvælµætë tø True sïñçë thë tÿpës "{lëftTÿpë}" æñð "{rïghtTÿpë}" hævë ñø øvërlæpẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        comprehensionInDict: '[Orm2O][นั้Çømprëhëñsïøñ çæññøt þë µsëð wïth øthër ðïçtïøñærÿ ëñtrïësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        comprehensionInSet: '[YUnu9][นั้Çømprëhëñsïøñ çæññøt þë µsëð wïth øthër set ëñtrïësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        concatenateContext: '[8tRy6][นั้"Concatenate" ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        concatenateParamSpecMissing: '[3s1CV][นั้£æst tÿpë ærgµmëñt før "Concatenate" mµst þë æ ParamSpec ør "..."Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        concatenateTypeArgsMissing: '[aH5g8][นั้"Concatenate" rëqµïrës æt lëæst twø tÿpë ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        conditionalOperandInvalid: '[HnbrG][นั้Ïñvælïð çøñðïtïøñæl øpëræñð øf tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        constantRedefinition: '[oRKBh][นั้"{ñæmë}" ïs çøñstæñt (þëçæµsë ït ïs µppërçæsë) æñð çæññøt þë rëðëfïñëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        constructorParametersMismatch: '[WWloK][นั้Mïsmætçh þëtwëëñ sïgñætµrë øf __new__ æñð __init__ ïñ çlæss "{çlæssTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        containmentAlwaysFalse: '[e6PIv][นั้Ëxprëssïøñ wïll ælwæÿs ëvælµætë tø False sïñçë thë tÿpës "{lëftTÿpë}" æñð "{rïghtTÿpë}" hævë ñø øvërlæpẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        containmentAlwaysTrue: '[8OhUO][นั้Ëxprëssïøñ wïll ælwæÿs ëvælµætë tø True sïñçë thë tÿpës "{lëftTÿpë}" æñð "{rïghtTÿpë}" hævë ñø øvërlæpẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        continueInExceptionGroup: '[h1tNi][นั้"continue" ïs ñøt ælløwëð ïñ æñ "except*" þløçkẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        continueOutsideLoop: '[6ACvd][นั้"continue" çæñ þë µsëð øñlÿ wïthïñ æ løøpẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        coroutineInConditionalExpression: '[ygK2r][นั้Çøñðïtïøñæl ëxprëssïøñ rëfërëñçës çørøµtïñë whïçh ælwæÿs ëvælµætës tø TrueẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        dataClassBaseClassFrozen: '[jjiw4][นั้Æ ñøñ-frøzëñ çlæss çæññøt ïñhërït frøm æ çlæss thæt ïs frøzëñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        dataClassBaseClassNotFrozen: '[KOz4K][นั้Æ frøzëñ çlæss çæññøt ïñhërït frøm æ çlæss thæt ïs ñøt frøzëñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        dataClassConverterFunction: '[FxD8r][นั้Ærgµmëñt øf tÿpë "{ærgTÿpë}" ïs ñøt æ vælïð çøñvërtër før fïëlð "{fïëlðÑæmë}" øf tÿpë "{fïëlðTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        dataClassConverterOverloads: '[ZJ0SE][นั้Ñø øvërløæðs øf "{fµñçÑæmë}" ærë vælïð çøñvërtërs før fïëlð "{fïëlðÑæmë}" øf tÿpë "{fïëlðTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        dataClassFieldInheritedDefault: '[BKxvn][นั้"{fïëlðÑæmë}" øvërrïðës æ fïëlð øf thë sæmë ñæmë þµt ïs mïssïñg æ ðëfæµlt vælµëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        dataClassFieldWithDefault: '[iJuju][นั้Fïëlðs wïthøµt ðëfæµlt vælµës çæññøt æppëær æftër fïëlðs wïth ðëfæµlt vælµësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        dataClassFieldWithPrivateName: '[miQYb][นั้Ðætæçlæss fïëlð çæññøt µsë prïvætë ñæmëẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        dataClassFieldWithoutAnnotation: '[zq5t5][นั้Ðætæçlæss fïëlð wïthøµt tÿpë æññøtætïøñ wïll çæµsë rµñtïmë ëxçëptïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        dataClassPostInitParamCount: '[yl0Bg][นั้Ðætæçlæss __post_init__ ïñçørrëçt pæræmëtër çøµñt; ñµmþër øf InitVar fïëlðs ïs {ëxpëçtëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        dataClassPostInitType: '[74TW4][นั้Ðætæçlæss __post_init__ mëthøð pæræmëtër tÿpë mïsmætçh før fïëlð "{fïëlðÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        dataClassSlotsOverwrite: '[D17er][นั้__slots__ ïs ælrëæðÿ ðëfïñëð ïñ çlæssẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        dataClassTransformExpectedBoolLiteral: '[y2upJ][นั้Ëxpëçtëð ëxprëssïøñ thæt stætïçællÿ ëvælµætës tø True ør FalseẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        dataClassTransformFieldSpecifier: '[xE1Cp][นั้Ëxpëçtëð tuple øf çlæssës ør fµñçtïøñs þµt rëçëïvëð tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        dataClassTransformPositionalParam: '[Cu7w4][นั้Æll ærgµmëñts tø "dataclass_transform" mµst þë këÿwørð ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        dataClassTransformUnknownArgument: '[hLQXL][นั้Ærgµmëñt "{ñæmë}" ïs ñøt sµppørtëð þÿ dataclass_transformẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        dataProtocolInSubclassCheck: '[kIIkO][นั้Ðætæ prøtøçøls (whïçh ïñçlµðë ñøñ-mëthøð ættrïþµtës) ærë ñøt ælløwëð ïñ issubclass çællsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        declaredReturnTypePartiallyUnknown: '[pDeOu][นั้Ðëçlærëð rëtµrñ tÿpë, "{rëtµrñTÿpë}", ïs pærtïællÿ µñkñøwñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        declaredReturnTypeUnknown: '[XRFJs][นั้Ðëçlærëð rëtµrñ tÿpë ïs µñkñøwñẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        defaultValueContainsCall: '[G3smw][นั้Fµñçtïøñ çælls æñð mµtæþlë øþjëçts ñøt ælløwëð wïthïñ pæræmëtër ðëfæµlt vælµë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        defaultValueNotAllowed: '[SuRpb][นั้Pæræmëtër wïth "*" ør "**" çæññøt hævë ðëfæµlt vælµëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        delTargetExpr: '[VLtXk][นั้Ëxprëssïøñ çæññøt þë ðëlëtëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        deprecatedClass: '[DIyRn][นั้Thë çlæss "{ñæmë}" ïs ðëprëçætëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        deprecatedConstructor: '[jq4aQ][นั้Thë çøñstrµçtør før çlæss "{ñæmë}" ïs ðëprëçætëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        deprecatedDescriptorDeleter: '[ljYHS][นั้Thë "__ðëlëtë__" mëthøð før ðësçrïptør "{ñæmë}" ïs ðëprëçætëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        deprecatedDescriptorGetter: '[06Y3N][นั้Thë "__gët__" mëthøð  før ðësçrïptør "{ñæmë}" ïs ðëprëçætëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        deprecatedDescriptorSetter: '[6nQQu][นั้Thë "__sët__" mëthøð  før ðësçrïptør "{ñæmë}" ïs ðëprëçætëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        deprecatedFunction: '[GdF0l][นั้Thë fµñçtïøñ "{ñæmë}" ïs ðëprëçætëðẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        deprecatedMethod: '[GxfND][นั้Thë mëthøð "{ñæmë}" ïñ çlæss "{çlæssÑæmë}" ïs ðëprëçætëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        deprecatedPropertyDeleter: '[BUlI2][นั้Thë deleter før property "{ñæmë}" ïs ðëprëçætëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        deprecatedPropertyGetter: '[54BuI][นั้Thë getter før property "{ñæmë}" ïs ðëprëçætëðẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        deprecatedPropertySetter: '[EHGoz][นั้Thë setter før property "{ñæmë}" ïs ðëprëçætëðẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        deprecatedType: '[IWdSs][นั้Thïs tÿpë ïs ðëprëçætëð æs øf Pÿthøñ {vërsïøñ}; µsë "{rëplæçëmëñt}" ïñstëæðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        dictExpandIllegalInComprehension: '[3B8LL][นั้Ðïçtïøñærÿ ëxpæñsïøñ ñøt ælløwëð ïñ çømprëhëñsïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        dictInAnnotation: '[0UcII][นั้Ðïçtïøñærÿ ëxprëssïøñ ñøt ælløwëð ïñ tÿpë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        dictKeyValuePairs: '[Hnd6W][นั้Ðïçtïøñærÿ ëñtrïës mµst çøñtæïñ këÿ/vælµë pæïrsẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        dictUnpackIsNotMapping: '[RhO60][นั้Ëxpëçtëð mæppïñg før ðïçtïøñærÿ µñpæçk øpërætørẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        dunderAllSymbolNotPresent: '[mlrcI][นั้"{ñæmë}" ïs spëçïfïëð ïñ __all__ þµt ïs ñøt prësëñt ïñ møðµlëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        duplicateArgsParam: '[bt3Os][นั้Øñlÿ øñë "*" pæræmëtër ælløwëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        duplicateBaseClass: '[HIzyw][นั้Ðµplïçætë þæsë çlæss ñøt ælløwëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        duplicateCapturePatternTarget: '[zq38Z][นั้Çæptµrë tærgët "{ñæmë}" çæññøt æppëær mørë thæñ øñçë wïthïñ thë sæmë pættërñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        duplicateCatchAll: '[6gO00][นั้Øñlÿ øñë çætçh-æll except çlæµsë ælløwëðẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        duplicateEnumMember: '[k9W8A][นั้Enum mëmþër "{ñæmë}" ïs ælrëæðÿ ðëçlærëðẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        duplicateGenericAndProtocolBase: '[4EO4W][นั้Øñlÿ øñë Generic[...] ør Protocol[...] þæsë çlæss ælløwëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        duplicateImport: '[qgZGm][นั้"{ïmpørtÑæmë}" ïs ïmpørtëð mørë thæñ øñçëẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        duplicateKeywordOnly: '[pbf3W][นั้Øñlÿ øñë "*" sëpærætør ælløwëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        duplicateKwargsParam: '[4QsUE][นั้Øñlÿ øñë "**" pæræmëtër ælløwëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        duplicateParam: '[s0XGf][นั้Ðµplïçætë pæræmëtër "{ñæmë}"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        duplicatePositionOnly: '[9hzW4][นั้Øñlÿ øñë "/" pæræmëtër ælløwëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        duplicateStarPattern: '[8quwQ][นั้Øñlÿ øñë "*" pættërñ ælløwëð ïñ æ pættërñ sëqµëñçëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        duplicateStarStarPattern: '[wScoI][นั้Øñlÿ øñë "**" ëñtrÿ ælløwëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        duplicateUnpack: '[wjeOP][นั้Øñlÿ øñë µñpæçk øpërætïøñ ælløwëð ïñ listẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        ellipsisAfterUnpacked: '[4EsWH][นั้"..." çæññøt þë µsëð wïth æñ µñpæçkëð TypeVarTuple ør tupleẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        ellipsisContext: '[Y4jK3][นั้"..." ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        ellipsisSecondArg: '[pvXJA][นั้"..." ïs ælløwëð øñlÿ æs thë sëçøñð øf twø ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        enumClassOverride: '[2JsL1][นั้Enum çlæss "{ñæmë}" ïs final æñð çæññøt þë sµþçlæssëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        enumMemberDelete: '[5wmRY][นั้Enum mëmþër "{ñæmë}" çæññøt þë ðëlëtëðẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        enumMemberSet: '[mBLro][นั้Enum mëmþër "{ñæmë}" çæññøt þë æssïgñëðẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        enumMemberTypeAnnotation: '[z8FaL][นั้Tÿpë æññøtætïøñs ærë ñøt ælløwëð før enum mëmþërsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        exceptGroupMismatch: '[XbzjN][นั้Trÿ stætëmëñt çæññøt ïñçlµðë þøth "except" æñð "except*"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        exceptGroupRequiresType: '[740wj][นั้Ëxçëptïøñ grøµp sÿñtæx ("except*") rëqµïrës æñ ëxçëptïøñ tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        exceptionGroupIncompatible: '[d0SLP][นั้Ëxçëptïøñ grøµp sÿñtæx ("except*") rëqµïrës Pÿthøñ 3.11 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        exceptionGroupTypeIncorrect: '[Kanvz][นั้Ëxçëptïøñ tÿpë ïñ except* çæññøt ðërïvë frøm BaseGroupExceptionẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        exceptionTypeIncorrect: '[G7AZt][นั้"{tÿpë}" ðøës ñøt ðërïvë frøm BaseExceptionẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        exceptionTypeNotClass: '[v1FmY][นั้"{tÿpë}" ïs ñøt æ vælïð ëxçëptïøñ çlæssẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        exceptionTypeNotInstantiable: '[PfdeG][นั้Çøñstrµçtør før ëxçëptïøñ tÿpë "{tÿpë}" rëqµïrës øñë ør mørë ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        expectedAfterDecorator: '[rzMVF][นั้Ëxpëçtëð fµñçtïøñ ør çlæss ðëçlærætïøñ æftër ðëçørætørẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        expectedArrow: '[DrZKr][นั้Ëxpëçtëð "->" følløwëð þÿ rëtµrñ tÿpë æññøtætïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        expectedAsAfterException: '[FDdTe][นั้Ëxpëçtëð "as" æftër ëxçëptïøñ tÿpëẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        expectedAssignRightHandExpr: '[mPzHP][นั้Ëxpëçtëð ëxprëssïøñ tø thë rïght øf "="Ấğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        expectedBinaryRightHandExpr: '[MgqnF][นั้Ëxpëçtëð ëxprëssïøñ tø thë rïght øf øpërætørẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        expectedBoolLiteral: '[bhZAe][นั้Ëxpëçtëð True ør FalseẤğ倪İЂҰक्र्นั้ढूँ]',
        expectedCase: '[kQ1sa][นั้Ëxpëçtëð "case" stætëmëñtẤğ倪İЂҰक्र्นั้ढूँ]',
        expectedClassName: '[f0XRc][นั้Ëxpëçtëð çlæss ñæmëẤğ倪İЂҰक्นั้ढूँ]',
        expectedCloseBrace: '[MQHKY][นั้"{" wæs ñøt çløsëðẤğ倪İЂҰक्นั้ढूँ]',
        expectedCloseBracket: '[YfM0n][นั้"[" wæs ñøt çløsëðẤğ倪İЂҰक्นั้ढूँ]',
        expectedCloseParen: '[tAuag][นั้"(" wæs ñøt çløsëðẤğ倪İЂҰक्นั้ढूँ]',
        expectedColon: '[KmzHa][นั้Ëxpëçtëð ":"Ấğ倪İЂนั้ढूँ]',
        expectedComplexNumberLiteral: '[dc2rM][นั้Ëxpëçtëð çømplëx ñµmþër lïtëræl før pættërñ mætçhïñgẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        expectedDecoratorExpr: '[415JG][นั้Ëxprëssïøñ førm ñøt sµppørtëð før ðëçørætør prïør tø Pÿthøñ 3.9Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        expectedDecoratorName: '[IKO4m][นั้Ëxpëçtëð ðëçørætør ñæmëẤğ倪İЂҰक्र्นั้ढूँ]',
        expectedDecoratorNewline: '[Bsyx3][นั้Ëxpëçtëð ñëw lïñë æt ëñð øf ðëçørætørẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        expectedDelExpr: '[u8JgL][นั้Ëxpëçtëð ëxprëssïøñ æftër "del"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        expectedElse: '[eROaU][นั้Ëxpëçtëð "else"Ấğ倪İЂҰนั้ढूँ]',
        expectedEquals: '[TXK4x][นั้Ëxpëçtëð "="Ấğ倪İЂนั้ढूँ]',
        expectedExceptionClass: '[sYtUr][นั้Ïñvælïð ëxçëptïøñ çlæss ør øþjëçtẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        expectedExceptionObj: '[w4tAQ][นั้Ëxpëçtëð ëxçëptïøñ øþjëçt, ëxçëptïøñ çlæss ør NoneẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        expectedExpr: '[iKSsw][นั้Ëxpëçtëð ëxprëssïøñẤğ倪İЂҰक्นั้ढूँ]',
        expectedFunctionAfterAsync: '[fWBMb][นั้Ëxpëçtëð fµñçtïøñ ðëfïñïtïøñ æftër "async"Ấğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        expectedFunctionName: '[cR036][นั้Ëxpëçtëð fµñçtïøñ ñæmë æftër "def"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        expectedIdentifier: '[Lj4l5][นั้Ëxpëçtëð ïðëñtïfïërẤğ倪İЂҰक्นั้ढूँ]',
        expectedImport: '[FNK2F][นั้Ëxpëçtëð "import"Ấğ倪İЂҰक्นั้ढूँ]',
        expectedImportAlias: '[mb4fF][นั้Ëxpëçtëð sÿmþøl æftër "as"Ấğ倪İЂҰक्र्นั้ढूँ]',
        expectedImportSymbols: '[QUZ7S][นั้Ëxpëçtëð øñë ør mørë sÿmþøl ñæmës æftër "import"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        expectedIn: '[9XkiC][นั้Ëxpëçtëð "in"Ấğ倪İЂนั้ढूँ]',
        expectedInExpr: '[RXryp][นั้Ëxpëçtëð ëxprëssïøñ æftër "in"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        expectedIndentedBlock: '[7ZvJC][นั้Ëxpëçtëð ïñðëñtëð þløçkẤğ倪İЂҰक्र्นั้ढूँ]',
        expectedMemberName: '[VvTAF][นั้Ëxpëçtëð ættrïþµtë ñæmë æftër "."Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        expectedModuleName: '[Jky7g][นั้Ëxpëçtëð møðµlë ñæmëẤğ倪İЂҰक्นั้ढूँ]',
        expectedNameAfterAs: '[KnNbR][นั้Ëxpëçtëð sÿmþøl ñæmë æftër "as"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        expectedNamedParameter: '[ZsE8l][นั้Këÿwørð pæræmëtër mµst følløw "*"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        expectedNewline: '[bW0cY][นั้Ëxpëçtëð ñëwlïñëẤğ倪İЂҰนั้ढूँ]',
        expectedNewlineOrSemicolon: '[av2Gz][นั้§tætëmëñts mµst þë sëpærætëð þÿ ñëwlïñës ør sëmïçøløñsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        expectedOpenParen: '[CLuzo][นั้Ëxpëçtëð "("Ấğ倪İЂนั้ढूँ]',
        expectedParamName: '[b0il7][นั้Ëxpëçtëð pæræmëtër ñæmëẤğ倪İЂҰक्र्นั้ढूँ]',
        expectedPatternExpr: '[76AU4][นั้Ëxpëçtëð pættërñ ëxprëssïøñẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        expectedPatternSubjectExpr: '[GUw9q][นั้Ëxpëçtëð pættërñ sµþjëçt ëxprëssïøñẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        expectedPatternValue: '[Ah06c][นั้Ëxpëçtëð pættërñ vælµë ëxprëssïøñ øf thë førm "a.b"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        expectedReturnExpr: '[nyeYf][นั้Ëxpëçtëð ëxprëssïøñ æftër "return"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        expectedSliceIndex: '[0HjFA][นั้Ëxpëçtëð ïñðëx ør slïçë ëxprëssïøñẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        expectedTypeNotString: '[FXeAr][นั้Ëxpëçtëð tÿpë þµt rëçëïvëð æ strïñg lïtërælẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        expectedTypeParameterName: '[aHX5Q][นั้Ëxpëçtëð tÿpë pæræmëtër ñæmëẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        expectedYieldExpr: '[TrB0N][นั้Ëxpëçtëð ëxprëssïøñ ïñ yield stætëmëñtẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        finalClassIsAbstract: '[qEcDN][นั้Çlæss "{tÿpë}" ïs mærkëð final æñð mµst ïmplëmëñt æll æþstræçt sÿmþølsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        finalContext: '[KT2Ma][นั้"Final" ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        finalInLoop: '[yUnYn][นั้Æ "Final" værïæþlë çæññøt þë æssïgñëð wïthïñ æ løøpẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        finalMethodOverride: '[rVyi2][นั้Mëthøð "{ñæmë}" çæññøt øvërrïðë final mëthøð ðëfïñëð ïñ çlæss "{çlæssÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        finalNonMethod: '[ITFlU][นั้Fµñçtïøñ "{ñæmë}" çæññøt þë mærkëð @final þëçæµsë ït ïs ñøt æ mëthøðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        finalReassigned: '[fgpqP][นั้"{ñæmë}" ïs ðëçlærëð æs Final æñð çæññøt þë rëæssïgñëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        finalRedeclaration: '[8jVSa][นั้"{ñæmë}" wæs prëvïøµslÿ ðëçlærëð æs FinalẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        finalRedeclarationBySubclass: '[0VswQ][นั้"{ñæmë}" çæññøt þë rëðëçlærëð þëçæµsë pærëñt çlæss "{çlæssÑæmë}" ðëçlærës ït æs FinalẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        finalTooManyArgs: '[9fleE][นั้Ëxpëçtëð æ sïñglë tÿpë ærgµmëñt æftër "Final"Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        finalUnassigned: '[PmdtN][นั้"{ñæmë}" ïs ðëçlærëð Final, þµt vælµë ïs ñøt æssïgñëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        formatStringBrace: '[j606J][นั้§ïñglë çløsë þræçë ñøt ælløwëð wïthïñ f-strïñg lïtëræl; µsë ðøµþlë çløsë þræçëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        formatStringBytes: '[1Xo44][นั้Førmæt strïñg lïtëræls (f-strïñgs) çæññøt þë þïñærÿẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        formatStringDebuggingIllegal: '[mQueA][นั้F-strïñg ðëþµggïñg spëçïfïër "=" rëqµïrës Pÿthøñ 3.8 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        formatStringEscape: '[lcP3H][นั้Ësçæpë sëqµëñçë (þæçkslæsh) ñøt ælløwëð ïñ ëxprëssïøñ pørtïøñ øf f-strïñg prïør tø Pÿthøñ 3.12Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        formatStringExpectedConversion: '[AjO2F][นั้Ëxpëçtëð æ çøñvërsïøñ spëçïfïër æftër "!" ïñ f-strïñgẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        formatStringIllegal: '[HhOeX][นั้Førmæt strïñg lïtëræls (f-strïñgs) rëqµïrë Pÿthøñ 3.6 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        formatStringInPattern: '[KqV2l][นั้Førmæt strïñg ñøt ælløwëð ïñ pættërñẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        formatStringNestedFormatSpecifier: '[OFqi6][นั้Ëxprëssïøñs ñëstëð tøø ðëëplÿ wïthïñ førmæt strïñg spëçïfïërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        formatStringNestedQuote: '[buq49][นั้§trïñgs ñëstëð wïthïñ æñ f-strïñg çæññøt µsë thë sæmë qµøtë çhæræçtër æs thë f-strïñg prïør tø Pÿthøñ 3.12Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        formatStringUnicode: '[RCCfD][นั้Førmæt strïñg lïtëræls (f-strïñgs) çæññøt þë µñïçøðëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        formatStringUnterminated: '[PnOZr][นั้Üñtërmïñætëð ëxprëssïøñ ïñ f-strïñg; ëxpëçtïñg "}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        functionDecoratorTypeUnknown: '[Gv66U][นั้Üñtÿpëð fµñçtïøñ ðëçørætør øþsçµrës tÿpë øf fµñçtïøñ; ïgñørïñg ðëçørætørẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        functionInConditionalExpression: '[9A68n][นั้Çøñðïtïøñæl ëxprëssïøñ rëfërëñçës fµñçtïøñ whïçh ælwæÿs ëvælµætës tø TrueẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        functionTypeParametersIllegal: '[0JM96][นั้Fµñçtïøñ tÿpë pæræmëtër sÿñtæx rëqµïrës Pÿthøñ 3.12 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        futureImportLocationNotAllowed: '[IdoQY][นั้Ïmpørts frøm __future__ mµst þë æt thë þëgïññïñg øf thë fïlëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        generatorAsyncReturnType: '[dYKl9][นั้Rëtµrñ tÿpë øf async gëñërætør fµñçtïøñ mµst þë çømpætïþlë wïth "AsyncGenerator[{yieldType}, Any]"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        generatorNotParenthesized: '[WmWZM][นั้Gëñërætør ëxprëssïøñs mµst þë pærëñthësïzëð ïf ñøt sølë ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        generatorSyncReturnType: '[ASD1z][นั้Rëtµrñ tÿpë øf gëñërætør fµñçtïøñ mµst þë çømpætïþlë wïth "Generator[{yieldType}, Any, Any]"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        genericBaseClassNotAllowed: '[fniUT][นั้"Generic" þæsë çlæss çæññøt þë µsëð wïth tÿpë pæræmëtër sÿñtæxẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        genericClassAssigned: '[iU1tH][นั้Gëñërïç çlæss tÿpë çæññøt þë æssïgñëðẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        genericClassDeleted: '[C942e][นั้Gëñërïç çlæss tÿpë çæññøt þë ðëlëtëðẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        genericInstanceVariableAccess: '[rpanq][นั้Æççëss tø gëñërïç ïñstæñçë værïæþlë thrøµgh çlæss ïs æmþïgµøµsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        genericNotAllowed: '[vnF07][นั้"Generic" ïs ñøt vælïð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        genericTypeAliasBoundTypeVar: '[S1NAS][นั้Gëñërïç tÿpë ælïæs wïthïñ çlæss çæññøt µsë þøµñð tÿpë værïæþlës {ñæmës}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        genericTypeArgMissing: '[OlCEv][นั้"Generic" rëqµïrës æt lëæst øñë tÿpë ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        genericTypeArgTypeVar: '[09E7H][นั้Tÿpë ærgµmëñt før "Generic" mµst þë æ tÿpë værïæþlëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        genericTypeArgUnique: '[xHwpY][นั้Tÿpë ærgµmëñts før "Generic" mµst þë µñïqµëẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        globalReassignment: '[B2UyK][นั้"{ñæmë}" ïs æssïgñëð þëførë global ðëçlærætïøñẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        globalRedefinition: '[UZSMp][นั้"{ñæmë}" wæs ælrëæðÿ ðëçlærëð globalẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        implicitStringConcat: '[t0D1l][นั้Ïmplïçït strïñg çøñçætëñætïøñ ñøt ælløwëðẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        importCycleDetected: '[FFPSZ][นั้Çÿçlë ðëtëçtëð ïñ ïmpørt çhæïñẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        importDepthExceeded: '[8G4s1][นั้Ïmpørt çhæïñ ðëpth ëxçëëðëð {ðëpth}Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        importResolveFailure: '[oBYA4][นั้Ïmpørt "{ïmpørtÑæmë}" çøµlð ñøt þë rësølvëðẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        importSourceResolveFailure: '[hjHFa][นั้Ïmpørt "{ïmpørtÑæmë}" çøµlð ñøt þë rësølvëð frøm søµrçëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        importSymbolUnknown: '[jY9ZH][นั้"{ñæmë}" ïs µñkñøwñ ïmpørt sÿmþølẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        incompatibleMethodOverride: '[i45Ka][นั้Mëthøð "{ñæmë}" øvërrïðës çlæss "{çlæssÑæmë}" ïñ æñ ïñçømpætïþlë mæññërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        inconsistentIndent: '[gdrcy][นั้Üñïñðëñt æmøµñt ðøës ñøt mætçh prëvïøµs ïñðëñtẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        inconsistentTabs: '[I3Z6K][นั้Ïñçøñsïstëñt µsë øf tæþs æñð spæçës ïñ ïñðëñtætïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        initMethodSelfParamTypeVar: '[S5RC7][นั้Tÿpë æññøtætïøñ før "self" pæræmëtër øf "__init__" mëthøð çæññøt çøñtæïñ çlæss-sçøpëð tÿpë værïæþlësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        initMustReturnNone: '[RlXyC][นั้Rëtµrñ tÿpë øf "__init__" mµst þë NoneẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        initSubclassCallFailed: '[w22Kh][นั้Ïñçørrëçt këÿwørð ærgµmëñts før __init_subclass__ mëthøðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        initSubclassClsParam: '[6CWuS][นั้__init_subclass__ øvërrïðë shøµlð tækë æ "cls" pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        initVarNotAllowed: '[Bb6V0][นั้"InitVar" ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        instanceMethodSelfParam: '[dPZPj][นั้Ïñstæñçë mëthøðs shøµlð tækë æ "self" pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        instanceVarOverridesClassVar: '[cfYeg][นั้Ïñstæñçë værïæþlë "{ñæmë}" øvërrïðës çlæss værïæþlë øf sæmë ñæmë ïñ çlæss "{çlæssÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        instantiateAbstract: '[IyeLb][นั้Çæññøt ïñstæñtïætë æþstræçt çlæss "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        instantiateProtocol: '[Xa6p2][นั้Çæññøt ïñstæñtïætë Protocol çlæss "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        internalBindError: '[PnkgK][นั้Æñ ïñtërñæl ërrør øççµrrëð whïlë þïñðïñg fïlë "{fïlë}": {mëssægë}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        internalParseError: '[T91nL][นั้Æñ ïñtërñæl ërrør øççµrrëð whïlë pærsïñg fïlë "{fïlë}": {mëssægë}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        internalTypeCheckingError: '[9E5Bn][นั้Æñ ïñtërñæl ërrør øççµrrëð whïlë tÿpë çhëçkïñg fïlë "{fïlë}": {mëssægë}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        invalidIdentifierChar: '[Vpy5i][นั้Ïñvælïð çhæræçtër ïñ ïðëñtïfïërẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        invalidStubStatement: '[sxuu1][นั้§tætëmëñt ïs mëæñïñglëss wïthïñ æ tÿpë stub fïlëẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        invalidTokenChars: '[n9Jty][นั้Ïñvælïð çhæræçtër "{tëxt}" ïñ tøkëñẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        isInstanceInvalidType: '[Q3jK3][นั้§ëçøñð ærgµmëñt tø "isinstance" mµst þë æ çlæss ør tuple øf çlæssësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        isSubclassInvalidType: '[6Q7qf][นั้§ëçøñð ærgµmëñt tø "issubclass" mµst þë æ çlæss ør tuple øf çlæssësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        keyValueInSet: '[tmmyt][นั้Këÿ/vælµë pæïrs ærë ñøt ælløwëð wïthïñ æ setẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        keywordArgInTypeArgument: '[BzcKx][นั้Këÿwørð ærgµmëñts çæññøt þë µsëð ïñ tÿpë ærgµmëñt lïstsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        keywordArgShortcutIllegal: '[KU0tn][นั้Këÿwørð ærgµmëñt shørtçµt rëqµïrës Pÿthøñ 3.14 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        keywordOnlyAfterArgs: '[RLvT4][นั้Këÿwørð-øñlÿ ærgµmëñt sëpærætør ñøt ælløwëð æftër "*" pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        keywordParameterMissing: '[gTcAl][นั้Øñë ør mørë këÿwørð pæræmëtërs mµst følløw "*" pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        keywordSubscriptIllegal: '[khu47][นั้Këÿwørð ærgµmëñts wïthïñ sµþsçrïpts ærë ñøt sµppørtëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        lambdaReturnTypePartiallyUnknown: '[Z5ML1][นั้Rëtµrñ tÿpë øf læmþðæ, "{rëtµrñTÿpë}", ïs pærtïællÿ µñkñøwñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        lambdaReturnTypeUnknown: '[h4icY][นั้Rëtµrñ tÿpë øf læmþðæ ïs µñkñøwñẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        listAssignmentMismatch: '[DZh64][นั้Ëxprëssïøñ wïth tÿpë "{tÿpë}" çæññøt þë æssïgñëð tø tærgët lïstẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        listInAnnotation: '[i5U8t][นั้List ëxprëssïøñ ñøt ælløwëð ïñ tÿpë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        literalEmptyArgs: '[VkrFm][นั้Ëxpëçtëð øñë ør mørë tÿpë ærgµmëñts æftër "Literal"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        literalNamedUnicodeEscape: '[8cbe7][นั้Ñæmëð µñïçøðë ësçæpë sëqµëñçës ærë ñøt sµppørtëð ïñ "Literal" strïñg æññøtætïøñsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        literalNotAllowed: '[FAk6E][นั้"Literal" çæññøt þë µsëð ïñ thïs çøñtëxt wïthøµt æ tÿpë ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        literalNotCallable: '[C75sx][นั้Literal tÿpë çæññøt þë ïñstæñtïætëðẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        literalUnsupportedType: '[10Yse][นั้Tÿpë ærgµmëñts før "Literal" mµst þë None, æ lïtëræl vælµë (int, bool, str, ør bytes), ør æñ enum vælµëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        matchIncompatible: '[9ljpM][นั้Match stætëmëñts rëqµïrë Pÿthøñ 3.10 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        matchIsNotExhaustive: '[BJ8EI][นั้Çæsës wïthïñ match stætëmëñt ðø ñøt ëxhæµstïvëlÿ hæñðlë æll vælµësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        maxParseDepthExceeded: '[5nAZx][นั้Mæxïmµm pærsë ðëpth ëxçëëðëð; þrëæk ëxprëssïøñ ïñtø smællër sµþ-ëxprëssïøñsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        memberAccess: '[YP5V0][นั้Çæññøt æççëss ættrïþµtë "{ñæmë}" før çlæss "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        memberDelete: '[o47cn][นั้Çæññøt ðëlëtë ættrïþµtë "{ñæmë}" før çlæss "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        memberSet: '[JCDqa][นั้Çæññøt æssïgñ tø ættrïþµtë "{ñæmë}" før çlæss "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        metaclassConflict: '[XgAJj][นั้Thë mëtæçlæss øf æ ðërïvëð çlæss mµst þë æ sµþçlæss øf thë mëtæçlæssës øf æll ïts þæsë çlæssësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        metaclassDuplicate: '[wrGuH][นั้Øñlÿ øñë mëtæçlæss çæñ þë prøvïðëðẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        metaclassIsGeneric: '[K5fXC][นั้Mëtæçlæss çæññøt þë gëñërïçẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        methodNotDefined: '[ZuPf7][นั้"{ñæmë}" mëthøð ñøt ðëfïñëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        methodNotDefinedOnType: '[sEtO5][นั้"{ñæmë}" mëthøð ñøt ðëfïñëð øñ tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        methodOrdering: '[0M0tn][นั้Çæññøt çrëætë çøñsïstëñt mëthøð ørðërïñgẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        methodOverridden: '[2Bu15][นั้"{ñæmë}" øvërrïðës mëthøð øf sæmë ñæmë ïñ çlæss "{çlæssÑæmë}" wïth ïñçømpætïþlë tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        methodReturnsNonObject: '[9nnVb][นั้"{ñæmë}" mëthøð ðøës ñøt rëtµrñ æñ øþjëçtẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        missingSuperCall: '[jNXGA][นั้Mëthøð "{mëthøðÑæmë}" ðøës ñøt çæll thë mëthøð øf thë sæmë ñæmë ïñ pærëñt çlæssẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        mixingBytesAndStr: '[Ng6gL][นั้Bytes æñð str vælµës çæññøt þë çøñçætëñætëðẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        moduleAsType: '[p9N4B][นั้Møðµlë çæññøt þë µsëð æs æ tÿpëẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        moduleNotCallable: '[YY0Jq][นั้Møðµlë ïs ñøt çællæþlëẤğ倪İЂҰक्र्นั้ढूँ]',
        moduleUnknownMember: '[tegoa][นั้"{mëmþërÑæmë}" ïs ñøt æ kñøwñ ættrïþµtë øf møðµlë "{møðµlëÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        namedExceptAfterCatchAll: '[pMR1l][นั้Æ ñæmëð except çlæµsë çæññøt æppëær æftër çætçh-æll except çlæµsëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        namedParamAfterParamSpecArgs: '[sF38r][นั้Këÿwørð pæræmëtër "{ñæmë}" çæññøt æppëær ïñ sïgñætµrë æftër ParamSpec args pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        namedTupleEmptyName: '[vnXqF][นั้Ñæmës wïthïñ æ ñæmëð tuple çæññøt þë ëmptÿẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        namedTupleEntryRedeclared: '[0tiaC][นั้Çæññøt øvërrïðë "{ñæmë}" þëçæµsë pærëñt çlæss "{çlæssÑæmë}" ïs æ ñæmëð tupleẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        namedTupleFirstArg: '[L5ZXq][นั้Ëxpëçtëð ñæmëð tuple çlæss ñæmë æs fïrst ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        namedTupleMultipleInheritance: '[KYJOA][นั้Mµltïplë ïñhërïtæñçë wïth NamedTuple ïs ñøt sµppørtëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        namedTupleNameKeyword: '[g6NTa][นั้Fïëlð ñæmës çæññøt þë æ këÿwørðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        namedTupleNameType: '[AxfdS][นั้Ëxpëçtëð twø-ëñtrÿ tuple spëçïfÿïñg ëñtrÿ ñæmë æñð tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        namedTupleNameUnique: '[TQaej][นั้Ñæmës wïthïñ æ ñæmëð tuple mµst þë µñïqµëẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        namedTupleNoTypes: '[Fn6FF][นั้"ñæmëðtµplë" prøvïðës ñø tÿpës før tµplë ëñtrïës; µsë "ÑæmëðTµplë" ïñstëæðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        namedTupleSecondArg: '[SqoXY][นั้Ëxpëçtëð ñæmëð tuple ëñtrÿ list æs sëçøñð ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        newClsParam: '[EUESX][นั้__new__ øvërrïðë shøµlð tækë æ "cls" pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        newTypeAnyOrUnknown: '[D4ZjA][นั้Thë sëçøñð ærgµmëñt tø NewType mµst þë æ kñøwñ çlæss, ñøt Any ør UnknownẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        newTypeBadName: '[cqWvO][นั้Thë fïrst ærgµmëñt tø NewType mµst þë æ strïñg lïtërælẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        newTypeLiteral: '[4k8om][นั้NewType çæññøt þë µsëð wïth Literal tÿpëẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        newTypeNameMismatch: '[kQgMv][นั้NewType mµst þë æssïgñëð tø æ værïæþlë wïth thë sæmë ñæmëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        newTypeNotAClass: '[ta6tZ][นั้Ëxpëçtëð çlæss æs sëçøñð ærgµmëñt tø NewTypeẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        newTypeParamCount: '[6b2ro][นั้NewType rëqµïrës twø pøsïtïøñæl ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        newTypeProtocolClass: '[1l02t][นั้NewType çæññøt þë µsëð wïth strµçtµræl tÿpë (æ Protocol ør TypedDict çlæss)Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        noOverload: '[IcBNQ][นั้Ñø øvërløæðs før "{ñæmë}" mætçh thë prøvïðëð ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        noReturnContainsReturn: '[nBLDq][นั้Fµñçtïøñ wïth ðëçlærëð return tÿpë "NoReturn" çæññøt ïñçlµðë æ return stætëmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        noReturnContainsYield: '[V3G36][นั้Fµñçtïøñ wïth ðëçlærëð rëtµrñ tÿpë "NoReturn" çæññøt ïñçlµðë æ yield stætëmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        noReturnReturnsNone: '[O3XA6][นั้Fµñçtïøñ wïth ðëçlærëð rëtµrñ tÿpë "NoReturn" çæññøt rëtµrñ "None"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        nonDefaultAfterDefault: '[mFFgP][นั้Ñøñ-ðëfæµlt ærgµmëñt følløws ðëfæµlt ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        nonLocalInModule: '[kmLlv][นั้Nonlocal ðëçlærætïøñ ñøt ælløwëð æt møðµlë lëvëlẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        nonLocalNoBinding: '[WTA2d][นั้Ñø þïñðïñg før nonlocal "{ñæmë}" føµñðẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        nonLocalReassignment: '[T1M6J][นั้"{ñæmë}" ïs æssïgñëð þëførë nonlocal ðëçlærætïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        nonLocalRedefinition: '[gwh1h][นั้"{ñæmë}" wæs ælrëæðÿ ðëçlærëð nonlocalẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        noneNotCallable: '[sIZ5J][นั้Øþjëçt øf tÿpë "None" çæññøt þë çællëðẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        noneNotIterable: '[spDD0][นั้Øþjëçt øf tÿpë "None" çæññøt þë µsëð æs ïtëræþlë vælµëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        noneNotSubscriptable: '[Emzwj][นั้Øþjëçt øf tÿpë "None" ïs ñøt sµþsçrïptæþlëẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        noneNotUsableWith: '[zlOOD][นั้Øþjëçt øf tÿpë "None" çæññøt þë µsëð with "with"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        noneOperator: '[3U0d3][นั้Øpërætør "{øpërætør}" ñøt sµppørtëð før "None"Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        noneUnknownMember: '[4KvEX][นั้"{ñæmë}" ïs ñøt æ kñøwñ ættrïþµtë øf "None"Ấğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        notRequiredArgCount: '[uOeAb][นั้Ëxpëçtëð æ sïñglë tÿpë ærgµmëñt æftër "NotRequired"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        notRequiredNotInTypedDict: '[Vl6XL][นั้"NotRequired" ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        objectNotCallable: '[bzlKk][นั้Øþjëçt øf tÿpë "{tÿpë}" ïs ñøt çællæþlëẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        obscuredClassDeclaration: '[ixjN9][นั้Çlæss ðëçlærætïøñ "{ñæmë}" ïs øþsçµrëð þÿ æ ðëçlærætïøñ øf thë sæmë ñæmëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        obscuredFunctionDeclaration: '[O71DX][นั้Fµñçtïøñ ðëçlærætïøñ "{ñæmë}" ïs øþsçµrëð þÿ æ ðëçlærætïøñ øf thë sæmë ñæmëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        obscuredMethodDeclaration: '[m04yf][นั้Mëthøð ðëçlærætïøñ "{ñæmë}" ïs øþsçµrëð þÿ æ ðëçlærætïøñ øf thë sæmë ñæmëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        obscuredParameterDeclaration: '[NaF76][นั้Pæræmëtër ðëçlærætïøñ "{ñæmë}" ïs øþsçµrëð þÿ æ ðëçlærætïøñ øf thë sæmë ñæmëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        obscuredTypeAliasDeclaration: '[0GZdR][นั้Tÿpë ælïæs ðëçlærætïøñ "{ñæmë}" ïs øþsçµrëð þÿ æ ðëçlærætïøñ øf thë sæmë ñæmëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        obscuredVariableDeclaration: '[HR10j][นั้Ðëçlærætïøñ "{ñæmë}" ïs øþsçµrëð þÿ æ ðëçlærætïøñ øf thë sæmë ñæmëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        operatorLessOrGreaterDeprecated: '[bNZp7][นั้Øpërætør "<>" ïs ñøt sµppørtëð ïñ Pÿthøñ 3; µsë "!=" ïñstëæðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        optionalExtraArgs: '[yW5W0][นั้Ëxpëçtëð øñë tÿpë ærgµmëñt æftër "Optional"Ấğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        orPatternIrrefutable: '[peFRW][นั้Ïrrëfµtæþlë pættërñ ælløwëð øñlÿ æs thë læst sµþpættërñ ïñ æñ "or" pættërñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        orPatternMissingName: '[OxMxP][นั้Æll sµþpættërñs wïthïñ æñ "or" pættërñ mµst tærgët thë sæmë ñæmësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        overlappingKeywordArgs: '[46dQE][นั้Tÿpëð ðïçtïøñærÿ øvërlæps wïth këÿwørð pæræmëtër: {ñæmës}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        overlappingOverload: '[SCQMv][นั้Øvërløæð {øþsçµrëð} før "{ñæmë}" wïll ñëvër þë µsëð þëçæµsë ïts pæræmëtërs øvërlæp øvërløæð {øþsçµrëðßÿ}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        overloadAbstractImplMismatch: '[IgMzu][นั้Øvërløæðs mµst mætçh æþstræçt stætµs øf ïmplëmëñtætïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        overloadAbstractMismatch: '[54DCM][นั้Øvërløæðs mµst æll þë æþstræçt ør ñøtẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        overloadClassMethodInconsistent: '[8y6vM][นั้Øvërløæðs før "{ñæmë}" µsë @classmethod ïñçøñsïstëñtlÿẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        overloadFinalInconsistencyImpl: '[0hpZY][นั้Øvërløæð før "{ñæmë}" ïs mærkëð @final þµt ïmplëmëñtætïøñ ïs ñøtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        overloadFinalInconsistencyNoImpl: '[Z6TSL][นั้Øvërløæð {ïñðëx} før "{ñæmë}" ïs mærkëð @final þµt øvërløæð 1 ïs ñøtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        overloadImplementationMismatch: '[dXlXE][นั้Øvërløæðëð ïmplëmëñtætïøñ ïs ñøt çøñsïstëñt wïth sïgñætµrë øf øvërløæð {ïñðëx}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        overloadReturnTypeMismatch: '[6BN74][นั้Øvërløæð {prëvÏñðëx} før "{ñæmë}" øvërlæps øvërløæð {ñëwÏñðëx} æñð rëtµrñs æñ ïñçømpætïþlë tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        overloadStaticMethodInconsistent: '[PKQvM][นั้Øvërløæðs før "{ñæmë}" µsë @staticmethod ïñçøñsïstëñtlÿẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        overloadWithoutImplementation: '[mn33a][นั้"{ñæmë}" ïs mærkëð æs overload, þµt ñø ïmplëmëñtætïøñ ïs prøvïðëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        overriddenMethodNotFound: '[YKdBy][นั้Mëthøð "{ñæmë}" ïs mærkëð æs override, þµt ñø þæsë mëthøð øf sæmë ñæmë ïs prësëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        overrideDecoratorMissing: '[2BnJq][นั้Mëthøð "{ñæmë}" ïs ñøt mærkëð æs override þµt ïs øvërrïðïñg æ mëthøð ïñ çlæss "{çlæssÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        paramAfterKwargsParam: '[wJZkp][นั้Pæræmëtër çæññøt følløw "**" pæræmëtërẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        paramAlreadyAssigned: '[srzhT][นั้Pæræmëtër "{ñæmë}" ïs ælrëæðÿ æssïgñëðẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        paramAnnotationMissing: '[1OYGc][นั้Tÿpë æññøtætïøñ ïs mïssïñg før pæræmëtër "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        paramAssignmentMismatch: '[Q8zha][นั้Ëxprëssïøñ øf tÿpë "{søµrçëTÿpë}" çæññøt þë æssïgñëð tø pæræmëtër øf tÿpë "{pæræmTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        paramNameMissing: '[ivXu4][นั้Ñø pæræmëtër ñæmëð "{ñæmë}"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        paramSpecArgsKwargsDuplicate: '[4Ie64][นั้Ærgµmëñts før ParamSpec "{tÿpë}" hævë ælrëæðÿ þëëñ prøvïðëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        paramSpecArgsKwargsUsage: '[oVRV0][นั้"args" æñð "kwargs" ættrïþµtës øf ParamSpec mµst þøth æppëær wïthïñ æ fµñçtïøñ sïgñætµrëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        paramSpecArgsMissing: '[rd6zO][นั้Ærgµmëñts før ParamSpec "{tÿpë}" ærë mïssïñgẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        paramSpecArgsUsage: '[2U9SN][นั้"args" ættrïþµtë øf ParamSpec ïs vælïð øñlÿ whëñ µsëð wïth *args pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        paramSpecAssignedName: '[ww5mM][นั้ParamSpec mµst þë æssïgñëð tø æ værïæþlë ñæmëð "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        paramSpecContext: '[y6xyK][นั้ParamSpec ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        paramSpecDefaultNotTuple: '[6Tdff][นั้Ëxpëçtëð ëllïpsïs, æ tuple ëxprëssïøñ, ør ParamSpec før ðëfæµlt vælµë øf ParamSpecẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        paramSpecFirstArg: '[W2Y3X][นั้Ëxpëçtëð ñæmë øf ParamSpec æs fïrst ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        paramSpecKwargsUsage: '[2UE71][นั้"kwargs" ættrïþµtë øf ParamSpec ïs vælïð øñlÿ whëñ µsëð wïth **kwargs pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        paramSpecNotUsedByOuterScope: '[5Pk7H][นั้ParamSpec "{ñæmë}" hæs ñø mëæñïñg ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        paramSpecUnknownArg: '[6zeYc][นั้ParamSpec ðøës ñøt sµppørt mørë thæñ øñë ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        paramSpecUnknownMember: '[GhhiY][นั้"{ñæmë}" ïs ñøt æ kñøwñ ættrïþµtë øf ParamSpecẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        paramSpecUnknownParam: '[YADLo][นั้"{ñæmë}" ïs µñkñøwñ pæræmëtër tø ParamSpecẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        paramTypeCovariant: '[USAuF][นั้Çøværïæñt tÿpë værïæþlë çæññøt þë µsëð ïñ pæræmëtër tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        paramTypePartiallyUnknown: '[1ShLP][นั้Tÿpë øf pæræmëtër "{pæræmÑæmë}" ïs pærtïællÿ µñkñøwñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        paramTypeUnknown: '[fweDh][นั้Tÿpë øf pæræmëtër "{pæræmÑæmë}" ïs µñkñøwñẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        parenthesizedContextManagerIllegal: '[NBxCb][นั้Pærëñthësës withïñ "with" stætëmëñt rëqµïrës Pÿthøñ 3.9 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        patternNeverMatches: '[lyG7p][นั้Pættërñ wïll ñëvër þë mætçhëð før sµþjëçt tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        positionArgAfterNamedArg: '[szCz2][นั้Pøsïtïøñæl ærgµmëñt çæññøt æppëær æftër këÿwørð ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        positionOnlyAfterArgs: '[Vqb7c][นั้Pøsïtïøñ-øñlÿ pæræmëtër sëpærætør ñøt ælløwëð æftër "*" pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        positionOnlyAfterKeywordOnly: '[z1FIK][นั้"/" pæræmëtër mµst æppëær þëførë "*" pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        positionOnlyAfterNon: '[iXb2r][นั้Pøsïtïøñ-øñlÿ pæræmëtër ñøt ælløwëð æftër pæræmëtër thæt ïs ñøt pøsïtïøñ-øñlÿẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        positionOnlyFirstParam: '[bmnbs][นั้Pøsïtïøñ-øñlÿ pæræmëtër sëpærætør ñøt ælløwëð æs fïrst pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        positionOnlyIncompatible: '[Ick28][นั้Pøsïtïøñ-øñlÿ pæræmëtër sëpærætør rëqµïrës Pÿthøñ 3.8 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        privateImportFromPyTypedModule: '[VRdf4][นั้"{ñæmë}" ïs ñøt ëxpørtëð frøm møðµlë "{møðµlë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        privateUsedOutsideOfClass: '[3YBNL][นั้"{ñæmë}" ïs prïvætë æñð µsëð øµtsïðë øf thë çlæss ïñ whïçh ït ïs ðëçlærëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        privateUsedOutsideOfModule: '[TgDgt][นั้"{ñæmë}" ïs prïvætë æñð µsëð øµtsïðë øf thë møðµlë ïñ whïçh ït ïs ðëçlærëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        propertyOverridden: '[mwp5C][นั้"{ñæmë}" ïñçørrëçtlÿ øvërrïðës property øf sæmë ñæmë ïñ çlæss "{çlæssÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        propertyStaticMethod: '[qs3pr][นั้§tætïç mëthøðs ñøt ælløwëð før property getter, setter ør deleterẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        protectedUsedOutsideOfClass: '[z2Y7X][นั้"{ñæmë}" ïs prøtëçtëð æñð µsëð øµtsïðë øf thë çlæss ïñ whïçh ït ïs ðëçlærëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        protocolBaseClass: '[lv3rP][นั้Protocol çlæss "{çlæssTÿpë}" çæññøt ðërïvë frøm ñøñ-Protocol çlæss "{þæsëTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        protocolBaseClassWithTypeArgs: '[tpYEx][นั้Tÿpë ærgµmëñts ærë ñøt ælløwëð wïth Protocol çlæss whëñ µsïñg tÿpë pæræmëtër sÿñtæxẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        protocolIllegal: '[jYjYe][นั้Üsë øf "Protocol" rëqµïrës Pÿthøñ 3.7 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        protocolNotAllowed: '[2GEt6][นั้"Protocol" çæññøt þë µsëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        protocolTypeArgMustBeTypeParam: '[WTgkM][นั้Tÿpë ærgµmëñt før "Protocol" mµst þë æ tÿpë pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        protocolUnsafeOverlap: '[79LbC][นั้Çlæss øvërlæps "{ñæmë}" µñsæfëlÿ æñð çøµlð prøðµçë æ mætçh æt rµñtïmëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        protocolVarianceContravariant: '[B4htZ][นั้Tÿpë værïæþlë "{værïæþlë}" µsëð ïñ gëñërïç Protocol "{çlæss}" shøµlð þë çøñtræværïæñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        protocolVarianceCovariant: '[Hcnn5][นั้Tÿpë værïæþlë "{værïæþlë}" µsëð ïñ gëñërïç Protocol "{çlæss}" shøµlð þë çøværïæñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        protocolVarianceInvariant: '[o8oB7][นั้Tÿpë værïæþlë "{værïæþlë}" µsëð ïñ gëñërïç Protocol "{çlæss}" shøµlð þë ïñværïæñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        pyrightCommentInvalidDiagnosticBoolValue: '[eaJY0][นั้Pyright çømmëñt ðïrëçtïvë mµst þë følløwëð þÿ "=" æñð æ vælµë øf true ør falseẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        pyrightCommentInvalidDiagnosticSeverityValue: '[2YA7K][นั้Pyright çømmëñt ðïrëçtïvë mµst þë følløwëð þÿ "=" æñð æ vælµë øf true, false, error, warning, information, ør noneẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        pyrightCommentMissingDirective: '[yy6rB][นั้Pyright çømmëñt mµst þë følløwëð þÿ æ ðïrëçtïvë (basic ør strict) ør æ ðïægñøstïç rµlëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        pyrightCommentNotOnOwnLine: '[mM2bV][นั้Pyright çømmëñts µsëð tø çøñtrøl fïlë-lëvël sëttïñgs mµst æppëær øñ thëïr øwñ lïñëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        pyrightCommentUnknownDiagnosticRule: '[DFAZp][นั้"{rµlë}" ïs æñ µñkñøwñ ðïægñøstïç rµlë før pyright çømmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        pyrightCommentUnknownDiagnosticSeverityValue: '[Tgt0Y][นั้"{vælµë}" ïs ïñvælïð vælµë før pyright çømmëñt; ëxpëçtëð true, false, error, warning, information, ør noneẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        pyrightCommentUnknownDirective: '[HD6T4][นั้"{ðïrëçtïvë}" ïs æñ µñkñøwñ ðïrëçtïvë før pyright çømmëñt; ëxpëçtëð "strict" ør "basic"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        readOnlyArgCount: '[B1Erm][นั้Ëxpëçtëð æ sïñglë tÿpë ærgµmëñt æftër "ReadOnly"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        readOnlyNotInTypedDict: '[xJrLN][นั้"ReadOnly" ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        recursiveDefinition: '[G3UUN][นั้Tÿpë øf "{ñæmë}" çøµlð ñøt þë ðëtërmïñëð þëçæµsë ït rëfërs tø ïtsëlfẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        relativeImportNotAllowed: '[JZqjC][นั้Rëlætïvë ïmpørts çæññøt þë µsëð wïth "import .a" førm; µsë "from . import a" ïñstëæðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        requiredArgCount: '[aZX4z][นั้Ëxpëçtëð æ sïñglë tÿpë ærgµmëñt æftër "Required"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        requiredNotInTypedDict: '[TArW6][นั้"Required" ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        returnInAsyncGenerator: '[qb5pt][นั้Rëtµrñ stætëmëñt wïth vælµë ïs ñøt ælløwëð ïñ async gëñërætørẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        returnInExceptionGroup: '[wRRjc][นั้"return" ïs ñøt ælløwëð ïñ æñ "except*" þløçkẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        returnMissing: '[kPevK][นั้Fµñçtïøñ wïth ðëçlærëð rëtµrñ tÿpë "{rëtµrñTÿpë}" mµst rëtµrñ vælµë øñ æll çøðë pæthsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        returnOutsideFunction: '[O4SJp][นั้"return" çæñ þë µsëð øñlÿ wïthïñ æ fµñçtïøñẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        returnTypeContravariant: '[KkMhh][นั้Çøñtræværïæñt tÿpë værïæþlë çæññøt þë µsëð ïñ rëtµrñ tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        returnTypeMismatch: '[QYqHy][นั้Tÿpë "{ëxprTÿpë}" ïs ñøt æssïgñæþlë tø rëtµrñ tÿpë "{rëtµrñTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        returnTypePartiallyUnknown: '[261DZ][นั้Rëtµrñ tÿpë, "{rëtµrñTÿpë}", ïs pærtïællÿ µñkñøwñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        returnTypeUnknown: '[II3Ix][นั้Rëtµrñ tÿpë ïs µñkñøwñẤğ倪İЂҰक्र्นั้ढूँ]',
        revealLocalsArgs: '[qKEIL][นั้Ëxpëçtëð ñø ærgµmëñts før "reveal_locals" çællẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        revealLocalsNone: '[xOTfI][นั้Ñø locals ïñ thïs sçøpëẤğ倪İЂҰक्र्นั้ढूँ]',
        revealTypeArgs: '[Sdo9V][นั้Ëxpëçtëð æ sïñglë pøsïtïøñæl ærgµmëñt før "reveal_type" çællẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        revealTypeExpectedTextArg: '[6cFBk][นั้Thë "expected_text" ærgµmëñt før fµñçtïøñ "reveal_type" mµst þë æ str lïtëræl vælµëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        revealTypeExpectedTextMismatch: '[ILnEV][นั้Tÿpë tëxt mïsmætçh; ëxpëçtëð "{ëxpëçtëð}" þµt rëçëïvëð "{rëçëïvëð}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        revealTypeExpectedTypeMismatch: '[3XS8T][นั้Tÿpë mïsmætçh; ëxpëçtëð "{ëxpëçtëð}" þµt rëçëïvëð "{rëçëïvëð}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        selfTypeContext: '[Hugyy][นั้"Self" ïs ñøt vælïð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        selfTypeMetaclass: '[YvoBy][นั้"Self" çæññøt þë µsëð wïthïñ æ mëtæçlæss (æ sµþçlæss øf "tÿpë")Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        selfTypeWithTypedSelfOrCls: '[sYgyY][นั้"Self" çæññøt þë µsëð ïñ æ fµñçtïøñ wïth æ `self` ør `cls` pæræmëtër thæt hæs æ tÿpë æññøtætïøñ øthër thæñ "Self"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        setterGetterTypeMismatch: '[8ZD1z][นั้Property setter vælµë tÿpë ïs ñøt æssïgñæþlë tø thë getter rëtµrñ tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        singleOverload: '[YQVUc][นั้"{ñæmë}" ïs mærkëð æs øvërløæð, þµt æððïtïøñæl øvërløæðs ærë mïssïñgẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        slotsAttributeError: '[OF4rK][นั้"{ñæmë}" ïs ñøt spëçïfïëð ïñ __slots__Ấğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        slotsClassVarConflict: '[tcS3q][นั้"{ñæmë}" çøñflïçts wïth ïñstæñçë værïæþlë ðëçlærëð ïñ __slots__Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        starPatternInAsPattern: '[ZFdWe][นั้§tær pættërñ çæññøt þë µsëð wïth "as" tærgëtẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        starPatternInOrPattern: '[y9LX3][นั้§tær pættërñ çæññøt þë ØRëð wïthïñ øthër pættërñsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        starStarWildcardNotAllowed: '[Ll1UV][นั้** çæññøt þë µsëð wïth wïlðçærð "_"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        staticClsSelfParam: '[mO4QU][นั้§tætïç mëthøðs shøµlð ñøt tækë æ "self" ør "cls" pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        stdlibModuleOverridden: '[AV6K3][นั้"{pæth}" ïs øvërrïðïñg thë stdlib møðµlë "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        stringNonAsciiBytes: '[dFNRn][นั้Ñøñ-ASCII çhæræçtër ñøt ælløwëð ïñ þÿtës strïñg lïtërælẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        stringNotSubscriptable: '[hKZT7][นั้§trïñg ëxprëssïøñ çæññøt þë sµþsçrïptëð ïñ tÿpë ëxprëssïøñ; ëñçløsë ëñtïrë ëxprëssïøñ ïñ qµøtësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        stringUnsupportedEscape: '[K2WsY][นั้Üñsµppørtëð ësçæpë sëqµëñçë ïñ strïñg lïtërælẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        stringUnterminated: '[jUKYA][นั้§trïñg lïtëræl ïs µñtërmïñætëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        stubFileMissing: '[Ua5GT][นั้Stub fïlë ñøt føµñð før "{ïmpørtÑæmë}"Ấğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        stubUsesGetAttr: '[KMBwK][นั้Tÿpë stub fïlë ïs ïñçømplëtë; "__getattr__" øþsçµrës tÿpë ërrørs før møðµlëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        sublistParamsIncompatible: '[582LE][นั้Sublist pæræmëtërs ærë ñøt sµppørtëð ïñ Pÿthøñ 3.xẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        superCallArgCount: '[iLYq6][นั้Ëxpëçtëð ñø mørë thæñ twø ærgµmëñts tø "super" çællẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        superCallFirstArg: '[HSEvD][นั้Ëxpëçtëð çlæss tÿpë æs fïrst ærgµmëñt tø "super" çæll þµt rëçëïvëð "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        superCallSecondArg: '[dKoHi][นั้§ëçøñð ærgµmëñt tø "super" çæll mµst þë øþjëçt ør çlæss thæt ðërïvës frøm "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        superCallZeroArgForm: '[0XO27][นั้Zërø-ærgµmëñt førm øf "super" çæll ïs vælïð øñlÿ wïthïñ æ mëthøðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        superCallZeroArgFormStaticMethod: '[9hJPB][นั้Zërø-ærgµmëñt førm øf "super" çæll ïs ñøt vælïð wïthïñ æ stætïç mëthøðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        symbolIsPossiblyUnbound: '[cUgue][นั้"{ñæmë}" ïs pøssïþlÿ µñþøµñðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        symbolIsUnbound: '[zhGl5][นั้"{ñæmë}" ïs µñþøµñðẤğ倪İЂҰक्นั้ढूँ]',
        symbolIsUndefined: '[qCm6F][นั้"{ñæmë}" ïs ñøt ðëfïñëðẤğ倪İЂҰक्र्นั้ढूँ]',
        symbolOverridden: '[JwRrv][นั้"{ñæmë}" øvërrïðës sÿmþøl øf sæmë ñæmë ïñ çlæss "{çlæssÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        ternaryNotAllowed: '[5NH6C][นั้Tërñærÿ ëxprëssïøñ ñøt ælløwëð ïñ tÿpë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        totalOrderingMissingMethod: '[eYfjn][นั้Çlæss mµst ðëfïñë øñë øf "__lt__", "__le__", "__gt__", ør "__ge__" tø µsë total_orderingẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        trailingCommaInFromImport: '[NcaZY][นั้Træïlïñg çømmæ ñøt ælløwëð wïthøµt sµrrøµñðïñg pærëñthësësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        tryWithoutExcept: '[6z9oA][นั้Try stætëmëñt mµst hævë æt lëæst øñë except ør finally çlæµsëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        tupleAssignmentMismatch: '[xySRW][นั้Ëxprëssïøñ wïth tÿpë "{tÿpë}" çæññøt þë æssïgñëð tø tærgët tupleẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        tupleInAnnotation: '[j2RAZ][นั้Tuple ëxprëssïøñ ñøt ælløwëð ïñ tÿpë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        tupleIndexOutOfRange: '[aNqDv][นั้Ïñðëx {ïñðëx} ïs øµt øf ræñgë før tÿpë {tÿpë}Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typeAliasIllegalExpressionForm: '[4u4ay][นั้Ïñvælïð ëxprëssïøñ førm før tÿpë ælïæs ðëfïñïtïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeAliasIsRecursiveDirect: '[r8PyZ][นั้Tÿpë ælïæs "{ñæmë}" çæññøt µsë ïtsëlf ïñ ïts ðëfïñïtïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeAliasNotInModuleOrClass: '[iQpDJ][นั้Æ TypeAlias çæñ þë ðëfïñëð øñlÿ wïthïñ æ møðµlë ør çlæss sçøpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeAliasRedeclared: '[P036x][นั้"{ñæmë}" ïs ðëçlærëð æs æ TypeAlias æñð çæñ þë æssïgñëð øñlÿ øñçëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeAliasStatementBadScope: '[C24Up][นั้Æ type stætëmëñt çæñ þë µsëð øñlÿ wïthïñ æ møðµlë ør çlæss sçøpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeAliasStatementIllegal: '[2EW0Q][นั้Tÿpë ælïæs stætëmëñt rëqµïrës Pÿthøñ 3.12 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeAliasTypeBaseClass: '[RIpMs][นั้Æ tÿpë ælïæs ðëfïñëð ïñ æ "type" stætëmëñt çæññøt þë µsëð æs æ þæsë çlæssẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        typeAliasTypeMustBeAssigned: '[aV4Nn][นั้TypeAliasType mµst þë æssïgñëð tø æ værïæþlë wïth thë sæmë ñæmë æs thë tÿpë ælïæsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typeAliasTypeNameArg: '[dUUf1][นั้Fïrst ærgµmëñt tø TypeAliasType mµst þë æ strïñg lïtëræl rëprësëñtïñg thë ñæmë øf thë tÿpë ælïæsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeAliasTypeNameMismatch: '[jW1bQ][นั้Ñæmë øf tÿpë ælïæs mµst mætçh thë ñæmë øf thë værïæþlë tø whïçh ït ïs æssïgñëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        typeAliasTypeParamInvalid: '[RdHRE][นั้Tÿpë pæræmëtër lïst mµst þë æ tuple çøñtæïñïñg øñlÿ TypeVar, TypeVarTuple, ør ParamSpecẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeAnnotationCall: '[7pNts][นั้Çæll ëxprëssïøñ ñøt ælløwëð ïñ tÿpë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typeAnnotationVariable: '[GeXWQ][นั้Værïæþlë ñøt ælløwëð ïñ tÿpë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        typeAnnotationWithCallable: '[JJENJ][นั้Tÿpë ærgµmëñt før "type" mµst þë æ çlæss; çællæþlës ærë ñøt sµppørtëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typeArgListExpected: '[2efoA][นั้Ëxpëçtëð ParamSpec, ëllïpsïs, ør list øf tÿpësẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typeArgListNotAllowed: '[oV7JF][นั้List ëxprëssïøñ ñøt ælløwëð før thïs tÿpë ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeArgsExpectingNone: '[faycH][นั้Ëxpëçtëð ñø tÿpë ærgµmëñts før çlæss "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typeArgsMismatchOne: '[BBe1n][นั้Ëxpëçtëð øñë tÿpë ærgµmëñt þµt rëçëïvëð {rëçëïvëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeArgsMissingForAlias: '[hk8aw][นั้Ëxpëçtëð tÿpë ærgµmëñts før gëñërïç tÿpë ælïæs "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeArgsMissingForClass: '[SkdfG][นั้Ëxpëçtëð tÿpë ærgµmëñts før gëñërïç çlæss "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeArgsTooFew: '[6PAb0][นั้Tøø fëw tÿpë ærgµmëñts prøvïðëð før "{ñæmë}"; ëxpëçtëð {ëxpëçtëð} þµt rëçëïvëð {rëçëïvëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeArgsTooMany: '[NKF2Z][นั้Tøø mæñÿ tÿpë ærgµmëñts prøvïðëð før "{ñæmë}"; ëxpëçtëð {ëxpëçtëð} þµt rëçëïvëð {rëçëïvëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeAssignmentMismatch: '[wwjSP][นั้Tÿpë "{søµrçëTÿpë}" ïs ñøt æssïgñæþlë tø ðëçlærëð tÿpë "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeAssignmentMismatchWildcard: '[qdgVA][นั้Ïmpørt sÿmþøl "{ñæmë}" hæs tÿpë "{søµrçëTÿpë}", whïçh ïs ñøt æssïgñæþlë tø ðëçlærëð tÿpë "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeCallNotAllowed: '[OGMmG][นั้type() çæll shøµlð ñøt þë µsëð ïñ tÿpë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeCheckOnly: '[cSmKj][นั้"{ñæmë}" ïs mærkëð æs @type_check_only æñð çæñ þë µsëð øñlÿ ïñ tÿpë æññøtætïøñsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typeCommentDeprecated: '[SRhVz][นั้Üsë øf type çømmëñts ïs ðëprëçætëð; µsë type æññøtætïøñ ïñstëæðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeExpectedClass: '[r0pdu][นั้Ëxpëçtëð çlæss þµt rëçëïvëð "{tÿpë}"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typeFormArgs: '[ivrdh][นั้"TypeForm" æççëpts æ sïñglë pøsïtïøñæl ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        typeGuardArgCount: '[Zl47K][นั้Ëxpëçtëð æ sïñglë tÿpë ærgµmëñt æftër "TypeGuard" ør "TypeIs"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeGuardParamCount: '[I3HUH][นั้Üsër-ðëfïñëð tÿpë gµærð fµñçtïøñs æñð mëthøðs mµst hævë æt lëæst øñë ïñpµt pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeIsReturnType: '[5bBbd][นั้Rëtµrñ tÿpë øf TypeIs ("{rëtµrñTÿpë}") ïs ñøt çøñsïstëñt wïth vælµë pæræmëtër tÿpë ("{tÿpë}")Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeNotAwaitable: '[NZ9Yu][นั้"{tÿpë}" ïs ñøt awaitableẤğ倪İЂҰक्र्นั้ढूँ]',
        typeNotIntantiable: '[f3xEe][นั้"{tÿpë}" çæññøt þë ïñstæñtïætëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeNotIterable: '[XMDzF][นั้"{tÿpë}" ïs ñøt ïtëræþlëẤğ倪İЂҰक्र्นั้ढूँ]',
        typeNotSpecializable: '[ZCsyD][นั้Çøµlð ñøt spëçïælïzë tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typeNotSubscriptable: '[fpefi][นั้Øþjëçt øf tÿpë "{tÿpë}" ïs ñøt sµþsçrïptæþlëẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typeNotSupportBinaryOperator: '[C0OGX][นั้Øpërætør "{øpërætør}" ñøt sµppørtëð før tÿpës "{lëftTÿpë}" æñð "{rïghtTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        typeNotSupportBinaryOperatorBidirectional: '[25nah][นั้Øpërætør "{øpërætør}" ñøt sµppørtëð før tÿpës "{lëftTÿpë}" æñð "{rïghtTÿpë}" whëñ ëxpëçtëð tÿpë ïs "{ëxpëçtëðTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typeNotSupportUnaryOperator: '[f2pEG][นั้Øpërætør "{øpërætør}" ñøt sµppørtëð før tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeNotSupportUnaryOperatorBidirectional: '[Z51QN][นั้Øpërætør "{øpërætør}" ñøt sµppørtëð før tÿpë "{tÿpë}" whëñ ëxpëçtëð tÿpë ïs "{ëxpëçtëðTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeNotUsableWith: '[R7VpZ][นั้Øþjëçt øf tÿpë "{tÿpë}" çæññøt þë µsëð wïth "wïth" þëçæµsë ït ðøës ñøt ïmplëmëñt {mëthøð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeParameterBoundNotAllowed: '[iA0kz][นั้ßøµñð ør çøñstræïñt çæññøt þë µsëð wïth æ værïæðïç tÿpë pæræmëtër ør ParamSpecẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        typeParameterConstraintTuple: '[8wa57][นั้Tÿpë pæræmëtër çøñstræïñt mµst þë æ tµplë øf twø ør mørë tÿpësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeParameterExistingTypeParameter: '[M2QXP][นั้Tÿpë pæræmëtër "{ñæmë}" ïs ælrëæðÿ ïñ µsëẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        typeParameterNotDeclared: '[WD9B6][นั้Tÿpë pæræmëtër "{ñæmë}" ïs ñøt ïñçlµðëð ïñ thë tÿpë pæræmëtër lïst før "{çøñtæïñër}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeParametersMissing: '[7nPE2][นั้Æt lëæst øñë tÿpë pæræmëtër mµst þë spëçïfïëðẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typePartiallyUnknown: '[K72xm][นั้Tÿpë øf "{ñæmë}" ïs pærtïællÿ µñkñøwñẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        typeUnknown: '[flab2][นั้Tÿpë øf "{ñæmë}" ïs µñkñøwñẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeVarAssignedName: '[AnBke][นั้TypeVar mµst þë æssïgñëð tø æ værïæþlë ñæmëð "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeVarAssignmentMismatch: '[IYCuH][นั้Tÿpë "{tÿpë}" çæññøt þë æssïgñëð tø tÿpë værïæþlë "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeVarBoundAndConstrained: '[nSFES][นั้TypeVar çæññøt þë þøth þøµñð æñð çøñstræïñëðẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typeVarBoundGeneric: '[scFkM][นั้TypeVar þøµñð tÿpë çæññøt þë gëñërïçẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typeVarConstraintGeneric: '[k7N05][นั้TypeVar çøñstræïñt tÿpë çæññøt þë gëñërïçẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        typeVarDefaultBoundMismatch: '[knxtI][นั้TypeVar ðëfæµlt tÿpë mµst þë æ sµþtÿpë øf thë þøµñð tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeVarDefaultConstraintMismatch: '[BlQvu][นั้TypeVar ðëfæµlt tÿpë mµst þë øñë øf thë çøñstræïñëð tÿpësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeVarDefaultIllegal: '[Z5lrX][นั้Tÿpë værïæþlë ðëfæµlt tÿpës rëqµïrë Pÿthøñ 3.13 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeVarDefaultInvalidTypeVar: '[bOQ21][นั้Tÿpë pæræmëtër "{ñæmë}" hæs æ ðëfæµlt tÿpë thæt rëfërs tø øñë ør mørë tÿpë værïæþlës thæt ærë øµt øf sçøpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typeVarFirstArg: '[XBVgA][นั้Ëxpëçtëð ñæmë øf TypeVar æs fïrst ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        typeVarInvalidForMemberVariable: '[m45Yw][นั้Ættrïþµtë tÿpë çæññøt µsë tÿpë værïæþlë "{ñæmë}" sçøpëð tø løçæl mëthøðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typeVarNoMember: '[Trelb][นั้TypeVar "{tÿpë}" hæs ñø ættrïþµtë "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        typeVarNotSubscriptable: '[3KoEm][นั้TypeVar "{tÿpë}" ïs ñøt sµþsçrïptæþlëẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        typeVarNotUsedByOuterScope: '[on7uQ][นั้Tÿpë værïæþlë "{ñæmë}" hæs ñø mëæñïñg ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeVarPossiblyUnsolvable: '[PP5xz][นั้Tÿpë værïæþlë "{ñæmë}" mæÿ gø µñsølvëð ïf çællër sµpplïës ñø ærgµmëñt før pæræmëtër "{pæræm}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeVarSingleConstraint: '[51MwX][นั้TypeVar mµst hævë æt lëæst twø çøñstræïñëð tÿpësẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        typeVarTupleConstraints: '[ouP8u][นั้TypeVarTuple çæññøt hævë vælµë çøñstræïñtsẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        typeVarTupleContext: '[Q8vE2][นั้TypeVarTuple ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        typeVarTupleDefaultNotUnpacked: '[S2joz][นั้TypeVarTuple ðëfæµlt tÿpë mµst þë æñ µñpæçkëð tuple ør TypeVarTupleẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeVarTupleMustBeUnpacked: '[TA5HX][นั้Üñpæçk øpërætør ïs rëqµïrëð før TypeVarTuple vælµëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeVarTupleUnknownParam: '[fOW23][นั้"{ñæmë}" ïs µñkñøwñ pæræmëtër tø TypeVarTupleẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typeVarUnknownParam: '[veXvU][นั้"{ñæmë}" ïs µñkñøwñ pæræmëtër tø TypeVarẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        typeVarUsedByOuterScope: '[GJ5N3][นั้TypeVar "{ñæmë}" ïs ælrëæðÿ ïñ µsë þÿ æñ øµtër sçøpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeVarUsedOnlyOnce: '[vSn0W][นั้TypeVar "{ñæmë}" æppëærs øñlÿ øñçë ïñ gëñërïç fµñçtïøñ sïgñætµrëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeVarVariance: '[1Dxdn][นั้TypeVar çæññøt þë þøth çøværïæñt æñð çøñtræværïæñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeVarWithDefaultFollowsVariadic: '[h1V5a][นั้TypeVar "{tÿpëVærÑæmë}" hæs æ ðëfæµlt vælµë æñð çæññøt følløw TypeVarTuple "{værïæðïçÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeVarWithoutDefault: '[w630R][นั้"{ñæmë}" çæññøt æppëær æftër "{øthër}" ïñ tÿpë pæræmëtër lïst þëçæµsë ït hæs ñø ðëfæµlt tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeVarsNotInGenericOrProtocol: '[ydmAV][นั้Generic[] ør Protocol[] mµst ïñçlµðë æll tÿpë værïæþlësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typedDictAccess: '[55CCf][นั้Çøµlð ñøt æççëss ïtëm ïñ TypedDictẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typedDictAssignedName: '[Dkf5M][นั้TypedDict mµst þë æssïgñëð tø æ værïæþlë ñæmëð "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typedDictBadVar: '[OL8Ox][นั้TypedDict çlæssës çæñ çøñtæïñ øñlÿ tÿpë æññøtætïøñsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typedDictBaseClass: '[HxyA2][นั้Æll þæsë çlæssës før TypedDict çlæssës mµst ælsø þë TypedDict çlæssësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typedDictBoolParam: '[GALOD][นั้Ëxpëçtëð "{ñæmë}" pæræmëtër tø hævë æ vælµë øf True ør FalseẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typedDictClosedExtras: '[mlkJO][นั้ßæsë çlæss "{ñæmë}" ïs æ closed TypedDict; ëxtræ ïtëms mµst þë tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        typedDictClosedNoExtras: '[BCyXd][นั้ßæsë çlæss "{ñæmë}" ïs æ closed TypedDict; ëxtræ ïtëms ærë ñøt ælløwëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typedDictDelete: '[bdBu7][นั้Çøµlð ñøt ðëlëtë ïtëm ïñ TypedDictẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typedDictEmptyName: '[h45e7][นั้Ñæmës wïthïñ æ TypedDict çæññøt þë ëmptÿẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        typedDictEntryName: '[NT4np][นั้Ëxpëçtëð strïñg lïtëræl før ðïçtïøñærÿ ëñtrÿ ñæmëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typedDictEntryUnique: '[nWy0L][นั้Ñæmës wïthïñ æ ðïçtïøñærÿ mµst þë µñïqµëẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        typedDictExtraArgs: '[0gX32][นั้Ëxtræ TypedDict ærgµmëñts ñøt sµppørtëðẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        typedDictExtraItemsClosed: '[5BDXE][นั้Æ TypedDict çæññøt þë closed ïf ït sµppørts ëxtræ ïtëmsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typedDictFieldNotRequiredRedefinition: '[rNYD1][นั้TypedDict ïtëm "{ñæmë}" çæññøt þë rëðëfïñëð æs NotRequiredẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typedDictFieldReadOnlyRedefinition: '[8IFAz][นั้TypedDict ïtëm "{ñæmë}" çæññøt þë rëðëfïñëð æs ReadOnlyẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typedDictFieldRequiredRedefinition: '[lpw97][นั้TypedDict ïtëm "{ñæmë}" çæññøt þë rëðëfïñëð æs RequiredẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typedDictFirstArg: '[OPlNk][นั้Ëxpëçtëð TypedDict çlæss ñæmë æs fïrst ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        typedDictInClassPattern: '[IqJCA][นั้TypedDict çlæss ñøt ælløwëð ïñ çlæss pættërñẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typedDictInitsubclassParameter: '[HMpfK][นั้TypedDict ðøës ñøt sµppørt __init_subclass__ pæræmëtër "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typedDictNotAllowed: '[UWg4F][นั้"TypedDict" çæññøt þë µsëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        typedDictSecondArgDict: '[mwrv7][นั้Ëxpëçtëð dict ør këÿwørð pæræmëtër æs sëçøñð pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typedDictSecondArgDictEntry: '[oAT5Z][นั้Ëxpëçtëð sïmplë ðïçtïøñærÿ ëñtrÿẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typedDictSet: '[30hTC][นั้Çøµlð ñøt æssïgñ ïtëm ïñ TypedDictẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        unaccessedClass: '[dou8i][นั้Çlæss "{ñæmë}" ïs ñøt æççëssëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        unaccessedFunction: '[AdgDz][นั้Fµñçtïøñ "{ñæmë}" ïs ñøt æççëssëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        unaccessedImport: '[2a90g][นั้Ïmpørt "{ñæmë}" ïs ñøt æççëssëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        unaccessedSymbol: '[MmnM7][นั้"{ñæmë}" ïs ñøt æççëssëðẤğ倪İЂҰक्र्นั้ढूँ]',
        unaccessedVariable: '[n5l1e][นั้Værïæþlë "{ñæmë}" ïs ñøt æççëssëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        unannotatedFunctionSkipped: '[Ovgyl][นั้Æñælÿsïs øf fµñçtïøñ "{ñæmë}" ïs skïppëð þëçæµsë ït ïs µñæññøtætëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        unaryOperationNotAllowed: '[2WB31][นั้Üñærÿ øpërætør ñøt ælløwëð ïñ tÿpë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unexpectedAsyncToken: '[fKSJb][นั้Ëxpëçtëð "def", "with" ør "for" tø følløw "async"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        unexpectedExprToken: '[MtBsu][นั้Üñëxpëçtëð tøkëñ æt ëñð øf ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        unexpectedIndent: '[uZUVS][นั้Üñëxpëçtëð ïñðëñtætïøñẤğ倪İЂҰक्र्นั้ढूँ]',
        unexpectedUnindent: '[yqwy4][นั้Üñïñðëñt ñøt ëxpëçtëðẤğ倪İЂҰक्นั้ढूँ]',
        unhashableDictKey: '[pIvHj][นั้Ðïçtïøñærÿ këÿ mµst þë hæshæþlëẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        unhashableSetEntry: '[rWf72][นั้Set ëñtrÿ mµst þë hæshæþlëẤğ倪İЂҰक्र्นั้ढूँ]',
        uninitializedAbstractVariables: '[SpCPH][นั้Værïæþlës ðëfïñëð ïñ æþstræçt þæsë çlæss ærë ñøt ïñïtïælïzëð ïñ final çlæss "{çlæssTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        uninitializedInstanceVariable: '[5pgFw][นั้Ïñstæñçë værïæþlë "{ñæmë}" ïs ñøt ïñïtïælïzëð ïñ thë çlæss þøðÿ ør __init__ mëthøðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        unionForwardReferenceNotAllowed: '[MOLby][นั้Union sÿñtæx çæññøt þë µsëð wïth strïñg øpëræñð; µsë qµøtës ærøµñð ëñtïrë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        unionSyntaxIllegal: '[vbTDG][นั้Æltërñætïvë sÿñtæx før µñïøñs rëqµïrës Pÿthøñ 3.10 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        unionTypeArgCount: '[vc6vA][นั้Union rëqµïrës twø ør mørë tÿpë ærgµmëñtsẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        unionUnpackedTuple: '[owRjE][นั้Union çæññøt ïñçlµðë æñ µñpæçkëð tupleẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        unionUnpackedTypeVarTuple: '[a6msY][นั้Union çæññøt ïñçlµðë æñ µñpæçkëð TypeVarTupleẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unnecessaryCast: '[QgPoI][นั้Üññëçëssærÿ "cast" çæll; tÿpë ïs ælrëæðÿ "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        unnecessaryIsInstanceAlways: '[gX4s7][นั้Üññëçëssærÿ isinstance çæll; "{tëstTÿpë}" ïs ælwæÿs æñ ïñstæñçë øf "{çlæssTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unnecessaryIsInstanceNever: '[60nSE][นั้Üññëçëssærÿ isinstance çæll; "{tëstTÿpë}" ïs ñëvër æñ ïñstæñçë øf "{çlæssTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unnecessaryIsSubclassAlways: '[BzHtx][นั้Üññëçëssærÿ issubclass çæll; "{tëstTÿpë}" ïs ælwæÿs æ sµþçlæss øf "{çlæssTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unnecessaryIsSubclassNever: '[bOMnf][นั้Üññëçëssærÿ issubclass çæll; "{tëstTÿpë}" ïs ñëvër æ sµþçlæss øf "{çlæssTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        unnecessaryPyrightIgnore: '[7QhdX][นั้Üññëçëssærÿ "# pyright: ignore" çømmëñtẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        unnecessaryPyrightIgnoreRule: '[0ESoQ][นั้Üññëçëssærÿ "# pyright: ignore" rµlë: "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unnecessaryTypeIgnore: '[IoWr9][นั้Üññëçëssærÿ "# type: ignore" çømmëñtẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        unpackArgCount: '[bkAT1][นั้Ëxpëçtëð æ sïñglë tÿpë ærgµmëñt æftër "Unpack"Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unpackExpectedTypeVarTuple: '[CWX8o][นั้Ëxpëçtëð TypeVarTuple ør tuple æs tÿpë ærgµmëñt før UnpackẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        unpackExpectedTypedDict: '[ha9qw][นั้Ëxpëçtëð TypedDict tÿpë ærgµmëñt før UnpackẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        unpackIllegalInComprehension: '[7a4pV][นั้Üñpæçk øpërætïøñ ñøt ælløwëð ïñ çømprëhëñsïøñẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unpackInAnnotation: '[6gqFu][นั้Üñpæçk øpërætør ñøt ælløwëð ïñ tÿpë ëxprëssïøñẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unpackInDict: '[eKn69][นั้Üñpæçk øpërætïøñ ñøt ælløwëð ïñ ðïçtïøñærïësẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unpackInSet: '[lKyO0][นั้Üñpæçk øpërætør ñøt ælløwëð wïthïñ æ setẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        unpackNotAllowed: '[MZq6e][นั้Unpack ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        unpackOperatorNotAllowed: '[lMq2B][นั้Üñpæçk øpërætïøñ ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        unpackTuplesIllegal: '[RJvzW][นั้Üñpæçk øpërætïøñ ñøt ælløwëð ïñ tµplës prïør tø Pÿthøñ 3.8Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        unpackedArgInTypeArgument: '[skxlo][นั้Üñpæçkëð ærgµmëñts çæññøt þë µsëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        unpackedArgWithVariadicParam: '[ZP3kP][นั้Üñpæçkëð ærgµmëñt çæññøt þë µsëð før TypeVarTuple pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        unpackedDictArgumentNotMapping: '[iSTnU][นั้Ærgµmëñt ëxprëssïøñ æftër ** mµst þë æ mæppïñg wïth æ "str" këÿ tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        unpackedDictSubscriptIllegal: '[slATr][นั้Ðïçtïøñærÿ µñpæçk øpërætør ïñ sµþsçrïpt ïs ñøt ælløwëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        unpackedSubscriptIllegal: '[2CpZz][นั้Üñpæçk øpërætør ïñ sµþsçrïpt rëqµïrës Pÿthøñ 3.11 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        unpackedTypeVarTupleExpected: '[tgdHs][นั้Ëxpëçtëð µñpæçkëð TypeVarTuple; µsë Unpack[{name1}] ør *{name2}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        unpackedTypedDictArgument: '[iCgjR][นั้Üñæþlë tø mætçh µñpæçkëð TypedDict ærgµmëñt tø pæræmëtërsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        unreachableCode: '[bpJSK][นั้Çøðë ïs µñrëæçhæþlëẤğ倪İЂҰक्นั้ढूँ]',
        unreachableCodeType: '[v80nR][นั้Tÿpë æñælÿsïs ïñðïçætës çøðë ïs µñrëæçhæþlëẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        unreachableExcept: '[zFMWg][นั้Except çlæµsë ïs µñrëæçhæþlë þëçæµsë ëxçëptïøñ ïs ælrëæðÿ hæñðlëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        unsupportedDunderAllOperation: '[KsX0f][นั้Øpërætïøñ øñ "__all__" ïs ñøt sµppørtëð, sø ëxpørtëð sÿmþøl lïst mæÿ þë ïñçørrëçtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        unusedCallResult: '[9IsV5][นั้Rësµlt øf çæll ëxprëssïøñ ïs øf tÿpë "{tÿpë}" æñð ïs ñøt µsëð; æssïgñ tø værïæþlë "_" ïf thïs ïs ïñtëñtïøñælẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        unusedCoroutine: '[nQUJ2][นั้Rësµlt øf async fµñçtïøñ çæll ïs ñøt µsëð; µsë "æwæït" ør æssïgñ rësµlt tø værïæþlëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        unusedExpression: '[ghmaU][นั้Ëxprëssïøñ vælµë ïs µñµsëðẤğ倪İЂҰक्र्นั้ढूँ]',
        varAnnotationIllegal: '[v2cs9][นั้Tÿpë æññøtætïøñs før værïæþlës rëqµïrës Pÿthøñ 3.6 ør ñëwër; µsë type çømmëñt før çømpætïþïlïtÿ wïth prëvïøµs vërsïøñsẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        variableFinalOverride: '[LcrNS][นั้Værïæþlë "{ñæmë}" ïs mærkëð Final æñð øvërrïðës ñøñ-Final værïæþlë øf sæmë ñæmë ïñ çlæss "{çlæssÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        variadicTypeArgsTooMany: '[1QX0D][นั้Tÿpë ærgµmëñt lïst çæñ hævë æt møst øñë µñpæçkëð TypeVarTuple ør tupleẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        variadicTypeParamTooManyAlias: '[43VIR][นั้Tÿpë ælïæs çæñ hævë æt møst øñë TypeVarTuple tÿpë pæræmëtër þµt rëçëïvëð mµltïplë ({ñæmës})Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        variadicTypeParamTooManyClass: '[fboqC][นั้Gëñërïç çlæss çæñ hævë æt møst øñë TypeVarTuple tÿpë pæræmëtër þµt rëçëïvëð mµltïplë ({ñæmës})Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        walrusIllegal: '[iR3y3][นั้Øpërætør ":=" rëqµïrës Pÿthøñ 3.8 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        walrusNotAllowed: '[kdD5j][นั้Øpërætør ":=" ïs ñøt ælløwëð ïñ thïs çøñtëxt wïthøµt sµrrøµñðïñg pærëñthësësẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        wildcardInFunction: '[NyGOv][นั้Wïlðçærð import ñøt ælløwëð wïthïñ æ çlæss ør fµñçtïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        wildcardLibraryImport: '[Yk3ai][นั้Wïlðçærð import frøm æ lïþrærÿ ñøt ælløwëðẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        wildcardPatternTypePartiallyUnknown: '[eRR5M][นั้Tÿpë çæptµrëð þÿ wïlðçærð pættërñ ïs pærtïællÿ µñkñøwñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        wildcardPatternTypeUnknown: '[Bo3gT][นั้Tÿpë çæptµrëð þÿ wïlðçærð pættërñ ïs µñkñøwñẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        yieldFromIllegal: '[DkXto][นั้Üsë øf "yield from" rëqµïrës Pÿthøñ 3.3 ør ñëwërẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        yieldFromOutsideAsync: '[ZONEz][นั้"yield from" ñøt ælløwëð ïñ æñ async fµñçtïøñẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        yieldOutsideFunction: '[2lDBQ][นั้"yield" ñøt ælløwëð øµtsïðë øf æ fµñçtïøñ ør læmþðæẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        yieldWithinComprehension: '[yALS5][นั้"yield" ñøt ælløwëð ïñsïðë æ çømprëhëñsïøñẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        zeroCaseStatementsFound: '[ArU3j][นั้Match stætëmëñt mµst ïñçlµðë æt lëæst øñë case stætëmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        zeroLengthTupleNotAllowed: '[3gVpF][นั้Zërø-lëñgth tuple ïs ñøt ælløwëð ïñ thïs çøñtëxtẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '[Mws6g][นั้"Annotated" spëçïæl førm çæññøt þë µsëð wïth ïñstæñçë æñð çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        argParam: '[nmvvb][นั้Ærgµmëñt çørrëspøñðs tø pæræmëtër "{pæræmÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        argParamFunction: '[7Xwg8][นั้Ærgµmëñt çørrëspøñðs tø pæræmëtër "{pæræmÑæmë}" ïñ fµñçtïøñ "{fµñçtïøñÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        argsParamMissing: '[vg3b8][นั้Pæræmëtër "*{pæræmÑæmë}" hæs ñø çørrëspøñðïñg pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        argsPositionOnly: '[sNlU1][นั้Pøsïtïøñ-øñlÿ pæræmëtër mïsmætçh; ëxpëçtëð {ëxpëçtëð} þµt rëçëïvëð {rëçëïvëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        argumentType: '[JJxeD][นั้Ærgµmëñt tÿpë ïs "{tÿpë}"Ấğ倪İЂҰक्र्นั้ढूँ]',
        argumentTypes: '[Omlwm][นั้Ærgµmëñt tÿpës: ({tÿpës})Ấğ倪İЂҰक्र्นั้ढूँ]',
        assignToNone: '[z249G][นั้Tÿpë ïs ñøt æssïgñæþlë tø "None"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        asyncHelp: '[2nasS][นั้Ðïð ÿøµ mëæñ "async with"?Ấğ倪İЂҰक्र्นั้ढूँ]',
        baseClassIncompatible: '[oW6Ip][นั้ßæsë çlæss "{þæsëÇlæss}" ïs ïñçømpætïþlë wïth tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        baseClassIncompatibleSubclass: '[mMUCH][นั้ßæsë çlæss "{þæsëÇlæss}" ðërïvës frøm "{sµþçlæss}" whïçh ïs ïñçømpætïþlë wïth tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        baseClassOverriddenType: '[Hp8Sl][นั้ßæsë çlæss "{þæsëÇlæss}" prøvïðës tÿpë "{tÿpë}", whïçh ïs øvërrïððëñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        baseClassOverridesType: '[P7N4Y][นั้ßæsë çlæss "{þæsëÇlæss}" øvërrïðës wïth tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        bytesTypePromotions: '[qIXYb][นั้§ët disableBytesTypePromotions tø false tø ëñæþlë tÿpë prømøtïøñ þëhævïør før "bytearray" æñð "memoryview"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        conditionalRequiresBool: '[k1G9a][นั้Mëthøð __bool__ før tÿpë "{øpëræñðTÿpë}" rëtµrñs tÿpë "{þøølRëtµrñTÿpë}" ræthër thæñ "þøøl"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        dataClassFieldLocation: '[vQxtf][นั้Fïëlð ðëçlærætïøñẤğ倪İЂҰक्นั้ढूँ]',
        dataClassFrozen: '[d4uiK][นั้"{ñæmë}" ïs frøzëñẤğ倪İЂҰक्นั้ढूँ]',
        dataProtocolUnsupported: '[7gIT2][นั้"{ñæmë}" ïs æ ðætæ prøtøçølẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        descriptorAccessBindingFailed: '[RiEhE][นั้Fæïlëð tø þïñð mëthøð "{ñæmë}" før ðësçrïptør çlæss "{çlæssÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        descriptorAccessCallFailed: '[8EXvg][นั้Fæïlëð tø çæll mëthøð "{ñæmë}" før ðësçrïptør çlæss "{çlæssÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        finalMethod: '[zz1yN][นั้Final mëthøðẤğ倪İЂนั้ढूँ]',
        functionParamDefaultMissing: '[yWAIy][นั้Pæræmëtër "{ñæmë}" ïs mïssïñg ðëfæµlt ærgµmëñtẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        functionParamName: '[NrJqx][นั้Pæræmëtër ñæmë mïsmætçh: "{ðëstÑæmë}" vërsµs "{srçÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        functionParamPositionOnly: '[XOhUP][นั้Pøsïtïøñ-øñlÿ pæræmëtër mïsmætçh; pæræmëtër "{ñæmë}" ïs ñøt pøsïtïøñ-øñlÿẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        functionReturnTypeMismatch: '[x4qH0][นั้Fµñçtïøñ rëtµrñ tÿpë "{søµrçëTÿpë}" ïs ïñçømpætïþlë wïth tÿpë "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        functionTooFewParams: '[575uy][นั้Fµñçtïøñ æççëpts tøø fëw pøsïtïøñæl pæræmëtërs; ëxpëçtëð {ëxpëçtëð} þµt rëçëïvëð {rëçëïvëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        functionTooManyParams: '[zj9vw][นั้Fµñçtïøñ æççëpts tøø mæñÿ pøsïtïøñæl pæræmëtërs; ëxpëçtëð {ëxpëçtëð} þµt rëçëïvëð {rëçëïvëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        genericClassNotAllowed: '[MDEt3][นั้Gëñërïç tÿpë wïth tÿpë ærgµmëñts ñøt ælløwëð før ïñstæñçë ør çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        incompatibleDeleter: '[LCJuj][นั้Property deleter mëthøð ïs ïñçømpætïþlëẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        incompatibleGetter: '[yds2G][นั้Property getter mëthøð ïs ïñçømpætïþlëẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        incompatibleSetter: '[GDoso][นั้Property setter mëthøð ïs ïñçømpætïþlëẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        initMethodLocation: '[D4O2l][นั้Thë __init__ mëthøð ïs ðëfïñëð ïñ çlæss "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        initMethodSignature: '[EULjB][นั้§ïgñætµrë øf __init__ ïs "{tÿpë}"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        initSubclassLocation: '[eEcCS][นั้Thë __init_subclass__ mëthøð ïs ðëfïñëð ïñ çlæss "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        invariantSuggestionDict: '[OIoHo][นั้Çøñsïðër swïtçhïñg frøm "dict" tø "Mapping" whïçh ïs çøværïæñt ïñ thë vælµë tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        invariantSuggestionList: '[irYWI][นั้Çøñsïðër swïtçhïñg frøm "list" tø "Sequence" whïçh ïs çøværïæñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        invariantSuggestionSet: '[64U47][นั้Çøñsïðër swïtçhïñg frøm "set" tø "Container" whïçh ïs çøværïæñtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        isinstanceClassNotSupported: '[uTDu4][นั้"{tÿpë}" ïs ñøt sµppørtëð før ïñstæñçë æñð çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        keyNotRequired: '[K1bDP][นั้"{ñæmë}" ïs ñøt æ rëqµïrëð këÿ ïñ "{tÿpë}", sø æççëss mæÿ rësµlt ïñ rµñtïmë ëxçëptïøñẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        keyReadOnly: '[dhAH3][นั้"{ñæmë}" ïs æ rëæð-øñlÿ këÿ ïñ "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        keyRequiredDeleted: '[YeZa5][นั้"{ñæmë}" ïs æ rëqµïrëð këÿ æñð çæññøt þë ðëlëtëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        keyUndefined: '[6mQGu][นั้"{ñæmë}" ïs ñøt æ ðëfïñëð këÿ ïñ "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        kwargsParamMissing: '[KHgb2][นั้Pæræmëtër "**{pæræmÑæmë}" hæs ñø çørrëspøñðïñg pæræmëtërẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        listAssignmentMismatch: '[fERKI][นั้Tÿpë "{tÿpë}" ïs ïñçømpætïþlë wïth tærgët lïstẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        literalAssignmentMismatch: '[17LiQ][นั้"{søµrçëTÿpë}" ïs ñøt æssïgñæþlë tø tÿpë "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        matchIsNotExhaustiveHint: '[3NR39][นั้Ïf ëxhæµstïvë hæñðlïñg ïs ñøt ïñtëñðëð, æðð "case _: pass"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        matchIsNotExhaustiveType: '[9RN1P][นั้Üñhæñðlëð tÿpë: "{tÿpë}"Ấğ倪İЂҰक्र्นั้ढूँ]',
        memberAssignment: '[1WFCt][นั้Ëxprëssïøñ øf tÿpë "{tÿpë}" çæññøt þë æssïgñëð tø ættrïþµtë "{ñæmë}" øf çlæss "{çlæssTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        memberIsAbstract: '[l912U][นั้"{tÿpë}.{ñæmë}" ïs ñøt ïmplëmëñtëðẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        memberIsAbstractMore: '[dgfwa][นั้æñð {çøµñt} mørëẤğ倪İЂҰนั้ढूँ]...',
        memberIsClassVarInProtocol: '[ZZeb4][นั้"{ñæmë}" ïs ðëfïñëð æs æ ClassVar ïñ prøtøçølẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        memberIsInitVar: '[0SGIB][นั้"{ñæmë}" ïs æñ init-only fïëlðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        memberIsInvariant: '[rBPX6][นั้"{ñæmë}" ïs ïñværïæñt þëçæµsë ït ïs mµtæþlëẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        memberIsNotClassVarInClass: '[bKhkE][นั้"{ñæmë}" mµst þë ðëfïñëð æs æ ClassVar tø þë çømpætïþlë wïth prøtøçølẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        memberIsNotClassVarInProtocol: '[OAmE1][นั้"{ñæmë}" ïs ñøt ðëfïñëð æs æ ClassVar ïñ prøtøçølẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        memberIsNotReadOnlyInProtocol: '[TKk1U][นั้"{ñæmë}" ïs ñøt rëæð-øñlÿ ïñ prøtøçølẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        memberIsReadOnlyInProtocol: '[xOSqy][นั้"{ñæmë}" ïs rëæð-øñlÿ ïñ prøtøçølẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        memberIsWritableInProtocol: '[x53Kg][นั้"{ñæmë}" ïs wrïtæþlë ïñ prøtøçølẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        memberSetClassVar: '[2pVfQ][นั้Ættrïþµtë "{ñæmë}" çæññøt þë æssïgñëð thrøµgh æ çlæss ïñstæñçë þëçæµsë ït ïs æ ClassVarẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        memberTypeMismatch: '[IHN4x][นั้"{ñæmë}" ïs æñ ïñçømpætïþlë tÿpëẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        memberUnknown: '[7kDIF][นั้Ættrïþµtë "{ñæmë}" ïs µñkñøwñẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        metaclassConflict: '[fjWW1][นั้Mëtæçlæss "{mëtæçlæss1}" çøñflïçts wïth "{mëtæçlæss2}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        missingDeleter: '[5IVNI][นั้Property deleter mëthøð ïs mïssïñgẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        missingGetter: '[Mzn4K][นั้Property getter mëthøð ïs mïssïñgẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        missingSetter: '[goeIY][นั้Property setter mëthøð ïs mïssïñgẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        namedParamMissingInDest: '[dc07X][นั้Ëxtræ pæræmëtër "{ñæmë}"Ấğ倪İЂҰक्र्นั้ढूँ]',
        namedParamMissingInSource: '[N59fC][นั้Mïssïñg këÿwørð pæræmëtër "{ñæmë}"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        namedParamTypeMismatch: '[9CAV6][นั้Këÿwørð pæræmëtër "{ñæmë}" øf tÿpë "{søµrçëTÿpë}" ïs ïñçømpætïþlë wïth tÿpë "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        namedTupleNotAllowed: '[gAlSp][นั้NamedTuple çæññøt þë µsëð før ïñstæñçë ør çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        newMethodLocation: '[n0dxL][นั้Thë __new__ mëthøð ïs ðëfïñëð ïñ çlæss "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        newMethodSignature: '[NeWKO][นั้§ïgñætµrë øf __new__ ïs "{tÿpë}"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        newTypeClassNotAllowed: '[JQmcY][นั้Çlæss çrëætëð wïth NewType çæññøt þë µsëð wïth ïñstæñçë æñð çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        noOverloadAssignable: '[FJ88c][นั้Ñø øvërløæðëð fµñçtïøñ mætçhës tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        noneNotAllowed: '[Yn8Lx][นั้None çæññøt þë µsëð før ïñstæñçë ør çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        orPatternMissingName: '[kgiPM][นั้Mïssïñg ñæmës: {ñæmë}Ấğ倪İЂҰक्นั้ढूँ]',
        overloadIndex: '[vNPxL][นั้Øvërløæð {ïñðëx} ïs thë çløsëst mætçhẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        overloadNotAssignable: '[BA2kK][นั้Øñë ør mørë øvërløæðs øf "{ñæmë}" ïs ñøt æssïgñæþlëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        overloadSignature: '[NPzwf][นั้Øvërløæð sïgñætµrë ïs ðëfïñëð hërëẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        overriddenMethod: '[CcUB2][นั้Øvërrïððëñ mëthøðẤğ倪İЂҰक्นั้ढूँ]',
        overriddenSymbol: '[cvpXz][นั้Øvërrïððëñ sÿmþølẤğ倪İЂҰक्นั้ढूँ]',
        overrideInvariantMismatch: '[uODzM][นั้Øvërrïðë tÿpë "{øvërrïðëTÿpë}" ïs ñøt thë sæmë æs þæsë tÿpë "{þæsëTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        overrideIsInvariant: '[j45KZ][นั้Værïæþlë ïs mµtæþlë sø ïts tÿpë ïs ïñværïæñtẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        overrideNoOverloadMatches: '[vG14w][นั้Ñø øvërløæð sïgñætµrë ïñ øvërrïðë ïs çømpætïþlë wïth þæsë mëthøðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        overrideNotClassMethod: '[t5OaH][นั้ßæsë mëthøð ïs ðëçlærëð æs æ classmethod þµt øvërrïðë ïs ñøtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        overrideNotInstanceMethod: '[e2Xo5][นั้ßæsë mëthøð ïs ðëçlærëð æs æñ ïñstæñçë mëthøð þµt øvërrïðë ïs ñøtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        overrideNotStaticMethod: '[Eu8Oy][นั้ßæsë mëthøð ïs ðëçlærëð æs æ staticmethod þµt øvërrïðë ïs ñøtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        overrideOverloadNoMatch: '[smVSW][นั้Øvërrïðë ðøës ñøt hæñðlë æll øvërløæðs øf þæsë mëthøðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        overrideOverloadOrder: '[HrUeN][นั้Øvërløæðs før øvërrïðë mëthøð mµst þë ïñ thë sæmë ørðër æs thë þæsë mëthøðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        overrideParamKeywordNoDefault: '[yIoa8][นั้Këÿwørð pæræmëtër "{ñæmë}" mïsmætçh: þæsë pæræmëtër hæs ðëfæµlt ærgµmëñt vælµë, øvërrïðë pæræmëtër ðøës ñøtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        overrideParamKeywordType: '[SAOAr][นั้Këÿwørð pæræmëtër "{ñæmë}" tÿpë mïsmætçh: þæsë pæræmëtër ïs tÿpë "{þæsëTÿpë}", øvërrïðë pæræmëtër ïs tÿpë "{øvërrïðëTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        overrideParamName: '[fRWyy][นั้Pæræmëtër {ïñðëx} ñæmë mïsmætçh: þæsë pæræmëtër ïs ñæmëð "{þæsëÑæmë}", øvërrïðë pæræmëtër ïs ñæmëð "{øvërrïðëÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        overrideParamNameExtra: '[HEG0d][นั้Pæræmëtër "{ñæmë}" ïs mïssïñg ïñ þæsëẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        overrideParamNameMissing: '[PN8Rl][นั้Pæræmëtër "{ñæmë}" ïs mïssïñg ïñ øvërrïðëẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        overrideParamNamePositionOnly: '[3yVlj][นั้Pæræmëtër {ïñðëx} mïsmætçh: þæsë pæræmëtër "{þæsëÑæmë}" ïs këÿwørð pæræmëtër, øvërrïðë pæræmëtër ïs pøsïtïøñ-øñlÿẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        overrideParamNoDefault: '[azvZD][นั้Pæræmëtër {ïñðëx} mïsmætçh: þæsë pæræmëtër hæs ðëfæµlt ærgµmëñt vælµë, øvërrïðë pæræmëtër ðøës ñøtẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        overrideParamType: '[FXBcO][นั้Pæræmëtër {ïñðëx} tÿpë mïsmætçh: þæsë pæræmëtër ïs tÿpë "{þæsëTÿpë}", øvërrïðë pæræmëtër ïs tÿpë "{øvërrïðëTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        overridePositionalParamCount: '[jJZNP][นั้Pøsïtïøñæl pæræmëtër çøµñt mïsmætçh; þæsë mëthøð hæs {þæsëÇøµñt}, þµt øvërrïðë hæs {øvërrïðëÇøµñt}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        overrideReturnType: '[mdPwX][นั้Rëtµrñ tÿpë mïsmætçh: þæsë mëthøð rëtµrñs tÿpë "{þæsëTÿpë}", øvërrïðë rëtµrñs tÿpë "{øvërrïðëTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        overrideType: '[ryAgb][นั้ßæsë çlæss ðëfïñës tÿpë æs "{tÿpë}"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        paramAssignment: '[HGg7D][นั้Pæræmëtër {ïñðëx}: tÿpë "{søµrçëTÿpë}" ïs ïñçømpætïþlë wïth tÿpë "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        paramSpecMissingInOverride: '[AUge7][นั้ParamSpec pæræmëtërs ærë mïssïñg ïñ øvërrïðë mëthøðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        paramType: '[hHLAX][นั้Pæræmëtër tÿpë ïs "{pæræmTÿpë}"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        privateImportFromPyTypedSource: '[8gX6u][นั้Ïmpørt frøm "{møðµlë}" ïñstëæðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        propertyAccessFromProtocolClass: '[h75EJ][นั้Æ prøpërtÿ ðëfïñëð wïthïñ æ prøtøçøl çlæss çæññøt þë æççëssëð æs æ çlæss værïæþlëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        propertyMethodIncompatible: '[dWDwG][นั้Property mëthøð "{ñæmë}" ïs ïñçømpætïþlëẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        propertyMethodMissing: '[xWlRK][นั้Property mëthøð "{ñæmë}" ïs mïssïñg ïñ øvërrïðëẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        propertyMissingDeleter: '[r2oGK][นั้Property "{ñæmë}" hæs ñø ðëfïñëð deleterẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        propertyMissingSetter: '[Sr1R9][นั้Property "{ñæmë}" hæs ñø ðëfïñëð setterẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        protocolIncompatible: '[4uTqc][นั้"{søµrçëTÿpë}" ïs ïñçømpætïþlë wïth prøtøçøl "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        protocolMemberMissing: '[Ad9PZ][นั้"{ñæmë}" ïs ñøt prësëñtẤğ倪İЂҰक्र्นั้ढूँ]',
        protocolRequiresRuntimeCheckable: '[c9ewn][นั้Protocol çlæss mµst þë @runtime_checkable tø þë µsëð wïth ïñstæñçë æñð çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        protocolSourceIsNotConcrete: '[DnLrN][นั้"{søµrçëTÿpë}" ïs ñøt æ çøñçrëtë çlæss tÿpë æñð çæññøt þë æssïgñëð tø tÿpë "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        protocolUnsafeOverlap: '[fKiUM][นั้Ættrïþµtës øf "{ñæmë}" hævë thë sæmë ñæmës æs thë prøtøçølẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        pyrightCommentIgnoreTip: '[raFZN][นั้Üsë "# pyright: ignore[<diagnostic rules>]" tø sµpprëss ðïægñøstïçs før æ sïñglë lïñëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        readOnlyAttribute: '[k9waY][นั้Ættrïþµtë "{ñæmë}" ïs rëæð-øñlÿẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        seeClassDeclaration: '[8sx7n][นั้§ëë çlæss ðëçlærætïøñẤğ倪İЂҰक्นั้ढूँ]',
        seeDeclaration: '[K0X6p][นั้§ëë ðëçlærætïøñẤğ倪İЂҰนั้ढूँ]',
        seeFunctionDeclaration: '[1N6ig][นั้§ëë fµñçtïøñ ðëçlærætïøñẤğ倪İЂҰक्र्นั้ढूँ]',
        seeMethodDeclaration: '[eJSye][นั้§ëë mëthøð ðëçlærætïøñẤğ倪İЂҰक्र्นั้ढूँ]',
        seeParameterDeclaration: '[mBEpT][นั้§ëë pæræmëtër ðëçlærætïøñẤğ倪İЂҰक्र्นั้ढूँ]',
        seeTypeAliasDeclaration: '[Pjnb8][นั้§ëë tÿpë ælïæs ðëçlærætïøñẤğ倪İЂҰक्र्นั้ढूँ]',
        seeVariableDeclaration: '[M3EiY][นั้§ëë værïæþlë ðëçlærætïøñẤğ倪İЂҰक्र्นั้ढूँ]',
        tupleAssignmentMismatch: '[aLGep][นั้Tÿpë "{tÿpë}" ïs ïñçømpætïþlë wïth tærgët tupleẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        tupleEntryTypeMismatch: '[ny8Sn][นั้Tuple ëñtrÿ {ëñtrÿ} ïs ïñçørrëçt tÿpëẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        tupleSizeIndeterminateSrc: '[EnNiw][นั้Tuple sïzë mïsmætçh; ëxpëçtëð {ëxpëçtëð} þµt rëçëïvëð ïñðëtërmïñætëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        tupleSizeIndeterminateSrcDest: '[lrxYh][นั้Tuple sïzë mïsmætçh; ëxpëçtëð {ëxpëçtëð} ør mørë þµt rëçëïvëð ïñðëtërmïñætëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğนั้ढूँ]',
        tupleSizeMismatch: '[F2Yc7][นั้Tuple sïzë mïsmætçh; ëxpëçtëð {ëxpëçtëð} þµt rëçëïvëð {rëçëïvëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        tupleSizeMismatchIndeterminateDest: '[6vxdi][นั้Tuple sïzë mïsmætçh; ëxpëçtëð {ëxpëçtëð} ør mørë þµt rëçëïvëð {rëçëïvëð}Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        typeAliasInstanceCheck: '[29G7K][นั้Tÿpë ælïæs çrëætëð wïth "type" stætëmëñt çæññøt þë µsëð wïth ïñstæñçë æñð çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeAssignmentMismatch: '[VF9B4][นั้Tÿpë "{søµrçëTÿpë}" ïs ñøt æssïgñæþlë tø tÿpë "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeBound: '[AIZri][นั้Tÿpë "{søµrçëTÿpë}" ïs ñøt æssïgñæþlë tø µppër þøµñð "{ðëstTÿpë}" før tÿpë værïæþlë "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeConstrainedTypeVar: '[qHztb][นั้Tÿpë "{tÿpë}" ïs ñøt æssïgñæþlë tø çøñstræïñëð tÿpë værïæþlë "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typeIncompatible: '[L3llJ][นั้"{søµrçëTÿpë}" ïs ñøt æssïgñæþlë tø "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        typeNotClass: '[DTm1E][นั้"{tÿpë}" ïs ñøt æ çlæssẤğ倪İЂҰक्र्นั้ढूँ]',
        typeNotStringLiteral: '[D7UY3][นั้"{tÿpë}" ïs ñøt æ strïñg lïtërælẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeOfSymbol: '[qlRHN][นั้Tÿpë øf "{ñæmë}" ïs "{tÿpë}"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeParamSpec: '[m23b5][นั้Tÿpë "{tÿpë}" ïs ïñçømpætïþlë wïth ParamSpec "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeUnsupported: '[Dx3Cx][นั้Tÿpë "{tÿpë}" ïs µñsµppørtëðẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typeVarDefaultOutOfScope: '[05ALy][นั้Tÿpë værïæþlë "{ñæmë}" ïs ñøt ïñ sçøpëẤğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        typeVarIsContravariant: '[kup2Y][นั้Tÿpë pæræmëtër "{ñæmë}" ïs çøñtræværïæñt, þµt "{søµrçëTÿpë}" ïs ñøt æ sµpërtÿpë øf "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeVarIsCovariant: '[EeRng][นั้Tÿpë pæræmëtër "{ñæmë}" ïs çøværïæñt, þµt "{søµrçëTÿpë}" ïs ñøt æ sµþtÿpë øf "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeVarIsInvariant: '[WLZaN][นั้Tÿpë pæræmëtër "{ñæmë}" ïs ïñværïæñt, þµt "{søµrçëTÿpë}" ïs ñøt thë sæmë æs "{ðëstTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typeVarNotAllowed: '[37OGF][นั้TypeVar ñøt ælløwëð før ïñstæñçë ør çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        typeVarTupleRequiresKnownLength: '[GGttd][นั้TypeVarTuple çæññøt þë þøµñð tø æ tuple øf µñkñøwñ lëñgthẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        typeVarUnnecessarySuggestion: '[k0XTd][นั้Üsë {tÿpë} ïñstëæðẤğ倪İЂҰक्นั้ढूँ]',
        typeVarUnsolvableRemedy: '[PaRa7][นั้Prøvïðë æñ øvërløæð thæt spëçïfïës thë rëtµrñ tÿpë whëñ thë ærgµmëñt ïs ñøt sµpplïëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        typeVarsMissing: '[R1SEV][นั้Mïssïñg tÿpë værïæþlës: {ñæmës}Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        typedDictBaseClass: '[Zv6vP][นั้Çlæss "{tÿpë}" ïs ñøt æ TypedDictẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        typedDictClassNotAllowed: '[Vgl7x][นั้TypedDict çlæss ñøt ælløwëð før ïñstæñçë ør çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typedDictClosedExtraNotAllowed: '[zT7Rm][นั้Çæññøt æðð ïtëm "{ñæmë}"Ấğ倪İЂҰक्र्นั้ढूँ]',
        typedDictClosedExtraTypeMismatch: '[blC1e][นั้Çæññøt æðð ïtëm "{ñæmë}" wïth tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        typedDictClosedFieldNotRequired: '[6rtDR][นั้Çæññøt æðð ïtëm "{ñæmë}" þëçæµsë ït mµst þë NotRequiredẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        typedDictExtraFieldNotAllowed: '[kFDh9][นั้"{ñæmë}" ïs ñøt prësëñt ïñ "{tÿpë}"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typedDictExtraFieldTypeMismatch: '[DnAhM][นั้Tÿpë øf "{ñæmë}" ïs ïñçømpætïþlë wïth tÿpë øf "extra_items" ïñ "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typedDictFieldMissing: '[rNzn7][นั้"{ñæmë}" ïs mïssïñg frøm "{tÿpë}"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        typedDictFieldNotReadOnly: '[BJy1V][นั้"{ñæmë}" ïs ñøt rëæð-øñlÿ ïñ "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤนั้ढूँ]',
        typedDictFieldNotRequired: '[eqatW][นั้"{ñæmë}" ïs ñøt rëqµïrëð ïñ "{tÿpë}"Ấğ倪İЂҰक्र्तिृまนั้ढूँ]',
        typedDictFieldRequired: '[ckyH4][นั้"{ñæmë}" ïs rëqµïrëð ïñ "{tÿpë}"Ấğ倪İЂҰक्र्तिृนั้ढूँ]',
        typedDictFieldTypeMismatch: '[XYIBH][นั้Tÿpë "{tÿpë}" ïs ñøt æssïgñæþlë tø ïtëm "{ñæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]',
        typedDictFieldUndefined: '[UsDC9][นั้"{ñæmë}" ïs æñ µñðëfïñëð ïtëm ïñ tÿpë "{tÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typedDictFinalMismatch: '[tFb04][นั้"{søµrçëTÿpë}" ïs ïñçømpætïþlë wïth "{ðëstTÿpë}" þëçæµsë øf æ @final mïsmætçhẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        typedDictKeyAccess: '[67DLq][นั้Üsë ["{ñæmë}"] tø rëfërëñçë ïtëm ïñ TypedDictẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        typedDictNotAllowed: '[eTsPP][นั้TypedDict çæññøt þë µsëð før ïñstæñçë ør çlæss çhëçksẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        unhashableType: '[IJEeq][นั้Tÿpë "{tÿpë}" ïs ñøt hæshæþlëẤğ倪İЂҰक्र्तिृนั้ढूँ]',
        uninitializedAbstractVariable: '[uDuHt][นั้Ïñstæñçë værïæþlë "{ñæmë}" ïs ðëfïñëð ïñ æþstræçt þæsë çlæss "{çlæssTÿpë}" þµt ñøt ïñïtïælïzëðẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्นั้ढूँ]',
        unreachableExcept: '[3CSUL][นั้"{ëxçëptïøñTÿpë}" ïs æ sµþçlæss øf "{pærëñtTÿpë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰนั้ढूँ]',
        useDictInstead: '[LReB5][นั้Üsë Dict[T1, T2] tø ïñðïçætë æ ðïçtïøñærÿ tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]',
        useListInstead: '[RPu0E][นั้Üsë List[T] tø ïñðïçætë æ list tÿpë ør Union[T1, T2] tø ïñðïçætë æ union tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪นั้ढूँ]',
        useTupleInstead: '[jaFqC][นั้Üsë tuple[T1, ..., Tn] tø ïñðïçætë æ tuple tÿpë ør Union[T1, T2] tø ïñðïçætë æ union tÿpëẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        useTypeInstead: '[Zig8D][นั้Üsë Type[T] ïñstëæðẤğ倪İЂҰक्นั้ढूँ]',
        varianceMismatchForClass: '[fqhIl][นั้Værïæñçë øf tÿpë ærgµmëñt "{tÿpëVærÑæmë}" ïs ïñçømpætïþlë wïth þæsë çlæss "{çlæssÑæmë}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्นั้ढूँ]',
        varianceMismatchForTypeAlias: '[YSiVx][นั้Værïæñçë øf tÿpë ærgµmëñt "{tÿpëVærÑæmë}" ïs ïñçømpætïþlë wïth "{tÿpëÆlïæsPæræm}"Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İนั้ढूँ]'
      },
      Service: {
        longOperation: '[Mvrp3][นั้Ëñµmërætïøñ øf wørkspæçë søµrçë fïlës ïs tækïñg æ løñg tïmë. Çøñsïðër øpëñïñg æ sµþ-følðër ïñstëæð. [£ëærñ mørë](https://ækæ.ms/wørkspæçë-tøø-mæñÿ-fïlës)Ấğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂҰक्र्तिृまẤğ倪İЂนั้ढूँ]'
      }
    };
  },
  78483: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Создать Stub типа',
        createTypeStubFor: 'Создать Stub типа для "{moduleName}"',
        executingCommand: 'Производится выполнение команды',
        filesToAnalyzeCount: '{count} файлов для анализа',
        filesToAnalyzeOne: '1 файл для анализа',
        findingReferences: 'Производится поиск ссылок',
        organizeImports: 'Упорядочение импорта',
        renameShadowedFile: 'Переименовать "{oldFile}" в "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Автоматический импорт',
        indexValueDetail: 'Значение индекса'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Невозможно вызвать метод "{method}", так как он является абстрактным и нереализованным',
        annotatedMetadataInconsistent: 'Тип аннотированных метаданных "{metadataType}" несовместим с типом "{type}"',
        annotatedParamCountMismatch: 'Несоответствие числа аннотаций параметра: ожидается {expected}, но получено {received}',
        annotatedTypeArgMissing: 'Для "Annotated" ожидается один аргумент типа и одна или несколько заметок типа',
        annotationBytesString: 'Выражения типа не могут использовать строковые литералы байтов',
        annotationFormatString: 'В выражениях типа не могут использоваться строковые литералы формата (f-строки)',
        annotationNotSupported: 'Заметка типа не поддерживается для этой инструкции',
        annotationRawString: 'Выражения типа не могут использовать необработанные строковые литералы',
        annotationSpansStrings: 'Выражения типа не могут охватывать несколько строковых литералов',
        annotationStringEscape: 'Выражения типа не могут содержать escape-символы',
        argAssignment: 'Аргумент типа "{argType}" нельзя присвоить параметру типа "{paramType}"',
        argAssignmentFunction: 'Аргумент типа "{argType}" нельзя присвоить параметру типа "{paramType}" в функции "{functionName}"',
        argAssignmentParam: 'Аргумент типа "{argType}" нельзя присвоить параметру "{paramName}" типа "{paramType}"',
        argAssignmentParamFunction: 'Аргумент типа "{argType}" нельзя присвоить параметру "{paramName}" типа "{paramType}" в функции "{functionName}"',
        argMissingForParam: 'Отсутствует аргумент для параметра {name}',
        argMissingForParams: 'Отсутствуют аргументы для параметров {names}',
        argMorePositionalExpectedCount: 'Ожидаются еще позиционные аргументы: {expected}',
        argMorePositionalExpectedOne: 'Ожидается еще 1 позиционный аргумент',
        argPositional: 'Ожидается позиционный аргумент',
        argPositionalExpectedCount: 'Ожидаемые позиционные аргументы: {expected}',
        argPositionalExpectedOne: 'Ожидается 1 позиционный аргумент',
        argTypePartiallyUnknown: 'Тип аргумента частично неизвестен',
        argTypeUnknown: 'Тип аргумента неизвестен',
        assertAlwaysTrue: 'Выражение assert всегда вычисляется как true',
        assertTypeArgs: 'Для "assert_type" ожидается два позиционных аргумента',
        assertTypeTypeMismatch: 'Несоответствие типов "assert_type": ожидается "{expected}", но получено "{received}"',
        assignmentExprComprehension: 'Цель выражения назначения "{name}" не может использовать то же имя, что и понимание для целевого объекта',
        assignmentExprContext: 'Выражение присваивания должно находиться в модуле, функции или лямбде',
        assignmentExprInSubscript: 'Выражения назначения внутри оператора получения подстроки можно использовать в Python версии не ниже 3.10',
        assignmentInProtocol: 'Переменные экземпляра или класса в классе Protocol должны быть явно объявлены в тексте класса',
        assignmentTargetExpr: 'Выражение не может быть целевым объектом присваивания',
        asyncNotInAsyncFunction: 'Использование "async" не разрешено вне async функции',
        awaitIllegal: 'Инструкцию "await" можно использовать в Python версии не ранее 3.5',
        awaitNotAllowed: 'Выражения типа не могут использовать "await"',
        awaitNotInAsync: 'Ключевое слово "await" допускается только в async функции',
        backticksIllegal: 'Выражения, окруженные одиночными обратными кавычками, не поддерживаются в Python 3.x; используйте вместо этого функцию repr',
        baseClassCircular: 'Класс не может быть производным от себя',
        baseClassFinal: 'Базовый класс "{type}" помечен как final, и от него нельзя создать производный класс',
        baseClassIncompatible: 'Базовые классы {type} взаимно несовместимы',
        baseClassInvalid: 'Аргумент класса должен быть базовым классом',
        baseClassMethodTypeIncompatible: 'Базовые классы класса "{classType}" определяют метод "{name}" несовместимым способом',
        baseClassUnknown: 'Неизвестный тип базового класса скрывает тип производного класса',
        baseClassVariableTypeIncompatible: 'Базовые классы класса "{classType}" определяют переменную "{name}" несовместимым способом',
        binaryOperationNotAllowed: 'Бинарный оператор нельзя использовать в выражении типа',
        bindTypeMismatch: 'Не удалось привязать метод "{methodName}", "{type}" не может быть назначен параметру "{paramName}"',
        breakInExceptionGroup: 'Запрещено наличие "break" в блоке "except*"',
        breakOutsideLoop: '"break" можно использовать только внутри цикла',
        callableExtraArgs: 'В "Callable" ожидается только два аргумента типа',
        callableFirstArg: 'Ожидается список типов параметров или "..."',
        callableNotInstantiable: 'Невозможно создать экземпляр типа "{type}"',
        callableSecondArg: 'В качестве аргумента второго типа для "Callable" ожидается возвращаемый тип',
        casePatternIsIrrefutable: 'Неопровержимый шаблон допускается только для последнего оператора case',
        classAlreadySpecialized: 'Тип "{type}" уже специализирован',
        classDecoratorTypeUnknown: 'Нетипизированный декоратор класса скрывает тип класса. Игнорирование декоратора',
        classDefinitionCycle: 'Определение класса для "{name}" зависит от себя',
        classGetItemClsParam: 'Переопределение метода __class_getitem__ должно принимать параметр "cls"',
        classMethodClsParam: 'Методы класса должны принимать параметр cls',
        classNotRuntimeSubscriptable: 'Операция взятия подстроки для класса "{name}" создаст исключение среды выполнения; заключите выражение типа в кавычки',
        classPatternBuiltInArgPositional: 'Шаблон класса принимает только позиционный вложенный шаблон',
        classPatternPositionalArgCount: 'Слишком много позиционных шаблонов для класса "{type}"; ожидается {expected}, но получено {received}',
        classPatternTypeAlias: '"{type}" нельзя использовать в шаблоне класса, поскольку это псевдоним специализированного типа',
        classPropertyDeprecated: 'Свойства класса упразднены в Python 3.11 и не будут поддерживаться в Python 3.13',
        classTypeParametersIllegal: 'Синтаксис параметра типа класса может использоваться в Python версии не ниже 3.12.',
        classVarFirstArgMissing: 'Ожидается аргумент типа после "ClassVar"',
        classVarNotAllowed: 'Использование "ClassVar" в этом контексте не допускается',
        classVarOverridesInstanceVar: 'Переменная класса "{name}" переопределяет переменную экземпляра с тем же именем в классе "{className}"',
        classVarTooManyArgs: 'Ожидается только один аргумент типа после "ClassVar"',
        classVarWithTypeVar: 'Тип "ClassVar" не может включать переменные типа',
        clsSelfParamTypeMismatch: 'Тип параметра "{name}" должен быть супертипом своего класса "{classType}"',
        codeTooComplexToAnalyze: 'Код слишком сложен для анализа; уменьшите сложность, разбив его на фрагменты (вложенные процедуры) или сократите количество условных конструкций',
        collectionAliasInstantiation: 'Тип "{type}" не может быть создан, вместо этого используйте "{alias}"',
        comparisonAlwaysFalse: 'Условие всегда будет оцениваться как False, поскольку типы "{leftType}" и "{rightType}" не перекрываются',
        comparisonAlwaysTrue: 'Выражение всегда будет возвращать значение True, поскольку типы "{leftType}" и "{rightType}" не перекрываются',
        comprehensionInDict: 'Понимание не может использоваться с другими записями словаря',
        comprehensionInSet: 'Понимание не может использоваться с другими записями set',
        concatenateContext: '"Concatenate" не допускается в этом контексте',
        concatenateParamSpecMissing: 'Последний аргумент типа для "Concatenate" должен быть ParamSpec или "..."',
        concatenateTypeArgsMissing: 'Для "Concatenate" требуется по крайней мере два аргумента типа',
        conditionalOperandInvalid: 'Недопустимый условный операнд типа "{type}"',
        constantRedefinition: '"{name}" является константой (поскольку оно в верхнем регистре) и не может быть переопределено.',
        constructorParametersMismatch: 'Несоответствие подписи __new__ и __init__ в классе "{classType}"',
        containmentAlwaysFalse: 'Выражение всегда будет оцениваться как False, так как типы "{leftType}" и "{rightType}" не перекрываются',
        containmentAlwaysTrue: 'Выражение всегда будет оцениваться как True, так как типы "{leftType}" и "{rightType}" не перекрываются',
        continueInExceptionGroup: 'Запрещено наличие "continue" в блоке "except*"',
        continueOutsideLoop: 'Ключевое слово "continue" можно использовать только внутри цикла',
        coroutineInConditionalExpression: 'Условное выражение ссылается на сопрограмму, которая всегда возвращает значение True',
        dataClassBaseClassFrozen: 'Незафиксированный класс не может наследоваться от зафиксированного класса',
        dataClassBaseClassNotFrozen: 'Незафиксированный класс не может наследоваться от зафиксированного класса',
        dataClassConverterFunction: 'Аргумент типа "{argType}" не является допустимым преобразователем для поля "{fieldName}" типа "{fieldType}"',
        dataClassConverterOverloads: 'Ни одна перегрузка "{funcName}" не является допустимым преобразователем поля "{fieldName}" типа "{fieldType}"',
        dataClassFieldInheritedDefault: '"{fieldName}" переопределяет поле с тем же именем, но в нем отсутствует значение по умолчанию',
        dataClassFieldWithDefault: 'Поля без значений по умолчанию не могут отображаться после полей со значениями по умолчанию.',
        dataClassFieldWithPrivateName: 'Поле класса данных не может использовать закрытое имя',
        dataClassFieldWithoutAnnotation: 'Поле dataclass без заметки с типом вызовет исключение среды выполнения',
        dataClassPostInitParamCount: 'Неверное число параметров в методе __post_init__ класса данных; ожидается число, соответствующее числу полей InitVar {expected}',
        dataClassPostInitType: 'Тип параметра метода __post_init__ в классе данных не соответствует типу поля "{fieldName}"',
        dataClassSlotsOverwrite: '__slots__ уже определен в классе',
        dataClassTransformExpectedBoolLiteral: 'Ожидается выражение, статически оцениваемое как True или False',
        dataClassTransformFieldSpecifier: 'Ожидается tuple классов или функций, но получен тип "{type}"',
        dataClassTransformPositionalParam: 'Все аргументы "dataclass_transform" должны быть аргументами типа "ключевое слово"',
        dataClassTransformUnknownArgument: 'Аргумент "{name}" не поддерживается в dataclass_transform',
        dataProtocolInSubclassCheck: 'Протоколы данных (включающие атрибуты, не связанные с методами) запрещены в вызовах issubclass',
        declaredReturnTypePartiallyUnknown: 'Объявленный тип возвращаемого значения "{returnType}" частично неизвестен',
        declaredReturnTypeUnknown: 'Объявленный тип возвращаемого значения неизвестен',
        defaultValueContainsCall: 'Вызовы функций и изменяемые объекты не разрешены в выражении значения параметра по умолчанию',
        defaultValueNotAllowed: 'Параметр с "*" или "**" не может иметь значение по умолчанию',
        delTargetExpr: 'Не удается удалить выражение',
        deprecatedClass: 'Класс "{name}" является нерекомендуемым',
        deprecatedConstructor: 'Конструктор для класса "{name}" больше не рекомендуется к использованию',
        deprecatedDescriptorDeleter: 'Метод "__delete__" для дескриптора "{name}" не рекомендуется',
        deprecatedDescriptorGetter: 'Метод "__get__" для дескриптора "{name}" не рекомендуется',
        deprecatedDescriptorSetter: 'Метод "__set__" для дескриптора "{name}" не рекомендуется',
        deprecatedFunction: 'Функция "{name}" больше не рекомендуется к использованию',
        deprecatedMethod: 'Метод "{name}" в классе "{className}" не рекомендуется к использованию',
        deprecatedPropertyDeleter: 'Метод deleter для property "{name}" не рекомендуется',
        deprecatedPropertyGetter: 'Метод getter для property "{name}" не рекомендуется',
        deprecatedPropertySetter: 'Метод setter для property "{name}" не рекомендуется',
        deprecatedType: 'Этот тип больше не рекомендуется к использованию начиная с версии Python {version}; используйте вместо него "{replacement}"',
        dictExpandIllegalInComprehension: 'Расширение словаря в понимании не допускается',
        dictInAnnotation: 'Словарное выражение не разрешено в выражении типа',
        dictKeyValuePairs: 'Записи словаря должны содержать пары "ключ-значение"',
        dictUnpackIsNotMapping: 'Ожидается сопоставление для оператора распаковки словаря',
        dunderAllSymbolNotPresent: '"{name}" указано в методе __all__, но отсутствует в модуле',
        duplicateArgsParam: 'Разрешен только один параметр "*"',
        duplicateBaseClass: 'Дублирование базового класса не допускается',
        duplicateCapturePatternTarget: 'Целевой объект захвата "{name}" не может появляться более одного раза в одном шаблоне',
        duplicateCatchAll: 'В блоке except допускается только одно предложение catch-all',
        duplicateEnumMember: 'Элемент Enum типа "{name}" уже объявлен',
        duplicateGenericAndProtocolBase: 'Допускается только один базовый класс Generic[...] или Protocol[...]',
        duplicateImport: '"{importName}" импортируется несколько раз',
        duplicateKeywordOnly: 'Разрешен только один разделитель "*"',
        duplicateKwargsParam: 'Разрешен только один параметр "**"',
        duplicateParam: 'Параметр "{name}" повторяется',
        duplicatePositionOnly: 'Разрешен только один параметр "/"',
        duplicateStarPattern: 'В последовательности шаблонов допускается только один шаблон "*"',
        duplicateStarStarPattern: 'Допускается только одна запись "**"',
        duplicateUnpack: 'В list разрешена только одна операция распаковки',
        ellipsisAfterUnpacked: '"..." не может использоваться с распакованным элементом TypeVarTuple или tuple',
        ellipsisContext: '"..." не допускается в данном контексте',
        ellipsisSecondArg: '"..." разрешается только в качестве второго из двух аргументов',
        enumClassOverride: 'Enum класс "{name}" является final и не может иметь производных классов',
        enumMemberDelete: 'Не удается удалить элемент Enum "{name}"',
        enumMemberSet: 'Не удается назначить элемент Enum "{name}"',
        enumMemberTypeAnnotation: 'Аннотации типов не разрешены для элементов enum',
        exceptGroupMismatch: 'Оператор Try не может одновременно включать "except" и "except*"',
        exceptGroupRequiresType: 'Для синтаксиса группы исключений ("except*") требуется тип исключения',
        exceptionGroupIncompatible: 'Синтаксис группы исключений ("except*") можно использовать в Python версии не ранее 3.11',
        exceptionGroupTypeIncorrect: 'Тип исключения в except* не может быть производным от BaseGroupException',
        exceptionTypeIncorrect: '"{type}" не является производным от BaseException',
        exceptionTypeNotClass: '"{type}" не является допустимым классом исключений',
        exceptionTypeNotInstantiable: 'Конструктору типа исключения "{type}" требуется один или несколько аргументов',
        expectedAfterDecorator: 'Ожидаемая функция или объявление класса после декоратора',
        expectedArrow: 'Ожидается "->", за которым следует заметка типа к возвращаемому типу',
        expectedAsAfterException: 'Ожидается "as" после типа исключения',
        expectedAssignRightHandExpr: 'Справа от "=" ожидается выражение',
        expectedBinaryRightHandExpr: 'Справа от оператора ожидается выражение',
        expectedBoolLiteral: 'Ожидается True или False',
        expectedCase: 'Ожидается оператор case',
        expectedClassName: 'Ожидается имя класса',
        expectedCloseBrace: 'Для скобки "{" отсутствует закрывающая скобка',
        expectedCloseBracket: 'Для скобки "[" отсутствует закрывающая скобка',
        expectedCloseParen: 'Для скобки "(" отсутствует закрывающая скобка',
        expectedColon: 'Ожидается ":"',
        expectedComplexNumberLiteral: 'Для сопоставления шаблонов ожидается сложный числовой литерал',
        expectedDecoratorExpr: 'Форму выражения для декоратора можно использовать в Python версии не ниже 3.9',
        expectedDecoratorName: 'Ожидается имя декоратора',
        expectedDecoratorNewline: 'В конце декоратора ожидается символ перехода на новую строку',
        expectedDelExpr: 'После "del" ожидается выражение',
        expectedElse: 'Ожидается ключевое слово "else"',
        expectedEquals: 'Ожидается "="',
        expectedExceptionClass: 'Недопустимый класс или объект исключения',
        expectedExceptionObj: 'Ожидается объект исключения, класс исключения или значение None',
        expectedExpr: 'Ожидается выражение',
        expectedFunctionAfterAsync: 'Ожидается определение функции после "async"',
        expectedFunctionName: 'После ключевого слова "def" ожидается имя функции',
        expectedIdentifier: 'Ожидается идентификатор',
        expectedImport: 'Ожидается "import"',
        expectedImportAlias: 'После "as" ожидается символ',
        expectedImportSymbols: 'После "import" ожидается одно или несколько имен символов',
        expectedIn: 'Ожидается "in"',
        expectedInExpr: 'После ключевого слова "in" ожидается выражение',
        expectedIndentedBlock: 'Ожидается блок с отступом',
        expectedMemberName: 'Требуется указать имя атрибута после "."',
        expectedModuleName: 'Ожидаемое имя модуля',
        expectedNameAfterAs: 'Ожидается имя символа после "as"',
        expectedNamedParameter: 'За "*" должен следовать параметр типа "ключевое слово"',
        expectedNewline: 'Ожидается новая строка',
        expectedNewlineOrSemicolon: 'Операторы должны быть разделены символами перевода строки или точками с запятой',
        expectedOpenParen: 'Ожидается "("',
        expectedParamName: 'Ожидается имя параметра',
        expectedPatternExpr: 'Ожидается выражение шаблона',
        expectedPatternSubjectExpr: 'Ожидаемое выражение субъекта шаблона',
        expectedPatternValue: 'Ожидается выражение значения шаблона в форме "a.b"',
        expectedReturnExpr: 'После "return" ожидается выражение',
        expectedSliceIndex: 'Ожидается выражение индекса или среза',
        expectedTypeNotString: 'Ожидался тип, но получен строковый литерал',
        expectedTypeParameterName: 'Ожидаемое имя параметра типа',
        expectedYieldExpr: 'Ожидаемое выражение в операторе yield',
        finalClassIsAbstract: 'Класс "{type}" помечен как final (окончательный) и должен реализовать все абстрактные символы.',
        finalContext: '"Final" не допускается в данном контексте',
        finalInLoop: 'Переменная "Final" не может быть назначена внутри цикла',
        finalMethodOverride: 'Метод "{name}" не может переопределять final метод, определенный в классе "{className}"',
        finalNonMethod: 'Функцию "{name}" нельзя пометить как @final, так как она не является методом',
        finalReassigned: '"{name}" объявляется Final и не может быть переназначено',
        finalRedeclaration: '"{name}" ранее объявлено как Final',
        finalRedeclarationBySubclass: '"{name}" невозможно повторно объявить, поскольку в родительском классе "{className}" он объявлен как Final',
        finalTooManyArgs: 'После "Final" ожидается один аргумент типа',
        finalUnassigned: '"{name}" объявлен как Final, но ему не присвоено значение',
        formatStringBrace: 'Одиночная закрывающая скобка не допускается в литерале f-строки. Используйте двойную закрывающую скобку',
        formatStringBytes: 'Строковые литералы формата (f-строки) не могут быть двоичными',
        formatStringDebuggingIllegal: 'Для описателя отладки F-строки "=" требуется версия Python 3.8 или более новая',
        formatStringEscape: 'Escape-последовательность (обратная косая черта) не разрешена в части выражения f-строки до версии Python 3.12',
        formatStringExpectedConversion: 'После "!" в f-строке ожидался спецификатор преобразования',
        formatStringIllegal: 'Для строковых литералов формата (f-строки) требуется версия Python 3.6 или более новая',
        formatStringInPattern: 'Строка формата не разрешена в шаблоне',
        formatStringNestedFormatSpecifier: 'В строке спецификации формата слишком высок уровень вложенности выражений',
        formatStringNestedQuote: 'Строки, вложенные в f-строку, не могут использовать тот же символ кавычка, что и f-строка до Python 3.12',
        formatStringUnicode: 'Строковые литералы формата (f-строки) не могут быть в кодировке Unicode',
        formatStringUnterminated: 'Незавершенное выражение в f-строке; ожидается "}"',
        functionDecoratorTypeUnknown: 'Нетипизированный декоратор функции скрывает тип функции; декоратор будет игнорирован',
        functionInConditionalExpression: 'Условное выражение ссылается на функцию, которая всегда возвращает значение True',
        functionTypeParametersIllegal: 'Для синтаксиса параметра типа функции требуется версия Python 3.12 или более новая',
        futureImportLocationNotAllowed: 'Операторы импорта из __future__ должны находиться в начале файла',
        generatorAsyncReturnType: 'Тип возвращаемого значения функции генератора async должен быть совместим с "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: 'Выражения генератора следует взять в скобки, если аргументов больше одного',
        generatorSyncReturnType: 'Возвращаемый тип функции генератора должен быть совместим с "Generator[{yieldType}, Any, Any]"',
        genericBaseClassNotAllowed: 'Базовый класс "Generic" нельзя использовать с синтаксисом параметра типа',
        genericClassAssigned: 'Универсальный тип класса невозможно присвоить',
        genericClassDeleted: 'Не удается удалить универсальный тип класса',
        genericInstanceVariableAccess: 'Доступ к универсальной переменной экземпляра через класс является неоднозначным',
        genericNotAllowed: 'Ключевое слово "Generic" недопустимо в этом контексте',
        genericTypeAliasBoundTypeVar: 'Псевдоним универсального типа в классе не может использовать переменные привязанного типа {names}',
        genericTypeArgMissing: 'Для "Generic" требуется по крайней мере один аргумент типа',
        genericTypeArgTypeVar: 'Аргумент типа для "Generic" должен быть переменной типа',
        genericTypeArgUnique: 'Аргументы типа для "Generic" должны быть уникальными',
        globalReassignment: 'Присвоение "{name}" происходит раньше global объявления',
        globalRedefinition: 'Имя "{name}" уже объявлено ранее как global',
        implicitStringConcat: 'Неявное объединение строк не разрешено',
        importCycleDetected: 'Обнаружен цикл в цепочке импорта',
        importDepthExceeded: 'Глубина цепочки импорта превысила {depth}',
        importResolveFailure: 'Не удается разрешить импорт "{importName}"',
        importSourceResolveFailure: 'Не удается разрешить импорт "{importName}" из источника',
        importSymbolUnknown: '"{name}" — неизвестный символ импорта',
        incompatibleMethodOverride: 'Метод "{name}" переопределяет класс "{className}" несовместимым образом',
        inconsistentIndent: 'Сумма отступа не соответствует предыдущему отступу',
        inconsistentTabs: 'Непоследовательное использование вкладок и пробелов в отступах',
        initMethodSelfParamTypeVar: 'Заметка типа для параметра "self" метода "__init__" не может содержать переменные типа в области класса.',
        initMustReturnNone: 'Метод "__init__" должен возвращать тип None',
        initSubclassCallFailed: 'Неверные аргументы ключевых слов для метода __init_subclass__',
        initSubclassClsParam: 'Переопределение метода __init_subclass__ должно принимать параметр "cls"',
        initVarNotAllowed: 'Использование "InitVar" в этом контексте не допускается',
        instanceMethodSelfParam: 'Методы экземпляра должны принимать параметр "self"',
        instanceVarOverridesClassVar: 'Переменная экземпляра "{name}" переопределяет переменную класса с тем же именем в классе "{className}"',
        instantiateAbstract: 'Не удается создать экземпляр абстрактного класса "{type}"',
        instantiateProtocol: 'Не удается создать экземпляр класса Protocol "{type}"',
        internalBindError: 'При привязке файла "{file}" произошла внутренняя ошибка: {message}',
        internalParseError: 'При разборе файла "{file}" произошла внутренняя ошибка: {message}',
        internalTypeCheckingError: 'При проверке файла "{file}" произошла внутренняя ошибка: {message}',
        invalidIdentifierChar: 'Недопустимый символ в идентификаторе',
        invalidStubStatement: 'Инструкция не имеет смысла в файле stub типа',
        invalidTokenChars: 'Недопустимый символ "{text}" в маркере',
        isInstanceInvalidType: 'Второй аргумент "isinstance" должен быть классом или tuple классов',
        isSubclassInvalidType: 'Второй аргумент в "issubclass" должен быть классом или tuple классов',
        keyValueInSet: 'Пары "ключ-значение" не допускаются в set',
        keywordArgInTypeArgument: 'Аргументы ключевых слов нельзя использовать в списках аргументов типа',
        keywordArgShortcutIllegal: 'Ярлык аргумента ключевого слова требует Python 3.14 или более поздней версии',
        keywordOnlyAfterArgs: 'Разделитель аргументов типа "только ключевое слово" не разрешен после параметра "*"',
        keywordParameterMissing: 'За параметром "*" должен следовать один или несколько параметров ключевого слова.',
        keywordSubscriptIllegal: 'Аргументы ключевых слов в нижних индексах не поддерживаются',
        lambdaReturnTypePartiallyUnknown: 'Тип возвращаемого лямбдой значения "{returnType}" частично неизвестен',
        lambdaReturnTypeUnknown: 'Тип значения, возвращаемого лямбдой, неизвестен',
        listAssignmentMismatch: 'Выражение с типом "{type}" нельзя присвоить целевому списку',
        listInAnnotation: 'List выражение не разрешено в выражении типа',
        literalEmptyArgs: 'Ожидается один или несколько аргументов типа после "Literal"',
        literalNamedUnicodeEscape: 'Именованные escape-последовательности Юникода не поддерживаются в аннотациях строк Literal',
        literalNotAllowed: 'Невозможно использовать "Literal" в этом контексте без аргумента типа',
        literalNotCallable: 'Не удается создать экземпляр типа Literal',
        literalUnsupportedType: 'Аргументы типа для "Literal" должны иметь значение None, литеральное значение (int, bool, str или bytes) или значение enum типа',
        matchIncompatible: 'Операторы Match могут использоваться в Python версии не ниже 3.10',
        matchIsNotExhaustive: 'Блоки case в операторе match обрабатывают не все множество возможных значений',
        maxParseDepthExceeded: 'Превышена максимальная глубина разбора; разбейте выражение на составляющие выражения меньшего размера',
        memberAccess: 'Не удается получить доступ к атрибуту "{name}" для класса "{type}"',
        memberDelete: 'Не удается удалить атрибут "{name}" для класса "{type}"',
        memberSet: 'Не удается назначить атрибуту "{name}" для класса "{type}"',
        metaclassConflict: 'Метакласс производного класса должен быть производным классом метаклассов всех его базовых классов',
        metaclassDuplicate: 'Можно указать только один метакласс',
        metaclassIsGeneric: 'Метакласс не может быть универсальным',
        methodNotDefined: 'Метод "{name}" не определен',
        methodNotDefinedOnType: 'Метод "{name}" не определен для типа "{type}"',
        methodOrdering: 'Не удается создать согласованный порядок методов',
        methodOverridden: '"{name}" переопределяет метод с тем же именем в классе "{className}" с несовместимым типом "{type}"',
        methodReturnsNonObject: 'Метод "{name}" не возвращает объект',
        missingSuperCall: 'Метод "{methodName}" не вызывает метод с тем же именем в родительском классе',
        mixingBytesAndStr: 'Невозможно объединить bytes и str значения',
        moduleAsType: 'Модуль не может использоваться в качестве типа',
        moduleNotCallable: 'Модуль не является вызываемым',
        moduleUnknownMember: '"{memberName}" не является известным атрибутом модуля "{moduleName}"',
        namedExceptAfterCatchAll: 'Именованное предложение except не может стоять после предложения catch-all except',
        namedParamAfterParamSpecArgs: 'Параметр ключевого слова "{name}" не может размещаться в сигнатуре после параметра ParamSpec args',
        namedTupleEmptyName: 'Имена в именованном tuple не могут быть пустыми',
        namedTupleEntryRedeclared: 'Не удается переопределить "{name}", так как родительский класс "{className}" является именованным tuple',
        namedTupleFirstArg: 'В качестве первого аргумента ожидалось имя именованного класса tuple',
        namedTupleMultipleInheritance: 'Множественное наследование для NamedTuple не поддерживается',
        namedTupleNameKeyword: 'Имена полей не могут быть ключевыми словами',
        namedTupleNameType: 'Ожидается двухфакторный tuple с указанием имени и типа записи',
        namedTupleNameUnique: 'Имена внутри именованного tuple должны быть уникальными',
        namedTupleNoTypes: '"namedtuple" не предоставляет типов для записей кортежа; используйте вместо него "NamedTuple"',
        namedTupleSecondArg: 'В качестве второго аргумента ожидается именованный list записей tuple',
        newClsParam: 'Переопределение метода __new__ должно принимать параметр "cls"',
        newTypeAnyOrUnknown: 'Второй аргумент для NewType должен быть известным классом, а не вариантом "Any" или "Unknown"',
        newTypeBadName: 'Первый аргумент NewType должен быть строковым литералом',
        newTypeLiteral: 'NewType нельзя использовать с типом Literal',
        newTypeNameMismatch: 'NewType должен быть назначен переменной с тем же именем',
        newTypeNotAClass: 'В NewType в качестве второго аргумента ожидается класс',
        newTypeParamCount: 'Для NewType требуются два позиционных аргумента',
        newTypeProtocolClass: 'NewType нельзя использовать со структурным типом (класс Protocol или TypedDict)',
        noOverload: 'Не существует перегрузок для "{name}", соответствующих указанным аргументам',
        noReturnContainsReturn: 'Функция с объявленным типом return значения "NoReturn" не может содержать оператор return',
        noReturnContainsYield: 'Функция с объявленным типом возвращаемого значения "NoReturn" не может содержать инструкцию yield',
        noReturnReturnsNone: 'Функция с объявленным типом возвращаемого значения "NoReturn" не может возвращать "None"',
        nonDefaultAfterDefault: 'Аргумент, отличный от аргумента по умолчанию, следует за аргументом по умолчанию',
        nonLocalInModule: 'Nonlocal объявления на уровне модулей не разрешены',
        nonLocalNoBinding: 'Привязка для nonlocal элемента "{name}" не найдена',
        nonLocalReassignment: 'Назначение "{name}" происходит раньше nonlocal объявления',
        nonLocalRedefinition: '"{name}" уже объявлено ранее как nonlocal',
        noneNotCallable: 'Объект типа "None" не может быть вызван',
        noneNotIterable: 'Объект типа "None" не может использоваться в качестве итерируемого значения',
        noneNotSubscriptable: 'Объект типа "None" не подлежит подписке',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Оператор "{operator}" не поддерживается для "None"',
        noneUnknownMember: '"{name}" не является известным атрибутом "None"',
        notRequiredArgCount: 'После "NotRequired" ожидается один аргумент типа',
        notRequiredNotInTypedDict: 'Использование "NotRequired" в этом контексте не допускается',
        objectNotCallable: 'Объект типа "{type}" не является вызываемым',
        obscuredClassDeclaration: 'Объявление класса "{name}" скрывается объявлением с тем же именем',
        obscuredFunctionDeclaration: 'Объявление функции "{name}" скрывается объявлением с тем же именем',
        obscuredMethodDeclaration: 'Объявление метода "{name}" скрывается объявлением с тем же именем',
        obscuredParameterDeclaration: 'Объявление параметра "{name}" скрывается объявлением с тем же именем',
        obscuredTypeAliasDeclaration: 'Объявление псевдонима типа "{name}" скрывается объявлением с тем же именем',
        obscuredVariableDeclaration: 'Объявление "{name}" скрывается объявлением с тем же именем',
        operatorLessOrGreaterDeprecated: 'Оператор "<>" не поддерживается в Python 3; используйте вместо него "!="',
        optionalExtraArgs: 'Ожидается один аргумент типа после "Optional"',
        orPatternIrrefutable: 'Неопровержимый шаблон допускается только в качестве последнего вложенного шаблона в шаблоне "or"',
        orPatternMissingName: 'Все вложенные шаблоны в шаблоне "or" должны быть привязаны к одним и тем же именам',
        overlappingKeywordArgs: 'Типизированный словарь перекрывается с параметром ключевого слова: {names}',
        overlappingOverload: 'Перегрузка {obscured} для "{name}" никогда не будет использоваться, так как ее параметры перекрывают перегрузку {obscuredBy}',
        overloadAbstractImplMismatch: 'Перегрузки должны соответствовать абстрактному статусу реализации',
        overloadAbstractMismatch: 'Все перегрузки должны быть абстрактными или не абстрактными',
        overloadClassMethodInconsistent: 'Перегрузки для "{name}" используют @classmethod несогласованно',
        overloadFinalInconsistencyImpl: 'Перегрузка для "{name}" помечена как @final, но реализация — нет',
        overloadFinalInconsistencyNoImpl: 'Перегрузка {index} для "{name}" помечена как @final, но перегрузка 1 — нет',
        overloadImplementationMismatch: 'Перегруженная реализация не согласована с сигнатурой перегрузки {index}',
        overloadReturnTypeMismatch: 'Перегрузка {prevIndex} для "{name}" перекрывает перегрузку {newIndex} и возвращает несовместимый тип',
        overloadStaticMethodInconsistent: 'Перегрузки для "{name}" используют @staticmethod несогласованно',
        overloadWithoutImplementation: '"{name}" помечен как overload, но реализация не предоставлена',
        overriddenMethodNotFound: 'Метод "{name}" помечен как override, но базового метода с таким же именем нет',
        overrideDecoratorMissing: 'Метод "{name}" не помечен как override, но переопределяет метод в классе "{className}"',
        paramAfterKwargsParam: 'Параметр не может следовать за параметром "**"',
        paramAlreadyAssigned: 'Параметр "{name}" уже назначен.',
        paramAnnotationMissing: 'Отсутствует заметка с типом для параметра "{name}"',
        paramAssignmentMismatch: 'Выражение типа "{sourceType}" не может быть назначено параметру типа "{paramType}"',
        paramNameMissing: 'Параметра с именем "{name}" не существует',
        paramSpecArgsKwargsDuplicate: 'Аргументы для "{type}" ParamSpec уже предоставлены',
        paramSpecArgsKwargsUsage: 'Атрибуты "args" и "kwargs" ParamSpec должны одновременно присутствовать в сигнатуре функции',
        paramSpecArgsMissing: 'Отсутствуют аргументы для "{type}" ParamSpec',
        paramSpecArgsUsage: 'Атрибут "args" ParamSpec допустим только при использовании с параметром *args',
        paramSpecAssignedName: 'ParamSpec необходимо присвоить переменной с именем "{name}"',
        paramSpecContext: 'ParamSpec не допускается в этом контексте',
        paramSpecDefaultNotTuple: 'Для значения ParamSpec по умолчанию ожидается многоточие, выражение tuple или ParamSpec',
        paramSpecFirstArg: 'Ожидается имя ParamSpec в качестве первого аргумента',
        paramSpecKwargsUsage: 'Атрибут "kwargs" ParamSpec допустим только при использовании с параметром **kwargs',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" не имеет смысла в этом контексте',
        paramSpecUnknownArg: 'ParamSpec не поддерживает более одного аргумента',
        paramSpecUnknownMember: '"{name}" не является известным атрибутом ParamSpec',
        paramSpecUnknownParam: '"{name}" является неизвестным параметром для ParamSpec',
        paramTypeCovariant: 'Переменную ковариантного типа нельзя использовать в типе параметра',
        paramTypePartiallyUnknown: 'Тип параметра "{paramName}" частично неизвестен',
        paramTypeUnknown: 'Тип параметра "{paramName}" неизвестен',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Шаблон никогда не будет совпадать для типа субъекта "{type}"',
        positionArgAfterNamedArg: 'Позиционный аргумент не может стоять после аргументов типа "ключевое слово"',
        positionOnlyAfterArgs: 'Разделитель чисто позиционных параметров после параметра "*" не разрешен',
        positionOnlyAfterKeywordOnly: 'Параметр "/" должен располагаться перед параметром "*"',
        positionOnlyAfterNon: 'Чисто позиционный параметр не разрешен после параметра, который не является чисто позиционным',
        positionOnlyFirstParam: 'Разделитель чисто позиционных параметров в качестве первого параметра не разрешен',
        positionOnlyIncompatible: 'Разделитель чисто позиционных параметров можно использовать в Python версии не ниже 3.8',
        privateImportFromPyTypedModule: '"{name}" не экспортируется из модуля "{module}"',
        privateUsedOutsideOfClass: 'Элемент "{name}" является закрытым, но используется вне класса, в котором объявлен',
        privateUsedOutsideOfModule: '"{name}" является закрытым, но используется вне модуля, в котором объявлен',
        propertyOverridden: '"{name}" неправильно переопределяет property с таким же именем в классе "{className}"',
        propertyStaticMethod: 'Статические методы не разрешены в методах getter, setter и deleter property',
        protectedUsedOutsideOfClass: '"{name}" защищено и используется вне класса, в котором оно объявлено',
        protocolBaseClass: 'Класс Protocol "{classType}" не может быть производным от класса "{baseType}", отличного от Protocol',
        protocolBaseClassWithTypeArgs: 'Аргументы типа не допускаются с классом Protocol при использовании синтаксиса параметра типа',
        protocolIllegal: 'Ключевое слово "Protocol" можно использовать в Python версии не ниже 3.7',
        protocolNotAllowed: 'Невозможно использовать "Protocol" в этом контексте',
        protocolTypeArgMustBeTypeParam: 'Аргумент типа для параметра "Protocol" должен быть параметром типа',
        protocolUnsafeOverlap: 'Класс небезопасно перекрывает "{name}" и может вызвать совпадение во время выполнения',
        protocolVarianceContravariant: 'Переменная типа "{variable}", используемая в универсальном Protocol "{class}", должна быть контравариантной.',
        protocolVarianceCovariant: 'Переменная типа "{variable}", используемая в универсальном Protocol "{class}", должна быть ковариантной',
        protocolVarianceInvariant: 'Переменная типа "{variable}", используемая в универсальном Protocol "{class}", должна быть инвариантной',
        pyrightCommentInvalidDiagnosticBoolValue: 'За директивой комментария Pyright должно следовать "=" и значение true или false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'За директивой комментария Pyright должно следовать "=" и одно из следующих значений: true, false, error, warning, information или none',
        pyrightCommentMissingDirective: 'После комментария Pyright должна следовать директива (basic или strict) или правило диагностики',
        pyrightCommentNotOnOwnLine: 'Комментарии Pyright, используемые для управления параметрами на уровне файлов, должны располагаться в отдельной строке',
        pyrightCommentUnknownDiagnosticRule: 'Правило диагностики "{rule}" для комментария pyright неизвестно',
        pyrightCommentUnknownDiagnosticSeverityValue: 'Значение "{value}" недопустимо для комментария pyright; ожидается одно из значений true, false, error, warning, information или none',
        pyrightCommentUnknownDirective: '"{directive}" является неизвестной директивой для комментария pyright; ожидается "strict" или "basic"',
        readOnlyArgCount: 'Ожидается один аргумент типа после "ReadOnly"',
        readOnlyNotInTypedDict: 'Использование "ReadOnly" в этом контексте не допускается',
        recursiveDefinition: 'Не удалось определить тип "{name}", так как он ссылается на себя',
        relativeImportNotAllowed: 'Операции импорта с относительным путем нельзя использовать с формой "import .a"; используйте вместо этого "from . import a"',
        requiredArgCount: 'Ожидается один аргумент типа после "Required"',
        requiredNotInTypedDict: 'Использование "Required" в этом контексте не допускается',
        returnInAsyncGenerator: 'Оператор return со значением не допускается в генераторе async',
        returnInExceptionGroup: 'Запрещено наличие "return" в блоке "except*"',
        returnMissing: 'Функция с объявленным типом возвращаемого значения "{returnType}" должна возвращать значение во всех путях кода',
        returnOutsideFunction: '"return" можно использовать только внутри функции',
        returnTypeContravariant: 'Переменная контравариантного типа не может использоваться в возвращаемом типе',
        returnTypeMismatch: 'Тип "{exprType}" не может быть присвоен для возврата типа "{returnType}"',
        returnTypePartiallyUnknown: 'Тип возвращаемого значения "{returnType}" частично неизвестен',
        returnTypeUnknown: 'Тип возвращаемого значения неизвестен',
        revealLocalsArgs: 'Не ожидаются аргументы для вызова "reveal_locals"',
        revealLocalsNone: 'В этой области нет locals',
        revealTypeArgs: 'Для вызова "reveal_type" ожидается один позиционный аргумент',
        revealTypeExpectedTextArg: 'Аргумент "expected_text" для функции "reveal_type" должен быть значением литерала str',
        revealTypeExpectedTextMismatch: 'Несоответствие текста в типе; ожидалось "{expected}", но получено "{received}"',
        revealTypeExpectedTypeMismatch: 'Несоответствие типов; ожидается "{expected}", но получено "{received}"',
        selfTypeContext: '\'В этом контексте ключевое слово "Self" недопустимо',
        selfTypeMetaclass: '"Self" нельзя использовать в метаклассе (подкласс "type")',
        selfTypeWithTypedSelfOrCls: 'Ключевое слово "Self" нельзя использовать в функции с параметром "self" или "cls" с заметкой типа, отличной от "Self".',
        setterGetterTypeMismatch: 'Тип значения setter property нельзя присвоить типу возвращаемого значения getter',
        singleOverload: 'Элемент "{name}" помечен как перегруженный, но дополнительные перегрузки отсутствуют',
        slotsAttributeError: '"{name}" не указано в __slots__',
        slotsClassVarConflict: '"{name}" конфликтует с переменной экземпляра, объявленной в __slots__',
        starPatternInAsPattern: 'Шаблон "звездочка" не может использоваться с целевым объектом "as"',
        starPatternInOrPattern: 'Шаблон "звездочка" не может быть аргументом операции OR в других шаблонах',
        starStarWildcardNotAllowed: '** нельзя использовать с символом подстановки "_"',
        staticClsSelfParam: 'Статические методы не принимают в качестве параметра "self" и "cls"',
        stdlibModuleOverridden: '"{path}" переопределяет модуль stdlib "{name}"',
        stringNonAsciiBytes: 'Символы, отличные от ASCII, не допускаются в строковом литерале байтов',
        stringNotSubscriptable: 'От строкового выражения нельзя взять подстроку в выражении типа; заключите все выражение в кавычки',
        stringUnsupportedEscape: 'Неподдерживаемая escape-последовательность в строковом литерале',
        stringUnterminated: 'В строковом литерале отсутствует символ конца строки',
        stubFileMissing: 'Файл stub для "{importName}" не найден',
        stubUsesGetAttr: 'Файл stub типа неполон; "__getattr__" скрывает ошибки типа для модуля',
        sublistParamsIncompatible: 'Параметры sublist списка не поддерживаются в Python 3.x',
        superCallArgCount: 'Ожидается не более двух аргументов для вызова "super"',
        superCallFirstArg: 'В качестве первого аргумента для вызова "super" ожидался тип класса, но получен "{type}"',
        superCallSecondArg: 'Второй аргумент для вызова "super" должен быть объектом или классом, производным от "{type}"',
        superCallZeroArgForm: 'Форма вызова "super" с нулевым аргументом допустима только внутри метода',
        superCallZeroArgFormStaticMethod: 'Форма вызова "super" с нулевым аргументом недопустима в статическом методе',
        symbolIsPossiblyUnbound: 'Элемент "{name}", возможно, не привязан',
        symbolIsUnbound: 'Элемент "{name}" не привязан',
        symbolIsUndefined: '"{name}" не определено',
        symbolOverridden: '"{name}" переопределяет символ с тем же именем в классе "{className}"',
        ternaryNotAllowed: 'Тернарное выражение не разрешено в выражении типа',
        totalOrderingMissingMethod: 'Чтобы можно было использовать total_ordering, в классе должен быть определен один из операторов: "__lt__", "__le__", "__gt__" или "__ge__"',
        trailingCommaInFromImport: 'Конечные запятые можно использовать только при заключении в скобки',
        tryWithoutExcept: 'В операторе try должно быть хотя бы одно предложение except или finally',
        tupleAssignmentMismatch: 'Выражение с типом "{type}" не может быть назначено целевому tuple',
        tupleInAnnotation: 'Выражение tuple не разрешено в выражении типа',
        tupleIndexOutOfRange: 'Индекс {index} выходит за пределы допустимого диапазона для типа {type}',
        typeAliasIllegalExpressionForm: 'Недопустимая форма выражения для определения псевдонима типа',
        typeAliasIsRecursiveDirect: 'Псевдоним типа "{name}" не может использовать себя в своем определении',
        typeAliasNotInModuleOrClass: 'TypeAlias можно определить только внутри области модуля или класса',
        typeAliasRedeclared: '"{name}" объявлен как TypeAlias и может быть присвоен только один раз',
        typeAliasStatementBadScope: 'Утверждение type можно использовать только внутри области модуля или класса',
        typeAliasStatementIllegal: 'Оператор псевдонима типа можно использовать в Python версии не ниже 3.12',
        typeAliasTypeBaseClass: 'Псевдоним типа, определяемый в операторе "type", не может использоваться в качестве базового класса.',
        typeAliasTypeMustBeAssigned: 'TypeAliasType должен быть назначен переменной с тем же именем, что и псевдоним типа',
        typeAliasTypeNameArg: 'Первый аргумент TypeAliasType должен быть строковым литералом, представляющим имя псевдонима типа',
        typeAliasTypeNameMismatch: 'Имя псевдонима типа должно соответствовать имени переменной, которой оно назначено',
        typeAliasTypeParamInvalid: 'Список параметров типа должен быть tuple, содержащим только TypeVar, TypeVarTuple или ParamSpec',
        typeAnnotationCall: 'Выражение вызова не разрешено в выражении типа',
        typeAnnotationVariable: 'Переменная не разрешена в выражении типа',
        typeAnnotationWithCallable: 'Аргумент типа для "type" должен быть классом. Вызываемые объекты не поддерживаются',
        typeArgListExpected: 'Ожидается ParamSpec, многоточие или list типов',
        typeArgListNotAllowed: 'Выражение list не разрешено для аргумента этого типа',
        typeArgsExpectingNone: 'Для класса "{name}" не ожидается аргументов типа',
        typeArgsMismatchOne: 'Ожидается один аргумент типа, но получено {received}',
        typeArgsMissingForAlias: 'Для псевдонима универсального типа "{name}" ожидаются аргументы типа',
        typeArgsMissingForClass: 'Ожидаются аргументы типа для универсального класса "{name}"',
        typeArgsTooFew: 'Указано слишком мало аргументов типа для "{name}"; ожидалось {expected}, но получено {received}',
        typeArgsTooMany: 'Для "{name}" предоставлено слишком много аргументов типа. Ожидается {expected}, но получено {received}',
        typeAssignmentMismatch: 'Тип "{sourceType}" не может быть назначен объявленному типу "{destType}"',
        typeAssignmentMismatchWildcard: 'Символ импорта "{name}" имеет тип "{sourceType}", который не может быть назначен объявленному типу "{destType}"',
        typeCallNotAllowed: 'Вызов type() не разрешен в выражении типа',
        typeCheckOnly: '"{name}" помечено как @type_check_only и может использоваться только в заметках с типом',
        typeCommentDeprecated: 'Комментарии type больше не рекомендуются к использованию; вместо них используйте заметки type',
        typeExpectedClass: 'Ожидался класс, но получен "{type}"',
        typeFormArgs: '"TypeForm" принимает один позиционный аргумент',
        typeGuardArgCount: 'После "TypeGuard" или "TypeIs" ожидается один аргумент типа',
        typeGuardParamCount: 'Определяемые пользователем функции и методы защиты типов должны иметь по крайней мере один входной параметр',
        typeIsReturnType: 'Тип возвращаемого значения TypeIs ("{returnType}") не соответствует типу параметра значения ("{type}")',
        typeNotAwaitable: '"{type}" не является awaitable',
        typeNotIntantiable: 'Не удается создать экземпляр "{type}"',
        typeNotIterable: '"{type}" не является итерируемым',
        typeNotSpecializable: 'Не удалось специализировать тип "{type}"',
        typeNotSubscriptable: 'Объект типа "{type}" не поддерживает операцию получения подстроки',
        typeNotSupportBinaryOperator: 'Оператор "{operator}" не поддерживается для типов "{leftType}" и "{rightType}"',
        typeNotSupportBinaryOperatorBidirectional: 'Оператор "{operator}" не поддерживается для типов "{leftType}" и "{rightType}", если ожидаемый тип является "{expectedType}"',
        typeNotSupportUnaryOperator: 'Оператор "{operator}" не поддерживается для типа "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'Оператор "{operator}" не поддерживается для типа "{type}", если ожидается тип "{expectedType}"',
        typeNotUsableWith: 'Объект типа "{type}" нельзя использовать с ключевым словом "with", так как он не реализует метод {method}',
        typeParameterBoundNotAllowed: 'Привязку или ограничение нельзя использовать с параметром типа variadic или ParamSpec',
        typeParameterConstraintTuple: 'Ограничение параметра типа должно быть кортежем двух или более типов',
        typeParameterExistingTypeParameter: 'Параметр типа "{name}" уже используется',
        typeParameterNotDeclared: 'Параметр типа "{name}" не включен в список параметров типа для контейнера "{container}"',
        typeParametersMissing: 'Необходимо указать хотя бы один параметр типа',
        typePartiallyUnknown: 'Тип "{name}" частично неизвестен',
        typeUnknown: 'Тип "{name}" неизвестен',
        typeVarAssignedName: 'TypeVar необходимо присвоить переменной с именем "{name}"',
        typeVarAssignmentMismatch: 'Тип "{type}" не может быть присвоен переменной типа "{name}"',
        typeVarBoundAndConstrained: 'TypeVar не может быть одновременно привязанным и ограниченным',
        typeVarBoundGeneric: 'Тип привязки TypeVar не может быть универсальным',
        typeVarConstraintGeneric: 'Тип ограничения TypeVar не может быть универсальным',
        typeVarDefaultBoundMismatch: 'Тип по умолчанию TypeVar должен быть подтипом привязанного типа',
        typeVarDefaultConstraintMismatch: 'Тип по умолчанию TypeVar должен быть одним из ограниченных типов',
        typeVarDefaultIllegal: 'Для типов переменных по умолчанию требуется версия Python 3.13 или более новая',
        typeVarDefaultInvalidTypeVar: 'Параметр типа "{name}" имеет тип по умолчанию, который ссылается на одну или несколько переменных типа, находящихся вне области',
        typeVarFirstArg: 'В качестве первого аргумента ожидалось имя TypeVar',
        typeVarInvalidForMemberVariable: 'Тип атрибута не может использовать переменную "{name}" в локальном методе',
        typeVarNoMember: 'У TypeVar "{type}" нет атрибута "{name}"',
        typeVarNotSubscriptable: 'Невозможно взять подстроку от "{type}" TypeVar',
        typeVarNotUsedByOuterScope: 'Переменная типа "{name}" не имеет смысла в этом контексте',
        typeVarPossiblyUnsolvable: 'Переменная типа "{name}" может остаться нерешенной, если вызывающая сторона не указывает аргумент для параметра "{param}"',
        typeVarSingleConstraint: 'TypeVar должен иметь не менее двух ограниченных типов',
        typeVarTupleConstraints: 'TypeVarTuple не может использовать ограничения значений',
        typeVarTupleContext: 'TypeVarTuple не допускается в этом контексте',
        typeVarTupleDefaultNotUnpacked: 'Тип по умолчанию TypeVarTuple должен быть распакованным tuple или TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'Для значения TypeVarTuple требуется оператор распаковки',
        typeVarTupleUnknownParam: '"{name}" является неизвестным параметром для TypeVarTuple',
        typeVarUnknownParam: '"{name}" является неизвестным параметром для TypeVar',
        typeVarUsedByOuterScope: 'TypeVar "{name}" уже используется внешней областью',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" появляется в сигнатуре универсальной функции только один раз',
        typeVarVariance: 'TypeVar не может быть одновременно ковариантным и контравариантным',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}" имеет значение по умолчанию и не может следовать за TypeVarTuple "{variadicName}"',
        typeVarWithoutDefault: '"{name}" не может появиться после "{other}" в списке параметров типа, так как у него нет типа по умолчанию',
        typeVarsNotInGenericOrProtocol: 'Generic[] и Protocol[] должны включать все переменные типа',
        typedDictAccess: 'Не удалось получить доступ к элементу в TypedDict',
        typedDictAssignedName: 'TypedDict необходимо присвоить переменной с именем "{name}"',
        typedDictBadVar: 'Классы TypedDict могут содержать только заметки с типом',
        typedDictBaseClass: 'Все базовые классы для классов TypedDict также должны быть классами TypedDict',
        typedDictBoolParam: 'От параметра "{name}" ожидается значение True или False',
        typedDictClosedExtras: 'Базовый класс "{name}" представляет собой closed TypedDict; дополнительные элементы должны иметь тип "{type}"',
        typedDictClosedNoExtras: 'Базовый класс "{name}" представляет собой closed TypedDict; дополнительные элементы не разрешены',
        typedDictDelete: 'Не удалось удалить элемент в TypedDict',
        typedDictEmptyName: 'Имена в TypedDict не могут быть пустыми',
        typedDictEntryName: 'Для имени записи словаря ожидается строковый литерал',
        typedDictEntryUnique: 'Имена в словаре должны быть уникальными',
        typedDictExtraArgs: 'Дополнительные аргументы TypedDict не поддерживаются',
        typedDictExtraItemsClosed: 'TypedDict не может быть "closed", если он поддерживает дополнительные элементы',
        typedDictFieldNotRequiredRedefinition: 'Элемент TypedDict "{name}" нельзя переопределить как NotRequired',
        typedDictFieldReadOnlyRedefinition: 'Элемент TypedDict "{name}" нельзя переопределить как доступный ReadOnly',
        typedDictFieldRequiredRedefinition: 'Элемент TypedDict "{name}" нельзя переопределить как Required',
        typedDictFirstArg: 'В качестве первого аргумента ожидается имя класса TypedDict',
        typedDictInClassPattern: 'Класс TypedDict не разрешен в шаблоне класса',
        typedDictInitsubclassParameter: 'TypedDict не поддерживает параметр __init_subclass__ "{name}"',
        typedDictNotAllowed: 'Невозможно использовать "TypedDict" в этом контексте',
        typedDictSecondArgDict: 'В качестве второго параметра ожидается dict или ключевое слово',
        typedDictSecondArgDictEntry: 'Ожидается простая запись словаря',
        typedDictSet: 'Не удалось назначить элемент в TypedDict',
        unaccessedClass: 'Нет доступа к классу "{name}"',
        unaccessedFunction: 'Доступ к функции "{name}" не производится',
        unaccessedImport: 'Доступ к импорту "{name}" не производится',
        unaccessedSymbol: 'Доступ к "{name}" не осуществляется',
        unaccessedVariable: 'Доступ к переменной "{name}" не производится',
        unannotatedFunctionSkipped: 'Анализ функции "{name}" пропущен, так как она не аннотирована.',
        unaryOperationNotAllowed: 'Унарный оператор нельзя использовать в выражении типа',
        unexpectedAsyncToken: 'После "async" ожидается "def", "with" или "for"',
        unexpectedExprToken: 'Непредвиденный токен в конце выражения',
        unexpectedIndent: 'Непредвиденный отступ',
        unexpectedUnindent: 'Отступ не ожидается',
        unhashableDictKey: 'Ключ словаря должен быть хэшируемым',
        unhashableSetEntry: 'Запись set должна быть хэшируемой',
        uninitializedAbstractVariables: 'Переменные, определенные в абстрактном базовом классе, не инициализированы в final классе "{classType}"',
        uninitializedInstanceVariable: 'Переменная экземпляра "{name}" не инициализирована ни в тексте класса, ни в методе __init__',
        unionForwardReferenceNotAllowed: 'Синтаксис Union не может использоваться со строковым операндом; заключите всё выражение в кавычки',
        unionSyntaxIllegal: 'Альтернативный синтаксис объединений можно использовать в версии Python не ниже 3.10',
        unionTypeArgCount: 'Для Union требуется два или более аргумента типа',
        unionUnpackedTuple: 'Union не может включать распакованный tuple',
        unionUnpackedTypeVarTuple: 'Union не может включать распакованный TypeVarTuple',
        unnecessaryCast: 'Ненужный вызов "cast"; тип уже является "{type}"',
        unnecessaryIsInstanceAlways: 'Ненужный вызов isinstance; "{testType}" всегда является экземпляром "{classType}"',
        unnecessaryIsInstanceNever: 'Ненужный вызов isinstance; "{testType}" никогда не является экземпляром "{classType}"',
        unnecessaryIsSubclassAlways: 'Ненужный вызов issubclass. "{testType}" всегда является подклассом "{classType}"',
        unnecessaryIsSubclassNever: 'Ненужный вызов issubclass; "{testType}" никогда не является подклассом "{classType}"',
        unnecessaryPyrightIgnore: 'Ненужный комментарий "# pyright: ignore"',
        unnecessaryPyrightIgnoreRule: 'Ненужное правило "# pyright: ignore": "{name}"',
        unnecessaryTypeIgnore: 'Ненужный комментарий "# type: ignore"',
        unpackArgCount: 'Ожидается один аргумент типа после "Unpack"',
        unpackExpectedTypeVarTuple: 'В качестве аргумента типа для Unpack ожидается элемент TypeVarTuple или tuple',
        unpackExpectedTypedDict: 'Ожидается аргумент типа TypedDict для Unpack',
        unpackIllegalInComprehension: 'Операция распаковки в понимании не разрешена',
        unpackInAnnotation: 'Оператор распаковки нельзя использовать в выражении типа',
        unpackInDict: 'Операция распаковки в словарях не разрешена',
        unpackInSet: 'Оператор распаковки не разрешен в set',
        unpackNotAllowed: 'Unpack допускается в этом контексте',
        unpackOperatorNotAllowed: 'Операция распаковки допускается в этом контексте',
        unpackTuplesIllegal: 'Операцию распаковки в кортежах можно использовать в Python версии не ниже 3.8',
        unpackedArgInTypeArgument: 'В этом контексте нельзя использовать распакованные аргументы',
        unpackedArgWithVariadicParam: 'Невозможно использовать распакованный аргумент для параметра TypeVarTuple',
        unpackedDictArgumentNotMapping: 'Выражение аргумента после ** должно быть сопоставлением с типом ключа "str".',
        unpackedDictSubscriptIllegal: 'Оператор распаковки словаря не допускается внутри операции взятия подстроки',
        unpackedSubscriptIllegal: 'Оператор распаковки в операции взятия подстроки можно использовать в Python версии не ниже 3.11',
        unpackedTypeVarTupleExpected: 'Ожидается распакованный TypeVarTuple; используйте Unpack[{name1}] или *{name2}',
        unpackedTypedDictArgument: 'Не удалось сопоставить распакованный аргумент TypedDict с параметрами',
        unreachableCode: 'Код недоступен',
        unreachableCodeType: 'Анализ типа показывает, что код недоступен',
        unreachableExcept: 'Предложение Except недоступно, так как исключение уже обработано',
        unsupportedDunderAllOperation: 'Операция на "__all__" не поддерживается, поэтому список экспортируемых символов может быть неправильным',
        unusedCallResult: 'Результат выражения вызова принадлежит к типу "{type}" и не используется. Назначьте переменной "_", если это сделано намеренно',
        unusedCoroutine: 'Результат вызова async функции не используется; добавьте ключевое слово "await" или присвойте результат переменной',
        unusedExpression: 'Значение выражения не используется',
        varAnnotationIllegal: 'Заметки type для переменных можно использовать в Python версии не ниже 3.6. Для совместимости с более ранними версиями используйте комментарий к типу.',
        variableFinalOverride: 'Переменная "{name}" помечена как Final и переопределяет non-Final переменную с тем же именем в классе "{className}"',
        variadicTypeArgsTooMany: 'Список аргументов типа может содержать не более одного распакованного элемента TypeVarTuple или tuple',
        variadicTypeParamTooManyAlias: 'Псевдоним типа может иметь не более одного параметра типа TypeVarTuple, но получил несколько ({names})',
        variadicTypeParamTooManyClass: 'Универсальный класс может иметь не более одного параметра типа TypeVarTuple, но получил несколько ({names})',
        walrusIllegal: 'Оператор ":=" может использоваться в Python версии не ниже 3.8',
        walrusNotAllowed: 'Оператор ":=" не допускается в этом контексте без окружающих круглых скобок',
        wildcardInFunction: 'import с подстановочными знаками в классе или функции запрещен',
        wildcardLibraryImport: 'import подстановочных знаков из библиотеки запрещен',
        wildcardPatternTypePartiallyUnknown: 'Тип, захваченный шаблоном подстановки, частично неизвестен',
        wildcardPatternTypeUnknown: 'Тип, захваченный шаблоном подстановки, неизвестен',
        yieldFromIllegal: '"yield from" можно использовать в Python версии не ниже 3.3',
        yieldFromOutsideAsync: '"yield from" не допускается в async функции',
        yieldOutsideFunction: '"yield" не допускается за пределами функции или лямбда-выражении',
        yieldWithinComprehension: '"yield" не допускается внутри понимания',
        zeroCaseStatementsFound: 'Операторе match должен включать по крайней мере один оператор case',
        zeroLengthTupleNotAllowed: 'tuple нулевой длины не допускается в этом контексте'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Специальную форму "Annotated" нельзя использовать с проверками экземпляра и класса',
        argParam: 'Аргумент соответствует параметру "{paramName}"',
        argParamFunction: 'Аргумент соответствует параметру "{paramName}" функции "{functionName}"',
        argsParamMissing: 'У параметра "*{paramName}" нет соответствующего параметра',
        argsPositionOnly: 'Несоответствие параметров только положения. Ожидается {expected}, но получено {received}',
        argumentType: 'Аргумент принадлежит к типу "{type}"',
        argumentTypes: 'Типы аргументов: ({types})',
        assignToNone: 'Для типа не может быть назначено значение "None"',
        asyncHelp: 'Вы имели в виду "async with"?',
        baseClassIncompatible: 'Базовый класс "{baseClass}" несовместим с типом "{type}"',
        baseClassIncompatibleSubclass: 'Базовый класс "{baseClass}" является производным от "{subclass}", который несовместим с типом "{type}"',
        baseClassOverriddenType: 'Базовый класс "{baseClass}" предоставляет тип "{type}", который переопределен',
        baseClassOverridesType: 'Базовый класс "{baseClass}" переопределяет тип "{type}"',
        bytesTypePromotions: 'Установите для параметра disableBytesTypePromotions значение false, чтобы включить повышение типа для "bytearray" и "memoryview"',
        conditionalRequiresBool: 'Метод __bool__ для типа "{operandType}" возвращает тип "{boolReturnType}", а не "bool"',
        dataClassFieldLocation: 'Объявление поля',
        dataClassFrozen: 'Элемент "{name}" зафиксирован',
        dataProtocolUnsupported: '"{name}" является протоколом данных',
        descriptorAccessBindingFailed: 'Не удалось привязать метод "{name}" для класса дескриптора "{className}"',
        descriptorAccessCallFailed: 'Не удалось вызвать метод "{name}" для класса дескриптора "{className}"',
        finalMethod: 'Final метод',
        functionParamDefaultMissing: 'В параметре "{name}" отсутствует аргумент по умолчанию.',
        functionParamName: 'Несоответствие имени параметра: "{destName}" и "{srcName}"',
        functionParamPositionOnly: 'Несоответствие исключительно позиционных параметров; параметр "{name}" не является исключительно позиционным',
        functionReturnTypeMismatch: 'Тип возвращаемого значения функции "{sourceType}" несовместим с типом "{destType}"',
        functionTooFewParams: 'Функция принимает слишком мало позиционных параметров; ожидалось {expected}, но получено {received}',
        functionTooManyParams: 'Функция принимает слишком много позиционных параметров; ожидалось {expected}, но получено {received}',
        genericClassNotAllowed: 'Универсальный тип с аргументами типа запрещен для проверок экземпляров или классов',
        incompatibleDeleter: 'Метод deleter property является несовместимым',
        incompatibleGetter: 'Несовместимый метод getter property',
        incompatibleSetter: 'Метод setter property является несовместимым',
        initMethodLocation: 'Метод __init__ определен в классе "{type}"',
        initMethodSignature: 'Сигнатура __init__ — "{type}"',
        initSubclassLocation: 'Метод __init_subclass__ определен в классе "{name}"',
        invariantSuggestionDict: 'Рассмотрите возможность перехода с "dict" на "Mapping", являющийся ковариантным по типу значения.',
        invariantSuggestionList: 'Рассмотрите возможность перехода с "list" на "Sequence", являющийся ковариантным.',
        invariantSuggestionSet: 'Рассмотрите возможность переключения с "set" на "Container", который является ковариантным',
        isinstanceClassNotSupported: '"{type}" не поддерживается для проверок экземпляров и классов',
        keyNotRequired: '"{name}" не является обязательным ключом в "{type}", поэтому доступ может вызвать исключение во время выполнения',
        keyReadOnly: '"{name}" является ключом только для чтения в "{type}"',
        keyRequiredDeleted: '"{name}" является обязательным ключом и не подлежит удалению',
        keyUndefined: '"{name}" не является определенным ключом в "{type}"',
        kwargsParamMissing: 'У параметра "**{paramName}" нет соответствующего параметра',
        listAssignmentMismatch: 'Тип "{type}" несовместим с целевым списком',
        literalAssignmentMismatch: '"{sourceType}" невозможно назначить тип "{destType}"',
        matchIsNotExhaustiveHint: 'Если не предполагается исчерпывающая обработка, добавьте "case _: pass"',
        matchIsNotExhaustiveType: 'Тип "{type}" не обрабатывается',
        memberAssignment: 'Выражение типа "{type}" не может быть назначено атрибуту "{name}" класса "{classType}"',
        memberIsAbstract: 'Отсутствует реализация "{type}.{name}".',
        memberIsAbstractMore: 'и еще {{count}}...',
        memberIsClassVarInProtocol: '"{name}" определено как класс ClassVar в протоколе',
        memberIsInitVar: '"{name}" является полем только для init-only',
        memberIsInvariant: 'Элемент "{name}" инвариантен, поскольку помечен как mutable',
        memberIsNotClassVarInClass: 'Необходимо определить "{name}" как ClassVar для совместимости с протоколом.',
        memberIsNotClassVarInProtocol: '"{name}" не определено как класс ClassVar в протоколе',
        memberIsNotReadOnlyInProtocol: '"{name}" не является элементом только для чтения в протоколе',
        memberIsReadOnlyInProtocol: '"{name}" в протоколе только для чтения',
        memberIsWritableInProtocol: '"{name}" доступно для записи в протоколе',
        memberSetClassVar: 'Атрибут "{name}" не может быть назначен через экземпляр класса, так как это ClassVar',
        memberTypeMismatch: '"{name}" является несовместимым типом',
        memberUnknown: 'Атрибут "{name}" неизвестен',
        metaclassConflict: 'Метакласс "{metaclass1}" конфликтует с "{metaclass2}"',
        missingDeleter: 'Отсутствует метод deleter property',
        missingGetter: 'Отсутствует метод getter property',
        missingSetter: 'Отсутствует метод setter property',
        namedParamMissingInDest: 'Дополнительный параметр "{name}"',
        namedParamMissingInSource: 'Отсутствует параметр ключевого слова "{name}".',
        namedParamTypeMismatch: 'Параметр ключевого слова "{name}" типа "{sourceType}" несовместим с типом "{destType}"',
        namedTupleNotAllowed: 'NamedTuple не может использоваться для проверок экземпляров или классов',
        newMethodLocation: 'Метод __new__ определен в классе "{type}"',
        newMethodSignature: 'Сигнатура метода __new__ требует "{type}"',
        newTypeClassNotAllowed: 'Класс, созданный с NewType, нельзя использовать с проверками экземпляров и классов',
        noOverloadAssignable: 'Нет перегруженной функции, соответствующей типу "{type}"',
        noneNotAllowed: 'None невозможно использовать для проверок экземпляров или классов',
        orPatternMissingName: 'Отсутствуют имена: {name}',
        overloadIndex: 'Наилучшее совпадение: {index} перегрузки',
        overloadNotAssignable: 'Одна или несколько перегрузок "{name}" не подлежат присвоению',
        overloadSignature: 'Здесь определена сигнатура перегрузки',
        overriddenMethod: 'Переопределенный метод',
        overriddenSymbol: 'Переопределенный символ',
        overrideInvariantMismatch: 'Тип переопределения "{overrideType}" не совпадает с базовым типом "{baseType}"',
        overrideIsInvariant: 'Переменная изменяема, поэтому ее тип является инвариантным',
        overrideNoOverloadMatches: 'В переопределении нет сигнатуры перегрузки, совместимой с базовым методом',
        overrideNotClassMethod: 'Базовый метод объявлен как classmethod, а его переопределение — нет',
        overrideNotInstanceMethod: 'Базовый метод объявлен как метод экземпляра, а его переопределение — нет',
        overrideNotStaticMethod: 'Базовый метод объявлен как staticmethod, а его переопределение — нет',
        overrideOverloadNoMatch: 'Переопределение не обрабатывает все перегрузки базового метода',
        overrideOverloadOrder: 'Перегрузки в методе переопределения должны располагаться в том же порядке, что и в базовом методе',
        overrideParamKeywordNoDefault: 'Несоответствие параметра ключевого слова "{name}": базовый параметр содержит значение аргумента по умолчанию, параметр переопределения — нет',
        overrideParamKeywordType: 'Несоответствие типа параметра ключевого слова "{name}": базовый параметр имеет тип "{baseType}", параметр переопределения имеет тип "{overrideType}"',
        overrideParamName: 'Несоответствие имени параметра {index}: базовый параметр называется "{baseName}", параметр переопределения называется "{overrideName}"',
        overrideParamNameExtra: 'Параметр "{name}" отсутствует в базовом классе',
        overrideParamNameMissing: 'Параметр "{name}" отсутствует в переопределении',
        overrideParamNamePositionOnly: 'Несоответствие параметра {index}: базовый параметр "{baseName}" является параметром ключевого слова, параметр переопределения предназначен только для позиции',
        overrideParamNoDefault: 'Несоответствие параметра {index}: базовый параметр содержит значение аргумента по умолчанию, параметр переопределения — нет',
        overrideParamType: 'Несоответствие типа параметра {index}: базовый параметр имеет тип "{baseType}", параметр переопределения имеет тип "{overrideType}"',
        overridePositionalParamCount: 'Несоответствие позиционного подсчета параметров. Базовый метод содержит {baseCount}, но переопределение содержит {overrideCount}',
        overrideReturnType: 'Несоответствие типа возвращаемого значения: базовый метод возвращает тип "{baseType}", а переопределение — "{overrideType}"',
        overrideType: 'Базовый класс определяет тип как "{type}"',
        paramAssignment: 'Параметр {index}: типа "{sourceType}" несовместим с типом "{destType}"',
        paramSpecMissingInOverride: 'В методе переопределения отсутствуют параметры ParamSpec.',
        paramType: 'Параметр принадлежит к типу "{paramType}"',
        privateImportFromPyTypedSource: 'Вместо этого используйте импорт из "{module}"',
        propertyAccessFromProtocolClass: 'Свойство, определенное в классе протокола, не может быть доступно как переменная класса.',
        propertyMethodIncompatible: 'Метод property "{name}" несовместим',
        propertyMethodMissing: 'Метод property "{name}" отсутствует в переопределении',
        propertyMissingDeleter: 'Для property "{name}" не определен метод deleter',
        propertyMissingSetter: 'Для property "{name}" не определен метод setter',
        protocolIncompatible: '"{sourceType}" несовместим с протоколом "{destType}"',
        protocolMemberMissing: '"{name}" отсутствует.',
        protocolRequiresRuntimeCheckable: 'Класс Protocol должен быть @runtime_checkable, чтобы его можно было использовать при проверках экземпляров и классов',
        protocolSourceIsNotConcrete: '"{sourceType}" не является конкретным типом класса и не может быть присвоен типу "{destType}"',
        protocolUnsafeOverlap: 'Атрибуты "{name}" используют те же имена, что и протокол',
        pyrightCommentIgnoreTip: 'Для подавления диагностики в одной строке используйте конструкцию "# pyright: ignore[<diagnostic rules>]"',
        readOnlyAttribute: 'Атрибут "{name}" доступен только для чтения',
        seeClassDeclaration: 'См. объявление класса',
        seeDeclaration: 'См. объявление',
        seeFunctionDeclaration: 'См. объявление функции',
        seeMethodDeclaration: 'См. объявление метода',
        seeParameterDeclaration: 'Просмотреть объявление параметра',
        seeTypeAliasDeclaration: 'Просмотреть объявление псевдонима типа',
        seeVariableDeclaration: 'Просмотреть объявление переменной',
        tupleAssignmentMismatch: 'Тип "{type}" несовместим с целевым tuple',
        tupleEntryTypeMismatch: 'Запись tuple {entry} имеет неверный тип',
        tupleSizeIndeterminateSrc: 'Несоответствие размеров tuple: ожидается "{expected}", но получено неопределенное значение',
        tupleSizeIndeterminateSrcDest: 'Несоответствие размеров tuple: ожидается {expected} или больше, но получено неопределенное значение',
        tupleSizeMismatch: 'Несоответствие размеров tuple: ожидается "{expected}", но получено "{received}"',
        tupleSizeMismatchIndeterminateDest: 'Несоответствие размеров tuple: ожидается {expected} или больше, но получено {received}',
        typeAliasInstanceCheck: 'Псевдоним типа, создаваемый оператором "type", не может использоваться с проверками экземпляра и класса.',
        typeAssignmentMismatch: '"{sourceType}" типа невозможно назначить тип "{destType}"',
        typeBound: 'Тип "{sourceType}" не может быть назначен верхней границе "{destType}" для переменной типа "{name}"',
        typeConstrainedTypeVar: 'Тип "{type}" не может быть назначен переменной ограниченного типа "{name}"',
        typeIncompatible: '"{sourceType}" невозможно назначить "{destType}"',
        typeNotClass: '"{type}" не является классом.',
        typeNotStringLiteral: '"{type}" не является строковым литералом',
        typeOfSymbol: 'Тип "{name}" является "{type}"',
        typeParamSpec: 'Тип "{type}" несовместим с ParamSpec "{name}"',
        typeUnsupported: 'Тип "{type}" не поддерживается',
        typeVarDefaultOutOfScope: 'Переменная типа "{name}" лежит за пределами области',
        typeVarIsContravariant: 'Параметр типа "{name}" является контравариантным, но "{sourceType}" не является супертипом "{destType}"',
        typeVarIsCovariant: 'Параметр типа "{name}" является ковариантным, но "{sourceType}" не является подтипом "{destType}"',
        typeVarIsInvariant: 'Параметр типа "{name}" является инвариантным, но "{sourceType}" не совпадает с "{destType}"',
        typeVarNotAllowed: 'TypeVar не допускается для проверок экземпляров или классов',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple не может граничить с tuple неизвестной длины',
        typeVarUnnecessarySuggestion: 'Вместо этого используйте {type}',
        typeVarUnsolvableRemedy: 'Укажите перегрузку, которая указывает тип возвращаемого значения, если аргумент не передается',
        typeVarsMissing: 'Отсутствуют переменные типа: {names}',
        typedDictBaseClass: 'Класс "{type}" не является TypedDict',
        typedDictClassNotAllowed: 'Класс TypedDict не допускается для проверок экземпляров или классов',
        typedDictClosedExtraNotAllowed: 'Не удается добавить элемент "{name}"',
        typedDictClosedExtraTypeMismatch: 'Не удается добавить элемент "{name}" типа "{type}"',
        typedDictClosedFieldNotRequired: 'Не удается добавить элемент "{name}", так как он должен быть помечен как NotRequired',
        typedDictExtraFieldNotAllowed: 'Элемент "{name}" отсутствует в типе "{type}"',
        typedDictExtraFieldTypeMismatch: 'Тип "{name}" несовместим с типом "extra_items" в "{type}"',
        typedDictFieldMissing: '"{name}" отсутствует в "{type}"',
        typedDictFieldNotReadOnly: '"{name}" не является элементом "{type}" только для чтения',
        typedDictFieldNotRequired: '"{name}" не является обязательным в "{type}"',
        typedDictFieldRequired: '"{name}" является обязательным в "{type}"',
        typedDictFieldTypeMismatch: 'Тип "{type}" нельзя присвоить полю "{name}"',
        typedDictFieldUndefined: 'Элемент "{name}" не определен в типе "{type}"',
        typedDictFinalMismatch: '"{sourceType}" несовместим с "{destType}" из-за несоответствия @final',
        typedDictKeyAccess: 'Использовать ["{name}"] для ссылки на элемент в TypedDict',
        typedDictNotAllowed: 'TypedDict не может использоваться для проверок экземпляров или классов',
        unhashableType: 'Тип "{type}" не является хэшируемым',
        uninitializedAbstractVariable: 'Переменная экземпляра "{name}" определена в абстрактном базовом классе "{classType}", но не инициализирована',
        unreachableExcept: '"{exceptionType}" является подклассом "{parentType}"',
        useDictInstead: 'Используйте Dict[T1, T2] для указания типа словаря',
        useListInstead: 'Используйте List[T] для указания типа list или Union[T1, T2] для указания типа union',
        useTupleInstead: 'Используйте конструкцию tuple[T1, ..., Tn], чтобы указать тип tuple, или Union[T1, T2], чтобы указать тип union',
        useTypeInstead: 'Используйте вместо этого Type[T]',
        varianceMismatchForClass: 'Вариант аргумента типа "{typeVarName}" несовместим с базовым классом "{className}"',
        varianceMismatchForTypeAlias: 'Отклонение аргумента типа "{typeVarName}" несовместимо с "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'Перечисление исходных файлов рабочей области занимает много времени. Вместо этого рассмотрите возможность открыть вложенную папку. [Подробнее](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  83132: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Create Type Stub',
        createTypeStubFor: 'Create Type Stub For "{moduleName}"',
        executingCommand: 'Komut yürütülüyor',
        filesToAnalyzeCount: 'analiz edilecek {count} dosya var',
        filesToAnalyzeOne: 'Analiz edilecek 1 dosya',
        findingReferences: 'Başvurular bulunuyor',
        organizeImports: 'İçeri Aktarmaları Düzenle',
        renameShadowedFile: '"{oldFile}" dosyasını "{newFile}" olarak yeniden adlandır'
      },
      Completion: {
        autoImportDetail: 'Otomatik içeri aktarma',
        indexValueDetail: 'Dizin değeri'
      },
      Diagnostic: {
        abstractMethodInvocation: '"{method}" metodu soyut veya uygulanmamış olduğundan çağrılamaz',
        annotatedMetadataInconsistent: '"{metadataType}" not eklenmiş meta veri türü "{type}" türüyle uyumlu değil',
        annotatedParamCountMismatch: 'Parametre ek açıklama sayısı uyuşmazlığı: {expected} bekleniyordu ancak {received} alındı',
        annotatedTypeArgMissing: '"Annotated" için bir tür bağımsız değişkeni ve bir veya daha fazla ek açıklama bekleniyordu',
        annotationBytesString: 'Tür ifadeleri bayt sabit değerli dizeleri kullanamaz',
        annotationFormatString: 'Tür ifadeleri biçim dizesi sabit değerlerini (f-strings) kullanamaz',
        annotationNotSupported: 'Tür ek açıklaması bu deyim için desteklenmiyor',
        annotationRawString: 'Tür ifadeleri ham dize sabit değerlerini kullanamaz',
        annotationSpansStrings: 'Tür ifadeleri birden çok dize sabit değerine yayılamaz',
        annotationStringEscape: 'Tür ifadeleri kaçış karakterleri içeremez',
        argAssignment: '"{argType}" türünde bağımsız değişken, "{paramType}" türündeki parametreye atanamaz',
        argAssignmentFunction: '"{argType}" türünde bağımsız değişken, "{functionName}" işlevi içinde "{paramType}" türündeki parametreye atanamaz',
        argAssignmentParam: '"{argType}" türünde bağımsız değişken, "{paramName}" türündeki "{paramType}" parametresine atanamaz',
        argAssignmentParamFunction: '"{argType}" türünde bağımsız değişken, "{functionName}" işlevi içinde "{paramName}" türündeki "{paramType}" parametresine atanamaz',
        argMissingForParam: '{name} parametresi için bağımsız değişken eksik',
        argMissingForParams: '{names} parametrelerinin bağımsız değişkenleri eksik',
        argMorePositionalExpectedCount: '{expected} tane daha konumsal bağımsız değişken bekleniyordu',
        argMorePositionalExpectedOne: '1 tane daha konumsal bağımsız değişken bekleniyordu',
        argPositional: 'Konumsal bağımsız değişken bekleniyordu',
        argPositionalExpectedCount: '{expected} konumsal bağımsız değişken bekleniyordu',
        argPositionalExpectedOne: '1 konumsal bağımsız değişken bekleniyordu',
        argTypePartiallyUnknown: 'Bağımsız değişken türü kısmen bilinmiyor',
        argTypeUnknown: 'Bağımsız değişken türü bilinmiyor',
        assertAlwaysTrue: 'Assert ifadesi her zaman true olarak değerlendirilir',
        assertTypeArgs: '"assert_type" iki konumsal bağımsız değişken bekliyor',
        assertTypeTypeMismatch: '"assert_type" uyuşmuyor; "{expected}" bekleniyordu ancak "{received}" alındı',
        assignmentExprComprehension: '"{name}" atama ifadesi hedefi, hedef için anlama ile aynı adı kullanamaz',
        assignmentExprContext: 'Atama ifadesi modül, işlev veya lambda içinde olmalıdır',
        assignmentExprInSubscript: 'Bir alt simge içindeki atama ifadeleri yalnızca Python 3.10 ve daha yeni sürümlerinde desteklenir',
        assignmentInProtocol: 'Instance or class variables within a Protocol class must be explicitly declared within the class body',
        assignmentTargetExpr: 'İfade, atama hedefi olamaz',
        asyncNotInAsyncFunction: 'Use of "async" not allowed outside of async function',
        awaitIllegal: '"await" kullanımı için Python 3.5 veya daha yeni bir sürümü gerekiyor',
        awaitNotAllowed: 'Tür ifadeleri "await" kullanamaz',
        awaitNotInAsync: '"await" allowed only within async function',
        backticksIllegal: 'Eski kesme işaretleri arasında yer almayan ifadeler Python3.x’de desteklenmiyor; bunun yerine repr kullanın',
        baseClassCircular: 'Sınıf kendi türevi olamaz',
        baseClassFinal: '"{type}" temel sınıfı final olarak işaretlendi ve alt sınıf olamaz',
        baseClassIncompatible: '{type} türündeki temel sınıflar karşılıklı olarak uyumsuzdur',
        baseClassInvalid: 'Sınıfın bağımsız değişkeni bir temel sınıf olmalıdır',
        baseClassMethodTypeIncompatible: '"{classType}" sınıfına ait temel sınıflar, "{name}" metodunu uyumsuz bir şekilde tanımlıyor',
        baseClassUnknown: 'Temel sınıf türü bilinmiyor, türetilmiş sınıfı gizliyor',
        baseClassVariableTypeIncompatible: '"{classType}" sınıfı için temel sınıflar, "{name}" değişkenini uyumsuz bir şekilde tanımlıyor',
        binaryOperationNotAllowed: 'Tür ifadesinde ikili işleç kullanılamaz',
        bindTypeMismatch: '"{type}", "{paramName}" parametresine atanamadığından "{methodName}" metodu bağlanamadı',
        breakInExceptionGroup: '"except*" bloğunda "break" kullanılamaz',
        breakOutsideLoop: '"break" yalnızca bir döngü içinde kullanılabilir',
        callableExtraArgs: '"Callable" için yalnızca iki tür bağımsız değişkeni bekleniyordu',
        callableFirstArg: 'Parametre türü listesi veya "..." bekleniyordu',
        callableNotInstantiable: '"{type}" türünün örneği oluşturulamıyor',
        callableSecondArg: '"Callable" için ikinci tür bağımsız değişkeni olarak dönüş türü bekleniyordu',
        casePatternIsIrrefutable: 'Reddedilemez desene yalnızca son case deyimi için izin verilir',
        classAlreadySpecialized: '"{type}" türü zaten özelleştirilmiş',
        classDecoratorTypeUnknown: 'Türü belirtilmemiş sınıf dekoratörü sınıf türünü gizliyor; dekoratör yoksayılıyor',
        classDefinitionCycle: '"{name}" için sınıf tanımı kendisine bağımlı',
        classGetItemClsParam: '__class_getitem__ geçersiz kılması bir "cls" parametresi almalı',
        classMethodClsParam: 'Sınıf metotları bir "cls" parametresi almalıdır',
        classNotRuntimeSubscriptable: '"{name}" sınıfına ait alt simge çalışma zamanı özel durumunu oluşturur; tür ifadelerini tırnak içine alın',
        classPatternBuiltInArgPositional: 'Sınıf deseni yalnızca konumsal alt desen kabul eder',
        classPatternPositionalArgCount: '"{type}" sınıfı için çok fazla konumsal desen var; {expected} bekleniyordu ancak {received} alındı',
        classPatternTypeAlias: '"{type}" özel bir tür diğer adı olduğundan sınıf deseninde kullanılamaz',
        classPropertyDeprecated: 'Sınıf özellikleri Python 3.11\'de kullanım dışıdır ve Python 3.13\'te desteklenmez',
        classTypeParametersIllegal: 'Sınıf türü parametresi söz dizimi için Python 3.12 veya daha yeni bir sürümü gerekiyor',
        classVarFirstArgMissing: '"ClassVar" sonrasında tür bağımsız değişkeni bekleniyordu',
        classVarNotAllowed: 'Bu bağlamda "ClassVar" kullanımına izin verilmiyor',
        classVarOverridesInstanceVar: '"{name}" sınıf değişkeni "{className}" sınıfındaki aynı ada sahip örnek değişkenini geçersiz kılıyor',
        classVarTooManyArgs: '"ClassVar" sonrasında yalnızca bir tür bağımsız değişkeni bekleniyordu',
        classVarWithTypeVar: '"ClassVar" türü tür değişkenleri içeremez',
        clsSelfParamTypeMismatch: '"{name}" parametre türü, "{classType}" sınıfının üst türü olmalıdır',
        codeTooComplexToAnalyze: 'Kod analiz edilemeyecek kadar karmaşık; alt yordamlara ayırarak yeniden düzenleyip veya koşullu kod yollarını azaltarak karmaşıklığı azaltın',
        collectionAliasInstantiation: '"{type}" türündeki örnek oluşturulamıyor, bunun yerine "{alias}" kullanın',
        comparisonAlwaysFalse: '"{leftType}" türleri ve "{rightType}" türleri çakışmadığından koşul her zaman False olarak değerlendirilir',
        comparisonAlwaysTrue: '"{leftType}" ve "{rightType}" türleri çakışmadığından ifade her zaman True olarak değerlendirilir',
        comprehensionInDict: 'Anlama diğer küme girdileri ile kullanılamaz',
        comprehensionInSet: 'Comprehension cannot be used with other set entries',
        concatenateContext: 'Bu bağlamda "Concatenate" kullanılamaz',
        concatenateParamSpecMissing: '"Concatenate" için son tür bağımsız değişkeni bir ParamSpec veya "..." olmalıdır',
        concatenateTypeArgsMissing: '"Concatenate" requires at least two type arguments',
        conditionalOperandInvalid: '"{type}" türündeki koşullu işlenen geçersiz',
        constantRedefinition: '"{name}" sabit (büyük harf olduğundan) ve yeniden tanımlanamaz',
        constructorParametersMismatch: '"{classType}" sınıfındaki __new__ ve __init__ imzaları arasında uyuşmazlık var',
        containmentAlwaysFalse: '"{leftType}" türleri ve "{rightType}" türleri çakışmadığından ifade her zaman False olarak değerlendirilir',
        containmentAlwaysTrue: '"{leftType}" türleri ve "{rightType}" türleri çakışmadığından ifade her zaman True olarak değerlendirilir',
        continueInExceptionGroup: '"except*" bloğunda "continue" kullanılamaz',
        continueOutsideLoop: '"continue" yalnızca bir döngü içinde kullanılabilir',
        coroutineInConditionalExpression: 'Koşullu ifade, her zaman True olarak değerlendirilen eş yordama başvurur',
        dataClassBaseClassFrozen: 'Dondurulmuş olmayan bir sınıf dondurulmuş bir sınıftan devralamaz',
        dataClassBaseClassNotFrozen: 'Dondurulmuş sınıf, dondurulmuş olmayan bir sınıftan devralamaz',
        dataClassConverterFunction: '"{argType}" türündeki bağımsız değişken, "{fieldName}" türündeki "{fieldType}" alanı için geçerli bir dönüştürücü değil',
        dataClassConverterOverloads: '"{funcName}" işlevinin aşırı yüklemelerinden hiçbiri "{fieldType}" türündeki "{fieldName}" alanı için geçerli dönüştürücüler değil',
        dataClassFieldInheritedDefault: '"{fieldName}", aynı ada sahip bir alanı geçersiz kılıyor ancak varsayılan değeri yok',
        dataClassFieldWithDefault: 'Varsayılan değerleri olmayan alanlar, varsayılan değerleri olan alanlardan sonra gelemez',
        dataClassFieldWithPrivateName: 'Veri sınıfı alanı özel ad kullanamıyor',
        dataClassFieldWithoutAnnotation: 'Tür ek açıklaması olmayan veri sınıfı alanı çalışma zamanı özel durumuna neden olur',
        dataClassPostInitParamCount: 'Veri sınıfı __post_init__ parametre sayısı yanlış; InitVar alanlarının sayısı {expected}',
        dataClassPostInitType: 'Veri sınıfı __post_init__ metodu parametre türü ile "{fieldName}" alanı uyuşmuyor',
        dataClassSlotsOverwrite: '__slots__ zaten sınıfta tanımlı',
        dataClassTransformExpectedBoolLiteral: 'Statik olarak True veya False olarak değerlendirilen ifade bekleniyordu',
        dataClassTransformFieldSpecifier: 'Expected tuple of classes or functions but received type "{type}"',
        dataClassTransformPositionalParam: '"dataclass_transform" için tüm bağımsız değişkenlerin anahtar sözcük bağımsız değişkenleri olması gerekiyor',
        dataClassTransformUnknownArgument: '"{name}" bağımsız değişkeni, dataclass_transform tarafından desteklenmiyor',
        dataProtocolInSubclassCheck: 'issubclass çağrılarında veri protokollerine (yöntem dışı öznitelikler dahil) izin verilmez',
        declaredReturnTypePartiallyUnknown: 'Bildirilen "{returnType}" dönüş türü kısmen bilinmiyor',
        declaredReturnTypeUnknown: 'Bildirilen dönüş türü bilinmiyor',
        defaultValueContainsCall: 'Parametre varsayılan değer ifadesinde işlev çağrılarına ve değiştirilebilir nesnelere izin verilmez',
        defaultValueNotAllowed: '"*" veya "**" olan parametre varsayılan değere sahip olamaz',
        delTargetExpr: 'İfade silinemiyor',
        deprecatedClass: '"{name}" sınıfı kullanım dışı',
        deprecatedConstructor: '"{name}" sınıfının oluşturucusu kullanım dışı',
        deprecatedDescriptorDeleter: '"{name}" tanımlayıcısı için "__delete__" yöntemi kullanım dışı',
        deprecatedDescriptorGetter: '"{name}" tanımlayıcısı için "__get__" yöntemi kullanım dışı',
        deprecatedDescriptorSetter: '"{name}" tanımlayıcısı için "__set__" yöntemi kullanım dışı',
        deprecatedFunction: '"{name}" işlevi kullanım dışı',
        deprecatedMethod: '"{className}" sınıfındaki "{name}" yöntemi kullanım dışı',
        deprecatedPropertyDeleter: '"{name}" property deleter kullanım dışı',
        deprecatedPropertyGetter: '"{name}" property getter kullanım dışı',
        deprecatedPropertySetter: '"{name}" property setter kullanım dışı',
        deprecatedType: 'Bu tür Python {version} sürümünden itibaren kullanım dışı; bunun yerine "{replacement}" kullanın',
        dictExpandIllegalInComprehension: 'Sözlük genişletmeye anlamada izin verilmiyor',
        dictInAnnotation: 'Tür ifadesinde sözlük ifadesi kullanılamaz',
        dictKeyValuePairs: 'Sözlük girdileri anahtar/değer çiftleri içermelidir',
        dictUnpackIsNotMapping: 'Sözlük açma işleci için eşleme bekleniyordu',
        dunderAllSymbolNotPresent: '"{name}" __all__ ile belirtildi ancak modülde yok',
        duplicateArgsParam: 'Yalnızca bir "*" parametresi kullanılabilir',
        duplicateBaseClass: 'Yinelenen temel sınıfa izin verilmiyor',
        duplicateCapturePatternTarget: '"{name}" yakalama hedefi, aynı desen içinde birden çok kez bulunamaz',
        duplicateCatchAll: 'Yalnızca bir catch-all except yan tümcesine izin verilir',
        duplicateEnumMember: 'Enum member "{name}" is already declared',
        duplicateGenericAndProtocolBase: 'Only one Generic[...] or Protocol[...] base class allowed',
        duplicateImport: '"{importName}" birden çok kez içeri aktarıldı',
        duplicateKeywordOnly: 'Yalnızca bir "*" ayırıcısı kullanılabilir',
        duplicateKwargsParam: 'Yalnızca bir "**" parametresine izin verilir',
        duplicateParam: '"{name}" yinelenen parametresi',
        duplicatePositionOnly: 'Yalnızca bir "/" parametresine izin verilir',
        duplicateStarPattern: 'Desen dizisinde yalnızca bir "*" desenine izin verilir',
        duplicateStarStarPattern: 'Yalnızca bir "**" girdisine izin verilir',
        duplicateUnpack: 'Only one unpack operation allowed in list',
        ellipsisAfterUnpacked: '"..." paketlenmemiş TypeVarTuple veya tuple ile kullanılamaz',
        ellipsisContext: '"..." kullanımına bu bağlamda izin verilmiyor',
        ellipsisSecondArg: '"..." yalnızca iki bağımsız değişkenin ikincisi olarak kullanılabilir',
        enumClassOverride: 'Enum class "{name}" is final and cannot be subclassed',
        enumMemberDelete: 'Enum üyesi "{name}" silinemiyor',
        enumMemberSet: 'Enum üyesi "{name}" atanamıyor',
        enumMemberTypeAnnotation: 'Type annotations are not allowed for enum members',
        exceptGroupMismatch: 'Try ifadesi hem "except*" hem de "except" içeremez',
        exceptGroupRequiresType: 'Özel durum grubu söz dizimi ("except*") biri özel durum türü gerektirir',
        exceptionGroupIncompatible: 'Özel durum grubu söz dizimi ("except*") için Python 3.11 veya daha yeni bir sürümü gerekiyor',
        exceptionGroupTypeIncorrect: 'except* altındaki özel durum türü BaseGroupException değerinden türetilemiyor',
        exceptionTypeIncorrect: '"{type}", BaseException türevi değil',
        exceptionTypeNotClass: '"{type}" geçerli bir özel durum sınıfı değil',
        exceptionTypeNotInstantiable: '"{type}" özel durum türü oluşturucusu bir veya daha fazla bağımsız değişken gerektiriyor',
        expectedAfterDecorator: 'Dekoratörden sonra işlev veya sınıf bildirimi bekleniyordu',
        expectedArrow: 'Dönüş türü ek açıklaması sonrasında "->" bekleniyordu',
        expectedAsAfterException: 'Özel durum türünden sonra "as" bekleniyordu',
        expectedAssignRightHandExpr: '"=" öğesinin sağ tarafında ifade bekleniyordu',
        expectedBinaryRightHandExpr: 'İşlecin sağında ifade bekleniyordu',
        expectedBoolLiteral: 'True veya False bekleniyor',
        expectedCase: '"case" deyimi bekleniyordu',
        expectedClassName: 'Sınıf adı bekleniyordu',
        expectedCloseBrace: '"{" kapatılmadı',
        expectedCloseBracket: '"[" kapatılmadı',
        expectedCloseParen: '"(" kapatılmadı',
        expectedColon: '":" bekleniyordu',
        expectedComplexNumberLiteral: 'Desen eşleme için karmaşık sayı sabit değeri bekleniyordu',
        expectedDecoratorExpr: 'İfade formu Python 3.9\'dan önceki dekoratör için desteklenmiyor',
        expectedDecoratorName: 'Dekoratör adı bekleniyordu',
        expectedDecoratorNewline: 'Dekoratör sonunda yeni satır bekleniyordu',
        expectedDelExpr: '"del" sonrasında ifade bekleniyordu',
        expectedElse: '"else" bekleniyordu',
        expectedEquals: '"=" bekleniyordu',
        expectedExceptionClass: 'Geçersiz özel durum sınıfı veya nesnesi',
        expectedExceptionObj: 'Özel durum nesnesi, özel durum sınıfı veya None bekleniyordu',
        expectedExpr: 'İfade bekleniyor',
        expectedFunctionAfterAsync: '"async" sonrasında işlev tanımı bekleniyordu',
        expectedFunctionName: '"def" sonrasında işlev adı bekleniyordu',
        expectedIdentifier: 'Tanımlayıcı bekleniyordu',
        expectedImport: '"import" bekleniyordu',
        expectedImportAlias: '"as" sonrasında sembol bekleniyordu',
        expectedImportSymbols: '"import" sonrasında bir veya daha fazla sembol adı bekleniyordu',
        expectedIn: '"in" bekleniyordu',
        expectedInExpr: '"in" sonrasında ifade bekleniyordu',
        expectedIndentedBlock: 'Girintili blok bekleniyordu',
        expectedMemberName: '"." sonrasında bir öznitelik adı bekleniyor',
        expectedModuleName: 'Modül adı bekleniyordu',
        expectedNameAfterAs: '"as" sonrasında sembol adı bekleniyordu',
        expectedNamedParameter: 'Anahtar sözcük parametresi, "*" sonrasında gelmelidir',
        expectedNewline: 'Yeni satır bekleniyordu',
        expectedNewlineOrSemicolon: 'Deyimler yeni satırlarla veya noktalı virgüllerle ayrılarak belirtilmelidir',
        expectedOpenParen: '"(" bekleniyordu',
        expectedParamName: 'Parametre adı bekleniyordu',
        expectedPatternExpr: 'Desen ifadesi bekleniyordu',
        expectedPatternSubjectExpr: 'Beklenen desen konusu ifadesi',
        expectedPatternValue: '"a.b" biçiminde bir desen değeri ifadesi bekleniyordu',
        expectedReturnExpr: '"return" sonrasında ifade bekleniyordu',
        expectedSliceIndex: 'Dizin veya dilim ifadesi bekleniyordu',
        expectedTypeNotString: 'Tür bekleniyordu ancak sabit değerli dize alındı',
        expectedTypeParameterName: 'Beklenen tür parametresi adı',
        expectedYieldExpr: 'Expected expression in yield statement',
        finalClassIsAbstract: 'Class "{type}" is marked final and must implement all abstract symbols',
        finalContext: 'Bu bağlamda "Final" kullanılamaz',
        finalInLoop: 'Bir döngü içinde “Final” değişkeni atanamaz',
        finalMethodOverride: '"{name}" yöntemi "{className}" sınıfı içinde tanımlanan final metodu geçersiz kılamaz',
        finalNonMethod: '"{name}" işlevi bir yöntem olmadığından @final olarak işaretlenemez',
        finalReassigned: '"{name}" is declared as Final and cannot be reassigned',
        finalRedeclaration: '"{name}" daha önce Final olarak bildirildi',
        finalRedeclarationBySubclass: '"{name}", "{className}" sınıf adı bu adı Final olarak bildirdiğinden yeniden bildirilemez',
        finalTooManyArgs: '"Final" sonrasında tek bir tür bağımsız değişken bekleniyordu',
        finalUnassigned: '"{name}" Final olarak bildirildi, ancak değer atanmadı',
        formatStringBrace: 'f dizesi sabit değerinde tek bir kapatma küme ayracı kullanılamaz; çift sağ ayraç kullanın',
        formatStringBytes: 'Biçim dizesi sabit değerleri (f-strings) ikili olamaz',
        formatStringDebuggingIllegal: 'F dizesi hata ayıklama belirticisi "=", Python 3.8 veya daha yeni bir sürüm gerektirir',
        formatStringEscape: 'Python 3.12 öncesinde f dizesinin ifade bölümünde kaçış sırasına (ters eğik çizgi) izin verilmez',
        formatStringExpectedConversion: 'f-string\'de "!" öğesinden sonra bir dönüştürme tanımlayıcısı bekleniyordu',
        formatStringIllegal: 'Biçim dizesi sabit değerleri (f dizeleri) Python 3.6 veya daha yeni bir sürüm gerektirir',
        formatStringInPattern: 'Desende biçim dizesine izin verilmiyor',
        formatStringNestedFormatSpecifier: 'İfadeler biçim dizesi belirticisi içinde çok derin iç içe geçmiş',
        formatStringNestedQuote: 'F dizesi içinde iç içe geçmiş dizeler Python 3.12\'den önceki f dizesiyle aynı tırnak karakterini kullanamaz',
        formatStringUnicode: 'Biçim dizesi sabit değerleri (f-strings) unicode olamaz',
        formatStringUnterminated: 'F dizesi içinde sonlandırılmamış ifade; "}" bekleniyor',
        functionDecoratorTypeUnknown: 'Türü belirsiz işlev dekoratörü işlevin türünü gizler; dekoratör yoksayılıyor',
        functionInConditionalExpression: 'Koşullu ifade, her zaman True olarak değerlendirilen işleve başvurur',
        functionTypeParametersIllegal: 'İşlev türü parametre sözdizimi Python 3.12 veya daha yeni bir sürüm gerektirir',
        futureImportLocationNotAllowed: '__future__ içeri aktarmaları dosyanın başında olmalıdır',
        generatorAsyncReturnType: 'Return type of async generator function must be compatible with "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: 'Tek bağımsız değişken olmadıklarında oluşturucu ifadeleri ayraç içine alınmalıdır',
        generatorSyncReturnType: 'Oluşturucu işlevinin dönüş türü "Generator[{yieldType}, Any, Any]" ile uyumlu olmalıdır',
        genericBaseClassNotAllowed: '"Generic" temel sınıfı, tür parametresi sözdizimiyle kullanılamaz',
        genericClassAssigned: 'Genel sınıf türü atanamıyor',
        genericClassDeleted: 'Genel sınıf türü silinemiyor',
        genericInstanceVariableAccess: 'Sınıf üzerinden genel örnek değişkenine erişim belirsiz',
        genericNotAllowed: '"Generic" bu bağlamda geçerli değil',
        genericTypeAliasBoundTypeVar: 'Sınıf içindeki genel tür diğer adı {names} bağlı tür değişkenlerini kullanamıyor',
        genericTypeArgMissing: '"Generic" en az bir tür bağımsız değişkeni gerektirir',
        genericTypeArgTypeVar: '"Generic" için tür bağımsız değişkeni bir tür değişkeni olmalıdır',
        genericTypeArgUnique: '"Generic" için tür bağımsız değişkenleri benzersiz olmalıdır',
        globalReassignment: '"{name}" is assigned before global declaration',
        globalRedefinition: '"{name}" was already declared global',
        implicitStringConcat: 'Örtük dize birleştirmesine izin verilmiyor',
        importCycleDetected: 'İçeri aktarma zincirinde döngü algılandı',
        importDepthExceeded: 'İçeri aktarma zinciri derinliği {depth} sınırını aştı',
        importResolveFailure: '"{importName}" adlı içeri aktarma çözümlenemedi',
        importSourceResolveFailure: '"{importName}" adlı içeri aktarma kaynaktan çözümlenemedi',
        importSymbolUnknown: '"{name}" alma simgesi bilinmiyor',
        incompatibleMethodOverride: '"{name}" metodu "{className}" sınıfını uyumsuz bir şekilde geçersiz kılıyor',
        inconsistentIndent: 'Girintisiz miktar önceki girintiyle eşleşmiyor',
        inconsistentTabs: 'Girinti içinde sekmelerin ve boşlukların kullanımı tutarsız',
        initMethodSelfParamTypeVar: '"__init__" metodunun "self" parametresi için tür ek açıklaması sınıf kapsamlı tür değişkenleri içeremez',
        initMustReturnNone: '"__init__" dönüş türü None olmalıdır',
        initSubclassCallFailed: '__init_subclass__ yöntemi için yanlış anahtar bağımsız değişkenleri',
        initSubclassClsParam: '__init_subclass__ geçersiz kılması bir "cls" parametresi almalı',
        initVarNotAllowed: '"InitVar" öğesi bu bağlamda kullanılamaz',
        instanceMethodSelfParam: 'Örnek metotları bir "self" parametresi almalıdır',
        instanceVarOverridesClassVar: '"{name}" örnek değişkeni "{className}" sınıfındaki aynı ada sahip sınıf değişkenini geçersiz kılıyor',
        instantiateAbstract: '"{type}" soyut sınıfı örneği oluşturulamıyor',
        instantiateProtocol: '"{type}" Protocol sınıfının örneği oluşturulamıyor',
        internalBindError: '"{file}" dosyası bağlanırken dahili bir hata oluştu: {message}',
        internalParseError: '"{file}" dosyası ayrıştırılırken dahili bir hata oluştu: {message}',
        internalTypeCheckingError: '"{file}" dosyası tür denetimi gerçekleştirilirken dahili bir hata oluştu: {message}',
        invalidIdentifierChar: 'Tanımlayıcıda geçersiz karakter',
        invalidStubStatement: 'Statement is meaningless within a type stub file',
        invalidTokenChars: 'Belirteçte geçersiz "{text}" karakteri var',
        isInstanceInvalidType: 'Second argument to "isinstance" must be a class or tuple of classes',
        isSubclassInvalidType: 'Second argument to "issubclass" must be a class or tuple of classes',
        keyValueInSet: 'Key/value pairs are not allowed within a set',
        keywordArgInTypeArgument: 'Anahtar sözcük bağımsız değişkenleri tür bağımsız değişken listelerinde kullanılamaz',
        keywordArgShortcutIllegal: 'Anahtar sözcük bağımsız değişkeni kısayolu için Python 3.14 veya daha yenisini gereklidir.',
        keywordOnlyAfterArgs: '"*" parametresinden sonra keyword-only bağımsız değişken ayırıcısı kullanılamaz',
        keywordParameterMissing: 'Bir veya daha fazla anahtar sözcük parametresi "*" parametresini izlemeli',
        keywordSubscriptIllegal: 'Alt simge içindeki anahtar sözcük bağımsız değişkenleri desteklenmiyor',
        lambdaReturnTypePartiallyUnknown: 'Lambdanın "{returnType}" dönüş türü kısmen bilinmiyor',
        lambdaReturnTypeUnknown: 'Lambdanın dönüş türü bilinmiyor',
        listAssignmentMismatch: '"{type}" türündeki ifade hedef listesine atanamaz',
        listInAnnotation: 'List expression not allowed in type expression',
        literalEmptyArgs: '"Literal" sonrasında bir veya daha fazla tür bağımsız değişkeni bekleniyordu',
        literalNamedUnicodeEscape: 'Adlandırılmış unicode kaçış sıraları “Literal” dize ek açıklamalarında desteklenmiyor',
        literalNotAllowed: '"Literal" bir tür bağımsız değişken olmadan bu bağlamda kullanılamaz',
        literalNotCallable: 'Literal type cannot be instantiated',
        literalUnsupportedType: 'Type arguments for "Literal" must be None, a literal value (int, bool, str, or bytes), or an enum value',
        matchIncompatible: 'Match statements require Python 3.10 or newer',
        matchIsNotExhaustive: 'Cases within match statement do not exhaustively handle all values',
        maxParseDepthExceeded: 'Maksimum ayrıştırma derinliği aşıldı; ifadeyi daha küçük alt ifadelere bölün',
        memberAccess: 'Sınıf "{type}" için "{name}" özniteliğine erişilemiyor',
        memberDelete: 'Sınıf "{type}" için "{name}" özniteliği silinemiyor',
        memberSet: 'Sınıf "{type}" için "{name}" özniteliği atanamıyor',
        metaclassConflict: 'Türetilmiş sınıfın meta sınıfı, tüm temel sınıflarının meta sınıflarının bir alt sınıfı olmalıdır',
        metaclassDuplicate: 'Yalnızca bir meta sınıfı sağlanmalıdır',
        metaclassIsGeneric: 'Meta sınıfı genel olamaz',
        methodNotDefined: '"{name}" metodu tanımlanmadı',
        methodNotDefinedOnType: '"{name}" metodu "{type}" türü üzerinde tanımlanmadı',
        methodOrdering: 'Tutarlı metot sıralaması oluşturulamıyor',
        methodOverridden: '"{name}", uyumsuz "{type}" türüne sahip "{className}" sınıfında aynı ad metodunu geçersiz kılar',
        methodReturnsNonObject: '"{name}" metodu bir nesne döndürmez',
        missingSuperCall: '"{methodName}" metodu üst sınıftaki aynı ada sahip metodu çağıramaz',
        mixingBytesAndStr: 'Bytes ve str değerleri birleştirilemez',
        moduleAsType: 'Modül tür olarak kullanılamaz',
        moduleNotCallable: 'Modül çağrılabilir değil',
        moduleUnknownMember: '"{memberName}", "{moduleName}" modülünün bilinen bir özniteliği değil',
        namedExceptAfterCatchAll: 'Adlandırılmış except yan tümcesi, catch-all except yan tümcesinden sonra gelemez',
        namedParamAfterParamSpecArgs: '"{name}" anahtar sözcük parametresi ParamSpec args parametresinden sonra imzada yer alamaz',
        namedTupleEmptyName: 'Names within a named tuple cannot be empty',
        namedTupleEntryRedeclared: 'Üst sınıf "{name}" adlandırılmış bir tuple olduğundan "{className}" geçersiz kılınamıyor',
        namedTupleFirstArg: 'Expected named tuple class name as first argument',
        namedTupleMultipleInheritance: 'NamedTuple bulunan birden çok devralma desteklenmiyor',
        namedTupleNameKeyword: 'Alan adları anahtar sözcük olamaz',
        namedTupleNameType: 'Expected two-entry tuple specifying entry name and type',
        namedTupleNameUnique: 'Names within a named tuple must be unique',
        namedTupleNoTypes: '"namedtuple" demet girdileri için tür sağlamaz; bunun yerine "NamedTuple" kullanın',
        namedTupleSecondArg: 'Expected named tuple entry list as second argument',
        newClsParam: '__new__ geçersiz kılması bir "cls" parametresi almalı',
        newTypeAnyOrUnknown: 'NewType\'ın ikinci bağımsız değişkeni Any veya Unknown değil, bilinen bir sınıf olmalıdır',
        newTypeBadName: 'NewType için ilk bağımsız değişken bir sabit değerli dize olmalıdır',
        newTypeLiteral: 'NewType Literal türüyle kullanılamaz',
        newTypeNameMismatch: 'NewType, aynı ada sahip bir değişkene atanmalıdır',
        newTypeNotAClass: 'NewType için ikinci bağımsız değişken olarak sınıf bekleniyordu',
        newTypeParamCount: 'NewType için iki konumsal bağımsız değişken gerekiyor',
        newTypeProtocolClass: 'NewType yapısal türle (Protocol veya TypedDict sınıfı) kullanılamaz',
        noOverload: '"{name}" için aşırı yüklemelerin hiçbiri sağlanan bağımsız değişkenlerle eşleşmiyor',
        noReturnContainsReturn: 'Function with declared return type "NoReturn" cannot include a return statement',
        noReturnContainsYield: 'Bildirilen dönüş türü "NoReturn" olan işlev bir yield deyimi içeremez',
        noReturnReturnsNone: 'Bildirilen "NoReturn" döndürme türüne sahip işlev "None" döndüremez',
        nonDefaultAfterDefault: 'Varsayılan olmayan bağımsız değişken varsayılan bağımsız değişkeni izler',
        nonLocalInModule: 'Nonlocal declaration not allowed at module level',
        nonLocalNoBinding: 'No binding for nonlocal "{name}" found',
        nonLocalReassignment: '"{name}" is assigned before nonlocal declaration',
        nonLocalRedefinition: '"{name}" was already declared nonlocal',
        noneNotCallable: '"None" türündeki nesne çağrılamaz',
        noneNotIterable: '"None" türündeki nesne, yeniden kullanılabilir değer olarak kullanılamaz',
        noneNotSubscriptable: '"None" türündeki nesne alt simgeleştirilebilir değil',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: '"{operator}" işleci "None" için desteklenmiyor',
        noneUnknownMember: '"{name}" bilinen bir "None" özniteliği değil',
        notRequiredArgCount: '"NotRequired" sonrasında tek bir tür bağımsız değişken bekleniyordu',
        notRequiredNotInTypedDict: 'Bu bağlamda "NotRequired" kullanımına izin verilmiyor',
        objectNotCallable: '"{type}" türündeki nesne çağrılamaz',
        obscuredClassDeclaration: '"{name}" sınıf bildirimi aynı ada sahip bir bildirim tarafından gizlendi',
        obscuredFunctionDeclaration: '"{name}" işlev bildirimi aynı ada sahip bir bildirim tarafından gizlendi',
        obscuredMethodDeclaration: '"{name}" metot bildirimi aynı ada sahip bir bildirim tarafından gizlendi',
        obscuredParameterDeclaration: '"{name}" parametre bildirimi aynı ada sahip bir bildirim tarafından gizlendi',
        obscuredTypeAliasDeclaration: '"{name}" tür diğer ad bildirimi aynı ada sahip bir bildirim tarafından etkisiz kılındı',
        obscuredVariableDeclaration: '"{name}" bildirimi aynı ada sahip bir bildirim tarafından gizlendi',
        operatorLessOrGreaterDeprecated: '"<>" işleci Python 3\'de desteklenmiyor; bunun yerine "!=" kullanın',
        optionalExtraArgs: 'Expected one type argument after "Optional"',
        orPatternIrrefutable: 'Reddedilemez desene yalnızca "or" deseninde son alt desen olarak izin verilir',
        orPatternMissingName: 'Bir "or" deseni içindeki tüm alt desenlerde aynı adlar hedeflenmeli',
        overlappingKeywordArgs: 'Türü belirlenmiş sözlük anahtar sözcük parametresiyle çakışıyor: {names}',
        overlappingOverload: 'Parametreleri {obscuredBy} aşırı yüklemesi ile çakıştığından "{name}" {obscured} aşırı yüklemesi hiçbir zaman kullanılmayacak',
        overloadAbstractImplMismatch: 'Aşırı yüklemeler uygulamanın özet durumuyla eşleşmelidir',
        overloadAbstractMismatch: 'Aşırı yüklemelerin tümü soyut olmalı veya tümü olmamalıdır',
        overloadClassMethodInconsistent: '"{name}" için aşırı yüklemeler, @classmethod yöntemini tutarlı kullanıyor',
        overloadFinalInconsistencyImpl: '"{name}" için aşırı yükleme @final olarak işaretlendi ancak uygulama işaretlenmedi',
        overloadFinalInconsistencyNoImpl: '"{name}" için aşırı yükleme {index} @final olarak işaretlendi ancak aşırı yükleme 1 işaretlenmedi',
        overloadImplementationMismatch: 'Aşırı yüklenmiş uygulama, {index} aşırı yükleme imzası ile tutarlı değil',
        overloadReturnTypeMismatch: '"{name}" için {prevIndex} aşırı yüklemesi {newIndex} aşırı yüklemesi ile çakışıyor ve uyumsuz bir tür döndürüyor',
        overloadStaticMethodInconsistent: '"{name}" için aşırı yüklemeler, @staticmethod yöntemini tutarsız kullanıyor',
        overloadWithoutImplementation: '"{name}" is marked as overload, but no implementation is provided',
        overriddenMethodNotFound: 'Method "{name}" is marked as override, but no base method of same name is present',
        overrideDecoratorMissing: 'Method "{name}" is not marked as override but is overriding a method in class "{className}"',
        paramAfterKwargsParam: 'Parametre "**" parametresini izleyemez',
        paramAlreadyAssigned: '"{name}" parametresi zaten atanmış',
        paramAnnotationMissing: '"{name}" parametresi için tür ek açıklaması eksik',
        paramAssignmentMismatch: '"{sourceType}" türündeki ifade, "{paramType}" türündeki parametreye atanamaz',
        paramNameMissing: '"{name}" adlı parametre yok',
        paramSpecArgsKwargsDuplicate: '"{type}" ParamSpec\'i için bağımsız değişkenler zaten sağlandı',
        paramSpecArgsKwargsUsage: 'ParamSpec\'in "args" ve "kwargs" özniteliklerinin ikisi de işlev imzasında görünmelidir',
        paramSpecArgsMissing: 'ParamSpec "{type}" bağımsız değişkenleri eksik',
        paramSpecArgsUsage: 'ParamSpec\'in "args" özniteliği yalnızca *args parametresiyle kullanıldığında geçerlidir',
        paramSpecAssignedName: 'ParamSpec, "{name}" adlı bir değişkene atanmalı',
        paramSpecContext: 'ParamSpec bu bağlamda kullanılamaz',
        paramSpecDefaultNotTuple: 'Expected ellipsis, a tuple expression, or ParamSpec for default value of ParamSpec',
        paramSpecFirstArg: 'İlk bağımsız değişken olarak ParamSpec adı bekleniyordu',
        paramSpecKwargsUsage: 'ParamSpec\'in "kwargs" özniteliği yalnızca **kwargs parametresiyle kullanıldığında geçerlidir',
        paramSpecNotUsedByOuterScope: '"{name}" adlı ParamSpec bu bağlamda bir anlam ifade etmiyor',
        paramSpecUnknownArg: 'ParamSpec birden fazla bağımsız değişkeni desteklemiyor',
        paramSpecUnknownMember: '"{name}" bilinen bir ParamSpec özniteliği değil',
        paramSpecUnknownParam: '"{name}", ParamSpec için bilinmeyen bir parametre',
        paramTypeCovariant: 'Kovaryant türü değişkeni parametre türünde kullanılamaz',
        paramTypePartiallyUnknown: '"{paramName}" parametresinin türü kısmen bilinmiyor',
        paramTypeUnknown: '"{paramName}" parametresinin türü bilinmiyor',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Desen, "{type}" konu türü ile hiçbir zaman eşleşmez',
        positionArgAfterNamedArg: 'Konumsal bağımsız değişken anahtar sözcük bağımsız değişkenlerden sonra gelemez',
        positionOnlyAfterArgs: '"*" parametresinden sonra yalnızca konum parametre ayırıcısı kullanılamaz',
        positionOnlyAfterKeywordOnly: '"/" parametresi "*" parametresinden önce gelmelidir',
        positionOnlyAfterNon: 'Yalnızca konum parametresi olmayan parametreden sonra yalnızca konum parametresine izin verilmez',
        positionOnlyFirstParam: 'Yalnızca konum parametre ayırıcısı ilk parametre olarak kullanılamaz',
        positionOnlyIncompatible: 'Yalnızca konum parametre ayırıcısı için Python 3.8 veya daha yeni bir sürümü gerekiyor',
        privateImportFromPyTypedModule: '"{name}" "{module}" modülünden dışarı aktarılamadı',
        privateUsedOutsideOfClass: '"{name}" özeldir ve bildirildiği sınıfın dışında kullanılır',
        privateUsedOutsideOfModule: '"{name}" özeldir ve bildirildiği modülün dışında kullanılır',
        propertyOverridden: '"{name}" incorrectly overrides property of same name in class "{className}"',
        propertyStaticMethod: 'Static methods not allowed for property getter, setter or deleter',
        protectedUsedOutsideOfClass: '"{name}" korumalıdır ve içinde bildirildiği sınıfın dışında kullanılır',
        protocolBaseClass: '"{classType}" Protocol sınıfı, Protocol olmayan "{baseType}" sınıfının türevi olamaz',
        protocolBaseClassWithTypeArgs: 'Type arguments are not allowed with Protocol class when using type parameter syntax',
        protocolIllegal: '"Protocol" kullanımı için Python 3.7 veya daha yeni bir sürümü gerekiyor',
        protocolNotAllowed: '"Protocol" bu bağlamda kullanılamaz',
        protocolTypeArgMustBeTypeParam: '“Protocol” için tür bağımsız değişkeni bir tür parametresi olmalıdır',
        protocolUnsafeOverlap: 'Sınıf, "{name}" ile güvenli olmayan bir şekilde çakışıyor ve çalışma zamanında bir eşleşme üretebilir',
        protocolVarianceContravariant: 'Genel Protocol "{class}" için kullanılan "{variable}" tür değişkeni, değişken karşıtı olmalıdır',
        protocolVarianceCovariant: 'Genel Protocol "{class}" için kullanılan "{variable}" tür değişkeni, birlikte değişen olmalıdır',
        protocolVarianceInvariant: 'Genel Protocol "{class}" için kullanılan "{variable}" tür değişkeni sabit olmalıdır',
        pyrightCommentInvalidDiagnosticBoolValue: 'Pyright açıklama yönergesinden sonra "=" ve true veya false değeri olmalıdır',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Pyright açıklama yönergesinden sonra "=" ve true, false, error, warning, information veya none değeri girilmelidir',
        pyrightCommentMissingDirective: 'Pyright comment must be followed by a directive (basic or strict) or a diagnostic rule',
        pyrightCommentNotOnOwnLine: 'Pyright comments used to control file-level settings must appear on their own line',
        pyrightCommentUnknownDiagnosticRule: '"{rule}", pyright açıklaması için bilinmeyen bir tanılama kuralı',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" pyright açıklaması için geçersiz değer; true, false, error, warning, information veya none bekleniyordu',
        pyrightCommentUnknownDirective: '"{directive}", pyright açıklaması için bilinmeyen bir yönergedir; "strict" veya "basic" bekleniyordu',
        readOnlyArgCount: '"ReadOnly" sonrasında tek bir tür bağımsız değişken bekleniyordu',
        readOnlyNotInTypedDict: 'Bu bağlamda "ReadOnly" kullanımına izin verilmiyor',
        recursiveDefinition: 'Kendine başvurduğundan "{name}" türü belirlenemedi',
        relativeImportNotAllowed: 'Göreli içeri aktarmalar "import .a" formuyla kullanılamaz; bunun yerine "from . import a" kullanın',
        requiredArgCount: '"Required" sonrasında tek bir tür bağımsız değişken bekleniyordu',
        requiredNotInTypedDict: 'Bu bağlamda "Required" kullanımına izin verilmiyor',
        returnInAsyncGenerator: 'Return statement with value is not allowed in async generator',
        returnInExceptionGroup: '"except*" bloğunda "return" kullanılamaz',
        returnMissing: 'Bildirilen "{returnType}" döndürme türüne sahip işlev, tüm kod yollarında değer döndürmelidir',
        returnOutsideFunction: '"return" yalnızca bir işlev içinde kullanılabilir',
        returnTypeContravariant: 'Değişken karşıtı tür değişkeni dönüş türünde kullanılamaz',
        returnTypeMismatch: '"{exprType}" türü "{returnType}" dönüş türüne atanamaz',
        returnTypePartiallyUnknown: '"{returnType}" dönüş türü kısmen bilinmiyor',
        returnTypeUnknown: 'Dönüş türü bilinmiyor',
        revealLocalsArgs: '"reveal_locals" çağrısı için bağımsız değişken beklenmiyordu',
        revealLocalsNone: 'No locals in this scope',
        revealTypeArgs: '"reveal_type" çağrısı için tek bir konumsal bağımsız değişken bekleniyordu',
        revealTypeExpectedTextArg: '"reveal_type" bağımsız değişkeni için "expected_text" argümanı bir str sabit değeri olmalıdır',
        revealTypeExpectedTextMismatch: 'Tür uyuşmazlığı; "{expected}" bekleniyordu ancak "{received}" alındı',
        revealTypeExpectedTypeMismatch: 'Tür uyuşmazlığı; "{expected}" bekleniyordu ancak "{received}" alındı',
        selfTypeContext: '"Self" bu bağlamda geçerli değil',
        selfTypeMetaclass: '"Self" bir meta sınıfı ("type" alt sınıfı) içinde kullanılamaz',
        selfTypeWithTypedSelfOrCls: '"Self", "Self" dışında bir tür ek açıklamasına sahip bir `self` veya `cls` parametresine sahip bir işlevde kullanılamaz',
        setterGetterTypeMismatch: 'Property setter value type is not assignable to the getter return type',
        singleOverload: '"{name}" aşırı yükleme olarak işaretlenmiş, ancak ek aşırı yüklemeler eksik',
        slotsAttributeError: '"{name}", __slots__ içinde belirtilmedi',
        slotsClassVarConflict: '"{name}", __slots__ içinde bildirilen örnek değişkenle çakışıyor',
        starPatternInAsPattern: 'Yıldız deseni "as" hedefiyle kullanılamaz',
        starPatternInOrPattern: 'Yıldız deseni diğer desenlerde ORed olamaz',
        starStarWildcardNotAllowed: '"_" joker karakteriyle ** kullanılamaz',
        staticClsSelfParam: 'Static metotları "self" veya "cls" parametresi almamalıdır',
        stdlibModuleOverridden: '"{path}", "{name}" stdlib modülünü geçersiz kılıyor',
        stringNonAsciiBytes: 'ASCII olmayan karaktere bayt sabit değerli dizesinde izin verilmez',
        stringNotSubscriptable: 'Tür ifadesinde dize ifadesi alt simge olarak belirtilemez; ifadenin tamamını tırnak içine alın',
        stringUnsupportedEscape: 'Dize sabit değerinde desteklenmeyen kaçış dizisi',
        stringUnterminated: 'Sabit değerli dize sonlandırılmamış',
        stubFileMissing: 'Stub file not found for "{importName}"',
        stubUsesGetAttr: 'Type stub file is incomplete; "__getattr__" obscures type errors for module',
        sublistParamsIncompatible: 'Sublist parameters are not supported in Python 3.x',
        superCallArgCount: '"super" çağrısı için ikiden fazla bağımsız değişken beklenmiyordu',
        superCallFirstArg: '"super" çağrısının ilk bağımsız değişkeni olarak sınıf türü bekleniyordu ancak "{type}" alındı',
        superCallSecondArg: '"super" çağrısının ikinci bağımsız değişkeni, "{type}" türünden türetilen nesne veya sınıf olmalıdır',
        superCallZeroArgForm: '"super" çağrısının zero-argument biçimi yalnızca bir metot içinde geçerlidir',
        superCallZeroArgFormStaticMethod: '"super" çağrısının zero-argument biçimi statik bir metot içinde geçerli değildir',
        symbolIsPossiblyUnbound: '"{name}" büyük olasılıkla bağlı değil',
        symbolIsUnbound: '"{name}" bağlı değil',
        symbolIsUndefined: '"{name}" tanımlanmadı',
        symbolOverridden: '"{name}", "{className}" sınıfında aynı ada sahip sembolü geçersiz kılar',
        ternaryNotAllowed: 'Tür ifadesinde üçlü ifade kullanılamaz',
        totalOrderingMissingMethod: 'total_ordering kullanmak için sınıfta "__lt__", "__le__", "__gt__" veya "__ge__" metotlarından biri tanımlanmalıdır',
        trailingCommaInFromImport: 'Çevreleyen parantezler olmadan sondaki virgüle izin verilmez',
        tryWithoutExcept: 'Try deyimi en az bir except veya finally yan tümcesi içermelidir',
        tupleAssignmentMismatch: 'Expression with type "{type}" cannot be assigned to target tuple',
        tupleInAnnotation: 'Tuple expression not allowed in type expression',
        tupleIndexOutOfRange: '{index} dizini {type} türü için aralık dışında',
        typeAliasIllegalExpressionForm: 'Tür diğer ad tanımı için geçersiz ifade form',
        typeAliasIsRecursiveDirect: 'Tür diğer adı "{name}", tanımında kendisini kullanamaz',
        typeAliasNotInModuleOrClass: 'TypeAlias yalnızca bir modül veya sınıf kapsamında tanımlanabilir',
        typeAliasRedeclared: '"{name}" bir TypeAlias olarak bildirilmiş ve yalnızca bir kez atanabilir',
        typeAliasStatementBadScope: 'A type statement can be used only within a module or class scope',
        typeAliasStatementIllegal: 'Tür diğer adı deyimi için Python 3.12 veya daha yeni bir sürümü gerekiyor',
        typeAliasTypeBaseClass: 'Bir "type" deyiminde tanımlanan type diğer adı temel sınıf olarak kullanılamaz',
        typeAliasTypeMustBeAssigned: 'TypeAliasType, tür diğer adıyla aynı ada sahip bir değişkene atanmalıdır',
        typeAliasTypeNameArg: 'TypeAliasType için ilk bağımsız değişken, tür diğer adının adını temsil eden bir sabit değerli dize olmalıdır',
        typeAliasTypeNameMismatch: 'Tür diğer adının atandığı değişkenin adıyla eşleşmesi gerekiyor',
        typeAliasTypeParamInvalid: 'Type parameter list must be a tuple containing only TypeVar, TypeVarTuple, or ParamSpec',
        typeAnnotationCall: 'Tür ifadesinde çağrı ifadesine izin verilmiyor',
        typeAnnotationVariable: 'Tür ifadesinde değişkene izin verilmiyor',
        typeAnnotationWithCallable: 'Type argument for "type" must be a class; callables are not supported',
        typeArgListExpected: 'ParamSpec, üç nokta veya tür listesi bekleniyordu',
        typeArgListNotAllowed: 'Bu tür bağımsız değişkeni için liste ifadesine izin verilmiyor',
        typeArgsExpectingNone: '"{name}" sınıfı için tür bağımsız değişkeni beklenmiyordu',
        typeArgsMismatchOne: 'Bir tane tür bağımsız değişkeni bekleniyordu ancak {received} alındı',
        typeArgsMissingForAlias: '"{name}" genel tür diğer adı için tür bağımsız değişkenleri bekleniyordu',
        typeArgsMissingForClass: '"{name}" genel sınıf adı için tür bağımsız değişkenleri bekleniyordu',
        typeArgsTooFew: '"{name}" için çok az tür bağımsız değişkeni sağlandı; {expected} bekleniyordu ancak {received} alındı',
        typeArgsTooMany: '"{name}" için çok fazla tür bağımsız değişkeni sağlandı; {expected} bekleniyordu ancak {received} alındı',
        typeAssignmentMismatch: '"{sourceType}" türü "{destType}" bildirilen türüne atanamaz',
        typeAssignmentMismatchWildcard: '"{name}" içeri aktarma sembolü "{sourceType}" türüne sahip ve bu tür "{destType}" bildirilen türüne atanamaz',
        typeCallNotAllowed: 'Tür ifadesinde type() çağrısı kullanılmamalıdır',
        typeCheckOnly: '"{name}", @type_check_only olarak işaretlendi ve yalnızca tür ek açıklamalarında kullanılabilir',
        typeCommentDeprecated: 'Use of type comments is deprecated; use type annotation instead',
        typeExpectedClass: 'Sınıf bekleniyordu ancak "{type}" alındı',
        typeFormArgs: '"TypeForm" tek bir konumsal bağımsız değişkeni kabul eder',
        typeGuardArgCount: 'Expected a single type argument after "TypeGuard" or "TypeIs"',
        typeGuardParamCount: 'Kullanıcı tanımlı tür koruma işlevleri ve metotlarında en az bir giriş parametresi olmalıdır',
        typeIsReturnType: 'TypeIs dönüş türü ("{returnType}"), değer parametresi türü ("{type}") ile tutarlı değil',
        typeNotAwaitable: '"{type}" is not awaitable',
        typeNotIntantiable: '"{type}" örneği oluşturulamıyor',
        typeNotIterable: '"{type}" yeniden kullanılamaz',
        typeNotSpecializable: '"{type}" türü özelleştirilemedi',
        typeNotSubscriptable: '"{type}" türündeki nesne alt simgeleştirilebilir değil',
        typeNotSupportBinaryOperator: 'İşleç "{operator}", "{leftType}" ve "{rightType}" türleri için desteklenmiyor',
        typeNotSupportBinaryOperatorBidirectional: '"{operator}" işleci, beklenen tür "{expectedType}" olduğunda "{leftType}" ve "{rightType}" türleri için desteklenmez',
        typeNotSupportUnaryOperator: '"{operator}" işleci "{type}" türü için desteklenmiyor',
        typeNotSupportUnaryOperatorBidirectional: '"{operator}" işleci, beklenen tür "{expectedType}" olduğunda "{type}" türü için desteklenmiyor',
        typeNotUsableWith: '{method} metodunu uygulamadığından "{type}" türündeki nesne "with" ile kullanılamaz',
        typeParameterBoundNotAllowed: 'Sınır veya kısıtlama, değişen tür parametresi veya ParamSpec ile kullanılamaz',
        typeParameterConstraintTuple: 'Tür parametresi kısıtlaması iki veya daha fazla türde bir demet olmalıdır',
        typeParameterExistingTypeParameter: '"{name}" tür parametresi zaten kullanılıyor',
        typeParameterNotDeclared: '"{name}" tür parametresi "{container}" öğesine ait tür parametreleri listesinde yok',
        typeParametersMissing: 'En az bir tür parametresi belirtilmelidir',
        typePartiallyUnknown: '"{name}" türü kısmen bilinmiyor',
        typeUnknown: '"{name}" türü bilinmiyor',
        typeVarAssignedName: 'TypeVar, "{name}" adlı bir değişkene atanmalı',
        typeVarAssignmentMismatch: '"{type}" türü "{name}" tür değişkenine atanamaz',
        typeVarBoundAndConstrained: 'TypeVar hem bağlı hem de kısıtlanmış olamaz',
        typeVarBoundGeneric: 'TypeVar bağlı türü genel olamaz',
        typeVarConstraintGeneric: 'TypeVar kısıtlama türü genel olamaz',
        typeVarDefaultBoundMismatch: 'TypeVar varsayılan türü, bağlı türün bir alt türü olmalıdır',
        typeVarDefaultConstraintMismatch: 'TypeVar varsayılan türü kısıtlanmış türlerden biri olmalıdır',
        typeVarDefaultIllegal: 'Tür değişkeni varsayılan türleri Python 3.13 veya daha yeni bir sürüm gerektirir',
        typeVarDefaultInvalidTypeVar: '"{name}" tür parametresi, kapsam dışı bir veya daha fazla tür değişkenine başvuran varsayılan bir türe sahip',
        typeVarFirstArg: 'İlk bağımsız değişken olarak TypeVar adı bekleniyordu',
        typeVarInvalidForMemberVariable: 'Öznitelik türü, yerel yöntem kapsamına alınan "{name}" tür değişkenini kullanamaz',
        typeVarNoMember: 'TypeVar "{type}", "{name}" özniteliğine sahip değil',
        typeVarNotSubscriptable: 'TypeVar "{type}" alt yazılabilir değil',
        typeVarNotUsedByOuterScope: '"{name}" tür değişkeni bu bağlamda bir anlam ifade etmiyor',
        typeVarPossiblyUnsolvable: '"{name}" tür değişkeni, çağıran "{param}" parametresi için bağımsız değişken sağlamazsa çözümlenemeyebilir',
        typeVarSingleConstraint: 'TypeVar en az iki kısıtlanmış türe sahip olmalıdır',
        typeVarTupleConstraints: 'TypeVarTuple değer kısıtlamalarına sahip olamaz',
        typeVarTupleContext: 'TypeVarTuple bu bağlamda kullanılamaz',
        typeVarTupleDefaultNotUnpacked: 'TypeVarTuple default type must be an unpacked tuple or TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'TypeVarTuple değeri için Paket açma işleci gereklidir',
        typeVarTupleUnknownParam: '"{name}" is unknown parameter to TypeVarTuple',
        typeVarUnknownParam: '"{name}", TypeVar için bilinmeyen bir parametre',
        typeVarUsedByOuterScope: 'TypeVar "{name}" zaten bir dış kapsam tarafından kullanılıyor',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" genel işlev imzasında yalnızca bir kez görünür',
        typeVarVariance: 'TypeVar hem birlikte değişken hem de değişken karşıtı olamaz',
        typeVarWithDefaultFollowsVariadic: '"{typeVarName}" TypeVar alanı bir varsayılan değer içerir ve "{variadicName}" TypeVarTuple alanına uyamaz',
        typeVarWithoutDefault: '"{name}" varsayılan türe sahip olmadığından tür parametresi listesinde "{other}" sonrasında bulunamaz',
        typeVarsNotInGenericOrProtocol: 'Generic[] veya Protocol[] tüm tür değişkenlerini içermeli',
        typedDictAccess: 'TypedDict\'da öğeye erişilemedi',
        typedDictAssignedName: 'TypedDict, "{name}" adlı bir değişkene atanmalı',
        typedDictBadVar: 'TypedDict sınıfları yalnızca tür ek açıklamaları içerebilir',
        typedDictBaseClass: 'TypedDict sınıfları için tüm temel sınıflar da TypedDict sınıfları olmalıdır',
        typedDictBoolParam: 'True veya False değeri olması için "{name}" parametresi bekleniyordu',
        typedDictClosedExtras: '"{name}" temel sınıfı closed bir TypedDict öğesidir; ek öğeler "{type}" türünde olmalıdır',
        typedDictClosedNoExtras: '"{name}" temel sınıfı closed bir TypedDict öğesidir; ek öğelere izin verilmiyor',
        typedDictDelete: 'TypedDict\'da öğe silinemedi',
        typedDictEmptyName: 'TypedDict içindeki adlar boş olamaz',
        typedDictEntryName: 'Sözlük girdisi adı için sabit değerli dize bekleniyordu',
        typedDictEntryUnique: 'Sözlük içindeki adlar benzersiz olmalıdır',
        typedDictExtraArgs: 'Ekstra TypedDict bağımsız değişkenleri desteklenmiyor',
        typedDictExtraItemsClosed: 'Bir TypedDict ek öğeleri destekliyorsa closed olamaz',
        typedDictFieldNotRequiredRedefinition: '"{name}" TypedDict öğesi NotRequired olarak yeniden tanımlanamaz',
        typedDictFieldReadOnlyRedefinition: '"{name}" TypedDict öğesi ReadOnly olarak yeniden tanımlanamaz',
        typedDictFieldRequiredRedefinition: '"{name}" TypedDict öğesi Required olarak yeniden tanımlanamaz',
        typedDictFirstArg: 'Birinci bağımsız değişken olarak TypedDict sınıf adı bekleniyordu',
        typedDictInClassPattern: 'TypedDict sınıfına sınıf deseninde izin verilmez',
        typedDictInitsubclassParameter: 'TypedDict, "{name}" __init_subclass__ parametresini desteklemez',
        typedDictNotAllowed: '"TypedDict" bu bağlamda kullanılamaz',
        typedDictSecondArgDict: 'Expected dict or keyword parameter as second parameter',
        typedDictSecondArgDictEntry: 'Basit sözlük girişi bekleniyordu',
        typedDictSet: 'TypedDict içinde öğe atanamadı',
        unaccessedClass: '"{name}" sınıfına erişilemiyor',
        unaccessedFunction: '"{name}" işlevine erişilemiyor',
        unaccessedImport: '"{name}" içeri aktarma işlemine erişilemiyor',
        unaccessedSymbol: '"{name}" öğesine erişilemiyor',
        unaccessedVariable: '"{name}" değişkenine erişilemiyor',
        unannotatedFunctionSkipped: '"{name}" işlevinin analizi, açıklanmadığından atlandı',
        unaryOperationNotAllowed: 'Tür ifadesinde birli işleç kullanılamaz',
        unexpectedAsyncToken: '"async" öğesinin ardından "def", "with" veya "for" bekleniyordu',
        unexpectedExprToken: 'İfadenin sonunda beklenmeyen belirteç',
        unexpectedIndent: 'Beklenmeyen girinti',
        unexpectedUnindent: 'Girintiyi kaldırma beklenmiyordu',
        unhashableDictKey: 'Sözlük anahtarı karmalanabilir olmalıdır',
        unhashableSetEntry: 'Set entry must be hashable',
        uninitializedAbstractVariables: 'Soyut temel sınıfta tanımlanan değişkenler "{classType}" final sınıfında başlatılmaz',
        uninitializedInstanceVariable: '"{name}" örnek değişkeni sınıf gövdesinde veya __init__ metodunda başlatılmadı',
        unionForwardReferenceNotAllowed: 'Union söz dizimi dize işleneni ile kullanılamaz; ifadenin tamamını tırnak içine alın',
        unionSyntaxIllegal: 'Union işlemlerinde alternatif söz dizimi kullanılabilmesi için Python 3.10 veya daha yeni bir sürümü gerekiyor',
        unionTypeArgCount: 'Union için iki veya daha fazla tür bağımsız değişkeni gerekiyor',
        unionUnpackedTuple: 'Union, paketlenmemiş bir tuple içeremez',
        unionUnpackedTypeVarTuple: 'Union, paketlenmemiş bir TypeVarTuple içeremez',
        unnecessaryCast: 'Gereksiz "cast" çağrısı; tür zaten "{type}"',
        unnecessaryIsInstanceAlways: 'Gereksiz isinstance çağrısı; "{testType}" her zaman bir "{classType}" örneğidir',
        unnecessaryIsInstanceNever: 'Gereksiz isinstance çağrısı; "{testType}" asla bir "{classType}" örneği değildir',
        unnecessaryIsSubclassAlways: 'Gereksiz issubclass çağrısı; "{testType}" her zaman "{classType}" sınıf türünün bir alt sınıfıdır',
        unnecessaryIsSubclassNever: 'Gereksiz issubclass çağrısı; "{testType}" asla "{classType}" sınıf türünün bir alt sınıfı değildir',
        unnecessaryPyrightIgnore: 'Gereksiz "# pyright: ignore" açıklaması',
        unnecessaryPyrightIgnoreRule: '"# pyright: ignore" rule: "{name}" gereksiz',
        unnecessaryTypeIgnore: 'Unnecessary "# type: ignore" comment',
        unpackArgCount: '"Unpack" sonrasında tek bir tür bağımsız değişken bekleniyordu',
        unpackExpectedTypeVarTuple: 'Unpack için tür bağımsız değişkeni olarak TypeVarTuple veya tuple bekleniyordu',
        unpackExpectedTypedDict: 'Unpack için TypedDict tür bağımsız değişkeni bekleniyordu',
        unpackIllegalInComprehension: 'Anlamada paket açma işlemi kullanılamaz',
        unpackInAnnotation: 'Tür ifadesinde paket açma işleci kullanılamaz',
        unpackInDict: 'Sözlüklerde paket açma işlemi kullanılamaz',
        unpackInSet: 'Unpack operator not allowed within a set',
        unpackNotAllowed: 'Unpack is not allowed in this context',
        unpackOperatorNotAllowed: 'Bu bağlamda paket açma işlemi kullanılamaz',
        unpackTuplesIllegal: 'Python 3.8\'den önceki demetler içinde paket açma işlemi kullanılamıyor',
        unpackedArgInTypeArgument: 'Paketlenmemiş bağımsız değişkenler bu bağlamda kullanılamaz',
        unpackedArgWithVariadicParam: 'Paketlenmemiş bağımsız değişken, TypeVarTuple parametresi için kullanılamaz',
        unpackedDictArgumentNotMapping: '** sonrasındaki bağımsız değişken ifadesi "str" anahtar türüne sahip bir eşleme olmalıdır',
        unpackedDictSubscriptIllegal: 'Alt simgede sözlük açma işlecine izin verilmiyor',
        unpackedSubscriptIllegal: 'Alt simgede açma işleci için Python 3.11 veya daha yeni bir sürümü gerekiyor',
        unpackedTypeVarTupleExpected: 'Paketlenmemiş TypeVarTuple bekleniyordu; Unpack[{name1}] veya *{name2} kullanın',
        unpackedTypedDictArgument: 'Paketlenmemiş TypedDict bağımsız değişkeni parametrelerle eşlenemiyor',
        unreachableCode: 'Koda ulaşılamıyor',
        unreachableCodeType: 'Tür analizi koda erişilemediğini gösteriyor',
        unreachableExcept: 'Except clause is unreachable because exception is already handled',
        unsupportedDunderAllOperation: '"__all__" üzerinde işlem desteklenmiyor, bu nedenle dışarı aktarılan sembol listesi yanlış olabilir',
        unusedCallResult: 'Çağrı ifadesinin sonucu "{type}" türünde ve kullanılmıyor; bilerek yapıldıysa "_" değişkenine atayın',
        unusedCoroutine: 'Result of async function call is not used; use "await" or assign result to variable',
        unusedExpression: 'İfade değeri kullanılmadı',
        varAnnotationIllegal: 'Type annotations for variables requires Python 3.6 or newer; use type comment for compatibility with previous versions',
        variableFinalOverride: '"{name}" değişkeni Final olarak işaretlendi ve "{className}" sınıfı içinde aynı ada sahip Final olmayan değişkeni geçersiz kılıyor',
        variadicTypeArgsTooMany: 'Tür bağımsız değişkeni listesinde en fazla bir paketlenmemiş TypeVarTuple veya tuple olabilir',
        variadicTypeParamTooManyAlias: 'Tür diğer adı en fazla bir TypeVarTuple tür parametresine sahip olabilir ancak birden fazlası {names}) alındı',
        variadicTypeParamTooManyClass: 'Genel sınıf en fazla bir TypeVarTuple tür parametresine sahip olabilir ancak birden fazlası {names}) alındı',
        walrusIllegal: '":=" işleci için Python 3.8 veya daha yeni bir sürümü gerekiyor',
        walrusNotAllowed: 'Çevreleyen parantezler olmadan bu bağlamda ":=" işlecine izin verilmiyor',
        wildcardInFunction: 'Wildcard import not allowed within a class or function',
        wildcardLibraryImport: 'Wildcard import from a library not allowed',
        wildcardPatternTypePartiallyUnknown: 'Joker karakter deseni tarafından yakalanan tür kısmen bilinmiyor',
        wildcardPatternTypeUnknown: 'Joker karakter deseni tarafından yakalanan tür bilinmiyor',
        yieldFromIllegal: '"yield from" kullanımı için Python 3.3 veya daha yeni bir sürümü gerekiyor',
        yieldFromOutsideAsync: '"yield from" not allowed in an async function',
        yieldOutsideFunction: '"yield", işlev veya lambda dışında kullanılamaz',
        yieldWithinComprehension: 'Bir anlama içinde “yield” kullanılamaz',
        zeroCaseStatementsFound: 'Match deyimi en az bir case deyimi içermeli',
        zeroLengthTupleNotAllowed: 'Zero-length tuple is not allowed in this context'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '“Annotated” özel biçimi, örnek ve sınıf denetimleriyle kullanılamaz',
        argParam: 'Bağımsız değişken "{paramName}" parametresine karşılık gelir',
        argParamFunction: 'Bağımsız değişken, "{functionName}" işlevinde "{paramName}" parametresine karşılık gelir',
        argsParamMissing: '"*{paramName}" parametresine karşılık gelen bir parametre yok',
        argsPositionOnly: 'Yalnızca konum parametresi uyuşmazlığı; {expected} bekleniyordu ancak {received} alındı',
        argumentType: 'Bağımsız değişken türü "{type}"',
        argumentTypes: 'Bağımsız değişken türleri: ({types})',
        assignToNone: 'Tür "None" öğesine atanamaz',
        asyncHelp: '"async with" mi demek istediniz?',
        baseClassIncompatible: '"{baseClass}" temel sınıfı "{type}" türüyle uyumlu değil',
        baseClassIncompatibleSubclass: '"{baseClass}" temel sınıfı, "{type}" türüyle uyumlu olmayan "{subclass}" alt sınıfından türetiliyor',
        baseClassOverriddenType: '"{baseClass}" temel sınıfı geçersiz kılınan "{type}" türünü sağlar',
        baseClassOverridesType: 'Temel sınıf "{baseClass}", "{type}" türünü geçersiz kılıyor',
        bytesTypePromotions: '“bytearray” ve “memoryview” için tür yükseltme davranışını etkinleştirmek için disableBytesTypePromotions seçeneğini “false” olarak ayarlayın',
        conditionalRequiresBool: '"{operandType}" türü için __bool__ metodu "bool" yerine "{boolReturnType}" türü döndürür',
        dataClassFieldLocation: 'Alan bildirimi',
        dataClassFrozen: '"{name}" donduruldu',
        dataProtocolUnsupported: '"{name}" bir veri protokolü',
        descriptorAccessBindingFailed: 'Tanımlayıcı sınıf "{className}" için "{name}" yöntemi bağlanamadı',
        descriptorAccessCallFailed: 'Tanımlayıcı sınıf "{className}" için "{name}" yöntemi çağrılamadı',
        finalMethod: 'Final metodu',
        functionParamDefaultMissing: '"{name}" parametresinde varsayılan bağımsız değişken eksik',
        functionParamName: 'Parametre adı uyuşmazlığı: "{destName}" ve "{srcName}"',
        functionParamPositionOnly: 'Yalnızca konum parametresi uyuşmazlığı; "{name}" parametresi yalnızca konum değil',
        functionReturnTypeMismatch: '"{sourceType}" işlev dönüş türü, "{destType}" türüyle uyumsuz',
        functionTooFewParams: 'İşlev çok az konumsal parametre kabul ediyor; {expected} bekleniyordu ancak {received} alındı',
        functionTooManyParams: 'İşlev çok fazla konumsal parametre kabul ediyor; {expected} bekleniyordu ancak {received} alındı',
        genericClassNotAllowed: 'Örnek veya sınıf denetimleri için tür bağımsız değişkenlerine sahip genel türe izin verilmiyor',
        incompatibleDeleter: 'Property deleter method is incompatible',
        incompatibleGetter: 'Property getter method is incompatible',
        incompatibleSetter: 'Property setter method is incompatible',
        initMethodLocation: '"{type}" sınıfı içinde __init__ metodu tanımlandı',
        initMethodSignature: '__init__ imzası "{type}"',
        initSubclassLocation: '__init_subclass__ yöntemi "{name}" sınıfı içinde tanımlandı',
        invariantSuggestionDict: '“dict” öğesinden değer türünde eş değişken olan “Mapping” öğesine geçmeyi deneyin',
        invariantSuggestionList: '“list” öğesinden eş değişken olan “Sequence” öğesine geçmeyi deneyin',
        invariantSuggestionSet: 'Consider switching from "set" to "Container" which is covariant',
        isinstanceClassNotSupported: '"{type}", örnek ve sınıf denetimleri için desteklenmiyor',
        keyNotRequired: '"{name}", "{type}" türünde gerekli bir anahtar olmadığından çalışma zamanı özel durumuna neden olabilir',
        keyReadOnly: '"{name}", "{type}" içinde salt okunur',
        keyRequiredDeleted: '"{name}" gerekli bir anahtar olduğundan silinemez',
        keyUndefined: '"{name}", "{type}" içinde tanımlı bir anahtar değil',
        kwargsParamMissing: '"**{paramName}" parametresine karşılık gelen bir parametre yok',
        listAssignmentMismatch: '"{type}" türü hedef listeyle uyumsuz',
        literalAssignmentMismatch: '"{sourceType}" "{destType}" türüne atanamaz',
        matchIsNotExhaustiveHint: 'Tümlemeli işleme amaçlanmadıysa "case _: pass" ekleyin',
        matchIsNotExhaustiveType: '"{type}" türü işlenmemiş',
        memberAssignment: '"{type}" türündeki ifade, "{classType}" sınıfının "{name}" özniteliğine atanamaz',
        memberIsAbstract: '"{type}.{name}" uygulanmadı',
        memberIsAbstractMore: 've +{count} tane daha...',
        memberIsClassVarInProtocol: '"{name}", protokolde ClassVar olarak tanımlandı',
        memberIsInitVar: '"{name}" is an init-only field',
        memberIsInvariant: '"{name}" değiştirilebilir olduğundan sabit ayarlanır',
        memberIsNotClassVarInClass: '"{name}" protokolle uyumlu olması için ClassVar olarak tanımlanmalıdır',
        memberIsNotClassVarInProtocol: '"{name}" protokolde ClassVar olarak tanımlanmadı',
        memberIsNotReadOnlyInProtocol: '"{name}" protokolde salt okunur durumda değil',
        memberIsReadOnlyInProtocol: '"{name}" protokolde salt okunur durumda',
        memberIsWritableInProtocol: '"{name}" protokolde yazılabilir',
        memberSetClassVar: '"{name}" özniteliği bir ClassVar olduğundan sınıf örneği aracılığıyla atanamaz',
        memberTypeMismatch: '"{name}" uyumsuz bir tür',
        memberUnknown: '"{name}" özniteliği bilinmiyor',
        metaclassConflict: 'Metaclass "{metaclass1}", "{metaclass2}" ile çakışıyor',
        missingDeleter: 'Property deleter method is missing',
        missingGetter: 'Property getter method is missing',
        missingSetter: 'Property setter method is missing',
        namedParamMissingInDest: '"{name}" ek parametresi',
        namedParamMissingInSource: '"{name}" eksik anahtar sözcük parametresi',
        namedParamTypeMismatch: '"{sourceType}" türündeki "{name}" anahtar sözcük parametresi, "{destType}" türüyle uyumsuz',
        namedTupleNotAllowed: 'NamedTuple örnek veya sınıf kontrolleri için kullanılamaz',
        newMethodLocation: '"{type}" sınıfı içinde __new__ metodu tanımlandı',
        newMethodSignature: '__new__ imzası "{type}"',
        newTypeClassNotAllowed: 'NewType ile oluşturulan sınıf, örnek ve sınıf denetimleriyle kullanılamaz',
        noOverloadAssignable: 'Aşırı yüklenmiş işlevlerden hiçbiri "{type}" türüyle uyuşmuyor',
        noneNotAllowed: 'Örnek veya sınıf denetimleri için None kullanılamaz',
        orPatternMissingName: 'Eksik adlar: {name}',
        overloadIndex: 'Aşırı yükleme {index} en yakın eşleşmedir',
        overloadNotAssignable: 'Bir veya daha fazla "{name}" aşırı yüklemesi atanabilir değil',
        overloadSignature: 'Aşırı yükleme imzası burada tanımlı',
        overriddenMethod: 'Geçersiz kılınan metot',
        overriddenSymbol: 'Geçersiz kılınan simge',
        overrideInvariantMismatch: '"{overrideType}" geçersiz kılma türü "{baseType}" temel türüyle aynı değil',
        overrideIsInvariant: 'Değişken değişebilir, bu nedenle türü sabit',
        overrideNoOverloadMatches: 'Geçersiz kılmadaki hiçbir aşırı yükleme imzası temel metotla uyumlu değil',
        overrideNotClassMethod: 'Base method is declared as a classmethod but override is not',
        overrideNotInstanceMethod: 'Temel metot bir örnek metodu olarak bildirilir, ancak geçersiz kılma bu şekilde bildirilmez',
        overrideNotStaticMethod: 'Temel metot bir staticmethod olarak bildirilir, ancak geçersiz kılma bu şekilde bildirilmez',
        overrideOverloadNoMatch: 'Geçersiz kılma temel yöntemin tüm aşırı yüklemelerini işlemez',
        overrideOverloadOrder: 'Geçersiz kılma metoduna ait aşırı yüklemeler temel metotla aynı sırada olmalıdır',
        overrideParamKeywordNoDefault: '"{name}" anahtar sözcük parametresi eşleşmiyor: Temel parametrede varsayılan bağımsız değişken değer var, geçersiz kılma parametresinde yok',
        overrideParamKeywordType: '"{name}" anahtar sözcük parametresi tür uyuşmazlığı: temel parametre "{baseType}" türünde, geçersiz kılma parametresi "{overrideType}" türünde',
        overrideParamName: '{index} parametresi ad uyuşmazlığı: temel parametre adı "{baseName}", geçersiz kılma parametresinin adı "{overrideName}"',
        overrideParamNameExtra: 'Temelde "{name}" parametresi eksik',
        overrideParamNameMissing: 'Geçersiz kılmada "{name}" parametresi eksik',
        overrideParamNamePositionOnly: '{index} parametresi eşleşmiyor: "{baseName}" temel parametresi, anahtar sözcük parametresidir, geçersiz kılma parametresi ise yalnızca konumdur',
        overrideParamNoDefault: '{index} parametresi eşleşmiyor: Temel parametrede varsayılan bağımsız değişken değer var, geçersiz kılma parametresinde yok',
        overrideParamType: '"{index}" parametresi tür uyuşmazlığı: temel parametre "{baseType}" türünde, geçersiz kılma parametresi "{overrideType}" türünde',
        overridePositionalParamCount: 'Konumsal parametre sayısı uyuşmazlığı; temel metotta {baseCount} var, ancak geçersiz kılmada {overrideCount} var',
        overrideReturnType: 'Dönüş türü uyuşmazlığı: temel metot tür "{baseType}" türü döndürür, geçersiz kılma ise "{overrideType}" türü döndürür',
        overrideType: 'Temel sınıf, türü "{type}" olarak tanımlar',
        paramAssignment: '{index} parametresi: "{sourceType}" türü "{destType}" türüyle uyumsuz',
        paramSpecMissingInOverride: 'Geçersiz kılma metodunda ParamSpec parametreleri eksik',
        paramType: 'Parametre türü "{paramType}"',
        privateImportFromPyTypedSource: 'Bunun yerine "{module}" üzerinden içeri aktarın',
        propertyAccessFromProtocolClass: 'Protokol sınıfı içinde tanımlanan bir özelliğe sınıf değişkeni olarak erişilemez',
        propertyMethodIncompatible: 'Property method "{name}" is incompatible',
        propertyMethodMissing: 'Property method "{name}" is missing in override',
        propertyMissingDeleter: 'Property "{name}" has no defined deleter',
        propertyMissingSetter: 'Property "{name}" has no defined setter',
        protocolIncompatible: '"{sourceType}", "{destType}" protokol ayarlarıyla uyumsuz',
        protocolMemberMissing: '"{name}" yok',
        protocolRequiresRuntimeCheckable: 'Protocol sınıfının örnekle ve sınıf denetimleriyle birlikte kullanılabilmesi için @runtime_checkable olması gerekir',
        protocolSourceIsNotConcrete: '"{sourceType}" somut bir sınıf türü değil ve "{destType}" türüne atanamaz',
        protocolUnsafeOverlap: '"{name}" öznitelikleri protokolle aynı adlara sahip',
        pyrightCommentIgnoreTip: 'Tek bir satırda tanılamayı durdurmak için "# pyright: ignore[<diagnostic rules>]" kullanın',
        readOnlyAttribute: '"{name}" özniteliği salt okunur',
        seeClassDeclaration: 'Sınıf bildirimine bakın',
        seeDeclaration: 'Bildirime bakın',
        seeFunctionDeclaration: 'İşlev bildirimine bakın',
        seeMethodDeclaration: 'Metot bildirimine bakın',
        seeParameterDeclaration: 'Parametre bildirimine bakın',
        seeTypeAliasDeclaration: 'Tür diğer adı bildirimine bakın',
        seeVariableDeclaration: 'Değişken bildirimine bakın',
        tupleAssignmentMismatch: 'Type "{type}" is incompatible with target tuple',
        tupleEntryTypeMismatch: 'Tuple entry {entry} is incorrect type',
        tupleSizeIndeterminateSrc: 'Tuple boyutu uyuşmuyor; {expected} bekleniyordu ancak indeterminate alındı',
        tupleSizeIndeterminateSrcDest: 'Tuple boyutu uyuşmuyor; {expected} veya daha büyük bir değer bekleniyordu ancak belirsiz bir değer alındı',
        tupleSizeMismatch: 'Tuple size mismatch; expected {expected} but received {received}',
        tupleSizeMismatchIndeterminateDest: 'Tuple boyutu uyuşmuyor; {expected} veya daha büyük bir değer bekleniyordu ancak {received} alındı',
        typeAliasInstanceCheck: '“Type” deyimi ile oluşturulan type diğer adı örnek ve sınıf denetimleri kullanılamaz',
        typeAssignmentMismatch: '"{sourceType}" türü "{destType}" türüne atanamaz',
        typeBound: '"{sourceType}" türü "{name}" tür değişkeni için "{destType}" üst sınırına atanamaz',
        typeConstrainedTypeVar: '"{type}" türü "{name}" kısıtlanmış tür değişkenine atanamaz',
        typeIncompatible: '"{sourceType}" "{destType}" öğesine atanamaz',
        typeNotClass: '"{type}" bir sınıf değil',
        typeNotStringLiteral: '"{type}" bir sabit değeri dize değil',
        typeOfSymbol: '"{name}" türü "{type}"',
        typeParamSpec: '"{type}" türü "{name}" ParamSpec ile uyumlu değil',
        typeUnsupported: '"{type}" türü desteklenmiyor',
        typeVarDefaultOutOfScope: '"{name}" tür değişkeni kapsamda değil',
        typeVarIsContravariant: '"{name}" tür parametresi bir karşıt değişken ancak "{sourceType}", "{destType}" öğesinin bir üst türü değil',
        typeVarIsCovariant: '"{name}" tür parametresi bir eşdeğişken ancak "{sourceType}", "{destType}" öğesinin bir alt türü değil',
        typeVarIsInvariant: '"{name}" tür parametresi bir değişmez değer ancak "{sourceType}", "{destType}" ile aynı değil',
        typeVarNotAllowed: 'Örnek veya sınıf denetimleri için TypeVar\'a izin verilmiyor',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple cannot be bound to a tuple of unknown length',
        typeVarUnnecessarySuggestion: 'Bunun yerine {type} kullanın',
        typeVarUnsolvableRemedy: 'Bağımsız değişken sağlanmamışken dönüş türünü belirten bir aşırı yükleme belirtin',
        typeVarsMissing: 'Eksik tür değişkenleri: {names}',
        typedDictBaseClass: '"{type}" sınıfı bir TypedDict değil',
        typedDictClassNotAllowed: 'Örnek veya sınıf denetimleri için TypedDict sınıfına izin verilmiyor',
        typedDictClosedExtraNotAllowed: '"{name}" öğesi eklenemiyor',
        typedDictClosedExtraTypeMismatch: '"{type}" türündeki "{name}" öğesi eklenemiyor',
        typedDictClosedFieldNotRequired: 'NotRequired olması gerektiğinden "{name}" öğesi eklenemiyor',
        typedDictExtraFieldNotAllowed: '"{name}" öğesi "{type}" türünde mevcut değil',
        typedDictExtraFieldTypeMismatch: '"{name}" türü, "{type}" altındaki "extra_items" türüyle uyumlu değil',
        typedDictFieldMissing: '"{type}" için "{name}" eksik',
        typedDictFieldNotReadOnly: '"{name}", "{type}" içinde salt okunur değil',
        typedDictFieldNotRequired: '"{type}" içinde "{name}" gerekli değil',
        typedDictFieldRequired: '"{type}" içinde "{name}" gerekiyor',
        typedDictFieldTypeMismatch: '"{type}" türü "{name}" öğesine atanamaz',
        typedDictFieldUndefined: '"{name}", "{type}" türündeki tanımsız bir öğedir',
        typedDictFinalMismatch: '"{sourceType}" @final uyumsuzluğu nedeniyle "{destType}" ile uyumsuz',
        typedDictKeyAccess: 'TypedDict’te öğeye başvurmak için ["{name}"] değerini kullanın',
        typedDictNotAllowed: 'TypedDict örnek veya sınıf kontrolleri için kullanılamaz',
        unhashableType: '"{type}" türü karmalanabilir değil',
        uninitializedAbstractVariable: '"{name}" örnek değişkeni, "{classType}" soyut temel sınıfında tanımlandı ancak başlatılmadı',
        unreachableExcept: '"{exceptionType}", "{parentType}" üst öğesinin bir alt sınıfı',
        useDictInstead: 'Sözlük türünü belirtmek için Dict[T1, T2] kullanın',
        useListInstead: 'Use List[T] to indicate a list type or Union[T1, T2] to indicate a union type',
        useTupleInstead: 'Use tuple[T1, ..., Tn] to indicate a tuple type or Union[T1, T2] to indicate a union type',
        useTypeInstead: 'Bunun yerine Type[T] kullanın',
        varianceMismatchForClass: '"{typeVarName}" tür bağımsız değişkeni "{className}" taban sınıfıyla uyumsuz',
        varianceMismatchForTypeAlias: '"{typeVarName}" tür bağımsız değişkeninin varyansı, "{typeAliasParam}" ile uyumsuz'
      },
      Service: {
        longOperation: 'Çalışma alanı kaynak dosyalarının numaralandırılması uzun zaman alıyor. Bunun yerine bir alt klasör açabilirsiniz. [Daha fazla bilgi edinin](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  63982: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: '创建类型 Stub',
        createTypeStubFor: '为 "{moduleName}" 创建类型 Stub',
        executingCommand: '正在执行命令',
        filesToAnalyzeCount: '要分析的 {count} 个文件',
        filesToAnalyzeOne: '1 个要分析的文件',
        findingReferences: '正在查找引用',
        organizeImports: '整理 Import',
        renameShadowedFile: '将“{oldFile}”重命名为“{newFile}”'
      },
      Completion: {
        autoImportDetail: '自动导入',
        indexValueDetail: '索引值'
      },
      Diagnostic: {
        abstractMethodInvocation: '无法调用方法“{method}”，因为它是抽象的且未实施',
        annotatedMetadataInconsistent: '带批注的元数据类型“{metadataType}”与类型“{type}”不兼容',
        annotatedParamCountMismatch: '参数批注计数不匹配: 应为 {expected}，但收到 {received}',
        annotatedTypeArgMissing: '“Annotated”应为一个类型参数和一个或多个批注',
        annotationBytesString: '类型表达式不能使用字节字符串文本',
        annotationFormatString: '类型表达式不能使用格式字符串文本(f-string)',
        annotationNotSupported: '此语句不支持类型批注',
        annotationRawString: '类型表达式不能使用原始字符串文本',
        annotationSpansStrings: '类型表达式不能跨越多个字符串文本',
        annotationStringEscape: '类型表达式不能包含转义字符',
        argAssignment: '无法将“{argType}”类型的参数分配给“{paramType}”类型的参数',
        argAssignmentFunction: '无法将"{argType}"类型的参数分配给函数"{functionName}"中的"{paramType}"类型参数',
        argAssignmentParam: '无法将“{argType}”类型的参数分配给“{paramType}”类型的参数“{paramName}”',
        argAssignmentParamFunction: '无法将“{argType}”类型的参数分配给函数“{functionName}”中类型为“{paramType}”的参数“{paramName}”',
        argMissingForParam: '参数 {name} 缺少参数',
        argMissingForParams: '参数 {names} 缺少参数',
        argMorePositionalExpectedCount: '预期还有 {expected} 个位置参数',
        argMorePositionalExpectedOne: '应为 1 个以上位置参数',
        argPositional: '应为位置参数',
        argPositionalExpectedCount: '应为 {expected} 个位置参数',
        argPositionalExpectedOne: '应为 1 个位置参数',
        argTypePartiallyUnknown: '参数类型部分未知',
        argTypeUnknown: '参数类型未知',
        assertAlwaysTrue: '断言表达式的计算结果始终为 true',
        assertTypeArgs: '“assert_type”需要两个位置参数',
        assertTypeTypeMismatch: '“assert_type”不匹配:应为“{expected}”，但收到“{received}”',
        assignmentExprComprehension: '赋值表达式目标“{name}”不能使用与目标推导式相同的名称',
        assignmentExprContext: '赋值表达式必须在模块、函数或 lambda 中',
        assignmentExprInSubscript: '仅在 Python 3.10 和更高版本中支持下标中的赋值表达式',
        assignmentInProtocol: 'Protocol 类中的实例或类变量必须在类主体内显式声明',
        assignmentTargetExpr: '表达式不能是赋值目标',
        asyncNotInAsyncFunction: '不允许在 async 函数之外使用 "async"',
        awaitIllegal: '使用 “await” 需要 Python 3.5 或更高版本',
        awaitNotAllowed: '类型表达式不能使用 "await"',
        awaitNotInAsync: '仅允许在 async 函数内使用 "await"',
        backticksIllegal: 'Python 3.x 中不支持由反引号环绕的表达式；请改用 repr',
        baseClassCircular: '类不能从自身派生',
        baseClassFinal: '基类 "{type}" 被标记为 final 类，无法子类化',
        baseClassIncompatible: '{type} 的基类相互不兼容',
        baseClassInvalid: '类的参数必须是基类',
        baseClassMethodTypeIncompatible: '类“{classType}”的基类以不兼容的方式定义方法“{name}”',
        baseClassUnknown: '基类类型未知，隐蔽派生类的类型',
        baseClassVariableTypeIncompatible: '类“{classType}”的基类以不兼容的方式定义变量“{name}”',
        binaryOperationNotAllowed: '类型表达式中不允许使用二元运算符',
        bindTypeMismatch: '无法绑定方法“{methodName}”，因为“{type}”不能分配给参数“{paramName}”',
        breakInExceptionGroup: '"except*" 块中不允许 "break"',
        breakOutsideLoop: '“break”只能在循环中使用',
        callableExtraArgs: '"Callable"应只有两个类型参数',
        callableFirstArg: '应为参数类型列表或“...”',
        callableNotInstantiable: '无法实例化类型“{type}”',
        callableSecondArg: '返回类型应为"Callable"的第二个类型参数',
        casePatternIsIrrefutable: '仅最后一个 case 语句允许使用无可辩驳的模式',
        classAlreadySpecialized: '类型"{type}"已专用化',
        classDecoratorTypeUnknown: '非类型化类修饰器遮盖类类型;忽略修饰器',
        classDefinitionCycle: '“{name}”的类定义取决于自身',
        classGetItemClsParam: '__class_getitem__替代应采用“cls”参数',
        classMethodClsParam: '类方法应采用“cls”参数',
        classNotRuntimeSubscriptable: '类 "{name}" 的下标将生成运行时异常; 请将类型表达式括在引号中',
        classPatternBuiltInArgPositional: '类模式仅接受位置子模式',
        classPatternPositionalArgCount: '类“{type}”的位置模式太多; 应为 {expected}，但收到了 {received}',
        classPatternTypeAlias: '无法在类模式中使用“{type}”，因为它是专用类型别名',
        classPropertyDeprecated: '类属性在 Python 3.11 中已弃用，在 Python 3.13 中将不受支持',
        classTypeParametersIllegal: '类类型参数语法需要 Python 3.12 或更高版本',
        classVarFirstArgMissing: '"ClassVar"后应为类型参数',
        classVarNotAllowed: '此上下文中不允许使用“ClassVar”',
        classVarOverridesInstanceVar: '类变量"{name}"替代类"{className}"中的同名实例变量',
        classVarTooManyArgs: '“ClassVar”后应只有一个类型参数',
        classVarWithTypeVar: '“ClassVar”类型不能包含类型变量',
        clsSelfParamTypeMismatch: '参数“{name}”的类型必须是类“{classType}”的超类型',
        codeTooComplexToAnalyze: '代码太复杂，无法分析；通过重构为子例程或减少条件代码路径来降低复杂性',
        collectionAliasInstantiation: '无法实例化类型“{type}”，请改用“{alias}”',
        comparisonAlwaysFalse: '条件的计算结果始终为 False，因为类型“{leftType}”和“{rightType}”没有重叠',
        comparisonAlwaysTrue: '条件的计算结果始终为 True，因为类型“{leftType}”和“{rightType}”没有重叠',
        comprehensionInDict: '推导式不能与其他字典条目一起使用',
        comprehensionInSet: '推导式不能与其他 set 条目一起使用',
        concatenateContext: '此上下文中不允许使用“Concatenate”',
        concatenateParamSpecMissing: '“Concatenate”的最后一个类型参数必须是 ParamSpec 或 "..."',
        concatenateTypeArgsMissing: '“Concatenate” 至少需要两个类型参数',
        conditionalOperandInvalid: '类型“{type}”的条件操作数无效',
        constantRedefinition: '“{name}”是常量 (因为它是大写)且无法重新定义',
        constructorParametersMismatch: '类“{classType}”中__new__和__init__的签名不匹配',
        containmentAlwaysFalse: '表达式的计算结果始终为 False，因为类型“{leftType}”和“{rightType}”没有重叠',
        containmentAlwaysTrue: '表达式的计算结果始终为 True，因为类型“{leftType}”和“{rightType}”没有重叠',
        continueInExceptionGroup: '"except*" 块中不允许 "continue"',
        continueOutsideLoop: '“continue”只能在循环中使用',
        coroutineInConditionalExpression: '始终计算结果为 True 的条件表达式引用协同例程',
        dataClassBaseClassFrozen: '非冻结类不能从已冻结类继承',
        dataClassBaseClassNotFrozen: '冻结类不能从未冻结的类继承',
        dataClassConverterFunction: '类型“{argType}”的参数不是类型为“{fieldType}”的字段“{fieldName}”的有效转换器',
        dataClassConverterOverloads: '“{funcName}”的重载不是类型为“{fieldType}”的字段“{fieldName}”的有效转换器',
        dataClassFieldInheritedDefault: '“{fieldName}”替代同名字段，但缺少默认值',
        dataClassFieldWithDefault: '没有默认值的字段不能出现在具有默认值的字段之后',
        dataClassFieldWithPrivateName: '数据类字段不能使用专用名称',
        dataClassFieldWithoutAnnotation: '不带类型批注的数据类字段将导致运行时异常',
        dataClassPostInitParamCount: '数据类__post_init__参数计数不正确；InitVar 字段数为 {expected}',
        dataClassPostInitType: '数据类__post_init__方法参数类型不匹配 "{fieldName}"字段',
        dataClassSlotsOverwrite: '__slots__已在类中定义',
        dataClassTransformExpectedBoolLiteral: '静态计算结果为 True 或 False 的预期表达式',
        dataClassTransformFieldSpecifier: '应为类或函数的 tuple，但收到类型 "{type}"',
        dataClassTransformPositionalParam: '“dataclass_transform”的所有参数都必须是关键字参数',
        dataClassTransformUnknownArgument: 'dataclass_transform不支持参数“{name}”',
        dataProtocolInSubclassCheck: 'issubclass 调用中不允许使用数据协议(包括非方法属性)',
        declaredReturnTypePartiallyUnknown: '声明的返回类型“{returnType}”部分未知',
        declaredReturnTypeUnknown: '声明的返回类型未知',
        defaultValueContainsCall: '参数默认值表达式中不允许函数调用和可变对象',
        defaultValueNotAllowed: '“*”或“**”的参数不能有默认值',
        delTargetExpr: '无法删除表达式',
        deprecatedClass: '类"{name}"已弃用',
        deprecatedConstructor: '类"{name}"的构造函数已弃用',
        deprecatedDescriptorDeleter: '已弃用描述符“{name}”的“__delete__”方法',
        deprecatedDescriptorGetter: '已弃用描述符“{name}”的“__get__”方法',
        deprecatedDescriptorSetter: '已弃用描述符“{name}”的“__set__”方法',
        deprecatedFunction: '函数“{name}”已弃用',
        deprecatedMethod: '类“{className}”中的“{name}”方法已弃用',
        deprecatedPropertyDeleter: '已弃用 property "{name}" 的 deleter',
        deprecatedPropertyGetter: '已弃用 property "{name}" 的 getter',
        deprecatedPropertySetter: '已弃用 property "{name}" 的 setter',
        deprecatedType: '自 Python {version} 起，此类型已弃用；请改用“{replacement}”',
        dictExpandIllegalInComprehension: '推导式中不允许使用字典扩展',
        dictInAnnotation: '类型表达式中不允许使用字典表达式',
        dictKeyValuePairs: '字典条目必须包含键/值对',
        dictUnpackIsNotMapping: '字典解包运算符的预期映射',
        dunderAllSymbolNotPresent: '"{name}"已在__all__中指定，但在模块中不存在',
        duplicateArgsParam: '只允许一个 "*" 参数',
        duplicateBaseClass: '不允许重复的基类',
        duplicateCapturePatternTarget: '捕获目标“{name}”不能在同一模式中出现多次',
        duplicateCatchAll: '仅允许一个 catch-all except 子句',
        duplicateEnumMember: 'Enum 成员 "{name}" 已声明',
        duplicateGenericAndProtocolBase: '只允许一个 Generic[...] 或 Protocol[...] 基类',
        duplicateImport: '已多次导入“{importName}”',
        duplicateKeywordOnly: '只允许一个“*”分隔符',
        duplicateKwargsParam: '仅允许一个 “**” 参数',
        duplicateParam: '参数“{name}”重复',
        duplicatePositionOnly: '只允许一个“/”参数',
        duplicateStarPattern: '模式序列中只允许一个“*”模式',
        duplicateStarStarPattern: '只允许一个“**”条目',
        duplicateUnpack: 'list 中仅允许一个解包操作',
        ellipsisAfterUnpacked: '"..." 不能与未打包的 TypeVarTuple 或 tuple 一起使用',
        ellipsisContext: '不允许在此上下文中使用 "..."',
        ellipsisSecondArg: '仅允许 "..." 作为两个参数中的第二个参数',
        enumClassOverride: 'Enum 类 "{name}" 是 final 类，无法子类化',
        enumMemberDelete: '无法删除 Enum 成员 "{name}"',
        enumMemberSet: '无法分配 Enum 成员 "{name}"',
        enumMemberTypeAnnotation: 'enum 成员不允许使用类型批注',
        exceptGroupMismatch: 'Try 语句不能同时包含 "except" 和 "except*"',
        exceptGroupRequiresType: '异常组语法("except*")需要异常类型',
        exceptionGroupIncompatible: '异常组语法 ("except*") 需要 Python 3.11 或更高版本',
        exceptionGroupTypeIncorrect: 'except* 中的异常类型不能派生自 BaseGroupException',
        exceptionTypeIncorrect: '"{type}" 不是派生自 BaseException',
        exceptionTypeNotClass: '“{type}”不是有效的异常类',
        exceptionTypeNotInstantiable: '异常类型"{type}"的构造函数需要一个或多个参数',
        expectedAfterDecorator: '修饰器后应有函数或类声明',
        expectedArrow: '应为“->”，后跟返回类型批注',
        expectedAsAfterException: '异常类型后应为“as”',
        expectedAssignRightHandExpr: '应为 “=” 右侧的表达式',
        expectedBinaryRightHandExpr: '应为运算符右侧的表达式',
        expectedBoolLiteral: '应为 True 或 False',
        expectedCase: '应为 “case” 语句',
        expectedClassName: '预期的类名',
        expectedCloseBrace: '"{" 未关闭',
        expectedCloseBracket: '“[”未关闭',
        expectedCloseParen: '"(" 未关闭',
        expectedColon: '应为 ":"',
        expectedComplexNumberLiteral: '模式匹配的预期复数文本',
        expectedDecoratorExpr: 'Python 3.9 之前的修饰器不支持表达式窗体',
        expectedDecoratorName: '预期的修饰器名称',
        expectedDecoratorNewline: '修饰器末尾应有新行',
        expectedDelExpr: '"del"后应为表达式',
        expectedElse: '应为 "else"',
        expectedEquals: '应为 "="',
        expectedExceptionClass: '异常类或对象无效',
        expectedExceptionObj: '应为异常对象、异常类或 None',
        expectedExpr: '应为表达式',
        expectedFunctionAfterAsync: '"async"后面应有函数定义',
        expectedFunctionName: '“def”后应为函数名称',
        expectedIdentifier: '预期标识符',
        expectedImport: '应为 "import"',
        expectedImportAlias: '应为 “as” 后面的符号',
        expectedImportSymbols: '"import" 后应有一个或多个符号名称',
        expectedIn: '应为 "in"',
        expectedInExpr: '"in"后应为表达式',
        expectedIndentedBlock: '应为缩进块',
        expectedMemberName: '"." 后应为属性名称',
        expectedModuleName: '预期模块名称',
        expectedNameAfterAs: '"as" 后应有符号名',
        expectedNamedParameter: '关键字参数必须跟在 “*” 之后',
        expectedNewline: '需要换行符',
        expectedNewlineOrSemicolon: '语句必须用换行符或分号分隔',
        expectedOpenParen: '应为 "("',
        expectedParamName: '应为参数名称',
        expectedPatternExpr: '预期的模式表达式',
        expectedPatternSubjectExpr: '预期的模式主题表达式',
        expectedPatternValue: '应为 “a.b”形式的模式值表达式',
        expectedReturnExpr: '“return” 后应有表达式',
        expectedSliceIndex: '预期索引或切片表达式',
        expectedTypeNotString: '应为类型，但收到字符串文本',
        expectedTypeParameterName: '应为类型参数名称',
        expectedYieldExpr: 'yield 语句中的预期表达式',
        finalClassIsAbstract: '类“{type}”被标记为 final，并且必须实现所有抽象符号',
        finalContext: '不允许在此上下文中使用 "Final"',
        finalInLoop: '无法在循环中分配 "Final" 变量',
        finalMethodOverride: '方法 "{name}" 无法替代在类 "{className}" 中定义的 final 方法',
        finalNonMethod: '不能将函数“{name}”标记为 @final，因为它不是方法',
        finalReassigned: '"{name}"声明为 Final，无法重新分配',
        finalRedeclaration: '"{name}"以前声明为 Final',
        finalRedeclarationBySubclass: '无法重新声明“{name}”，因为父类“{className}”将其声明为 Final',
        finalTooManyArgs: '“Final”后应为单个类型参数',
        finalUnassigned: '"{name}" 被声明为 Final，但未分配值',
        formatStringBrace: 'f 字符串文本中不允许使用单个右大括号；使用双右大括号',
        formatStringBytes: '格式字符串文本(f 字符串)不能为二进制',
        formatStringDebuggingIllegal: 'F 字符串调试说明符“=”需要 Python 3.8 或更高版本',
        formatStringEscape: 'Python 3.12 之前 f 字符串的表达式部分中不允许使用转义序列(反斜杠)',
        formatStringExpectedConversion: '在 f 字符串中应为 "!" 之后的转换说明符',
        formatStringIllegal: '格式化字符串文本(f 字符串)需要 Python 3.6 或更高版本',
        formatStringInPattern: '模式中不允许使用格式字符串',
        formatStringNestedFormatSpecifier: '表达式嵌套在格式字符串说明符内太深',
        formatStringNestedQuote: '嵌套在 f 字符串中的字符串不能使用与 Python 3.12 之前的 f 字符串相同的引号字符',
        formatStringUnicode: '格式字符串文本(f 字符串)不能为 unicode',
        formatStringUnterminated: 'f 字符串中未终止的表达式；应为 "}"',
        functionDecoratorTypeUnknown: '非类型化函数修饰器遮盖函数类型；忽略修饰器',
        functionInConditionalExpression: '始终计算结果为 True 的条件表达式引用函数',
        functionTypeParametersIllegal: '函数类型参数语法需要 Python 3.12 或更高版本',
        futureImportLocationNotAllowed: '从__future__导入必须位于文件的开头',
        generatorAsyncReturnType: 'async 生成器函数的返回类型必须与 "AsyncGenerator[{yieldType}, Any]" 兼容',
        generatorNotParenthesized: '如果不是唯一参数，生成器表达式必须带圆括号',
        generatorSyncReturnType: '生成器函数的返回类型必须与 "Generator[{yieldType}, Any, Any]"兼容',
        genericBaseClassNotAllowed: '“Generic” 基类不能与类型参数语法一起使用',
        genericClassAssigned: '无法分配泛型类类型',
        genericClassDeleted: '无法删除泛型类类型',
        genericInstanceVariableAccess: '通过类访问泛型实例变量是不明确的',
        genericNotAllowed: '"Generic" 在此上下文中无效',
        genericTypeAliasBoundTypeVar: '类中的泛型类型别名不能使用绑定类型变量 {names}',
        genericTypeArgMissing: '“Generic”至少需要一个类型参数',
        genericTypeArgTypeVar: '“Generic”的类型参数必须是类型变量',
        genericTypeArgUnique: '“Generic”的类型参数必须是唯一',
        globalReassignment: '"{name}" 已在 global 声明之前分配',
        globalRedefinition: '"{name}" 已声明为 global',
        implicitStringConcat: '不允许隐式字符串串联',
        importCycleDetected: '在导入链中检测到的周期数',
        importDepthExceeded: '导入链深度超过 {depth}',
        importResolveFailure: '无法解析导入“{importName}”',
        importSourceResolveFailure: '无法从源解析导入“{importName}”',
        importSymbolUnknown: '“{name}”是未知的导入符号',
        incompatibleMethodOverride: '方法“{name}”以不兼容的方式替代类“{className}”',
        inconsistentIndent: '取消缩进量与以前的缩进不匹配',
        inconsistentTabs: '缩进中制表符和空格的使用不一致',
        initMethodSelfParamTypeVar: '"__init__" 方法 “self” 参数的类型注释不能包含类范围的类型变量',
        initMustReturnNone: '“__init__”的返回类型必须为 None',
        initSubclassCallFailed: '__init_subclass__ 方法的关键字参数不正确',
        initSubclassClsParam: '__init_subclass__替代应采用“cls”参数',
        initVarNotAllowed: '此上下文中不允许使用“InitVar”',
        instanceMethodSelfParam: '实例方法应采用 “self” 参数',
        instanceVarOverridesClassVar: '实例变量"{name}"替代类"{className}"中的同名类变量',
        instantiateAbstract: '无法实例化抽象类“{type}”',
        instantiateProtocol: '无法实例化 Protocol 类 "{type}"',
        internalBindError: '绑定文件“{file}”时发生内部错误:{message}',
        internalParseError: '分析文件“{file}”时发生内部错误:{message}',
        internalTypeCheckingError: '类型检查文件“{file}”时发生内部错误:{message}',
        invalidIdentifierChar: '标识符中的字符无效',
        invalidStubStatement: '语句在类型 stub 文件中无意义',
        invalidTokenChars: '令牌中的字符"{text}"无效',
        isInstanceInvalidType: '"isinstance" 的第二个参数必须是类或类的 tuple',
        isSubclassInvalidType: '"issubclass" 的第二个参数必须是类或类的 tuple',
        keyValueInSet: '不允许在 set 内使用键/值对',
        keywordArgInTypeArgument: '关键字参数不能在类型参数列表中使用',
        keywordArgShortcutIllegal: '关键字参数快捷方式需要 Python 3.14 或更高版本',
        keywordOnlyAfterArgs: '“*”参数后不允许使用仅限关键字的参数分隔符',
        keywordParameterMissing: '一个或多个关键字参数必须遵循 "*"参数',
        keywordSubscriptIllegal: '不支持下标中的关键字参数',
        lambdaReturnTypePartiallyUnknown: 'lambda 的返回类型“{returnType}”部分未知',
        lambdaReturnTypeUnknown: 'lambda 的返回类型未知',
        listAssignmentMismatch: '无法将 "{type}" 类型的表达式分配给目标列表',
        listInAnnotation: '类型表达式中不允许使用 List 表达式',
        literalEmptyArgs: '“Literal”后应有一个或多个类型参数',
        literalNamedUnicodeEscape: '"Literal" 字符串批注不支持已命名的 unicode 转义序列',
        literalNotAllowed: '如果没有类型参数，则 "Literal" 不能用于此上下文',
        literalNotCallable: '无法实例化 Literal 类型',
        literalUnsupportedType: '"Literal" 的类型参数必须是 None、文本值(int、bool、str 或 bytes)或 enum 值',
        matchIncompatible: 'Match 语句需要 Python 3.10 或更高版本',
        matchIsNotExhaustive: 'match 语句中的事例不会彻底处理所有值',
        maxParseDepthExceeded: '超出最大分析深度;将表达式分解为较小的子表达式',
        memberAccess: '无法访问类“{type}”的属性“{name}”',
        memberDelete: '无法删除类“{type}”的属性“{name}”',
        memberSet: '无法为类“{type}”的属性“{name}”赋值。',
        metaclassConflict: '派生类的元类必须是其所有基类的元类的子类',
        metaclassDuplicate: '只能提供一个元类',
        metaclassIsGeneric: '元类不能是泛型',
        methodNotDefined: '未定义“{name}”方法',
        methodNotDefinedOnType: '未在类型"{type}"上定义"{name}"方法',
        methodOrdering: '无法创建一致的方法排序',
        methodOverridden: '“{name}”在类型“{type}”不兼容的类“{className}”中替代同名的方法',
        methodReturnsNonObject: '“{name}”方法不返回对象',
        missingSuperCall: '方法“{methodName}”在父类中不调用同名方法',
        mixingBytesAndStr: 'Bytes 和 str 值无法串联',
        moduleAsType: '模块不能用作类型',
        moduleNotCallable: '模块不可调用',
        moduleUnknownMember: '“{memberName}”不是模块“{moduleName}”的已知属性',
        namedExceptAfterCatchAll: '命名的 except 子句不能出现在 catch-all except 子句后',
        namedParamAfterParamSpecArgs: '关键字参数“{name}”不能出现在 ParamSpec args 参数之后的签名中',
        namedTupleEmptyName: '命名 tuple 中的名称不能为空',
        namedTupleEntryRedeclared: '无法替代 "{name}"，因为父类 "{className}" 是命名的 tuple',
        namedTupleFirstArg: '应将命名的 tuple 类名作为第一个参数',
        namedTupleMultipleInheritance: '不支持使用 NamedTuple 进行多个继承',
        namedTupleNameKeyword: '字段名称不能是关键字',
        namedTupleNameType: '应为指定条目名称和类型的双条目 tuple',
        namedTupleNameUnique: '命名的 tuple 中的名称必须唯一',
        namedTupleNoTypes: '“namedtuple”不提供元组条目的类型；请改用“NamedTuple”',
        namedTupleSecondArg: '应将命名的 tuple 条目 list 作为第二个参数',
        newClsParam: '__new__替代应采用“cls”参数',
        newTypeAnyOrUnknown: 'NewType 的第二个参数必须是已知类，而不是 Any 或 Unknown',
        newTypeBadName: 'NewType 的第一个参数必须是字符串文本',
        newTypeLiteral: 'NewType 不能与 Literal 类型一起使用',
        newTypeNameMismatch: '必须将 NewType 分配给同名变量',
        newTypeNotAClass: '应为 NewType 的第二个参数的类',
        newTypeParamCount: 'NewType 需要两个位置参数',
        newTypeProtocolClass: 'NewType 不能与结构类型(Protocol 或 TypedDict 类)一起使用',
        noOverload: '“{name}”的重载与提供的参数不匹配',
        noReturnContainsReturn: '声明的 return 类型为 "NoReturn" 的函数不能包含 return 语句',
        noReturnContainsYield: '声明的返回类型为 “NoReturn” 的函数不能包含 yield 语句',
        noReturnReturnsNone: '所声明的返回类型为 "NoReturn" 的函数无法返回 "None"',
        nonDefaultAfterDefault: '非默认参数遵循默认参数',
        nonLocalInModule: '模块级不允许使用 nonlocal 声明',
        nonLocalNoBinding: '找不到 nonlocal "{name}" 的绑定',
        nonLocalReassignment: '"{name}" 已在 nonlocal 声明之前分配',
        nonLocalRedefinition: '"{name}" 已声明为 nonlocal',
        noneNotCallable: '无法调用类型为“None”的对象',
        noneNotIterable: '类型为“None”的对象不能用作可迭代值',
        noneNotSubscriptable: '类型为“None”的对象不可下标',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: '“None”不支持运算符"{operator}"',
        noneUnknownMember: '“{name}”不是 "None" 的已知属性',
        notRequiredArgCount: '“NotRequired” 之后应为单个类型参数',
        notRequiredNotInTypedDict: '此上下文中不允许使用“NotRequired”',
        objectNotCallable: '类型为“{type}”的对象不可调用',
        obscuredClassDeclaration: '类声明"{name}"被同名的声明遮蔽',
        obscuredFunctionDeclaration: '函数声明“{name}”被同名声明遮盖',
        obscuredMethodDeclaration: '方法声明“{name}”被同名声明遮盖',
        obscuredParameterDeclaration: '参数声明“{name}”被同名声明遮盖',
        obscuredTypeAliasDeclaration: '类型别名声明“{name}”被同名声明遮盖',
        obscuredVariableDeclaration: '声明“{name}”被同名声明遮盖',
        operatorLessOrGreaterDeprecated: 'Python 3 不支持运算符“<>”；请改用 "!="',
        optionalExtraArgs: '"Optional"后面应有一个类型参数',
        orPatternIrrefutable: '无可辩驳的模式仅允许作为 "or"模式中的最后一个子模式',
        orPatternMissingName: '“or”模式中的所有子节点必须以相同的名称为目标',
        overlappingKeywordArgs: '类型化字典与以下关键字参数重叠: {names}',
        overlappingOverload: '永远不会使用“{name}”的重载 {obscured}，因为其参数与重载 {obscuredBy} 重叠',
        overloadAbstractImplMismatch: '重载必须与实现的抽象状态匹配',
        overloadAbstractMismatch: '重载必须全是抽象重载，或者全都不是抽象重载',
        overloadClassMethodInconsistent: '“{name}”的重载使用 @classmethod 的方式不一致',
        overloadFinalInconsistencyImpl: '“{name}”的重载被标记为 @final，但实施未被标记',
        overloadFinalInconsistencyNoImpl: '“{name}”的重载 {index} 被标记为 @final，但重载 1 未被标记',
        overloadImplementationMismatch: '重载实现与重载 {index} 的签名不一致',
        overloadReturnTypeMismatch: '“{name}”的重载 {prevIndex} 与重载 {newIndex} 重叠，并返回不兼容的类型',
        overloadStaticMethodInconsistent: '“{name}”的重载使用 @staticmethod 的方式不一致',
        overloadWithoutImplementation: '"{name}" 被标记为 overload，但未提供实现',
        overriddenMethodNotFound: '方法 "{name}" 被标记为 override，但不存在同名的基方法',
        overrideDecoratorMissing: '方法 "{name}" 未被标记为替代，但 override 类 "{className}" 中的方法',
        paramAfterKwargsParam: '参数不能跟随“**”参数',
        paramAlreadyAssigned: '已分配参数“{name}”',
        paramAnnotationMissing: '参数“{name}”缺少类型批注',
        paramAssignmentMismatch: '无法将"{sourceType}"类型的表达式分配给"{paramType}"类型的参数',
        paramNameMissing: '没有名为“{name}”的参数',
        paramSpecArgsKwargsDuplicate: '已提供 ParamSpec "{type}" 的参数',
        paramSpecArgsKwargsUsage: 'ParamSpec 的 "args" 和 "kwargs" 属性必须同时出现在函数签名中',
        paramSpecArgsMissing: '缺少 ParamSpec“{type}”的参数',
        paramSpecArgsUsage: 'ParamSpec 的 "args" 属性仅在与 *args 参数一起使用时有效',
        paramSpecAssignedName: '必须将 ParamSpec 分配给名为“{name}”的变量',
        paramSpecContext: '此上下文中不允许使用 ParamSpec',
        paramSpecDefaultNotTuple: 'ParamSpec 的默认值应为省略号、tuple 表达式或 ParamSpec',
        paramSpecFirstArg: 'ParamSpec 作为第一个参数的预期名称',
        paramSpecKwargsUsage: 'ParamSpec 的 "kwargs" 属性仅在与 **kwargs 参数一起使用时有效',
        paramSpecNotUsedByOuterScope: 'ParamSpec“{name}”在此上下文中没有意义',
        paramSpecUnknownArg: 'ParamSpec 不支持多个参数',
        paramSpecUnknownMember: '“{name}”不是 ParamSpec 的已知属性',
        paramSpecUnknownParam: '“{name}”是 ParamSpec 的未知参数',
        paramTypeCovariant: '不能在参数类型中使用协变类型变量',
        paramTypePartiallyUnknown: '参数"{paramName}"的类型部分未知',
        paramTypeUnknown: '参数“{paramName}”的类型未知',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: '主题类型“{type}”的模式永远不会匹配',
        positionArgAfterNamedArg: '位置参数不能出现在关键字参数之后',
        positionOnlyAfterArgs: '“*”参数后不允许使用仅位置参数分隔符',
        positionOnlyAfterKeywordOnly: '“/”参数必须出现在“*”参数之前',
        positionOnlyAfterNon: '非仅位置参数后面不允许仅位置参数',
        positionOnlyFirstParam: '不允许将仅位置参数分隔符用作第一个参数',
        positionOnlyIncompatible: '仅位置参数分隔符需要 Python 3.8 或更高版本',
        privateImportFromPyTypedModule: '未从模块“{module}”导出“{name}”',
        privateUsedOutsideOfClass: '"{name}"是专用的，在声明它的类之外使用',
        privateUsedOutsideOfModule: '“{name}”是专用的，在声明它的模块外部使用',
        propertyOverridden: '"{name}" 错误地替代了类 "{className}" 中同名的 property',
        propertyStaticMethod: 'property getter、setter 或 deleter 不允许使用静态方法',
        protectedUsedOutsideOfClass: '“{name}”在声明它的类之外受到保护并被使用',
        protocolBaseClass: 'Protocol 类 "{classType}" 不能派生自非 Protocol 类 "{baseType}"',
        protocolBaseClassWithTypeArgs: '使用类型参数语法时，Protocol 类不允许使用类型参数',
        protocolIllegal: '使用 "Protocol" 需要 Python 3.7 或更高版本',
        protocolNotAllowed: '"Protocol" 不能用于此上下文',
        protocolTypeArgMustBeTypeParam: '"Protocol" 的类型参数必须是类型参数',
        protocolUnsafeOverlap: '类与“{name}”不安全地重叠，并且可能在运行时生成匹配项',
        protocolVarianceContravariant: '泛型 Protocol "{class}" 中使用的类型变量 "{variable}" 应为反变量',
        protocolVarianceCovariant: '泛型 Protocol "{class}" 中使用的类型变量 "{variable}" 应为共变量',
        protocolVarianceInvariant: '泛型 Protocol "{class}" 中使用的类型变量 "{variable}" 应为固定变量',
        pyrightCommentInvalidDiagnosticBoolValue: 'Pyright 注释指令后面必须跟有“=”和 true 或 false 值',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Pyright 注释指令后面必须跟有“=”，并且值为 true、false、error、warning、information 或 none',
        pyrightCommentMissingDirective: 'Pyright 注释后面必须是指令(basic 或 strict)或诊断规则',
        pyrightCommentNotOnOwnLine: '用于控制文件级设置的 Pyright 注释必须显示在其自己的行上',
        pyrightCommentUnknownDiagnosticRule: '“{rule}”是 pyright 注释的未知诊断规则',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}"是 pyright 注释的无效值；应为 true、false、error、warning、information 或 none',
        pyrightCommentUnknownDirective: '"{directive}"是 pyright 注释的未知指令；应为 “strict” 或 “basic”',
        readOnlyArgCount: '“ReadOnly”后应为单个类型参数',
        readOnlyNotInTypedDict: '此上下文中不允许使用“ReadOnly”',
        recursiveDefinition: '无法确定“{name}”的类型，因为它引用其自身',
        relativeImportNotAllowed: '相对导入不能与“import .a”窗体一起使用；改用 "from . import a"',
        requiredArgCount: '"Required"后应为单个类型参数',
        requiredNotInTypedDict: '此上下文中不允许使用"Required"',
        returnInAsyncGenerator: 'async 生成器中不允许使用具有值的 return 语句',
        returnInExceptionGroup: '"except*" 块中不允许 "return"',
        returnMissing: '所声明的返回类型为“{returnType}”的函数必须在所有代码路径上返回值',
        returnOutsideFunction: '“return”只能在函数中使用',
        returnTypeContravariant: '逆变类型变量不能用于返回类型',
        returnTypeMismatch: '类型“{exprType}”不可分配给返回类型“{returnType}”',
        returnTypePartiallyUnknown: '返回类型“{returnType}”部分未知',
        returnTypeUnknown: '返回类型未知',
        revealLocalsArgs: '“reveal_locals”调用应没有参数',
        revealLocalsNone: '此范围内没有 locals 变量',
        revealTypeArgs: '“reveal_type”调用应为单个位置参数',
        revealTypeExpectedTextArg: '函数“reveal_type”的“expected_text”参数必须是 str 文本值',
        revealTypeExpectedTextMismatch: '类型文本不匹配；应为"{expected}"但收到"{received}"',
        revealTypeExpectedTypeMismatch: '类型不匹配;应为“{expected}”，但收到“{received}”',
        selfTypeContext: '“Self”在此上下文中无效',
        selfTypeMetaclass: '“Self”不能在元类(“type”的子类)中使用',
        selfTypeWithTypedSelfOrCls: '“Self”不能在具有“self”或“cls”参数的函数中使用，该参数的类型批注不是“Self”',
        setterGetterTypeMismatch: 'Property setter 值类型不可分配给 getter 返回类型',
        singleOverload: '“{name}”被标记为重载，但缺少其他重载',
        slotsAttributeError: '未在__slots__中指定“{name}”',
        slotsClassVarConflict: '"{name}"与__slots__中声明的实例变量冲突',
        starPatternInAsPattern: '星形模式不能与“as”目标一起使用',
        starPatternInOrPattern: '在其他模式中，星形图案不能为 ORed',
        starStarWildcardNotAllowed: '** 不能与通配符“_”一起使用',
        staticClsSelfParam: '静态方法不应采用“self”或“cls”参数',
        stdlibModuleOverridden: '"{path}"正在替代 stdlib 模块"{name}"',
        stringNonAsciiBytes: '不允许使用非 ASCII 字符(以字节为单位)字符串文本',
        stringNotSubscriptable: '字符串表达式不能在类型表达式中使用下标; 请将整个表达式括在引号中',
        stringUnsupportedEscape: '字符串文本中不受支持的转义序列',
        stringUnterminated: '字符串文本未终止',
        stubFileMissing: '找不到 "{importName}" 的 Stub 文件',
        stubUsesGetAttr: '类型 stub 文件不完整; "__getattr__" 遮盖了模块的类型错误',
        sublistParamsIncompatible: 'Python 3.x 不支持 Sublist 参数',
        superCallArgCount: '“super” 调用应不超过两个参数',
        superCallFirstArg: '应将类类型作为“super”调用的第一个参数，但收到“{type}”',
        superCallSecondArg: '“super”调用的第二个参数必须是派生自“{type}”的对象或类',
        superCallZeroArgForm: '"super" 调用的零参数形式仅在方法中有效',
        superCallZeroArgFormStaticMethod: '“super”调用的零参数形式在静态方法中无效',
        symbolIsPossiblyUnbound: '“{name}”可能未绑定',
        symbolIsUnbound: '“{name}”未绑定',
        symbolIsUndefined: '未定义“{name}”',
        symbolOverridden: '“{name}”替代类“{className}”中的同名符号',
        ternaryNotAllowed: '类型表达式中不允许使用三元表达式',
        totalOrderingMissingMethod: '类必须定义“__lt__”、“__le__”、“__gt__”或“__ge__”之一才能使用total_ordering',
        trailingCommaInFromImport: '不允许使用尾随逗号，没有括号',
        tryWithoutExcept: 'Try 语句必须至少有一个 except 或 finally 子句',
        tupleAssignmentMismatch: '无法将类型为 "{type}" 的表达式分配给目标 tuple',
        tupleInAnnotation: '类型表达式中不允许使用 tuple 表达式',
        tupleIndexOutOfRange: '类型 {type} 的索引 {index} 超出范围',
        typeAliasIllegalExpressionForm: '类型别名定义的表达式形式无效',
        typeAliasIsRecursiveDirect: '类型别名“{name}”不能在其定义中使用自身',
        typeAliasNotInModuleOrClass: 'TypeAlias 只能在模块或类范围内定义',
        typeAliasRedeclared: '“{name}”声明为 TypeAlias，只能分配一次',
        typeAliasStatementBadScope: 'type 语句只能在模块或类范围内使用',
        typeAliasStatementIllegal: '类型别名语句需要 Python 3.12 或更高版本',
        typeAliasTypeBaseClass: '"type" 语句中定义的类型别名不能用作基类',
        typeAliasTypeMustBeAssigned: '必须将 TypeAliasType 分配给与类型别名同名的变量',
        typeAliasTypeNameArg: 'TypeAliasType 的第一个参数必须是表示类型别名名称的字符串文本',
        typeAliasTypeNameMismatch: '类型别名的名称必须与分配到的变量的名称匹配',
        typeAliasTypeParamInvalid: '类型参数列表必须是仅包含 TypeVar、TypeVarTuple 或 ParamSpec 的 tuple',
        typeAnnotationCall: '类型表达式中不允许使用调用表达式',
        typeAnnotationVariable: '类型表达式中不允许使用变量',
        typeAnnotationWithCallable: '“type”的类型参数必须为类; 不支持可调用项',
        typeArgListExpected: '应为 ParamSpec、省略号或类型 list',
        typeArgListNotAllowed: '此类型参数不允许使用 list 表达式',
        typeArgsExpectingNone: '类“{name}”不应有类型参数',
        typeArgsMismatchOne: '应为一个类型参数，但收到 {received}',
        typeArgsMissingForAlias: '泛型类型别名“{name}”的预期类型参数',
        typeArgsMissingForClass: '泛型类“{name}”的预期类型参数',
        typeArgsTooFew: '为“{name}”提供的类型参数太少；应为 {expected}，但收到 {received}',
        typeArgsTooMany: '为“{name}”提供的类型参数太多；应为 {expected}，但收到 {received}',
        typeAssignmentMismatch: '类型“{sourceType}”不可分配给声明的类型“{destType}”',
        typeAssignmentMismatchWildcard: '导入符号“{name}”的类型为“{sourceType}”，该类型不可分配给声明的类型“{destType}”',
        typeCallNotAllowed: '不应在类型表达式中使用 type() 调用',
        typeCheckOnly: '“{name}”标记为 @type_check_only，并且只能在类型注释中使用',
        typeCommentDeprecated: '已弃用 type 注释; 请改用 type 批注',
        typeExpectedClass: '应为类，但收到“{type}”',
        typeFormArgs: '"TypeForm" 接受单个位置参数',
        typeGuardArgCount: '“TypeGuard”或“TypeIs”后应为单个类型参数',
        typeGuardParamCount: '用户定义的类型防护函数和方法必须至少有一个输入参数',
        typeIsReturnType: 'TypeIs 的返回类型(“{returnType}”)与值参数类型(“{type}”)不一致',
        typeNotAwaitable: '"{type}" 并非 awaitable',
        typeNotIntantiable: '无法实例化"{type}"',
        typeNotIterable: '“{type}”不可迭代',
        typeNotSpecializable: '无法专用化类型“{type}”',
        typeNotSubscriptable: '类型为“{type}”的对象不可下标',
        typeNotSupportBinaryOperator: '类型“{leftType}”和“{rightType}”不支持运算符“{operator}”',
        typeNotSupportBinaryOperatorBidirectional: '预期类型为“{expectedType}”时，类型“{leftType}”和“{rightType}”不支持运算符“{operator}”',
        typeNotSupportUnaryOperator: '类型“{type}”不支持运算符“{operator}”',
        typeNotSupportUnaryOperatorBidirectional: '预期类型为 "{expectedType}"时，类型"{type}"不支持运算符"{operator}"',
        typeNotUsableWith: '"{type}"类型的对象不能与 “with” 一起使用，因为它未实现{method}',
        typeParameterBoundNotAllowed: '绑定或约束不能与 variadic 类型参数或 ParamSpec 一起使用',
        typeParameterConstraintTuple: '类型参数约束必须是两个或更多类型的元组',
        typeParameterExistingTypeParameter: '类型参数"{name}"已在使用中',
        typeParameterNotDeclared: '类型参数“{name}”未包含在“{container}”的类型参数列表中',
        typeParametersMissing: '必须至少指定一个类型参数',
        typePartiallyUnknown: '“{name}”的类型部分未知',
        typeUnknown: '"{name}"类型未知',
        typeVarAssignedName: '必须将 TypeVar 分配给名为“{name}”的变量',
        typeVarAssignmentMismatch: '无法将类型"{type}"分配给类型变量"{name}"',
        typeVarBoundAndConstrained: 'TypeVar 不能同时绑定和约束',
        typeVarBoundGeneric: 'TypeVar 绑定类型不能是泛型',
        typeVarConstraintGeneric: 'TypeVar 约束类型不能是泛型',
        typeVarDefaultBoundMismatch: 'TypeVar 默认类型必须是绑定类型的子类型',
        typeVarDefaultConstraintMismatch: 'TypeVar 默认类型必须是受约束类型之一',
        typeVarDefaultIllegal: '类型变量默认类型需要 Python 3.13 或更高版本',
        typeVarDefaultInvalidTypeVar: '类型参数“{name}”的默认类型是指超出范围的一个或多个类型变量',
        typeVarFirstArg: 'TypeVar 作为第一个参数的预期名称',
        typeVarInvalidForMemberVariable: '属性类型不能使用作用域为本地方法的类型变量"{name}"',
        typeVarNoMember: 'TypeVar“{type}”没有属性“{name}”',
        typeVarNotSubscriptable: 'TypeVar“{type}”不可下标',
        typeVarNotUsedByOuterScope: '类型变量“{name}”在此上下文中没有意义',
        typeVarPossiblyUnsolvable: '如果调用方没有为参数提供参数"{param}"，则类型变量"{name}"可能无法解析',
        typeVarSingleConstraint: 'TypeVar 必须至少有两种约束类型',
        typeVarTupleConstraints: 'TypeVarTuple 不能有值约束',
        typeVarTupleContext: '此上下文中不允许使用 TypeVarTuple',
        typeVarTupleDefaultNotUnpacked: 'TypeVarTuple 默认类型必须是未打包的 tuple 或 TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'TypeVarTuple 值需要解包运算符',
        typeVarTupleUnknownParam: '“{name}”是 TypeVarTuple 的未知参数',
        typeVarUnknownParam: '"{name}" 是 TypeVar 的未知参数',
        typeVarUsedByOuterScope: 'TypeVar“{name}”已被外部作用域使用',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" 在泛型函数签名中仅显示一次',
        typeVarVariance: 'TypeVar 不能同时为协变和逆变',
        typeVarWithDefaultFollowsVariadic: 'TypeVar“{typeVarName}”具有默认值，并且不能遵循 TypeVarTuple“{variadicName}”',
        typeVarWithoutDefault: '“{name}”不能出现在类型参数列表的“{other}”后面，因为它没有默认类型',
        typeVarsNotInGenericOrProtocol: 'Generic[] 或 Protocol[] 必须包括所有类型变量',
        typedDictAccess: '无法存取 TypedDict 中的项',
        typedDictAssignedName: '必须将 TypedDict 分配给名为“{name}”的变量',
        typedDictBadVar: 'TypedDict 类只能包含类型批注',
        typedDictBaseClass: 'TypedDict 类的所有基类也必须是 TypedDict 类',
        typedDictBoolParam: '预期“{name}”参数的值为 True 或 False',
        typedDictClosedExtras: '基类 "{name}" 是 closed TypedDict; 额外的项必须是类型 "{type}"',
        typedDictClosedNoExtras: '基类 "{name}" 是 closed TypedDict; 不允许使用额外的项',
        typedDictDelete: '无法删除 TypedDict 中的项',
        typedDictEmptyName: 'TypedDict 中的名称不能为空',
        typedDictEntryName: '字典条目名称的预期字符串文本',
        typedDictEntryUnique: '字典中的名称必须唯一',
        typedDictExtraArgs: '不支持额外的 TypedDict 参数',
        typedDictExtraItemsClosed: '如果 TypedDict 支持额外项目，则无法将其 closed',
        typedDictFieldNotRequiredRedefinition: '无法将 TypedDict 项“{name}”重新定义为 NotRequired',
        typedDictFieldReadOnlyRedefinition: '无法将 TypedDict 项“{name}”重新定义为 ReadOnly',
        typedDictFieldRequiredRedefinition: '无法将 TypedDict 项“{name}”重新定义为 Required',
        typedDictFirstArg: '应将 TypedDict 类名作为第一个参数',
        typedDictInClassPattern: '类模式中不允许使用 TypedDict 类',
        typedDictInitsubclassParameter: 'TypedDict 不支持 __init_subclass__ parameter“{name}”',
        typedDictNotAllowed: '"TypedDict" 不能用于此上下文',
        typedDictSecondArgDict: '预期的 dict 或关键字参数作为第二个参数',
        typedDictSecondArgDictEntry: '应为简单字典条目',
        typedDictSet: '无法在 TypedDict 中分配项',
        unaccessedClass: '未存取类“{name}”',
        unaccessedFunction: '无法存取函数"{name}"',
        unaccessedImport: '未存取导入“{name}”',
        unaccessedSymbol: '未存取“{name}”',
        unaccessedVariable: '无法存取变量“{name}”',
        unannotatedFunctionSkipped: '已跳过对函数“{name}”的分析，因为它未被批注',
        unaryOperationNotAllowed: '类型表达式中不允许使用一元运算符',
        unexpectedAsyncToken: '“def”、“with” 或 “for” 应跟随 “async”',
        unexpectedExprToken: '表达式末尾出现意外标记',
        unexpectedIndent: '意外缩进',
        unexpectedUnindent: '不应取消缩进',
        unhashableDictKey: '字典密钥必须可哈希',
        unhashableSetEntry: 'Set 条目必须是可哈希的',
        uninitializedAbstractVariables: '抽象基类中定义的变量未在 final 类 "{classType}" 中初始化',
        uninitializedInstanceVariable: '未在类体或__init__方法中初始化实例变量“{name}”',
        unionForwardReferenceNotAllowed: 'Union 语法不能与字符串操作数一起使用; 请在整个表达式周围使用引号',
        unionSyntaxIllegal: '联合的替代语法需要 Python 3.10 或更高版本',
        unionTypeArgCount: 'Union 需要两个或更多类型参数',
        unionUnpackedTuple: 'Union 不能包含未打包的 tuple',
        unionUnpackedTypeVarTuple: 'Union 不能包含未打包的 TypeVarTuple',
        unnecessaryCast: '不必要的 "cast" 调用；类型已为“{type}”',
        unnecessaryIsInstanceAlways: '不必要的 isinstance 调用；“{testType}”始终是“{classType}”的实例',
        unnecessaryIsInstanceNever: '不必要的 isinstance 调用；“{testType}”始终不是“{classType}”的实例',
        unnecessaryIsSubclassAlways: '不必要的 issubclass 调用；“{testType}”始终是“{classType}”的子类',
        unnecessaryIsSubclassNever: '不必要的 issubclass 调用；“{testType}”始终不是“{classType}”的子类',
        unnecessaryPyrightIgnore: '不必要的 "# pyright: ignore" 注释',
        unnecessaryPyrightIgnoreRule: '不必要的 "# pyright: ignore"规则: "{name}"',
        unnecessaryTypeIgnore: '不必要的 "# type: ignore" 注释',
        unpackArgCount: '"Unpack"后应为单个类型参数',
        unpackExpectedTypeVarTuple: 'Unpack 预期接收 TypeVarTuple 或 tuple 作为类型参数',
        unpackExpectedTypedDict: 'Unpack 预期接收 TypedDict 类型参数',
        unpackIllegalInComprehension: '在推导式中不允许使用解包操作',
        unpackInAnnotation: '类型表达式中不允许使用解包运算符',
        unpackInDict: '字典中不允许解压缩操作',
        unpackInSet: 'set 内不允许使用解包运算符',
        unpackNotAllowed: '此上下文中不允许 Unpack',
        unpackOperatorNotAllowed: '此上下文中不允许解压缩操作',
        unpackTuplesIllegal: 'Python 3.8 之前的元组中不允许解包操作',
        unpackedArgInTypeArgument: '未打包的参数不能用于此上下文',
        unpackedArgWithVariadicParam: '未打包的参数不能用于 TypeVarTuple 参数',
        unpackedDictArgumentNotMapping: '** 后面的参数表达式必须是具有“str”键类型的映射',
        unpackedDictSubscriptIllegal: '不允许在下标中使用字典解包运算符',
        unpackedSubscriptIllegal: '下标中的解包运算符需要 Python 3.11 或更高版本',
        unpackedTypeVarTupleExpected: '应为未打包的 TypeVarTuple；使用 Unpack[{name1}] 或 *{name2}',
        unpackedTypedDictArgument: '无法将解压缩的 TypedDict 参数与参数匹配',
        unreachableCode: '代码无法访问',
        unreachableCodeType: '类型分析指示代码不可访问',
        unreachableExcept: '无法访问 Except 子句，因为已处理异常',
        unsupportedDunderAllOperation: '不支持对“__all__”执行操作，因此导出的符号列表可能不正确',
        unusedCallResult: '调用表达式的结果类型为 "{type}" 且未使用；如果这是有意为之，则分配给变量 “_”',
        unusedCoroutine: '未使用 async 函数调用的结果; 请使用 "await" 或将结果分配给变量',
        unusedExpression: '表达式值未使用',
        varAnnotationIllegal: '变量的 Type 批注需要 Python 3.6 或更高版本; 请使用 type 注释以与以前的版本兼容',
        variableFinalOverride: '变量"{name}"被标记为 Final，并替代类"{className}"中同名的非 Final 变量',
        variadicTypeArgsTooMany: '类型参数列表最多可以有一个未打包的 TypeVarTuple 或 tuple',
        variadicTypeParamTooManyAlias: '类型别名最多可以有一个 TypeVarTuple 类型参数，但收到多个 ({names})',
        variadicTypeParamTooManyClass: '泛型类最多可以有一个 TypeVarTuple 类型参数，但收到多个 ({names})',
        walrusIllegal: '运算符 ":=" 需要 Python 3.8 或更高版本',
        walrusNotAllowed: '此上下文中不允许使用运算符 ":="，且不带括号',
        wildcardInFunction: '类或函数中不允许使用通配符 import',
        wildcardLibraryImport: '不允许从库中 import 通配符',
        wildcardPatternTypePartiallyUnknown: '通配符模式捕获的类型部分未知',
        wildcardPatternTypeUnknown: '通配符模式捕获的类型未知',
        yieldFromIllegal: '使用“yield from”需要 Python 3.3 或更高版本',
        yieldFromOutsideAsync: 'async 函数中不允许使用 "yield from"',
        yieldOutsideFunction: '不允许在函数或 lambda 之外使用“yield”',
        yieldWithinComprehension: '允许在推导式中使用 "yield"',
        zeroCaseStatementsFound: 'Match 语句必须至少包含一个 case 语句',
        zeroLengthTupleNotAllowed: '此上下文中不允许使用零长度 tuple'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '"Annotated" 特殊形式不能与实例和类检查一起使用',
        argParam: '参数对应于参数“{paramName}”',
        argParamFunction: '参数对应于函数“{functionName}”中的参数“{paramName}”',
        argsParamMissing: '参数“*{paramName}”没有相应的参数',
        argsPositionOnly: '仅位置参数不匹配；应为 {expected}，但收到 {received}',
        argumentType: '参数类型为“{type}”',
        argumentTypes: '参数类型:({types})',
        assignToNone: '类型不可分配给“None”',
        asyncHelp: '是否表示“async with”?',
        baseClassIncompatible: '基类“{baseClass}”与类型“{type}”不兼容',
        baseClassIncompatibleSubclass: '基类“{baseClass}”派生自与类型“{type}”不兼容的“{subclass}”',
        baseClassOverriddenType: '基类"{baseClass}"提供被替代的类型"{type}"',
        baseClassOverridesType: '基类“{baseClass}”替代类型{type}”',
        bytesTypePromotions: '将 disableBytesTypePromotions 设置为 false，以启用“bytearray”和“memoryview”的类型提升行为',
        conditionalRequiresBool: '类型“{operandType}”的方法__bool__返回类型“{boolReturnType}”而不是“bool”',
        dataClassFieldLocation: '字段声明',
        dataClassFrozen: '"{name}"已冻结',
        dataProtocolUnsupported: '“{name}”是数据协议',
        descriptorAccessBindingFailed: '无法绑定描述符类“{className}”的方法“{name}”',
        descriptorAccessCallFailed: '无法为描述符类“{className}”调用方法“{name}”',
        finalMethod: 'Final 方法',
        functionParamDefaultMissing: '参数“{name}”缺少默认参数',
        functionParamName: '参数名称不匹配: "{destName}" versus "{srcName}"',
        functionParamPositionOnly: '仅位置参数不匹配; 参数“{name}”并非仅限位置',
        functionReturnTypeMismatch: '函数返回类型"{sourceType}"与类型"{destType}"不兼容',
        functionTooFewParams: '函数接受的位置参数太少；应为 {expected}，但收到 {received}',
        functionTooManyParams: '函数接受太多位置参数；应为 {expected}，但收到 {received}',
        genericClassNotAllowed: '不允许对实例或类检查使用具有类型参数的泛型类型',
        incompatibleDeleter: 'Property deleter 方法不兼容',
        incompatibleGetter: 'Property getter 方法不兼容',
        incompatibleSetter: 'Property setter 方法不兼容',
        initMethodLocation: '__init__方法已在类“{type}”中定义',
        initMethodSignature: '__init__的签名为“{type}”',
        initSubclassLocation: '__init_subclass__ 方法在类“{name}”中定义',
        invariantSuggestionDict: '请考虑从 “dict” 切换到 “Mapping”(在值类型中为协变)',
        invariantSuggestionList: '考虑从“list”切换到“Sequence”(协变)',
        invariantSuggestionSet: '请考虑从“set”切换到“Container”，后者是协变的',
        isinstanceClassNotSupported: '实例和类检查不支持“{type}”',
        keyNotRequired: '“{type}”中“{name}”不是必需的密钥，因此访问可能会导致运行时异常',
        keyReadOnly: '“{name}”是“{type}”中的只读密钥',
        keyRequiredDeleted: '“{name}”是必需的密钥，无法删除',
        keyUndefined: '“{name}”不是“{type}”中定义的密钥',
        kwargsParamMissing: '参数“**{paramName}”没有相应的参数',
        listAssignmentMismatch: '类型“{type}”与目标列表不兼容',
        literalAssignmentMismatch: '“{sourceType}”不可分配给类型“{destType}”',
        matchIsNotExhaustiveHint: '如果未进行详尽处理，请添加"case _: pass"',
        matchIsNotExhaustiveType: '未处理的类型: "{type}"',
        memberAssignment: '无法将类型“{type}”的表达式分配给类“{classType}”的属性“{name}”',
        memberIsAbstract: '未实现“{type}.{name}”',
        memberIsAbstractMore: '还有 {count} 个...',
        memberIsClassVarInProtocol: '“{name}”在协议中定义为 ClassVar',
        memberIsInitVar: '"{name}" 是 init-only 的字段',
        memberIsInvariant: '“{name}”是固定的，因为它是可变的',
        memberIsNotClassVarInClass: '“{name}”必须定义为 ClassVar 才能与协议兼容',
        memberIsNotClassVarInProtocol: '“{name}”未在协议中定义为 ClassVar',
        memberIsNotReadOnlyInProtocol: '“{name}”在协议中不是只读的',
        memberIsReadOnlyInProtocol: '“{name}”在协议中是只读的',
        memberIsWritableInProtocol: '“{name}”在协议中是可写入的',
        memberSetClassVar: '无法通过类实例分配属性“{name}”，因为它是 ClassVar',
        memberTypeMismatch: '"{name}"是不兼容的类型',
        memberUnknown: '属性“{name}”未知',
        metaclassConflict: '元类“{metaclass1}”与“{metaclass2}”存在冲突',
        missingDeleter: '缺少 Property deleter 方法',
        missingGetter: '缺少 Property getter 方法',
        missingSetter: '缺少 Property setter 方法',
        namedParamMissingInDest: '额外参数“{name}”',
        namedParamMissingInSource: '缺少关键字参数“{name}”',
        namedParamTypeMismatch: '类型为“{sourceType}”的关键字参数“{name}”与类型“{destType}”不兼容',
        namedTupleNotAllowed: '不能对实例或类检查使用 NamedTuple',
        newMethodLocation: '__new__方法已在类“{type}”中定义',
        newMethodSignature: '__new__的签名为“{type}”',
        newTypeClassNotAllowed: '不能将使用 NewType 创建的类用于实例和类检查',
        noOverloadAssignable: '没有重载函数与类型“{type}”匹配',
        noneNotAllowed: '不能对实例或类检查使用 None',
        orPatternMissingName: '缺少名称: {name}',
        overloadIndex: '重载 {index} 是最接近的匹配项',
        overloadNotAssignable: '无法分配“{name}”的一个或多个重载',
        overloadSignature: '此处定义了重载签名',
        overriddenMethod: '替代的方法',
        overriddenSymbol: '替代符号',
        overrideInvariantMismatch: '替代类型“{overrideType}”与基类型“{baseType}”不同',
        overrideIsInvariant: '变量是可变的，因此其类型是固定的',
        overrideNoOverloadMatches: '替代中没有与基本方法兼容的重载签名',
        overrideNotClassMethod: '基方法声明为 classmethod，但替代不是',
        overrideNotInstanceMethod: '基方法声明为实例方法，但替代不是',
        overrideNotStaticMethod: '基方法声明为 staticmethod，但替代不是',
        overrideOverloadNoMatch: '替代不处理基方法的所有重载',
        overrideOverloadOrder: '替代方法的重载必须与基方法的顺序相同',
        overrideParamKeywordNoDefault: '关键字参数"{name}"不匹配: 基参数具有默认参数值，替代参数不匹配',
        overrideParamKeywordType: '关键字参数“{name}”类型不匹配: 基参数是类型“{baseType}”，替代参数为类型“{overrideType}”',
        overrideParamName: '参数{index}名称不匹配: 基参数命名为 "{baseName}"，替代参数命名为 "{overrideName}"',
        overrideParamNameExtra: '基数中缺少参数“{name}”',
        overrideParamNameMissing: '替代中缺少参数“{name}”',
        overrideParamNamePositionOnly: '参数 {index} 不匹配: 基参数“{baseName}”是关键字参数，替代参数为仅位置参数',
        overrideParamNoDefault: '参数 {index} 不匹配: 基参数具有默认参数值，替代参数不匹配',
        overrideParamType: '参数 {index} 类型不匹配: 基参数为类型“{baseType}”，替代参数为类型“{overrideType}”',
        overridePositionalParamCount: '位置参数计数不匹配；基方法具有 {baseCount}，但替代具有 {overrideCount}',
        overrideReturnType: '返回类型不匹配:基方法返回类型"{baseType}"，替代返回类型"{overrideType}"',
        overrideType: '基类将类型定义为"{type}"',
        paramAssignment: '参数 {index}: 类型“{sourceType}”与类型“{destType}”不兼容',
        paramSpecMissingInOverride: '替代方法中缺少 ParamSpec 参数',
        paramType: '参数类型为“{paramType}”',
        privateImportFromPyTypedSource: '改为从"{module}"导入',
        propertyAccessFromProtocolClass: '不能以类变量形式存取协议类中定义的属性',
        propertyMethodIncompatible: 'Property 方法 "{name}" 不兼容',
        propertyMethodMissing: '替代中缺少 Property 方法 "{name}"',
        propertyMissingDeleter: 'Property "{name}" 没有定义的 deleter',
        propertyMissingSetter: 'Property "{name}" 没有定义的 setter',
        protocolIncompatible: '“{sourceType}”与协议“{destType}”不兼容',
        protocolMemberMissing: '“{name}”不存在',
        protocolRequiresRuntimeCheckable: 'Protocol 类必须为 @runtime_checkable 才能用于实例和类检查',
        protocolSourceIsNotConcrete: '“{sourceType}”不是具体类类型，无法分配给类型“{destType}”',
        protocolUnsafeOverlap: '“{name}”的属性与协议具有相同的名称',
        pyrightCommentIgnoreTip: '使用 "# pyright: ignore[<diagnostic rules>]" 抑制单行诊断',
        readOnlyAttribute: '属性“{name}”为只读',
        seeClassDeclaration: '查看类声明',
        seeDeclaration: '参见声明',
        seeFunctionDeclaration: '请参阅函数声明',
        seeMethodDeclaration: '请参阅方法声明',
        seeParameterDeclaration: '请参阅参数声明',
        seeTypeAliasDeclaration: '请参阅类型别名声明',
        seeVariableDeclaration: '查看变量声明',
        tupleAssignmentMismatch: '类型 "{type}" 与目标 tuple 不兼容',
        tupleEntryTypeMismatch: 'Tuple 条目 {entry} 的类型不正确',
        tupleSizeIndeterminateSrc: 'Tuple 大小不匹配; 应为 {expected}，但收到不确定的值',
        tupleSizeIndeterminateSrcDest: 'Tuple 大小不匹配; 应为 {expected} 或更多，但收到不确定的值',
        tupleSizeMismatch: 'Tuple 大小不匹配; 应为 {expected}，但收到 {received}',
        tupleSizeMismatchIndeterminateDest: 'Tuple 大小不匹配; 应为 {expected} 或更多，但收到 {received}',
        typeAliasInstanceCheck: '使用 "type" 语句创建的类型别名不能与实例和类检查一起使用',
        typeAssignmentMismatch: '类型“{sourceType}”不可分配给类型“{destType}”',
        typeBound: '类型“{sourceType}”不可分配给类型变量“{name}”的上限“{destType}”',
        typeConstrainedTypeVar: '类型“{type}”不可分配给受约束的类型变量“{name}”',
        typeIncompatible: '“{sourceType}”不可分配给“{destType}”',
        typeNotClass: '“{type}”不是类',
        typeNotStringLiteral: '“{type}”不是字符串文本',
        typeOfSymbol: '“{name}”的类型为“{type}”',
        typeParamSpec: '类型“{type}”与 ParamSpec“{name}”不兼容',
        typeUnsupported: '类型“{type}”不受支持',
        typeVarDefaultOutOfScope: '类型变量“{name}”不在范围内',
        typeVarIsContravariant: '类型参数 "{name}" 是逆变的，但 "{sourceType}" 不是 "{destType}" 的超类型',
        typeVarIsCovariant: '类型参数 "{name}" 是协变的，但 "{sourceType}" 不是 "{destType}" 的子类型',
        typeVarIsInvariant: '类型参数 "{name}" 是固定的，但 "{sourceType}" 与 "{destType}" 不同',
        typeVarNotAllowed: '不允许对实例或类检查使用 TypeVar',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple 不能绑定到长度未知的 tuple',
        typeVarUnnecessarySuggestion: '请改用 {type}',
        typeVarUnsolvableRemedy: '提供一个重载，该重载指定未提供参数时的返回类型',
        typeVarsMissing: '缺少类型变量: {names}',
        typedDictBaseClass: '类“{type}”不是 TypedDict',
        typedDictClassNotAllowed: '不允许对实例或类检查使用 TypedDict 类',
        typedDictClosedExtraNotAllowed: '无法添加项“{name}”',
        typedDictClosedExtraTypeMismatch: '无法添加类型为“{type}”的项“{name}”',
        typedDictClosedFieldNotRequired: '无法添加项“{name}”，因为它必须是 NotRequired',
        typedDictExtraFieldNotAllowed: '“{type}”中不存在“{name}”',
        typedDictExtraFieldTypeMismatch: '“{name}”的类型与“{type}”中的 “extra_items” 类型不兼容',
        typedDictFieldMissing: '"{type}"中缺少"{name}"',
        typedDictFieldNotReadOnly: '"{name}"在"{type}"中不是只读的',
        typedDictFieldNotRequired: '“{type}”中不需要“{name}”',
        typedDictFieldRequired: '"{type}"中需要"{name}"',
        typedDictFieldTypeMismatch: '类型“{type}”不可分配给项“{name}”',
        typedDictFieldUndefined: '“{name}”是类型“{type}”中的未定义项',
        typedDictFinalMismatch: '"{sourceType}"与"{destType}"不兼容，因为@final不匹配',
        typedDictKeyAccess: '使用 ["{name}"] 引用 TypedDict 中的项',
        typedDictNotAllowed: '不能对实例或类检查使用 TypedDict',
        unhashableType: '类型“{type}”不可哈希',
        uninitializedAbstractVariable: '实例变量“{name}”在抽象基类“{classType}”中定义，但未初始化',
        unreachableExcept: '“{exceptionType}”是“{parentType}”的子类',
        useDictInstead: '使用 Dict[T1, T2] 指示字典类型',
        useListInstead: '使用 List[T] 指示 list 类型或使用 Union[T1, T2] 指示 union 类型',
        useTupleInstead: '使用 tuple[T1, ..., Tn] 指示 tuple 类型或使用 Union[T1, T2] 指示 union 类型',
        useTypeInstead: '改用 Type[T]',
        varianceMismatchForClass: '类型参数"{typeVarName}"的差异与基类"{className}"不兼容',
        varianceMismatchForTypeAlias: '类型参数"{typeVarName}"的差异与"{typeAliasParam}"不兼容'
      },
      Service: {
        longOperation: '枚举工作区源文件需要很长时间。请考虑打开子文件夹。[了解详细信息](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  95610: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: '建立類型 Stub',
        createTypeStubFor: '建立 "{moduleName}" 的類型 Stub',
        executingCommand: '執行命令',
        filesToAnalyzeCount: '要分析的 {count} 個檔案',
        filesToAnalyzeOne: '1 個要分析的檔案',
        findingReferences: '尋找參考',
        organizeImports: '整理匯入',
        renameShadowedFile: '將 "{oldFile}" 重新命名為 "{newFile}"'
      },
      Completion: {
        autoImportDetail: '自動匯入',
        indexValueDetail: '索引值'
      },
      Diagnostic: {
        abstractMethodInvocation: '無法呼叫方法 "{method}"，因為它是抽象且未執行',
        annotatedMetadataInconsistent: '標註的中繼資料類型 "{metadataType}" 與類型 "{type}" 不相容',
        annotatedParamCountMismatch: '參數註釋計數不符: 應為 {expected}，但收到 {received}',
        annotatedTypeArgMissing: '預期 "Annotated" 有一個類型引數和一或多個註釋',
        annotationBytesString: '類型運算式無法使用位元組字串常值',
        annotationFormatString: '類型運算式不能使用格式字串常值 (f-strings)',
        annotationNotSupported: '此陳述式不支援類型註釋',
        annotationRawString: '類型運算式無法使用原始字串常值',
        annotationSpansStrings: '型別運算式無法跨越多個字串常值',
        annotationStringEscape: '型別運算式不可包含逸出字元',
        argAssignment: '類型 "{argType}" 的引數不能指派至類型 "{paramType}" 的參數',
        argAssignmentFunction: '類型 "{argType}" 的引數不能指派至函式 "{functionName}" 中類型 "{paramType}" 的參數',
        argAssignmentParam: '類型 "{argType}" 的引數不能指派至類型 "{paramType}" 的參數 "{paramName}"',
        argAssignmentParamFunction: '類型 "{argType}" 的引數不能指派至函式 "{functionName}" 中類型 "{paramType}" 的參數 "{paramName}"',
        argMissingForParam: '參數 {name} 遺漏引數',
        argMissingForParams: '參數 {names} 的引數遺失',
        argMorePositionalExpectedCount: '預期有另 {expected} 個位置引數',
        argMorePositionalExpectedOne: '預期有另 1 個位置引數',
        argPositional: '預期為位置引數',
        argPositionalExpectedCount: '預期有 {expected} 個位置引數',
        argPositionalExpectedOne: '預期為 1 個位置引數',
        argTypePartiallyUnknown: '引數型別為部分未知',
        argTypeUnknown: '引數類型未知',
        assertAlwaysTrue: 'Assert 運算式一律會評估為 true',
        assertTypeArgs: '"assert_type" 需要兩個位置引數',
        assertTypeTypeMismatch: '"assert_type" 不符: 預期為 "{expected}"，但收到 "{received}"',
        assignmentExprComprehension: '指派運算式目標 "{name}" 不能使用與目標 Comprehension 相同的名稱',
        assignmentExprContext: 'Assignment 運算式必須在模組、函式或 Lambda 內',
        assignmentExprInSubscript: '下標內的 Assignment 運算式僅在 Python 3.10 和更新版本中支援',
        assignmentInProtocol: '必須在類別主體內明確宣告 Protocol 類別內的執行個體或類別變數',
        assignmentTargetExpr: '運算式不能是指派目標',
        asyncNotInAsyncFunction: '不允許在非 async 之外使用 "async"',
        awaitIllegal: '使用 "await" 需要 Python 3.5 或更新版本',
        awaitNotAllowed: '類型運算式不能使用 "await"',
        awaitNotInAsync: '只在 async 函式內允許 "await"',
        backticksIllegal: 'Python 3.x 中不支援以反引號括住的運算式; 請改為使用 repr',
        baseClassCircular: '類別無法從本身衍生',
        baseClassFinal: '基底類別 "{type}" 標示為 final，且不能設為子類別',
        baseClassIncompatible: '{type} 的基底類別互不相容',
        baseClassInvalid: '類別的引數必須是基底類別',
        baseClassMethodTypeIncompatible: '類別 "{classType}" 的基底類別以不相容的方式定義方法 "{name}"',
        baseClassUnknown: '基底類別類型未知，遮蔽衍生類別的類型',
        baseClassVariableTypeIncompatible: '類別 "{classType}" 的基底類別以不相容的方式定義變數 "{name}"',
        binaryOperationNotAllowed: '類型運算式中不允許二元運算子',
        bindTypeMismatch: '無法繫結方法 "{methodName}"，因為 "{type}" 無法指派給參數 "{paramName}"',
        breakInExceptionGroup: '"except*" 區塊中不允許 "break"',
        breakOutsideLoop: '"break" 只能在迴圈內使用',
        callableExtraArgs: '預期 "Callable" 只有兩個類型引數',
        callableFirstArg: '預期為參數類型清單或 "..."',
        callableNotInstantiable: '不能具現化類型 "{type}"',
        callableSecondArg: '預期為傳回類型作為 "Callable" 的第二個類型引數',
        casePatternIsIrrefutable: '僅允許最後一個案例陳述式使用無法推翻的模式',
        classAlreadySpecialized: '類型 "{type}" 已特殊化',
        classDecoratorTypeUnknown: '不具型別的類別裝飾項目會掩蓋類別的型別; 略過裝飾項目',
        classDefinitionCycle: '"{name}" 的類別定義視其本身而定',
        classGetItemClsParam: '__class_getitem__ 覆寫應接受 "cls" 參數',
        classMethodClsParam: '類別方法應採用 "cls" 參數',
        classNotRuntimeSubscriptable: '類別 "{name}" 的下標會產生執行階段例外; 以引號括住類型運算式',
        classPatternBuiltInArgPositional: '類別模式僅接受位置子模式',
        classPatternPositionalArgCount: '類別 "{type}" 的位置模式太多;預期 {expected} 但收到 {received}',
        classPatternTypeAlias: '無法在類別模式中使用 "{type}"，因為它是特殊的型別別名',
        classPropertyDeprecated: '類別屬性在 Python 3.11 中已取代，在 Python 3.13 中將不受支援',
        classTypeParametersIllegal: '類別類型參數語法需要 Python 3.12 或更新版本',
        classVarFirstArgMissing: '"ClassVar" 後面應有一個型別引數',
        classVarNotAllowed: '此內容中不允許 "ClassVar"',
        classVarOverridesInstanceVar: '類別變數 "{name}" 會覆寫類別 "{className}" 中相同名稱的執行個體變數',
        classVarTooManyArgs: '"ClassVar" 後面應只能有一個型別引數',
        classVarWithTypeVar: '"ClassVar" 型別不能包含型別變數',
        clsSelfParamTypeMismatch: '參數 "{name}" 的型別必須是其類別 "{classType}" 的超級型別',
        codeTooComplexToAnalyze: '程式碼太複雜而無法分析; 重構為副常式或減少條件式程式碼路徑，以降低複雜性',
        collectionAliasInstantiation: '無法將型別 "{type}" 具現化，請改用 "{alias}"',
        comparisonAlwaysFalse: '條件一律會評估為 False，因為類型 "{leftType}" 和 "{rightType}" 沒有重疊',
        comparisonAlwaysTrue: '條件一律會評估為 True，因為類型 "{leftType}" 和 "{rightType}" 沒有重疊',
        comprehensionInDict: 'Comprehension 不能與其他字典項目搭配使用',
        comprehensionInSet: 'Comprehension 無法與其他 set 輸入項目一起使用',
        concatenateContext: '此內容中不允許 "Concatenate"',
        concatenateParamSpecMissing: '"Concatenate" 的最後一個類型引數必須是 ParamSpec 或 "..."',
        concatenateTypeArgsMissing: '"Concatenate" 至少需要兩個型別引數',
        conditionalOperandInvalid: '型別 "{type}" 的條件運算元無效',
        constantRedefinition: '"{name}" 是常數 (因為它是大寫) 且無法重新定義',
        constructorParametersMismatch: '類別 "{classType}" 中__new__與__init__的簽章不相符',
        containmentAlwaysFalse: '運算式一律會評估為 False，因為型別 "{leftType}" 和 "{rightType}" 沒有重疊',
        containmentAlwaysTrue: '運算式一律會評估為 True，因為型別 "{leftType}" 和 "{rightType}" 沒有重疊',
        continueInExceptionGroup: '"except*" 區塊中不允許 "continue"',
        continueOutsideLoop: '"continue" 只能在 loop 內使用',
        coroutineInConditionalExpression: '條件運算式參考協同程式，一律評估為 True',
        dataClassBaseClassFrozen: '未凍結的類別無法繼承已凍結的類別',
        dataClassBaseClassNotFrozen: '凍結的類別不能從未凍結的類別繼承',
        dataClassConverterFunction: '類型 "{argType}" 的引數不是類型 "{fieldType}" 欄位 "{fieldName}" 的有效轉換程式',
        dataClassConverterOverloads: '"{funcName}" 沒有任何多載是類型 "{fieldType}" 欄位 "{fieldName}" 的有效轉換程式',
        dataClassFieldInheritedDefault: '"{fieldName}" 覆寫相同名稱的欄位，但缺少預設值',
        dataClassFieldWithDefault: '沒有預設值的欄位無法出現在具有預設值的欄位後面',
        dataClassFieldWithPrivateName: 'Dataclass 欄位不能使用私人名稱',
        dataClassFieldWithoutAnnotation: '沒有型別註釋的 Dataclass 欄位會造成執行階段例外狀況',
        dataClassPostInitParamCount: 'Dataclass __post_init__ 不正確的參數計數; InitVar 欄位數目為 {expected}',
        dataClassPostInitType: '欄位 "{fieldName}" 的 Dataclass __post_init__ 方法參數類型不符',
        dataClassSlotsOverwrite: '__slots__已定義在類別中',
        dataClassTransformExpectedBoolLiteral: '應為靜態評估為 True 或 False 的運算式',
        dataClassTransformFieldSpecifier: '應為類別或函式的 tuple，但收到的類別為 "{type}"',
        dataClassTransformPositionalParam: '"dataclass_transform" 的所有引數都必須是關鍵字引數',
        dataClassTransformUnknownArgument: 'dataclass_transform 不支援引數 "{name}"',
        dataProtocolInSubclassCheck: 'issubclass 呼叫中不允許資料通訊協定 (包含非方法屬性)',
        declaredReturnTypePartiallyUnknown: '宣告的傳回類型 "{returnType}" 部分未知',
        declaredReturnTypeUnknown: '宣告的傳回類型未知',
        defaultValueContainsCall: '參數預設值運算式內不允許函式呼叫和可變物件',
        defaultValueNotAllowed: '具有 "*" 或 "**" 的參數不能有預設值',
        delTargetExpr: '無法刪除運算式',
        deprecatedClass: '類別 "{name}" 已淘汰',
        deprecatedConstructor: '類別 "{name}" 的建構函式已取代',
        deprecatedDescriptorDeleter: '描述項 "{name}" 的 "__delete__" 方法已被取代',
        deprecatedDescriptorGetter: '描述項 "{name}" 的 "__get__" 方法已被取代',
        deprecatedDescriptorSetter: '描述項 "{name}" 的 "__set__" 方法已被取代',
        deprecatedFunction: '函式 "{name}" 已取代',
        deprecatedMethod: '類別 "{className}" 中的方法 "{name}" 已取代',
        deprecatedPropertyDeleter: 'The deleter for property "{name}" is deprecated',
        deprecatedPropertyGetter: 'The getter for property "{name}" is deprecated',
        deprecatedPropertySetter: 'The setter for property "{name}" is deprecated',
        deprecatedType: '此類型已隨著 Python {version} 取代; 請改為使用 "{replacement}"',
        dictExpandIllegalInComprehension: 'Comprehension 中不允許字典擴充',
        dictInAnnotation: '類型運算式中不允許字典運算式',
        dictKeyValuePairs: '字典項目必須包含金鑰/值組',
        dictUnpackIsNotMapping: '預期為字典解壓縮運算子的對應',
        dunderAllSymbolNotPresent: '"{name}" 已在 __all__ 中指定，但在模組中不存在',
        duplicateArgsParam: '只允許一個 "*" 參數',
        duplicateBaseClass: '不允許重複的基底類別',
        duplicateCapturePatternTarget: '擷取目標 "{name}" 不能在相同模式中出現一次以上',
        duplicateCatchAll: '只允許一個 catch-all except 子句',
        duplicateEnumMember: '已宣告 Enum 成員 "{name}"',
        duplicateGenericAndProtocolBase: '只允許一個 Generic[...] 或 Protocol[...] 基底類別',
        duplicateImport: '"{importName}" 已匯入多次',
        duplicateKeywordOnly: '只允許一個 "*" 分隔符號',
        duplicateKwargsParam: '只允許一個 "**" 參數',
        duplicateParam: '重複的參數 "{name}"',
        duplicatePositionOnly: '僅允許一個 "/" 參數',
        duplicateStarPattern: '模式序列中僅允許一個 "*" 模式',
        duplicateStarStarPattern: '僅允許輸入一個 "**"',
        duplicateUnpack: 'list 中僅允許一個解除封裝作業',
        ellipsisAfterUnpacked: '"..." 不能與解壓縮的 TypeVarTuple 或 tuple 一起使用',
        ellipsisContext: '此內容中不允許 "..."',
        ellipsisSecondArg: '"..." 只允許做為兩個引數的第二個',
        enumClassOverride: 'Enum 類別 "{name}" 為 final，且不能設為子類別',
        enumMemberDelete: 'Enum member "{name}" cannot be deleted',
        enumMemberSet: 'Enum member "{name}" cannot be assigned',
        enumMemberTypeAnnotation: 'Type annotations are not allowed for enum members',
        exceptGroupMismatch: 'Try 陳述式不能同時包含 "except" 與 “except*”',
        exceptGroupRequiresType: '例外狀況群組語法 ("except*") 需要例外狀況類型',
        exceptionGroupIncompatible: '例外群組語法 ("except*") 需要 Python 3.11 或更新版本',
        exceptionGroupTypeIncorrect: 'except* 中的例外狀況類型不能衍生自 BaseGroupException',
        exceptionTypeIncorrect: '"{type}" 不是衍生自 BaseException',
        exceptionTypeNotClass: '"{type}" 不是有效的例外類別',
        exceptionTypeNotInstantiable: '例外類型 "{type}" 的建構函式需要一或多個引數',
        expectedAfterDecorator: '裝飾項目後面應有函式或類別宣告',
        expectedArrow: '預期為 "->"，後面接著傳回類型註釋',
        expectedAsAfterException: '例外狀況型別後面應有 "as"',
        expectedAssignRightHandExpr: '"=" 右側預期為運算式',
        expectedBinaryRightHandExpr: '運算子右側預期為運算式',
        expectedBoolLiteral: '應為 True 或 False',
        expectedCase: '預期為 "case" 陳述式',
        expectedClassName: '預期為類別名稱',
        expectedCloseBrace: '"{" 未關閉',
        expectedCloseBracket: '"[" 未關閉',
        expectedCloseParen: '"(" 未關閉',
        expectedColon: '預期為 ":"',
        expectedComplexNumberLiteral: '模式比對預期為複數常值',
        expectedDecoratorExpr: 'Python 3.9 之前的裝飾項目不支援運算式格式',
        expectedDecoratorName: '預期為裝飾項目名稱',
        expectedDecoratorNewline: '預期裝飾項目結尾為換行符號',
        expectedDelExpr: '"del" 後預期為運算式',
        expectedElse: '預期為 "else"',
        expectedEquals: '預期為 "="',
        expectedExceptionClass: '不正確的例外狀況類別或物件',
        expectedExceptionObj: '預期為例外物件、例外類別或 None',
        expectedExpr: '應為運算式',
        expectedFunctionAfterAsync: '"async" 後面應有函式定義',
        expectedFunctionName: '"def" 後預期為函式名稱',
        expectedIdentifier: '應為識別碼',
        expectedImport: '預期為 "import"',
        expectedImportAlias: '"as" 之後預期為符號',
        expectedImportSymbols: '預期 "import" 後為一或多個符號名稱',
        expectedIn: '預期為 "in"',
        expectedInExpr: '"in" 後預期為運算式',
        expectedIndentedBlock: '預期為縮排區塊',
        expectedMemberName: '"." 後面應該接著屬性名稱。',
        expectedModuleName: '應為模組名稱',
        expectedNameAfterAs: '"as" 後面應有符號名稱',
        expectedNamedParameter: '關鍵字參數必須接著 "*"',
        expectedNewline: '預期為換行符號',
        expectedNewlineOrSemicolon: '陳述式必須以換行符號或分號分隔',
        expectedOpenParen: '應為 "("',
        expectedParamName: '預期為參數名稱',
        expectedPatternExpr: '預期為模式運算式',
        expectedPatternSubjectExpr: '應為模式主體運算式',
        expectedPatternValue: '預期為格式 "a.b" 的模式值運算式',
        expectedReturnExpr: '"return" 後預期為運算式',
        expectedSliceIndex: '應為索引或切片運算式',
        expectedTypeNotString: '預期為類型，但收到字串常值',
        expectedTypeParameterName: '應為型別參數名稱',
        expectedYieldExpr: 'yield 陳述式中應有運算式',
        finalClassIsAbstract: '類別 "{type}" 標示為 final，且必須實作所有抽象符號',
        finalContext: '此內容中不允許 "Final"',
        finalInLoop: '無法在迴圈內指派 "Final" 變數',
        finalMethodOverride: '方法 "{name}" 不能覆寫類別 "{className}" 中定義的 final 方法',
        finalNonMethod: '無法將函式 "{name}" 標示為 @final，因為它不是方法',
        finalReassigned: '"{name}" 已宣告為 Final，因此無法重新指派',
        finalRedeclaration: '"{name}" 先前已宣告為 Final',
        finalRedeclarationBySubclass: '不能重新宣告 "{name}"，因為父類別 "{className}" 將其宣告為 Final',
        finalTooManyArgs: '預期 "Final" 之後為單一類型引數',
        finalUnassigned: '"{name}" 宣告為 Final，但未指派值',
        formatStringBrace: 'F 字串常值內不允許單一右大括弧; 請使用雙右大括弧',
        formatStringBytes: '格式字串常值 (f-strings) 不可為二進位',
        formatStringDebuggingIllegal: 'F 字串偵錯指定名稱 "=" 需要 Python 3.8 或較新的版本',
        formatStringEscape: 'Python 3.12 之前的 f 字串運算式部分不允許逸出序列 (反斜線)',
        formatStringExpectedConversion: '預期 f-string 中的 "!" 後為轉換指定元',
        formatStringIllegal: '格式字串常值 (f-strings) 需要 Python 3.6 或較新的版本',
        formatStringInPattern: '模式中不允許格式字串',
        formatStringNestedFormatSpecifier: '運算式在格式字串指定元內巢狀太深',
        formatStringNestedQuote: 'f 字串內的巢狀字串無法使用與 Python 3.12 之前的 f 字串相同的引號字元',
        formatStringUnicode: '格式字串常值 (f-strings) 不能是 Unicode',
        formatStringUnterminated: 'f 字串中有未結束的運算式; 應有 "}"',
        functionDecoratorTypeUnknown: '非類型化函式修飾項目會遮蔽函式的類型; 忽略裝飾項目',
        functionInConditionalExpression: '條件運算式參考函式，一律評估為 True',
        functionTypeParametersIllegal: '函式型別參數語法需要 Python 3.12 或較新的版本',
        futureImportLocationNotAllowed: '來自 __future__ 的匯入必須位於檔案的開頭',
        generatorAsyncReturnType: 'Return type of async generator function must be compatible with "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: '如果不是唯一引數，則必須將產生器運算式用括弧括住',
        generatorSyncReturnType: '產生器函式的傳回類型必須與 "Generator[{yieldType}, Any, Any]" 相容',
        genericBaseClassNotAllowed: '"Generic" 基底類別不能與型別參數語法一起使用',
        genericClassAssigned: '不能指派一般類別類型',
        genericClassDeleted: '無法刪除一般類別型別',
        genericInstanceVariableAccess: '透過類別存取泛型執行個體變數不明確',
        genericNotAllowed: '"Generic" 在此內容中無效',
        genericTypeAliasBoundTypeVar: '類別內的一般類型別名不能使用繫結類型變數 {names}',
        genericTypeArgMissing: '"Generic" 至少需要一個類型引數',
        genericTypeArgTypeVar: '"Generic" 的類型引數必須是類型變數',
        genericTypeArgUnique: '"Generic" 的類型引數必須是唯一的',
        globalReassignment: '"{name}" 在 global 宣告之前指派',
        globalRedefinition: '"{name}" 已宣告為 global',
        implicitStringConcat: '不允許隱含字串串連',
        importCycleDetected: '在匯入鏈結中偵測到迴圈',
        importDepthExceeded: '匯入鏈結深度超過 {depth}',
        importResolveFailure: '無法解析匯入 "{importName}"',
        importSourceResolveFailure: '無法從來源解析匯入 "{importName}"',
        importSymbolUnknown: '"{name}" 是未知的匯入符號',
        incompatibleMethodOverride: '方法 "{name}" 會以不相容的方式覆寫類別 "{className}"',
        inconsistentIndent: '取消縮排量與先前縮排不符',
        inconsistentTabs: '在縮排中使用 Tab 字元和空格不一致',
        initMethodSelfParamTypeVar: '"__init__" 方法之 "self" 參數的類型註釋不得包含類別範圍的類型變數',
        initMustReturnNone: '"__init__" 的傳回類型必須為 None',
        initSubclassCallFailed: '__init_subclass__ 方法不正確的關鍵字引數',
        initSubclassClsParam: '__init_subclass__ 覆寫應接受 "cls" 參數',
        initVarNotAllowed: '此內容中不允許 "InitVar"',
        instanceMethodSelfParam: '執行個體方法應該採用 "self" 參數',
        instanceVarOverridesClassVar: '執行個體變數 "{name}" 覆寫類別 "{className}" 中相同名稱的類別變數',
        instantiateAbstract: '無法將抽象類別 "{type}" 具現化',
        instantiateProtocol: '無法將 Protocol 類別 "{type}" 具現化',
        internalBindError: '繫結檔案 "{file}" 時發生內部錯誤: {message}',
        internalParseError: '剖析檔案 "{file}" 時發生內部錯誤: {message}',
        internalTypeCheckingError: '類型檢查檔案 "{file}" 時發生內部錯誤: {message}',
        invalidIdentifierChar: '識別碼中的字元無效',
        invalidStubStatement: '陳述式在類型 stub 檔案內沒有意義',
        invalidTokenChars: '權杖中的字元 "{text}" 無效',
        isInstanceInvalidType: '"isinstance" 的第二個引數必須是類別或類別的tuple',
        isSubclassInvalidType: '"issubclass" 的第二個引數必須是類別的類別或 tuple',
        keyValueInSet: 'set 內不允許金鑰/值組',
        keywordArgInTypeArgument: '關鍵字引數無法用於型別引數清單',
        keywordArgShortcutIllegal: '關鍵字引數快速鍵需要 Python 3.14 或更新版本',
        keywordOnlyAfterArgs: '"*" 參數之後不允許僅限關鍵字的引數分隔符號',
        keywordParameterMissing: '一或多個關鍵字參數必須接在 "*" 參數後面',
        keywordSubscriptIllegal: '不支援下標內的關鍵字引數',
        lambdaReturnTypePartiallyUnknown: 'Lambda 的傳回類型 "{returnType}" 部分未知',
        lambdaReturnTypeUnknown: 'Lambda 的傳回類型未知',
        listAssignmentMismatch: '類型 "{type}" 的運算式不能指派至目標清單',
        listInAnnotation: '型別運算式中不允許 List 運算式',
        literalEmptyArgs: '"Literal" 後面應有一或多個型別引數',
        literalNamedUnicodeEscape: '"Literal" 字串常值中不支援具名 Unicode 逸出序列',
        literalNotAllowed: '沒有類型參數，"Literal" 不能在此內容中使用',
        literalNotCallable: 'Literal 類型不能具現化',
        literalUnsupportedType: '"Literal" 的類型引數必須是 None、literal (int、bool、str 或 bytes) 或 enum 值',
        matchIncompatible: 'Match 陳述式需要 Python 3.10 或更新版本',
        matchIsNotExhaustive: 'match 陳述式內的案例並未完整處理所有值',
        maxParseDepthExceeded: '超過剖析深度上限; 將運算式分成較小的子運算式',
        memberAccess: '無法存取類別 "{type}" 的屬性 "{name}"',
        memberDelete: '無法刪除類別 "{type}" 的屬性 "{name}"',
        memberSet: '無法指派至類別 "{type}" 的屬性 "{name}"',
        metaclassConflict: '衍生類別的變換類型必須是其所有基底類別的變換類型的子類別',
        metaclassDuplicate: '只能提供一個變換類型',
        metaclassIsGeneric: '變換類型不能是一般',
        methodNotDefined: '"{name}" 方法未定義',
        methodNotDefinedOnType: '類型 "{type}" 上未定義 "{name}" 方法',
        methodOrdering: '不能建立一致的方法順序',
        methodOverridden: '"{name}" 以不相容型別 "{type}" 覆寫類別 "{className}" 中具有相同名稱的方法',
        methodReturnsNonObject: '"{name}" 方法未傳回物件',
        missingSuperCall: '方法 "{methodName}" 未呼叫父類別中相同名稱的方法',
        mixingBytesAndStr: '無法串連 Bytes 和 str 值',
        moduleAsType: '模組不能當作型別來使用',
        moduleNotCallable: '模組無法呼叫',
        moduleUnknownMember: '"{memberName}" 不是模組 "{moduleName}" 的已知屬性',
        namedExceptAfterCatchAll: 'catch-all except 子句後面不能出現具名 except 子句',
        namedParamAfterParamSpecArgs: '關鍵字參數 "{name}" 不能在簽章中出現在 ParamSpec args 參數之後',
        namedTupleEmptyName: '具名 tuple 內的名稱不可為空白',
        namedTupleEntryRedeclared: '無法覆寫 "{name}"，因為父代類別 "{className}" 是具名的 tuple',
        namedTupleFirstArg: '預期為具名 tuple 類別名稱作為第一個引數',
        namedTupleMultipleInheritance: '不支援使用 NamedTuple 的多重繼承',
        namedTupleNameKeyword: '欄位名稱不能是關鍵字',
        namedTupleNameType: '指定輸入項目名稱和類型預期有兩個輸入項目 tuple',
        namedTupleNameUnique: '具名 tuple 內的名稱必須是唯一的',
        namedTupleNoTypes: '"namedtuple" 未提供 Tuple 項目的類型; 請改為使用 "NamedTuple"',
        namedTupleSecondArg: '預期為具名 tuple 項目 list 作為第二個引數',
        newClsParam: '__new__ 覆寫應接受 "cls" 參數',
        newTypeAnyOrUnknown: 'NewType 的第二個引數必須是已知的類別，不能是 Any 或 Unknown',
        newTypeBadName: 'NewType 的第一個引數必須是字串常值',
        newTypeLiteral: 'NewType 不能與 Literal 類型搭配使用',
        newTypeNameMismatch: 'NewType 必須指派給名稱相同的變數',
        newTypeNotAClass: '預期類別為 NewType 的第二個引數',
        newTypeParamCount: 'NewType 需要兩個位置引數',
        newTypeProtocolClass: 'NewType 無法與結構類型 (Protocol 或 TypedDict 類別) 搭配使用',
        noOverload: '"{name}" 沒有任何多載符合提供的引數',
        noReturnContainsReturn: '宣告 return 類型為 "NoReturn" 的函式不能包含 return 陳述式',
        noReturnContainsYield: '宣告傳回類型為 "NoReturn" 的函式不能包含 yield 陳述式',
        noReturnReturnsNone: '宣告類型為 "NoReturn" 的函式不能傳回 "None"',
        nonDefaultAfterDefault: '非預設引數遵循預設引數',
        nonLocalInModule: '模組層級不允許 nonlocal 宣告',
        nonLocalNoBinding: '找不到 nonlocal "{name}" 的繫結',
        nonLocalReassignment: '"{name}" 在 nonlocal 宣告之前指派',
        nonLocalRedefinition: '"{name}" 已宣告為 nonlocal',
        noneNotCallable: '無法呼叫型別 "None" 的物件',
        noneNotIterable: '類型 "None" 的物件不能作為可疊代的值',
        noneNotSubscriptable: '型別 "None" 的物件不能下標',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: '"None" 不支援運算子 "{operator}"',
        noneUnknownMember: '"{name}" 不是 "None" 的已知屬性',
        notRequiredArgCount: '預期 "NotRequired" 之後為單一類型引數',
        notRequiredNotInTypedDict: '此內容中不允許 "NotRequired"',
        objectNotCallable: '類型 "{type}" 的物件無法呼叫',
        obscuredClassDeclaration: '類別宣告 "{name}" 已被相同名稱的宣告遮蔽',
        obscuredFunctionDeclaration: '函式宣告 "{name}" 被相同名稱的宣告遮蔽',
        obscuredMethodDeclaration: '方法宣告 "{name}" 被相同名稱的宣告遮蔽',
        obscuredParameterDeclaration: '參數宣告 "{name}" 被相同名稱的宣告遮蔽',
        obscuredTypeAliasDeclaration: '類型別名宣告 "{name}" 被相同名稱的宣告遮蔽',
        obscuredVariableDeclaration: '宣告 "{name}" 被相同名稱的宣告遮蔽',
        operatorLessOrGreaterDeprecated: 'Python 3 中不支援運算子 "<>"; 請改為使用 "!="',
        optionalExtraArgs: '"Optional" 後面應有一個型別引數',
        orPatternIrrefutable: '無法推翻的模式僅允許作為 "or" 模式中的最後一個子模式',
        orPatternMissingName: '"or" 模式內的所有子模式都必須以相同的名稱為目標',
        overlappingKeywordArgs: '輸入的字典與關鍵字參數重疊:: {names}',
        overlappingOverload: '"{name}" 的多載 {obscured} 將永遠不會使用，因為它的參數與多載 {obscuredBy} 重疊',
        overloadAbstractImplMismatch: '多載必須符合實作的抽象狀態',
        overloadAbstractMismatch: '多載必須全為抽象或不抽象',
        overloadClassMethodInconsistent: '"{name}" 的多載不一致地使用 @classmethod',
        overloadFinalInconsistencyImpl: '"{name}" 的多載已標示為 @final 但未實作',
        overloadFinalInconsistencyNoImpl: '"{name}" 的多載 {index} 標示為 @final 但多載 1 未標示',
        overloadImplementationMismatch: '多載的實作與多載 {index} 的簽章不一致',
        overloadReturnTypeMismatch: '"{name}" 的多載 {prevIndex} 與多載 {newIndex} 重疊，並傳回不相容的類型',
        overloadStaticMethodInconsistent: '"{name}" 的多載不一致地使用 @staticmethod',
        overloadWithoutImplementation: '"{name}" 標示為 overload，但未提供實作',
        overriddenMethodNotFound: '方法 "{name}" 已標示為 override，但不存在相同名稱的基底方法',
        overrideDecoratorMissing: '方法 "{name}" 未標示為 override，但正在覆寫類別 "{className}" 中的方法',
        paramAfterKwargsParam: '參數無法接在 "**" 參數後面',
        paramAlreadyAssigned: '已指派參數 "{name}"',
        paramAnnotationMissing: '參數 "{name}" 遺漏了型別註釋',
        paramAssignmentMismatch: '無法將型別 "{sourceType}" 的運算式指派給型別 "{paramType}" 的參數',
        paramNameMissing: '沒有名為 "{name}" 的參數',
        paramSpecArgsKwargsDuplicate: 'ParamSpec "{type}" 的引數已提供',
        paramSpecArgsKwargsUsage: 'ParamSpec 的 "args" 和 "kwargs" 屬性都必須出現在函式簽章內',
        paramSpecArgsMissing: 'ParamSpec "{type}" 的引數遺失',
        paramSpecArgsUsage: '只有搭配 *args 參數使用時，ParamSpec 的 "args" 屬性才有效',
        paramSpecAssignedName: 'ParamSpec 必須指派至名為 "{name}" 的變數',
        paramSpecContext: '此內容中不允許 ParamSpec',
        paramSpecDefaultNotTuple: 'ParamSpec 的預設值必須是省略符號、tuple 運算式或 ParamSpec',
        paramSpecFirstArg: '應以 ParamSpec 的名稱作為第一個引數',
        paramSpecKwargsUsage: '只有搭配 **kwargs 參數使用時，ParamSpec 的 "kwargs" 屬性才有效',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" 在此內容中沒有意義',
        paramSpecUnknownArg: 'ParamSpec 不支援一個以上的引數',
        paramSpecUnknownMember: '"{name}" 不是 ParamSpec 的已知屬性',
        paramSpecUnknownParam: '"{name}" 對 ParamSpec 是未知的參數',
        paramTypeCovariant: '不能在參數類型中使用共變數類型變數',
        paramTypePartiallyUnknown: '參數 "{paramName}" 的類型部分未知',
        paramTypeUnknown: '參數 "{paramName}" 的類型未知',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: '模式永遠不會符合主體類型 "{type}"',
        positionArgAfterNamedArg: '位置引數不能出現在關鍵字引數之後',
        positionOnlyAfterArgs: '"*" 參數之後不允許 Position-only 參數分隔符號',
        positionOnlyAfterKeywordOnly: '"/" 參數必須出現在 "*" 參數之前',
        positionOnlyAfterNon: '非 Position-only 參數之後不允許 Position-only 參數',
        positionOnlyFirstParam: '不允許 Position-only 參數分隔符號作為第一個參數',
        positionOnlyIncompatible: 'Position-only 參數分隔符號需要 Python 3.8 或更新版本',
        privateImportFromPyTypedModule: '"{name}" 未從模組 "{module}" 匯出',
        privateUsedOutsideOfClass: '"{name}" 為私人，並用於宣告其所在的類別之外',
        privateUsedOutsideOfModule: '"{name}" 為私人，並用於宣告其所在的模組之外',
        propertyOverridden: '"{name}" 不正確地覆寫了類別 "{className}" 中相同名稱的 property',
        propertyStaticMethod: 'Static methods not allowed for property getter, setter or deleter',
        protectedUsedOutsideOfClass: '"{name}" 受到保護，並用於其宣告所在的類別之外',
        protocolBaseClass: 'Protocol 類別 "{classType}" 不能衍生自非 Protocol 類別 "{baseType}"',
        protocolBaseClassWithTypeArgs: '使用型別參數語法時，Protocol 類別不允許使用型別引數',
        protocolIllegal: '使用 "Protocol" 需要 Python 3.7 或更新版本',
        protocolNotAllowed: '"Protocol" 不能用在此內容中',
        protocolTypeArgMustBeTypeParam: '“Protocol” 的型別引數必須是型別參數',
        protocolUnsafeOverlap: '類別以不安全方式重疊 "{name}"，且可能會在運行時間產生相符專案',
        protocolVarianceContravariant: '一般 Protocol "{class}" 中使用的類別變數 "{variable}" 必須為逆變數',
        protocolVarianceCovariant: '一般 Protocol "{class}" 中使用的類型變數 "{variable}" 必須為共變數',
        protocolVarianceInvariant: '一般 Protocol "{class}" 中使用的類別變數 "{variable}" 必須為不變數',
        pyrightCommentInvalidDiagnosticBoolValue: 'Pyright 註解指示詞後面必須接著 "="，且值為 true 或 false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Pyright 註解指示詞後面必須接著 "="，且值為 true、false、error、warning、information 或 none',
        pyrightCommentMissingDirective: 'Pyright 註解後面必須接著指示詞 (basic 或 strict) 或診斷規則',
        pyrightCommentNotOnOwnLine: '用來控制檔案層級設定的 Pyright 註解必須出現在自己的行上',
        pyrightCommentUnknownDiagnosticRule: '"{rule}" 是 pyright 註解未知的診斷規則',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" 是 pyright 註解無效的值; 預期為 true、false、error、warning、information 或 none',
        pyrightCommentUnknownDirective: '"{directive}" 是 pyright 註解未知的指示詞; 預期為 "strict" 或 "basic"',
        readOnlyArgCount: '"ReadOnly" 後面應有單一型別引數',
        readOnlyNotInTypedDict: '此內容中不允許 "ReadOnly"',
        recursiveDefinition: '無法判斷 "{name}" 型別，因為它參照了自己',
        relativeImportNotAllowed: '相對匯入不能與 "import .a" 格式搭配使用; 請改為使用 "from . import a"',
        requiredArgCount: '"Required" 後面應有單一型別引數',
        requiredNotInTypedDict: '此內容中不允許 "Required"',
        returnInAsyncGenerator: 'Return statement with value is not allowed in async generator',
        returnInExceptionGroup: '"except*" 區塊中不允許 "return"',
        returnMissing: '宣告類型為 "{returnType}" 的函式必須在所有程式碼路徑上傳回值',
        returnOutsideFunction: '"return" 只能在函式內使用',
        returnTypeContravariant: '逆變數型別變數不能用在傳回型別中',
        returnTypeMismatch: '型別 "{exprType}" 無法指派給傳回型別 "{returnType}"',
        returnTypePartiallyUnknown: '傳回類型 "{returnType}" 部分未知',
        returnTypeUnknown: '傳回類型未知',
        revealLocalsArgs: '"reveal_locals" 呼叫不應有任何引數',
        revealLocalsNone: '此範圍中沒有任何 locals',
        revealTypeArgs: '"reveal_type" 呼叫預期為單一位置引數',
        revealTypeExpectedTextArg: '函式 "reveal_type" 的 "expected_text" 引數必須是 str 常值',
        revealTypeExpectedTextMismatch: '類型文字不符; 預期為 "{expected}"，但收到 "{received}"',
        revealTypeExpectedTypeMismatch: '型別不符; 應為 "{expected}"，但收到 "{received}"',
        selfTypeContext: '"Self" 在此內容中無效',
        selfTypeMetaclass: '“Self” 不能用於 Metaclass 内 (“type” 的子類別)',
        selfTypeWithTypedSelfOrCls: '"Self" 不能用在具有 `self` 或 `cls` 參數的函式中，其類型註釋不是 "Self"',
        setterGetterTypeMismatch: 'Property setter 數值類型不能指派至 getter 傳回類型',
        singleOverload: '"{name}" 標示為多載，但遺失其他多載',
        slotsAttributeError: '未在__slots__中指定 "{name}"',
        slotsClassVarConflict: '"{name}" 與在 __slots__ 中宣告的執行個體變數衝突',
        starPatternInAsPattern: '星形模式不能與 "as" 目標搭配使用',
        starPatternInOrPattern: '星形模式不能在其他模式內使用 OR',
        starStarWildcardNotAllowed: '** 不能與萬用字元 "_" 搭配使用',
        staticClsSelfParam: '靜態方法不應採用 "self" 或 "cls" 參數',
        stdlibModuleOverridden: '"{path}" 正在覆寫 stdlib 模組 "{name}"',
        stringNonAsciiBytes: '位元組字串常值中不允許非 ASCII 字元',
        stringNotSubscriptable: '字串運算式不能在類型運算式中下標; 以引號括住整個運算式',
        stringUnsupportedEscape: '字串常值中不支援的逸出序列',
        stringUnterminated: '字串常值未結束',
        stubFileMissing: '找不到 "{importName}" 的 stub 檔案',
        stubUsesGetAttr: '類型 stub 檔案不完整; "__getattr__" 會遮蔽模組的類型錯誤',
        sublistParamsIncompatible: 'Python 3.x 不支援 sublist 參數',
        superCallArgCount: '"super" 呼叫不應有兩個以上的引數',
        superCallFirstArg: '預期的類別類型為 "super" 呼叫的第一個引數，但收到 "{type}"',
        superCallSecondArg: '"super" 呼叫的第二個引數必須是衍生自 "{type}" 的物件或類別',
        superCallZeroArgForm: '"super" 呼叫的零引數形式只在方法內有效',
        superCallZeroArgFormStaticMethod: '"super" 呼叫的零引數形式在靜態方法內無效',
        symbolIsPossiblyUnbound: '"{name}" 可能未繫結',
        symbolIsUnbound: '"{name}" 未繫結',
        symbolIsUndefined: '"{name}" 未定義',
        symbolOverridden: '"{name}" 會覆寫類別 "{className}" 中相同名稱的符號',
        ternaryNotAllowed: '類型運算式中不允許三元運算式',
        totalOrderingMissingMethod: '類別必須定義 "__lt__"、"__le__"、"__gt__" 或 "__ge__" 其中一個，才能使用 total_ordering',
        trailingCommaInFromImport: '後置逗號不允許未使用括弧',
        tryWithoutExcept: 'Try 陳述式必須至少有一個 except 或 finally 子句',
        tupleAssignmentMismatch: '無法將型別 "{type}" 的運算式指派至目標 tuple',
        tupleInAnnotation: '型別運算式中不允許 Tuple 運算式',
        tupleIndexOutOfRange: '索引 {index} 超過類型 {type} 的範圍',
        typeAliasIllegalExpressionForm: '類型別名定義無效的運算式格式',
        typeAliasIsRecursiveDirect: '型別別名 "{name}" 無法在其定義中使用它自己',
        typeAliasNotInModuleOrClass: 'TypeAlias 只能在模組或類別範圍內定義',
        typeAliasRedeclared: '"{name}" 宣告為 TypeAlias，且只能指派一次',
        typeAliasStatementBadScope: 'A type statement can be used only within a module or class scope',
        typeAliasStatementIllegal: '類型別名陳述式需要 Python 3.12 或更新版本',
        typeAliasTypeBaseClass: '"type" 陳述式中定義的類型別名不能做為基底類別使用',
        typeAliasTypeMustBeAssigned: 'TypeAliasType 必須指派給與型別別名相同的變數',
        typeAliasTypeNameArg: 'TypeAliasType 的第一個引數必須是代表型別別名名稱的字串常值',
        typeAliasTypeNameMismatch: '類型別名的名稱必須與指派它的變數名稱相符',
        typeAliasTypeParamInvalid: '型別參數清單必須是只包含 TypeVar、TypeVarTuple 或 ParamSpec 的 tuple',
        typeAnnotationCall: '型別運算式中不允許呼叫運算式',
        typeAnnotationVariable: '型別運算式中不允許變數',
        typeAnnotationWithCallable: '"type" 的類型引數必須是類別; 不支援可呼叫項目',
        typeArgListExpected: '預期為 ParamSpec、省略符號或類型 list',
        typeArgListNotAllowed: '此型別引數不允許 list 運算式',
        typeArgsExpectingNone: '預期類別 "{name}" 沒有類型引數',
        typeArgsMismatchOne: '預期為一個類型引數，但收到 {received}',
        typeArgsMissingForAlias: '預期為一般類型別名 "{name}" 的類型引數',
        typeArgsMissingForClass: '應為一般類別 "{name}" 的型別引數',
        typeArgsTooFew: '為 "{name}" 提供太少類型引數; 預期為 {expected} 但收到 {received}',
        typeArgsTooMany: '已為 "{name}" 提供太多型別引數; 應為 {expected} 但收到 {received}',
        typeAssignmentMismatch: '型別 "{sourceType}" 無法指派給宣告的型別 "{destType}"',
        typeAssignmentMismatchWildcard: '匯入符號 "{name}" 具有型別 "{sourceType}"，該型別無法指派給宣告的型別 "{destType}"',
        typeCallNotAllowed: '不應在類型運算式中使用 type() 呼叫',
        typeCheckOnly: '"{name}" 已標示為 @type_check_only，只能在型別註釋中使用',
        typeCommentDeprecated: '使用 type 註解已取代; 請改為使用 type 註釋',
        typeExpectedClass: '預期的類別，但已收到 "{type}"',
        typeFormArgs: '"TypeForm" 接受單一位置引數',
        typeGuardArgCount: '預期 "TypeGuard" 或 "TypeIs" 之後為單一類型引數',
        typeGuardParamCount: '使用者定義的類型防護函式和方法至少必須有一個輸入參數',
        typeIsReturnType: 'TypeIs 的傳回類型 ("{returnType}") 與值參數類型 ("{type}") 不一致',
        typeNotAwaitable: '"{type}" 不可 awaitable',
        typeNotIntantiable: '"{type}" 不能具現化',
        typeNotIterable: '"{type}" 無法疊代',
        typeNotSpecializable: '無法將型別 "{type}" 特殊化',
        typeNotSubscriptable: '類型 "{type}" 的物件不能下標',
        typeNotSupportBinaryOperator: '型別 "{leftType}" 和 "{rightType}" 不支援運算子 "{operator}"',
        typeNotSupportBinaryOperatorBidirectional: '當預期的型別為 "{expectedType}" 時，型別 "{leftType}" 和 "{rightType}" 不支援運算子 "{operator}"',
        typeNotSupportUnaryOperator: '型別 "{type}" 不支援運算子 "{operator}"',
        typeNotSupportUnaryOperatorBidirectional: '預期的類型為 "{expectedType}" 時，類型 "{type}" 不支援運算子 "{operator}"',
        typeNotUsableWith: '類型 "{type}" 的物件不能與 "with" 搭配使用，因為它未實作 {method}',
        typeParameterBoundNotAllowed: '界限或條件約束不能與 variadic 型別參數或 ParamSpec 一起使用',
        typeParameterConstraintTuple: '類型參數限制式必須是兩個或兩個以上類型的 Tuple',
        typeParameterExistingTypeParameter: '類型參數 "{name}" 已在使用中',
        typeParameterNotDeclared: '類型參數 "{name}" 未包含在 "{container}" 的類型參數清單中',
        typeParametersMissing: '至少必須指定一個類型參數',
        typePartiallyUnknown: '"{name}" 的類型部分未知',
        typeUnknown: '"{name}" 的類型未知',
        typeVarAssignedName: 'TypeVar 必須指派至名為 "{name}" 的變數',
        typeVarAssignmentMismatch: '無法將型別 "{type}" 指派給型別變數 "{name}"',
        typeVarBoundAndConstrained: 'TypeVar 不能同時繫結和限制',
        typeVarBoundGeneric: 'TypeVar 繫結類型不能是一般',
        typeVarConstraintGeneric: 'TypeVar 限制式類型不能是一般',
        typeVarDefaultBoundMismatch: 'TypeVar 預設型別必須是繫結型別的子型別',
        typeVarDefaultConstraintMismatch: 'TypeVar 預設型別必須是其中一個限制型別',
        typeVarDefaultIllegal: '型別變數預設型別需要 Python 3.13 或較新的版本',
        typeVarDefaultInvalidTypeVar: '類型參數 "{name}" 的預設類型參考不在範圍的一或多個類型變數',
        typeVarFirstArg: '預期為 TypeVar 的名稱作為第一個引數',
        typeVarInvalidForMemberVariable: '屬性類型不能使用範圍為 local 方法的類型變數 "{name}"',
        typeVarNoMember: 'TypeVar "{type}" 沒有屬性 "{name}"',
        typeVarNotSubscriptable: 'TypeVar "{type}" 不能下標',
        typeVarNotUsedByOuterScope: '類型變數 "{name}" 在此內容中沒有意義',
        typeVarPossiblyUnsolvable: '如果呼叫者未提供參數 "{param}" 的引數，則型別變數 "{name}" 可能無法解析',
        typeVarSingleConstraint: 'TypeVar 至少必須有兩個限制類型',
        typeVarTupleConstraints: 'TypeVarTuple 不能有值條件約束',
        typeVarTupleContext: '此內容中不允許 TypeVarTuple',
        typeVarTupleDefaultNotUnpacked: 'TypeVarTuple 預設型別必須是未封裝的 tuple 或 TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'TypeVarTuple 值需要解除封裝運算子',
        typeVarTupleUnknownParam: '"{name}" 是 TypeVarTuple 的未知參數',
        typeVarUnknownParam: '"{name}" 對 TypeVar 是未知的參數',
        typeVarUsedByOuterScope: '外部領域已在使用 TypeVar "{name}"',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" 只會在一般函式簽章中出現一次',
        typeVarVariance: 'TypeVar 不能同時為共變數和逆變數',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}" 具有預設值，無法遵循 TypeVarTuple "{variadicName}"',
        typeVarWithoutDefault: '"{name}" 無法出現在型別參數清單中的 "{other}" 後面，因為它沒有預設型別',
        typeVarsNotInGenericOrProtocol: 'Generic[] 或 Protocol[] 必須包含所有類型變數',
        typedDictAccess: '無法存取 TypedDict 中的項目',
        typedDictAssignedName: 'TypedDict 必須指派至名為 "{name}" 的變數',
        typedDictBadVar: 'TypedDict 類別只能包含型別註釋',
        typedDictBaseClass: 'TypedDict 類別的所有基底類別也必須是 TypedDict 類別',
        typedDictBoolParam: '預期 "{name}" 參數的值為 True 或 False',
        typedDictClosedExtras: '基底類別 "{name}" 是 closed 的 TypedDict; 額外項目必須為型別 "{type}"',
        typedDictClosedNoExtras: '基底類別 "{name}" 是 closed 的 TypedDict; 不允許額外項目',
        typedDictDelete: '無法刪除 TypedDict 中的項目',
        typedDictEmptyName: 'TypedDict 內的名稱不可為空白',
        typedDictEntryName: '字典項目名稱預期為字串常值',
        typedDictEntryUnique: '字典內的名稱必須是唯一的',
        typedDictExtraArgs: '不支援額外的 TypedDict 引數',
        typedDictExtraItemsClosed: '如果 TypedDict 支援額外項目，就不能是 closed',
        typedDictFieldNotRequiredRedefinition: 'TypedDict 項目 "{name}" 不能重新定義為 NotRequired',
        typedDictFieldReadOnlyRedefinition: 'TypedDict 項目 "{name}" 不能重新定義為 ReadOnly',
        typedDictFieldRequiredRedefinition: 'TypedDict 項目 "{name}" 不能重新定義為 Required',
        typedDictFirstArg: '預期 TypedDict 類別名稱作為第一個引數',
        typedDictInClassPattern: '類別模式中不允許 TypedDict 類別',
        typedDictInitsubclassParameter: 'TypedDict 不支援__init_subclass__參數 "{name}"',
        typedDictNotAllowed: '"TypedDict" 不能用在此內容中',
        typedDictSecondArgDict: '預期為 dict 或關鍵字參數作為第二個參數',
        typedDictSecondArgDictEntry: '應為簡單字典輸入項目',
        typedDictSet: '無法在 TypedDict 中指派項目',
        unaccessedClass: '未存取類別 "{name}"',
        unaccessedFunction: '未存取函式 "{name}"',
        unaccessedImport: '未存取匯入 "{name}"',
        unaccessedSymbol: '未存取 "{name}"',
        unaccessedVariable: '未存取變數 "{name}"',
        unannotatedFunctionSkipped: '因為未標註函式 "{name}"，所以略過其分析',
        unaryOperationNotAllowed: '類型運算式中不允許一元運算子',
        unexpectedAsyncToken: '預期為 "def"、"with" 或 "for" 來追蹤 "async"',
        unexpectedExprToken: '運算式結尾未預期的權杖',
        unexpectedIndent: '未預期的縮排',
        unexpectedUnindent: '取消縮排未預期',
        unhashableDictKey: '字典索引鍵必須是可雜湊的',
        unhashableSetEntry: 'Set 項目必須是可雜湊',
        uninitializedAbstractVariables: '抽象基底類別中定義的變數未在 final 類別 "{classType}" 中初始化',
        uninitializedInstanceVariable: '執行個體變數 "{name}" 未在類別本文或 __init__ 方法上初始化',
        unionForwardReferenceNotAllowed: 'Union 語法不能與字串運算元搭配使用; 使用引號括住整個運算式',
        unionSyntaxIllegal: '聯集的替代語法需要 Python 3.10 或更新版本',
        unionTypeArgCount: 'Union 需要兩個或多個類型引數',
        unionUnpackedTuple: 'Union 不能包含未封裝的 tuple',
        unionUnpackedTypeVarTuple: 'Union 不能包含未封裝的 TypeVarTuple',
        unnecessaryCast: '不必要的 "cast" 呼叫; 型別已是 "{type}"',
        unnecessaryIsInstanceAlways: '不必要的 isinstance 呼叫; "{testType}" 一律是 "{classType}" 的執行個體',
        unnecessaryIsInstanceNever: '不必要的 isinstance 呼叫; "{testType}" 永遠不是 "{classType}" 的執行個體',
        unnecessaryIsSubclassAlways: '不必要的 issubclass 呼叫; "{testType}"永遠是 "{classType}" 的子類別',
        unnecessaryIsSubclassNever: '不必要的 issubclass 呼叫; "{testType}"永遠不是 "{classType}" 的子類別',
        unnecessaryPyrightIgnore: '不必要的 "# pyright: ignore" 註解',
        unnecessaryPyrightIgnoreRule: '不必要的 "# pyright: ignore" 規則: "{name}"',
        unnecessaryTypeIgnore: '不必要的 "# type: ignore" 註解',
        unpackArgCount: '"Unpack" 後面應為單一型別引數',
        unpackExpectedTypeVarTuple: '預期 TypeVarTuple 或 tuple 作為 Unpack 的類型引數',
        unpackExpectedTypedDict: '應為 Unpack 的 TypedDict 型別引數',
        unpackIllegalInComprehension: 'Comprehension 中不允許解壓縮作業',
        unpackInAnnotation: '類型運算式中不允許解壓縮運算子',
        unpackInDict: '字典中不允許解壓縮作業',
        unpackInSet: 'Unpack operator not allowed within a set',
        unpackNotAllowed: '此內容中不允許 Unpack',
        unpackOperatorNotAllowed: '此內容中不允許解壓縮作業',
        unpackTuplesIllegal: 'Python 3.8 之前的 Tuple 中不允許解壓縮作業',
        unpackedArgInTypeArgument: '無法在此內容中使用未封裝的引數',
        unpackedArgWithVariadicParam: '未封裝的引數無法用於 TypeVarTuple 參數',
        unpackedDictArgumentNotMapping: '** 後的引數運算式必須是具有 "str" 金鑰類型的對應',
        unpackedDictSubscriptIllegal: '字典解壓縮運算子在下標中不被允許',
        unpackedSubscriptIllegal: '下標中的解壓縮運算子需要 Python 3.11 或更新版本',
        unpackedTypeVarTupleExpected: '預期為解壓縮的 TypeVarTuple; 使用 Unpack[{name1}] 或 *{name2}',
        unpackedTypedDictArgument: '無法比對解壓縮的 TypedDict 引數與參數',
        unreachableCode: '無法連線到程式碼',
        unreachableCodeType: '類型分析指出程式碼無法連線',
        unreachableExcept: '無法連接 Except 子句，因為例外已處理',
        unsupportedDunderAllOperation: '不支援 "__all__" 上的作業，因此匯出的符號清單可能不正確',
        unusedCallResult: '呼叫運算式的結果是 "{type}" 型別，而且未使用; 如果這是刻意的，則指派給變數 "_"',
        unusedCoroutine: '未使用 async 函式呼叫的結果; 使用 "await" 或指派結果至變數',
        unusedExpression: '未使用運算式值',
        varAnnotationIllegal: '變數的 type 註釋需要 Python 3.6 或更新版本; 使用類型註解以獲得與先前版本的相容性',
        variableFinalOverride: '變數 "{name}" 標示為 Final，且會覆寫類別 "{className}" 中相同名稱的非 Final 變數',
        variadicTypeArgsTooMany: '類型引數清單最多只能有一個解壓縮的 TypeVarTuple 或 tuple',
        variadicTypeParamTooManyAlias: '類型別名最多只能有一個 TypeVarTuple 類型參數，但收到多個 ({names})',
        variadicTypeParamTooManyClass: '一般類別最多只能有一個 TypeVarTuple 類型參數，但收到多個 ({names})',
        walrusIllegal: '運算子 ":=" 需要 Python 3.8 或更新版本',
        walrusNotAllowed: '此內容中不允許未使用括弧括住的運算子 ":="',
        wildcardInFunction: '類別或函式內不允許萬用字元 import',
        wildcardLibraryImport: '不允許從程式庫 import 萬用字元',
        wildcardPatternTypePartiallyUnknown: '萬用字元模式擷取的類型部分未知',
        wildcardPatternTypeUnknown: '萬用字元模式擷取的型別不明',
        yieldFromIllegal: '使用 "yield from" 需要 Python 3.3 或更新版本',
        yieldFromOutsideAsync: '"yield from" not allowed in an async function',
        yieldOutsideFunction: '在函式或 lambda 外部不允許 "yield"',
        yieldWithinComprehension: 'Comprehension 內不允許 "yield"',
        zeroCaseStatementsFound: 'Match 陳述式必須至少包含一個 case 陳述式',
        zeroLengthTupleNotAllowed: '此內容中不允許零長度 tuple'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '[Annotated] 特殊表單不可與執行個體和類別檢查一起使用',
        argParam: '引數對應至參數 "{paramName}"',
        argParamFunction: '引數對應至函式 "{functionName}" 中的參數 "{paramName}"',
        argsParamMissing: '參數 "*{paramName}" 沒有對應的參數',
        argsPositionOnly: '僅限位置的參數不符; 應為 {expected}，但收到 {received}',
        argumentType: '引數類型為 "{type}"',
        argumentTypes: '引數型別: ({types})',
        assignToNone: '型別無法指派給「None」',
        asyncHelp: '您是指 "async with" 嗎?',
        baseClassIncompatible: '基底類別 "{baseClass}" 與類型 "{type}" 不相容',
        baseClassIncompatibleSubclass: '基底類別 "{baseClass}" 衍生自與類型 "{type}" 不相容的 "{subclass}"',
        baseClassOverriddenType: '基底類別 "{baseClass}" 提供類型 "{type}"，其已覆寫',
        baseClassOverridesType: '基底類別 "{baseClass}" 以型別 "{type}" 來覆寫',
        bytesTypePromotions: '將 disableBytesTypePromotions 設定為 false，以啟用「bytearray」和「memoryview」的類型升級行為',
        conditionalRequiresBool: '類型 "{operandType}" 的方法 __bool__ 傳回類型 "{boolReturnType}" 而非 "bool"',
        dataClassFieldLocation: '欄位宣告',
        dataClassFrozen: '"{name}" 已凍結',
        dataProtocolUnsupported: '"{name}" 是個資料通訊協定',
        descriptorAccessBindingFailed: '無法為描述項類別 "{className}" 繫結方法 "{name}"',
        descriptorAccessCallFailed: '無法呼叫描述項類別 "{className}" 的方法 "{name}"',
        finalMethod: 'Final 方法',
        functionParamDefaultMissing: '參數 "{name}" 遺漏了預設引數',
        functionParamName: '參數名稱不符: "{destName}" 與 "{srcName}"',
        functionParamPositionOnly: '僅位置參數不符；參數 "{name}" 不是僅限位置',
        functionReturnTypeMismatch: '函式傳回型別 "{sourceType}" 與型別 "{destType}" 不相容',
        functionTooFewParams: '函式接受太少位置參數; 預期 {expected}，但收到 {received}',
        functionTooManyParams: '函式接受太多位置參數; 預期 {expected}，但收到 {received}',
        genericClassNotAllowed: '執行個體或類別檢查不允許具有類型引數的泛型類型',
        incompatibleDeleter: 'Property deleter 方法不相容',
        incompatibleGetter: 'Property getter 方法不相容',
        incompatibleSetter: 'Property setter 方法不相容',
        initMethodLocation: '__init__ 方法於類別 "{type}" 中定義',
        initMethodSignature: '__init__ 的簽章為 "{type}"',
        initSubclassLocation: '__init_subclass__ 方法已於類別 "{name}" 中定義',
        invariantSuggestionDict: '請考慮從「dict」切換到實值型別中共變數的「Mapping」',
        invariantSuggestionList: '請考慮從共變數的「list」切換到「Sequence」',
        invariantSuggestionSet: '考慮從 “set”切換到共同變數 “Container”',
        isinstanceClassNotSupported: '執行個體和類別檢查不支援 "{type}"',
        keyNotRequired: '"{name}" 在 "{type}" 中不是必要的索引鍵，因此存取可能會導致執行階段例外狀況',
        keyReadOnly: '"{name}" 是 "{type}" 中的唯讀金鑰',
        keyRequiredDeleted: '"{name}" 是必要的金鑰，因此不能刪除',
        keyUndefined: '"{name}" 不是 "{type}" 中定義的金鑰',
        kwargsParamMissing: '參數 "**{paramName}" 沒有對應的參數',
        listAssignmentMismatch: '類型 "{type}" 與目標清單不相容',
        literalAssignmentMismatch: '"{sourceType}" 無法指派給型別 "{destType}"',
        matchIsNotExhaustiveHint: '如果不需要徹底處理，請新增 "case _: pass"',
        matchIsNotExhaustiveType: '未處理的類型: "{type}"',
        memberAssignment: '無法將型別 "{type}" 的運算式指派給類別 "{classType}" 的屬性 "{name}"',
        memberIsAbstract: '"{type}.{name}" 未實作',
        memberIsAbstractMore: '和其他 {count} 人...',
        memberIsClassVarInProtocol: '"{name}" 定義為通訊協定中的 ClassVar',
        memberIsInitVar: '"{name}" 是 init-only 的欄位',
        memberIsInvariant: '"{name}" 為不變數，因為它可變動',
        memberIsNotClassVarInClass: '"{name}" 必須定義為 ClassVar，才能與通訊協定相容',
        memberIsNotClassVarInProtocol: '"{name}" 未定義為通訊協定中的 ClassVar',
        memberIsNotReadOnlyInProtocol: '通訊協定中的 “{name}” 不是唯讀的',
        memberIsReadOnlyInProtocol: '通訊協定中的 “{name}” 是唯讀的',
        memberIsWritableInProtocol: '"{name}" 在通訊協定中是可寫入的',
        memberSetClassVar: '無法透過類別執行個體指派屬性 "{name}"，因為它是 ClassVar',
        memberTypeMismatch: '"{name}" 是不相容的類型',
        memberUnknown: '屬性 "{name}" 不明',
        metaclassConflict: 'Metaclass「{metaclass1}」與「{metaclass2}」衝突',
        missingDeleter: 'Property deleter 方法遺失',
        missingGetter: 'Property getter 方法遺失',
        missingSetter: '遺漏了 property setter 方法',
        namedParamMissingInDest: '額外參數 "{name}"',
        namedParamMissingInSource: '遺失關鍵詞參數 "{name}"',
        namedParamTypeMismatch: '類型 "{sourceType}" 的關鍵字參數 "{name}" 與類型 "{destType}" 不相容',
        namedTupleNotAllowed: '執行個體或類別檢查無法使用 NamedTuple',
        newMethodLocation: '__new__ 方法於類別 "{type}" 中定義',
        newMethodSignature: '__new__ 的簽章為 "{type}"',
        newTypeClassNotAllowed: '使用 NewType 建立的類別不能與執行個體和類別檢查一起使用',
        noOverloadAssignable: '沒有任何多載函式符合類型 "{type}"',
        noneNotAllowed: '無法對執行個體或類別檢查使用 None',
        orPatternMissingName: '遺失名稱: {name}',
        overloadIndex: '多載 {index} 是最接近的相符項目',
        overloadNotAssignable: '"{name}" 的一或多個多載無法指派',
        overloadSignature: '多載簽章在這裡定義',
        overriddenMethod: '覆寫方法',
        overriddenSymbol: '覆寫的符號',
        overrideInvariantMismatch: '覆寫類型 "{overrideType}" 與基底類型 "{baseType}" 不同',
        overrideIsInvariant: '變數是可變動的，所以其類型是不變的',
        overrideNoOverloadMatches: '覆寫中沒有任何多載簽章與基底方法相容',
        overrideNotClassMethod: '基底方法宣告為 classmethod，但無法覆寫',
        overrideNotInstanceMethod: '基底方法已宣告為執行個體方法，但無法覆寫',
        overrideNotStaticMethod: '基底方法宣告為 staticmethod，但無法覆寫',
        overrideOverloadNoMatch: '覆寫未處理基底方法的所有多載',
        overrideOverloadOrder: '覆寫方法的多載必須與基底方法的順序相同',
        overrideParamKeywordNoDefault: '關鍵字參數 "{name}" 不相符: 基底參數有預設引數值，覆寫參數則否',
        overrideParamKeywordType: '關鍵字參數 "{name}" 型別不符: 基底參數為型別 "{baseType}"，覆寫參數為型別 "{overrideType}"',
        overrideParamName: '參數 {index} 名稱不符: 基底參數名為 "{baseName}"，覆寫參數名為 "{overrideName}"',
        overrideParamNameExtra: '基底中遺失參數 "{name}"',
        overrideParamNameMissing: '覆寫中遺漏了參數 "{name}"',
        overrideParamNamePositionOnly: '參數 {index} 不符: 基底參數 "{baseName}" 為關鍵字參數，覆寫參數為 "position-only"',
        overrideParamNoDefault: '參數 {index} 不相符: 基底參數有預設引數值，覆寫參數則否',
        overrideParamType: '參數 "{index}" 型別不符: 基底參數為型別 "{baseType}"，覆寫參數為型別 "{overrideType}"',
        overridePositionalParamCount: '位置參數計數不相符; 基底方法有 {baseCount} 個，但覆寫有 {overrideCount} 個',
        overrideReturnType: '傳回類型不符: 基底方法會傳回類型 "{baseType}"，覆寫會傳回類型 "{overrideType}"',
        overrideType: '基底類別會將類型定義為 "{type}"',
        paramAssignment: '參數 {index}: 類型 "{sourceType}" 與類型 "{destType}" 不相容',
        paramSpecMissingInOverride: '覆寫方法中遺漏了 ParamSpec 參數',
        paramType: '參數類型為 "{paramType}"',
        privateImportFromPyTypedSource: '改為從 "{module}" 匯入',
        propertyAccessFromProtocolClass: '通訊協定類別中定義的屬性無法存取為類別變數',
        propertyMethodIncompatible: 'Property 方法 "{name}" 不相容',
        propertyMethodMissing: '覆寫中遺漏了 property 方法 "{name}"',
        propertyMissingDeleter: 'Property "{name}" 沒有定義的 deleter',
        propertyMissingSetter: 'Property "{name}" 沒有定義的 setter',
        protocolIncompatible: '"{sourceType}" 與通訊協定 "{destType}" 不相容',
        protocolMemberMissing: '"{name}" 不存在',
        protocolRequiresRuntimeCheckable: 'Protocol 類別必須為 @runtime_checkable，才能搭配執行個體和類別檢查使用',
        protocolSourceIsNotConcrete: '"{sourceType}" 不是實體類別型別，因此無法指派給型別 "{destType}"',
        protocolUnsafeOverlap: '"{name}" 的屬性與通訊協定的名稱相同',
        pyrightCommentIgnoreTip: '使用 "# pyright: ignore[<diagnostic rules>]" 來隱藏單行的診斷',
        readOnlyAttribute: '屬性 "{name}" 為唯讀',
        seeClassDeclaration: '請參閱類別宣告',
        seeDeclaration: '請參閱宣告',
        seeFunctionDeclaration: '請參閱函式宣告',
        seeMethodDeclaration: '請參閱方法宣告',
        seeParameterDeclaration: '請參閱參數宣告',
        seeTypeAliasDeclaration: '請參閱類型別名宣告',
        seeVariableDeclaration: '請參閱變數宣告',
        tupleAssignmentMismatch: '型別 "{type}" 與目標 tuple 不相容',
        tupleEntryTypeMismatch: 'Tuple 項目 {entry} 的類型不正確',
        tupleSizeIndeterminateSrc: 'Tuple 大小不符; 預期為 {expected}，但收到不確定的大小',
        tupleSizeIndeterminateSrcDest: 'Tuple 大小不符; 預期為 {expected} 或其他，但收到不確定的大小',
        tupleSizeMismatch: 'Tuple 大小不符; 預期為 {expected}，但收到 {received}',
        tupleSizeMismatchIndeterminateDest: 'Tuple 大小不符; 預期為 {expected} 或其他，但收到 {received}',
        typeAliasInstanceCheck: '使用 "type" 陳述式建立的類型別名不能搭配執行個體和類別檢查使用',
        typeAssignmentMismatch: '型別 "{sourceType}" 無法指派給型別 "{destType}"',
        typeBound: '型別 "{sourceType}" 無法指派給型別變數 "{name}" 的上限 "{destType}"',
        typeConstrainedTypeVar: '型別 "{type}" 無法指派給限制型別變數 "{name}"',
        typeIncompatible: '"{sourceType}" 無法指派給 "{destType}"',
        typeNotClass: '"{type}" 不是類別',
        typeNotStringLiteral: '"{type}" 不是字串常值',
        typeOfSymbol: '"{name}" 的型別為 "{type}"',
        typeParamSpec: '類型 "{type}" 與 ParamSpec "{name}" 不相容',
        typeUnsupported: '類型 "{type}" 不受支援',
        typeVarDefaultOutOfScope: '類型變數 "{name}" 不在範圍內',
        typeVarIsContravariant: '型別參數 "{name}" 具有反變性，但 "{sourceType}" 不是 "{destType}" 的超型別',
        typeVarIsCovariant: '型別參數 "{name}" 具有共變性，但 "{sourceType}" 不是 "{destType}" 的子型別',
        typeVarIsInvariant: '型別參數 "{name}" 具有不變性，但 "{sourceType}" 與 "{destType}" 不同',
        typeVarNotAllowed: '執行個體或類別檢查不允許 TypeVar',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple 無法繫結至長度不明的 tuple',
        typeVarUnnecessarySuggestion: '改用 {type}',
        typeVarUnsolvableRemedy: '提供多載，其指定未提供引數時的傳回類型',
        typeVarsMissing: '遺失類型變數: {names}',
        typedDictBaseClass: '類別 "{type}" 不是 TypedDict',
        typedDictClassNotAllowed: '執行個體或類別檢查不允許 TypedDict 類別',
        typedDictClosedExtraNotAllowed: '無法新增項目 "{name}"',
        typedDictClosedExtraTypeMismatch: '無法新增型別為 "{type}" 的項目 "{name}"',
        typedDictClosedFieldNotRequired: '無法新增項目 "{name}"，因為它必須是 NotRequired',
        typedDictExtraFieldNotAllowed: '"{name}" 不存在於 "{type}"',
        typedDictExtraFieldTypeMismatch: '"{name}" 的類型與 "{type}" 中 "extra_items" 的類型不相容',
        typedDictFieldMissing: '"{type}" 遺失 "{name}"',
        typedDictFieldNotReadOnly: '"{name}" 在 "{type}" 中不是唯讀',
        typedDictFieldNotRequired: '"{type}" 中不需要 "{name}"',
        typedDictFieldRequired: '"{type}" 中需要 "{name}"',
        typedDictFieldTypeMismatch: '型別 "{type}" 無法指派給項目 "{name}"',
        typedDictFieldUndefined: '"{name}" 是型別 "{type}" 中未定義的項目',
        typedDictFinalMismatch: '"{sourceType}" 與 "{destType}" 不相容，因為@final 不符',
        typedDictKeyAccess: '使用 ["{name}"] 參考 TypedDict 中的項目',
        typedDictNotAllowed: '執行個體或類別檢查無法使用 TypedDict',
        unhashableType: '型別 "{type}" 無法雜湊',
        uninitializedAbstractVariable: '執行個體變數 "{name}" 在抽象基底類別 "{classType}" 中定義，但未初始化',
        unreachableExcept: '"{exceptionType}" 是 "{parentType}" 的子類別',
        useDictInstead: '使用 Dict[T1, T2] 來表示字典型別',
        useListInstead: '使用 List[T] 來指出 list 類型，或使用 Union[T1, T2] 來指出 union 類型',
        useTupleInstead: '使用 tuple[T1, ..., Tn] 來指出 tuple 類型，或使用 Union[T1, T2] 來指出 union 類型',
        useTypeInstead: '改為使用 Type[T]',
        varianceMismatchForClass: '型別引數 "{typeVarName}" 的變異數與基底類別 "{className}" 不相容',
        varianceMismatchForTypeAlias: '型別引數 "{typeVarName}" 的變異數與 "{typeAliasParam}" 不相容'
      },
      Service: {
        longOperation: '列舉工作區來源檔案需要很長的時間。請考慮改為開啟子資料夾。[深入了解](https://aka.ms/workspace-too-many-files)'
      }
    };
  }
}; //# sourceMappingURL=pyright.bundle.js.map