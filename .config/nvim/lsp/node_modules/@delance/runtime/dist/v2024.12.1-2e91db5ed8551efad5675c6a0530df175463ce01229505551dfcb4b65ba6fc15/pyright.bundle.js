"use strict";

exports.id = 344;
exports.ids = [344];
exports.modules = {
  1811: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.nullCallback = undefined;
    exports.analyzeProgram = function (e, n, a, r, s, p) {
      let d = false;
      r = r ?? exports.nullCallback;
      try {
        i.throwIfCancellationRequested(p);
        const t = new l.Duration();
        d = e.analyze(n, p);
        const s = e.getFilesToAnalyzeCount();
        const o = n !== undefined;
        const c = e.getDiagnostics(a, o);
        const u = c.length;
        const m = t.getDurationInSeconds();
        if (u > 0 || !d) {
          r({
            diagnostics: c,
            filesInProgram: e.getFileCount(),
            requiringAnalysisCount: s,
            checkingOnlyOpenFiles: e.isCheckingOnlyOpenFiles(),
            fatalErrorOccurred: false,
            configParseErrorOccurred: false,
            elapsedTime: m,
            reason: 'analysis'
          });
        }
      } catch (e) {
        if (i.OperationCanceledException.is(e)) {
          return false;
        }
        const t = o.getErrorString(e);
        s.error(`Error performing analysis: ${t}`);
        r({
          diagnostics: [],
          filesInProgram: 0,
          requiringAnalysisCount: {
            files: 0,
            cells: 0
          },
          checkingOnlyOpenFiles: true,
          fatalErrorOccurred: true,
          configParseErrorOccurred: false,
          elapsedTime: 0,
          error: o.getSerializableError(e),
          reason: 'analysis'
        });
      }
      return d;
    };
    const i = require(91426);
    const o = __importStar(require(48281));
    const l = require(71582);
    exports.nullCallback = () => {};
  },
  12673: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.isAnnotationEvaluationPostponed = function (e) {
      if (e.isStubFile) {
        return true;
      }
      if (e.futureImports.has('annotations')) {
        return true;
      }
      if (a.PythonVersion.isGreaterOrEqualTo(e.executionEnvironment.pythonVersion, a.pythonVersion3_14)) {
        return true;
      }
      return false;
    };
    const a = require(63808);
  },
  26687: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.cleanNodeAnalysisInfo = function (e) {
      const t = s(e);
      if (t == null ? undefined : t.scope) {
        t.scope = undefined;
      }
      if (t == null ? undefined : t.declaration) {
        t.declaration = undefined;
      }
      if (t == null ? undefined : t.flowNode) {
        t.flowNode = undefined;
      }
      if (t == null ? undefined : t.afterFlowNode) {
        t.afterFlowNode = undefined;
      }
      if (t == null ? undefined : t.fileInfo) {
        t.fileInfo = undefined;
      }
      if (t == null ? undefined : t.codeFlowExpressions) {
        t.codeFlowExpressions = undefined;
      }
      if (t == null ? undefined : t.codeFlowComplexity) {
        t.codeFlowComplexity = undefined;
      }
      if (t == null ? undefined : t.dunderAllInfo) {
        t.dunderAllInfo = undefined;
      }
      if (t == null ? undefined : t.typeParamSymbol) {
        t.typeParamSymbol = undefined;
      }
    };
    exports.getImportInfo = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.importInfo;
      }
    };
    exports.setImportInfo = function (e, t) {
      i(e).importInfo = t;
    };
    exports.getScope = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.scope;
      }
    };
    exports.setScope = function (e, t) {
      i(e).scope = t;
    };
    exports.getDeclaration = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.declaration;
      }
    };
    exports.setDeclaration = function (e, t) {
      i(e).declaration = t;
    };
    exports.getFlowNode = r;
    exports.setFlowNode = function (e, t) {
      i(e).flowNode = t;
    };
    exports.getAfterFlowNode = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.afterFlowNode;
      }
    };
    exports.setAfterFlowNode = function (e, t) {
      i(e).afterFlowNode = t;
    };
    exports.getFileInfo = function (e) {
      while (e.nodeType !== 36) {
        e = e.parent;
      }
      return s(e).fileInfo;
    };
    exports.setFileInfo = function (e, t) {
      i(e).fileInfo = t;
    };
    exports.getCodeFlowExpressions = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.codeFlowExpressions;
      }
    };
    exports.setCodeFlowExpressions = function (e, t) {
      i(e).codeFlowExpressions = t;
    };
    exports.getCodeFlowComplexity = function (e) {
      var t;
      const n = s(e);
      if ((t = n == null ? undefined : n.codeFlowComplexity) !== null && t !== undefined) {
        return t;
      } else {
        return 0;
      }
    };
    exports.setCodeFlowComplexity = function (e, t) {
      i(e).codeFlowComplexity = t;
    };
    exports.getDunderAllInfo = function (e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.dunderAllInfo;
      }
    };
    exports.setDunderAllInfo = function (e, t) {
      i(e).dunderAllInfo = t;
    };
    exports.isCodeUnreachable = function (e) {
      let t = e;
      while (t) {
        const e = r(t);
        if (e) {
          return !!(e.flags & a.FlowFlags.Unreachable);
        }
        t = t.parent;
      }
      return false;
    };
    const a = require(50299);
    function r(e) {
      const t = s(e);
      if (t == null) {
        return undefined;
      } else {
        return t.flowNode;
      }
    }
    function s(e) {
      return e.a;
    }
    function i(e) {
      let t = e.a;
      if (!t) {
        e.a = t = {};
      }
      return t;
    }
  },
  82695: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.BackgroundAnalysisProgram = exports.InvalidatedReason = undefined;
    require(23070);
    const a = require(1811);
    const r = require(79253);
    var s;
    (function (e) {
      e[e.Reanalyzed = 0] = 'Reanalyzed';
      e[e.SourceWatcherChanged = 1] = 'SourceWatcherChanged';
      e[e.LibraryWatcherChanged = 2] = 'LibraryWatcherChanged';
      e[e.LibraryWatcherContentOnlyChanged = 3] = 'LibraryWatcherContentOnlyChanged';
    })(s || (exports.InvalidatedReason = s = {}));
    exports.BackgroundAnalysisProgram = class {
      constructor(e, t, n, a, s, i, o) {
        var l;
        this.serviceId = e;
        this._serviceProvider = t;
        this._configOptions = n;
        this._importResolver = a;
        this._backgroundAnalysis = s;
        this._maxAnalysisTime = i;
        this._disableChecker = o;
        this._disposed = false;
        this._program = new r.Program(this.importResolver, this.configOptions, this._serviceProvider, undefined, this._disableChecker, e);
        if ((l = this._backgroundAnalysis) !== null && l !== undefined) {
          l.setProgramView(this._program);
        }
      }
      get configOptions() {
        return this._configOptions;
      }
      get importResolver() {
        return this._importResolver;
      }
      get program() {
        return this._program;
      }
      get host() {
        return this._importResolver.host;
      }
      get backgroundAnalysis() {
        return this._backgroundAnalysis;
      }
      hasSourceFile(e) {
        return !!this._program.getSourceFile(e);
      }
      setConfigOptions(e) {
        var t;
        this._configOptions = e;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.setConfigOptions(e);
        }
        this._program.setConfigOptions(e);
      }
      setImportResolver(e) {
        var t;
        this._importResolver = e;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.setImportResolver(e);
        }
        this._program.setImportResolver(e);
        this.configOptions.getExecutionEnvironments().forEach(e => this._ensurePartialStubPackages(e));
      }
      setTrackedFiles(e) {
        var t;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.setTrackedFiles(e);
        }
        const n = this._program.setTrackedFiles(e);
        this._reportDiagnosticsForRemovedFiles(n);
      }
      setAllowedThirdPartyImports(e) {
        var t;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.setAllowedThirdPartyImports(e);
        }
        this._program.setAllowedThirdPartyImports(e);
      }
      setFileOpened(e, t, n, a) {
        var r;
        if ((r = this._backgroundAnalysis) !== null && r !== undefined) {
          r.setFileOpened(e, t, n, a);
        }
        this._program.setFileOpened(e, t, n, a);
      }
      getChainedUri(e) {
        return this._program.getChainedUri(e);
      }
      updateChainedUri(e, t) {
        var n;
        if ((n = this._backgroundAnalysis) !== null && n !== undefined) {
          n.updateChainedUri(e, t);
        }
        this._program.updateChainedUri(e, t);
      }
      updateOpenFileContents(e, t, n, a) {
        var r;
        if ((r = this._backgroundAnalysis) !== null && r !== undefined) {
          r.setFileOpened(e, t, n, a);
        }
        this._program.setFileOpened(e, t, n, a);
        this.markFilesDirty([e], true);
      }
      setFileClosed(e, t) {
        var n;
        if ((n = this._backgroundAnalysis) !== null && n !== undefined) {
          n.setFileClosed(e, t);
        }
        const a = this._program.setFileClosed(e, t);
        this._reportDiagnosticsForRemovedFiles(a);
      }
      addInterimFile(e) {
        var t;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.addInterimFile(e);
        }
        this._program.addInterimFile(e);
      }
      markAllFilesDirty(e) {
        var t;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.markAllFilesDirty(e);
        }
        this._program.markAllFilesDirty(e);
      }
      markFilesDirty(e, t) {
        var n;
        if ((n = this._backgroundAnalysis) !== null && n !== undefined) {
          n.markFilesDirty(e, t);
        }
        this._program.markFilesDirty(e, t);
      }
      setCompletionCallback(e) {
        var t;
        this._onAnalysisCompletion = e;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.setCompletionCallback(e);
        }
      }
      startAnalysis(e) {
        if (this._backgroundAnalysis) {
          this._backgroundAnalysis.startAnalysis(e);
          return false;
        } else {
          return a.analyzeProgram(this._program, this._maxAnalysisTime, this._configOptions, this._onAnalysisCompletion, this._serviceProvider.console(), e);
        }
      }
      async analyzeFile(e, t) {
        if (this._backgroundAnalysis) {
          return this._backgroundAnalysis.analyzeFile(e, t);
        } else {
          return this._program.analyzeFile(e, t);
        }
      }
      libraryUpdated() {
        return false;
      }
      async getDiagnosticsForRange(e, t, n) {
        if (this._backgroundAnalysis) {
          return this._backgroundAnalysis.getDiagnosticsForRange(e, t, n);
        } else {
          return this._program.getDiagnosticsForRange(e, t);
        }
      }
      async writeTypeStub(e, t, n, r) {
        if (this._backgroundAnalysis) {
          return this._backgroundAnalysis.writeTypeStub(e, t, n, r);
        } else {
          a.analyzeProgram(this._program, undefined, this._configOptions, this._onAnalysisCompletion, this._serviceProvider.console(), r);
          return this._program.writeTypeStub(e, t, n, r);
        }
      }
      invalidateAndForceReanalysis(e) {
        var t;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.invalidateAndForceReanalysis(e);
        }
        this._importResolver.invalidateCache();
        this._program.markAllFilesDirty(true);
      }
      restart() {
        var e;
        if ((e = this._backgroundAnalysis) !== null && e !== undefined) {
          e.restart();
        }
      }
      dispose() {
        var e;
        var t;
        if (!this._disposed) {
          this._disposed = true;
          this._program.dispose();
          if ((e = this._backgroundAnalysis) !== null && e !== undefined) {
            e.shutdown();
          }
          if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
            t.dispose();
          }
        }
      }
      enterEditMode() {
        this._preEditAnalysis = this._backgroundAnalysis;
        this._backgroundAnalysis = undefined;
        this._program.enterEditMode();
      }
      exitEditMode() {
        this._backgroundAnalysis = this._preEditAnalysis;
        this._preEditAnalysis = undefined;
        return this._program.exitEditMode();
      }
      _ensurePartialStubPackages(e) {
        var t;
        var n;
        if ((t = this._backgroundAnalysis) !== null && t !== undefined) {
          t.ensurePartialStubPackages((n = e.root) === null || n === undefined ? undefined : n.toString());
        }
        return this._importResolver.ensurePartialStubPackages(e);
      }
      _reportDiagnosticsForRemovedFiles(e) {
        if (e.length !== 0 && !this._backgroundAnalysis && this._onAnalysisCompletion) {
          this._onAnalysisCompletion({
            diagnostics: e,
            filesInProgram: this._program.getFileCount(),
            requiringAnalysisCount: this._program.getFilesToAnalyzeCount(),
            checkingOnlyOpenFiles: this._program.isCheckingOnlyOpenFiles(),
            fatalErrorOccurred: false,
            configParseErrorOccurred: false,
            elapsedTime: 0,
            reason: 'tracking'
          });
        }
      }
    };
  },
  15157: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DummyScopeGenerator = exports.ReturnFinder = exports.YieldFinder = exports.Binder = undefined;
    const i = require(58147);
    const o = require(48281);
    const l = require(65880);
    const p = require(54010);
    const d = require(56814);
    const c = require(88754);
    const u = require(27113);
    const m = require(67703);
    const y = __importStar(require(26687));
    const g = require(50299);
    const h = require(28445);
    const f = __importStar(require(41557));
    const T = require(88744);
    const v = require(35197);
    const b = __importStar(require(28676));
    const _ = require(58253);
    const C = require(12097);
    class I extends T.ParseTreeWalker {
      constructor(e, t = false) {
        super();
        this._moduleSymbolOnly = t;
        this._deferredBindingTasks = [];
        this._currentExceptTargets = [];
        this._finallyTargets = [];
        this._typingImportAliases = [];
        this._sysImportAliases = [];
        this._dataclassesImportAliases = [];
        this._typingSymbolAliases = new Map();
        this._dataclassesSymbolAliases = new Map();
        this._dunderAllStringNodes = [];
        this._usesUnsupportedDunderAllForm = false;
        this._isInExceptSuite = false;
        this._isInAnnotatedAnnotation = false;
        this._potentialHiddenSymbols = new Map();
        this._potentialPrivateSymbols = new Map();
        this._codeFlowComplexity = 0;
        this._fileInfo = e;
      }
      bindModule(e) {
        var t;
        const n = this._fileInfo.builtinsScope === undefined;
        this._addTypingImportAliasesFromBuiltinsScope();
        this._createNewScope(n ? 5 : 4, this._fileInfo.builtinsScope, undefined, () => {
          y.setScope(e, this._currentScope);
          y.setFlowNode(e, this._currentFlowNode);
          this._addImplicitSymbolToCurrentScope('__name__', e, 'str');
          this._addImplicitSymbolToCurrentScope('__loader__', e, 'Any');
          this._addImplicitSymbolToCurrentScope('__package__', e, 'str | None');
          this._addImplicitSymbolToCurrentScope('__spec__', e, 'Any');
          this._addImplicitSymbolToCurrentScope('__path__', e, 'Iterable[str]');
          this._addImplicitSymbolToCurrentScope('__file__', e, 'str');
          this._addImplicitSymbolToCurrentScope('__cached__', e, 'str');
          this._addImplicitSymbolToCurrentScope('__dict__', e, 'Dict[str, Any]');
          this._addImplicitSymbolToCurrentScope('__annotations__', e, 'Dict[str, Any]');
          this._addImplicitSymbolToCurrentScope('__builtins__', e, 'Any');
          this._addImplicitSymbolToCurrentScope('__doc__', e, 'str | None');
          this._currentFlowNode = this._createStartFlowNode();
          this._walkStatementsAndReportUnreachable(e.d.statements);
          y.setAfterFlowNode(e, this._currentFlowNode);
          y.setCodeFlowExpressions(e, this._currentScopeCodeFlowExpressions);
          y.setCodeFlowComplexity(e, this._codeFlowComplexity);
        });
        this._bindDeferred();
        this._potentialHiddenSymbols.forEach((e, t) => {
          var n;
          if (!((n = this._dunderAllNames) === null || n === undefined ? undefined : n.some(e => e === t))) {
            if (this._fileInfo.isStubFile) {
              e.setIsExternallyHidden();
            } else {
              e.setPrivatePyTypedImport();
            }
          }
        });
        this._potentialPrivateSymbols.forEach((e, t) => {
          var n;
          if (!((n = this._dunderAllNames) === null || n === undefined ? undefined : n.some(e => e === t))) {
            e.setIsPrivateMember();
          }
        });
        if (this._dunderAllNames) {
          y.setDunderAllInfo(e, {
            names: this._dunderAllNames,
            stringNodes: this._dunderAllStringNodes,
            usesUnsupportedDunderAllForm: this._usesUnsupportedDunderAllForm
          });
        } else {
          y.setDunderAllInfo(e, undefined);
        }
        const a = y.getScope(e);
        if (a && this._dunderAllNames) {
          for (const e of this._dunderAllNames) {
            if ((t = a.symbolTable.get(e)) !== null && t !== undefined) {
              t.setIsInDunderAll();
            }
          }
        }
      }
      visitModule(e) {
        o.fail('We should never get here');
        return false;
      }
      visitSuite(e) {
        this._walkStatementsAndReportUnreachable(e.d.statements);
        return false;
      }
      visitModuleName(e) {
        const t = y.getImportInfo(e);
        o.assert(t !== undefined);
        if (t.isNativeLib) {
          return true;
        }
        if (!t.isImportFound) {
          this._addDiagnostic(l.DiagnosticRule.reportMissingImports, m.LocMessage.importResolveFailure().format({
            importName: t.importName,
            venv: this._fileInfo.executionEnvironment.name
          }), e);
          return true;
        }
        if (!t.isStubFile && t.importType === 1 && !t.pyTypedInfo) {
          const n = this._addDiagnostic(l.DiagnosticRule.reportMissingTypeStubs, m.LocMessage.stubFileMissing().format({
            importName: t.importName
          }), e);
          if (n) {
            const e = {
              action: 'pyright.createtypestub',
              moduleName: t.importName
            };
            n.addAction(e);
          }
        }
        return true;
      }
      visitClass(e) {
        this.walkMultiple(e.d.decorators);
        const t = {
          type: 6,
          node: e,
          uri: this._fileInfo.fileUri,
          range: d.convertTextRangeToRange(e.d.name, this._fileInfo.lines),
          moduleName: this._fileInfo.moduleName,
          isInExceptSuite: this._isInExceptSuite
        };
        const n = this._bindNameToScope(this._currentScope, e.d.name);
        let a;
        if (n) {
          n.addDeclaration(t);
        }
        y.setDeclaration(e, t);
        if (e.d.typeParams) {
          this.walk(e.d.typeParams);
          a = y.getScope(e.d.typeParams);
        }
        this.walkMultiple(e.d.arguments);
        this._createNewScope(3, a ?? this._getNonClassParentScope(), undefined, () => {
          y.setScope(e, this._currentScope);
          this._addImplicitSymbolToCurrentScope('__doc__', e, 'str | None');
          this._addImplicitSymbolToCurrentScope('__module__', e, 'str');
          this._addImplicitSymbolToCurrentScope('__qualname__', e, 'str');
          this._dunderSlotsEntries = undefined;
          if (!this._moduleSymbolOnly) {
            this.walk(e.d.suite);
          }
          if (this._dunderSlotsEntries) {
            this._addSlotsToCurrentScope(this._dunderSlotsEntries);
          }
          this._dunderSlotsEntries = undefined;
        });
        this._createAssignmentTargetFlowNodes(e.d.name, false, false);
        return false;
      }
      visitFunction(e) {
        this._createVariableAnnotationFlowNode();
        y.setFlowNode(e, this._currentFlowNode);
        const t = this._bindNameToScope(this._currentScope, e.d.name);
        const n = f.getEnclosingClass(e, true);
        const a = {
          type: 5,
          node: e,
          isMethod: !!n,
          isGenerator: false,
          uri: this._fileInfo.fileUri,
          range: d.convertTextRangeToRange(e.d.name, this._fileInfo.lines),
          moduleName: this._fileInfo.moduleName,
          isInExceptSuite: this._isInExceptSuite
        };
        let r;
        if (t) {
          t.addDeclaration(a);
        }
        y.setDeclaration(e, a);
        e.d.params.forEach(e => {
          if (e.d.defaultValue) {
            this.walk(e.d.defaultValue);
          }
        });
        if (e.d.typeParams) {
          this.walk(e.d.typeParams);
          r = y.getScope(e.d.typeParams);
        }
        this.walkMultiple(e.d.decorators);
        e.d.params.forEach(e => {
          if (e.d.annotation) {
            this.walk(e.d.annotation);
          }
          if (e.d.annotationComment) {
            this.walk(e.d.annotationComment);
          }
        });
        if (e.d.returnAnnotation) {
          this.walk(e.d.returnAnnotation);
        }
        if (e.d.funcAnnotationComment) {
          this.walk(e.d.funcAnnotationComment);
        }
        this._createNewScope(2, r ?? this._getNonClassParentScope(), undefined, () => {
          y.setScope(e, this._currentScope);
          if (f.getEnclosingClass(e)) {
            this._addImplicitSymbolToCurrentScope('__class__', e, 'type[self]');
          }
          this._deferBinding(() => {
            this._currentFlowNode = this._createStartFlowNode();
            this._codeFlowComplexity = 0;
            e.d.params.forEach(e => {
              if (e.d.name) {
                const t = this._bindNameToScope(this._currentScope, e.d.name);
                if (t) {
                  const n = {
                    type: 2,
                    node: e,
                    uri: this._fileInfo.fileUri,
                    range: d.convertTextRangeToRange(e, this._fileInfo.lines),
                    moduleName: this._fileInfo.moduleName,
                    isInExceptSuite: this._isInExceptSuite
                  };
                  t.addDeclaration(n);
                  y.setDeclaration(e.d.name, n);
                }
                this._createFlowAssignment(e.d.name);
              }
            });
            this._targetFunctionDeclaration = a;
            this._currentReturnTarget = this._createBranchLabel();
            this.walk(e.d.suite);
            this._targetFunctionDeclaration = undefined;
            y.setAfterFlowNode(e.d.suite, this._currentFlowNode);
            this._addAntecedent(this._currentReturnTarget, this._currentFlowNode);
            const t = this._finishFlowLabel(this._currentReturnTarget);
            y.setAfterFlowNode(e, t);
            y.setCodeFlowExpressions(e, this._currentScopeCodeFlowExpressions);
            y.setCodeFlowComplexity(e, this._codeFlowComplexity);
          });
        });
        this._createAssignmentTargetFlowNodes(e.d.name, false, false);
        return false;
      }
      visitLambda(e) {
        this._createVariableAnnotationFlowNode();
        y.setFlowNode(e, this._currentFlowNode);
        e.d.params.forEach(e => {
          if (e.d.defaultValue) {
            this.walk(e.d.defaultValue);
          }
        });
        this._createNewScope(2, this._getNonClassParentScope(), undefined, () => {
          y.setScope(e, this._currentScope);
          this._deferBinding(() => {
            this._currentFlowNode = this._createStartFlowNode();
            e.d.params.forEach(e => {
              if (e.d.name) {
                const t = this._bindNameToScope(this._currentScope, e.d.name);
                if (t) {
                  const n = {
                    type: 2,
                    node: e,
                    uri: this._fileInfo.fileUri,
                    range: d.convertTextRangeToRange(e, this._fileInfo.lines),
                    moduleName: this._fileInfo.moduleName,
                    isInExceptSuite: this._isInExceptSuite
                  };
                  t.addDeclaration(n);
                  y.setDeclaration(e.d.name, n);
                }
                this._createFlowAssignment(e.d.name);
                this.walk(e.d.name);
                y.setFlowNode(e, this._currentFlowNode);
              }
            });
            this.walk(e.d.expr);
            y.setCodeFlowExpressions(e, this._currentScopeCodeFlowExpressions);
          });
        });
        return false;
      }
      visitCall(e) {
        var t;
        var n;
        this._disableTrueFalseTargets(() => {
          this.walk(e.d.leftExpr);
          f.getArgsByRuntimeOrder(e).forEach(e => {
            if (this._currentFlowNode) {
              y.setFlowNode(e, this._currentFlowNode);
            }
            this.walk(e);
          });
        });
        if (!f.isNodeContainedWithinNodeType(e, 16) && !this._isInAnnotatedAnnotation) {
          this._createCallFlowNode(e);
        }
        if (this._currentScope.type === 4 && e.d.leftExpr.nodeType === 35 && e.d.leftExpr.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.leftExpr.d.value === '__all__') {
          let a = true;
          if (e.d.leftExpr.d.member.d.value === 'extend' && e.d.args.length === 1) {
            const t = e.d.args[0].d.valueExpr;
            if (t.nodeType === 34) {
              if (t.d.items.every(e => {
                var t;
                var n;
                return e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49 && ((t = this._dunderAllNames) === null || t === undefined || t.push(e.d.strings[0].d.value), (n = this._dunderAllStringNodes) === null || n === undefined || n.push(e.d.strings[0]), true);
              })) {
                a = false;
              }
            } else {
              if (t.nodeType === 35 && t.d.leftExpr.nodeType === 38 && t.d.member.d.value === '__all__') {
                const e = this._getDunderAllNamesFromImport(t.d.leftExpr.d.value);
                if (e && e.length > 0) {
                  e.forEach(e => {
                    var t;
                    if ((t = this._dunderAllNames) !== null && t !== undefined) {
                      t.push(e);
                    }
                  });
                }
                a = false;
              }
            }
          } else {
            if (e.d.leftExpr.d.member.d.value === 'remove' && e.d.args.length === 1) {
              const t = e.d.args[0].d.valueExpr;
              if (t.nodeType === 48 && t.d.strings.length === 1 && t.d.strings[0].nodeType === 49 && this._dunderAllNames) {
                this._dunderAllNames = this._dunderAllNames.filter(e => e !== t.d.strings[0].d.value);
                this._dunderAllStringNodes = this._dunderAllStringNodes.filter(e => e.d.value !== t.d.strings[0].d.value);
                a = false;
              }
            } else {
              if (e.d.leftExpr.d.member.d.value === 'append' && e.d.args.length === 1) {
                const r = e.d.args[0].d.valueExpr;
                if (r.nodeType === 48 && r.d.strings.length === 1 && r.d.strings[0].nodeType === 49) {
                  if ((t = this._dunderAllNames) !== null && t !== undefined) {
                    t.push(r.d.strings[0].d.value);
                  }
                  if ((n = this._dunderAllStringNodes) !== null && n !== undefined) {
                    n.push(r.d.strings[0]);
                  }
                  a = false;
                }
              }
            }
          }
          if (a) {
            this._usesUnsupportedDunderAllForm = true;
            this._addDiagnostic(l.DiagnosticRule.reportUnsupportedDunderAll, m.LocMessage.unsupportedDunderAllOperation(), e);
          }
        }
        return false;
      }
      visitTypeParameterList(e) {
        const t = new v.Scope(0, this._getNonClassParentScope(), this._currentScope);
        e.d.params.forEach(e => {
          if (e.d.boundExpr) {
            this.walk(e.d.boundExpr);
          }
        });
        const n = new Set();
        e.d.params.forEach(a => {
          const r = a.d.name;
          const s = t.addSymbol(r.d.value, 0);
          const i = {
            type: 3,
            node: a,
            uri: this._fileInfo.fileUri,
            range: d.convertTextRangeToRange(e, this._fileInfo.lines),
            moduleName: this._fileInfo.moduleName,
            isInExceptSuite: this._isInExceptSuite
          };
          s.addDeclaration(i);
          y.setDeclaration(r, i);
          if (n.has(r.d.value)) {
            this._addSyntaxError(m.LocMessage.typeParameterExistingTypeParameter().format({
              name: r.d.value
            }), r);
          } else {
            n.add(r.d.value);
          }
        });
        e.d.params.forEach(e => {
          if (e.d.defaultExpr) {
            this.walk(e.d.defaultExpr);
          }
        });
        y.setScope(e, t);
        return false;
      }
      visitTypeAlias(e) {
        let t;
        this._bindNameToScope(this._currentScope, e.d.name);
        this.walk(e.d.name);
        if (e.d.typeParams) {
          this.walk(e.d.typeParams);
          t = y.getScope(e.d.typeParams);
        }
        const n = {
          type: 4,
          node: e,
          uri: this._fileInfo.fileUri,
          range: d.convertTextRangeToRange(e.d.name, this._fileInfo.lines),
          moduleName: this._fileInfo.moduleName,
          isInExceptSuite: this._isInExceptSuite,
          docString: this._getVariableDocString(e.d.expr)
        };
        const a = this._bindNameToScope(this._currentScope, e.d.name);
        if (a) {
          a.addDeclaration(n);
        }
        y.setDeclaration(e, n);
        this._createAssignmentTargetFlowNodes(e.d.name, true, false);
        const r = this._currentScope;
        this._currentScope = t ?? this._currentScope;
        this.walk(e.d.expr);
        this._currentScope = r;
        return false;
      }
      visitAssignment(e) {
        if (this._handleTypingStubAssignmentOrAnnotation(e)) {
          return false;
        }
        this._bindPossibleTupleNamedTarget(e.d.leftExpr);
        if (e.d.annotationComment) {
          this.walk(e.d.annotationComment);
          this._addTypeDeclarationForVariable(e.d.leftExpr, e.d.annotationComment);
        }
        if (e.d.chainedAnnotationComment) {
          this._addDiagnostic(l.DiagnosticRule.reportInvalidTypeForm, m.LocMessage.annotationNotSupported(), e.d.chainedAnnotationComment);
        }
        if (e.d.leftExpr.nodeType === 27) {
          const t = e.d.leftExpr;
          if (t.d.items.length === 1 && !t.d.trailingComma && t.d.items[0].d.valueExpr.nodeType === 48 && g.isCodeFlowSupportedForReference(t.d.leftExpr)) {
            const e = g.createKeyForReference(t.d.leftExpr);
            this._currentScopeCodeFlowExpressions.add(e);
          }
        }
        this.walk(e.d.rightExpr);
        let t = true;
        if (f.getEnclosingFunction(e) || e.d.rightExpr.nodeType === 9 && this._fileInfo.isTypingStubFile || f.isWithinLoop(e)) {
          t = false;
        }
        this._addInferredTypeAssignmentForVariable(e.d.leftExpr, e.d.rightExpr, t);
        this._createAssignmentTargetFlowNodes(e.d.leftExpr, true, false);
        if (this._currentScope.type === 4 && (e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === '__all__' || e.d.leftExpr.nodeType === 54 && e.d.leftExpr.d.valueExpr.nodeType === 38 && e.d.leftExpr.d.valueExpr.d.value === '__all__')) {
          const t = e.d.rightExpr;
          this._dunderAllNames = [];
          let n = false;
          if (t.nodeType === 34) {
            t.d.items.forEach(e => {
              if (e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49) {
                this._dunderAllNames.push(e.d.strings[0].d.value);
                this._dunderAllStringNodes.push(e.d.strings[0]);
              } else {
                n = true;
              }
            });
          } else {
            if (t.nodeType === 52) {
              t.d.items.forEach(e => {
                if (e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49) {
                  this._dunderAllNames.push(e.d.strings[0].d.value);
                  this._dunderAllStringNodes.push(e.d.strings[0]);
                } else {
                  n = true;
                }
              });
            } else {
              n = true;
            }
          }
          if (n) {
            this._usesUnsupportedDunderAllForm = true;
            this._addDiagnostic(l.DiagnosticRule.reportUnsupportedDunderAll, m.LocMessage.unsupportedDunderAllOperation(), e);
          }
        }
        if (this._currentScope.type === 3 && (e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === '__slots__' || e.d.leftExpr.nodeType === 54 && e.d.leftExpr.d.valueExpr.nodeType === 38 && e.d.leftExpr.d.valueExpr.d.value === '__slots__')) {
          const t = e.d.rightExpr;
          this._dunderSlotsEntries = [];
          let n = true;
          if (t.nodeType === 48) {
            this._dunderSlotsEntries.push(t);
          } else {
            if (t.nodeType === 34) {
              t.d.items.forEach(e => {
                if (e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49) {
                  this._dunderSlotsEntries.push(e);
                } else {
                  n = false;
                }
              });
            } else {
              if (t.nodeType === 52) {
                t.d.items.forEach(e => {
                  if (e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49) {
                    this._dunderSlotsEntries.push(e);
                  } else {
                    n = false;
                  }
                });
              } else {
                n = false;
              }
            }
          }
          if (!n) {
            this._dunderSlotsEntries = undefined;
          }
        }
        return false;
      }
      visitAssignmentExpression(e) {
        this._disableTrueFalseTargets(() => {
          this.walk(e.d.rightExpr);
        });
        const t = f.getEvaluationNodeForAssignmentExpression(e);
        if (t) {
          const n = y.getScope(t);
          let a = this._currentScope;
          while (a && a !== n) {
            if (a.lookUpSymbol(e.d.name.d.value)) {
              this._addSyntaxError(m.LocMessage.assignmentExprComprehension().format({
                name: e.d.name.d.value
              }), e.d.name);
              break;
            }
            a = a.parent;
          }
          this._bindNameToScope(n, e.d.name);
          this._addInferredTypeAssignmentForVariable(e.d.name, e.d.rightExpr);
          this._createAssignmentTargetFlowNodes(e.d.name, true, false);
        } else {
          this._addSyntaxError(m.LocMessage.assignmentExprContext(), e);
          this.walk(e.d.name);
        }
        return false;
      }
      visitAugmentedAssignment(e) {
        this.walk(e.d.leftExpr);
        this.walk(e.d.rightExpr);
        this._bindPossibleTupleNamedTarget(e.d.destExpr);
        this._createAssignmentTargetFlowNodes(e.d.destExpr, false, false);
        if (e.d.operator === 1 && this._currentScope.type === 4 && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === '__all__') {
          const t = e.d.rightExpr;
          let n = true;
          if (t.nodeType === 34) {
            t.d.items.forEach(e => {
              var t;
              if (e.nodeType === 48 && e.d.strings.length === 1 && e.d.strings[0].nodeType === 49) {
                if ((t = this._dunderAllNames) !== null && t !== undefined) {
                  t.push(e.d.strings[0].d.value);
                }
                this._dunderAllStringNodes.push(e.d.strings[0]);
              }
            });
            n = false;
          } else {
            if (t.nodeType === 35 && t.d.leftExpr.nodeType === 38 && t.d.member.d.value === '__all__') {
              const e = this._getDunderAllNamesFromImport(t.d.leftExpr.d.value);
              if (e) {
                e.forEach(e => {
                  var t;
                  if ((t = this._dunderAllNames) !== null && t !== undefined) {
                    t.push(e);
                  }
                });
                n = false;
              }
            }
          }
          if (n) {
            this._usesUnsupportedDunderAllForm = true;
            this._addDiagnostic(l.DiagnosticRule.reportUnsupportedDunderAll, m.LocMessage.unsupportedDunderAllOperation(), e);
          }
        }
        return false;
      }
      visitDel(e) {
        e.d.targets.forEach(e => {
          this._bindPossibleTupleNamedTarget(e);
          this.walk(e);
          this._createAssignmentTargetFlowNodes(e, false, true);
        });
        return false;
      }
      visitTypeAnnotation(e) {
        var t;
        if (this._handleTypingStubAssignmentOrAnnotation(e)) {
          return false;
        }
        const n = ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 3 && f.getEnclosingClass(e, true) !== undefined;
        if (!n) {
          this.walk(e.d.annotation);
        }
        this._createVariableAnnotationFlowNode();
        this._bindPossibleTupleNamedTarget(e.d.valueExpr);
        this._addTypeDeclarationForVariable(e.d.valueExpr, e.d.annotation);
        if (n) {
          this.walk(e.d.annotation);
        }
        const a = [];
        if (this._isNarrowingExpression(e.d.valueExpr, a)) {
          a.forEach(e => {
            const t = g.createKeyForReference(e);
            this._currentScopeCodeFlowExpressions.add(t);
          });
        }
        this.walk(e.d.valueExpr);
        return false;
      }
      visitFor(e) {
        this._bindPossibleTupleNamedTarget(e.d.targetExpr);
        this._addInferredTypeAssignmentForVariable(e.d.targetExpr, e);
        this.walk(e.d.iterableExpr);
        const t = this._createLoopLabel();
        const n = this._createBranchLabel();
        const a = this._createBranchLabel();
        this._addAntecedent(t, this._currentFlowNode);
        this._currentFlowNode = t;
        this._addAntecedent(n, this._currentFlowNode);
        const r = this._trackCodeFlowExpressions(() => {
          this._createAssignmentTargetFlowNodes(e.d.targetExpr, true, false);
        });
        this._bindLoopStatement(t, a, () => {
          this.walk(e.d.forSuite);
          this._addAntecedent(t, this._currentFlowNode);
          r.forEach(e => {
            var t;
            if ((t = this._currentScopeCodeFlowExpressions) !== null && t !== undefined) {
              t.add(e);
            }
          });
        });
        this._currentFlowNode = this._finishFlowLabel(n);
        if (e.d.elseSuite) {
          this.walk(e.d.elseSuite);
        }
        this._addAntecedent(a, this._currentFlowNode);
        this._currentFlowNode = this._finishFlowLabel(a);
        if (e.d.asyncToken && !this._fileInfo.ipythonMode) {
          const t = f.getEnclosingFunction(e);
          if (!t || !t.d.isAsync) {
            this._addSyntaxError(m.LocMessage.asyncNotInAsyncFunction(), e.d.asyncToken);
          }
        }
        return false;
      }
      visitContinue(e) {
        if (this._currentContinueTarget) {
          this._addAntecedent(this._currentContinueTarget, this._currentFlowNode);
        }
        this._currentFlowNode = I._unreachableFlowNode;
        return false;
      }
      visitBreak(e) {
        if (this._currentBreakTarget) {
          this._addAntecedent(this._currentBreakTarget, this._currentFlowNode);
        }
        this._currentFlowNode = I._unreachableFlowNode;
        return false;
      }
      visitReturn(e) {
        if (this._targetFunctionDeclaration) {
          if (!this._targetFunctionDeclaration.returnStatements) {
            this._targetFunctionDeclaration.returnStatements = [];
          }
          this._targetFunctionDeclaration.returnStatements.push(e);
        }
        if (e.d.expr) {
          this.walk(e.d.expr);
        }
        y.setFlowNode(e, this._currentFlowNode);
        if (this._currentReturnTarget) {
          this._addAntecedent(this._currentReturnTarget, this._currentFlowNode);
        }
        this._finallyTargets.forEach(e => {
          this._addAntecedent(e, this._currentFlowNode);
        });
        this._currentFlowNode = I._unreachableFlowNode;
        return false;
      }
      visitYield(e) {
        if (this._isInComprehension(e, true)) {
          this._addSyntaxError(m.LocMessage.yieldWithinComprehension(), e);
        }
        this._bindYield(e);
        return false;
      }
      visitYieldFrom(e) {
        if (this._isInComprehension(e, true)) {
          this._addSyntaxError(m.LocMessage.yieldWithinComprehension(), e);
        }
        this._bindYield(e);
        return false;
      }
      visitMemberAccess(e) {
        this.walk(e.d.leftExpr);
        y.setFlowNode(e, this._currentFlowNode);
        return false;
      }
      visitName(e) {
        y.setFlowNode(e, this._currentFlowNode);
        return false;
      }
      visitIndex(e) {
        y.setFlowNode(e, this._currentFlowNode);
        this.walk(e.d.leftExpr);
        const t = this._isInAnnotatedAnnotation;
        if (this._isTypingAnnotation(e.d.leftExpr, 'Annotated')) {
          this._isInAnnotatedAnnotation = true;
        }
        e.d.items.forEach(e => {
          this.walk(e);
        });
        this._isInAnnotatedAnnotation = t;
        return false;
      }
      visitIf(e) {
        const t = this._currentFlowNode;
        const n = this._createBranchLabel();
        const a = this._createBranchLabel();
        const r = this._createBranchLabel(t);
        r.affectedExpressions = this._trackCodeFlowExpressions(() => {
          const t = b.evaluateStaticBoolLikeExpression(e.d.testExpr, this._fileInfo.executionEnvironment, this._fileInfo.definedConstants, this._typingImportAliases, this._sysImportAliases);
          this._bindConditional(e.d.testExpr, n, a);
          this._currentFlowNode = t === false ? I._unreachableFlowNode : this._finishFlowLabel(n);
          this.walk(e.d.ifSuite);
          this._addAntecedent(r, this._currentFlowNode);
          this._currentFlowNode = t === true ? I._unreachableFlowNode : this._finishFlowLabel(a);
          if (e.d.elseSuite) {
            this.walk(e.d.elseSuite);
          } else {
            this._bindNeverCondition(e.d.testExpr, r, false);
          }
          this._addAntecedent(r, this._currentFlowNode);
          this._currentFlowNode = this._finishFlowLabel(r);
        });
        return false;
      }
      visitWhile(e) {
        const t = this._createBranchLabel();
        const n = this._createBranchLabel();
        const a = this._createBranchLabel();
        const r = b.evaluateStaticBoolLikeExpression(e.d.testExpr, this._fileInfo.executionEnvironment, this._fileInfo.definedConstants, this._typingImportAliases, this._sysImportAliases);
        const s = this._createLoopLabel();
        this._addAntecedent(s, this._currentFlowNode);
        this._currentFlowNode = s;
        this._bindConditional(e.d.testExpr, t, n);
        this._currentFlowNode = r === false ? I._unreachableFlowNode : this._finishFlowLabel(t);
        this._bindLoopStatement(s, a, () => {
          this.walk(e.d.whileSuite);
        });
        this._addAntecedent(s, this._currentFlowNode);
        this._currentFlowNode = r === true ? I._unreachableFlowNode : this._finishFlowLabel(n);
        if (e.d.elseSuite) {
          this.walk(e.d.elseSuite);
        }
        this._addAntecedent(a, this._currentFlowNode);
        this._currentFlowNode = this._finishFlowLabel(a);
        return false;
      }
      visitAssert(e) {
        const t = this._createBranchLabel();
        const n = this._createBranchLabel();
        this._bindConditional(e.d.testExpr, t, n);
        if (e.d.exceptionExpr) {
          this._currentFlowNode = this._finishFlowLabel(n);
          this.walk(e.d.exceptionExpr);
        }
        this._currentFlowNode = this._finishFlowLabel(t);
        return false;
      }
      visitExcept(e) {
        if (e.d.typeExpr) {
          this.walk(e.d.typeExpr);
        }
        if (e.d.name) {
          this.walk(e.d.name);
          const t = this._bindNameToScope(this._currentScope, e.d.name);
          this._createAssignmentTargetFlowNodes(e.d.name, true, false);
          if (t) {
            const n = {
              type: 1,
              node: e.d.name,
              isConstant: C.isConstantName(e.d.name.d.value),
              inferredTypeSource: e,
              uri: this._fileInfo.fileUri,
              range: d.convertTextRangeToRange(e.d.name, this._fileInfo.lines),
              moduleName: this._fileInfo.moduleName,
              isInExceptSuite: this._isInExceptSuite,
              isExplicitBinding: this._currentScope.getBindingType(e.d.name.d.value) !== undefined
            };
            t.addDeclaration(n);
          }
        }
        const t = this._isInExceptSuite;
        this._isInExceptSuite = true;
        this.walk(e.d.exceptSuite);
        this._isInExceptSuite = t;
        if (e.d.name) {
          this._createFlowAssignment(e.d.name, true);
        }
        return false;
      }
      visitRaise(e) {
        if (this._currentFlowNode) {
          this._addExceptTargets(this._currentFlowNode);
        }
        if (this._targetFunctionDeclaration) {
          if (!this._targetFunctionDeclaration.raiseStatements) {
            this._targetFunctionDeclaration.raiseStatements = [];
          }
          this._targetFunctionDeclaration.raiseStatements.push(e);
        }
        if (e.d.expr) {
          this.walk(e.d.expr);
        }
        if (e.d.fromExpr) {
          this.walk(e.d.fromExpr);
        }
        this._finallyTargets.forEach(e => {
          this._addAntecedent(e, this._currentFlowNode);
        });
        this._currentFlowNode = I._unreachableFlowNode;
        return false;
      }
      visitTry(e) {
        const t = this._currentFlowNode;
        const n = e.d.exceptClauses.map(() => this._createBranchLabel());
        const a = this._createBranchLabel(t);
        let r = false;
        const s = this._createBranchLabel(t);
        const i = {
          flags: g.FlowFlags.PreFinallyGate,
          id: this._getUniqueFlowNodeId(),
          antecedent: s
        };
        a.affectedExpressions = this._trackCodeFlowExpressions(() => {
          if (e.d.finallySuite) {
            this._addAntecedent(a, i);
          }
          if (!e.d.exceptClauses.some(e => !e.d.typeExpr)) {
            n.push(s);
          }
          n.forEach(e => {
            this._addAntecedent(e, this._currentFlowNode);
          });
          if (e.d.finallySuite) {
            this._finallyTargets.push(s);
          }
          this._useExceptTargets(n, () => {
            this.walk(e.d.trySuite);
          });
          if (e.d.elseSuite) {
            this.walk(e.d.elseSuite);
          }
          this._addAntecedent(a, this._currentFlowNode);
          if (!this._isCodeUnreachable()) {
            r = true;
          }
          e.d.exceptClauses.forEach((e, t) => {
            this._currentFlowNode = this._finishFlowLabel(n[t]);
            this.walk(e);
            this._addAntecedent(a, this._currentFlowNode);
            if (!this._isCodeUnreachable()) {
              r = true;
            }
          });
          if (e.d.finallySuite) {
            this._finallyTargets.pop();
          }
          this._currentFlowNode = this._finishFlowLabel(a);
        });
        if (e.d.finallySuite) {
          this.walk(e.d.finallySuite);
          const t = {
            flags: g.FlowFlags.PostFinally,
            id: this._getUniqueFlowNodeId(),
            finallyNode: e.d.finallySuite,
            antecedent: this._currentFlowNode,
            preFinallyGate: i
          };
          this._currentFlowNode = r ? t : I._unreachableFlowNode;
        }
        return false;
      }
      visitAwait(e) {
        var t;
        var n;
        var a;
        var r;
        var s;
        var i;
        var o;
        const l = f.getExecutionScopeNode(e);
        if ((l == null ? undefined : l.nodeType) !== 31 || !l.d.isAsync) {
          if (this._fileInfo.ipythonMode && (l == null ? undefined : l.nodeType) === 36) {
            return true;
          }
          if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 11 || ((a = (n = e.parent) === null || n === undefined ? undefined : n.parent) === null || a === undefined ? undefined : a.nodeType) === 34 || ((s = (r = e.parent) === null || r === undefined ? undefined : r.parent) === null || s === undefined ? undefined : s.nodeType) === 45 || ((o = (i = e.parent) === null || i === undefined ? undefined : i.parent) === null || o === undefined ? undefined : o.nodeType) === 18) {
            this._addSyntaxError(m.LocMessage.awaitNotInAsync(), e.d.awaitToken);
          }
        }
        return true;
      }
      visitGlobal(e) {
        const t = this._currentScope.getGlobalScope().scope;
        e.d.targets.forEach(e => {
          const n = e.d.value;
          if (this._currentScope.getBindingType(n) === 0) {
            this._addSyntaxError(m.LocMessage.nonLocalRedefinition().format({
              name: n
            }), e);
          }
          const a = this._currentScope.lookUpSymbolRecursive(n);
          if (a && a.scope === this._currentScope) {
            this._addSyntaxError(m.LocMessage.globalReassignment().format({
              name: n
            }), e);
          }
          this._bindNameToScope(t, e);
          if (this._currentScope !== t) {
            this._currentScope.setBindingType(n, 1);
          }
        });
        return true;
      }
      visitNonlocal(e) {
        const t = this._currentScope.getGlobalScope().scope;
        if (this._currentScope === t) {
          this._addSyntaxError(m.LocMessage.nonLocalInModule(), e);
        } else {
          e.d.targets.forEach(e => {
            const n = e.d.value;
            if (this._currentScope.getBindingType(n) === 1) {
              this._addSyntaxError(m.LocMessage.globalRedefinition().format({
                name: n
              }), e);
            }
            const a = this._currentScope.lookUpSymbolRecursive(n);
            if (a && a.scope === this._currentScope) {
              this._addSyntaxError(m.LocMessage.nonLocalReassignment().format({
                name: n
              }), e);
            } else {
              if (!a || a.scope === t) {
                this._addSyntaxError(m.LocMessage.nonLocalNoBinding().format({
                  name: n
                }), e);
              }
            }
            if (a) {
              this._currentScope.setBindingType(n, 0);
            }
          });
        }
        return true;
      }
      visitImportAs(e) {
        var t;
        var n;
        var a;
        var r;
        var s;
        var i;
        if (e.d.module.d.nameParts.length > 0) {
          const l = e.d.module.d.nameParts[0].d.value;
          let p;
          let d;
          if (e.d.alias) {
            p = e.d.alias.d.value;
            d = e.d.alias;
          } else {
            p = l;
            d = e.d.module.d.nameParts[0];
          }
          const c = this._bindNameToScope(this._currentScope, d);
          if (!!c && (this._currentScope.type === 4 || this._currentScope.type === 5) && (!e.d.alias || e.d.module.d.nameParts.length !== 1 || e.d.module.d.nameParts[0].d.value !== e.d.alias.d.value)) {
            if (this._fileInfo.isStubFile || this._fileInfo.isInPyTypedPackage) {
              this._potentialHiddenSymbols.set(p, c);
            }
          }
          const u = y.getImportInfo(e.d.module);
          o.assert(u !== undefined);
          if (c) {
            this._createAliasDeclarationForMultipartImportName(e, e.d.alias, u, c);
          }
          this._createFlowAssignment(e.d.alias ? e.d.alias : e.d.module.d.nameParts[0]);
          if (e.d.module.d.nameParts.length === 1) {
            if (l === 'typing' || l === 'typing_extensions') {
              this._typingImportAliases.push((n = (t = e.d.alias) === null || t === undefined ? undefined : t.d.value) !== null && n !== undefined ? n : l);
            } else {
              if (l === 'sys') {
                this._sysImportAliases.push((r = (a = e.d.alias) === null || a === undefined ? undefined : a.d.value) !== null && r !== undefined ? r : l);
              } else {
                if (l === 'dataclasses') {
                  this._dataclassesImportAliases.push((i = (s = e.d.alias) === null || s === undefined ? undefined : s.d.value) !== null && i !== undefined ? i : l);
                }
              }
            }
          }
        }
        return true;
      }
      visitImportFrom(e) {
        var t;
        const n = ['Final', 'ClassVar', 'Annotated'];
        const a = ['InitVar'];
        const r = y.getImportInfo(e.d.module);
        y.setFlowNode(e, this._currentFlowNode);
        let s = u.Uri.empty();
        if (r && r.isImportFound && !r.isNativeLib) {
          s = r.resolvedUris[r.resolvedUris.length - 1];
        }
        const i = p.stripFileExtension(this._fileInfo.fileUri.fileName);
        const o = i === '__init__' && e.d.module.d.leadingDots === 1 && e.d.module.d.nameParts.length === 1;
        let l = false;
        let h = false;
        if (e.d.module.d.nameParts.length === 1) {
          const t = e.d.module.d.nameParts[0].d.value;
          if (t === 'typing' || t === 'typing_extensions') {
            l = true;
          }
          if (t === 'dataclasses') {
            h = true;
          }
        }
        if (e.d.isWildcardImport) {
          if (f.getEnclosingClass(e) || f.getEnclosingFunction(e)) {
            this._addSyntaxError(m.LocMessage.wildcardInFunction(), e);
          }
          if (r) {
            const i = [];
            if ((t = this._currentScopeCodeFlowExpressions) !== null && t !== undefined) {
              t.add(g.wildcardImportReferenceKey);
            }
            const p = this._fileInfo.importLookup(s);
            if (p) {
              const t = this._getWildcardImportNames(p);
              if (o) {
                if (!t.some(t => t === e.d.module.d.nameParts[0].d.value)) {
                  this._addImplicitFromImport(e, r);
                }
              }
              t.forEach(t => {
                const n = this._bindNameValueToScope(this._currentScope, t);
                if (n) {
                  if (p.symbolTable.get(t)) {
                    const a = {
                      type: 8,
                      node: e,
                      uri: s,
                      loadSymbolsFromPath: true,
                      range: c.getEmptyRange(),
                      usesLocalName: false,
                      symbolName: t,
                      moduleName: this._fileInfo.moduleName,
                      isInExceptSuite: this._isInExceptSuite
                    };
                    n.addDeclaration(a);
                    i.push(t);
                  } else {
                    if (r && r.filteredImplicitImports) {
                      const a = r.filteredImplicitImports.get(t);
                      if (a) {
                        const r = {
                          type: 8,
                          node: e,
                          uri: a.uri,
                          loadSymbolsFromPath: true,
                          range: c.getEmptyRange(),
                          usesLocalName: false,
                          moduleName: this._fileInfo.moduleName,
                          isInExceptSuite: this._isInExceptSuite
                        };
                        const o = {
                          type: 8,
                          node: e,
                          uri: s,
                          loadSymbolsFromPath: true,
                          usesLocalName: false,
                          symbolName: t,
                          submoduleFallback: r,
                          range: c.getEmptyRange(),
                          moduleName: this._fileInfo.moduleName,
                          isInExceptSuite: this._isInExceptSuite
                        };
                        n.addDeclaration(o);
                        i.push(t);
                      }
                    }
                  }
                  if (l) {
                    n.setTypingSymbolAlias(t);
                  }
                }
              });
            }
            this._createFlowWildcardImport(e, i);
            if (l) {
              n.forEach(e => {
                this._typingSymbolAliases.set(e, e);
              });
            }
            if (h) {
              a.forEach(e => {
                this._dataclassesSymbolAliases.set(e, e);
              });
            }
          }
        } else {
          if (o) {
            this._addImplicitFromImport(e, r);
          }
          e.d.imports.forEach(t => {
            const o = t.d.name.d.value;
            const p = t.d.alias || t.d.name;
            y.setFlowNode(t, this._currentFlowNode);
            const u = this._bindNameToScope(this._currentScope, p);
            if (u) {
              let m;
              let y;
              if (e.d.module.d.nameParts.length > 0) {
                if ((this._currentScope.type === 4 || this._currentScope.type === 5) && (!t.d.alias || t.d.alias.d.value !== t.d.name.d.value)) {
                  if (this._fileInfo.isStubFile || this._fileInfo.isInPyTypedPackage) {
                    this._potentialHiddenSymbols.set(p.d.value, u);
                  }
                }
              }
              if (r && r.filteredImplicitImports) {
                m = r.filteredImplicitImports.get(o);
              }
              let g = true;
              if (m) {
                y = {
                  type: 8,
                  node: t,
                  uri: m.uri,
                  loadSymbolsFromPath: true,
                  range: c.getEmptyRange(),
                  usesLocalName: false,
                  moduleName: this._formatModuleName(e.d.module),
                  isInExceptSuite: this._isInExceptSuite
                };
                if (i === '__init__' && (e.d.module.d.leadingDots === 1 && e.d.module.d.nameParts.length === 0 || s.equals(this._fileInfo.fileUri))) {
                  g = false;
                }
              }
              const f = {
                type: 8,
                node: t,
                uri: s,
                loadSymbolsFromPath: g,
                usesLocalName: !!t.d.alias,
                symbolName: o,
                submoduleFallback: y,
                range: d.convertTextRangeToRange(p, this._fileInfo.lines),
                moduleName: this._formatModuleName(e.d.module),
                isInExceptSuite: this._isInExceptSuite,
                isNativeLib: r == null ? undefined : r.isNativeLib
              };
              u.addDeclaration(f);
              this._createFlowAssignment(t.d.alias || t.d.name);
              if (l && n.some(e => e === t.d.name.d.value)) {
                this._typingSymbolAliases.set(p.d.value, t.d.name.d.value);
                if (l) {
                  u.setTypingSymbolAlias(p.d.value);
                }
              }
              if (h && a.some(e => e === t.d.name.d.value)) {
                this._dataclassesSymbolAliases.set(p.d.value, t.d.name.d.value);
              }
            }
          });
        }
        return true;
      }
      visitWith(e) {
        e.d.withItems.forEach(e => {
          this.walk(e.d.expr);
          if (e.d.target) {
            this._bindPossibleTupleNamedTarget(e.d.target);
            this._addInferredTypeAssignmentForVariable(e.d.target, e);
            this._createAssignmentTargetFlowNodes(e.d.target, true, false);
          }
        });
        const t = this._createContextManagerLabel(e.d.withItems.map(e => e.d.expr), !!e.d.isAsync, false);
        this._addAntecedent(t, this._currentFlowNode);
        const n = this._createContextManagerLabel(e.d.withItems.map(e => e.d.expr), !!e.d.isAsync, true);
        this._currentExceptTargets.forEach(e => {
          this._addAntecedent(e, n);
        });
        const a = this._currentFlowNode;
        const r = this._createBranchLabel(a);
        this._addAntecedent(r, t);
        r.affectedExpressions = this._trackCodeFlowExpressions(() => {
          this._useExceptTargets([t, n], () => {
            this.walk(e.d.suite);
          });
          this._addAntecedent(r, this._currentFlowNode);
          this._currentFlowNode = r;
          if (!this._isCodeUnreachable()) {
            this._addExceptTargets(this._currentFlowNode);
          }
          if (e.d.asyncToken && !this._fileInfo.ipythonMode) {
            const t = f.getEnclosingFunction(e);
            if (!t || !t.d.isAsync) {
              this._addSyntaxError(m.LocMessage.asyncNotInAsyncFunction(), e.d.asyncToken);
            }
          }
        });
        return false;
      }
      visitTernary(e) {
        const t = this._currentFlowNode;
        const n = this._createBranchLabel();
        const a = this._createBranchLabel();
        const r = this._createBranchLabel(t);
        r.affectedExpressions = this._trackCodeFlowExpressions(() => {
          this._bindConditional(e.d.testExpr, n, a);
          this._currentFlowNode = this._finishFlowLabel(n);
          this.walk(e.d.ifExpr);
          this._addAntecedent(r, this._currentFlowNode);
          this._currentFlowNode = this._finishFlowLabel(a);
          this.walk(e.d.elseExpr);
          this._addAntecedent(r, this._currentFlowNode);
          this._currentFlowNode = this._finishFlowLabel(r);
        });
        return false;
      }
      visitUnaryOperation(e) {
        if (e.d.operator === 38 && this._currentFalseTarget && this._currentTrueTarget) {
          this._bindConditional(e.d.expr, this._currentFalseTarget, this._currentTrueTarget);
        } else {
          this._disableTrueFalseTargets(() => {
            this.walk(e.d.expr);
          });
        }
        return false;
      }
      visitBinaryOperation(e) {
        if (e.d.operator === 36 || e.d.operator === 37) {
          let t;
          let n = this._currentTrueTarget;
          let a = this._currentFalseTarget;
          if (!n || !a) {
            t = this._createBranchLabel();
            n = a = t;
          }
          const r = this._createBranchLabel();
          if (e.d.operator === 36) {
            this._bindConditional(e.d.leftExpr, r, a);
          } else {
            this._bindConditional(e.d.leftExpr, n, r);
          }
          this._currentFlowNode = this._finishFlowLabel(r);
          this._bindConditional(e.d.rightExpr, n, a);
          if (t) {
            this._currentFlowNode = this._finishFlowLabel(t);
          }
        } else {
          this._disableTrueFalseTargets(() => {
            this.walk(e.d.leftExpr);
            this.walk(e.d.rightExpr);
          });
        }
        return false;
      }
      visitComprehension(e) {
        const t = f.getEnclosingFunction(e);
        if (e.d.forIfNodes.length > 0 && e.d.forIfNodes[0].nodeType === 12) {
          this.walk(e.d.forIfNodes[0].d.iterableExpr);
        }
        this._createNewScope(1, this._getNonClassParentScope(), undefined, () => {
          var n;
          var a;
          var r;
          y.setScope(e, this._currentScope);
          const s = this._createBranchLabel();
          for (let s = 0; s < e.d.forIfNodes.length; s++) {
            const i = e.d.forIfNodes[s];
            const o = new Map();
            if (i.nodeType === 12) {
              this._bindPossibleTupleNamedTarget(i.d.targetExpr, o);
              this._addInferredTypeAssignmentForVariable(i.d.targetExpr, i);
              if (i.d.asyncToken && !this._fileInfo.ipythonMode) {
                if ((!t || !t.d.isAsync) && (((n = e.parent) === null || n === undefined ? undefined : n.nodeType) === 34 || ((a = e.parent) === null || a === undefined ? undefined : a.nodeType) === 45 || ((r = e.parent) === null || r === undefined ? undefined : r.nodeType) === 18)) {
                  this._addSyntaxError(m.LocMessage.asyncNotInAsyncFunction(), i.d.asyncToken);
                }
              }
            }
          }
          for (let t = 0; t < e.d.forIfNodes.length; t++) {
            const n = e.d.forIfNodes[t];
            if (n.nodeType === 12) {
              if (t !== 0) {
                this.walk(n.d.iterableExpr);
              }
              this._createAssignmentTargetFlowNodes(n.d.targetExpr, true, false);
            } else {
              const e = this._createBranchLabel();
              this._bindConditional(n.d.testExpr, e, s);
              this._currentFlowNode = this._finishFlowLabel(e);
            }
          }
          this.walk(e.d.expr);
          this._addAntecedent(s, this._currentFlowNode);
          this._currentFlowNode = this._finishFlowLabel(s);
        });
        return false;
      }
      visitMatch(e) {
        this.walk(e.d.expr);
        const t = [];
        let n = this._isNarrowingExpression(e.d.expr, t);
        if (e.d.expr.nodeType === 52) {
          e.d.expr.d.items.forEach(e => {
            if (this._isNarrowingExpression(e, t)) {
              n = true;
            }
          });
        }
        if (n) {
          t.forEach(e => {
            const t = g.createKeyForReference(e);
            this._currentScopeCodeFlowExpressions.add(t);
          });
        }
        const a = this._createBranchLabel();
        let r = false;
        e.d.cases.forEach(t => {
          const n = this._createBranchLabel();
          const s = this._createBranchLabel();
          const i = this._createBranchLabel();
          this._addAntecedent(s, this._currentFlowNode);
          if (t.d.isIrrefutable) {
            if (!t.d.guardExpr) {
              r = true;
            }
          } else {
            this._addAntecedent(n, this._currentFlowNode);
          }
          this._currentFlowNode = this._finishFlowLabel(s);
          this._currentMatchSubjExpr = e.d.expr;
          this.walk(t.d.pattern);
          if (this._currentMatchSubjExpr) {
            this._createFlowNarrowForPattern(e.d.expr, t);
            this._currentMatchSubjExpr = undefined;
          }
          if (t.d.guardExpr) {
            this._bindConditional(t.d.guardExpr, i, n);
          } else {
            this._addAntecedent(i, this._currentFlowNode);
          }
          this._currentFlowNode = this._finishFlowLabel(i);
          this.walk(t.d.suite);
          this._addAntecedent(a, this._currentFlowNode);
          this._currentFlowNode = this._finishFlowLabel(n);
        });
        if (n) {
          this._createFlowNarrowForPattern(e.d.expr, e);
        }
        if (!r) {
          this._createFlowExhaustedMatch(e);
        }
        this._addAntecedent(a, this._currentFlowNode);
        this._currentFlowNode = this._finishFlowLabel(a);
        return false;
      }
      visitPatternAs(e) {
        const t = this._createBranchLabel();
        e.d.orPatterns.forEach(e => {
          this.walk(e);
          this._addAntecedent(t, this._currentFlowNode);
        });
        this._currentFlowNode = this._finishFlowLabel(t);
        if (e.d.target) {
          this.walk(e.d.target);
          const t = this._bindNameToScope(this._currentScope, e.d.target);
          this._createAssignmentTargetFlowNodes(e.d.target, false, false);
          if (t) {
            const n = {
              type: 1,
              node: e.d.target,
              isConstant: C.isConstantName(e.d.target.d.value),
              inferredTypeSource: e,
              uri: this._fileInfo.fileUri,
              range: d.convertTextRangeToRange(e.d.target, this._fileInfo.lines),
              moduleName: this._fileInfo.moduleName,
              isInExceptSuite: this._isInExceptSuite,
              isExplicitBinding: this._currentScope.getBindingType(e.d.target.d.value) !== undefined
            };
            t.addDeclaration(n);
          }
        }
        return false;
      }
      visitPatternCapture(e) {
        if (!e.d.isWildcard) {
          this._addPatternCaptureTarget(e.d.target);
        }
        return true;
      }
      visitPatternMappingExpandEntry(e) {
        if (e.d.target.d.value !== '_') {
          this._addPatternCaptureTarget(e.d.target);
        }
        return true;
      }
      _addTypingImportAliasesFromBuiltinsScope() {
        if (!this._fileInfo.builtinsScope) {
          return;
        }
        this._fileInfo.builtinsScope.symbolTable.forEach((e, t) => {
          const n = e.getTypingSymbolAlias();
          if (n && !e.isExternallyHidden()) {
            this._typingSymbolAliases.set(t, n);
          }
        });
      }
      _formatModuleName(e) {
        return '.'.repeat(e.d.leadingDots) + e.d.nameParts.map(e => e.d.value).join('.');
      }
      _getNonClassParentScope() {
        let e = this._currentScope;
        while (e.type === 3) {
          e = e.parent;
        }
        return e;
      }
      _addSlotsToCurrentScope(e) {
        o.assert(this._currentScope.type === 3);
        let t = false;
        for (const n of e) {
          const e = n.d.strings[0].d.value;
          if (e === '__dict__') {
            t = true;
            continue;
          }
          let a = this._currentScope.lookUpSymbol(e);
          if (!a) {
            a = this._currentScope.addSymbol(e, 5);
            const t = this._fileInfo.diagnosticRuleSet.reportPrivateUsage !== 'none';
            if (C.isPrivateOrProtectedName(e) && t) {
              a.setIsPrivateMember();
            }
          }
          const r = {
            type: 1,
            node: n,
            isConstant: C.isConstantName(e),
            isDefinedBySlots: true,
            uri: this._fileInfo.fileUri,
            range: d.convertTextRangeToRange(n, this._fileInfo.lines),
            moduleName: this._fileInfo.moduleName,
            isInExceptSuite: this._isInExceptSuite,
            isExplicitBinding: this._currentScope.getBindingType(e) !== undefined
          };
          a.addDeclaration(r);
        }
        if (!t) {
          this._currentScope.setSlotsNames(e.map(e => e.d.strings[0].d.value));
        }
      }
      _isInComprehension(e, t = false) {
        let n;
        let a;
        let r = e;
        while (r) {
          if (r.nodeType === 11) {
            if (t && r.d.forIfNodes.length > 0) {
              const e = r.d.forIfNodes[0];
              if (n === e && e.nodeType === 12 && a === e.d.iterableExpr) {
                return false;
              }
            }
            return true;
          }
          a = n;
          n = r;
          r = r.parent;
        }
        return false;
      }
      _addPatternCaptureTarget(e) {
        const t = this._bindNameToScope(this._currentScope, e);
        this._createAssignmentTargetFlowNodes(e, false, false);
        if (this._currentMatchSubjExpr && (f.isMatchingExpression(e, this._currentMatchSubjExpr) || f.isPartialMatchingExpression(e, this._currentMatchSubjExpr))) {
          this._currentMatchSubjExpr = undefined;
        }
        if (t) {
          const n = {
            type: 1,
            node: e,
            isConstant: C.isConstantName(e.d.value),
            inferredTypeSource: e.parent,
            uri: this._fileInfo.fileUri,
            range: d.convertTextRangeToRange(e, this._fileInfo.lines),
            moduleName: this._fileInfo.moduleName,
            isInExceptSuite: this._isInExceptSuite,
            isExplicitBinding: this._currentScope.getBindingType(e.d.value) !== undefined
          };
          t.addDeclaration(n);
        }
      }
      _useExceptTargets(e, t) {
        const n = this._currentExceptTargets;
        this._currentExceptTargets = e;
        t();
        this._currentExceptTargets = n;
      }
      _getDunderAllNamesFromImport(e) {
        var t;
        var n;
        const a = this._currentScope.lookUpSymbol(e);
        if (!a) {
          return;
        }
        const r = a.getDeclarations().find(e => e.type === 8);
        const s = (r == null ? undefined : r.uri) && !r.uri.isEmpty() && r.loadSymbolsFromPath ? r.uri : ((t = r == null ? undefined : r.submoduleFallback) === null || t === undefined ? undefined : t.uri) && !r.submoduleFallback.uri.isEmpty() && r.submoduleFallback.loadSymbolsFromPath ? r.submoduleFallback.uri : undefined;
        if (!s) {
          return;
        }
        let i = this._fileInfo.importLookup(s);
        if (i == null ? undefined : i.dunderAllNames) {
          return i.dunderAllNames;
        } else {
          if (((n = r == null ? undefined : r.submoduleFallback) === null || n === undefined ? undefined : n.uri) && !r.submoduleFallback.uri.isEmpty()) {
            i = this._fileInfo.importLookup(r.submoduleFallback.uri);
            return i == null ? undefined : i.dunderAllNames;
          } else {
            return undefined;
          }
        }
      }
      _addImplicitFromImport(e, t) {
        const n = e.d.module.d.nameParts[0].d.value;
        const a = this._bindNameValueToScope(this._currentScope, n);
        if (a) {
          this._createAliasDeclarationForMultipartImportName(e, undefined, t, a);
        }
        this._createFlowAssignment(e.d.module.d.nameParts[0]);
      }
      _createAliasDeclarationForMultipartImportName(e, t, n, a) {
        var r;
        const s = e.d.module.d.nameParts[0].d.value;
        y.setFlowNode(e, this._currentFlowNode);
        const i = a.getDeclarations().find(e => e.type === 8 && e.firstNamePart === s);
        let o;
        let l;
        l = n && n.isImportFound && !n.isNativeLib && n.resolvedUris.length > 0 ? n.resolvedUris[n.resolvedUris.length - 1] : h.UnresolvedModuleMarker;
        const p = n && n.isImportFound && !n.isNativeLib && n.resolvedUris.length > 0;
        o = i || (p ? {
          type: 8,
          node: e,
          uri: l,
          loadSymbolsFromPath: false,
          range: c.getEmptyRange(),
          usesLocalName: !!t,
          moduleName: t ? this._formatModuleName(e.d.module) : '.'.repeat(e.d.module.d.leadingDots) + s,
          firstNamePart: s,
          isInExceptSuite: this._isInExceptSuite
        } : {
          type: 8,
          node: e,
          uri: l,
          loadSymbolsFromPath: true,
          range: c.getEmptyRange(),
          usesLocalName: !!t,
          moduleName: (r = n == null ? undefined : n.importName) !== null && r !== undefined ? r : '',
          firstNamePart: t ? this._formatModuleName(e.d.module) : '.'.repeat(e.d.module.d.leadingDots) + s,
          isUnresolved: true,
          isInExceptSuite: this._isInExceptSuite
        });
        const d = y.getImportInfo(e.d.module.d.nameParts[0]);
        if (d && d.resolvedUris.length) {
          o.uri = d.resolvedUris[0];
          o.loadSymbolsFromPath = true;
          this._addImplicitImportsToLoaderActions(d, o);
        }
        if (t || e.d.module.d.nameParts.length === 1) {
          o.uri = l;
          o.loadSymbolsFromPath = true;
          o.isUnresolved = false;
          if (n) {
            this._addImplicitImportsToLoaderActions(n, o);
          }
        } else {
          let t = o;
          for (let a = 1; a < e.d.module.d.nameParts.length; a++) {
            const r = e.d.module.d.nameParts[a].d.value;
            let s = t.implicitImports ? t.implicitImports.get(r) : undefined;
            if (!s) {
              s = {
                uri: n && a < n.resolvedUris.length ? n.resolvedUris[a] : h.UnresolvedModuleMarker,
                loadSymbolsFromPath: false,
                implicitImports: new Map(),
                isUnresolved: !p
              };
              if (!t.implicitImports) {
                t.implicitImports = new Map();
              }
              t.implicitImports.set(r, s);
            }
            if (a === e.d.module.d.nameParts.length - 1) {
              if (n && a < n.resolvedUris.length) {
                s.uri = n.resolvedUris[a];
                s.loadSymbolsFromPath = true;
                this._addImplicitImportsToLoaderActions(n, s);
              }
            } else {
              const t = y.getImportInfo(e.d.module.d.nameParts[a]);
              if (t && t.resolvedUris.length) {
                s.uri = t.resolvedUris[a];
                s.loadSymbolsFromPath = true;
                this._addImplicitImportsToLoaderActions(t, s);
              }
            }
            t = s;
          }
        }
        if (!i) {
          a.addDeclaration(o);
        }
      }
      _getWildcardImportNames(e) {
        const t = [];
        if (e.dunderAllNames) {
          if (!e.usesUnsupportedDunderAllForm) {
            return e.dunderAllNames;
          }
          i.appendArray(t, e.dunderAllNames);
        }
        e.symbolTable.forEach((e, n) => {
          if (!e.isExternallyHidden() && !n.startsWith('_')) {
            t.push(n);
          }
        });
        return t;
      }
      _walkStatementsAndReportUnreachable(e) {
        let t = false;
        for (const n of e) {
          y.setFlowNode(n, this._currentFlowNode);
          if (!t) {
            t = this._isCodeUnreachable();
          }
          if (t) {
            if (this._targetFunctionDeclaration && !this._targetFunctionDeclaration.isGenerator) {
              if (new k().checkContainsYield(n)) {
                this._targetFunctionDeclaration.isGenerator = true;
              }
            }
            if (!this._moduleSymbolOnly) {
              new S(this._currentScope).walk(n);
            }
          } else {
            this.walk(n);
          }
        }
        return false;
      }
      _createStartFlowNode() {
        return {
          flags: g.FlowFlags.Start,
          id: this._getUniqueFlowNodeId()
        };
      }
      _createBranchLabel(e) {
        return {
          flags: g.FlowFlags.BranchLabel,
          id: this._getUniqueFlowNodeId(),
          antecedents: [],
          preBranchAntecedent: e,
          affectedExpressions: undefined
        };
      }
      _createFlowNarrowForPattern(e, t) {
        const n = {
          flags: g.FlowFlags.NarrowForPattern,
          id: this._getUniqueFlowNodeId(),
          subjectExpression: e,
          statement: t,
          antecedent: this._currentFlowNode
        };
        this._currentFlowNode = n;
      }
      _createContextManagerLabel(e, t, n) {
        return {
          flags: g.FlowFlags.PostContextManager | g.FlowFlags.BranchLabel,
          id: this._getUniqueFlowNodeId(),
          antecedents: [],
          expressions: e,
          affectedExpressions: undefined,
          isAsync: t,
          blockIfSwallowsExceptions: n
        };
      }
      _createLoopLabel() {
        return {
          flags: g.FlowFlags.LoopLabel,
          id: this._getUniqueFlowNodeId(),
          antecedents: [],
          affectedExpressions: undefined
        };
      }
      _finishFlowLabel(e) {
        if (e.antecedents.length === 0) {
          return I._unreachableFlowNode;
        } else {
          if (e.antecedents.length === 1 && e.flags === g.FlowFlags.BranchLabel) {
            return e.antecedents[0];
          } else {
            this._codeFlowComplexity += e.antecedents.length - 1;
            return e;
          }
        }
      }
      _bindNeverCondition(e, t, n) {
        const a = [];
        if (e.nodeType === 55 && e.d.operator === 38) {
          this._bindNeverCondition(e.d.expr, t, !n);
        } else {
          if (e.nodeType !== 7 || e.d.operator !== 36 && e.d.operator !== 37) {
            if (this._isNarrowingExpression(e, a, {
              filterForNeverNarrowing: true
            })) {
              if (a.filter(e => e.nodeType === 38).length > 0) {
                this._currentFlowNode = this._createFlowConditional(n ? g.FlowFlags.TrueNeverCondition : g.FlowFlags.FalseNeverCondition, this._currentFlowNode, e);
              }
            }
            this._addAntecedent(t, this._currentFlowNode);
          } else {
            let a = e.d.operator === 36;
            if (n) {
              a = !a;
            }
            if (a) {
              const a = this._currentFlowNode;
              this._bindNeverCondition(e.d.leftExpr, t, n);
              this._currentFlowNode = a;
              this._bindNeverCondition(e.d.rightExpr, t, n);
            } else {
              const a = this._currentFlowNode;
              const r = this._createBranchLabel();
              this._bindNeverCondition(e.d.leftExpr, r, n);
              if (a !== this._currentFlowNode) {
                this._currentFlowNode = this._finishFlowLabel(r);
                const s = this._currentFlowNode;
                this._bindNeverCondition(e.d.rightExpr, t, n);
                if (s === this._currentFlowNode) {
                  this._currentFlowNode = a;
                }
              }
            }
          }
        }
      }
      _bindConditional(e, t, n) {
        this._setTrueFalseTargets(t, n, () => {
          this.walk(e);
        });
        if (!this._isLogicalExpression(e)) {
          this._addAntecedent(t, this._createFlowConditional(g.FlowFlags.TrueCondition, this._currentFlowNode, e));
          this._addAntecedent(n, this._createFlowConditional(g.FlowFlags.FalseCondition, this._currentFlowNode, e));
        }
      }
      _disableTrueFalseTargets(e) {
        this._setTrueFalseTargets(undefined, undefined, e);
      }
      _setTrueFalseTargets(e, t, n) {
        const a = this._currentTrueTarget;
        const r = this._currentFalseTarget;
        this._currentTrueTarget = e;
        this._currentFalseTarget = t;
        n();
        this._currentTrueTarget = a;
        this._currentFalseTarget = r;
      }
      _createFlowConditional(e, t, n) {
        if (t.flags & g.FlowFlags.Unreachable) {
          return t;
        }
        const a = b.evaluateStaticBoolLikeExpression(n, this._fileInfo.executionEnvironment, this._fileInfo.definedConstants, this._typingImportAliases, this._sysImportAliases);
        if (a === true && e & g.FlowFlags.FalseCondition || a === false && e & g.FlowFlags.TrueCondition) {
          return I._unreachableFlowNode;
        }
        const r = [];
        if (!this._isNarrowingExpression(n, r, {
          filterForNeverNarrowing: !!(e & (g.FlowFlags.TrueNeverCondition | g.FlowFlags.FalseNeverCondition))
        })) {
          return t;
        }
        r.forEach(e => {
          const t = g.createKeyForReference(e);
          this._currentScopeCodeFlowExpressions.add(t);
        });
        const s = r.filter(e => e.nodeType === 38);
        const i = {
          flags: e,
          id: this._getUniqueFlowNodeId(),
          reference: s.length > 0 ? s[0] : undefined,
          expression: n,
          antecedent: t
        };
        this._addExceptTargets(i);
        return i;
      }
      _isLogicalExpression(e) {
        switch (e.nodeType) {
          case 55:
            return e.d.operator === 38;
          case 7:
            return e.d.operator === 36 || e.d.operator === 37;
        }
        return false;
      }
      _isNarrowingExpression(e, t, n = {}) {
        switch (e.nodeType) {
          case 38:
          case 35:
          case 27:
            if (n.filterForNeverNarrowing) {
              if (e.nodeType !== 38) {
                return false;
              }
              if (!n.isComplexExpression) {
                return false;
              }
            }
            return !!g.isCodeFlowSupportedForReference(e) && (t.push(e), n.filterForNeverNarrowing || (e.nodeType === 35 && n.allowDiscriminatedNarrowing && g.isCodeFlowSupportedForReference(e.d.leftExpr) && t.push(e.d.leftExpr), e.nodeType !== 27 || e.d.items.length !== 1 || e.d.trailingComma || e.d.items[0].d.argCategory !== 0 || g.isCodeFlowSupportedForReference(e.d.leftExpr) && t.push(e.d.leftExpr)), true);
          case 4:
            t.push(e.d.name);
            this._isNarrowingExpression(e.d.rightExpr, t, {
              ...n,
              isComplexExpression: true
            });
            return true;
          case 7:
            {
              const a = e.d.operator === 39 || e.d.operator === 40;
              const r = e.d.operator === 12 || e.d.operator === 28;
              if (a || r) {
                if (e.d.rightExpr.nodeType === 14 && e.d.rightExpr.d.constType === 26) {
                  return this._isNarrowingExpression(e.d.leftExpr, t, {
                    ...n,
                    isComplexExpression: true,
                    allowDiscriminatedNarrowing: true
                  });
                }
                if (a && e.d.leftExpr.nodeType === 9 && e.d.leftExpr.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.leftExpr.d.value === 'type' && e.d.leftExpr.d.args.length === 1 && e.d.leftExpr.d.args[0].d.argCategory === 0) {
                  return this._isNarrowingExpression(e.d.leftExpr.d.args[0].d.valueExpr, t, {
                    ...n,
                    isComplexExpression: true
                  });
                }
                return this._isNarrowingExpression(e.d.leftExpr, t, {
                  ...n,
                  isComplexExpression: true,
                  allowDiscriminatedNarrowing: true
                });
              }
              if (e.d.rightExpr.nodeType === 40 && e.d.rightExpr.d.isInteger && (e.d.operator === 20 || e.d.operator === 21 || e.d.operator === 15 || e.d.operator === 16)) {
                return this._isNarrowingExpression(e.d.leftExpr, t, {
                  ...n,
                  isComplexExpression: true
                });
              }
              if ((e.d.operator === 41 || e.d.operator === 42) && e.d.leftExpr.nodeType === 48 && this._isNarrowingExpression(e.d.rightExpr, t, {
                ...n,
                isComplexExpression: true
              })) {
                return true;
              }
              if (e.d.operator === 41 || e.d.operator === 42) {
                const a = this._isNarrowingExpression(e.d.leftExpr, t, {
                  ...n,
                  isComplexExpression: true
                });
                const r = this._isNarrowingExpression(e.d.rightExpr, t, {
                  ...n,
                  isComplexExpression: true
                });
                return a || r;
              }
              return false;
            }
          case 55:
            return e.d.operator === 38 && this._isNarrowingExpression(e.d.expr, t, {
              ...n,
              isComplexExpression: false
            });
          case 5:
            return this._isNarrowingExpression(e.d.rightExpr, t, {
              ...n,
              isComplexExpression: true
            });
          case 9:
            if (e.d.leftExpr.nodeType === 38 && (e.d.leftExpr.d.value === 'isinstance' || e.d.leftExpr.d.value === 'issubclass') && e.d.args.length === 2) {
              return this._isNarrowingExpression(e.d.args[0].d.valueExpr, t, {
                ...n,
                isComplexExpression: true
              });
            }
            if (e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'callable' && e.d.args.length === 1) {
              return this._isNarrowingExpression(e.d.args[0].d.valueExpr, t, {
                ...n,
                isComplexExpression: true
              });
            }
            if (e.d.args.length >= 1) {
              return !n.filterForNeverNarrowing && this._isNarrowingExpression(e.d.args[0].d.valueExpr, t, {
                ...n,
                isComplexExpression: true
              });
            }
        }
        return false;
      }
      _createAssignmentTargetFlowNodes(e, t, n) {
        switch (e.nodeType) {
          case 38:
          case 35:
          case 27:
            this._createFlowAssignment(e, n);
            if (t) {
              this.walk(e);
            }
            break;
          case 52:
            e.d.items.forEach(e => {
              this._createAssignmentTargetFlowNodes(e, t, n);
            });
            break;
          case 54:
            this._createAssignmentTargetFlowNodes(e.d.valueExpr, false, n);
            if (t) {
              this.walk(e);
            }
            break;
          case 56:
            this._createAssignmentTargetFlowNodes(e.d.expr, false, n);
            if (t) {
              this.walk(e);
            }
            break;
          case 34:
            e.d.items.forEach(e => {
              this._createAssignmentTargetFlowNodes(e, t, n);
            });
            break;
          default:
            if (t) {
              this.walk(e);
            }
        }
      }
      _createCallFlowNode(e) {
        if (!this._isCodeUnreachable()) {
          this._addExceptTargets(this._currentFlowNode);
          const t = {
            flags: g.FlowFlags.Call,
            id: this._getUniqueFlowNodeId(),
            node: e,
            antecedent: this._currentFlowNode
          };
          this._currentFlowNode = t;
        }
      }
      _createVariableAnnotationFlowNode() {
        if (!this._isCodeUnreachable()) {
          const e = {
            flags: g.FlowFlags.VariableAnnotation,
            id: this._getUniqueFlowNodeId(),
            antecedent: this._currentFlowNode
          };
          this._currentFlowNode = e;
        }
      }
      _createFlowAssignment(e, t = false) {
        let n = _.indeterminateSymbolId;
        if (e.nodeType === 38) {
          const t = this._currentScope.lookUpSymbolRecursive(e.d.value);
          o.assert(t !== undefined);
          n = t.symbol.id;
        }
        const a = this._currentFlowNode;
        if (!this._isCodeUnreachable() && g.isCodeFlowSupportedForReference(e)) {
          const a = {
            flags: g.FlowFlags.Assignment,
            id: this._getUniqueFlowNodeId(),
            node: e,
            antecedent: this._currentFlowNode,
            targetSymbolId: n
          };
          const r = g.createKeyForReference(e);
          this._currentScopeCodeFlowExpressions.add(r);
          if (t) {
            a.flags |= g.FlowFlags.Unbind;
          }
          if (e.nodeType === 35) {
            this._addExceptTargets(a);
          }
          this._currentFlowNode = a;
        }
        if (!t || y.getFlowNode(e) === undefined) {
          y.setFlowNode(e, t ? a : this._currentFlowNode);
        }
      }
      _createFlowWildcardImport(e, t) {
        if (!this._isCodeUnreachable()) {
          const n = {
            flags: g.FlowFlags.WildcardImport,
            id: this._getUniqueFlowNodeId(),
            node: e,
            names: t,
            antecedent: this._currentFlowNode
          };
          this._addExceptTargets(n);
          this._currentFlowNode = n;
        }
        y.setFlowNode(e, this._currentFlowNode);
      }
      _createFlowExhaustedMatch(e) {
        if (!this._isCodeUnreachable()) {
          const t = {
            flags: g.FlowFlags.ExhaustedMatch,
            id: this._getUniqueFlowNodeId(),
            node: e,
            antecedent: this._currentFlowNode,
            subjectExpression: e.d.expr
          };
          this._currentFlowNode = t;
        }
        y.setAfterFlowNode(e, this._currentFlowNode);
      }
      _isCodeUnreachable() {
        return !!(this._currentFlowNode.flags & g.FlowFlags.Unreachable);
      }
      _addExceptTargets(e) {
        if (this._currentExceptTargets) {
          this._currentExceptTargets.forEach(t => {
            this._addAntecedent(t, e);
          });
        }
      }
      _trackCodeFlowExpressions(e) {
        const t = this._currentScopeCodeFlowExpressions;
        this._currentScopeCodeFlowExpressions = new Set();
        e();
        const n = this._currentScopeCodeFlowExpressions;
        if (t) {
          this._currentScopeCodeFlowExpressions.forEach(e => {
            t.add(e);
          });
        }
        this._currentScopeCodeFlowExpressions = t;
        return n;
      }
      _bindLoopStatement(e, t, n) {
        const a = this._currentContinueTarget;
        const r = this._currentBreakTarget;
        this._currentContinueTarget = e;
        this._currentBreakTarget = t;
        e.affectedExpressions = this._trackCodeFlowExpressions(n);
        this._currentContinueTarget = a;
        this._currentBreakTarget = r;
      }
      _addAntecedent(e, t) {
        if (!(this._currentFlowNode.flags & g.FlowFlags.Unreachable) && !e.antecedents.some(e => e.id === t.id)) {
          e.antecedents.push(t);
        }
      }
      _bindNameToScope(e, t, n) {
        return this._bindNameValueToScope(e, t.d.value, n);
      }
      _bindNameValueToScope(e, t, n) {
        const a = this._currentScope.getBindingType(t);
        if (a === undefined) {
          let a = e.lookUpSymbol(t);
          if (!a) {
            a = e.addSymbol(t, 5);
            if (this._currentScope.type === 4 || this._currentScope.type === 5) {
              if (C.isPrivateOrProtectedName(t)) {
                if (C.isPrivateName(t)) {
                  if (e.type === 3) {
                    a.setIsExternallyHidden();
                  } else {
                    this._potentialPrivateSymbols.set(t, a);
                  }
                } else {
                  if (this._fileInfo.isStubFile || this._fileInfo.isInPyTypedPackage) {
                    if (this._currentScope.type === 5) {
                      a.setIsExternallyHidden();
                    } else {
                      this._potentialPrivateSymbols.set(t, a);
                    }
                  } else {
                    a.setIsPrivateMember();
                  }
                }
              }
            }
            if (n) {
              n.set(t, a);
            }
          }
          return a;
        }
        {
          const e = (a === 0 ? this._currentScope.parent : this._currentScope.getGlobalScope().scope).lookUpSymbolRecursive(t);
          if (e) {
            return e.symbol;
          }
        }
      }
      _bindPossibleTupleNamedTarget(e, t) {
        switch (e.nodeType) {
          case 38:
            this._bindNameToScope(this._currentScope, e, t);
            break;
          case 52:
          case 34:
            e.d.items.forEach(e => {
              this._bindPossibleTupleNamedTarget(e, t);
            });
            break;
          case 54:
            this._bindPossibleTupleNamedTarget(e.d.valueExpr, t);
            break;
          case 56:
            this._bindPossibleTupleNamedTarget(e.d.expr, t);
        }
      }
      _addImplicitSymbolToCurrentScope(e, t, n) {
        const a = this._addSymbolToCurrentScope(e, false);
        if (a) {
          a.addDeclaration({
            type: 0,
            node: t,
            intrinsicType: n,
            uri: this._fileInfo.fileUri,
            range: c.getEmptyRange(),
            moduleName: this._fileInfo.moduleName,
            isInExceptSuite: this._isInExceptSuite
          });
          a.setIsIgnoredForProtocolMatch();
        }
      }
      _addSymbolToCurrentScope(e, t) {
        let n = this._currentScope.lookUpSymbol(e);
        if (!n) {
          let a = 0;
          if (t) {
            a |= 1;
          }
          if (this._currentScope.type === 3) {
            a |= 4;
          }
          if (this._fileInfo.isStubFile && C.isPrivateOrProtectedName(e)) {
            a |= 2;
          }
          n = this._currentScope.addSymbol(e, a);
        }
        return n;
      }
      _createNewScope(e, t, n, a) {
        const r = this._currentScope;
        const s = new v.Scope(e, t, n);
        this._currentScope = s;
        const i = e === 5 || e === 4 || e === 2;
        const o = this._currentScopeCodeFlowExpressions;
        if (i) {
          this._currentScopeCodeFlowExpressions = new Set();
        }
        a();
        this._currentScopeCodeFlowExpressions = o;
        this._currentScope = r;
        return s;
      }
      _addInferredTypeAssignmentForVariable(e, t, n = false) {
        switch (e.nodeType) {
          case 38:
            {
              const a = e;
              const r = this._currentScope.lookUpSymbolRecursive(a.d.value);
              if (r && r.symbol) {
                const s = {
                  type: 1,
                  node: e,
                  isConstant: C.isConstantName(e.d.value),
                  inferredTypeSource: t,
                  isInferenceAllowedInPyTyped: this._isInferenceAllowedInPyTyped(a.d.value),
                  typeAliasName: n ? e : undefined,
                  uri: this._fileInfo.fileUri,
                  range: d.convertTextRangeToRange(a, this._fileInfo.lines),
                  moduleName: this._fileInfo.moduleName,
                  isInExceptSuite: this._isInExceptSuite,
                  docString: this._getVariableDocString(e),
                  isExplicitBinding: this._currentScope.getBindingType(a.d.value) !== undefined
                };
                r.symbol.addDeclaration(s);
              }
              break;
            }
          case 35:
            {
              const n = this._getMemberAccessInfo(e);
              if (n) {
                const a = e.d.member;
                let r = n.classScope.lookUpSymbol(a.d.value);
                if (!r) {
                  r = n.classScope.addSymbol(a.d.value, 1);
                  const e = this._fileInfo.diagnosticRuleSet.reportPrivateUsage !== 'none';
                  if (C.isPrivateOrProtectedName(a.d.value) && e) {
                    r.setIsPrivateMember();
                  }
                }
                if (n.isInstanceMember) {
                  if (!r.isClassMember() || !r.getDeclarations().some(e => e.type === 5 && e.isMethod)) {
                    r.setIsInstanceMember();
                  }
                } else {
                  r.setIsClassMember();
                }
                const s = {
                  type: 1,
                  node: e.d.member,
                  isConstant: C.isConstantName(a.d.value),
                  inferredTypeSource: t,
                  isDefinedByMemberAccess: true,
                  uri: this._fileInfo.fileUri,
                  range: d.convertTextRangeToRange(e.d.member, this._fileInfo.lines),
                  moduleName: this._fileInfo.moduleName,
                  isInExceptSuite: this._isInExceptSuite,
                  docString: this._getVariableDocString(e)
                };
                r.addDeclaration(s);
              }
              break;
            }
          case 52:
            e.d.items.forEach(e => {
              this._addInferredTypeAssignmentForVariable(e, t);
            });
            break;
          case 54:
            this._addInferredTypeAssignmentForVariable(e.d.valueExpr, t);
            break;
          case 56:
            this._addInferredTypeAssignmentForVariable(e.d.expr, t);
            break;
          case 34:
            e.d.items.forEach(e => {
              this._addInferredTypeAssignmentForVariable(e, t);
            });
        }
      }
      _isInferenceAllowedInPyTyped(e) {
        return ['__match_args__', '__slots__', '__all__'].some(t => t === e);
      }
      _addTypeDeclarationForVariable(e, t) {
        var n;
        var a;
        var r;
        let s = false;
        switch (e.nodeType) {
          case 38:
            {
              const i = e;
              const o = this._currentScope.lookUpSymbolRecursive(i.d.value);
              if (o && o.symbol) {
                const s = this._isAnnotationFinal(t);
                let l = t;
                if (s.isFinal) {
                  if (!s.finalTypeNode) {
                    l = undefined;
                  }
                }
                const p = this._isAnnotationClassVar(t);
                if (p.isClassVar) {
                  if (!p.classVarTypeNode) {
                    l = undefined;
                  }
                }
                let c = false;
                if (s.isFinal) {
                  const t = f.getEnclosingClassOrFunction(e);
                  if (t && t.nodeType === 10) {
                    if (((n = e.parent) === null || n === undefined ? undefined : n.nodeType) === 3 || ((r = (a = e.parent) === null || a === undefined ? undefined : a.parent) === null || r === undefined ? undefined : r.nodeType) === 3) {
                      c = true;
                    }
                  }
                }
                const u = {
                  type: 1,
                  node: e,
                  isConstant: C.isConstantName(i.d.value),
                  isFinal: s.isFinal,
                  typeAliasName: e,
                  uri: this._fileInfo.fileUri,
                  typeAnnotationNode: l,
                  range: d.convertTextRangeToRange(i, this._fileInfo.lines),
                  moduleName: this._fileInfo.moduleName,
                  isInExceptSuite: this._isInExceptSuite,
                  docString: this._getVariableDocString(e),
                  isExplicitBinding: this._currentScope.getBindingType(i.d.value) !== undefined
                };
                o.symbol.addDeclaration(u);
                if (c) {
                  o.symbol.setIsFinalVarInClassBody();
                }
                if (p.isClassVar) {
                  o.symbol.setIsClassVar();
                } else {
                  if (!c) {
                    o.symbol.setIsInstanceMember();
                  }
                }
                if (t.nodeType === 27) {
                  if (this._isDataclassesAnnotation(t.d.leftExpr, 'InitVar')) {
                    o.symbol.setIsInitVar();
                  } else {
                    if (this._isTypingAnnotation(t.d.leftExpr, 'Annotated') && t.d.items.length > 0) {
                      const e = t.d.items[0].d.valueExpr;
                      if (e.nodeType === 27 && this._isDataclassesAnnotation(e.d.leftExpr, 'InitVar')) {
                        o.symbol.setIsInitVar();
                      }
                    }
                  }
                }
              }
              s = true;
              break;
            }
          case 35:
            {
              const n = this._getMemberAccessInfo(e);
              if (n) {
                const a = e.d.member;
                let r = n.classScope.lookUpSymbol(a.d.value);
                if (!r) {
                  r = n.classScope.addSymbol(a.d.value, 1);
                  const e = this._fileInfo.diagnosticRuleSet.reportPrivateUsage !== 'none';
                  if (C.isPrivateOrProtectedName(a.d.value) && e) {
                    r.setIsPrivateMember();
                  }
                }
                if (n.isInstanceMember) {
                  r.setIsInstanceMember();
                } else {
                  r.setIsClassMember();
                }
                const i = this._isAnnotationFinal(t);
                const o = {
                  type: 1,
                  node: e.d.member,
                  isConstant: C.isConstantName(a.d.value),
                  isDefinedByMemberAccess: true,
                  isFinal: i.isFinal,
                  uri: this._fileInfo.fileUri,
                  typeAnnotationNode: i.isFinal && !i.finalTypeNode ? undefined : t,
                  range: d.convertTextRangeToRange(e.d.member, this._fileInfo.lines),
                  moduleName: this._fileInfo.moduleName,
                  isInExceptSuite: this._isInExceptSuite,
                  docString: this._getVariableDocString(e)
                };
                r.addDeclaration(o);
                s = true;
              }
              break;
            }
        }
        if (!s) {
          this._addDiagnostic(l.DiagnosticRule.reportInvalidTypeForm, m.LocMessage.annotationNotSupported(), t);
        }
      }
      _isTypingAnnotation(e, t) {
        return this._isKnownAnnotation(e, t, this._typingImportAliases, this._typingSymbolAliases);
      }
      _isDataclassesAnnotation(e, t) {
        return this._isKnownAnnotation(e, t, this._dataclassesImportAliases, this._dataclassesSymbolAliases);
      }
      _isKnownAnnotation(e, t, n, a) {
        let r = e;
        if (r.nodeType === 48 && r.d.annotation) {
          r = r.d.annotation;
        }
        if (r.nodeType === 38) {
          if (a.get(r.d.value) === t) {
            return true;
          }
        } else {
          if (r.nodeType === 35 && r.d.leftExpr.nodeType === 38 && r.d.member.d.value === t) {
            const e = r.d.leftExpr.d.value;
            return n.some(t => t === e);
          }
        }
        return false;
      }
      _getVariableDocString(e) {
        const t = f.getVariableDocStringNode(e);
        if (!t) {
          return;
        }
        const n = t.d.strings;
        if (n.length === 1) {
          return n[0].d.value;
        } else {
          return n.map(e => e.d.value).join('');
        }
      }
      _isAnnotationFinal(e) {
        let t;
        let n = false;
        if (e) {
          const a = this._isAnnotationClassVar(e);
          if (a == null ? undefined : a.classVarTypeNode) {
            e = a.classVarTypeNode;
          }
          if (this._isTypingAnnotation(e, 'Final')) {
            n = true;
          } else {
            if (e.nodeType === 27 && e.d.items.length > 0 && this._isTypingAnnotation(e.d.leftExpr, 'Annotated')) {
              return this._isAnnotationFinal(e.d.items[0].d.valueExpr);
            }
            if (e.nodeType === 27 && e.d.items.length === 1) {
              if (!!this._isAnnotationFinal(e.d.leftExpr).isFinal && e.d.items[0].d.argCategory === 0 && !e.d.items[0].d.name && !e.d.trailingComma) {
                n = true;
                t = e.d.items[0].d.valueExpr;
              }
            }
          }
        }
        return {
          isFinal: n,
          finalTypeNode: t
        };
      }
      _isAnnotationClassVar(e) {
        let t;
        let n = false;
        while (e) {
          if (e.nodeType === 48 && e.d.annotation) {
            e = e.d.annotation;
          }
          if (e.nodeType !== 27 || !(e.d.items.length > 0) || !this._isTypingAnnotation(e.d.leftExpr, 'Annotated')) {
            if (this._isTypingAnnotation(e, 'ClassVar')) {
              n = true;
              break;
            }
            if (e.nodeType === 27 && e.d.items.length === 1) {
              if (!!this._isAnnotationClassVar(e.d.leftExpr).isClassVar && e.d.items[0].d.argCategory === 0 && !e.d.items[0].d.name && !e.d.trailingComma) {
                n = true;
                t = e.d.items[0].d.valueExpr;
              }
              break;
            }
            break;
          }
          e = e.d.items[0].d.valueExpr;
        }
        return {
          isClassVar: n,
          classVarTypeNode: t
        };
      }
      _getMemberAccessInfo(e) {
        if (e.d.leftExpr.nodeType !== 38) {
          return;
        }
        const t = e.d.leftExpr.d.value;
        const n = f.getEnclosingFunction(e);
        if (!n) {
          return;
        }
        const a = f.getEnclosingClass(n, true);
        if (!a) {
          return;
        }
        let r = false;
        if (n.d.params.length < 1 || !n.d.params[0].d.name) {
          return;
        }
        const s = a.d.name.d.value;
        const i = n.d.params[0].d.name.d.value;
        if (t === s) {
          r = false;
        } else {
          if (t !== i) {
            return;
          }
          if (['__new__', '__init_subclass__', '__class_getitem__'].includes(n.d.name.d.value)) {
            r = false;
          } else {
            r = true;
            for (const e of n.d.decorators) {
              if (e.d.expr.nodeType === 38) {
                const t = e.d.expr.d.value;
                if (t === 'staticmethod') {
                  return;
                }
                if (t === 'classmethod') {
                  r = false;
                  break;
                }
              }
            }
          }
        }
        const l = y.getScope(a);
        o.assert(l !== undefined);
        return {
          classNode: a,
          methodNode: n,
          classScope: l,
          isInstanceMember: r
        };
      }
      _addImplicitImportsToLoaderActions(e, t) {
        e.filteredImplicitImports.forEach(e => {
          const n = t.implicitImports ? t.implicitImports.get(e.name) : undefined;
          if (n) {
            n.uri = e.uri;
            n.loadSymbolsFromPath = true;
          } else {
            if (!t.implicitImports) {
              t.implicitImports = new Map();
            }
            t.implicitImports.set(e.name, {
              uri: e.uri,
              loadSymbolsFromPath: true,
              implicitImports: new Map()
            });
          }
        });
      }
      _handleTypingStubAssignmentOrAnnotation(e) {
        if (!this._fileInfo.isTypingStubFile) {
          return false;
        }
        let t;
        if (e.nodeType === 54) {
          t = e;
        } else {
          if (e.d.leftExpr.nodeType !== 54) {
            return false;
          }
          t = e.d.leftExpr;
        }
        if (t.d.valueExpr.nodeType !== 38) {
          return false;
        }
        const n = t.d.valueExpr;
        const a = new Set(['Tuple', 'Generic', 'Protocol', 'Callable', 'Type', 'ClassVar', 'Final', 'Literal', 'TypedDict', 'Union', 'Optional', 'Annotated', 'TypeAlias', 'Concatenate', 'TypeGuard', 'Unpack', 'Self', 'NoReturn', 'Never', 'LiteralString', 'OrderedDict', 'TypeIs']);
        const r = n.d.value;
        if (!a.has(r)) {
          return false;
        }
        const s = {
          type: 7,
          node: t,
          uri: this._fileInfo.fileUri,
          range: d.convertTextRangeToRange(t, this._fileInfo.lines),
          moduleName: this._fileInfo.moduleName,
          isInExceptSuite: this._isInExceptSuite
        };
        const i = this._bindNameToScope(this._currentScope, t.d.valueExpr);
        if (i) {
          i.addDeclaration(s);
        }
        y.setDeclaration(e, s);
        return true;
      }
      _deferBinding(e) {
        if (!this._moduleSymbolOnly) {
          this._deferredBindingTasks.push({
            scope: this._currentScope,
            codeFlowExpressions: this._currentScopeCodeFlowExpressions,
            callback: e
          });
        }
      }
      _bindDeferred() {
        while (this._deferredBindingTasks.length > 0) {
          const e = this._deferredBindingTasks.shift();
          this._currentScope = e.scope;
          this._currentScopeCodeFlowExpressions = e.codeFlowExpressions;
          e.callback();
        }
      }
      _bindYield(e) {
        const t = f.getEnclosingFunction(e);
        if (t) {
          if (t.d.isAsync && e.nodeType === 61) {
            this._addSyntaxError(m.LocMessage.yieldFromOutsideAsync(), e);
          }
        } else {
          if (!f.getEnclosingLambda(e)) {
            this._addSyntaxError(m.LocMessage.yieldOutsideFunction(), e);
          }
        }
        if (this._targetFunctionDeclaration) {
          if (!this._targetFunctionDeclaration.yieldStatements) {
            this._targetFunctionDeclaration.yieldStatements = [];
          }
          this._targetFunctionDeclaration.yieldStatements.push(e);
          this._targetFunctionDeclaration.isGenerator = true;
        }
        if (e.d.expr) {
          this.walk(e.d.expr);
        }
        y.setFlowNode(e, this._currentFlowNode);
      }
      _getUniqueFlowNodeId() {
        this._codeFlowComplexity += 0.05;
        return g.getUniqueFlowNodeId();
      }
      _addDiagnostic(e, t, n) {
        const a = this._fileInfo.diagnosticRuleSet[e];
        let r;
        switch (a) {
          case 'error':
          case 'warning':
          case 'information':
            r = this._fileInfo.diagnosticSink.addDiagnosticWithTextRange(a, t, n);
            break;
          case 'none':
            break;
          default:
            return o.assertNever(a, `${a} is not expected`);
        }
        if (r) {
          r.setRule(e);
        }
        return r;
      }
      _addSyntaxError(e, t) {
        return this._fileInfo.diagnosticSink.addDiagnosticWithTextRange('error', e, t);
      }
    }
    exports.Binder = I;
    I._unreachableFlowNode = {
      flags: g.FlowFlags.Unreachable,
      id: g.getUniqueFlowNodeId()
    };
    class k extends T.ParseTreeWalker {
      constructor() {
        super(...arguments);
        this._containsYield = false;
      }
      checkContainsYield(e) {
        this.walk(e);
        return this._containsYield;
      }
      visitYield(e) {
        this._containsYield = true;
        return false;
      }
      visitYieldFrom(e) {
        this._containsYield = true;
        return false;
      }
    }
    exports.YieldFinder = k;
    class w extends T.ParseTreeWalker {
      constructor() {
        super(...arguments);
        this._containsReturn = false;
      }
      checkContainsReturn(e) {
        this.walk(e);
        return this._containsReturn;
      }
      visitReturn(e) {
        this._containsReturn = true;
        return false;
      }
    }
    exports.ReturnFinder = w;
    class S extends T.ParseTreeWalker {
      constructor(e) {
        super();
        this._currentScope = e;
      }
      visitClass(e) {
        const t = this._createNewScope(3, () => {
          this.walk(e.d.suite);
        });
        if (!y.getScope(e)) {
          y.setScope(e, t);
        }
        return false;
      }
      visitFunction(e) {
        const t = this._createNewScope(2, () => {
          this.walk(e.d.suite);
        });
        if (!y.getScope(e)) {
          y.setScope(e, t);
        }
        return false;
      }
      _createNewScope(e, t) {
        const n = this._currentScope;
        const a = new v.Scope(e, this._currentScope);
        this._currentScope = a;
        t();
        this._currentScope = n;
        return a;
      }
    }
    exports.DummyScopeGenerator = S;
  },
  32720: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CacheManager = undefined;
    const a = require(48281);
    const r = require(16066);
    class s {
      constructor(e = 0) {
        this._maxWorkers = e;
        this._pausedCount = 0;
        this._cacheOwners = [];
        this._sharedUsagePosition = 0;
        this._lastHeapStats = Date.now();
      }
      registerCacheOwner(e) {
        this._cacheOwners.push(e);
      }
      addWorker(e, t) {
        const n = this._getSharedUsageBuffer();
        if (n) {
          t.postMessage({
            requestType: 'cacheUsageBuffer',
            sharedUsageBuffer: n,
            data: e.toString()
          });
          t.on('exit', () => {
            new Float64Array(n)[e] = 0;
          });
        }
      }
      handleCachedUsageBufferMessage(e) {
        if (e.requestType === 'cacheUsageBuffer') {
          const t = parseInt(e.data || '0');
          const n = e.sharedUsageBuffer;
          if (n && t) {
            this._sharedUsageBuffer = n;
            this._sharedUsagePosition = t;
          }
        }
      }
      unregisterCacheOwner(e) {
        const t = this._cacheOwners.findIndex(t => t === e);
        if (t < 0) {
          a.fail('Specified cache provider not found');
        } else {
          this._cacheOwners.splice(t, 1);
        }
      }
      pauseTracking() {
        const e = this;
        e._pausedCount++;
        return {
          dispose() {
            e._pausedCount--;
          }
        };
      }
      getCacheUsage() {
        if (this._pausedCount > 0) {
          return -1;
        }
        let e = 0;
        this._cacheOwners.forEach(t => {
          e += t.getCacheUsage();
        });
        return e;
      }
      emptyCache(e) {
        if (e) {
          const t = r.getHeapStatistics();
          e.info(`Emptying type cache to avoid heap overflow. Used ${this._convertToMB(t.used_heap_size)} out of ${this._convertToMB(t.heap_size_limit)}.`);
        }
        this._cacheOwners.forEach(e => {
          e.emptyCache();
        });
      }
      getUsedHeapRatio(e) {
        if (this._pausedCount > 0) {
          return -1;
        }
        const t = r.getHeapStatistics();
        let n = this._getTotalHeapUsage(t);
        if (e && Date.now() - this._lastHeapStats > 1000) {
          this._lastHeapStats = Date.now();
          const a = r.getSystemMemoryInfo();
          e.info(`Heap stats: total_memory_size=${this._convertToMB(a.total)}, total_free_size=${this._convertToMB(a.free)}, total_heap_size=${this._convertToMB(t.total_heap_size)}, used_heap_size=${this._convertToMB(t.used_heap_size)}, cross_worker_used_heap_size=${this._convertToMB(n)}, total_physical_size=${this._convertToMB(t.total_physical_size)}, total_available_size=${this._convertToMB(t.total_available_size)}, heap_size_limit=${this._convertToMB(t.heap_size_limit)}`);
        }
        n += n * 0.05;
        return n / t.heap_size_limit;
      }
      _convertToMB(e) {
        return `${Math.round(e / 1048576)}MB`;
      }
      _getSharedUsageBuffer() {
        try {
          if (!this._sharedUsageBuffer && this._maxWorkers > 0) {
            this._sharedUsageBuffer = new SharedArrayBuffer((this._maxWorkers + 1) * 8);
          }
          return this._sharedUsageBuffer;
        } catch {
          return;
        }
      }
      _getTotalHeapUsage(e) {
        const t = this._getSharedUsageBuffer();
        if (t) {
          const n = new Float64Array(t);
          n[this._sharedUsagePosition] = e.used_heap_size;
          return n.reduce((e, t) => e + t, 0);
        }
        return e.used_heap_size;
      }
    }
    exports.CacheManager = s;
    (function (e) {
      e.is = function (e) {
        return e.registerCacheOwner !== undefined && e.unregisterCacheOwner !== undefined && e.pauseTracking !== undefined && e.getCacheUsage !== undefined && e.emptyCache !== undefined && e.getUsedHeapRatio !== undefined;
      };
    })(s || (exports.CacheManager = s = {}));
  },
  56798: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Checker = undefined;
    const i = require(56911);
    const o = require(58147);
    const l = require(48281);
    const p = require(11479);
    const d = require(65880);
    const c = require(63808);
    const u = require(88754);
    const m = require(27113);
    const y = require(65574);
    const g = require(67703);
    const h = require(85114);
    const f = require(23981);
    const T = __importStar(require(26687));
    const v = require(86672);
    const b = require(20516);
    const _ = require(57373);
    const C = require(28445);
    const I = require(83760);
    const k = require(45579);
    const w = require(21451);
    const S = require(75130);
    const A = require(47610);
    const x = require(44321);
    const P = __importStar(require(41557));
    const D = require(88744);
    const N = require(69932);
    const F = require(54500);
    const E = require(95952);
    const M = require(53266);
    const O = require(3113);
    const z = require(28676);
    const U = __importStar(require(12097));
    const V = require(4064);
    const R = require(66308);
    const L = require(90080);
    const B = require(83055);
    const j = require(18891);
    const q = require(21024);
    const G = require(92324);
    class W extends D.ParseTreeWalker {
      constructor(e, t, n, a, r) {
        super();
        this._importResolver = e;
        this._evaluator = t;
        this._sourceMapper = a;
        this._dependentFiles = r;
        this._isUnboundCheckSuppressed = false;
        this._scopedNodes = [];
        this._typeParamLists = [];
        this._moduleNode = n.parseTree;
        this._fileInfo = T.getFileInfo(this._moduleNode);
      }
      check() {
        this._scopedNodes.push(this._moduleNode);
        this._conditionallyReportShadowedModule();
        const e = T.getCodeFlowComplexity(this._moduleNode);
        if (e > L.maxCodeComplexity) {
          this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.codeTooComplexToAnalyze(), {
            start: 0,
            length: 0
          });
        }
        this._walkStatementsAndReportUnreachable(this._moduleNode.d.statements);
        const t = T.getDunderAllInfo(this._moduleNode);
        if (t) {
          this._evaluator.markNamesAccessed(this._moduleNode, t.names);
          this._reportUnusedDunderAllSymbols(t.stringNodes);
        }
        this._validateSymbolTables();
        this._reportDuplicateImports();
      }
      walk(e) {
        if (T.isCodeUnreachable(e)) {
          this._evaluator.suppressDiagnostics(e, () => {
            super.walk(e);
          });
        } else {
          super.walk(e);
        }
      }
      visitSuite(e) {
        this._walkStatementsAndReportUnreachable(e.d.statements);
        return false;
      }
      visitStatementList(e) {
        e.d.statements.forEach(e => {
          if (h.isExpressionNode(e)) {
            this._evaluator.getType(e);
            this._reportUnusedExpression(e);
          }
        });
        return true;
      }
      visitClass(e) {
        const t = this._evaluator.getTypeOfClass(e);
        if (e.d.typeParams) {
          this.walk(e.d.typeParams);
        }
        this.walk(e.d.suite);
        this.walkMultiple(e.d.decorators);
        this.walkMultiple(e.d.arguments);
        if (t) {
          if (q.ClassType.isProtocolClass(t.classType)) {
            e.d.arguments.forEach(e => {
              if (!e.d.name) {
                const n = this._evaluator.getType(e.d.valueExpr);
                if (n && q.isInstantiableClass(n) && !q.ClassType.isBuiltIn(n, 'Protocol') && !q.ClassType.isBuiltIn(n, 'Generic')) {
                  if (!q.ClassType.isProtocolClass(n)) {
                    this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.protocolBaseClass().format({
                      classType: t.classType.shared.name,
                      baseType: n.shared.name
                    }), e.d.valueExpr);
                  }
                }
              }
            });
            this._validateProtocolTypeParamVariance(e, t.classType);
          }
          if (!this._fileInfo.isStubFile) {
            this._validateSlotsClassVarConflict(t.classType);
          }
          this._validateBaseClassOverrides(t.classType);
          this._validateTypedDictOverrides(t.classType);
          this._validateOverloadDecoratorConsistency(t.classType);
          this._validateMultipleInheritanceBaseClasses(t.classType, e.d.name);
          this._validateMultipleInheritanceCompatibility(t.classType, e.d.name);
          this._validateConstructorConsistency(t.classType, e.d.name);
          this._validateFinalMemberOverrides(t.classType);
          this._validateInstanceVariableInitialization(e, t.classType);
          this._validateFinalClassNotAbstract(t.classType, e);
          this._validateDataClassPostInit(t.classType);
          this._validateEnumMembers(t.classType, e);
          if (q.ClassType.isTypedDictClass(t.classType)) {
            this._validateTypedDictClassSuite(e.d.suite);
          }
          if (q.ClassType.isEnumClass(t.classType)) {
            this._validateEnumClassOverride(e, t.classType);
          }
          this._evaluator.validateInitSubclassArgs(e, t.classType);
        }
        this._scopedNodes.push(e);
        return false;
      }
      visitFunction(e) {
        var t;
        var n;
        var a;
        if (e.d.typeParams) {
          this.walk(e.d.typeParams);
        }
        if (!this._fileInfo.diagnosticRuleSet.analyzeUnannotatedFunctions && !this._fileInfo.isStubFile) {
          if (P.isUnannotatedFunction(e)) {
            this._evaluator.addInformation(g.LocMessage.unannotatedFunctionSkipped().format({
              name: e.d.name.d.value
            }), e.d.name);
          }
        }
        const r = this._evaluator.getTypeOfFunction(e);
        const s = P.getEnclosingClass(e, true);
        if (r) {
          let i = false;
          const o = new Set();
          const l = x.getParamListDetails(r.functionType);
          e.d.params.forEach((e, t) => {
            var n;
            if (e.d.name) {
              if (e.d.category === 0 && t >= l.positionOnlyParamCount) {
                o.add(e.d.name.d.value);
              }
              if (e.d.category === 1) {
                const t = (n = e.d.annotation) !== null && n !== undefined ? n : e.d.annotationComment;
                if (t && t.nodeType === 35 && t.d.member.d.value === 'args') {
                  const e = this._evaluator.getType(t.d.leftExpr);
                  if (e && q.isParamSpec(e)) {
                    i = true;
                  }
                }
              } else {
                if (e.d.category === 2) {
                  i = false;
                }
              }
            }
            if (e.d.name && e.d.category === 0 && i) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.namedParamAfterParamSpecArgs().format({
                name: e.d.name.d.value
              }), e.d.name);
            }
            if (e.d.name && e.d.name.d.value !== '_') {
              const t = r.functionType.shared.parameters.findIndex(t => {
                var n;
                return t.name === ((n = e.d.name) === null || n === undefined ? undefined : n.d.value);
              });
              if (t >= 0) {
                const n = r.functionType.shared.parameters[t];
                const a = q.FunctionType.getParamType(r.functionType, t);
                if (this._fileInfo.diagnosticRuleSet.reportUnknownParameterType !== 'none') {
                  if (q.isUnknown(a) || q.isTypeVar(a) && a.shared.isSynthesized && !q.TypeVarType.isSelf(a)) {
                    this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownParameterType, g.LocMessage.paramTypeUnknown().format({
                      paramName: e.d.name.d.value
                    }), e.d.name);
                  } else {
                    if (G.isPartlyUnknown(a)) {
                      const t = new p.DiagnosticAddendum();
                      t.addMessage(g.LocAddendum.paramType().format({
                        paramType: this._evaluator.printType(a, {
                          expandTypeAlias: true
                        })
                      }));
                      this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownParameterType, g.LocMessage.paramTypePartiallyUnknown().format({
                        paramName: e.d.name.d.value
                      }) + t.getString(), e.d.name);
                    }
                  }
                }
                let s = false;
                if (q.FunctionParam.isTypeDeclared(n) || q.isTypeVar(a) && q.TypeVarType.isSelf(a)) {
                  s = true;
                }
                if (!s && this._fileInfo.diagnosticRuleSet.reportMissingParameterType !== 'none') {
                  this._evaluator.addDiagnostic(d.DiagnosticRule.reportMissingParameterType, g.LocMessage.paramAnnotationMissing().format({
                    name: e.d.name.d.value
                  }), e.d.name);
                }
              }
            }
          });
          if (l.hasUnpackedTypedDict) {
            const n = r.functionType.shared.parameters.length - 1;
            const a = q.FunctionType.getParamType(r.functionType, n);
            if (q.isClass(a) && a.shared.typedDictEntries) {
              const r = new Set();
              a.shared.typedDictEntries.knownItems.forEach((e, t) => {
                if (o.has(t)) {
                  r.add(t);
                }
              });
              if (r.size > 0) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.overlappingKeywordArgs().format({
                  names: [...r.values()].join(', ')
                }), (t = e.d.params[n].d.annotation) !== null && t !== undefined ? t : e.d.params[n]);
              }
            }
          }
          const c = r.functionType.shared.parameters.filter((e, t) => {
            const n = q.FunctionType.getParamType(r.functionType, t);
            return !!q.FunctionParam.isTypeDeclared(e) && !!q.isTypeVar(n) && !!q.isParamSpec(n) && e.category !== 0 && !!e.name && !!n.priv.paramSpecAccess;
          });
          if (c.length === 1 && c[0].name) {
            const t = e.d.params.find(e => {
              var t;
              return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === c[0].name;
            });
            const a = (n = t == null ? undefined : t.d.annotation) !== null && n !== undefined ? n : t == null ? undefined : t.d.annotationComment;
            if (a) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecArgsKwargsUsage(), a);
            }
          }
          if (this._fileInfo.isStubFile) {
            if (!e.d.returnAnnotation && !((a = e.d.funcAnnotationComment) === null || a === undefined ? undefined : a.d.returnAnnotation)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownParameterType, g.LocMessage.returnTypeUnknown(), e.d.name);
            }
          }
          if (s) {
            this._validateMethod(e, r.functionType, s);
          }
        }
        e.d.params.forEach((e, t) => {
          if (e.d.defaultValue) {
            this.walk(e.d.defaultValue);
          }
          if (e.d.annotation) {
            this.walk(e.d.annotation);
          }
          if (e.d.annotationComment) {
            this.walk(e.d.annotationComment);
          }
          if (r) {
            const n = e.d.annotation || e.d.annotationComment;
            if (n && t < r.functionType.shared.parameters.length) {
              const e = q.FunctionType.getParamType(r.functionType, t);
              const a = ['__init__', '__new__'];
              if (s && q.isTypeVar(e) && e.priv.scopeType === 0 && e.shared.declaredVariance === 3 && !e.shared.isSynthesized && !a.some(e => e === r.functionType.shared.name)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramTypeCovariant(), n);
              }
            }
          }
        });
        if (e.d.returnAnnotation) {
          this.walk(e.d.returnAnnotation);
        }
        if (e.d.funcAnnotationComment) {
          this.walk(e.d.funcAnnotationComment);
          if (this._fileInfo.diagnosticRuleSet.reportTypeCommentUsage !== 'none' && c.PythonVersion.isGreaterOrEqualTo(this._fileInfo.executionEnvironment.pythonVersion, c.pythonVersion3_5)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportTypeCommentUsage, g.LocMessage.typeCommentDeprecated(), e.d.funcAnnotationComment);
          }
        }
        this.walkMultiple(e.d.decorators);
        e.d.params.forEach(e => {
          if (e.d.name) {
            this.walk(e.d.name);
          }
        });
        const i = T.getCodeFlowComplexity(e);
        const o = i > L.maxCodeComplexity;
        if (o) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.codeTooComplexToAnalyze(), e.d.name);
        } else {
          this.walk(e.d.suite);
        }
        if (r) {
          if (!o) {
            this._validateFunctionReturn(e, r.functionType);
          }
          this._validateDunderSignatures(e, r.functionType, s !== undefined);
          this._validateTypeGuardFunction(e, r.functionType, s !== undefined);
          this._validateFunctionTypeVarUsage(e, r);
          this._validateGeneratorReturnType(e, r.functionType);
          this._reportDeprecatedClassProperty(e, r);
          if (!s && q.FunctionType.isFinal(r.functionType)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalNonMethod().format({
              name: e.d.name.d.value
            }), e.d.name);
          }
        }
        if (this._fileInfo.isStubFile && e.d.name.d.value === '__getattr__') {
          const t = E.getScopeForNode(e);
          if ((t == null ? undefined : t.type) === 4) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompleteStub, g.LocMessage.stubUsesGetAttr(), e.d.name);
          }
        }
        this._scopedNodes.push(e);
        if (r && q.isOverloaded(r.decoratedType) && r.functionType.priv.overloaded) {
          if (q.OverloadedType.getImplementation(r.decoratedType) !== r.functionType) {
            const t = q.OverloadedType.getOverloads(r.decoratedType);
            if (t.length > 1) {
              const n = 100;
              if (t.length < n) {
                this._validateOverloadConsistency(e, t[t.length - 1], t.slice(0, t.length - 1));
              }
            }
          }
          this._validateOverloadAttributeConsistency(e, r.decoratedType);
        }
        return false;
      }
      visitLambda(e) {
        this._evaluator.getType(e);
        this.walkMultiple([...e.d.params, e.d.expr]);
        e.d.params.forEach(e => {
          if (e.d.name) {
            const t = this._evaluator.getType(e.d.name);
            if (t) {
              if (q.isUnknown(t)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownLambdaType, g.LocMessage.paramTypeUnknown().format({
                  paramName: e.d.name.d.value
                }), e.d.name);
              } else {
                if (G.isPartlyUnknown(t)) {
                  this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownLambdaType, g.LocMessage.paramTypePartiallyUnknown().format({
                    paramName: e.d.name.d.value
                  }), e.d.name);
                }
              }
            }
          }
        });
        const t = this._evaluator.getType(e.d.expr);
        if (t) {
          if (q.isUnknown(t)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownLambdaType, g.LocMessage.lambdaReturnTypeUnknown(), e.d.expr);
          } else {
            if (G.isPartlyUnknown(t)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownLambdaType, g.LocMessage.lambdaReturnTypePartiallyUnknown().format({
                returnType: this._evaluator.printType(t, {
                  expandTypeAlias: true
                })
              }), e.d.expr);
            }
          }
        }
        this._scopedNodes.push(e);
        return false;
      }
      visitCall(e) {
        var t;
        this._validateIsInstanceCall(e);
        this._validateIllegalDefaultParamInitializer(e);
        this._validateStandardCollectionInstantiation(e);
        if ((this._fileInfo.diagnosticRuleSet.reportUnusedCallResult !== 'none' || this._fileInfo.diagnosticRuleSet.reportUnusedCoroutine !== 'none') && ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 47) {
          const t = e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'reveal_type';
          const n = this._evaluator.getType(e);
          if (!t && n && this._isTypeValidForUnusedValueTest(n)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnusedCallResult, g.LocMessage.unusedCallResult().format({
              type: this._evaluator.printType(n)
            }), e);
            if (q.isClassInstance(n) && q.ClassType.isBuiltIn(n, 'Coroutine')) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnusedCoroutine, g.LocMessage.unusedCoroutine(), e);
            }
          }
        }
        return true;
      }
      visitAwait(e) {
        var t;
        if (this._fileInfo.diagnosticRuleSet.reportUnusedCallResult !== 'none' && ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 47 && e.d.expr.nodeType === 9) {
          const t = this._evaluator.getType(e);
          if (t && this._isTypeValidForUnusedValueTest(t)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnusedCallResult, g.LocMessage.unusedCallResult().format({
              type: this._evaluator.printType(t)
            }), e);
          }
        }
        return true;
      }
      visitFor(e) {
        this._evaluator.evaluateTypesForStatement(e);
        if (e.d.typeComment) {
          this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.annotationNotSupported(), e.d.typeComment);
        }
        return true;
      }
      visitList(e) {
        this._validateIllegalDefaultParamInitializer(e);
        return true;
      }
      visitSet(e) {
        this._validateIllegalDefaultParamInitializer(e);
        return true;
      }
      visitDictionary(e) {
        this._validateIllegalDefaultParamInitializer(e);
        return true;
      }
      visitComprehension(e) {
        this._scopedNodes.push(e);
        return true;
      }
      visitComprehensionIf(e) {
        this._validateConditionalIsBool(e.d.testExpr);
        this._reportUnnecessaryConditionExpression(e.d.testExpr);
        return true;
      }
      visitIf(e) {
        this._validateConditionalIsBool(e.d.testExpr);
        this._reportUnnecessaryConditionExpression(e.d.testExpr);
        return true;
      }
      visitWhile(e) {
        this._validateConditionalIsBool(e.d.testExpr);
        this._reportUnnecessaryConditionExpression(e.d.testExpr);
        return true;
      }
      visitWith(e) {
        e.d.withItems.forEach(e => {
          this._evaluator.evaluateTypesForStatement(e);
        });
        if (e.d.typeComment) {
          this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.annotationNotSupported(), e.d.typeComment);
        }
        return true;
      }
      visitReturn(e) {
        var t;
        var n;
        var a;
        var r;
        var s;
        var i;
        let o;
        let l;
        const c = P.getEnclosingFunction(e);
        let u = c ? this._evaluator.getDeclaredReturnType(c) : undefined;
        o = e.d.expr ? (t = this._evaluator.getTypeResult(e.d.expr)) !== null && t !== undefined ? t : {
          type: q.UnknownType.create()
        } : {
          type: this._evaluator.getNoneType()
        };
        l = o.type;
        if ((n = l.props) === null || n === undefined ? undefined : n.specialForm) {
          l = l.props.specialForm;
        }
        if ((c == null ? undefined : c.d.isAsync) && e.d.expr) {
          const t = T.getDeclaration(c);
          if ((t == null ? undefined : t.type) === 5 && t.isGenerator) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.returnInAsyncGenerator(), e.d.expr);
          }
        }
        if (this._evaluator.isNodeReachable(e, undefined) && c) {
          if (u) {
            if (q.isNever(u)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.noReturnContainsReturn(), e);
            } else {
              const t = P.getTypeVarScopesForNode(e);
              u = this._evaluator.stripTypeGuard(u);
              let n = G.makeTypeVarsBound(u, t);
              let s = new p.DiagnosticAddendum();
              let i = false;
              if (this._evaluator.assignType(n, l, s)) {
                i = true;
              } else {
                const a = G.getTypeVarArgsRecursive(u);
                if (a && a.some(e => q.TypeVarType.hasConstraints(e))) {
                  const r = new v.ConstraintTracker();
                  for (const t of a) {
                    if (q.TypeVarType.hasConstraints(t)) {
                      const n = this._evaluator.narrowConstrainedTypeVar(e, q.TypeVarType.cloneAsBound(t));
                      if (n) {
                        r.setBounds(t, n);
                      }
                    }
                  }
                  if (!r.isEmpty()) {
                    n = this._evaluator.solveAndApplyConstraints(u, r);
                    n = G.makeTypeVarsBound(n, t);
                    if (this._evaluator.assignType(n, l, s)) {
                      i = true;
                    }
                  }
                }
              }
              if (!i) {
                if (o.expectedTypeDiagAddendum) {
                  s = o.expectedTypeDiagAddendum;
                }
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportReturnType, g.LocMessage.returnTypeMismatch().format({
                  exprType: this._evaluator.printType(l),
                  returnType: this._evaluator.printType(u)
                }) + s.getString(), (a = e.d.expr) !== null && a !== undefined ? a : e, (r = o.expectedTypeDiagAddendum) === null || r === undefined ? undefined : r.getEffectiveTextRange());
              }
            }
          }
          if (q.isUnknown(l)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownVariableType, g.LocMessage.returnTypeUnknown(), (s = e.d.expr) !== null && s !== undefined ? s : e);
          } else {
            if (G.isPartlyUnknown(l)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownVariableType, g.LocMessage.returnTypePartiallyUnknown().format({
                returnType: this._evaluator.printType(l, {
                  expandTypeAlias: true
                })
              }), (i = e.d.expr) !== null && i !== undefined ? i : e);
            }
          }
        }
        return true;
      }
      visitYield(e) {
        var t;
        const n = e.d.expr ? this._evaluator.getTypeResult(e.d.expr) : {
          type: this._evaluator.getNoneType()
        };
        this._validateYieldType(e, (t = n == null ? undefined : n.type) !== null && t !== undefined ? t : q.UnknownType.create(), n == null ? undefined : n.expectedTypeDiagAddendum);
        return true;
      }
      visitYieldFrom(e) {
        var t;
        var n;
        var a;
        var r;
        const s = this._evaluator.getType(e.d.expr) || q.UnknownType.create();
        let i;
        let o;
        if (q.isClassInstance(s) && q.ClassType.isBuiltIn(s, 'Coroutine')) {
          i = q.UnknownType.create();
        } else {
          i = (n = (t = this._evaluator.getTypeOfIterable({
            type: s
          }, false, e)) === null || t === undefined ? undefined : t.type) !== null && n !== undefined ? n : q.UnknownType.create();
          const l = G.getGeneratorTypeArgs(i);
          if (l) {
            i = l.length >= 1 ? l[0] : q.UnknownType.create();
            o = l.length >= 2 ? l[1] : undefined;
          } else {
            i = (r = (a = this._evaluator.getTypeOfIterator({
              type: s
            }, false, e)) === null || a === undefined ? undefined : a.type) !== null && r !== undefined ? r : q.UnknownType.create();
          }
        }
        this._validateYieldType(e, i, undefined, o);
        return true;
      }
      visitRaise(e) {
        if (e.d.expr) {
          this._evaluator.verifyRaiseExceptionType(e.d.expr, false);
        }
        if (e.d.fromExpr) {
          this._evaluator.verifyRaiseExceptionType(e.d.fromExpr, true);
        }
        return true;
      }
      visitExcept(e) {
        if (e.d.typeExpr) {
          this._evaluator.evaluateTypesForStatement(e);
          const t = this._evaluator.getType(e.d.typeExpr);
          if (t) {
            this._validateExceptionType(t, e.d.typeExpr, e.d.isExceptGroup);
          }
        }
        return true;
      }
      visitAssert(e) {
        if (e.d.exceptionExpr) {
          this._evaluator.getType(e.d.exceptionExpr);
        }
        this._validateConditionalIsBool(e.d.testExpr);
        const t = this._evaluator.getType(e.d.testExpr);
        if (t && q.isClassInstance(t) && G.isTupleClass(t) && t.priv.tupleTypeArgs && t.priv.tupleTypeArgs.length > 0) {
          if (!G.isUnboundedTupleClass(t)) {
            this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportAssertAlwaysTrue, g.LocMessage.assertAlwaysTrue(), e.d.testExpr);
          }
        }
        return true;
      }
      visitAssignment(e) {
        this._evaluator.evaluateTypesForStatement(e);
        if (e.d.annotationComment) {
          this._evaluator.getType(e.d.annotationComment);
          if (this._fileInfo.diagnosticRuleSet.reportTypeCommentUsage !== 'none' && c.PythonVersion.isGreaterOrEqualTo(this._fileInfo.executionEnvironment.pythonVersion, c.pythonVersion3_6)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportTypeCommentUsage, g.LocMessage.typeCommentDeprecated(), e.d.annotationComment);
          }
        }
        if (e.d.leftExpr.nodeType === 54) {
          const t = this._evaluator.getTypeOfAnnotation(e.d.leftExpr.d.annotation);
          if (q.isClassInstance(t) && q.ClassType.isBuiltIn(t, 'TypeAlias')) {
            const t = E.getScopeForNode(e);
            if (t && t.type !== 3 && t.type !== 4 && t.type !== 5) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasNotInModuleOrClass(), e.d.leftExpr.d.annotation);
            }
          }
        }
        return true;
      }
      visitAssignmentExpression(e) {
        this._evaluator.getType(e);
        return true;
      }
      visitAugmentedAssignment(e) {
        const t = this._evaluator.getTypeResult(e);
        this._reportDeprecatedUseForOperation(e.d.destExpr, t);
        return true;
      }
      visitIndex(e) {
        this._evaluator.getType(e);
        const t = this._evaluator.getType(e.d.leftExpr);
        if (t) {
          G.doForEachSubtype(t, n => {
            const a = G.getSpecializedTupleType(n);
            if (!q.isClassInstance(n) || !(a == null ? undefined : a.priv.tupleTypeArgs) || G.isUnboundedTupleClass(a)) {
              return;
            }
            const r = a.priv.tupleTypeArgs.length;
            if (e.d.items.length !== 1 || e.d.trailingComma || e.d.items[0].d.argCategory !== 0 || e.d.items[0].d.name) {
              return;
            }
            const s = this._evaluator.getType(e.d.items[0].d.valueExpr);
            if (s && q.isClassInstance(s) && q.ClassType.isBuiltIn(s, 'int') && G.isLiteralType(s) && typeof s.priv.literalValue == 'number') {
              if ((!(s.priv.literalValue < 0) && !(s.priv.literalValue < r) || !(s.priv.literalValue >= 0) && !(s.priv.literalValue + r >= 0)) && !this._evaluator.isTypeSubsumedByOtherType(a, t, false)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.tupleIndexOutOfRange().format({
                  index: s.priv.literalValue,
                  type: this._evaluator.printType(n)
                }), e);
              }
            }
          });
        }
        return true;
      }
      visitBinaryOperation(e) {
        if (e.d.operator === 12 || e.d.operator === 28 || e.d.operator === 39 || e.d.operator === 40) {
          if (!P.isWithinAssertExpression(e)) {
            this._validateComparisonTypes(e);
          }
        } else {
          if ((e.d.operator === 41 || e.d.operator === 42) && !P.isWithinAssertExpression(e)) {
            this._validateContainmentTypes(e);
          }
        }
        const t = this._evaluator.getTypeResult(e);
        this._reportDeprecatedUseForOperation(e.d.leftExpr, t);
        return true;
      }
      visitSlice(e) {
        this._evaluator.getType(e);
        return true;
      }
      visitUnpack(e) {
        this._evaluator.getType(e);
        return true;
      }
      visitTuple(e) {
        this._evaluator.getType(e);
        return true;
      }
      visitUnaryOperation(e) {
        if (e.d.operator === 38) {
          this._validateConditionalIsBool(e.d.expr);
        }
        const t = this._evaluator.getTypeResult(e);
        this._reportDeprecatedUseForOperation(e.d.expr, t);
        return true;
      }
      visitTernary(e) {
        this._evaluator.getType(e);
        this._validateConditionalIsBool(e.d.testExpr);
        this._reportUnnecessaryConditionExpression(e.d.testExpr);
        return true;
      }
      visitStringList(e) {
        const t = [];
        if (c.PythonVersion.isLessThan(this._fileInfo.executionEnvironment.pythonVersion, c.pythonVersion3_12)) {
          let n = e;
          while (n) {
            if (n.nodeType === 30) {
              t.push(n);
            }
            n = n.parent;
          }
        }
        for (const n of e.d.strings) {
          (n.nodeType === 49 ? [n.d.token] : n.d.middleTokens).forEach(e => {
            const n = f.getUnescapedString(e);
            let a = e.start;
            if (e.type === 5) {
              a += e.prefixLength + e.quoteMarkLength;
            }
            n.unescapeErrors.forEach(e => {
              if (e.errorType === 0) {
                this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportInvalidStringEscapeSequence, g.LocMessage.stringUnsupportedEscape(), {
                  start: a + e.offset,
                  length: e.length
                });
              }
            });
            if (t.length > 0) {
              if (e.escapedValue.indexOf('\\') >= 0) {
                this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.formatStringEscape(), {
                  start: a,
                  length: 1
                });
              }
            }
          });
          if (t.length > 0) {
            const e = 7;
            if (t.some(t => (t.d.token.flags & e) == (n.d.token.flags & e))) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.formatStringNestedQuote(), n);
            }
          }
        }
        if (e.d.annotation) {
          this._evaluator.getType(e);
        }
        if (e.d.strings.length > 1 && !e.d.hasParens) {
          this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportImplicitStringConcatenation, g.LocMessage.implicitStringConcat(), e);
        }
        return true;
      }
      visitFormatString(e) {
        e.d.fieldExprs.forEach(e => {
          this._evaluator.getType(e);
        });
        e.d.formatExprs.forEach(e => {
          this._evaluator.getType(e);
        });
        return true;
      }
      visitGlobal(e) {
        this._suppressUnboundCheck(() => {
          e.d.targets.forEach(e => {
            this._evaluator.getType(e);
            this.walk(e);
          });
        });
        return false;
      }
      visitNonlocal(e) {
        this._suppressUnboundCheck(() => {
          e.d.targets.forEach(e => {
            this._evaluator.getType(e);
            this.walk(e);
          });
        });
        return false;
      }
      visitName(e) {
        this._conditionallyReportPrivateUsage(e);
        if (!this._isUnboundCheckSuppressed) {
          this._reportUnboundName(e);
        }
        const t = this._evaluator.getType(e);
        this._reportDeprecatedUseForType(e, t);
        return true;
      }
      visitDel(e) {
        e.d.targets.forEach(e => {
          this._evaluator.verifyDeleteExpression(e);
          this.walk(e);
        });
        return false;
      }
      visitMemberAccess(e) {
        var t;
        const n = this._evaluator.getTypeResult(e.d.member);
        const a = (t = n == null ? undefined : n.type) !== null && t !== undefined ? t : q.UnknownType.create();
        const r = this._evaluator.getType(e.d.leftExpr);
        this._reportDeprecatedUseForType(e.d.member, a, r && q.isModule(r) && r.priv.moduleName === 'typing');
        if (n == null ? undefined : n.memberAccessDeprecationInfo) {
          this._reportDeprecatedUseForMemberAccess(e.d.member, n.memberAccessDeprecationInfo);
        }
        this._conditionallyReportPrivateUsage(e.d.member);
        this.walk(e.d.leftExpr);
        return false;
      }
      visitImportAs(e) {
        this._conditionallyReportShadowedImport(e);
        this._evaluator.evaluateTypesForStatement(e);
        return true;
      }
      visitImportFrom(e) {
        if (e.d.module.d.leadingDots === 0 && e.d.module.d.nameParts.length === 1 && e.d.module.d.nameParts[0].d.value === '__future__') {
          if (!P.isValidLocationForFutureImport(e)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.futureImportLocationNotAllowed(), e);
          }
        }
        this._conditionallyReportShadowedImport(e);
        if (e.d.isWildcardImport) {
          this._evaluator.evaluateTypesForStatement(e);
          const t = T.getImportInfo(e.d.module);
          if (t && t.isImportFound && t.importType !== 2 && !this._fileInfo.isStubFile) {
            this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportWildcardImportFromLibrary, g.LocMessage.wildcardLibraryImport(), e.d.wildcardToken || e);
          }
        } else {
          e.d.imports.forEach(e => {
            this._evaluator.evaluateTypesForStatement(e);
          });
        }
        return true;
      }
      visitImportFromAs(e) {
        var t;
        var n;
        var a;
        if (this._fileInfo.isStubFile) {
          return false;
        }
        const r = (t = this._evaluator.getDeclInfoForNameNode(e.d.name)) === null || t === undefined ? undefined : t.decls;
        if (!r) {
          return false;
        }
        for (const t of r) {
          if (!C.isAliasDeclaration(t) || !t.submoduleFallback || t.node !== e) {
            continue;
          }
          const n = this._evaluator.resolveAliasDeclaration(t, true);
          const a = n == null ? undefined : n.uri;
          if (!a || !O.isStubFile(a)) {
            continue;
          }
          const r = this._getImportResult(e, a);
          if (r) {
            this._addMissingModuleSourceDiagnosticIfNeeded(r, e.d.name);
            break;
          }
        }
        let s = false;
        if (((n = e.parent) === null || n === undefined ? undefined : n.nodeType) === 25 && e.parent.d.module.d.leadingDots === 0 && e.parent.d.module.d.nameParts.length === 1 && e.parent.d.module.d.nameParts[0].d.value === 'typing') {
          s = true;
        }
        const i = this._evaluator.getType((a = e.d.alias) !== null && a !== undefined ? a : e.d.name);
        this._reportDeprecatedUseForType(e.d.name, i, s);
        return false;
      }
      visitModuleName(e) {
        if (this._fileInfo.isStubFile) {
          return false;
        }
        const t = T.getImportInfo(e);
        l.assert(t !== undefined);
        this._addMissingModuleSourceDiagnosticIfNeeded(t, e);
        return false;
      }
      visitTypeParameterList(e) {
        this._typeParamLists.push(e);
        return true;
      }
      visitTypeParameter(e) {
        var t;
        var n;
        var a;
        var r;
        let s = (n = (t = e.parent) === null || t === undefined ? undefined : t.parent) === null || n === undefined ? undefined : n.parent;
        let i = false;
        while (s) {
          const t = P.getTypeVarScopeNode(s);
          if (!t) {
            break;
          }
          if (t.nodeType === 10) {
            const n = (a = this._evaluator.getTypeOfClass(t)) === null || a === undefined ? undefined : a.classType;
            if (n == null ? undefined : n.shared.typeParams.some(t => t.shared.name === e.d.name.d.value)) {
              i = true;
              break;
            }
          } else {
            if (t.nodeType === 31) {
              const n = (r = this._evaluator.getTypeOfFunction(t)) === null || r === undefined ? undefined : r.functionType;
              if (n == null ? undefined : n.shared.typeParams.some(t => t.shared.name === e.d.name.d.value)) {
                i = true;
                break;
              }
            }
          }
          s = t.parent;
        }
        if (i) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarUsedByOuterScope().format({
            name: e.d.name.d.value
          }), e.d.name);
        }
        return false;
      }
      visitTypeAlias(e) {
        const t = E.getScopeForNode(e);
        if (t && t.type !== 3 && t.type !== 4 && t.type !== 5) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasStatementBadScope(), e.d.name);
        }
        return true;
      }
      visitTypeAnnotation(e) {
        this._evaluator.getType(e.d.annotation);
        return true;
      }
      visitMatch(e) {
        this._evaluator.getType(e.d.expr);
        this._validateExhaustiveMatch(e);
        return true;
      }
      visitCase(e) {
        if (e.d.guardExpr) {
          this._validateConditionalIsBool(e.d.guardExpr);
        }
        this._evaluator.evaluateTypesForStatement(e.d.pattern);
        return true;
      }
      visitPatternClass(e) {
        N.validateClassPattern(this._evaluator, e);
        return true;
      }
      visitTry(e) {
        this._reportUnusedExceptStatements(e);
        return true;
      }
      visitError(e) {
        if (e.d.child) {
          this._evaluator.getType(e.d.child);
        }
        return false;
      }
      _getImportResult(e, t) {
        const n = this._importResolver.getConfigOptions().findExecEnvironment(t);
        const a = e.parent.d.module.d.leadingDots === 0 ? this._importResolver.getModuleNameForImport(t, n).moduleName : A.getRelativeModuleName(this._importResolver.fileSystem, this._fileInfo.fileUri, t, this._importResolver.getConfigOptions());
        if (a) {
          return this._importResolver.resolveImport(this._fileInfo.fileUri, n, S.createImportedModuleDescriptor(a));
        }
      }
      _addMissingModuleSourceDiagnosticIfNeeded(e, t) {
        if (!e.isNativeLib && e.isStubFile && e.importType !== 0 && e.nonStubImportResult && !e.nonStubImportResult.isImportFound) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportMissingModuleSource, g.LocMessage.importSourceResolveFailure().format({
            importName: e.importName,
            venv: this._fileInfo.executionEnvironment.name
          }), t);
        }
      }
      _validateConditionalIsBool(e) {
        const t = this._evaluator.getType(e);
        if (!t) {
          return;
        }
        let n = true;
        const a = new p.DiagnosticAddendum();
        this._evaluator.mapSubtypesExpandTypeVars(t, undefined, t => {
          var r;
          if (q.isAnyOrUnknown(t)) {
            return;
          }
          if (q.isClassInstance(t) && q.ClassType.isBuiltIn(t, 'bool')) {
            return;
          }
          const s = (r = this._evaluator.getTypeOfMagicMethodCall(t, '__bool__', [], e, undefined)) === null || r === undefined ? undefined : r.type;
          if (s && !q.isAnyOrUnknown(s)) {
            if (!q.isClassInstance(s) || !q.ClassType.isBuiltIn(s, 'bool')) {
              n = false;
              a.addMessage(g.LocAddendum.conditionalRequiresBool().format({
                operandType: this._evaluator.printType(t),
                boolReturnType: this._evaluator.printType(s)
              }));
            }
          }
        });
        if (!n) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.conditionalOperandInvalid().format({
            type: this._evaluator.printType(t)
          }) + a.getString(), e);
        }
      }
      _reportUnnecessaryConditionExpression(e) {
        if (e.nodeType === 7) {
          if (e.d.operator === 36 || e.d.operator === 37) {
            this._reportUnnecessaryConditionExpression(e.d.leftExpr);
            this._reportUnnecessaryConditionExpression(e.d.rightExpr);
          }
          return;
        }
        if (e.nodeType === 55) {
          if (e.d.operator === 38) {
            this._reportUnnecessaryConditionExpression(e.d.expr);
          }
          return;
        }
        const t = this._evaluator.getTypeOfExpression(e);
        let n = true;
        let a = true;
        G.doForEachSubtype(t.type, e => {
          e = this._evaluator.makeTopLevelTypeVarsConcrete(e);
          if (!q.isFunction(e) && !q.isOverloaded(e)) {
            n = false;
          }
          if (!q.isClassInstance(e) || !q.ClassType.isBuiltIn(e, 'Coroutine')) {
            a = false;
          }
        });
        if (n) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryComparison, g.LocMessage.functionInConditionalExpression(), e);
        }
        if (a) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryComparison, g.LocMessage.coroutineInConditionalExpression(), e);
        }
      }
      _reportUnusedExpression(e) {
        var t;
        var n;
        if (this._fileInfo.diagnosticRuleSet.reportUnusedExpression === 'none') {
          return;
        }
        let a = false;
        if ([55, 7, 40, 14, 38, 52].some(t => t === e.nodeType)) {
          a = true;
        } else {
          if ((e.nodeType === 34 || e.nodeType === 45 || e.nodeType === 18) && !e.d.items.some(e => e.nodeType === 11)) {
            a = true;
          }
        }
        if (a && this._fileInfo.ipythonMode === M.IPythonMode.CellDocs && ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 47 && e.parent.d.statements[e.parent.d.statements.length - 1] === e && ((n = e.parent.parent) === null || n === undefined ? undefined : n.nodeType) === 36 && e.parent.parent.d.statements[e.parent.parent.d.statements.length - 1] === e.parent) {
          a = false;
        }
        if (a) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnusedExpression, g.LocMessage.unusedExpression(), e);
        }
      }
      _validateExhaustiveMatch(e) {
        if (this._fileInfo.diagnosticRuleSet.reportMatchNotExhaustive === 'none') {
          return;
        }
        const t = this._evaluator.evaluateTypeForSubnode(e, () => {
          this._evaluator.evaluateTypesForMatchStatement(e);
        });
        if (t && !q.isNever(t.type)) {
          const n = new p.DiagnosticAddendum();
          n.addMessage(g.LocAddendum.matchIsNotExhaustiveType().format({
            type: this._evaluator.printType(t.type)
          }));
          n.addMessage(g.LocAddendum.matchIsNotExhaustiveHint());
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportMatchNotExhaustive, g.LocMessage.matchIsNotExhaustive() + n.getString(), e.d.expr);
        }
      }
      _suppressUnboundCheck(e) {
        const t = this._isUnboundCheckSuppressed;
        this._isUnboundCheckSuppressed = true;
        try {
          e();
        } finally {
          this._isUnboundCheckSuppressed = t;
        }
      }
      _validateIllegalDefaultParamInitializer(e) {
        if (this._fileInfo.diagnosticRuleSet.reportCallInDefaultInitializer !== 'none' && P.isWithinDefaultParamInitializer(e) && !this._fileInfo.isStubFile) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportCallInDefaultInitializer, g.LocMessage.defaultValueContainsCall(), e);
        }
      }
      _validateStandardCollectionInstantiation(e) {
        const t = this._evaluator.getType(e.d.leftExpr);
        if (t && q.isInstantiableClass(t) && q.ClassType.isBuiltIn(t) && !t.priv.includeSubclasses && t.priv.aliasName) {
          if (['List', 'Set', 'Dict', 'Tuple'].some(e => e === t.priv.aliasName)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.collectionAliasInstantiation().format({
              type: t.priv.aliasName,
              alias: t.shared.name
            }), e.d.leftExpr);
          }
        }
      }
      _validateContainmentTypes(e) {
        const t = this._evaluator.getType(e.d.leftExpr);
        const n = this._evaluator.getType(e.d.rightExpr);
        if (!t || !n) {
          return;
        }
        if (q.isNever(t) || q.isNever(n)) {
          return;
        }
        const a = j.getElementTypeForContainerNarrowing(n);
        if (!a) {
          return;
        }
        const r = j.narrowTypeForContainerElementType(this._evaluator, t, this._evaluator.makeTopLevelTypeVarsConcrete(a));
        if (q.isNever(r)) {
          const n = () => e.d.operator === 41 ? g.LocMessage.containmentAlwaysFalse() : g.LocMessage.containmentAlwaysTrue();
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryContains, n().format({
            leftType: this._evaluator.printType(t, {
              expandTypeAlias: true
            }),
            rightType: this._evaluator.printType(a, {
              expandTypeAlias: true
            })
          }), e);
        }
      }
      _validateComparisonTypes(e) {
        let t = e.d.rightExpr;
        if (t.nodeType === 7 && !t.d.hasParens && P.operatorSupportsChaining(t.d.operator)) {
          t = t.d.leftExpr;
        }
        const n = this._evaluator.getType(e.d.leftExpr);
        const a = this._evaluator.getType(t);
        if (!n || !a) {
          return;
        }
        if (q.isNever(n) || q.isNever(a)) {
          return;
        }
        const r = () => e.d.operator === 12 || e.d.operator === 39 ? g.LocMessage.comparisonAlwaysFalse() : g.LocMessage.comparisonAlwaysTrue();
        if (G.isLiteralTypeOrUnion(a) && G.isLiteralTypeOrUnion(n)) {
          if (z.evaluateStaticBoolExpression(e, this._fileInfo.executionEnvironment, this._fileInfo.definedConstants) === undefined) {
            let t = false;
            G.doForEachSubtype(n, e => {
              if (this._evaluator.assignType(a, e)) {
                t = true;
              }
            });
            G.doForEachSubtype(a, e => {
              if (this._evaluator.assignType(n, e)) {
                t = true;
              }
            });
            if (!t) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryComparison, r().format({
                leftType: this._evaluator.printType(n, {
                  expandTypeAlias: true
                }),
                rightType: this._evaluator.printType(a, {
                  expandTypeAlias: true
                })
              }), e);
            }
          }
        } else {
          let t = false;
          this._evaluator.mapSubtypesExpandTypeVars(n, {}, e => {
            if (!t) {
              this._evaluator.mapSubtypesExpandTypeVars(a, {}, n => {
                if (!t) {
                  if (this._isTypeComparable(e, n)) {
                    t = true;
                  }
                  return n;
                }
              });
              return e;
            }
          });
          if (!t) {
            const t = this._evaluator.printType(n, {
              expandTypeAlias: true
            });
            const s = this._evaluator.printType(a, {
              expandTypeAlias: true
            });
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryComparison, r().format({
              leftType: t,
              rightType: s
            }), e);
          }
        }
      }
      _isTypeComparable(e, t) {
        if (q.isAnyOrUnknown(e) || q.isAnyOrUnknown(t)) {
          return true;
        }
        if (q.isNever(e) || q.isNever(t)) {
          return false;
        }
        if (q.isModule(e) || q.isModule(t)) {
          return q.isTypeSame(e, t, {
            ignoreConditions: true
          });
        }
        if ((q.isFunction(e) || q.isOverloaded(e)) !== (q.isFunction(t) || q.isOverloaded(t))) {
          return false;
        }
        if (q.isInstantiableClass(e) || q.isClassInstance(e) && q.ClassType.isBuiltIn(e, 'type')) {
          if (q.isInstantiableClass(t) || q.isClassInstance(t) && q.ClassType.isBuiltIn(t, 'type')) {
            const n = q.ClassType.specialize(e, undefined);
            const a = q.ClassType.specialize(t, undefined);
            if (this._evaluator.assignType(n, a) || this._evaluator.assignType(a, n)) {
              return true;
            }
          }
          const n = e.shared.effectiveMetaclass;
          return !!n && !!q.isClass(n) && !!G.lookUpClassMember(n, '__eq__', 4);
        }
        if (q.isClassInstance(e)) {
          if (q.isClass(t)) {
            const n = q.ClassType.specialize(e, undefined);
            const a = q.ClassType.specialize(t, undefined);
            if (this._evaluator.assignType(n, a) || this._evaluator.assignType(a, n)) {
              return true;
            }
            if (q.ClassType.isBuiltIn(e) && q.ClassType.isBuiltIn(t) && q.TypeBase.isInstance(t)) {
              return false;
            }
          }
          const n = G.lookUpClassMember(q.ClassType.cloneAsInstantiable(e), '__eq__', 4);
          return !!n && (!q.ClassType.isDataClass(e) || !n.symbol.getSynthesizedType());
        }
        return true;
      }
      _validateGeneratorReturnType(e, t) {
        var n;
        if (!q.FunctionType.isGenerator(t)) {
          return;
        }
        const a = t.shared.declaredReturnType;
        if (!a) {
          return;
        }
        if (q.isNever(a)) {
          return;
        }
        const r = t.shared.declaration;
        if (!r || !r.yieldStatements || r.yieldStatements.length === 0) {
          return;
        }
        let s;
        s = !e.d.isAsync && q.isClassInstance(a) && q.ClassType.isBuiltIn(a, 'AwaitableGenerator') ? this._evaluator.getTypingType(e, 'AwaitableGenerator') : this._evaluator.getTypingType(e, e.d.isAsync ? 'AsyncGenerator' : 'Generator');
        if (!s || !q.isInstantiableClass(s)) {
          return;
        }
        const i = q.ClassType.cloneAsInstance(q.ClassType.specialize(s, [q.AnyType.create(), q.AnyType.create(), q.AnyType.create()]));
        const o = new p.DiagnosticAddendum();
        if (!this._evaluator.assignType(a, i, o)) {
          const t = e.d.isAsync ? g.LocMessage.generatorAsyncReturnType() : g.LocMessage.generatorSyncReturnType();
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeForm, t.format({
            yieldType: this._evaluator.printType(q.AnyType.create())
          }) + o.getString(), (n = e.d.returnAnnotation) !== null && n !== undefined ? n : e.d.name);
        }
      }
      _isTypeValidForUnusedValueTest(e) {
        return !G.isNoneInstance(e) && !q.isNever(e) && !q.isAnyOrUnknown(e);
      }
      _validateFunctionTypeVarUsage(e, t) {
        if (this._fileInfo.diagnosticRuleSet.reportInvalidTypeVarUse === 'none') {
          return;
        }
        const n = t.functionType;
        const a = new Map();
        const r = new Map();
        let s;
        let i;
        let o = true;
        if (q.FunctionType.isInstanceMethod(n) && e.d.name.d.value === '__init__') {
          const t = P.getEnclosingClassOrFunction(e);
          if (t && t.nodeType === 10) {
            const e = this._evaluator.getTypeOfClass(t);
            if (e && q.isClass(e.classType)) {
              i = e.classType;
            }
          }
        }
        const l = new P.NameNodeWalker((t, n, l) => {
          var p;
          var d;
          var c;
          var u;
          var m;
          var y;
          var g;
          const h = this._evaluator.getType(t);
          if (h && q.isTypeVar(h) && !q.TypeVarType.isSelf(h)) {
            if (h.priv.scopeId === P.getScopeIdForNode(e)) {
              let e = q.TypeVarType.hasConstraints(h) || h.shared.isDefaultExplicit || o && n !== undefined || q.isParamSpec(h);
              if (!e && l && n !== undefined) {
                const t = this._evaluator.getType(l);
                const a = (p = t == null ? undefined : t.props) === null || p === undefined ? undefined : p.typeAliasInfo;
                if ((a == null ? undefined : a.shared.typeParams) && n < a.shared.typeParams.length) {
                  e = true;
                }
              }
              const r = a.get(h.shared.name);
              const i = ((d = s == null ? undefined : s.d.defaultValue) === null || d === undefined ? undefined : d.nodeType) === 21;
              if (r) {
                r.nodes.push(t);
                if (s !== undefined) {
                  r.paramTypeUsageCount += 1;
                  if (i) {
                    r.paramTypeWithEllipsisUsageCount += 1;
                    if (!r.paramWithEllipsis) {
                      r.paramWithEllipsis = (u = s == null ? undefined : s.d.name) === null || u === undefined ? undefined : u.d.value;
                    }
                  }
                } else {
                  r.returnTypeUsageCount += 1;
                }
              } else {
                a.set(h.shared.name, {
                  nodes: [t],
                  typeVar: h,
                  paramTypeUsageCount: s !== undefined ? 1 : 0,
                  paramTypeWithEllipsisUsageCount: i ? 1 : 0,
                  returnTypeUsageCount: s === undefined ? 1 : 0,
                  paramWithEllipsis: i ? (c = s == null ? undefined : s.d.name) === null || c === undefined ? undefined : c.d.value : undefined,
                  isExempt: e
                });
              }
            }
            if (i && h.priv.scopeId === i.shared.typeVarScopeId) {
              const e = r.get(h.shared.name);
              const n = ((m = s == null ? undefined : s.d.defaultValue) === null || m === undefined ? undefined : m.nodeType) === 21;
              const a = !!h.shared.isDefaultExplicit;
              if (e) {
                e.nodes.push(t);
                if (s !== undefined) {
                  e.paramTypeUsageCount += 1;
                  if (n) {
                    e.paramTypeWithEllipsisUsageCount += 1;
                    if (!e.paramWithEllipsis) {
                      e.paramWithEllipsis = (g = s == null ? undefined : s.d.name) === null || g === undefined ? undefined : g.d.value;
                    }
                  }
                }
              } else {
                r.set(h.shared.name, {
                  typeVar: h,
                  nodes: [t],
                  paramTypeUsageCount: s !== undefined ? 1 : 0,
                  paramTypeWithEllipsisUsageCount: n ? 1 : 0,
                  returnTypeUsageCount: 0,
                  paramWithEllipsis: n ? (y = s == null ? undefined : s.d.name) === null || y === undefined ? undefined : y.d.value : undefined,
                  isExempt: a
                });
              }
            }
          }
        });
        e.d.params.forEach(e => {
          const t = e.d.annotation || e.d.annotationComment;
          if (t) {
            s = e;
            l.walk(t);
          }
        });
        s = undefined;
        if (e.d.returnAnnotation) {
          o = false;
          l.walk(e.d.returnAnnotation);
        }
        if (e.d.funcAnnotationComment) {
          e.d.funcAnnotationComment.d.paramAnnotations.forEach(e => {
            l.walk(e);
          });
          if (e.d.funcAnnotationComment.d.returnAnnotation) {
            o = false;
            l.walk(e.d.funcAnnotationComment.d.returnAnnotation);
          }
        }
        a.forEach(e => {
          var a;
          if (e.nodes.length === 1 && !e.isExempt) {
            let t;
            t = q.isTypeVarTuple(e.typeVar) ? '"tuple[object, ...]"' : e.typeVar.shared.boundType ? `"${this._evaluator.printType(G.convertToInstance(e.typeVar.shared.boundType))}"` : '"object"';
            const n = new p.DiagnosticAddendum();
            n.addMessage(g.LocAddendum.typeVarUnnecessarySuggestion().format({
              type: t
            }));
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeVarUse, g.LocMessage.typeVarUsedOnlyOnce().format({
              name: e.nodes[0].d.value
            }) + n.getString(), e.nodes[0]);
          }
          let r = e.returnTypeUsageCount > 0;
          if (e.returnTypeUsageCount === 1 && n.shared.declaredReturnType) {
            const t = n.shared.declaredReturnType;
            if (q.isUnion(t) && t.priv.subtypes.some(t => q.isTypeVar(t) && t.shared.name === e.nodes[0].d.value)) {
              r = false;
            }
          }
          const s = q.isOverloaded(t.decoratedType) && !q.FunctionType.isOverloaded(t.functionType);
          if (r && e.paramTypeWithEllipsisUsageCount > 0 && e.paramTypeUsageCount === e.paramTypeWithEllipsisUsageCount && !s) {
            const t = new p.DiagnosticAddendum();
            t.addMessage(g.LocAddendum.typeVarUnsolvableRemedy());
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeVarUse, g.LocMessage.typeVarPossiblyUnsolvable().format({
              name: e.nodes[0].d.value,
              param: (a = e.paramWithEllipsis) !== null && a !== undefined ? a : ''
            }) + t.getString(), e.nodes[0]);
          }
        });
        r.forEach(e => {
          var t;
          if (e.paramTypeWithEllipsisUsageCount > 0 && e.paramTypeUsageCount === e.paramTypeWithEllipsisUsageCount && !e.isExempt) {
            const n = new p.DiagnosticAddendum();
            n.addMessage(g.LocAddendum.typeVarUnsolvableRemedy());
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeVarUse, g.LocMessage.typeVarPossiblyUnsolvable().format({
              name: e.nodes[0].d.value,
              param: (t = e.paramWithEllipsis) !== null && t !== undefined ? t : ''
            }) + n.getString(), e.nodes[0]);
          }
        });
      }
      _validateOverloadAttributeConsistency(e, t) {
        var n;
        var a;
        var r;
        var s;
        var i;
        var o;
        if (this._fileInfo.diagnosticRuleSet.reportInconsistentOverload === 'none') {
          return;
        }
        let l = 0;
        let p = 0;
        const c = q.OverloadedType.getOverloads(t);
        if (c.length === 0) {
          return;
        }
        let u = c.length;
        c.forEach(e => {
          if (q.FunctionType.isStaticMethod(e)) {
            l++;
          }
          if (q.FunctionType.isClassMethod(e)) {
            p++;
          }
        });
        const m = q.OverloadedType.getImplementation(t);
        if (m && q.isFunction(m)) {
          u += 1;
          if (q.FunctionType.isStaticMethod(m)) {
            l++;
          }
          if (q.FunctionType.isClassMethod(m)) {
            p++;
          }
        }
        if (l > 0 && l < u) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadStaticMethodInconsistent().format({
            name: e.d.name.d.value
          }), (r = (a = (n = c[0]) === null || n === undefined ? undefined : n.shared.declaration) === null || a === undefined ? undefined : a.node.d.name) !== null && r !== undefined ? r : e.d.name);
        }
        if (p > 0 && p < u) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadClassMethodInconsistent().format({
            name: e.d.name.d.value
          }), (o = (i = (s = c[0]) === null || s === undefined ? undefined : s.shared.declaration) === null || i === undefined ? undefined : i.node.d.name) !== null && o !== undefined ? o : e.d.name);
        }
      }
      _validateOverloadConsistency(e, t, n) {
        if (this._fileInfo.diagnosticRuleSet.reportOverlappingOverload !== 'none') {
          for (let a = 0; a < n.length; a++) {
            const r = n[a];
            if (this._isOverlappingOverload(t, r, false)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportOverlappingOverload, g.LocMessage.overlappingOverload().format({
                name: e.d.name.d.value,
                obscured: n.length + 1,
                obscuredBy: a + 1
              }), e.d.name);
              break;
            }
          }
          for (let a = 0; a < n.length; a++) {
            const r = n[a];
            if (this._isOverlappingOverload(r, t, true)) {
              const s = q.FunctionType.getEffectiveReturnType(r);
              const i = q.FunctionType.getEffectiveReturnType(t);
              if (s && i && !this._evaluator.assignType(i, s, undefined, undefined, 0)) {
                const t = this._findNodeForOverload(e, r);
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportOverlappingOverload, g.LocMessage.overloadReturnTypeMismatch().format({
                  name: e.d.name.d.value,
                  newIndex: n.length + 1,
                  prevIndex: a + 1
                }), (t || e).d.name);
                break;
              }
            }
          }
        }
      }
      _findNodeForOverload(e, t) {
        var n;
        const a = (n = this._evaluator.getDeclInfoForNameNode(e.d.name)) === null || n === undefined ? undefined : n.decls;
        if (a) {
          for (const e of a) {
            if (e.type === 5) {
              const n = this._evaluator.getTypeOfFunction(e.node);
              if ((n == null ? undefined : n.functionType) === t) {
                return e.node;
              }
            }
          }
        }
      }
      _isOverlappingOverload(e, t, n) {
        var a;
        var r;
        var s;
        if (q.FunctionType.isInstanceMethod(e) && e.shared.name === '__get__') {
          return false;
        }
        let i = 80;
        if (n) {
          i |= 32;
        }
        const o = (a = e.shared.declaration) === null || a === undefined ? undefined : a.node;
        if (o) {
          const t = P.getTypeVarScopesForNode(o);
          e = G.makeTypeVarsBound(e, t);
        }
        const l = (s = (r = t.shared.declaration) === null || r === undefined ? undefined : r.node) === null || s === undefined ? undefined : s.parent;
        if (l) {
          const e = P.getTypeVarScopesForNode(l);
          t = G.makeTypeVarsBound(t, e);
        }
        return this._evaluator.assignType(e, t, undefined, undefined, i);
      }
      _validateOverloadImplementation(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        var o;
        const l = new v.ConstraintTracker();
        let d = t;
        let c = e;
        const u = (r = (a = t.shared.declaration) === null || a === undefined ? undefined : a.node) === null || r === undefined ? undefined : r.parent;
        if (u) {
          const e = P.getTypeVarScopesForNode(u);
          d = G.makeTypeVarsBound(t, e);
        }
        const m = (s = e.shared.declaration) === null || s === undefined ? undefined : s.node;
        if (m) {
          const t = P.getTypeVarScopesForNode(m);
          c = G.makeTypeVarsBound(e, t);
        }
        let y = this._evaluator.assignType(c, d, n, l, 578);
        const h = this._evaluator.solveAndApplyConstraints((i = q.FunctionType.getEffectiveReturnType(c)) !== null && i !== undefined ? i : this._evaluator.getInferredReturnType(c), l);
        const f = this._evaluator.solveAndApplyConstraints((o = q.FunctionType.getEffectiveReturnType(d)) !== null && o !== undefined ? o : this._evaluator.getInferredReturnType(d), l);
        const T = new p.DiagnosticAddendum();
        if (!q.isNever(h) && !this._evaluator.assignType(f, h, T.createAddendum(), l, 0)) {
          T.addMessage(g.LocAddendum.functionReturnTypeMismatch().format({
            sourceType: this._evaluator.printType(h),
            destType: this._evaluator.printType(f)
          }));
          if (n != null) {
            n.addAddendum(T);
          }
          y = false;
        }
        return y;
      }
      _walkStatementsAndReportUnreachable(e) {
        let t;
        let n = false;
        for (const a of e) {
          if (!n) {
            const r = this._evaluator.getNodeReachability(a, t);
            if (r !== B.Reachability.Reachable) {
              const t = a.start;
              const s = e[e.length - 1];
              const i = u.TextRange.getEnd(s);
              this._evaluator.addUnreachableCode(a, r, {
                start: t,
                length: i - t
              });
              n = true;
            }
          }
          if (!n && this._fileInfo.isStubFile) {
            this._validateStubStatement(a);
          }
          this.walk(a);
          t = a;
        }
      }
      _validateStubStatement(e) {
        switch (e.nodeType) {
          case 22:
          case 31:
          case 10:
          case 0:
            break;
          case 57:
          case 29:
          case 53:
          case 58:
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidStubStatement, g.LocMessage.invalidStubStatement(), e);
            break;
          case 47:
            for (const t of e.d.statements) {
              let e = true;
              switch (t.nodeType) {
                case 2:
                case 4:
                case 6:
                case 7:
                case 14:
                case 17:
                case 18:
                case 27:
                case 29:
                case 30:
                case 32:
                case 33:
                case 34:
                case 35:
                case 38:
                case 39:
                case 40:
                case 43:
                case 44:
                case 45:
                case 46:
                case 51:
                case 52:
                case 53:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                  e = false;
                  break;
                case 5:
                  e = t.d.operator === 1 && t.d.leftExpr.nodeType === 38 && t.d.leftExpr.d.value === '__all__';
                  break;
                case 9:
                  e = t.d.leftExpr.nodeType === 35 && t.d.leftExpr.d.leftExpr.nodeType === 38 && t.d.leftExpr.d.leftExpr.d.value === '__all__';
              }
              if (!e) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidStubStatement, g.LocMessage.invalidStubStatement(), t);
              }
            }
        }
      }
      _validateExceptionTypeRecursive(e, t, n, a, r, s) {
        G.doForEachSubtype(e, e => {
          var i;
          if (!q.isAnyOrUnknown(e) && q.isClass(e)) {
            if (q.TypeBase.isInstantiable(e)) {
              i = e;
              if (n && q.isInstantiableClass(n) && !G.derivesFromClassRecursive(i, n, false)) {
                t.addMessage(g.LocMessage.exceptionTypeIncorrect().format({
                  type: this._evaluator.printType(e)
                }));
              }
              if (s && (e => !a || !q.isInstantiableClass(a) || G.derivesFromClassRecursive(e, a, false))(e)) {
                t.addMessage(g.LocMessage.exceptionGroupTypeIncorrect());
              }
              return;
            }
            if (r && e.priv.tupleTypeArgs) {
              e.priv.tupleTypeArgs.forEach(e => {
                this._validateExceptionTypeRecursive(e.type, t, n, a, false, s);
              });
              return;
            }
            t.addMessage(g.LocMessage.exceptionTypeIncorrect().format({
              type: this._evaluator.printType(e)
            }));
          }
        });
      }
      _validateExceptionType(e, t, n) {
        const a = this._evaluator.getBuiltInType(t, 'BaseException');
        const r = this._evaluator.getBuiltInType(t, 'BaseExceptionGroup');
        const s = new p.DiagnosticAddendum();
        this._validateExceptionTypeRecursive(e, s, a, r, true, n);
        if (!s.isEmpty()) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.exceptionTypeNotClass().format({
            type: this._evaluator.printType(e)
          }), t);
        }
      }
      _reportUnusedDunderAllSymbols(e) {
        if (this._fileInfo.diagnosticRuleSet.reportUnsupportedDunderAll === 'none') {
          return;
        }
        const t = T.getScope(this._moduleNode);
        if (t) {
          e.forEach(e => {
            if (!t.symbolTable.has(e.d.value)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnsupportedDunderAll, g.LocMessage.dunderAllSymbolNotPresent().format({
                name: e.d.value
              }), e);
            }
          });
        }
      }
      _validateSymbolTables() {
        var e;
        const t = (e = this._dependentFiles) === null || e === undefined ? undefined : e.map(e => T.getFileInfo(e.parseTree));
        for (const e of this._scopedNodes) {
          const n = T.getScope(e);
          if (n) {
            n.symbolTable.forEach((e, a) => {
              this._conditionallyReportUnusedSymbol(a, e, n.type, t);
              this._reportIncompatibleDeclarations(a, e);
              this._reportMultipleFinalDeclarations(a, e, n.type);
              this._reportFinalInLoop(e);
              this._reportMultipleTypeAliasDeclarations(a, e);
              this._reportInvalidOverload(a, e);
            });
          }
        }
        const n = this._fileInfo.accessedSymbolSet;
        for (const e of this._typeParamLists) {
          const t = T.getScope(e);
          for (const a of e.d.params) {
            const e = t == null ? undefined : t.symbolTable.get(a.d.name.d.value);
            if (!e) {
              return;
            }
            if (!n.has(e.id)) {
              e.getDeclarations().forEach(e => {
                this._conditionallyReportUnusedDeclaration(e, false);
              });
            }
          }
        }
      }
      _reportInvalidOverload(e, t) {
        const n = t.getTypedDeclarations();
        if (n.length === 0) {
          return;
        }
        const a = n[0];
        if (a.type !== 5) {
          return;
        }
        const r = this._evaluator.getEffectiveTypeOfSymbol(t);
        const s = q.isOverloaded(r) ? q.OverloadedType.getOverloads(r) : q.isFunction(r) && q.FunctionType.isOverloaded(r) ? [r] : [];
        if (q.isOverloaded(r)) {
          const e = q.OverloadedType.getOverloads(r);
          if (e.length > 0 && e[0].shared.name === '') {
            return;
          }
        } else {
          if (q.isFunction(r) && r.shared.name === '') {
            return;
          }
        }
        if (s.length === 1) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.singleOverload().format({
            name: e
          }), a.node.d.name);
        }
        if (this._fileInfo.isStubFile || s.length === 0) {
          return;
        }
        let i;
        if (q.isOverloaded(r)) {
          i = q.OverloadedType.getImplementation(r);
        } else {
          if (q.isFunction(r) && !q.FunctionType.isOverloaded(r)) {
            i = r;
          }
        }
        if (i) {
          if (q.isOverloaded(r) && this._fileInfo.diagnosticRuleSet.reportInconsistentOverload !== 'none') {
            q.OverloadedType.getOverloads(r).forEach((t, n) => {
              var r;
              var s;
              var o;
              var l;
              const c = new p.DiagnosticAddendum();
              if (i && q.isFunction(i) && !this._validateOverloadImplementation(t, i, c) && i.shared.declaration) {
                const p = this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadImplementationMismatch().format({
                  name: e,
                  index: n + 1
                }) + c.getString(), i.shared.declaration.node.d.name);
                if (p && t.shared.declaration) {
                  p.addRelatedInfo(g.LocAddendum.overloadSignature(), (s = (r = t.shared.declaration) === null || r === undefined ? undefined : r.uri) !== null && s !== undefined ? s : a.uri, (l = (o = t.shared.declaration) === null || o === undefined ? undefined : o.range) !== null && l !== undefined ? l : a.range);
                }
              }
            });
          }
        } else {
          const e = P.getEnclosingClassOrFunction(a.node);
          if (e && e.nodeType === 10) {
            const t = this._evaluator.getTypeOfClass(e);
            if (t) {
              if (q.ClassType.isProtocolClass(t.classType)) {
                return;
              }
              if (q.ClassType.supportsAbstractMethods(t.classType) && q.isOverloaded(r) && q.OverloadedType.getOverloads(r).every(e => q.FunctionType.isAbstractMethod(e))) {
                return;
              }
            }
          }
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportNoOverloadImplementation, g.LocMessage.overloadWithoutImplementation().format({
            name: a.node.d.name.d.value
          }), a.node.d.name);
        }
      }
      _reportFinalInLoop(e) {
        if (!this._evaluator.isFinalVariable(e)) {
          return;
        }
        const t = e.getDeclarations();
        if (t.length !== 0 && P.isWithinLoop(t[0].node)) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalInLoop(), t[0].node);
        }
      }
      _reportMultipleFinalDeclarations(e, t, n) {
        if (!this._evaluator.isFinalVariable(t)) {
          return;
        }
        const a = t.getDeclarations();
        let r = false;
        let s = false;
        a.forEach(t => {
          var a;
          if (this._evaluator.isFinalVariableDeclaration(t)) {
            if (r) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalRedeclaration().format({
                name: e
              }), t.node);
            }
            r = true;
          }
          let i = false;
          if (t.type === 1) {
            if (t.inferredTypeSource) {
              if (s) {
                let e = false;
                if (n === 3) {
                  const n = P.getEnclosingClassOrFunction(t.node);
                  if ((n == null ? undefined : n.nodeType) === 31) {
                    e = true;
                  }
                }
                if (!e) {
                  i = true;
                }
              }
              s = true;
            }
          } else {
            i = true;
          }
          if (i) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalReassigned().format({
              name: e
            }), (a = I.getNameNodeForDeclaration(t)) !== null && a !== undefined ? a : t.node);
          }
        });
        if (!s && !this._fileInfo.isStubFile) {
          const n = a.find(e => e.type === 1 && e.isFinal);
          if (n) {
            let a = false;
            let r = false;
            if (t.isClassMember() && !t.isClassVar()) {
              const e = P.getEnclosingClass(n.node, true);
              if (e) {
                const t = this._evaluator.getTypeOfClass(e);
                if (t && q.isClass(t.decoratedType)) {
                  if (q.ClassType.isDataClass(t.decoratedType)) {
                    a = true;
                  }
                  if (q.ClassType.isProtocolClass(t.decoratedType)) {
                    r = true;
                  }
                }
              }
            }
            if (!a && !r) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalUnassigned().format({
                name: e
              }), n.node);
            }
          }
        }
      }
      _reportMultipleTypeAliasDeclarations(e, t) {
        const n = t.getDeclarations();
        const a = n.find(e => this._evaluator.isExplicitTypeAliasDeclaration(e));
        if (a && n.length > 1) {
          n.forEach(t => {
            if (t !== a) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, g.LocMessage.typeAliasRedeclared().format({
                name: e
              }), t.node);
            }
          });
        }
      }
      _reportIncompatibleDeclarations(e, t) {
        var n;
        var a;
        var r;
        var s;
        const i = V.getLastTypedDeclarationForSymbol(t);
        if (!i) {
          return;
        }
        if (e === '_') {
          return;
        }
        let o;
        let l = t.getDeclarations().filter(e => e !== i);
        if (i.type === 5) {
          const e = this._evaluator.getTypeOfFunction(i.node);
          l = l.filter(t => {
            if (t.type !== 5) {
              return true;
            }
            const n = this._evaluator.getTypeOfFunction(t.node);
            if (!n) {
              return true;
            }
            const a = e ? this._evaluator.makeTopLevelTypeVarsConcrete(e.decoratedType) : undefined;
            if (a && q.isClassInstance(a) && q.ClassType.isPropertyClass(a) && q.isClassInstance(n.decoratedType) && q.ClassType.isPropertyClass(n.decoratedType)) {
              return n.decoratedType.shared.typeSourceId !== a.shared.typeSourceId;
            } else {
              return !q.FunctionType.isOverloaded(n.functionType);
            }
          });
        }
        if (l.length === 0) {
          return;
        }
        o = i.type === 5 ? i.isMethod ? g.LocAddendum.seeMethodDeclaration() : g.LocAddendum.seeFunctionDeclaration() : i.type === 6 ? g.LocAddendum.seeClassDeclaration() : i.type === 2 ? g.LocAddendum.seeParameterDeclaration() : i.type === 1 ? g.LocAddendum.seeVariableDeclaration() : i.type === 4 ? g.LocAddendum.seeTypeAliasDeclaration() : g.LocAddendum.seeDeclaration();
        const p = e => {
          if (e) {
            let t;
            if (i.type === 5 || i.type === 6) {
              t = i.node.d.name;
            } else {
              if (i.type === 1) {
                if (i.node.nodeType === 38) {
                  t = i.node;
                }
              } else {
                if (i.type === 2 || i.type === 3) {
                  if (i.node.d.name) {
                    t = i.node.d.name;
                  }
                }
              }
            }
            if (t) {
              e.addRelatedInfo(o, i.uri, i.range);
            }
          }
        };
        for (const t of l) {
          if (t.type === 6) {
            let n = false;
            if (i.type === 3) {
              n = true;
            }
            if (!n) {
              p(this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, g.LocMessage.obscuredClassDeclaration().format({
                name: e
              }), t.node.d.name));
            }
          } else {
            if (t.type === 5) {
              const r = (n = this._evaluator.getTypeForDeclaration(i)) === null || n === undefined ? undefined : n.type;
              let s = false;
              if (r && q.isFunction(r)) {
                this._evaluator.getInferredReturnType(r);
              }
              const o = (a = this._evaluator.getTypeForDeclaration(t)) === null || a === undefined ? undefined : a.type;
              const l = P.getEnclosingSuite(i.node) === P.getEnclosingSuite(t.node);
              if (o && q.isFunction(o)) {
                this._evaluator.getInferredReturnType(o);
              }
              if (!l && r && o && q.isTypeSame(r, o)) {
                s = true;
              }
              if (i.type === 3) {
                s = true;
              }
              if (!s) {
                p(this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, t.isMethod ? g.LocMessage.obscuredMethodDeclaration().format({
                  name: e
                }) : g.LocMessage.obscuredFunctionDeclaration().format({
                  name: e
                }), t.node.d.name));
              }
            } else {
              if (t.type === 2) {
                if (t.node.d.name) {
                  let n = false;
                  if (i.type === 3) {
                    n = true;
                  }
                  if (!n) {
                    const n = g.LocMessage.obscuredParameterDeclaration();
                    p(this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, n.format({
                      name: e
                    }), t.node.d.name));
                  }
                }
              } else {
                if (t.type === 1) {
                  const n = (r = this._evaluator.getTypeForDeclaration(i)) === null || r === undefined ? undefined : r.type;
                  if (t.typeAnnotationNode && t.node.nodeType === 38) {
                    let a = false;
                    const r = (s = this._evaluator.getTypeForDeclaration(t)) === null || s === undefined ? undefined : s.type;
                    if (n && r && q.isTypeSame(n, r)) {
                      a = true;
                    }
                    if (i.type === 3) {
                      a = true;
                    }
                    if (!a) {
                      p(this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, g.LocMessage.obscuredVariableDeclaration().format({
                        name: e
                      }), t.node));
                    }
                  }
                } else {
                  if (t.type === 4) {
                    p(this._evaluator.addDiagnostic(d.DiagnosticRule.reportRedeclaration, g.LocMessage.obscuredTypeAliasDeclaration().format({
                      name: e
                    }), t.node.d.name));
                  }
                }
              }
            }
          }
        }
      }
      _conditionallyReportUnusedSymbol(e, t, n, a) {
        const r = this._fileInfo.accessedSymbolSet;
        if (t.isIgnoredForProtocolMatch() || r.has(t.id)) {
          return;
        }
        if (a && a.some(e => e.accessedSymbolSet.has(t.id))) {
          return;
        }
        if (e === '_') {
          return;
        }
        if (U.isDunderName(e)) {
          return;
        }
        t.getDeclarations().forEach(t => {
          this._conditionallyReportUnusedDeclaration(t, this._isSymbolPrivate(e, n));
        });
      }
      _conditionallyReportUnusedDeclaration(e, t) {
        var n;
        let a;
        let r;
        let s;
        let i;
        switch (e.type) {
          case 8:
            a = this._fileInfo.diagnosticRuleSet.reportUnusedImport;
            i = d.DiagnosticRule.reportUnusedImport;
            if (e.node.nodeType === 24) {
              if (e.node.d.alias) {
                if (e.node.d.alias.d.value !== e.moduleName) {
                  r = e.node.d.alias;
                }
              } else {
                const t = e.node.d.module.d.nameParts;
                if (t.length > 0) {
                  const e = t.map(e => e.d.value).join('.');
                  let n = {
                    start: t[0].start,
                    length: t[0].length
                  };
                  n = u.TextRange.extend(n, t[t.length - 1]);
                  this._fileInfo.diagnosticSink.addUnusedCodeWithTextRange(g.LocMessage.unaccessedSymbol().format({
                    name: e
                  }), n, {
                    action: 'pyright.unusedImport'
                  });
                  this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportUnusedImport, g.LocMessage.unaccessedImport().format({
                    name: e
                  }), n);
                  return;
                }
              }
            } else {
              if (e.node.nodeType === 26) {
                const t = e.node.parent;
                const a = ((n = e.node.d.alias) === null || n === undefined ? undefined : n.d.value) === e.node.d.name.d.value;
                const s = t.d.module.d.nameParts.length === 1 && t.d.module.d.nameParts[0].d.value === '__future__';
                if (!a && !s) {
                  r = e.node.d.alias || e.node.d.name;
                }
              }
            }
            if (r) {
              s = g.LocMessage.unaccessedImport().format({
                name: r.d.value
              });
            }
            break;
          case 4:
          case 1:
          case 2:
            if (!t) {
              return;
            }
            if (this._fileInfo.isStubFile) {
              return;
            }
            a = this._fileInfo.diagnosticRuleSet.reportUnusedVariable;
            if (e.node.nodeType === 38) {
              r = e.node;
              if (r.d.value.startsWith('_')) {
                a = 'none';
              }
            } else {
              if (e.node.nodeType === 41) {
                r = e.node.d.name;
                a = 'none';
              }
            }
            if (r) {
              i = d.DiagnosticRule.reportUnusedVariable;
              s = g.LocMessage.unaccessedVariable().format({
                name: r.d.value
              });
            }
            break;
          case 6:
            if (!t) {
              return;
            }
            if (this._fileInfo.isStubFile) {
              return;
            }
            a = this._fileInfo.diagnosticRuleSet.reportUnusedClass;
            r = e.node.d.name;
            i = d.DiagnosticRule.reportUnusedClass;
            s = g.LocMessage.unaccessedClass().format({
              name: r.d.value
            });
            break;
          case 5:
            if (!t) {
              return;
            }
            if (this._fileInfo.isStubFile) {
              return;
            }
            a = this._fileInfo.diagnosticRuleSet.reportUnusedFunction;
            r = e.node.d.name;
            i = d.DiagnosticRule.reportUnusedFunction;
            s = g.LocMessage.unaccessedFunction().format({
              name: r.d.value
            });
            break;
          case 3:
            a = 'none';
            r = e.node.d.name;
            break;
          case 0:
          case 7:
            return;
          default:
            l.assertNever(e);
        }
        const o = i === d.DiagnosticRule.reportUnusedImport ? {
          action: 'pyright.unusedImport'
        } : undefined;
        if (r) {
          this._fileInfo.diagnosticSink.addUnusedCodeWithTextRange(g.LocMessage.unaccessedSymbol().format({
            name: r.d.value
          }), r, o);
          if (i !== undefined && s && a !== 'none') {
            this._evaluator.addDiagnostic(i, s, r);
          }
        }
      }
      _validateIsInstanceCall(e) {
        if (e.d.leftExpr.nodeType !== 38 || e.d.leftExpr.d.value !== 'isinstance' && e.d.leftExpr.d.value !== 'issubclass' || e.d.args.length !== 2) {
          return;
        }
        const t = e.d.leftExpr.d.value === 'isinstance';
        let n = this._evaluator.getType(e.d.args[0].d.valueExpr);
        if (!n) {
          return;
        }
        n = G.mapSubtypes(n, e => G.transformPossibleRecursiveTypeAlias(e));
        n = this._evaluator.expandPromotionTypes(e, n);
        const a = this._evaluator.getType(e.d.args[1].d.valueExpr);
        if (!a) {
          return;
        }
        let r = true;
        const s = new p.DiagnosticAddendum();
        G.doForEachSubtype(a, e => {
          if (q.isClassInstance(e) && q.ClassType.isTupleClass(e) && e.priv.tupleTypeArgs) {
            if (e.priv.tupleTypeArgs.some(e => !this._isTypeSupportedTypeForIsInstance(e.type, t, s))) {
              r = false;
            }
          } else {
            if (!this._isTypeSupportedTypeForIsInstance(e, t, s)) {
              r = false;
            }
          }
        });
        if (!r) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportArgumentType, t ? g.LocMessage.isInstanceInvalidType().format({
            type: this._evaluator.printType(a)
          }) + s.getString() : g.LocMessage.isSubclassInvalidType().format({
            type: this._evaluator.printType(a)
          }) + s.getString(), e.d.args[1]);
        }
        if (!t) {
          const t = new p.DiagnosticAddendum();
          G.doForEachSubtype(a, e => {
            if (q.isClassInstance(e) && q.ClassType.isTupleClass(e) && e.priv.tupleTypeArgs) {
              e.priv.tupleTypeArgs.forEach(e => {
                this._validateNotDataProtocol(e.type, t);
              });
            } else {
              this._validateNotDataProtocol(e, t);
            }
          });
          if (!t.isEmpty()) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.dataProtocolInSubclassCheck(), e.d.args[1]);
          }
        }
        if (P.isWithinAssertExpression(e)) {
          return;
        }
        const i = j.getIsInstanceClassTypes(this._evaluator, a);
        if (i && (i.forEach(a => {
          if (q.isInstantiableClass(a)) {
            this._validateUnsafeProtocolOverlap(e.d.args[0].d.valueExpr, q.ClassType.cloneAsInstance(a), t ? n : G.convertToInstance(n));
          }
        }), this._fileInfo.diagnosticRuleSet.reportUnnecessaryIsInstance !== 'none')) {
          const a = j.narrowTypeForInstanceOrSubclass(this._evaluator, n, i, t, false, false, e);
          const r = j.narrowTypeForInstanceOrSubclass(this._evaluator, n, i, t, false, true, e);
          const s = q.isNever(a);
          const o = q.isNever(r);
          if (s || o) {
            const a = q.combineTypes(i.map(e => G.convertToInstance(e)));
            const r = s ? t ? g.LocMessage.unnecessaryIsInstanceAlways() : g.LocMessage.unnecessaryIsSubclassAlways() : t ? g.LocMessage.unnecessaryIsInstanceNever() : g.LocMessage.unnecessaryIsSubclassNever();
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnnecessaryIsInstance, r.format({
              testType: this._evaluator.printType(n),
              classType: this._evaluator.printType(a)
            }), e);
          }
        }
      }
      _validateUnsafeProtocolOverlap(e, t, n) {
        if (q.ClassType.isProtocolClass(t)) {
          let a = false;
          const r = new p.DiagnosticAddendum();
          G.doForEachSubtype(n, e => {
            if (q.isClassInstance(e) && F.isProtocolUnsafeOverlap(this._evaluator, t, e)) {
              a = true;
              r.addMessage(g.LocAddendum.protocolUnsafeOverlap().format({
                name: e.shared.name
              }));
            }
          });
          if (a) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.protocolUnsafeOverlap().format({
              name: t.shared.name
            }) + r.getString(), e);
          }
        }
      }
      _isTypeSupportedTypeForIsInstance(e, t, n) {
        let a = true;
        G.doForEachSubtype(e, e => {
          e = this._evaluator.makeTopLevelTypeVarsConcrete(e);
          if ((e = G.transformPossibleRecursiveTypeAlias(e)).props?.specialForm && q.ClassType.isBuiltIn(e.props.specialForm, 'TypeAliasType')) {
            n.addMessage(g.LocAddendum.typeAliasInstanceCheck());
            a = false;
            return;
          }
          switch (e.category) {
            case 2:
            case 1:
            case 0:
              break;
            case 6:
              if (q.ClassType.isBuiltIn(e, 'TypedDict')) {
                n.addMessage(g.LocAddendum.typedDictNotAllowed());
                a = false;
              } else {
                if (q.ClassType.isBuiltIn(e, 'NamedTuple')) {
                  n.addMessage(g.LocAddendum.namedTupleNotAllowed());
                  a = false;
                } else {
                  if (G.isNoneInstance(e)) {
                    n.addMessage(g.LocAddendum.noneNotAllowed());
                    a = false;
                  } else {
                    if (q.ClassType.isTypedDictClass(e)) {
                      n.addMessage(g.LocAddendum.typedDictClassNotAllowed());
                      a = false;
                    } else {
                      if (e.priv.isTypeArgExplicit && !e.priv.includeSubclasses) {
                        n.addMessage(g.LocAddendum.genericClassNotAllowed());
                        a = false;
                      } else {
                        if (q.ClassType.isIllegalIsinstanceClass(e)) {
                          n.addMessage(g.LocAddendum.isinstanceClassNotSupported().format({
                            type: e.shared.name
                          }));
                          a = false;
                        } else {
                          if (!q.ClassType.isProtocolClass(e) || q.ClassType.isRuntimeCheckable(e) || e.priv.includeSubclasses) {
                            if (q.ClassType.isNewTypeClass(e)) {
                              n.addMessage(g.LocAddendum.newTypeClassNotAllowed());
                              a = false;
                            } else {
                              if (e.props?.specialForm && q.isClassInstance(e.props.specialForm) && q.ClassType.isBuiltIn(e.props.specialForm, 'Annotated')) {
                                n.addMessage(g.LocAddendum.annotatedNotAllowed());
                                a = false;
                              }
                            }
                          } else {
                            n.addMessage(g.LocAddendum.protocolRequiresRuntimeCheckable());
                            a = false;
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;
            case 4:
              if (!q.TypeBase.isInstantiable(e) || !!e.priv.isCallableWithTypeArgs) {
                n.addMessage(g.LocAddendum.genericClassNotAllowed());
                a = false;
              }
              break;
            case 9:
              n.addMessage(g.LocAddendum.typeVarNotAllowed());
              a = false;
          }
        });
        return a;
      }
      _validateNotDataProtocol(e, t) {
        if (q.isInstantiableClass(e) && q.ClassType.isProtocolClass(e) && !F.isMethodOnlyProtocol(e)) {
          t.addMessage(g.LocAddendum.dataProtocolUnsupported().format({
            name: e.shared.name
          }));
        }
      }
      _isSymbolPrivate(e, t) {
        if (t === 2 || t === 1) {
          return true;
        }
        if (U.isPrivateName(e)) {
          return true;
        }
        if (U.isProtectedName(e)) {
          return t !== 3;
        }
        return false;
      }
      _reportDeprecatedClassProperty(e, t) {
        if (q.isClassInstance(t.decoratedType) && q.ClassType.isClassProperty(t.decoratedType)) {
          this._reportDeprecatedDiagnostic(e.d.name, g.LocMessage.classPropertyDeprecated());
        }
      }
      _reportDeprecatedUseForMemberAccess(e, t) {
        let n;
        if (t.accessType === 'property') {
          n = t.accessMethod === 'get' ? g.LocMessage.deprecatedPropertyGetter().format({
            name: e.d.value
          }) : t.accessMethod === 'set' ? g.LocMessage.deprecatedPropertySetter().format({
            name: e.d.value
          }) : g.LocMessage.deprecatedPropertyDeleter().format({
            name: e.d.value
          });
        } else {
          if (t.accessType === 'descriptor') {
            n = t.accessMethod === 'get' ? g.LocMessage.deprecatedDescriptorGetter().format({
              name: e.d.value
            }) : t.accessMethod === 'set' ? g.LocMessage.deprecatedDescriptorSetter().format({
              name: e.d.value
            }) : g.LocMessage.deprecatedDescriptorDeleter().format({
              name: e.d.value
            });
          }
        }
        if (n) {
          this._reportDeprecatedDiagnostic(e, n, t.deprecatedMessage);
        }
      }
      _reportDeprecatedUseForOperation(e, t) {
        const n = t == null ? undefined : t.magicMethodDeprecationInfo;
        if (n) {
          this._reportDeprecatedDiagnostic(e, g.LocMessage.deprecatedMethod().format({
            className: n.className,
            name: n.methodName
          }), n.deprecatedMessage);
        }
      }
      _reportDeprecatedUseForType(e, t, n = false) {
        var a;
        var r;
        var s;
        if (!t) {
          return;
        }
        let i;
        let o;
        function l(e) {
          if (e.shared.declaration && e.shared.declaration.node.nodeType === 31) {
            const t = P.getEnclosingClass(e.shared.declaration.node, true);
            if (t) {
              return g.LocMessage.deprecatedMethod().format({
                name: e.shared.name || '<anonymous>',
                className: t.d.name.d.value
              });
            }
          }
          return g.LocMessage.deprecatedFunction().format({
            name: e.shared.name
          });
        }
        function p(t, n) {
          let a;
          const r = P.getCallForName(e);
          if (r) {
            a = t.getTypeResult(r);
          } else {
            const n = P.getDecoratorForName(e);
            if (n) {
              a = t.getTypeResultForDecorator(n);
            }
          }
          if (a && a.overloadsUsedForCall && a.overloadsUsedForCall.length > 0) {
            a.overloadsUsedForCall.forEach(t => {
              if (t.shared.deprecatedMessage !== undefined) {
                if (e.d.value === t.shared.name) {
                  o = t.shared.deprecatedMessage;
                  i = l(t);
                } else {
                  if (q.isInstantiableClass(n) && ['__init__', '__new__'].includes(t.shared.name)) {
                    o = t.shared.deprecatedMessage;
                    i = g.LocMessage.deprecatedConstructor().format({
                      name: n.shared.name
                    });
                  } else {
                    if (q.isClassInstance(n) && t.shared.name === '__call__') {
                      o = t.shared.deprecatedMessage;
                      i = g.LocMessage.deprecatedFunction().format({
                        name: e.d.value
                      });
                    }
                  }
                }
              }
            });
          }
        }
        G.doForEachSubtype(t, t => {
          if (q.isClass(t)) {
            if (t.priv.includeSubclasses || t.shared.deprecatedMessage === undefined || e.d.value !== t.shared.name) {
              p(this._evaluator, t);
              return;
            } else {
              o = t.shared.deprecatedMessage;
              return void (i = g.LocMessage.deprecatedClass().format({
                name: t.shared.name
              }));
            }
          }
          if (q.isFunction(t)) {
            if (t.shared.deprecatedMessage !== undefined) {
              if (!t.shared.name || t.shared.name === '__call__' || e.d.value === t.shared.name) {
                o = t.shared.deprecatedMessage;
                i = l(t);
              }
            }
          } else {
            if (q.isOverloaded(t)) {
              p(this._evaluator, t);
              const n = q.OverloadedType.getImplementation(t);
              if (n && q.isFunction(n) && n.shared.deprecatedMessage !== undefined) {
                if (!n.shared.name || e.d.value === n.shared.name) {
                  o = n.shared.deprecatedMessage;
                  i = l(n);
                }
              }
            }
          }
        });
        if (i) {
          this._reportDeprecatedDiagnostic(e, i, o);
        }
        if (this._fileInfo.diagnosticRuleSet.deprecateTypingAliases) {
          const i = (a = k.deprecatedAliases.get(e.d.value)) !== null && a !== undefined ? a : k.deprecatedSpecialForms.get(e.d.value);
          if (i && (q.isInstantiableClass(t) && t.shared.fullName === i.fullName || ((s = (r = t.props) === null || r === undefined ? undefined : r.typeAliasInfo) === null || s === undefined ? undefined : s.shared.fullName) === i.fullName) && c.PythonVersion.isGreaterOrEqualTo(this._fileInfo.executionEnvironment.pythonVersion, i.version)) {
            if (!i.typingImportOnly || !!n) {
              this._reportDeprecatedDiagnostic(e, g.LocMessage.deprecatedType().format({
                version: c.PythonVersion.toString(i.version),
                replacement: i.replacementText
              }));
            }
          }
        }
      }
      _reportDeprecatedDiagnostic(e, t, n) {
        const a = new p.DiagnosticAddendum();
        if (n) {
          a.addMessage(n);
        }
        if (this._fileInfo.diagnosticRuleSet.reportDeprecated === 'none') {
          this._evaluator.addDeprecated(t + a.getString(), e);
        } else {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportDeprecated, t + a.getString(), e);
        }
      }
      _reportUnboundName(e) {
        if (this._fileInfo.diagnosticRuleSet.reportUnboundVariable !== 'none' && !T.isCodeUnreachable(e)) {
          const t = this._evaluator.getType(e);
          if (t) {
            if (q.isUnbound(t)) {
              if (this._evaluator.isNodeReachable(e)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnboundVariable, g.LocMessage.symbolIsUnbound().format({
                  name: e.d.value
                }), e);
              }
            } else {
              if (q.isPossiblyUnbound(t)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportPossiblyUnboundVariable, g.LocMessage.symbolIsPossiblyUnbound().format({
                  name: e.d.value
                }), e);
              }
            }
          }
        }
      }
      _conditionallyReportShadowedModule() {
        if (this._fileInfo.diagnosticRuleSet.reportShadowedImports === 'none') {
          return;
        }
        const e = this._fileInfo.moduleName;
        const t = {
          nameParts: e.split('.'),
          leadingDots: 0,
          importedSymbols: new Set()
        };
        if (this._importResolver.getTypeshedStdLibPath(this._fileInfo.executionEnvironment) && this._importResolver.isStdlibModule(t, this._fileInfo.executionEnvironment) && this._sourceMapper.isUserCode(this._fileInfo.fileUri)) {
          const t = this._evaluator.addDiagnosticForTextRange(this._fileInfo, d.DiagnosticRule.reportShadowedImports, g.LocMessage.stdlibModuleOverridden().format({
            name: e,
            path: this._fileInfo.fileUri.toUserVisibleString()
          }), this._moduleNode);
          if (t) {
            const e = {
              action: 'renameShadowedFile',
              oldUri: this._fileInfo.fileUri,
              newUri: this._sourceMapper.getNextFileName(this._fileInfo.fileUri)
            };
            t.addAction(e);
          }
        }
      }
      _conditionallyReportShadowedImport(e) {
        var t;
        var n;
        if (this._fileInfo.diagnosticRuleSet.reportShadowedImports === 'none') {
          return;
        }
        const a = e.nodeType === 26 ? ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 25 ? (n = e.parent) === null || n === undefined ? undefined : n.d.module : undefined : e.d.module;
        if (a == null ? undefined : a.d.leadingDots) {
          return;
        }
        const r = e.nodeType === 24 ? e.d.module.d.nameParts : e.nodeType === 26 ? [e.d.name] : e.d.module.d.nameParts;
        const s = r.map(e => e.d.value);
        const o = {
          nameParts: s,
          leadingDots: 0,
          importedSymbols: new Set()
        };
        const l = this._importResolver.getTypeshedStdLibPath(this._fileInfo.executionEnvironment);
        if (l && this._importResolver.isStdlibModule(o, this._fileInfo.executionEnvironment)) {
          const t = y.DefinitionProvider.getDefinitionsForNode(this._sourceMapper, this._evaluator, r[r.length - 1], r[r.length - 1].start, i.CancellationToken.None);
          (t ? t.map(e => e.uri) : []).forEach(t => {
            if (!t.startsWith(l) && !O.isStubFile(t) && this._sourceMapper.isUserCode(t)) {
              const n = this._evaluator.addDiagnostic(d.DiagnosticRule.reportShadowedImports, g.LocMessage.stdlibModuleOverridden().format({
                name: s.join('.'),
                path: t.toUserVisibleString()
              }), e);
              if (n) {
                const e = {
                  action: 'renameShadowedFile',
                  oldUri: t,
                  newUri: this._sourceMapper.getNextFileName(t)
                };
                n.addAction(e);
              }
            }
          });
        }
      }
      _conditionallyReportPrivateUsage(e) {
        var t;
        var n;
        var a;
        if (this._fileInfo.diagnosticRuleSet.reportPrivateUsage === 'none') {
          return;
        }
        if (this._fileInfo.isStubFile) {
          return;
        }
        if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 1 && e.parent.d.name === e) {
          return;
        }
        const r = e.d.value;
        const s = U.isPrivateName(r);
        const i = U.isProtectedName(r);
        if (!s && !i) {
          return;
        }
        const o = (a = (n = this._evaluator.getDeclInfoForNameNode(e)) === null || n === undefined ? undefined : n.decls) === null || a === undefined ? undefined : a.filter(e => e.type !== 1 || !e.isExplicitBinding);
        let l;
        let p = o && o.length > 0 ? o[o.length - 1] : undefined;
        if (!p || p.node === e) {
          return;
        }
        if (p.type === 8) {
          if (p.usesLocalName) {
            return;
          }
          const e = this._evaluator.resolveAliasDeclarationWithInfo(p, true);
          if (!e) {
            return;
          }
          p = e.declaration;
          if (!e.isPrivate) {
            return;
          }
        }
        if (!p || p.node === e) {
          return;
        }
        if (p.node) {
          l = P.getEnclosingClass(p.node);
        }
        if (p.node && p.node.parent && p.node.parent === l) {
          l = P.getEnclosingClass(l);
        }
        let c = false;
        if (l && i) {
          const t = this._evaluator.getTypeOfClass(l);
          if (t && q.isInstantiableClass(t.decoratedType)) {
            if (q.ClassType.isDefinedInStub(t.decoratedType)) {
              return;
            }
            c = true;
            const n = P.getEnclosingClass(e);
            if (n) {
              const e = this._evaluator.getTypeOfClass(n);
              if (e && q.isInstantiableClass(e.decoratedType) && G.derivesFromClassRecursive(e.decoratedType, t.decoratedType, true)) {
                return;
              }
            }
          }
        }
        if (l && !P.isNodeContainedWithin(e, l)) {
          if (c) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportPrivateUsage, g.LocMessage.protectedUsedOutsideOfClass().format({
              name: r
            }), e);
          } else {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportPrivateUsage, g.LocMessage.privateUsedOutsideOfClass().format({
              name: r
            }), e);
          }
        }
      }
      _validateEnumClassOverride(e, t) {
        t.shared.baseClasses.forEach((t, n) => {
          if (q.isClass(t) && w.isEnumClassWithMembers(this._evaluator, t)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.enumClassOverride().format({
              name: t.shared.name
            }), e.d.arguments[n]);
          }
        });
      }
      _validateTypedDictClassSuite(e) {
        const t = e => {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictBadVar(), e);
        };
        e.d.statements.forEach(e => {
          if (!T.isCodeUnreachable(e)) {
            if (e.nodeType === 47) {
              for (const n of e.d.statements) {
                if (n.nodeType !== 54 && n.nodeType !== 21 && n.nodeType !== 48 && n.nodeType !== 42) {
                  t(n);
                }
              }
            } else {
              t(e);
            }
          }
        });
      }
      _validateTypeGuardFunction(e, t, n) {
        var a;
        const r = t.shared.declaredReturnType;
        if (!r) {
          return;
        }
        if (!q.isClassInstance(r) || !r.priv.typeArgs || r.priv.typeArgs.length < 1) {
          return;
        }
        const s = q.ClassType.isBuiltIn(r, 'TypeGuard');
        const i = q.ClassType.isBuiltIn(r, 'TypeIs');
        if (!s && !i) {
          return;
        }
        let o = t.shared.parameters.length;
        if (n && (q.FunctionType.isInstanceMethod(t) || q.FunctionType.isConstructorMethod(t) || q.FunctionType.isClassMethod(t))) {
          o--;
        }
        if (o < 1) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeGuardParamCount(), e.d.name);
        }
        if (i) {
          const s = G.getTypeVarScopeIds(t);
          const i = r.priv.typeArgs[0];
          let o = G.makeTypeVarsBound(i, s);
          o = q.TypeBase.cloneWithTypeForm(o, o);
          const l = n && !q.FunctionType.isStaticMethod(t) ? 1 : 0;
          if (l >= t.shared.parameters.length) {
            return;
          }
          const p = G.makeTypeVarsBound(q.FunctionType.getParamType(t, l), s);
          if (!this._evaluator.assignType(p, o)) {
            const t = e.d.returnAnnotation || ((a = e.d.funcAnnotationComment) === null || a === undefined ? undefined : a.d.returnAnnotation);
            if (t) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeIsReturnType().format({
                type: this._evaluator.printType(p),
                returnType: this._evaluator.printType(i)
              }), t);
            }
          }
        }
      }
      _validateDunderSignatures(e, t, n) {
        var a;
        const r = t.shared.name;
        if (n && r === '__init__') {
          const n = e.d.returnAnnotation || ((a = e.d.funcAnnotationComment) === null || a === undefined ? undefined : a.d.returnAnnotation);
          const r = t.shared.declaredReturnType;
          if (n && r) {
            if (!G.isNoneInstance(r) && !q.isNever(r)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.initMustReturnNone(), n);
            }
          } else {
            const n = this._evaluator.getInferredReturnType(t);
            if (!q.isNever(n) && !G.isNoneInstance(n) && !q.isAnyOrUnknown(n)) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.initMustReturnNone(), e.d.name);
            }
          }
        }
      }
      _validateFunctionReturn(e, t) {
        var n;
        if (this._fileInfo.isStubFile) {
          return;
        }
        const a = e.d.returnAnnotation || ((n = e.d.funcAnnotationComment) === null || n === undefined ? undefined : n.d.returnAnnotation);
        if (a) {
          const n = !this._evaluator.isAfterNodeReachable(e);
          const r = this._evaluator.isAfterNodeReachable(e.d.suite);
          let s = t.shared.declaredReturnType;
          if (s) {
            this._reportUnknownReturnResult(e, s);
            this._validateReturnTypeIsNotContravariant(s, a);
            const t = P.getTypeVarScopesForNode(e);
            s = G.makeTypeVarsBound(s, t);
          }
          if (q.FunctionType.isGenerator(t)) {
            s = G.getDeclaredGeneratorReturnType(t);
          }
          if (s && !n && r) {
            if (q.isNever(s)) {
              if (!P.isSuiteEmpty(e.d.suite) && !q.FunctionType.isOverloaded(t) && !q.FunctionType.isAsync(t)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportReturnType, g.LocMessage.noReturnReturnsNone(), a);
              }
            } else {
              if (!q.FunctionType.isAbstractMethod(t)) {
                const n = P.isSuiteEmpty(e.d.suite) || q.FunctionType.isOverloaded(t);
                const r = n ? undefined : new p.DiagnosticAddendum();
                if (!this._evaluator.assignType(s, this._evaluator.getNoneType(), r) && !n) {
                  this._evaluator.addDiagnostic(d.DiagnosticRule.reportReturnType, g.LocMessage.returnMissing().format({
                    returnType: this._evaluator.printType(s)
                  }) + (r == null ? undefined : r.getString()), a);
                }
              }
            }
          }
        } else {
          const n = this._evaluator.getInferredReturnType(t);
          this._reportUnknownReturnResult(e, n);
          this._validateReturnTypeIsNotContravariant(n, e.d.name);
        }
      }
      _validateReturnTypeIsNotContravariant(e, t) {
        let n = false;
        G.doForEachSubtype(e, e => {
          if (q.isTypeVar(e) && e.shared.declaredVariance === 4 && e.priv.scopeType === 0) {
            n = true;
          }
        });
        if (n) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.returnTypeContravariant(), t);
        }
      }
      _reportUnknownReturnResult(e, t) {
        if (q.isUnknown(t)) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownParameterType, g.LocMessage.returnTypeUnknown(), e.d.name);
        } else {
          if (G.isPartlyUnknown(t)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnknownParameterType, g.LocMessage.returnTypePartiallyUnknown().format({
              returnType: this._evaluator.printType(t, {
                expandTypeAlias: true
              })
            }), e.d.name);
          }
        }
      }
      _validateFinalMemberOverrides(e) {
        q.ClassType.getSymbolTable(e).forEach((t, n) => {
          const a = G.lookUpClassMember(e, n, 1);
          if (a && q.isInstantiableClass(a.classType) && !U.isPrivateName(n)) {
            if (this._evaluator.isFinalVariable(a.symbol)) {
              const e = t.getDeclarations()[0];
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalRedeclarationBySubclass().format({
                name: n,
                className: a.classType.shared.name
              }), e.node);
            } else {
              if (q.ClassType.hasNamedTupleEntry(a.classType, n) && !U.isDunderName(n)) {
                const e = t.getDeclarations()[0];
                if (e.type === 1) {
                  this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.namedTupleEntryRedeclared().format({
                    name: n,
                    className: a.classType.shared.name
                  }), e.node);
                }
              }
            }
          }
        });
      }
      _validateEnumMembers(e, t) {
        if (!q.ClassType.isEnumClass(e) || q.ClassType.isBuiltIn(e)) {
          return;
        }
        const n = w.getEnumDeclaredValueType(this._evaluator, e, true);
        let a = b.getBoundNewMethod(this._evaluator, t.d.name, e, undefined, 4);
        if ((a == null ? undefined : a.classType) && q.isClass(a.classType) && q.ClassType.isBuiltIn(a.classType)) {
          a = undefined;
        }
        let r = b.getBoundInitMethod(this._evaluator, t.d.name, q.ClassType.cloneAsInstance(e), undefined, 4);
        if ((r == null ? undefined : r.classType) && q.isClass(r.classType) && q.ClassType.isBuiltIn(r.classType)) {
          r = undefined;
        }
        q.ClassType.getSymbolTable(e).forEach((t, s) => {
          var i;
          const o = w.transformTypeForEnumMember(this._evaluator, e, s, true);
          if (!o || !q.isClassInstance(o) || !q.ClassType.isSameGenericClass(o, q.ClassType.cloneAsInstance(e)) || !(o.priv.literalValue instanceof q.EnumLiteral)) {
            return;
          }
          const l = t.getTypedDeclarations();
          if (l.length > 0) {
            if (l[0].type === 1 && l[0].inferredTypeSource) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.enumMemberTypeAnnotation(), l[0].node);
            }
            return;
          }
          const c = t.getDeclarations();
          if (c.length >= 2 && c[0].type === 1) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.duplicateEnumMember().format({
              name: s
            }), c[1].node);
            return;
          }
          if (c[0].type !== 1) {
            return;
          }
          if (c[0].isFinal) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.enumMemberTypeAnnotation(), c[0].node);
          }
          const u = c[0].node;
          const m = o.priv.literalValue.itemType;
          const y = P.getParentNodeOfType(u, 3);
          const h = (i = y == null ? undefined : y.d.rightExpr) !== null && i !== undefined ? i : u;
          if (a || r) {
            if (!q.isAnyOrUnknown(m)) {
              const e = [{
                argCategory: q.isClassInstance(m) && G.isTupleClass(m) ? 1 : 0,
                typeResult: {
                  type: m
                }
              }];
              if (a) {
                this._evaluator.validateCallArgs(h, e, a, undefined, undefined, undefined);
              }
              if (r) {
                this._evaluator.validateCallArgs(h, e, r, undefined, undefined, undefined);
              }
            }
          } else {
            if (n) {
              const t = new p.DiagnosticAddendum();
              if ((!q.isClassInstance(m) || !q.ClassType.isSameGenericClass(m, e)) && !this._evaluator.assignType(n, m, t)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportAssignmentType, g.LocMessage.typeAssignmentMismatch().format(this._evaluator.printSrcDestTypes(m, n)) + t.getString(), h);
              }
            }
          }
        });
      }
      _validateDataClassPostInit(e) {
        if (!q.ClassType.isDataClass(e)) {
          return;
        }
        const t = G.lookUpClassMember(e, '__post_init__', 66);
        if (!t) {
          return;
        }
        if (q.ClassType.derivesFromAnyOrUnknown(e)) {
          return;
        }
        const n = new Map();
        q.ClassType.getReverseMro(e).forEach(e => {
          if (q.isClass(e) && q.ClassType.isDataClass(e)) {
            q.ClassType.getSymbolTable(e).forEach((e, t) => {
              if (e.isInitVar()) {
                n.set(t, e);
              }
            });
          }
        });
        const a = this._evaluator.getTypeOfMember(t);
        if (!q.isFunction(a) || !q.FunctionType.isInstanceMethod(a) || !a.shared.declaration) {
          return;
        }
        const r = x.getParamListDetails(a);
        if (r.argsIndex !== undefined || r.kwargsIndex !== undefined || r.firstKeywordOnlyIndex !== undefined) {
          return;
        }
        const s = r.params.filter((e, t) => q.FunctionType.getParamDefaultType(a, t) === undefined);
        const i = n.size + 1;
        const o = a.shared.declaration.node;
        if (i < s.length || i > r.params.length) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.dataClassPostInitParamCount().format({
            expected: n.size
          }), o.d.name);
        }
        let l = 1;
        n.forEach((e, t) => {
          var n;
          var s;
          if (l >= r.params.length) {
            return;
          }
          const i = r.params[l].param;
          const c = o.d.params.find(e => {
            var t;
            return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === i.name;
          });
          const u = (n = c == null ? undefined : c.d.annotation) !== null && n !== undefined ? n : c == null ? undefined : c.d.annotationComment;
          if (q.FunctionParam.isTypeDeclared(i) && u) {
            const n = (s = this._evaluator.getDeclaredTypeOfSymbol(e)) === null || s === undefined ? undefined : s.type;
            const i = q.FunctionType.getParamType(a, r.params[l].index);
            const o = new p.DiagnosticAddendum();
            if (n && !this._evaluator.assignType(i, n, o)) {
              const n = this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.dataClassPostInitType().format({
                fieldName: t
              }) + o.getString(), u);
              if (n) {
                const t = e.getTypedDeclarations();
                if (t.length > 0) {
                  n.addRelatedInfo(g.LocAddendum.dataClassFieldLocation(), t[0].uri, t[0].range);
                }
              }
            }
          }
          l++;
        });
      }
      _validateFinalClassNotAbstract(e, t) {
        if (!q.ClassType.isFinal(e)) {
          return;
        }
        if (!q.ClassType.supportsAbstractMethods(e)) {
          return;
        }
        const n = this._evaluator.getAbstractSymbols(e);
        if (n.length === 0) {
          return;
        }
        const a = new p.DiagnosticAddendum();
        n.forEach((e, t) => {
          if (t === 2) {
            a.addMessage(g.LocAddendum.memberIsAbstractMore().format({
              count: n.length - 2
            }));
          } else {
            if (t < 2 && q.isInstantiableClass(e.classType)) {
              const t = e.classType.shared.name;
              a.addMessage(g.LocAddendum.memberIsAbstract().format({
                type: t,
                name: e.symbolName
              }));
            }
          }
        });
        this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalClassIsAbstract().format({
          type: e.shared.name
        }) + a.getString(), t.d.name);
      }
      _validateInstanceVariableInitialization(e, t) {
        if (this._fileInfo.isStubFile) {
          return;
        }
        if (this._fileInfo.diagnosticRuleSet.reportUninitializedInstanceVariable === 'none') {
          return;
        }
        if (q.ClassType.isProtocolClass(t) || q.ClassType.supportsAbstractMethods(t) && !q.ClassType.isFinal(t)) {
          return;
        }
        const n = new Map();
        if (q.ClassType.isFinal(t)) {
          G.getProtocolSymbolsRecursive(t, n, 64);
        }
        const a = [];
        if (q.ClassType.isDataClass(t)) {
          _.addInheritedDataClassEntries(t, a);
        }
        q.ClassType.getSymbolTable(t).forEach((e, a) => {
          n.delete(a);
          if (!e.isInstanceMember()) {
            return;
          }
          const r = e.getDeclarations();
          if (r.find(e => {
            var n;
            var r;
            var s;
            const i = P.getEnclosingClassOrFunction(e.node);
            if (!i) {
              return true;
            }
            if (i.nodeType === 10) {
              if (((n = e.node.parent) === null || n === undefined ? undefined : n.nodeType) === 3) {
                return true;
              }
              if (((r = e.node.parent) === null || r === undefined ? undefined : r.nodeType) === 54 && ((s = e.node.parent.parent) === null || s === undefined ? undefined : s.nodeType) === 3) {
                return true;
              }
              if (q.ClassType.isDataClass(t) || q.ClassType.hasNamedTupleEntry(t, a)) {
                return true;
              }
              if (q.ClassType.isTypedDictClass(t)) {
                return true;
              }
            }
            return i.d.name.d.value === '__init__';
          })) {
            return;
          }
          if (!G.lookUpClassMember(t, a, 1)) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportUninitializedInstanceVariable, g.LocMessage.uninitializedInstanceVariable().format({
              name: a
            }), r[0].node);
          }
        });
        const r = new p.DiagnosticAddendum();
        n.forEach((e, t) => {
          const n = e.symbol.getDeclarations();
          if (n.length === 0 || !q.isClass(e.classType)) {
            return;
          }
          if (n[0].type !== 1) {
            return;
          }
          const s = a == null ? undefined : a.find(e => e.name === t);
          if (s) {
            if (s.includeInInit) {
              return;
            }
          } else {
            if (n.some(e => e.type === 1 && !!e.inferredTypeSource)) {
              return;
            }
          }
          r.addMessage(g.LocAddendum.uninitializedAbstractVariable().format({
            name: t,
            classType: e.classType.shared.name
          }));
        });
        if (!r.isEmpty()) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportUninitializedInstanceVariable, g.LocMessage.uninitializedAbstractVariables().format({
            classType: t.shared.name
          }) + r.getString(), e.d.name);
        }
      }
      _validateProtocolTypeParamVariance(e, t) {
        if (t.shared.typeParams.length === 0) {
          return;
        }
        const n = this._evaluator.getBuiltInType(e, 'object');
        if (!q.isInstantiableClass(n)) {
          return;
        }
        const a = q.ClassType.cloneAsInstance(n);
        const r = q.ClassType.createInstantiable('__varianceDummy', '', '', m.Uri.empty(), 0, 0, undefined, undefined);
        t.shared.typeParams.forEach((n, s) => {
          if (q.isTypeVarTuple(n) || q.isParamSpec(n)) {
            return;
          }
          if (n.shared.isSynthesized) {
            return;
          }
          if (n.shared.declaredVariance === 0) {
            return;
          }
          const i = t.shared.typeParams.map((e, t) => q.isTypeVarTuple(e) ? e : t === s ? a : r);
          const o = t.shared.typeParams.map((e, t) => t === s || q.isTypeVarTuple(e) ? e : r);
          const l = q.ClassType.specialize(t, i);
          const p = q.ClassType.specialize(t, o);
          let c;
          if (this._evaluator.assignClassToSelf(l, p, 3)) {
            c = 3;
          } else {
            c = this._evaluator.assignClassToSelf(p, l, 4) ? 4 : 2;
          }
          if (c !== t.shared.typeParams[s].shared.declaredVariance) {
            let a;
            a = c === 3 ? g.LocMessage.protocolVarianceCovariant().format({
              variable: n.shared.name,
              class: t.shared.name
            }) : c === 4 ? g.LocMessage.protocolVarianceContravariant().format({
              variable: n.shared.name,
              class: t.shared.name
            }) : g.LocMessage.protocolVarianceInvariant().format({
              variable: n.shared.name,
              class: t.shared.name
            });
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeVarUse, a, e.d.name);
          }
        });
      }
      _validateSlotsClassVarConflict(e) {
        if (e.shared.localSlotsNames) {
          if (!q.ClassType.isDataClass(e)) {
            q.ClassType.getSymbolTable(e).forEach((e, t) => {
              const n = e.getDeclarations();
              if (n.some(e => e.type === 1 && e.isDefinedBySlots)) {
                n.forEach(e => {
                  if (e.type === 1 && !e.isDefinedBySlots && !e.isDefinedByMemberAccess) {
                    if (e.node.nodeType === 38 && P.isWriteAccess(e.node)) {
                      this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.slotsClassVarConflict().format({
                        name: t
                      }), e.node);
                    }
                  }
                });
              }
            });
          }
        }
      }
      _validateConstructorConsistency(e, t) {
        if (b.getBoundCallMethod(this._evaluator, t, e)) {
          return;
        }
        const n = b.getBoundNewMethod(this._evaluator, t, e);
        if (!n || n.typeErrors || !n.classType || !q.isClass(n.classType)) {
          return;
        }
        const a = b.getBoundInitMethod(this._evaluator, t, q.ClassType.cloneAsInstance(e));
        if (!a || a.typeErrors || !a.classType || !q.isClass(a.classType)) {
          return;
        }
        if (!q.ClassType.isSameGenericClass(a.classType, e) && !q.ClassType.isSameGenericClass(n.classType, e)) {
          return;
        }
        let r = n.type;
        if (!q.isFunction(r) && !q.isOverloaded(r)) {
          return;
        }
        if (q.isOverloaded(r) && (r = q.OverloadedType.getImplementation(r), !r || !q.isFunction(r))) {
          return;
        }
        let s = a.type;
        if ((q.isFunction(s) || q.isOverloaded(s)) && (!q.isOverloaded(s) || (s = q.OverloadedType.getImplementation(s), s && q.isFunction(s))) && !q.FunctionType.hasDefaultParams(s) && !q.FunctionType.hasDefaultParams(r) && (!this._evaluator.assignType(r, s, undefined, undefined, 64) || !this._evaluator.assignType(s, r, undefined, undefined, 64))) {
          const t = q.ClassType.isSameGenericClass(a.classType, e);
          const i = s.shared.declaration;
          const o = r.shared.declaration;
          if (i && o) {
            const e = t ? i : o;
            const l = e.node.nodeType === 31 ? e.node.d.name : e.node;
            const c = new p.DiagnosticAddendum();
            const u = this._evaluator.printType(s);
            const m = this._evaluator.printType(r);
            c.addMessage(g.LocAddendum.initMethodSignature().format({
              type: u
            }));
            c.addMessage(g.LocAddendum.newMethodSignature().format({
              type: m
            }));
            const y = this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentConstructor, g.LocMessage.constructorParametersMismatch().format({
              classType: this._evaluator.printType(q.ClassType.cloneAsInstance(t ? a.classType : n.classType))
            }) + c.getString(), l);
            if (y) {
              const e = t ? o : i;
              y.addRelatedInfo((t ? g.LocAddendum.newMethodLocation() : g.LocAddendum.initMethodLocation()).format({
                type: this._evaluator.printType(q.ClassType.cloneAsInstance(t ? n.classType : a.classType))
              }), e.uri, e.range);
            }
          }
        }
      }
      _validateMultipleInheritanceBaseClasses(e, t) {
        const n = [];
        for (const t of e.shared.baseClasses) {
          if (!q.isClass(t)) {
            return;
          }
          if (!q.ClassType.isBuiltIn(t, ['Generic', 'Protocol', 'object'])) {
            n.push(t);
          }
        }
        if (n.length < 2) {
          return;
        }
        const a = new p.DiagnosticAddendum();
        for (const t of n) {
          const n = G.buildSolutionFromSpecializedClass(t);
          for (const r of t.shared.mro) {
            if (q.isClass(r) && r.shared.typeParams.length > 0) {
              const s = G.applySolvedTypeVars(r, n);
              const i = e.shared.mro.find(e => q.isClass(e) && q.ClassType.isSameGenericClass(e, s));
              if (i && q.isInstantiableClass(i)) {
                const n = G.getTypeVarScopeIds(e);
                const r = G.makeTypeVarsBound(q.ClassType.cloneAsInstance(i), n);
                const o = G.makeTypeVarsBound(q.ClassType.cloneAsInstance(s), n);
                if (!this._evaluator.assignType(r, o)) {
                  const e = new p.DiagnosticAddendum();
                  const n = G.convertToInstance(t);
                  if (q.isTypeSame(n, o)) {
                    e.addMessage(g.LocAddendum.baseClassIncompatible().format({
                      baseClass: this._evaluator.printType(n),
                      type: this._evaluator.printType(r)
                    }));
                  } else {
                    e.addMessage(g.LocAddendum.baseClassIncompatibleSubclass().format({
                      baseClass: this._evaluator.printType(n),
                      subclass: this._evaluator.printType(o),
                      type: this._evaluator.printType(r)
                    }));
                  }
                  a.addAddendum(e);
                  break;
                }
              }
            }
          }
        }
        if (!a.isEmpty()) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.baseClassIncompatible().format({
            type: e.shared.name
          }) + a.getString(), t);
        }
      }
      _validateMultipleInheritanceCompatibility(e, t) {
        if (this._fileInfo.diagnosticRuleSet.reportIncompatibleMethodOverride === 'none' && this._fileInfo.diagnosticRuleSet.reportIncompatibleVariableOverride === 'none') {
          return;
        }
        const n = [];
        e.shared.baseClasses.forEach(e => {
          if (!!q.isClass(e) && !q.ClassType.isBuiltIn(e, 'Generic') && !q.ClassType.isBuiltIn(e, 'Protocol')) {
            n.push(e);
          }
        });
        if (n.length < 2) {
          return;
        }
        const a = n.map(t => {
          const n = e.shared.mro.find(e => q.isClass(e) && q.ClassType.isSameGenericClass(e, t));
          if (n && q.isClass(n)) {
            return G.getClassFieldsRecursive(n);
          } else {
            return new Map();
          }
        });
        const r = G.getClassFieldsRecursive(e);
        for (let n = 1; n < a.length; n++) {
          const s = a[n];
          for (const [n, a] of s) {
            if (U.isDunderName(n) || U.isPrivateName(n)) {
              continue;
            }
            const s = a.classType;
            if (!q.isClass(s)) {
              continue;
            }
            const i = r.get(n);
            if (i) {
              const r = i.classType;
              if (!q.isClass(r) || q.ClassType.isSameGenericClass(r, s) || q.ClassType.isSameGenericClass(r, e)) {
                continue;
              }
              this._validateMultipleInheritanceOverride(a, i, e, n, t);
            }
          }
        }
      }
      _validateMultipleInheritanceOverride(e, t, n, a, r) {
        var s;
        var i;
        var o;
        var l;
        if (!q.isClass(e.classType) || !q.isClass(t.classType)) {
          return;
        }
        if (a === '_') {
          return;
        }
        let c = this._evaluator.getEffectiveTypeOfSymbol(e.symbol);
        c = G.partiallySpecializeType(c, e.classType, this._evaluator.getTypeClassType());
        const u = t.symbol;
        let m = this._evaluator.getEffectiveTypeOfSymbol(u);
        m = G.partiallySpecializeType(m, t.classType, this._evaluator.getTypeClassType());
        const y = q.ClassType.getSymbolTable(n).get(a);
        const h = y ? this._evaluator.getEffectiveTypeOfSymbol(y) : undefined;
        let f;
        const T = V.getLastTypedDeclarationForSymbol(t.symbol);
        const v = V.getLastTypedDeclarationForSymbol(e.symbol);
        if (q.isFunction(c) || q.isOverloaded(c)) {
          const e = new p.DiagnosticAddendum();
          let t;
          if (q.isFunction(m)) {
            t = m;
          } else {
            if (q.isOverloaded(m)) {
              const e = q.OverloadedType.getImplementation(m);
              if (!e || !q.isFunction(e)) {
                return;
              }
              t = e;
            }
          }
          if (t && !this._evaluator.validateOverrideMethod(c, t, undefined, e, true)) {
            const s = t.shared.declaration;
            if (s && s.type === 5) {
              f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.baseClassMethodTypeIncompatible().format({
                classType: n.shared.name,
                name: a
              }) + e.getString(), r);
            }
          }
        } else {
          if (G.isProperty(c)) {
            if (G.isProperty(m) || q.isAnyOrUnknown(m)) {
              this._validateMultipleInheritancePropertyOverride(e.classType, n, c, m, u, a, r);
            } else {
              if (u.getDeclarations().length > 0) {
                f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.baseClassVariableTypeIncompatible().format({
                  classType: n.shared.name,
                  name: a
                }), r);
              }
            }
          } else {
            if (this._fileInfo.diagnosticRuleSet.reportIncompatibleVariableOverride !== 'none') {
              const p = V.getLastTypedDeclarationForSymbol(e.symbol);
              let u;
              let y;
              let T = (p == null ? undefined : p.type) === 1 && !p.isFinal;
              if (q.ClassType.isDataClassFrozen(e.classType) && e.classType.shared.dataClassEntries) {
                if (e.classType.shared.dataClassEntries.find(e => e.name === a)) {
                  T = false;
                }
              }
              if (e.classType.shared.typedDictEntries) {
                u = (i = (s = e.classType.shared.typedDictEntries.knownItems.get(a)) !== null && s !== undefined ? s : e.classType.shared.typedDictEntries.extraItems) !== null && i !== undefined ? i : R.getEffectiveExtraItemsEntryType(this._evaluator, e.classType);
                if (u == null ? undefined : u.isReadOnly) {
                  T = false;
                }
              }
              if (t.classType.shared.typedDictEntries) {
                y = (l = (o = t.classType.shared.typedDictEntries.knownItems.get(a)) !== null && o !== undefined ? o : t.classType.shared.typedDictEntries.extraItems) !== null && l !== undefined ? l : R.getEffectiveExtraItemsEntryType(this._evaluator, t.classType);
              }
              if (this._evaluator.assignType(c, h ?? m, undefined, undefined, T ? 1 : 0)) {
                if (u && y) {
                  let e;
                  let t = true;
                  if (u.isReadOnly) {
                    e = y.isRequired || !u.isRequired;
                  } else {
                    t = !y.isReadOnly;
                    e = y.isRequired === u.isRequired;
                  }
                  if (e) {
                    if (!t) {
                      f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.typedDictFieldReadOnlyRedefinition().format({
                        name: a
                      }), r);
                    }
                  } else {
                    const e = y.isRequired ? g.LocMessage.typedDictFieldRequiredRedefinition : g.LocMessage.typedDictFieldNotRequiredRedefinition;
                    f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, e().format({
                      name: a
                    }), r);
                  }
                }
              } else {
                f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.baseClassVariableTypeIncompatible().format({
                  classType: n.shared.name,
                  name: a
                }), r);
              }
            }
          }
        }
        if (f && T && v) {
          this._addMultipleInheritanceRelatedInfo(f, e.classType, c, v, t.classType, m, T);
        }
      }
      _addMultipleInheritanceRelatedInfo(e, t, n, a, r, s, i) {
        e.addRelatedInfo(g.LocAddendum.baseClassOverriddenType().format({
          baseClass: this._evaluator.printType(G.convertToInstance(t)),
          type: this._evaluator.printType(n)
        }), a.uri, a.range);
        e.addRelatedInfo(g.LocAddendum.baseClassOverridesType().format({
          baseClass: this._evaluator.printType(G.convertToInstance(r)),
          type: this._evaluator.printType(s)
        }), i.uri, i.range);
      }
      _validateMultipleInheritancePropertyOverride(e, t, n, a, r, s, i) {
        [['fget', e => {
          var t;
          if ((t = e.priv.fgetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }], ['fset', e => {
          var t;
          if ((t = e.priv.fsetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }], ['fdel', e => {
          var t;
          if ((t = e.priv.fdelInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }]].forEach(o => {
          const l = new p.DiagnosticAddendum();
          const [c, u] = o;
          const m = u(n);
          const y = u(a);
          if (m) {
            const o = G.partiallySpecializeType(m, e, this._evaluator.getTypeClassType());
            if (q.isFunction(o)) {
              if (y) {
                const r = G.partiallySpecializeType(y, t, this._evaluator.getTypeClassType());
                if (q.isFunction(r) && !this._evaluator.validateOverrideMethod(o, r, t, l.createAddendum())) {
                  l.addMessage(g.LocAddendum.propertyMethodIncompatible().format({
                    name: c
                  }));
                  const p = r.shared.declaration;
                  if (p && p.type === 5) {
                    const r = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.propertyOverridden().format({
                      name: s,
                      className: e.shared.name
                    }) + l.getString(), i);
                    const c = o.shared.declaration;
                    if (r && c) {
                      this._addMultipleInheritanceRelatedInfo(r, e, n, c, t, a, p);
                    }
                  }
                }
              } else {
                l.addMessage(g.LocAddendum.propertyMethodMissing().format({
                  name: c
                }));
                const p = r.getDeclarations();
                if (p.length > 0) {
                  const r = p[p.length - 1];
                  const c = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.propertyOverridden().format({
                    name: s,
                    className: e.shared.name
                  }) + l.getString(), i);
                  const u = o.shared.declaration;
                  if (c && u) {
                    this._addMultipleInheritanceRelatedInfo(c, e, n, u, t, a, r);
                  }
                }
              }
            }
          }
        });
      }
      _validateOverloadDecoratorConsistency(e) {
        q.ClassType.getSymbolTable(e).forEach((e, t) => {
          const n = V.getLastTypedDeclarationForSymbol(e);
          if (!n || n.type !== 5) {
            return;
          }
          const a = this._evaluator.getEffectiveTypeOfSymbol(e);
          if (!q.isOverloaded(a)) {
            return;
          }
          const r = q.OverloadedType.getOverloads(a);
          const s = q.OverloadedType.getImplementation(a);
          this._validateOverloadFinalConsistency(r, s);
          this._validateOverloadAbstractConsistency(r, s);
        });
      }
      _validateOverloadAbstractConsistency(e, t) {
        if (t && q.isFunction(t)) {
          if (q.FunctionType.isAbstractMethod(t)) {
            return;
          }
          e.forEach(e => {
            var t;
            const n = e.shared.declaration;
            if (q.FunctionType.isAbstractMethod(e) && n) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadAbstractImplMismatch().format({
                name: e.shared.name
              }), (t = I.getNameNodeForDeclaration(n)) !== null && t !== undefined ? t : n.node);
            }
          });
          return;
        }
        if (e.length < 2) {
          return;
        }
        const n = q.FunctionType.isAbstractMethod(e[0]);
        e.slice(1).forEach((e, t) => {
          var a;
          if (q.FunctionType.isAbstractMethod(e) !== n && e.shared.declaration) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadAbstractMismatch().format({
              name: e.shared.name
            }), (a = I.getNameNodeForDeclaration(e.shared.declaration)) !== null && a !== undefined ? a : e.shared.declaration.node);
          }
        });
      }
      _validateOverloadFinalConsistency(e, t) {
        if (t && q.isFunction(t)) {
          if (!q.FunctionType.isFinal(t)) {
            e.forEach(e => {
              var t;
              var n;
              if (q.FunctionType.isFinal(e) && ((t = e.shared.declaration) === null || t === undefined ? undefined : t.node)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadFinalInconsistencyImpl().format({
                  name: e.shared.name
                }), (n = I.getNameNodeForDeclaration(e.shared.declaration)) !== null && n !== undefined ? n : e.shared.declaration.node);
              }
            });
          }
        } else {
          if (e.length > 0 && !q.FunctionType.isFinal(e[0])) {
            e.slice(1).forEach((e, t) => {
              var n;
              var a;
              if (q.FunctionType.isFinal(e) && ((n = e.shared.declaration) === null || n === undefined ? undefined : n.node)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportInconsistentOverload, g.LocMessage.overloadFinalInconsistencyNoImpl().format({
                  name: e.shared.name,
                  index: t + 2
                }), (a = I.getNameNodeForDeclaration(e.shared.declaration)) !== null && a !== undefined ? a : e.shared.declaration.node);
              }
            });
          }
        }
      }
      _validateTypedDictOverrides(e) {
        if (!q.ClassType.isTypedDictClass(e)) {
          return;
        }
        const t = R.getTypedDictMembersForClass(this._evaluator, e, false);
        for (const n of e.shared.baseClasses) {
          const a = new p.DiagnosticAddendum();
          if (!q.isClass(n) || !q.ClassType.isTypedDictClass(n) || !q.ClassType.isTypedDictEffectivelyClosed(n)) {
            continue;
          }
          const r = R.getTypedDictMembersForClass(this._evaluator, n, false);
          const s = G.buildSolutionFromSpecializedClass(n);
          const i = r.extraItems ? G.applySolvedTypeVars(r.extraItems.valueType, s) : q.UnknownType.create();
          for (const [e, n] of t.knownItems) {
            if (!r.knownItems.get(e)) {
              if (!r.extraItems || q.isNever(r.extraItems.valueType)) {
                a.addMessage(g.LocAddendum.typedDictClosedExtraNotAllowed().format({
                  name: e
                }));
              } else {
                if (this._evaluator.assignType(i, n.valueType, undefined, undefined, r.extraItems.isReadOnly ? 0 : 1)) {
                  if (!r.extraItems.isReadOnly && n.isRequired) {
                    a.addMessage(g.LocAddendum.typedDictClosedFieldNotRequired().format({
                      name: e
                    }));
                  }
                } else {
                  a.addMessage(g.LocAddendum.typedDictClosedExtraTypeMismatch().format({
                    name: e,
                    type: this._evaluator.printType(n.valueType)
                  }));
                }
              }
            }
          }
          if (t.extraItems && r.extraItems) {
            if (!this._evaluator.assignType(i, t.extraItems.valueType, undefined, undefined, r.extraItems.isReadOnly ? 0 : 1)) {
              a.addMessage(g.LocAddendum.typedDictClosedExtraTypeMismatch().format({
                name: 'extra_items',
                type: this._evaluator.printType(t.extraItems.valueType)
              }));
            }
          }
          if (!a.isEmpty() && e.shared.declaration) {
            const t = I.getNameNodeForDeclaration(e.shared.declaration);
            if (t) {
              if (r.extraItems) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.typedDictClosedExtras().format({
                  name: n.shared.name,
                  type: this._evaluator.printType(i)
                }) + a.getString(), t);
              } else {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.typedDictClosedNoExtras().format({
                  name: n.shared.name
                }) + a.getString(), t);
              }
            }
          }
        }
      }
      _validateBaseClassOverrides(e) {
        q.ClassType.getSymbolTable(e).forEach((t, n) => {
          if (U.isPrivateName(n)) {
            return;
          }
          let a = true;
          if (!t.hasTypedDeclarations()) {
            a = false;
          }
          const r = this._evaluator.getEffectiveTypeOfSymbol(t);
          if (q.isAnyOrUnknown(r)) {
            return;
          }
          let s;
          for (const i of e.shared.baseClasses) {
            if (!q.isClass(i)) {
              continue;
            }
            const o = e.shared.mro.find(e => q.isClass(e) && q.ClassType.isSameGenericClass(e, i));
            if (!o) {
              continue;
            }
            l.assert(q.isClass(o));
            const p = G.lookUpClassMember(o, n, 0);
            if (p) {
              s = s ?? p;
              this._validateBaseClassOverride(p, t, a ? r : q.AnyType.create(), e, n);
            }
          }
          if (s) {
            this._validateOverrideDecoratorPresent(t, r, s);
          } else {
            this._validateOverrideDecoratorNotPresent(t, r);
          }
        });
      }
      _validateOverrideDecoratorPresent(e, t, n) {
        if (this._fileInfo.diagnosticRuleSet.reportImplicitOverride === 'none') {
          return;
        }
        let a;
        if (q.isFunction(t)) {
          a = t;
        } else {
          if (q.isOverloaded(t)) {
            const e = q.OverloadedType.getImplementation(t);
            if (e && q.isFunction(e)) {
              a = e;
            }
          } else {
            if (q.isClassInstance(t) && q.ClassType.isPropertyClass(t) && t.priv.fgetInfo) {
              a = t.priv.fgetInfo.methodType;
            }
          }
        }
        if (!(a == null ? undefined : a.shared.declaration) || q.FunctionType.isOverridden(a)) {
          return;
        }
        if (this._isMethodExemptFromLsp(a.shared.name)) {
          return;
        }
        if (!e.getDeclarations().some(e => e === a.shared.declaration)) {
          return;
        }
        if (q.isAnyOrUnknown(n.classType)) {
          return;
        }
        const r = a.shared.declaration.node;
        this._evaluator.addDiagnostic(d.DiagnosticRule.reportImplicitOverride, g.LocMessage.overrideDecoratorMissing().format({
          name: r.d.name.d.value,
          className: this._evaluator.printType(G.convertToInstance(n.classType))
        }), r.d.name);
      }
      _isMethodExemptFromLsp(e) {
        return ['__init__', '__new__', '__init_subclass__', '__post_init__'].some(t => t === e);
      }
      _validateOverrideDecoratorNotPresent(e, t) {
        let n;
        if (q.isFunction(t)) {
          n = t;
        } else {
          if (q.isOverloaded(t)) {
            const e = q.OverloadedType.getImplementation(t);
            if (e && q.isFunction(e)) {
              n = e;
            }
          } else {
            if (q.isClassInstance(t) && q.ClassType.isPropertyClass(t) && t.priv.fgetInfo) {
              n = t.priv.fgetInfo.methodType;
            }
          }
        }
        if (!(n == null ? undefined : n.shared.declaration) || !q.FunctionType.isOverridden(n)) {
          return;
        }
        if (!e.getDeclarations().some(e => e === n.shared.declaration)) {
          return;
        }
        const a = n.shared.declaration.node;
        this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.overriddenMethodNotFound().format({
          name: a.d.name.d.value
        }), a.d.name);
      }
      _validateBaseClassOverride(e, t, n, a, r) {
        var s;
        var i;
        var o;
        var l;
        var c;
        var u;
        var m;
        var y;
        var h;
        var f;
        var T;
        var v;
        if (!q.isInstantiableClass(e.classType)) {
          return;
        }
        if (e.symbol.isIgnoredForOverrideChecks() || t.isIgnoredForOverrideChecks()) {
          return;
        }
        if (!e.symbol.hasTypedDeclarations()) {
          return;
        }
        if (r === '_') {
          return;
        }
        const b = e.classType;
        const _ = q.ClassType.cloneAsInstance(G.selfSpecializeClass(a, {
          useBoundTypeVars: true
        }));
        const C = G.partiallySpecializeType(this._evaluator.getEffectiveTypeOfSymbol(e.symbol), b, this._evaluator.getTypeClassType(), _);
        n = G.partiallySpecializeType(n, a, this._evaluator.getTypeClassType(), _);
        if (a.shared.typeVarScopeId) {
          n = G.makeTypeVarsBound(n, [a.shared.typeVarScopeId]);
        }
        if (q.isFunction(C) || q.isOverloaded(C)) {
          const o = new p.DiagnosticAddendum();
          let l = false;
          if (!U.isPrivateName(r)) {
            if (q.isFunction(C) && q.FunctionType.isFinal(C)) {
              l = true;
            } else {
              if (q.isOverloaded(C)) {
                const e = q.OverloadedType.getOverloads(C);
                const t = q.OverloadedType.getImplementation(C);
                if (e.some(e => q.FunctionType.isFinal(e))) {
                  l = true;
                }
                if (t && q.isFunction(t) && q.FunctionType.isFinal(t)) {
                  l = true;
                }
              }
            }
          }
          if (l) {
            const n = V.getLastTypedDeclarationForSymbol(t);
            if (n && n.type === 5) {
              const t = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.finalMethodOverride().format({
                name: r,
                className: b.shared.name
              }), n.node.d.name);
              const a = V.getLastTypedDeclarationForSymbol(e.symbol);
              if (t && a) {
                t.addRelatedInfo(g.LocAddendum.finalMethod(), a.uri, a.range);
              }
            }
          }
          if (q.isFunction(n) || q.isOverloaded(n)) {
            const i = !U.isDunderName(r);
            if (!this._isMethodExemptFromLsp(r) && !U.isPrivateName(r) && !q.ClassType.isTypedDictClass(a) && !this._evaluator.validateOverrideMethod(C, n, a, o, i)) {
              const n = V.getLastTypedDeclarationForSymbol(t);
              if (n) {
                const t = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.incompatibleMethodOverride().format({
                  name: r,
                  className: b.shared.name
                }) + o.getString(), (s = I.getNameNodeForDeclaration(n)) !== null && s !== undefined ? s : n.node);
                const a = V.getLastTypedDeclarationForSymbol(e.symbol);
                if (t && a) {
                  t.addRelatedInfo(g.LocAddendum.overriddenMethod(), a.uri, a.range);
                }
              }
            }
          } else {
            if (!q.isAnyOrUnknown(n) && !q.ClassType.isBuiltIn(b, '_TypedDict')) {
              const a = t.getDeclarations();
              if (a.length > 0) {
                const t = a[a.length - 1];
                const s = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.methodOverridden().format({
                  name: r,
                  className: b.shared.name,
                  type: this._evaluator.printType(n)
                }), (i = I.getNameNodeForDeclaration(t)) !== null && i !== undefined ? i : t.node);
                const o = V.getLastTypedDeclarationForSymbol(e.symbol);
                if (s && o) {
                  s.addRelatedInfo(g.LocAddendum.overriddenMethod(), o.uri, o.range);
                }
              }
            }
          }
        } else {
          if (G.isProperty(C)) {
            if (G.isProperty(n)) {
              this._validatePropertyOverride(b, a, C, n, t, r);
            } else {
              const e = t.getDeclarations();
              if (e.length > 0 && t.isClassMember()) {
                const t = e[e.length - 1];
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.propertyOverridden().format({
                  name: r,
                  className: b.shared.name
                }), (o = I.getNameNodeForDeclaration(t)) !== null && o !== undefined ? o : t.node);
              }
            }
          } else {
            if (this._fileInfo.diagnosticRuleSet.reportIncompatibleVariableOverride !== 'none') {
              const s = t.getDeclarations();
              if (s.length > 0) {
                const i = s[s.length - 1];
                const o = s[0];
                let _;
                let k;
                let w = (o == null ? undefined : o.type) === 1 && !o.isFinal;
                if (q.ClassType.isDataClassFrozen(b) && b.shared.dataClassEntries) {
                  if (b.shared.dataClassEntries.find(e => e.name === r)) {
                    w = false;
                  }
                }
                if (!t.isIgnoredForProtocolMatch()) {
                  if (b.shared.typedDictEntries) {
                    _ = (c = (l = b.shared.typedDictEntries.knownItems.get(r)) !== null && l !== undefined ? l : b.shared.typedDictEntries.extraItems) !== null && c !== undefined ? c : R.getEffectiveExtraItemsEntryType(this._evaluator, b);
                    if (_ == null ? undefined : _.isReadOnly) {
                      w = false;
                    }
                  }
                  if (a.shared.typedDictEntries) {
                    k = (m = (u = a.shared.typedDictEntries.knownItems.get(r)) !== null && u !== undefined ? u : a.shared.typedDictEntries.extraItems) !== null && m !== undefined ? m : R.getEffectiveExtraItemsEntryType(this._evaluator, a);
                  }
                }
                let S = new p.DiagnosticAddendum();
                if (this._evaluator.assignType(C, n, S, undefined, w ? 1 : 0)) {
                  if (_ && k) {
                    let e = true;
                    e = _.isReadOnly ? k.isRequired || !_.isRequired : k.isRequired === _.isRequired;
                    if (!e) {
                      const e = k.isRequired ? g.LocMessage.typedDictFieldRequiredRedefinition : g.LocMessage.typedDictFieldNotRequiredRedefinition;
                      this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, e().format({
                        name: r
                      }), (h = I.getNameNodeForDeclaration(i)) !== null && h !== undefined ? h : i.node);
                    }
                    if (!_.isReadOnly && k.isReadOnly) {
                      this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictFieldReadOnlyRedefinition().format({
                        name: r
                      }), (f = I.getNameNodeForDeclaration(i)) !== null && f !== undefined ? f : i.node);
                    }
                  }
                } else {
                  if (w) {
                    S = new p.DiagnosticAddendum();
                    S.addMessage(g.LocAddendum.overrideIsInvariant());
                    S.createAddendum().addMessage(g.LocAddendum.overrideInvariantMismatch().format({
                      overrideType: this._evaluator.printType(n),
                      baseType: this._evaluator.printType(C)
                    }));
                  }
                  const t = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.symbolOverridden().format({
                    name: r,
                    className: b.shared.name
                  }) + S.getString(), (y = I.getNameNodeForDeclaration(i)) !== null && y !== undefined ? y : i.node);
                  const a = V.getLastTypedDeclarationForSymbol(e.symbol);
                  if (t && a) {
                    t.addRelatedInfo(g.LocAddendum.overriddenSymbol(), a.uri, a.range);
                  }
                }
                const A = this._evaluator.isFinalVariable(e.symbol);
                const x = s.find(e => this._evaluator.isFinalVariableDeclaration(e));
                if (!A && x) {
                  const e = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, g.LocMessage.variableFinalOverride().format({
                    name: r,
                    className: b.shared.name
                  }), (T = I.getNameNodeForDeclaration(i)) !== null && T !== undefined ? T : i.node);
                  if (e) {
                    e.addRelatedInfo(g.LocAddendum.overriddenSymbol(), x.uri, x.range);
                  }
                }
                const P = e.symbol.isClassVar();
                let D = t.isClassVar();
                if (P && !D) {
                  if (!t.hasTypedDeclarations()) {
                    D = true;
                  }
                  if (t.getTypedDeclarations().every(e => e.type === 6)) {
                    D = true;
                  }
                }
                const N = q.ClassType.isTypedDictClass(a) && !D;
                if (P !== D && !N) {
                  const n = t.isClassVar() ? g.LocMessage.classVarOverridesInstanceVar() : g.LocMessage.instanceVarOverridesClassVar();
                  const a = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleVariableOverride, n.format({
                    name: r,
                    className: b.shared.name
                  }), (v = I.getNameNodeForDeclaration(i)) !== null && v !== undefined ? v : i.node);
                  const s = V.getLastTypedDeclarationForSymbol(e.symbol);
                  if (a && s) {
                    a.addRelatedInfo(g.LocAddendum.overriddenSymbol(), s.uri, s.range);
                  }
                }
              }
            }
          }
        }
      }
      _validatePropertyOverride(e, t, n, a, r, s) {
        [['fget', e => {
          var t;
          if ((t = e.priv.fgetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }], ['fset', e => {
          var t;
          if ((t = e.priv.fsetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }], ['fdel', e => {
          var t;
          if ((t = e.priv.fdelInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        }]].forEach(i => {
          var o;
          var l;
          const c = new p.DiagnosticAddendum();
          const [u, m] = i;
          const y = m(n);
          const h = m(a);
          if (y) {
            const n = G.partiallySpecializeType(y, e, this._evaluator.getTypeClassType());
            if (!q.isFunction(n)) {
              return;
            }
            if (!h) {
              c.addMessage(g.LocAddendum.propertyMethodMissing().format({
                name: u
              }));
              const t = r.getDeclarations();
              if (t.length > 0) {
                const a = t[t.length - 1];
                const r = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.propertyOverridden().format({
                  name: s,
                  className: e.shared.name
                }) + c.getString(), (o = I.getNameNodeForDeclaration(a)) !== null && o !== undefined ? o : a.node);
                const i = n.shared.declaration;
                if (r && i) {
                  r.addRelatedInfo(g.LocAddendum.overriddenMethod(), i.uri, i.range);
                }
              }
              return;
            }
            const a = G.partiallySpecializeType(h, t, this._evaluator.getTypeClassType());
            if (!q.isFunction(a)) {
              return;
            }
            if (this._evaluator.validateOverrideMethod(n, a, t, c.createAddendum())) {
              return;
            }
            c.addMessage(g.LocAddendum.propertyMethodIncompatible().format({
              name: u
            }));
            const i = a.shared.declaration;
            if (!i || i.type !== 5) {
              return;
            }
            let p = i.node.d.name;
            const m = t.shared.declaration;
            if (!m || m.node.nodeType !== 10 || !P.isNodeContainedWithin(i.node, m.node.d.suite)) {
              const e = r.getDeclarations();
              if (e.length === 0) {
                return;
              }
              const t = e[e.length - 1];
              p = (l = I.getNameNodeForDeclaration(t)) !== null && l !== undefined ? l : t.node;
            }
            const f = this._evaluator.addDiagnostic(d.DiagnosticRule.reportIncompatibleMethodOverride, g.LocMessage.propertyOverridden().format({
              name: s,
              className: e.shared.name
            }) + c.getString(), p);
            const T = n.shared.declaration;
            if (f && T) {
              f.addRelatedInfo(g.LocAddendum.overriddenMethod(), T.uri, T.range);
            }
          }
        });
      }
      _validateMethod(e, t, n) {
        const a = this._evaluator.getTypeOfClass(n);
        if (!a) {
          return;
        }
        const r = a.classType;
        const s = e.d.name.d.value;
        const i = G.isInstantiableMetaclass(r);
        if (['__init__', '__init_subclass__', '__enter__', '__exit__'].includes(s)) {
          if (!q.FunctionType.isAbstractMethod(t) && !q.FunctionType.isOverloaded(t) && !this._fileInfo.isStubFile) {
            this._validateSuperCallForMethod(e, t, r);
          }
        }
        const o = ['self', '_self', '__self'];
        const l = ['cls', '_cls', '__cls'];
        const p = ['__mcls', 'mcls', 'mcs', 'metacls'];
        if (s === '_generate_next_value_') {
          return;
        }
        if (s === '__new__') {
          if (e.d.params.length !== 0 && e.d.params[0].d.name) {
            const t = e.d.params[0].d.name.d.value;
            if (!l.includes(t) && (!i || !p.includes(t))) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportSelfClsParameterName, g.LocMessage.newClsParam(), e.d.params[0]);
            }
          } else {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportSelfClsParameterName, g.LocMessage.newClsParam(), e.d.name);
          }
          this._validateClsSelfParamType(e, t, r, true);
          return;
        }
        if (q.FunctionType.isStaticMethod(t)) {
          if (e.d.params.length === 0 || !e.d.params[0].d.name) {
            return;
          }
          const t = e.d.params[0].d.name.d.value;
          if (t === 'self' || t === 'cls') {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportSelfClsParameterName, g.LocMessage.staticClsSelfParam(), e.d.params[0].d.name);
          }
          return;
        }
        if (q.FunctionType.isClassMethod(t)) {
          let n = '';
          if (e.d.params.length > 0 && e.d.params[0].d.name) {
            n = e.d.params[0].d.name.d.value;
          }
          if (!l.includes(n) && (!i || !p.includes(n))) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportSelfClsParameterName, g.LocMessage.classMethodClsParam(), e.d.params.length > 0 ? e.d.params[0] : e.d.name);
          }
          this._validateClsSelfParamType(e, t, r, true);
          return;
        }
        const c = e.d.decorators.length > 0;
        if (q.FunctionType.isOverloaded(t) || !c) {
          let t = '';
          let n = true;
          if (e.d.params.length > 0) {
            if (e.d.params[0].d.name) {
              t = e.d.params[0].d.name.d.value;
            }
            if (e.d.params[0].d.category !== 0) {
              n = false;
            }
          }
          if (n && !o.includes(t)) {
            const n = i && l.includes(t);
            const a = U.isPrivateOrProtectedName(t);
            if (!n && !a) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportSelfClsParameterName, g.LocMessage.instanceMethodSelfParam(), e.d.params.length > 0 ? e.d.params[0] : e.d.name);
            }
          }
        }
        this._validateClsSelfParamType(e, t, r, false);
      }
      _validateSuperCallForMethod(e, t, n) {
        if (this._fileInfo.diagnosticRuleSet.reportMissingSuperCall === 'none') {
          return;
        }
        let a = 17;
        if (q.ClassType.isFinal(n)) {
          a |= 4;
        }
        if (!G.lookUpClassMember(n, t.shared.name, a)) {
          return;
        }
        let r = false;
        const s = new P.CallNodeWalker(e => {
          if (e.d.leftExpr.nodeType === 35 && e.d.leftExpr.d.member.d.value === t.shared.name) {
            const t = e.d.leftExpr.d.leftExpr;
            if (t.nodeType === 9 && t.d.leftExpr.nodeType === 38 && t.d.leftExpr.d.value === 'super') {
              r = true;
            } else {
              const e = this._evaluator.getType(t);
              if (e && q.isInstantiableClass(e)) {
                r = true;
              }
            }
          }
        });
        s.walk(e.d.suite);
        if (!r) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportMissingSuperCall, g.LocMessage.missingSuperCall().format({
            methodName: t.shared.name
          }), e.d.name);
        }
      }
      _validateClsSelfParamType(e, t, n, a) {
        var r;
        if (e.d.params.length < 1 || t.shared.parameters.length < 1) {
          return;
        }
        const s = t.shared.parameters[0];
        const i = q.FunctionType.getParamType(t, 0);
        const o = (r = e.d.params[0].d.annotation) !== null && r !== undefined ? r : e.d.params[0].d.annotationComment;
        if (!o || !s.name) {
          return;
        }
        if (t.shared.name === '__init__' && t.shared.methodClass) {
          if (G.getTypeVarArgsRecursive(i).some(e => {
            var n;
            return e.priv.scopeId === ((n = t.shared.methodClass) === null || n === undefined ? undefined : n.shared.typeVarScopeId) && !q.TypeVarType.isSelf(e);
          })) {
            this._evaluator.addDiagnostic(d.DiagnosticRule.reportInvalidTypeVarUse, g.LocMessage.initMethodSelfParamTypeVar(), o);
          }
        }
        if (q.ClassType.isProtocolClass(n)) {
          return;
        }
        const l = this._evaluator.makeTopLevelTypeVarsConcrete(i);
        const p = a ? n : G.convertToInstance(n);
        if ((!q.isInstantiableClass(l) || !q.ClassType.isProtocolClass(l)) && (!q.isClassInstance(l) || !q.ClassType.isProtocolClass(l)) && (s.category !== 1 || !q.isParamSpec(i) || i.priv.paramSpecAccess !== 'args') && !q.FunctionType.isOverloaded(t) && (!q.isClassInstance(i) || !q.ClassType.isBuiltIn(i, 'LiteralString') || !q.ClassType.isBuiltIn(n, 'str')) && !this._evaluator.assignType(i, p) && !q.isNever(i)) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.clsSelfParamTypeMismatch().format({
            name: s.name,
            classType: this._evaluator.printType(p)
          }), o);
        }
      }
      _validateYieldType(e, t, n, a) {
        var r;
        var s;
        var i;
        var o;
        const l = P.getEnclosingFunction(e);
        if (!l || !l.d.returnAnnotation) {
          return;
        }
        const c = this._evaluator.getTypeOfFunction(l);
        if (!c) {
          return;
        }
        let u = q.FunctionType.getEffectiveReturnType(c.functionType);
        if (!u) {
          return;
        }
        const m = P.getTypeVarScopesForNode(e);
        let y;
        u = G.makeTypeVarsBound(u, m);
        y = !l.d.isAsync && q.isClassInstance(u) && q.ClassType.isBuiltIn(u, 'AwaitableGenerator') ? this._evaluator.getTypingType(e, 'AwaitableGenerator') : this._evaluator.getTypingType(e, l.d.isAsync ? 'AsyncGenerator' : 'Generator');
        if (!y || !q.isInstantiableClass(y)) {
          return;
        }
        if (!this._evaluator.isNodeReachable(e, undefined)) {
          return;
        }
        if (q.isNever(u)) {
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.noReturnContainsYield(), e);
          return;
        }
        const h = [t, a ?? q.UnknownType.create(), q.UnknownType.create()];
        const f = q.ClassType.cloneAsInstance(q.ClassType.specialize(y, h));
        const T = new p.DiagnosticAddendum();
        if (!this._evaluator.assignType(u, f, T)) {
          const a = l.d.isAsync ? g.LocMessage.generatorAsyncReturnType() : g.LocMessage.generatorSyncReturnType();
          this._evaluator.addDiagnostic(d.DiagnosticRule.reportReturnType, a.format({
            yieldType: this._evaluator.printType(t)
          }) + ((r = n == null ? undefined : n.getString()) !== null && r !== undefined ? r : T.getString()), (s = e.d.expr) !== null && s !== undefined ? s : e, (o = (i = n == null ? undefined : n.getEffectiveTextRange()) !== null && i !== undefined ? i : e.d.expr) !== null && o !== undefined ? o : e);
        }
      }
      _reportUnusedExceptStatements(e) {
        let t = false;
        const n = [];
        e.d.exceptClauses.forEach(e => {
          var a;
          var r;
          if (t || e.d.isExceptGroup || !e.d.typeExpr) {
            return;
          }
          const s = this._evaluator.getType(e.d.typeExpr);
          if (!s || q.isAnyOrUnknown(s)) {
            t = true;
            return;
          }
          const i = [];
          if (q.isInstantiableClass(s)) {
            if (s.priv.includeSubclasses) {
              t = true;
            }
            i.push(s);
          } else {
            if (q.isClassInstance(s)) {
              const n = (r = (a = this._evaluator.getTypeOfIterator({
                type: s
              }, false, e.d.typeExpr, false)) === null || a === undefined ? undefined : a.type) !== null && r !== undefined ? r : q.UnknownType.create();
              G.doForEachSubtype(n, e => {
                if (q.isAnyOrUnknown(e)) {
                  t = true;
                }
                if (q.isInstantiableClass(e)) {
                  if (e.priv.includeSubclasses) {
                    t = true;
                  }
                  i.push(e);
                }
              });
            } else {
              t = true;
            }
          }
          if (n.length > 0 && !t) {
            const t = new p.DiagnosticAddendum();
            let a = 0;
            i.forEach(e => {
              const r = n.find(t => G.derivesFromClassRecursive(e, t, true));
              if (r) {
                t.addMessage(g.LocAddendum.unreachableExcept().format({
                  exceptionType: this._evaluator.printType(G.convertToInstance(e)),
                  parentType: this._evaluator.printType(G.convertToInstance(r))
                }));
                a++;
              }
            });
            if (i.length > 0 && i.length === a) {
              this._evaluator.addDiagnostic(d.DiagnosticRule.reportUnusedExcept, g.LocMessage.unreachableExcept() + t.getString(), e.d.typeExpr);
              this._evaluator.addUnreachableCode(e, B.Reachability.UnreachableByAnalysis, e.d.exceptSuite);
            }
          }
          o.appendArray(n, i);
        });
      }
      _reportDuplicateImports() {
        const e = A.getTopLevelImports(this._moduleNode);
        const t = new Map();
        e.orderedImports.forEach(e => {
          if (e.node.nodeType === 25) {
            const t = new Map();
            e.node.d.imports.forEach(e => {
              if (!e.d.alias) {
                if (t.get(e.d.name.d.value)) {
                  this._evaluator.addDiagnostic(d.DiagnosticRule.reportDuplicateImport, g.LocMessage.duplicateImport().format({
                    importName: e.d.name.d.value
                  }), e.d.name);
                } else {
                  t.set(e.d.name.d.value, e);
                }
              }
            });
          } else {
            if (e.subnode && !e.subnode.d.alias) {
              if (t.get(e.moduleName)) {
                this._evaluator.addDiagnostic(d.DiagnosticRule.reportDuplicateImport, g.LocMessage.duplicateImport().format({
                  importName: e.moduleName
                }), e.subnode);
              } else {
                t.set(e.moduleName, e.subnode);
              }
            }
          }
        });
      }
    }
    exports.Checker = W;
  },
  1693: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CircularDependency = undefined;
    exports.CircularDependency = class {
      constructor() {
        this._paths = [];
      }
      appendPath(e) {
        this._paths.push(e);
      }
      getPaths() {
        return this._paths;
      }
      normalizeOrder() {
        let e = 0;
        this._paths.forEach((t, n) => {
          if (t < this._paths[e]) {
            e = n;
          }
        });
        if (e !== 0) {
          this._paths = this._paths.slice(e).concat(this._paths.slice(0, e));
        }
      }
      isEqual(e) {
        if (e._paths.length !== this._paths.length) {
          return false;
        }
        for (let t = 0; t < this._paths.length; t++) {
          if (this._paths[t] !== e._paths[t]) {
            return false;
          }
        }
        return true;
      }
    };
  },
  19914: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FlowNodeTypeResult = undefined;
    exports.isIncompleteType = f;
    exports.getCodeFlowEngine = function (e, t) {
      const n = new Set();
      const I = new Map();
      const k = new Map();
      const w = new Map();
      let S = 1;
      let A = 0;
      let x = 0;
      let P = false;
      function D(t, r, s = false) {
        const o = new Set();
        const l = new Set();
        function p(e) {
          if (l.size > 0) {
            return e;
          }
          let n = I.get(t.id);
          if (!n) {
            n = {
              reachability: undefined,
              reachabilityFrom: new Map()
            };
            I.set(t.id, n);
          }
          if (r) {
            n.reachabilityFrom.set(r.id, e);
          } else {
            n.reachability = e;
          }
          return e;
        }
        if (T) {
          z(t, undefined, 'getFlowNodeReachability');
        }
        if (n.has(t.id)) {
          return u.Reachability.UnreachableByAnalysis;
        }
        n.add(t.id);
        try {
          return function t(n, d = 0) {
            var c;
            if (d > 64) {
              return u.Reachability.Reachable;
            }
            d++;
            let g = n;
            while (true) {
              const h = I.get(n.id);
              if (h !== undefined && l.size === 0) {
                if (r) {
                  const e = h.reachabilityFrom.get(r.id);
                  if (e !== undefined) {
                    return e;
                  }
                } else {
                  if (h.reachability !== undefined) {
                    return h.reachability;
                  }
                }
              }
              if (o.has(g.id)) {
                return p(u.Reachability.UnreachableAlways);
              }
              o.add(g.id);
              if (g.flags & i.FlowFlags.Unreachable) {
                return p(u.Reachability.UnreachableAlways);
              }
              if (g === r) {
                return p(u.Reachability.Reachable);
              }
              if (g.flags & (i.FlowFlags.VariableAnnotation | i.FlowFlags.Assignment | i.FlowFlags.WildcardImport | i.FlowFlags.ExhaustedMatch)) {
                g = g.antecedent;
              } else {
                if (g.flags & i.FlowFlags.NarrowForPattern) {
                  const t = g;
                  const n = e.evaluateTypeForSubnode(t.statement, () => {
                    if (t.statement.nodeType === 64) {
                      e.evaluateTypesForCaseStatement(t.statement);
                    } else {
                      e.evaluateTypesForMatchStatement(t.statement);
                    }
                  });
                  if (n && y.isNever(n.type)) {
                    return p(u.Reachability.UnreachableByAnalysis);
                  }
                  g = t.antecedent;
                } else {
                  if (g.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.FalseCondition | i.FlowFlags.TrueNeverCondition | i.FlowFlags.FalseNeverCondition)) {
                    const t = g;
                    if (t.reference) {
                      const n = e.lookUpSymbolRecursive(t.reference, t.reference.d.value, false);
                      if (n && n.symbol.hasTypedDeclarations()) {
                        let n = false;
                        const a = m.getTypeNarrowingCallback(e, t.reference, t.expression, !!(t.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.TrueNeverCondition)));
                        if (a) {
                          const r = e.getTypeOfExpression(t.reference);
                          const s = a(r.type);
                          const i = (c = s == null ? undefined : s.type) !== null && c !== undefined ? c : r.type;
                          if (y.isNever(i) && !r.isIncomplete) {
                            n = true;
                          }
                        }
                        if (n) {
                          return p(u.Reachability.UnreachableByAnalysis);
                        }
                      }
                    }
                    g = t.antecedent;
                  } else {
                    if (g.flags & i.FlowFlags.Call) {
                      const t = g;
                      if (!s && F(e, t)) {
                        return p(u.Reachability.UnreachableByAnalysis);
                      }
                      g = t.antecedent;
                    } else {
                      if (g.flags & (i.FlowFlags.BranchLabel | i.FlowFlags.LoopLabel)) {
                        if (g.flags & i.FlowFlags.PostContextManager) {
                          const t = g;
                          if (!t.expressions.some(n => M(e, n, t.isAsync))) {
                            return p(u.Reachability.UnreachableByAnalysis);
                          }
                        }
                        const n = g;
                        let a = false;
                        for (const e of n.antecedents) {
                          const n = t(e, d);
                          if (n === u.Reachability.Reachable) {
                            return p(n);
                          }
                          if (n === u.Reachability.UnreachableByAnalysis) {
                            a = true;
                          }
                        }
                        return p(a ? u.Reachability.UnreachableByAnalysis : u.Reachability.UnreachableAlways);
                      }
                      if (g.flags & i.FlowFlags.Start) {
                        return p(r ? u.Reachability.UnreachableByAnalysis : u.Reachability.Reachable);
                      }
                      if (!(g.flags & i.FlowFlags.PreFinallyGate)) {
                        if (g.flags & i.FlowFlags.PostFinally) {
                          const e = g;
                          const n = l.has(e.preFinallyGate.id);
                          try {
                            l.add(e.preFinallyGate.id);
                            return p(t(e.antecedent, d));
                          } finally {
                            if (!n) {
                              l.delete(e.preFinallyGate.id);
                            }
                          }
                        }
                        a.fail('Unexpected flow node flags');
                        return p(u.Reachability.Reachable);
                      }
                      {
                        const e = g;
                        if (l.has(e.id)) {
                          return p(u.Reachability.UnreachableByAnalysis);
                        }
                        g = e.antecedent;
                      }
                    }
                  }
                }
              }
            }
          }(t);
        } finally {
          n.delete(t.id);
        }
      }
      function N(e, t) {
        let n = true;
        g.doForEachSubtype(e, e => {
          if (y.isTypeVar(e)) {
            if (!y.isTypeSame(e, t)) {
              n = false;
            }
          } else {
            if (!e.props?.condition || !e.props.condition.some(e => y.TypeVarType.hasConstraints(e.typeVar) && e.typeVar.priv.nameWithScope === t.priv.nameWithScope)) {
              n = false;
            }
          }
        });
        return n;
      }
      function F(e, t) {
        const n = t.node;
        if (s.getFileInfo(n).isStubFile) {
          return false;
        }
        if (v) {
          console.log(`isCallNoReturn@${t.id} Pre depth ${A}`);
        }
        if (k.has(n.id)) {
          const e = k.get(n.id);
          if (v) {
            console.log(`isCallNoReturn@${t.id} Post: ${e ? 'true' : 'false'} (cached)`);
          }
          return e;
        }
        if (A > y.maxTypeRecursionCount) {
          return false;
        }
        if (n.d.leftExpr.nodeType === 33) {
          return false;
        }
        k.set(n.id, false);
        A++;
        try {
          let a = 0;
          let r = 0;
          const s = e.getTypeOfExpression(n.d.leftExpr, 2);
          const i = s.type;
          g.doForEachSubtype(i, t => {
            r++;
            if (y.isInstantiableClass(t)) {
              if (l.getBoundCallMethod(e, n, t)) {
                return;
              }
              const a = l.getBoundNewMethod(e, n, t);
              if (a && (y.isFunction(a.type) || y.isOverloaded(a.type))) {
                t = a.type;
              }
            } else {
              if (y.isClassInstance(t)) {
                const n = e.getBoundMagicMethod(t, '__call__');
                if (n) {
                  t = n;
                }
              }
            }
            const o = n.parent?.nodeType === 6;
            if (y.isFunction(t)) {
              if (E(t, o)) {
                a++;
              }
            } else {
              if (y.isOverloaded(t)) {
                let r = 0;
                let i = 0;
                y.OverloadedType.getOverloads(t).forEach(e => {
                  r++;
                  if (E(e, o)) {
                    i++;
                  }
                });
                if (i > 0) {
                  if (i === r) {
                    a++;
                  } else {
                    const r = e.validateOverloadedArgTypes(n, n.d.args.map(t => e.convertNodeToArg(t)), {
                      type: t,
                      isIncomplete: s.isIncomplete
                    }, undefined, false, undefined);
                    if (r.returnType && y.isNever(r.returnType)) {
                      a++;
                    }
                  }
                }
              }
            }
          });
          const o = r > 0 && a === r;
          k.set(n.id, o);
          if (v) {
            console.log(`isCallNoReturn@${t.id} Post: ${o ? 'true' : 'false'}`);
          }
          return o;
        } finally {
          A--;
        }
      }
      function E(t, n) {
        const a = y.FunctionType.getEffectiveReturnType(t, false);
        if (a) {
          return !!y.isClassInstance(a) && !!y.ClassType.isBuiltIn(a, 'Coroutine') && !!a.priv.typeArgs && !!(a.priv.typeArgs.length >= 3) && !!y.isNever(a.priv.typeArgs[2]) && !!n || y.isNever(a);
        }
        if (!b) {
          return false;
        }
        if (t.shared.declaration && !t.shared.declaration.isGenerator && !y.FunctionType.isAbstractMethod(t) && !y.FunctionType.isStubDefinition(t) && !y.FunctionType.isPyTypedDefinition(t)) {
          const n = t.shared.declaration.node.d.suite.d.statements;
          let a = false;
          for (const t of n) {
            if (t.nodeType !== 47 || t.d.statements.length !== 1) {
              break;
            }
            const n = t.d.statements[0];
            if (n.nodeType !== 48) {
              if (n.nodeType === 43 && n.d.expr) {
                const t = e.getType(n.d.expr);
                if (t && y.isClass(t) && g.derivesFromStdlibClass(t, 'NotImplementedError')) {
                  a = true;
                }
              }
              break;
            }
          }
          if (!a && !function (e, t) {
            if (!t.shared.declaration) {
              return true;
            }
            return e.isAfterNodeReachable(t.shared.declaration.node);
          }(e, t)) {
            return true;
          }
        }
        return false;
      }
      function M(e, t, n) {
        if (w.has(t.id)) {
          return w.get(t.id);
        }
        w.set(t.id, false);
        if (x > y.maxTypeRecursionCount) {
          return false;
        }
        x++;
        let a = false;
        try {
          const r = e.getTypeOfExpression(t).type;
          if (r && y.isClassInstance(r)) {
            const t = n ? '__aexit__' : '__exit__';
            const s = e.getBoundMagicMethod(r, t);
            if (s && y.isFunction(s) && s.shared.declaredReturnType) {
              let e = s.shared.declaredReturnType;
              if (n && y.isClassInstance(e) && y.ClassType.isBuiltIn(e, 'Coroutine') && e.priv.typeArgs && e.priv.typeArgs.length >= 3) {
                e = e.priv.typeArgs[2];
              }
              a = false;
              if (y.isClassInstance(e) && y.ClassType.isBuiltIn(e, 'bool')) {
                if (e.priv.literalValue === undefined || e.priv.literalValue === true) {
                  a = true;
                }
              }
            }
          }
        } finally {
          x--;
        }
        w.set(t.id, a);
        return a;
      }
      function O(t, n) {
        const r = s.getImportInfo(t.node.d.module);
        a.assert(r !== undefined && r.isImportFound);
        a.assert(t.node.d.isWildcardImport);
        const i = e.lookUpSymbolRecursive(t.node, n, false);
        a.assert(i !== undefined);
        const o = i.symbol.getDeclarations().find(e => e.node === t.node);
        return o && e.getInferredTypeOfDeclaration(i.symbol, o) || y.UnknownType.create();
      }
      function z(e, t, n, a = console) {
        let i = '';
        if (t) {
          const e = s.getFileInfo(t);
          const n = r.convertOffsetToPosition(t.start, e.lines);
          i = `${p.printExpression(t)}[${n.line + 1}:${n.character + 1}]`;
        }
        a.log(`${n}@${e.id}: ${i || '(none)'}`);
        a.log(o.formatControlFlowGraph(e));
      }
      return {
        createCodeFlowAnalyzer: function () {
          const n = new Map();
          function r(e) {
            if (!e) {
              return false;
            }
            for (const [t, a] of n.entries()) {
              if (t !== e && a.pendingNodes.size > 0) {
                return true;
              }
            }
            return false;
          }
          return {
            getTypeFromCodeFlow: function (s, o, l) {
              var v;
              var b;
              if (T) {
                z(s, o, 'getTypeFromCodeFlow');
              }
              const I = o !== undefined ? i.createKeyForReference(o) : undefined;
              let k;
              const w = I !== undefined && (l == null ? undefined : l.targetSymbolId) !== undefined ? `${I}.${l == null ? undefined : l.targetSymbolId.toString()}` : '.';
              const A = function (e) {
                let t = n.get(e);
                if (!t) {
                  t = {
                    cache: new Map(),
                    pendingNodes: new Set(),
                    closedFinallyGateNodes: new Set()
                  };
                  n.set(e, t);
                }
                return t;
              }(w);
              function x(e, n, a) {
                if (a) {
                  if (n) {
                    const t = A.cache.get(e.id);
                    if (t) {
                      const e = t;
                      if (e.isIncompleteType && e.type && !y.isTypeSame(e.type, n)) {
                        S++;
                      }
                    }
                  }
                } else {
                  S++;
                }
                const r = a ? {
                  isIncompleteType: true,
                  type: n,
                  incompleteSubtypes: [],
                  generationCount: S
                } : n;
                A.cache.set(e.id, r);
                t.trackEntry(A.cache, e.id);
                return h.create(n, a, S, a ? [] : undefined);
              }
              function N(e, t, n, r, s, i) {
                const o = A.cache.get(e.id);
                if (o === undefined || !f(o)) {
                  a.fail(`setIncompleteSubtype can be called only on a valid incomplete cache entry: prev cache entry?: ${!o} index=${t} isPending=${s} evaluationCount=${i}`);
                }
                const l = o.incompleteSubtypes;
                if (t < l.length) {
                  const e = l[t];
                  if (e.isIncomplete === r && y.isTypeSame(e.type, n)) {
                    if (e.isPending !== s) {
                      l[t] = {
                        type: n,
                        isIncomplete: r,
                        isPending: s,
                        evaluationCount: i
                      };
                    }
                  } else {
                    l[t] = {
                      type: n,
                      isIncomplete: r,
                      isPending: s,
                      evaluationCount: i
                    };
                    S++;
                  }
                } else {
                  a.assert(l.length === t);
                  l.push({
                    type: n,
                    isIncomplete: r,
                    isPending: s,
                    evaluationCount: i
                  });
                  S++;
                }
                let p;
                if (o.incompleteSubtypes.length > 0) {
                  const e = [];
                  o.incompleteSubtypes.forEach(t => {
                    if (t.type) {
                      e.push(t.type);
                    }
                  });
                  p = e.length > 0 ? y.combineTypes(e) : undefined;
                }
                o.type = p;
                o.generationCount = S;
                return E(e);
              }
              function E(e) {
                if (!A.cache.has(e.id)) {
                  return;
                }
                const t = A.cache.get(e.id);
                if (t === undefined) {
                  return h.create(undefined, false);
                } else {
                  if (f(t)) {
                    return h.create(t.type, true, t.generationCount, t.incompleteSubtypes);
                  } else {
                    return h.create(t, false);
                  }
                }
              }
              function U(e) {
                var t;
                if (!e.type) {
                  return;
                }
                if (!e.incompleteSubtypes || e.incompleteSubtypes.length === 0) {
                  return g.cleanIncompleteUnknown(e.type);
                }
                const n = [];
                if ((t = e.incompleteSubtypes) !== null && t !== undefined) {
                  t.forEach(e => {
                    if (e.type && !g.isIncompleteUnknown(e.type)) {
                      n.push(g.cleanIncompleteUnknown(e.type));
                    }
                  });
                }
                return y.combineTypes(n);
              }
              function V(t) {
                let n = t.node;
                const a = t.node.parent;
                if (a) {
                  if (a.nodeType === 31 || a.nodeType === 10) {
                    n = a;
                  }
                }
                return e.evaluateTypeForSubnode(n, () => {
                  e.evaluateTypesForStatement(t.node);
                });
              }
              function R(e, t) {
                A.pendingNodes.add(e.id);
                try {
                  const n = t();
                  A.pendingNodes.delete(e.id);
                  return n;
                } catch (t) {
                  A.pendingNodes.delete(e.id);
                  throw t;
                }
              }
              function L(t) {
                var n;
                var r;
                var s;
                var f;
                var T;
                var v;
                let b = t;
                for (e.checkForCancellation();;) {
                  const t = E(b);
                  if (t) {
                    if (!t.isIncomplete) {
                      return t;
                    }
                    if (t.generationCount === S) {
                      return h.create(U(t), true);
                    }
                  }
                  if (A.pendingNodes.has(b.id)) {
                    return h.create((n = t == null ? undefined : t.type) !== null && n !== undefined ? n : y.UnknownType.create(true), true);
                  }
                  if (b.flags & i.FlowFlags.Unreachable) {
                    return x(b, y.NeverType.createNever(), false);
                  }
                  if (b.flags & i.FlowFlags.VariableAnnotation) {
                    b = b.antecedent;
                  } else {
                    if (b.flags & i.FlowFlags.Call) {
                      const t = b;
                      if (F(e, t)) {
                        return x(b, undefined, false);
                      }
                      b = t.antecedent;
                    } else {
                      if (b.flags & i.FlowFlags.Assignment) {
                        const t = b;
                        const n = t.node;
                        if (o) {
                          if ((l == null ? undefined : l.targetSymbolId) === t.targetSymbolId && p.isMatchingExpression(o, n)) {
                            if (b.flags & i.FlowFlags.Unbind) {
                              if (o.nodeType === 27 || o.nodeType === 35) {
                                return x(b, undefined, false);
                              } else {
                                return x(b, y.UnboundType.create(), false);
                              }
                            }
                            let a = R(b, () => V(t));
                            if (a) {
                              if (g.isTypeAliasPlaceholder(a.type)) {
                                return h.create(a.type, true);
                              }
                              if (o.nodeType === 35 && e.isAsymmetricAccessorAssignment(n)) {
                                a = undefined;
                              }
                            }
                            return x(b, a == null ? undefined : a.type, !!(a == null ? undefined : a.isIncomplete));
                          }
                          if (n.nodeType === 27 && p.isMatchingExpression(o, n.d.leftExpr) && ((r = n.parent) === null || r === undefined ? undefined : r.nodeType) === 3 && n.d.items.length === 1 && !n.d.trailingComma && !n.d.items[0].d.name && n.d.items[0].d.argCategory === 0 && n.d.items[0].d.valueExpr.nodeType === 48 && n.d.items[0].d.valueExpr.d.strings.length === 1 && n.d.items[0].d.valueExpr.d.strings[0].nodeType === 49) {
                            const e = n.d.items[0].d.valueExpr.d.strings[0].d.value;
                            const a = R(t, () => {
                              const n = L(t.antecedent);
                              if (n.type) {
                                n.type = g.mapSubtypes(n.type, t => y.isClass(t) && y.ClassType.isTypedDictClass(t) ? c.narrowForKeyAssignment(t, e) : t);
                              }
                              return n;
                            });
                            return x(b, a == null ? undefined : a.type, !!(a == null ? undefined : a.isIncomplete));
                          }
                          if (p.isPartialMatchingExpression(o, n)) {
                            return h.create((s = l == null ? undefined : l.typeAtStart) === null || s === undefined ? undefined : s.type, !!((f = l == null ? undefined : l.typeAtStart) === null || f === undefined ? undefined : f.isIncomplete));
                          }
                        }
                        b = t.antecedent;
                      } else {
                        if (b.flags & i.FlowFlags.BranchLabel) {
                          const t = b;
                          if (b.flags & i.FlowFlags.PostContextManager) {
                            const t = b;
                            if (t.expressions.some(n => M(e, n, t.isAsync)) === t.blockIfSwallowsExceptions) {
                              return x(b, undefined, false);
                            }
                          }
                          if (o && t.preBranchAntecedent && t.affectedExpressions && (k ||= i.createKeysForReferenceSubexpressions(o), !k.some(e => t.affectedExpressions.has(e)) && D(b, t.preBranchAntecedent) === u.Reachability.Reachable)) {
                            b = t.preBranchAntecedent;
                            continue;
                          }
                          return B(b);
                        }
                        if (b.flags & i.FlowFlags.LoopLabel) {
                          const e = b;
                          if (o && (k ||= i.createKeysForReferenceSubexpressions(o), !k.some(t => e.affectedExpressions.has(t)))) {
                            b = e.antecedents[0];
                            continue;
                          }
                          return j(e, t);
                        }
                        if (b.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.FalseCondition)) {
                          const t = b;
                          if (!(l == null ? undefined : l.skipConditionalNarrowing) && o) {
                            const n = R(b, () => {
                              const n = m.getTypeNarrowingCallback(e, o, t.expression, !!(t.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.TrueNeverCondition)));
                              if (n) {
                                const e = L(t.antecedent);
                                let a = e.type;
                                let r = e.isIncomplete;
                                if (a) {
                                  const e = n(a);
                                  if (e) {
                                    a = e.type;
                                    if (e.isIncomplete) {
                                      r = true;
                                    }
                                  }
                                }
                                return x(b, a, r);
                              }
                            });
                            if (n) {
                              return n;
                            }
                          }
                          b = t.antecedent;
                        } else {
                          if (b.flags & (i.FlowFlags.TrueNeverCondition | i.FlowFlags.FalseNeverCondition)) {
                            const t = b;
                            if (!(l == null ? undefined : l.skipConditionalNarrowing) && t.reference && i.createKeyForReference(t.reference) !== I) {
                              const n = e.lookUpSymbolRecursive(t.reference, t.reference.d.value, false);
                              if (n && n.symbol.hasTypedDeclarations()) {
                                const n = R(b, () => {
                                  const n = m.getTypeNarrowingCallback(e, t.reference, t.expression, !!(t.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.TrueNeverCondition)));
                                  if (n) {
                                    const a = e.getTypeOfExpression(t.reference);
                                    let r = a.type;
                                    let s = !!a.isIncomplete;
                                    const i = n(a.type);
                                    if (i) {
                                      r = i.type;
                                      if (i.isIncomplete) {
                                        s = true;
                                      }
                                    }
                                    if (y.isNever(r)) {
                                      return x(b, undefined, s);
                                    }
                                  }
                                });
                                if (n) {
                                  return n;
                                }
                              }
                            }
                            b = t.antecedent;
                          } else {
                            if (b.flags & i.FlowFlags.ExhaustedMatch) {
                              const t = b;
                              const n = e.evaluateTypeForSubnode(t.node, () => {
                                e.evaluateTypesForMatchStatement(t.node);
                              });
                              if (n) {
                                if (y.isNever(n.type)) {
                                  return x(b, n.type, !!n.isIncomplete);
                                }
                                if (o) {
                                  const a = d.getPatternSubtypeNarrowingCallback(e, o, t.subjectExpression);
                                  if (a) {
                                    const e = a(n.type);
                                    if (e) {
                                      return x(b, e.type, !!n.isIncomplete || !!e.isIncomplete);
                                    }
                                  }
                                }
                              }
                              b = t.antecedent;
                            } else {
                              if (b.flags & i.FlowFlags.NarrowForPattern) {
                                const t = b;
                                if (!o || p.isMatchingExpression(o, t.subjectExpression)) {
                                  const n = e.evaluateTypeForSubnode(t.statement, () => {
                                    if (t.statement.nodeType === 64) {
                                      e.evaluateTypesForCaseStatement(t.statement);
                                    } else {
                                      e.evaluateTypesForMatchStatement(t.statement);
                                    }
                                  });
                                  if (n) {
                                    if (o) {
                                      return x(b, n.type, !!n.isIncomplete);
                                    }
                                    if (y.isNever(n.type)) {
                                      return x(b, undefined, !!n.isIncomplete);
                                    }
                                  }
                                } else {
                                  if (t.statement.nodeType === 64) {
                                    const n = t.statement;
                                    const a = d.getPatternSubtypeNarrowingCallback(e, o, t.subjectExpression);
                                    if (a) {
                                      const t = e.evaluateTypeForSubnode(n, () => {
                                        e.evaluateTypesForCaseStatement(n);
                                      });
                                      if (t) {
                                        const e = a(t.type);
                                        if (e) {
                                          return x(b, e.type, !!t.isIncomplete || !!e.isIncomplete);
                                        }
                                      }
                                    }
                                  }
                                }
                                b = t.antecedent;
                              } else {
                                if (b.flags & i.FlowFlags.PreFinallyGate) {
                                  return q(b);
                                }
                                if (b.flags & i.FlowFlags.PostFinally) {
                                  return G(b);
                                }
                                if (b.flags & i.FlowFlags.Start) {
                                  return x(b, (T = l == null ? undefined : l.typeAtStart) === null || T === undefined ? undefined : T.type, !!((v = l == null ? undefined : l.typeAtStart) === null || v === undefined ? undefined : v.isIncomplete));
                                }
                                if (b.flags & i.FlowFlags.WildcardImport) {
                                  const e = b;
                                  if (o && o.nodeType === 38) {
                                    const t = o.d.value;
                                    if (e.names.some(e => e === t)) {
                                      return R(b, () => {
                                        const n = O(e, t);
                                        return x(b, n, false);
                                      });
                                    }
                                  }
                                  b = e.antecedent;
                                } else {
                                  a.fail('Unexpected flow node flags');
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              function B(e) {
                const t = [];
                let n = false;
                for (const a of e.antecedents) {
                  const r = L(a);
                  if (o === undefined && r.type && !y.isNever(r.type)) {
                    return x(e, y.UnknownType.create(), false);
                  }
                  if (r.isIncomplete) {
                    n = true;
                  }
                  if (r.type) {
                    t.push(r.type);
                  }
                }
                return x(e, t.length > 0 ? y.combineTypes(t) : undefined, n);
              }
              function j(e, t) {
                var n;
                const a = e.antecedents.length;
                if (t === undefined) {
                  t = x(e, o ? undefined : y.UnknownType.create(), true);
                } else {
                  if (t.incompleteSubtypes && t.incompleteSubtypes.length === e.antecedents.length && t.incompleteSubtypes.some(e => e.isPending)) {
                    return h.create(U(t), true);
                  }
                }
                let s = 0;
                while (true) {
                  let i = false;
                  let l = false;
                  let p = o === undefined && ((n = t.incompleteSubtypes) === null || n === undefined ? undefined : n.some(e => e.type !== undefined));
                  let d = false;
                  let c = false;
                  e.antecedents.forEach((n, a) => {
                    var r;
                    var s;
                    if (o === undefined && p) {
                      return;
                    }
                    if (c && a > 0) {
                      return;
                    }
                    if ((t = E(e)).incompleteSubtypes && a < t.incompleteSubtypes.length && t.incompleteSubtypes[a].isPending) {
                      if (a !== 0) {
                        i = true;
                        l = true;
                        return;
                      }
                      c = true;
                    }
                    const u = t.incompleteSubtypes !== undefined && a < t.incompleteSubtypes.length ? t.incompleteSubtypes[a] : undefined;
                    if (u === undefined || !(u == null ? undefined : u.isPending) && (u == null ? undefined : u.isIncomplete)) {
                      const o = u === undefined ? 0 : u.evaluationCount;
                      if (o >= _) {
                        if (!P && C) {
                          console.log('Types failed to converge during code flow analysis');
                        }
                        P = true;
                        return;
                      }
                      t = N(e, a, (r = u == null ? undefined : u.type) !== null && r !== undefined ? r : y.UnknownType.create(true), true, true, o);
                      try {
                        const r = L(n);
                        if (r.isIncomplete) {
                          i = true;
                          if (a === 0) {
                            d = true;
                          }
                        }
                        t = N(e, a, (s = r.type) !== null && s !== undefined ? s : r.isIncomplete ? y.UnknownType.create(true) : y.NeverType.createNever(), r.isIncomplete, c, o + 1);
                      } catch (n) {
                        t = N(e, a, y.UnknownType.create(true), true, c, o + 1);
                        throw n;
                      }
                    }
                    if (o === undefined && (t == null ? undefined : t.type) !== undefined) {
                      p = true;
                    }
                  });
                  if (p) {
                    if (l) {
                      return h.create(y.UnknownType.create(), false);
                    } else {
                      return x(e, y.UnknownType.create(), false);
                    }
                  }
                  let u = t.type;
                  if (i && u) {
                    const e = g.cleanIncompleteUnknown(u);
                    if (e !== u) {
                      u = e;
                    }
                  }
                  if (!i || s >= a) {
                    let t = i;
                    if (!!i && !l && !r(w) && !!u && !g.isIncompleteUnknown(u) && !d) {
                      t = false;
                    }
                    if (l || i) {
                      if (!t) {
                        S++;
                      }
                      return h.create(u, t);
                    } else {
                      if (c) {
                        return h.create(u, true);
                      } else {
                        return x(e, u, false);
                      }
                    }
                  }
                  s++;
                }
              }
              function q(e) {
                if (A.closedFinallyGateNodes.has(e.id)) {
                  return h.create(undefined, false);
                }
                const t = L(e.antecedent);
                (function (e) {
                  A.cache.delete(e.id);
                })(e);
                return h.create(t.type, t.isIncomplete);
              }
              function G(t) {
                const n = A.closedFinallyGateNodes.has(t.preFinallyGate.id);
                try {
                  let n;
                  A.closedFinallyGateNodes.add(t.preFinallyGate.id);
                  e.useSpeculativeMode(t.finallyNode, () => {
                    n = L(t.antecedent);
                  });
                  if (n.isIncomplete) {
                    return n;
                  } else {
                    return x(t, n.type, false);
                  }
                } finally {
                  if (!n) {
                    A.closedFinallyGateNodes.delete(t.preFinallyGate.id);
                  }
                }
              }
              if (s) {
                return L(s);
              } else {
                return h.create((v = l == null ? undefined : l.typeAtStart) === null || v === undefined ? undefined : v.type, !!((b = l == null ? undefined : l.typeAtStart) === null || b === undefined ? undefined : b.isIncomplete));
              }
            }
          };
        },
        getFlowNodeReachability: D,
        narrowConstrainedTypeVar: function (t, n) {
          a.assert(!y.isParamSpec(n));
          a.assert(!y.isTypeVarTuple(n));
          a.assert(!y.TypeVarType.hasBound(n));
          a.assert(y.TypeVarType.hasConstraints(n));
          const r = new Set();
          const s = [];
          for (const e of n.shared.constraints) {
            if (!y.isClassInstance(e)) {
              return;
            }
            s.push(e);
          }
          const o = function t(n, o) {
            let l = n;
            while (true) {
              if (r.has(l.id)) {
                return s;
              }
              if (l.flags & (i.FlowFlags.Unreachable | i.FlowFlags.Start)) {
                return s;
              }
              if (l.flags & (i.FlowFlags.VariableAnnotation | i.FlowFlags.Assignment | i.FlowFlags.WildcardImport | i.FlowFlags.TrueNeverCondition | i.FlowFlags.FalseNeverCondition | i.FlowFlags.ExhaustedMatch | i.FlowFlags.PostFinally | i.FlowFlags.PreFinallyGate | i.FlowFlags.Call)) {
                l = l.antecedent;
              } else {
                if (l.flags & i.FlowFlags.NarrowForPattern) {
                  const n = l;
                  if (n.statement.nodeType === 64 && N(e.getTypeOfExpression(n.subjectExpression).type, o)) {
                    const a = n.statement.d.pattern;
                    if (a.nodeType === 66 && a.d.orPatterns.length === 1 && a.d.orPatterns[0].nodeType === 68) {
                      const r = a.d.orPatterns[0];
                      const s = e.getTypeOfExpression(r.d.className, 2).type;
                      if (y.isInstantiableClass(s)) {
                        return t(n.antecedent, o).filter(e => y.ClassType.isSameGenericClass(e, y.ClassType.cloneAsInstance(s)));
                      }
                    }
                  }
                  l = n.antecedent;
                } else {
                  if (!(l.flags & (i.FlowFlags.TrueCondition | i.FlowFlags.FalseCondition))) {
                    if (l.flags & (i.FlowFlags.BranchLabel | i.FlowFlags.LoopLabel)) {
                      const e = l;
                      const n = [];
                      r.add(l.id);
                      for (const a of e.antecedents) {
                        const e = t(a, o);
                        for (const t of e) {
                          if (!n.some(e => y.isTypeSame(e, t))) {
                            n.push(t);
                          }
                        }
                      }
                      r.delete(l.id);
                      return n;
                    }
                    a.fail('Unexpected flow node flags');
                    return s;
                  }
                  {
                    const n = l;
                    const a = n.expression;
                    const s = !!(l.flags & i.FlowFlags.TrueCondition);
                    if (a.nodeType === 9 && a.d.leftExpr.nodeType === 38 && a.d.leftExpr.d.value === 'isinstance' && a.d.args.length === 2) {
                      const i = a.d.args[0].d.valueExpr;
                      if (N(e.getTypeOfExpression(i).type, o)) {
                        r.add(l.id);
                        const i = t(n.antecedent, o);
                        r.delete(l.id);
                        const p = a.d.args[1].d.valueExpr;
                        const d = e.getTypeOfExpression(p, 634).type;
                        if (y.isInstantiableClass(d)) {
                          return i.filter(e => y.ClassType.isSameGenericClass(e, y.ClassType.cloneAsInstance(d)) ? s : !s);
                        }
                      }
                    }
                    l = n.antecedent;
                  }
                }
              }
            }
          }(t, n);
          if (o.length === 1) {
            return o[0];
          } else {
            return undefined;
          }
        },
        printControlFlowGraph: z
      };
    };
    const a = require(48281);
    const r = require(56814);
    const s = require(26687);
    const i = require(50299);
    const o = require(20175);
    const l = require(20516);
    const p = require(41557);
    const d = require(69932);
    const c = require(66308);
    const u = require(83055);
    const m = require(18891);
    const y = require(21024);
    const g = require(92324);
    var h;
    function f(e) {
      return !!e.isIncompleteType;
    }
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          type: e,
          isIncomplete: t,
          generationCount: n,
          incompleteSubtypes: a
        };
      };
    })(h || (exports.FlowNodeTypeResult = h = {}));
    const T = false;
    const v = false;
    const b = false;
    const _ = 256;
    const C = false;
  },
  50299: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.wildcardImportReferenceKey = exports.FlowFlags = undefined;
    exports.getUniqueFlowNodeId = function () {
      return s++;
    };
    exports.isCodeFlowSupportedForReference = function e(t) {
      if (t.nodeType === 38) {
        return true;
      }
      if (t.nodeType === 35) {
        return e(t.d.leftExpr);
      }
      if (t.nodeType === 27) {
        if (t.d.items.length !== 1 || t.d.trailingComma || t.d.items[0].d.name !== undefined || t.d.items[0].d.argCategory !== 0) {
          return false;
        }
        const n = t.d.items[0].d.valueExpr;
        const a = n.nodeType === 40 && !n.d.isImaginary && n.d.isInteger;
        const r = n.nodeType === 55 && n.d.operator === 33 && n.d.expr.nodeType === 40 && !n.d.expr.d.isImaginary && n.d.expr.d.isInteger;
        const s = n.nodeType === 48 && n.d.strings.length === 1 && n.d.strings[0].nodeType === 49;
        return (!!a || !!r || !!s) && e(t.d.leftExpr);
      }
      return false;
    };
    exports.createKeyForReference = i;
    exports.createKeysForReferenceSubexpressions = function e(t) {
      if (t.nodeType === 38) {
        return [i(t)];
      }
      if (t.nodeType === 35) {
        return [...e(t.d.leftExpr), i(t)];
      }
      if (t.nodeType === 27) {
        return [...e(t.d.leftExpr), i(t)];
      }
      a.fail('createKeyForReference received unexpected expression type');
    };
    const a = require(48281);
    var r;
    (function (e) {
      e[e.Unreachable = 1] = 'Unreachable';
      e[e.Start = 2] = 'Start';
      e[e.BranchLabel = 4] = 'BranchLabel';
      e[e.LoopLabel = 8] = 'LoopLabel';
      e[e.Assignment = 16] = 'Assignment';
      e[e.Unbind = 32] = 'Unbind';
      e[e.WildcardImport = 64] = 'WildcardImport';
      e[e.TrueCondition = 128] = 'TrueCondition';
      e[e.FalseCondition = 512] = 'FalseCondition';
      e[e.Call = 1024] = 'Call';
      e[e.PreFinallyGate = 2048] = 'PreFinallyGate';
      e[e.PostFinally = 4096] = 'PostFinally';
      e[e.VariableAnnotation = 16384] = 'VariableAnnotation';
      e[e.PostContextManager = 32768] = 'PostContextManager';
      e[e.TrueNeverCondition = 65536] = 'TrueNeverCondition';
      e[e.FalseNeverCondition = 131072] = 'FalseNeverCondition';
      e[e.NarrowForPattern = 262144] = 'NarrowForPattern';
      e[e.ExhaustedMatch = 524288] = 'ExhaustedMatch';
    })(r || (exports.FlowFlags = r = {}));
    let s = 1;
    function i(e) {
      let t;
      if (e.nodeType === 38) {
        t = e.d.value;
      } else {
        if (e.nodeType === 35) {
          t = `${i(e.d.leftExpr)}.${e.d.member.d.value}`;
        } else {
          if (e.nodeType === 27) {
            const n = i(e.d.leftExpr);
            a.assert(e.d.items.length === 1);
            const r = e.d.items[0].d.valueExpr;
            if (r.nodeType === 40) {
              t = `${n}[${r.d.value.toString()}]`;
            } else {
              if (r.nodeType === 48) {
                const e = r;
                a.assert(e.d.strings.length === 1 && e.d.strings[0].nodeType === 49);
                t = `${n}["${e.d.strings[0].d.value}"]`;
              } else {
                if (r.nodeType === 55 && r.d.operator === 33 && r.d.expr.nodeType === 40) {
                  t = `${n}[-${r.d.expr.d.value.toString()}]`;
                } else {
                  a.fail('createKeyForReference received unexpected index type');
                }
              }
            }
          } else {
            a.fail('createKeyForReference received unexpected expression type');
          }
        }
      }
      return t;
    }
    exports.wildcardImportReferenceKey = '*';
  },
  20175: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.formatControlFlowGraph = function (e) {
      const t = Object.create(null);
      const n = [];
      const i = [];
      const o = c(e, new Set());
      for (const e of n) {
        e.text = g(e.flowNode, e.circular);
        m(e);
      }
      const l = function (e) {
        const t = f(Array(e), 0);
        for (const e of n) {
          t[e.level] = Math.max(t[e.level], e.text.length);
        }
        return t;
      }(function e(t) {
        let n = 0;
        for (const a of p(t)) {
          n = Math.max(n, e(a));
        }
        return n + 1;
      }(o));
      (function e(t, n) {
        if (t.lane === -1) {
          t.lane = n;
          t.endLane = n;
          const a = p(t);
          for (let r = 0; r < a.length; r++) {
            if (r > 0) {
              n++;
            }
            const s = a[r];
            e(s, n);
            if (s.endLane > t.endLane) {
              n = s.endLane;
            }
          }
          t.endLane = n;
        }
      })(o, 0);
      return function () {
        const e = l.length;
        const t = n.reduce((e, t) => Math.max(e, t.lane), 0) + 1;
        const a = f(Array(t), '');
        const r = l.map(() => Array(t));
        const s = l.map(() => f(Array(t), 0));
        for (const e of n) {
          r[e.level][e.lane] = e;
          const t = p(e);
          for (let n = 0; n < t.length; n++) {
            const a = t[n];
            let r = 8;
            if (a.lane === e.lane) {
              r |= 4;
            }
            if (n > 0) {
              r |= 1;
            }
            if (n < t.length - 1) {
              r |= 2;
            }
            s[e.level][a.lane] |= r;
          }
          if (t.length === 0) {
            s[e.level][e.lane] |= 16;
          }
          const n = d(e);
          for (let t = 0; t < n.length; t++) {
            const a = n[t];
            let r = 4;
            if (t > 0) {
              r |= 1;
            }
            if (t < n.length - 1) {
              r |= 2;
            }
            s[e.level - 1][a.lane] |= r;
          }
        }
        for (let n = 0; n < e; n++) {
          for (let e = 0; e < t; e++) {
            const t = n > 0 ? s[n - 1][e] : 0;
            const a = e > 0 ? s[n][e - 1] : 0;
            let r = s[n][e];
            if (!r) {
              r = 0;
              if (t & 8) {
                r |= 12;
              }
              if (a & 2) {
                r |= 3;
              }
              s[n][e] = r;
            }
          }
        }
        for (let t = 0; t < e; t++) {
          for (let n = 0; n < a.length; n++) {
            const a = s[t][n];
            const o = a & 4 ? '' : ' ';
            const p = r[t][n];
            if (p) {
              i(n, p.text);
              if (t < e - 1) {
                i(n, ' ');
                i(n, T(o, l[t] - p.text.length));
              }
            } else {
              if (t < e - 1) {
                i(n, T(o, l[t] + 1));
              }
            }
            i(n, h(a));
            i(n, a & 8 && t < e - 1 && !r[t + 1][n] ? '' : ' ');
          }
        }
        return `${a.join('\n')}\n`;
        function i(e, t) {
          a[e] += t;
        }
      }();
      function p(e) {
        const t = [];
        for (const n of e.edges) {
          if (n.source === e) {
            t.push(n.target);
          }
        }
        return t;
      }
      function d(e) {
        const t = [];
        for (const n of e.edges) {
          if (n.target === e) {
            t.push(n.source);
          }
        }
        return t;
      }
      function c(e, a) {
        const r = e.id;
        let i = t[r];
        if (i && a.has(e)) {
          i = {
            id: -1,
            flowNode: e,
            edges: [],
            text: '',
            lane: -1,
            endLane: -1,
            level: -1,
            circular: true
          };
          n.push(i);
          return i;
        }
        a.add(e);
        if (!i) {
          t[r] = i = {
            id: r,
            flowNode: e,
            edges: [],
            text: '',
            lane: -1,
            endLane: -1,
            level: -1,
            circular: false
          };
          n.push(i);
          const o = function (e) {
            if (e.flags & (s.FlowFlags.LoopLabel | s.FlowFlags.BranchLabel)) {
              return e.antecedents;
            }
            if (e.flags & (s.FlowFlags.Assignment | s.FlowFlags.VariableAnnotation | s.FlowFlags.WildcardImport | s.FlowFlags.TrueCondition | s.FlowFlags.FalseCondition | s.FlowFlags.TrueNeverCondition | s.FlowFlags.FalseNeverCondition | s.FlowFlags.NarrowForPattern | s.FlowFlags.ExhaustedMatch | s.FlowFlags.Call | s.FlowFlags.PreFinallyGate | s.FlowFlags.PostFinally)) {
              return [e.antecedent];
            }
            return [];
          }(e);
          for (const e of o) {
            u(i, e, a);
          }
        }
        a.delete(e);
        return i;
      }
      function u(e, t, n) {
        const a = c(t, n);
        const r = {
          source: e,
          target: a
        };
        i.push(r);
        e.edges.push(r);
        a.edges.push(r);
      }
      function m(e) {
        if (e.level !== -1) {
          return e.level;
        }
        let t = 0;
        for (const n of d(e)) {
          t = Math.max(t, m(n) + 1);
        }
        return e.level = t;
      }
      function y(e) {
        const t = function (e) {
          if (e.flags & s.FlowFlags.Assignment || e.flags & s.FlowFlags.WildcardImport) {
            return e.node;
          } else {
            if (e.flags & (s.FlowFlags.TrueCondition | s.FlowFlags.FalseCondition)) {
              return e.expression;
            } else {
              if (e.flags & s.FlowFlags.NarrowForPattern) {
                return e.statement;
              } else {
                if (e.flags & s.FlowFlags.Call) {
                  return e.node;
                } else {
                  return undefined;
                }
              }
            }
          }
        }(e);
        if (!t) {
          return;
        }
        const n = r.getFileInfo(t);
        const i = a.convertOffsetToPosition(t.start, n.lines);
        return `[${i.line + 1}:${i.character + 1}]`;
      }
      function g(e, t) {
        const n = `${function (e) {
          if (e & s.FlowFlags.Start) {
            return 'Start';
          }
          if (e & s.FlowFlags.BranchLabel) {
            return 'Branch';
          }
          if (e & s.FlowFlags.LoopLabel) {
            return 'Loop';
          }
          if (e & s.FlowFlags.Unbind) {
            return 'Unbind';
          }
          if (e & s.FlowFlags.Assignment) {
            return 'Assign';
          }
          if (e & s.FlowFlags.TrueCondition) {
            return 'True';
          }
          if (e & s.FlowFlags.FalseCondition) {
            return 'False';
          }
          if (e & s.FlowFlags.Call) {
            return 'Call';
          }
          if (e & s.FlowFlags.Unreachable) {
            return 'Unreachable';
          }
          if (e & s.FlowFlags.WildcardImport) {
            return 'Wildcard';
          }
          if (e & s.FlowFlags.PreFinallyGate) {
            return 'PreFinal';
          }
          if (e & s.FlowFlags.PostFinally) {
            return 'PostFinal';
          }
          if (e & s.FlowFlags.VariableAnnotation) {
            return 'Annotate';
          }
          if (e & s.FlowFlags.TrueNeverCondition) {
            return 'TrueNever';
          }
          if (e & s.FlowFlags.FalseNeverCondition) {
            return 'FalseNever';
          }
          if (e & s.FlowFlags.NarrowForPattern) {
            return 'Pattern';
          }
          if (e & s.FlowFlags.ExhaustedMatch) {
            return 'Exhaust';
          }
          throw new Error();
        }(e.flags)}@${e.id}${y(e) || ''}`;
        if (t) {
          return `Circular(${n})`;
        } else {
          return n;
        }
      }
      function h(e) {
        switch (e) {
          case 3:
            return '';
          case 12:
            return '';
          case 5:
            return '';
          case 9:
            return '';
          case 6:
            return '';
          case 10:
            return '';
          case 7:
            return '';
          case 11:
            return '';
          case 13:
            return '';
          case 14:
            return '';
          case 15:
            return '';
        }
        return ' ';
      }
      function f(e, t) {
        if (e.fill) {
          e.fill(t);
        } else {
          for (let n = 0; n < e.length; n++) {
            e[n] = t;
          }
        }
        return e;
      }
      function T(e, t) {
        if (e.repeat) {
          if (t > 0) {
            return e.repeat(t);
          } else {
            return '';
          }
        }
        let n = '';
        while (n.length < t) {
          n += e;
        }
        return n;
      }
    };
    const a = require(56814);
    const r = require(26687);
    const s = require(50299);
  },
  22415: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getFileLevelDirectives = function (e, t, n, r, s) {
      let o = a.cloneDiagnosticRuleSet(n);
      if (r) {
        c(o);
      }
      for (let n = 0; n < e.count; n++) {
        const a = e.getItemAt(n);
        if (a.comments) {
          for (const e of a.comments) {
            const [n, a] = g(e.value, {
              start: e.start,
              length: e.length
            });
            o = m(n, a, () => i.convertOffsetToPosition(e.start, t).character <= 1, o, s);
          }
        }
      }
      return o;
    };
    const a = require(12522);
    const r = require(48281);
    const s = require(11479);
    const i = require(56814);
    const o = require(67703);
    const l = 'strict';
    const p = 'standard';
    const d = 'basic';
    function c(e) {
      (function (e, t, n) {
        const r = a.getBooleanDiagnosticRules();
        const s = a.getDiagLevelDiagnosticRules();
        for (const a of r) {
          if (!n.find(e => e === a)) {
            if (t[a]) {
              e[a] = true;
            }
          }
        }
        for (const a of s) {
          if (n.find(e => e === a)) {
            continue;
          }
          const r = t[a];
          const s = e[a];
          if (r === 'error' || r === 'warning' && s !== 'error' || r === 'information' && s !== 'error' && s !== 'warning') {
            e[a] = r;
          }
        }
      })(e, a.getStrictDiagnosticRuleSet(), a.getStrictModeNotOverriddenRules());
    }
    function u(e, t) {
      const n = a.getBooleanDiagnosticRules();
      const r = a.getDiagLevelDiagnosticRules();
      for (const a of n) {
        e[a] = t[a];
      }
      for (const n of r) {
        e[n] = t[n];
      }
    }
    function m(e, t, n, r, i) {
      const m = 'pyright:';
      if (e.startsWith(m)) {
        const m = e.substring(8);
        if (m.trim().startsWith('ignore')) {
          return r;
        }
        if (!n()) {
          const e = new s.DiagnosticAddendum();
          e.addMessage(o.LocAddendum.pyrightCommentIgnoreTip());
          const n = {
            message: o.LocMessage.pyrightCommentNotOnOwnLine() + e.getString(),
            range: t
          };
          i.push(n);
        }
        const h = m.split(',');
        if (h.some(e => e.trim() === l)) {
          c(r);
        } else {
          if (h.some(e => e.trim() === p)) {
            (function (e) {
              u(e, a.getStandardDiagnosticRuleSet());
            })(r);
          } else {
            if (h.some(e => e.trim() === d)) {
              (function (e) {
                u(e, a.getBasicDiagnosticRuleSet());
              })(r);
            }
          }
        }
        let f = 0;
        for (const e of h) {
          const [n, a] = g(e, {
            start: t.start + 8 + f,
            length: e.length
          });
          r = y(n, a, r, i);
          f += e.length + 1;
        }
      }
      return r;
    }
    function y(e, t, n, r) {
      const s = e.split('=');
      const [i, c] = g(s[0], {
        start: t.start,
        length: s[0].length
      });
      if (s.length === 1 && i && [l, p, d].some(e => i === e)) {
        return n;
      }
      const u = a.getDiagLevelDiagnosticRules();
      const m = a.getBooleanDiagnosticRules();
      const y = s.length > 0 ? s.slice(1).join('=') : '';
      const [h, f] = g(y, {
        start: t.start + s[0].length + 1,
        length: y.length
      });
      if (u.find(e => e === i)) {
        const e = function (e) {
          switch (e) {
            case 'false':
            case 'none':
              return 'none';
            case 'true':
            case 'error':
              return 'error';
            case 'warning':
              return 'warning';
            case 'information':
              return 'information';
            default:
              return;
          }
        }(h);
        if (e !== undefined) {
          n[i] = e;
        } else {
          const e = {
            message: o.LocMessage.pyrightCommentInvalidDiagnosticSeverityValue(),
            range: h ? f : c
          };
          r.push(e);
        }
      } else {
        if (m.find(e => e === i)) {
          const e = function (e) {
            if (e === 'false') {
              return false;
            }
            if (e === 'true') {
              return true;
            }
            return;
          }(h);
          if (e !== undefined) {
            n[i] = e;
          } else {
            const e = {
              message: o.LocMessage.pyrightCommentInvalidDiagnosticBoolValue(),
              range: h ? f : c
            };
            r.push(e);
          }
        } else {
          if (i) {
            const e = {
              message: h ? o.LocMessage.pyrightCommentUnknownDiagnosticRule().format({
                rule: i
              }) : o.LocMessage.pyrightCommentUnknownDirective().format({
                directive: i
              }),
              range: c
            };
            r.push(e);
          } else {
            const e = {
              message: o.LocMessage.pyrightCommentMissingDirective(),
              range: c
            };
            r.push(e);
          }
        }
      }
      return n;
    }
    function g(e, t) {
      r.assert(e.length === t.length);
      const n = e.trimStart();
      let a = t;
      if (n !== e) {
        const t = e.length - n.length;
        a = {
          start: a.start + t,
          length: a.length - t
        };
      }
      const s = n.trimEnd();
      if (s !== n) {
        a = {
          start: a.start,
          length: a.length - n.length + s.length
        };
      }
      r.assert(s.length === a.length);
      return [s, a];
    }
  },
  70617: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ConstraintSolution = exports.ConstraintSolutionSet = undefined;
    const a = require(48281);
    const r = require(21024);
    class s {
      constructor() {
        this._typeVarMap = new Map();
      }
      isEmpty() {
        return this._typeVarMap.size === 0;
      }
      getType(e) {
        const t = r.TypeVarType.getNameWithScope(e);
        return this._typeVarMap.get(t);
      }
      setType(e, t) {
        const n = r.TypeVarType.getNameWithScope(e);
        return this._typeVarMap.set(n, t);
      }
      hasType(e) {
        const t = r.TypeVarType.getNameWithScope(e);
        return this._typeVarMap.has(t);
      }
      doForEachTypeVar(e) {
        this._typeVarMap.forEach((t, n) => {
          if (t) {
            e(t, n);
          }
        });
      }
    }
    exports.ConstraintSolutionSet = s;
    exports.ConstraintSolution = class {
      constructor(e) {
        this._solutionSets = e && e.length > 0 ? [...e] : [new s()];
      }
      isEmpty() {
        return this._solutionSets.every(e => e.isEmpty());
      }
      setType(e, t) {
        return this._solutionSets.forEach(n => {
          n.setType(e, t);
        });
      }
      getMainSolutionSet() {
        return this.getSolutionSet(0);
      }
      getSolutionSets() {
        return this._solutionSets;
      }
      doForEachSolutionSet(e) {
        this.getSolutionSets().forEach((t, n) => {
          e(t, n);
        });
      }
      getSolutionSet(e) {
        a.assert(e >= 0 && e < this._solutionSets.length);
        return this._solutionSets[e];
      }
    };
  },
  10081: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.assignTypeVar = u;
    exports.solveConstraints = function (e, t, n) {
      const a = [];
      t.doForEachConstraintSet(t => {
        const r = m(e, t, n);
        a.push(r);
      });
      return new s.ConstraintSolution(a);
    };
    exports.applySourceSolutionToConstraints = function (e, t) {
      if (t.isEmpty()) {
        return;
      }
      e.doForEachConstraintSet(e => {
        e.getTypeVars().forEach(n => {
          e.setBounds(n.typeVar, n.lowerBound ? p.applySolvedTypeVars(n.lowerBound, t) : undefined, n.upperBound ? p.applySolvedTypeVars(n.upperBound, t) : undefined, n.retainLiterals);
        });
      });
    };
    exports.solveConstraintSet = m;
    exports.addConstraintsForExpectedType = function (e, t, n, a, r, s = undefined) {
      if (l.isAny(n)) {
        t.shared.typeParams.forEach(e => {
          a.setBounds(e, n, n);
        });
        return true;
      }
      if (l.isTypeVar(n) && l.TypeVarType.isSelf(n) && n.shared.boundType) {
        n = n.shared.boundType;
      }
      if (!l.isClass(n)) {
        return false;
      }
      const o = n.priv.typeArgs;
      if (!o) {
        return e.assignType(t, n, undefined, a, 2048);
      }
      e.inferVarianceForClass(t);
      if (l.ClassType.isSameGenericClass(n, t)) {
        const e = p.buildSolutionFromSpecializedClass(n);
        l.ClassType.getTypeParams(n).forEach(t => {
          let n = e.getMainSolutionSet().getType(t);
          if (n && r) {
            n = p.transformExpectedType(n, r, s);
          }
          if (n) {
            const e = l.TypeVarType.getVariance(t);
            a.setBounds(t, e === 3 ? undefined : n, e === 4 ? undefined : n);
          }
        });
        return true;
      }
      const d = p.getTypeVarScopeId(n);
      const c = l.ClassType.getTypeParams(n).map((e, t) => {
        const n = l.TypeVarType.createInstance(`__dest${t}`, l.isParamSpec(e) ? l.TypeVarKind.ParamSpec : l.TypeVarKind.TypeVar);
        n.shared.isSynthesized = true;
        n.shared.declaredVariance = 2;
        n.priv.scopeId = d;
        return n;
      });
      const m = l.ClassType.specialize(n, c);
      const y = l.ClassType.getTypeParams(t).map((e, t) => {
        const n = l.TypeVarType.createInstance(`__source${t}`, l.isParamSpec(e) ? l.TypeVarKind.ParamSpec : l.TypeVarKind.TypeVar);
        n.shared.isSynthesized = true;
        n.shared.synthesizedIndex = t;
        n.shared.isExemptFromBoundCheck = true;
        return l.TypeVarType.cloneAsUnificationVar(n);
      });
      const g = l.ClassType.specialize(t, y);
      const f = new i.ConstraintTracker();
      if (e.assignType(m, g, undefined, f, 2048)) {
        let t = true;
        c.forEach((n, i) => {
          let d = h(e, f.getMainConstraintSet(), n);
          const c = [];
          if (d && (l.isParamSpec(n) && l.isFunction(d) && (d = p.simplifyFunctionToParamSpec(d)), l.isUnion(d))) {
            let e;
            p.sortTypes(d.priv.subtypes).forEach(t => {
              if (l.isTypeVar(t) && t.shared.isSynthesized && t.shared.synthesizedIndex !== undefined && !e) {
                e = t;
              } else {
                c.push(t);
              }
            });
            if (e) {
              d = e;
            }
          }
          if (d && l.isTypeVar(d) && d.shared.isSynthesized && d.shared.synthesizedIndex !== undefined) {
            const n = l.ClassType.getTypeParams(g)[d.shared.synthesizedIndex];
            if (i < o.length) {
              let d = p.transformPossibleRecursiveTypeAlias(o[i]);
              if (c.length > 0) {
                d = l.combineTypes([d, ...c]);
              }
              if (r) {
                d = p.transformExpectedType(d, r, s);
              }
              if (!d || !u(e, n, d, undefined, a, 256)) {
                t = false;
              }
            }
          }
        });
        return t;
      }
      return false;
    };
    const a = require(11479);
    const r = require(67703);
    const s = require(70617);
    const i = require(86672);
    const o = require(83055);
    const l = require(21024);
    const p = require(92324);
    const d = 64;
    const c = false;
    function u(e, t, n, s, i, u = 0, m = 0) {
      let y;
      if (c) {
        const a = ' '.repeat(m * 2);
        console.log(`${a}`);
        console.log(`${a}assignTypeVar called with`);
        console.log(`${a}destType: ${e.printType(t)}`);
        console.log(`${a}srcType: ${e.printType(n)}`);
        console.log(`${a}flags: ${u}`);
        if (i) {
          T(e, i, a);
        }
      }
      if (l.isUnpacked(t) && l.isUnpacked(n)) {
        t = l.TypeVarType.cloneForPacked(t);
        n = p.makePacked(n);
      }
      if (!t.priv.scopeId) {
        return true;
      }
      if (l.TypeVarType.isBound(t) && !l.TypeVarType.isUnification(t)) {
        return function (e, t, n, a, s) {
          if (l.isAnyOrUnknown(n) || l.isClass(n) && l.ClassType.derivesFromAnyOrUnknown(n)) {
            return true;
          }
          if (l.isParamSpec(t) && l.isFunction(n) && l.FunctionType.isGradualCallableForm(n)) {
            return true;
          }
          const i = !!(s & 1);
          if (l.isNever(n) && !i) {
            return true;
          }
          if (l.isClassInstance(n) && l.ClassType.isBuiltIn(n, 'type') && (!n.priv.typeArgs || n.priv.typeArgs.length < 1 || l.isAnyOrUnknown(n.priv.typeArgs[0])) && l.TypeBase.isInstantiable(t)) {
            return true;
          }
          if ((!t.shared.isSynthesized || !!l.TypeVarType.isSelf(t)) && a != null) {
            a.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(n, t)));
          }
          return false;
        }(e, t, n, s, u);
      }
      if (l.TypeBase.isInstantiable(t) && l.isInstantiableClass(n) && e.isSpecialFormClass(n, u)) {
        return false;
      }
      if (l.isTypeSame(t, n)) {
        return true;
      }
      if (l.isParamSpec(t)) {
        y = function (e, t, n, a, s, i = 0) {
          if (!s) {
            return true;
          }
          let o = true;
          let d = l.isParamSpec(n) ? n : p.convertTypeToParamSpecValue(n);
          if (l.isFunction(d)) {
            d = p.simplifyFunctionToParamSpec(d);
          }
          s.doForEachConstraintSet(n => {
            var s;
            var c;
            if (l.isParamSpec(d)) {
              const e = (s = n.getTypeVar(t)) === null || s === undefined ? undefined : s.lowerBound;
              if (!e) {
                n.setBounds(t, d);
                return;
              }
              {
                const t = p.convertTypeToParamSpecValue(e);
                const n = l.FunctionType.getParamSpecFromArgsKwargs(t);
                if (l.FunctionType.cloneRemoveParamSpecArgsKwargs(t).shared.parameters.length === 0 && n && l.isTypeSame(n, d, {}, i)) {
                  return;
                }
              }
            } else {
              if (l.isFunction(d)) {
                const a = d;
                let r = false;
                const s = (c = n.getTypeVar(t)) === null || c === undefined ? undefined : c.lowerBound;
                if (s) {
                  const t = p.simplifyFunctionToParamSpec(p.convertTypeToParamSpecValue(s));
                  const n = e.assignType(t, a, undefined, undefined, 64, i);
                  const o = e.assignType(a, t, undefined, undefined, 64, i);
                  if (n && o) {
                    if (l.FunctionType.isGradualCallableForm(a)) {
                      return;
                    }
                    r = true;
                  } else {
                    if (o) {
                      r = true;
                    } else {
                      if (n) {
                        return;
                      }
                    }
                  }
                } else {
                  r = true;
                }
                if (r) {
                  n.setBounds(t, a);
                  return;
                }
              } else {
                if (l.isAnyOrUnknown(d)) {
                  return;
                }
              }
            }
            if (a != null) {
              a.addMessage(r.LocAddendum.typeParamSpec().format({
                type: e.printType(d),
                name: t.shared.name
              }));
            }
            o = false;
          });
          return o;
        }(e, t, n, s, i, m);
      } else {
        if (l.isTypeVarTuple(t) && !t.priv.isInUnion) {
          if (t.priv.isUnpacked) {
            const t = e.getTupleClassType();
            if (!l.isUnpacked(n) && t) {
              n = p.convertToInstance(p.specializeTupleClass(t, [{
                type: n,
                isUnbounded: false
              }], true, true));
            }
          } else {
            n = p.makeUnpacked(n);
          }
        }
        if (l.isTypeVarTuple(n) && n.priv.isUnpacked && !n.priv.isInUnion && !l.isTypeVarTuple(t)) {
          n = l.TypeVarType.cloneForUnpacked(n, true);
        }
        y = l.TypeVarType.hasConstraints(t) ? function (e, t, n, a, s, i, o) {
          let d;
          const c = e.makeTopLevelTypeVarsConcrete(n);
          const u = s == null ? undefined : s.getMainConstraintSet().getTypeVar(t);
          const m = u == null ? undefined : u.upperBound;
          const y = u == null ? undefined : u.lowerBound;
          let g = false;
          if (l.isTypeVar(n)) {
            if (e.assignType(t, c, undefined, undefined, 0, o)) {
              d = n;
              if (l.TypeBase.isInstantiable(n)) {
                d = p.convertToInstance(n, false);
              }
            }
          } else {
            let n;
            let a = true;
            d = p.mapSubtypes(c, r => {
              let s;
              let d;
              if (l.isAnyOrUnknown(r)) {
                return r;
              } else {
                t.shared.constraints.forEach((n, a) => {
                  const i = l.TypeBase.isInstantiable(t) ? p.convertToInstantiable(n) : n;
                  if (e.assignType(i, r, undefined, undefined, 0, o)) {
                    if (!s || !!e.assignType(l.TypeBase.isInstantiable(t) ? p.convertToInstantiable(s) : s, i, undefined, undefined, 0, o)) {
                      s = p.addConditionToType(n, p.getTypeCondition(r));
                      d = a;
                    }
                  }
                });
                if (!s && !(i & 2)) {
                  a = false;
                }
                if (d !== undefined && !p.getTypeCondition(r)) {
                  if (n !== undefined && n !== d) {
                    a = false;
                  }
                  n = d;
                }
                return s;
              }
            });
            if (!!l.isNever(d) || !a) {
              d = undefined;
            }
            if (!d && l.isUnion(c)) {
              d = t.shared.constraints.find(n => {
                const a = l.TypeBase.isInstantiable(t) ? p.convertToInstantiable(n) : n;
                return e.assignType(a, c, undefined, undefined, 0, o);
              });
            }
          }
          if (!d) {
            if (a != null) {
              a.addMessage(r.LocAddendum.typeConstrainedTypeVar().format({
                type: e.printType(n),
                name: t.shared.name
              }));
            }
            return false;
          }
          if (p.isLiteralTypeOrUnion(d)) {
            g = true;
          }
          if (y && !l.isAnyOrUnknown(y)) {
            if (!e.assignType(y, d, undefined, undefined, 0, o)) {
              if (!e.assignType(d, y, undefined, undefined, 0, o)) {
                if (a != null) {
                  a.addMessage(r.LocAddendum.typeConstrainedTypeVar().format({
                    type: e.printType(d),
                    name: e.printType(y)
                  }));
                }
                return false;
              }
              if (s != null) {
                s.setBounds(t, d, m);
              }
            }
          } else {
            if (s != null) {
              s.setBounds(t, d, m, g);
            }
          }
          return true;
        }(e, t, n, s, i, u, m) : function (e, t, n, s, i, c, u) {
          const m = !!(c & 1);
          const y = !!(c & 2) && !m;
          const h = i == null ? undefined : i.getMainConstraintSet().getTypeVar(t);
          let T = h == null ? undefined : h.upperBound;
          if (!T && !l.TypeVarType.isSelf(t)) {
            T = t.shared.boundType;
          }
          let v = h == null ? undefined : h.lowerBound;
          let b = v;
          let _ = T;
          const C = s ? new a.DiagnosticAddendum() : undefined;
          let I = n;
          if (!(c & 8192)) {
            if (l.isClass(I) && I.priv.includeSubclasses) {
              I = p.specializeWithDefaultTypeArgs(I);
            }
          }
          if (l.TypeBase.isInstantiable(t)) {
            if (p.isEffectivelyInstantiable(I)) {
              I = p.convertToInstance(I, false);
            } else {
              const a = e.makeTopLevelTypeVarsConcrete(I);
              if (!p.isEffectivelyInstantiable(a)) {
                if (s != null) {
                  s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(n, t)));
                }
                return false;
              }
              I = p.convertToInstance(a);
            }
          } else {
            if (l.isTypeVar(n) && l.TypeBase.isInstantiable(n) && l.isTypeSame(p.convertToInstance(n), t)) {
              if (s != null) {
                s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(I, t)));
              }
              return false;
            }
          }
          if (c & 2048) {
            if (c & 4096 && l.isUnknown(I)) {
              return true;
            }
            if (!h) {
              if (m) {
                b = I;
                _ = I;
              } else {
                if (y) {
                  b = I;
                } else {
                  _ = I;
                }
              }
            }
          } else {
            if (y) {
              if (!T || l.isTypeSame(t, T)) {
                _ = I;
              } else {
                if (!l.isTypeSame(T, I, {}, u)) {
                  if (e.assignType(T, e.makeTopLevelTypeVarsConcrete(I), C, undefined, 0, u)) {
                    _ = I;
                  } else {
                    if (!e.assignType(I, T, C, undefined, 0, u)) {
                      if (s && C) {
                        s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(T, I)));
                        s.addAddendum(C);
                      }
                      return false;
                    }
                  }
                }
              }
              if (v && !e.assignType(_, v, undefined, undefined, 0, u)) {
                if (s && C) {
                  s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(v, _)));
                  s.addAddendum(C);
                }
                return false;
              }
            } else {
              if (!v || l.isTypeSame(t, v)) {
                b = I;
              } else {
                if (l.isTypeSame(v, I, {}, u)) {
                  if (!_ && m && h && !h.retainLiterals) {
                    b = g(e, t, v);
                  }
                } else {
                  if (e.assignType(v, I, C, i, c, u)) {
                    if (p.isPartlyUnknown(v) && !l.isUnknown(I) && e.assignType(I, v, undefined, i, 0, u)) {
                      b = I;
                    } else {
                      b = v;
                      if (i) {
                        b = e.solveAndApplyConstraints(b, i);
                      }
                    }
                  } else {
                    if (l.isTypeVar(v) && !l.isTypeVar(I) && e.assignType(e.makeTopLevelTypeVarsConcrete(v), I, C, i, c, u)) {
                      b = I;
                    } else {
                      if (e.assignType(I, v, undefined, i, 0, u)) {
                        if (!l.isTypeVar(I)) {
                          b = I;
                        }
                      } else {
                        if (l.isTypeVarTuple(t)) {
                          const t = function (e, t, n) {
                            if (!l.isUnpackedClass(t) || !l.isUnpackedClass(n)) {
                              return;
                            }
                            if (!t.priv.tupleTypeArgs || !n.priv.tupleTypeArgs || t.priv.tupleTypeArgs.length !== n.priv.tupleTypeArgs.length) {
                              return;
                            }
                            const a = f(e, t);
                            const r = f(e, n);
                            if (l.isTypeSame(a, r)) {
                              return a;
                            }
                            return;
                          }(e, v, I);
                          if (!t) {
                            if (s != null) {
                              s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(v, I)));
                            }
                            return false;
                          }
                          b = t;
                        } else {
                          const n = e.getObjectType();
                          if (!_ && m && h && !h.retainLiterals) {
                            v = g(e, t, v);
                          }
                          let a = v;
                          if (i) {
                            a = e.solveAndApplyConstraints(v, i);
                          }
                          b = l.isUnion(a) && a.priv.subtypes.length > o.maxSubtypesForInferredType && l.TypeVarType.hasBound(t) && l.isClassInstance(n) ? l.combineTypes([a, n], {
                            maxSubtypeCount: d
                          }) : l.combineTypes([a, I], {
                            maxSubtypeCount: d
                          });
                        }
                      }
                    }
                  }
                }
              }
              if (m && b && !e.assignType(I, b, s == null ? undefined : s.createAddendum(), undefined, 0, u)) {
                if (s && C) {
                  s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(b, I)));
                }
                return false;
              }
              if (T && b && !l.isTypeSame(T, b, {}, u) && !e.assignType(T, b, s == null ? undefined : s.createAddendum(), undefined, 0, u)) {
                if (s && C) {
                  s.addMessage(r.LocAddendum.typeAssignmentMismatch().format(e.printSrcDestTypes(b, T)));
                }
                return false;
              }
            }
          }
          if (!_ && m) {
            _ = b;
          }
          if (t.shared.boundType) {
            const a = b || _;
            if (l.TypeBase.isInstantiable(t) && !p.isEffectivelyInstantiable(n)) {
              return false;
            }
            const o = l.TypeVarType.isSelf(t) ? i : undefined;
            if (!e.assignType(t.shared.boundType, e.makeTopLevelTypeVarsConcrete(a), s == null ? undefined : s.createAddendum(), o, 0, u)) {
              if (!t.shared.isSynthesized && s != null) {
                s.addMessage(r.LocAddendum.typeBound().format({
                  sourceType: e.printType(a),
                  destType: e.printType(t.shared.boundType),
                  name: l.TypeVarType.getReadableName(t)
                }));
              }
              return false;
            }
          }
          if (i != null) {
            i.setBounds(t, b, _, !!(c & 2304));
          }
          return true;
        }(e, t, n, s, i, u, m);
      }
      if (c) {
        const t = ' '.repeat(m * 2);
        console.log(`${t}`);
        if (i) {
          T(e, i, t);
        }
      }
      return y;
    }
    function m(e, t, n) {
      const a = new s.ConstraintSolutionSet();
      t.doForEachTypeVar(r => {
        y(e, t, n, a, r);
      });
      return a;
    }
    function y(e, t, n, a, r) {
      if (a.hasType(r.typeVar)) {
        return a.getType(r.typeVar);
      }
      a.setType(r.typeVar, undefined);
      let i = h(e, t, r.typeVar, n == null ? undefined : n.useLowerBoundOnly);
      if (i) {
        const o = p.getTypeVarArgsRecursive(i);
        if (o.length > 0) {
          const d = new s.ConstraintSolution();
          for (const s of o) {
            if (l.isTypeSame(s, r.typeVar, {
              ignoreTypeFlags: true
            })) {
              continue;
            }
            if (l.TypeVarType.isBound(s)) {
              continue;
            }
            const i = t.getTypeVar(s);
            if (!i) {
              continue;
            }
            const o = y(e, t, n, a, i);
            if (o) {
              d.setType(s, o);
            }
          }
          if (!d.isEmpty()) {
            i = p.applySolvedTypeVars(i, d);
          }
        }
      }
      a.setType(r.typeVar, i);
      return i;
    }
    function g(e, t, n) {
      if (l.isTypeVarTuple(t)) {
        return f(e, n);
      } else {
        return p.stripTypeForm(e.stripLiteralValue(n));
      }
    }
    function h(e, t, n, a) {
      const r = t.getTypeVar(n);
      if (!r) {
        return;
      }
      if (l.isParamSpec(n)) {
        if (!r.lowerBound) {
          return;
        }
        if (l.isFunction(r.lowerBound)) {
          return r.lowerBound;
        }
        if (l.isAnyOrUnknown(r.lowerBound)) {
          return l.ParamSpecType.getUnknown();
        }
      }
      let s;
      let i = r.lowerBound;
      if (i) {
        if (!r.retainLiterals) {
          const t = g(e, n, i);
          if (t !== i) {
            if (!r.upperBound || !!e.assignType(r.upperBound, t)) {
              if (l.TypeVarType.hasConstraints(n)) {
                if (n.shared.constraints.some(e => l.isTypeSame(t, e))) {
                  i = t;
                }
              } else {
                i = t;
              }
            }
          }
        }
        s = i;
      } else {
        if (!a) {
          s = r.upperBound;
        }
      }
      return s;
    }
    function f(e, t) {
      if (!l.isUnpackedClass(t) || !t.priv.tupleTypeArgs) {
        return t;
      }
      let n = false;
      const a = t.priv.tupleTypeArgs.map(t => {
        const a = p.stripTypeForm(e.stripLiteralValue(t.type));
        if (a !== t.type) {
          n = true;
        }
        return {
          isUnbounded: t.isUnbounded,
          isOptional: t.isOptional,
          type: a
        };
      });
      if (n) {
        return p.specializeTupleClass(t, a, true, true);
      } else {
        return t;
      }
    }
    function T(e, t, n) {
      const a = t.getConstraintSets().length;
      if (a === 0) {
        console.log(`${n}  no signatures`);
      } else {
        if (a === 1) {
          v(e, t.getConstraintSets()[0], `${n}  `);
        } else {
          t.doForEachConstraintSet((t, a) => {
            console.log(`${n}  signature ${a}`);
            v(e, t, `${n}    `);
          });
        }
      }
    }
    function v(e, t, n) {
      let a = false;
      t.getTypeVars().forEach(t => {
        const r = `${n}${t.typeVar.shared.name}`;
        const s = t.lowerBound;
        const i = t.upperBound;
        if (s && i && l.isTypeSame(s, i)) {
          console.log(`${r} = ${e.printType(s)}`);
          a = true;
        } else {
          if (s) {
            console.log(`${r}  ${e.printType(s)}`);
            a = true;
          }
          if (i) {
            console.log(`${r}  ${e.printType(i)}`);
            a = true;
          }
        }
      });
      if (!a) {
        console.log(`${n}no constraints`);
      }
    }
  },
  86672: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ConstraintTracker = exports.ConstraintSet = undefined;
    const a = require(48281);
    const r = require(53529);
    const s = require(21024);
    class i {
      constructor() {
        this._typeVarMap = new Map();
      }
      clone() {
        const e = new i();
        this._typeVarMap.forEach(t => {
          e.setBounds(t.typeVar, t.lowerBound, t.upperBound, t.retainLiterals);
        });
        if (this._scopeIds) {
          this._scopeIds.forEach(t => e.addScopeId(t));
        }
        return e;
      }
      isSame(e) {
        if (this._typeVarMap.size !== e._typeVarMap.size) {
          return false;
        }
        function t(e, t) {
          if (e && t) {
            return s.isTypeSame(e, t, {
              honorIsTypeArgExplicit: true,
              honorTypeForm: true
            });
          } else {
            return e === t;
          }
        }
        let n = true;
        this._typeVarMap.forEach((a, r) => {
          const s = e._typeVarMap.get(r);
          if (!s || !t(a.lowerBound, s.lowerBound) || !t(a.upperBound, s.upperBound)) {
            n = false;
          }
        });
        return n;
      }
      isEmpty() {
        return this._typeVarMap.size === 0;
      }
      getScore() {
        let e = 0;
        this._typeVarMap.forEach(t => {
          var n;
          e += 1;
          const a = (n = t.lowerBound) !== null && n !== undefined ? n : t.upperBound;
          if (a) {
            e += 1 - r.getComplexityScoreForType(a);
          }
        });
        return e;
      }
      setBounds(e, t, n, a) {
        const r = s.TypeVarType.getNameWithScope(e);
        this._typeVarMap.set(r, {
          typeVar: e,
          lowerBound: t,
          upperBound: n,
          retainLiterals: a
        });
      }
      doForEachTypeVar(e) {
        this._typeVarMap.forEach(e);
      }
      getTypeVar(e) {
        const t = s.TypeVarType.getNameWithScope(e);
        return this._typeVarMap.get(t);
      }
      getTypeVars() {
        const e = [];
        this._typeVarMap.forEach(t => {
          e.push(t);
        });
        return e;
      }
      addScopeId(e) {
        if (!this._scopeIds) {
          this._scopeIds = new Set();
        }
        this._scopeIds.add(e);
      }
      hasScopeId(e) {
        return !!this._scopeIds && this._scopeIds.has(e);
      }
      getScopeIds() {
        return new Set(this._scopeIds);
      }
      hasUnificationVars() {
        for (const e of this._typeVarMap.values()) {
          if (s.TypeVarType.isUnification(e.typeVar)) {
            return true;
          }
        }
        return false;
      }
    }
    exports.ConstraintSet = i;
    class o {
      constructor() {
        this._constraintSets = [new i()];
      }
      clone() {
        const e = new o();
        e._constraintSets = this._constraintSets.map(e => e.clone());
        return e;
      }
      cloneWithSignature(e) {
        const t = this.clone();
        if (e) {
          const n = this._constraintSets.filter(t => t.hasScopeId(e));
          if (n.length > 0) {
            t._constraintSets = n;
          } else {
            t._constraintSets.forEach(t => {
              t.addScopeId(e);
            });
          }
        }
        return t;
      }
      copyFromClone(e) {
        this._constraintSets = e._constraintSets.map(e => e.clone());
      }
      copyBounds(e) {
        this._constraintSets.forEach(t => {
          t.setBounds(e.typeVar, e.lowerBound, e.upperBound, e.retainLiterals);
        });
      }
      addConstraintSets(e) {
        a.assert(e.length > 0);
        if (e.length < 1024) {
          this._constraintSets = Array.from(e);
        }
      }
      isSame(e) {
        return e._constraintSets.length === this._constraintSets.length && this._constraintSets.every((t, n) => t.isSame(e._constraintSets[n]));
      }
      isEmpty() {
        return this._constraintSets.every(e => e.isEmpty());
      }
      setBounds(e, t, n, a) {
        return this._constraintSets.forEach(r => {
          r.setBounds(e, t, n, a);
        });
      }
      getScore() {
        let e = 0;
        this._constraintSets.forEach(t => {
          e += t.getScore();
        });
        return e / this._constraintSets.length;
      }
      getMainConstraintSet() {
        return this._constraintSets[0];
      }
      getConstraintSets() {
        return this._constraintSets;
      }
      doForEachConstraintSet(e) {
        this.getConstraintSets().forEach((t, n) => {
          e(t, n);
        });
      }
      getConstraintSet(e) {
        a.assert(e >= 0 && e < this._constraintSets.length);
        return this._constraintSets[e];
      }
    }
    exports.ConstraintTracker = o;
  },
  10329: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.hasConstructorTransform = function (e) {
      if (e.shared.fullName === 'functools.partial') {
        return true;
      }
      return false;
    };
    exports.applyConstructorTransform = function (e, t, n, a, r) {
      if (a.shared.fullName === 'functools.partial') {
        return function (e, t, n, a) {
          if (!c.isClassInstance(a.returnType) || a.returnType.shared.fullName !== 'functools.partial') {
            return;
          }
          const r = u.lookUpObjectMember(a.returnType, '__call__', 16);
          if (!r || !c.isTypeSame(u.convertToInstance(r.classType), a.returnType)) {
            return;
          }
          const o = e.getTypeOfMember(r);
          if (!c.isFunction(o) || o.shared.parameters.length < 1) {
            return;
          }
          if (n.length < 1) {
            return;
          }
          const p = e.getTypeOfArg(n[0], undefined);
          let d = p.type;
          const y = e.makeTopLevelTypeVarsConcrete(d);
          if (c.isInstantiableClass(y)) {
            const t = l.createFunctionFromConstructor(e, y, c.isTypeVar(d) ? u.convertToInstance(d) : undefined);
            if (t) {
              d = t;
            }
          }
          e.inferReturnTypeIfNecessary(d);
          if (n.some(e => e.argCategory !== 0)) {
            return;
          }
          if (c.isFunction(d)) {
            const r = m(e, t, n, o, d);
            if (!r) {
              return;
            }
            return {
              returnType: c.ClassType.cloneForPartial(a.returnType, r.returnType),
              isTypeIncomplete: a.isTypeIncomplete,
              argumentErrors: r.argumentErrors
            };
          }
          if (c.isOverloaded(d)) {
            const r = [];
            const l = c.OverloadedType.getOverloads(d);
            let p;
            let u = false;
            l.forEach(t => {
              const a = m(e, undefined, n, o, t);
              if (a) {
                if (a.argumentErrors) {
                  u = true;
                } else {
                  if (c.isFunction(a.returnType)) {
                    r.push(a.returnType);
                  }
                }
              }
            });
            if (r.length === 0) {
              if (u && l.length > 0) {
                e.addDiagnostic(s.DiagnosticRule.reportCallIssue, i.LocMessage.noOverload().format({
                  name: l[0].shared.name
                }), t);
              }
              return;
            }
            p = r.length === 1 ? r[0] : c.OverloadedType.create(r.map(e => c.FunctionType.cloneWithNewFlags(e, e.shared.flags | 256)));
            return {
              returnType: c.ClassType.cloneForPartial(a.returnType, p),
              isTypeIncomplete: a.isTypeIncomplete,
              argumentErrors: false
            };
          }
          return;
        }(e, t, n, r);
      }
      return r;
    };
    const a = require(58147);
    const r = require(11479);
    const s = require(65880);
    const i = require(67703);
    const o = require(86672);
    const l = require(20516);
    const p = require(44321);
    const d = require(66308);
    const c = require(21024);
    const u = require(92324);
    function m(e, t, n, l, m) {
      const y = new Map();
      const g = p.getParamListDetails(m);
      let h = false;
      let f = false;
      const T = new o.ConstraintTracker();
      n.slice(1).forEach((n, a) => {
        var o;
        var l;
        var d;
        var v;
        var b;
        var _;
        var C;
        var I;
        if (n.valueExpression) {
          if (n.name) {
            const a = g.params.find(e => {
              var t;
              return e.param.name === ((t = n.name) === null || t === undefined ? undefined : t.d.value) && e.kind !== p.ParamKind.Positional;
            });
            if (a) {
              const o = a.param.name;
              const l = a.type;
              if (y.has(o)) {
                if (t) {
                  e.addDiagnostic(s.DiagnosticRule.reportCallIssue, i.LocMessage.paramAlreadyAssigned().format({
                    name: n.name.d.value
                  }), n.name);
                }
                h = true;
              } else {
                const a = new r.DiagnosticAddendum();
                const p = e.getTypeOfExpression(n.valueExpression, undefined, u.makeInferenceContext(l));
                if (!e.assignType(l, p.type, a, T)) {
                  if (t) {
                    e.addDiagnostic(s.DiagnosticRule.reportArgumentType, i.LocMessage.argAssignmentParamFunction().format({
                      argType: e.printType(p.type),
                      paramType: e.printType(l),
                      functionName: m.shared.name,
                      paramName: o
                    }), (I = n.valueExpression) !== null && I !== undefined ? I : t);
                  }
                  h = true;
                }
                y.set(o, true);
              }
            } else {
              if (g.kwargsIndex === undefined) {
                if (t) {
                  e.addDiagnostic(s.DiagnosticRule.reportCallIssue, i.LocMessage.paramNameMissing().format({
                    name: n.name.d.value
                  }), n.name);
                }
                h = true;
              } else {
                const a = c.FunctionType.getParamType(m, g.params[g.kwargsIndex].index);
                const o = new r.DiagnosticAddendum();
                const l = e.getTypeOfExpression(n.valueExpression, undefined, u.makeInferenceContext(a));
                if (!e.assignType(a, l.type, o, T)) {
                  if (t) {
                    e.addDiagnostic(s.DiagnosticRule.reportArgumentType, i.LocMessage.argAssignmentParamFunction().format({
                      argType: e.printType(l.type),
                      paramType: e.printType(a),
                      functionName: m.shared.name,
                      paramName: (_ = g.params[g.kwargsIndex].param.name) !== null && _ !== undefined ? _ : ''
                    }), (C = n.valueExpression) !== null && C !== undefined ? C : t);
                  }
                  h = true;
                }
              }
            }
          } else {
            if (a >= g.params.length || g.params[a].kind === p.ParamKind.Keyword) {
              if (g.argsIndex !== undefined) {
                const a = c.FunctionType.getParamType(m, g.params[g.argsIndex].index);
                const p = new r.DiagnosticAddendum();
                const d = e.getTypeOfExpression(n.valueExpression, undefined, u.makeInferenceContext(a));
                if (!e.assignType(a, d.type, p, T)) {
                  if (t) {
                    e.addDiagnostic(s.DiagnosticRule.reportArgumentType, i.LocMessage.argAssignmentParamFunction().format({
                      argType: e.printType(d.type),
                      paramType: e.printType(a),
                      functionName: m.shared.name,
                      paramName: (o = g.params[g.argsIndex].param.name) !== null && o !== undefined ? o : ''
                    }), (l = n.valueExpression) !== null && l !== undefined ? l : t);
                  }
                  h = true;
                }
              } else {
                if (!f) {
                  if (t) {
                    e.addDiagnostic(s.DiagnosticRule.reportCallIssue, g.positionParamCount === 1 ? i.LocMessage.argPositionalExpectedOne() : i.LocMessage.argPositionalExpectedCount().format({
                      expected: g.positionParamCount
                    }), (d = n.valueExpression) !== null && d !== undefined ? d : t);
                  }
                }
                f = true;
                h = true;
              }
            } else {
              const o = c.FunctionType.getParamType(m, a);
              const l = new r.DiagnosticAddendum();
              const p = (v = g.params[a].param.name) !== null && v !== undefined ? v : '';
              const d = e.getTypeOfExpression(n.valueExpression, undefined, u.makeInferenceContext(o));
              if (!e.assignType(o, d.type, l, T)) {
                if (t) {
                  e.addDiagnostic(s.DiagnosticRule.reportArgumentType, i.LocMessage.argAssignmentParamFunction().format({
                    argType: e.printType(d.type),
                    paramType: e.printType(o),
                    functionName: m.shared.name,
                    paramName: p
                  }), (b = n.valueExpression) !== null && b !== undefined ? b : t);
                }
                h = true;
              }
              y.set(p, false);
            }
          }
        }
      });
      const v = e.solveAndApplyConstraints(m, T);
      if (!c.isFunction(v)) {
        return;
      }
      const b = v.shared.parameters.map((t, n) => {
        var a;
        let r = c.FunctionType.getParamType(v, n);
        if (t.category === 2 && c.isClassInstance(r) && c.isUnpackedClass(r) && c.ClassType.isTypedDictClass(r)) {
          const t = d.getTypedDictMembersForClass(e, r);
          const n = new Map((a = r.priv.typedDictNarrowedEntries) !== null && a !== undefined ? a : []);
          t.knownItems.forEach((e, t) => {
            if (y.has(t)) {
              n.set(t, {
                ...e,
                isRequired: false
              });
            }
          });
          r = c.ClassType.cloneAsInstance(c.ClassType.cloneForNarrowedTypedDictEntries(r, n));
        }
        let s = c.FunctionType.getParamDefaultType(v, n);
        if (t.name && y.get(t.name)) {
          s = c.AnyType.create(true);
        }
        return c.FunctionParam.create(t.category, r, t.flags, t.name, s);
      });
      const _ = b.filter(e => e.category !== 2 && (e.category === 1 || !e.name || !y.has(e.name)));
      const C = b.filter(e => e.name && y.get(e.name));
      const I = b.filter(e => e.category === 2);
      const k = [];
      a.appendArray(k, _);
      a.appendArray(k, C);
      a.appendArray(k, I);
      const w = c.FunctionType.createInstance(l.shared.name, l.shared.fullName, l.shared.moduleName, l.shared.flags, v.shared.docString);
      if (l.shared.parameters.length > 0) {
        c.FunctionType.addParam(w, l.shared.parameters[0]);
      }
      k.forEach(e => {
        c.FunctionType.addParam(w, e);
      });
      w.shared.declaredReturnType = v.shared.declaredReturnType ? c.FunctionType.getEffectiveReturnType(v) : v.priv.inferredReturnType;
      w.shared.declaration = l.shared.declaration;
      w.shared.typeVarScopeId = v.shared.typeVarScopeId;
      return {
        returnType: w,
        isTypeIncomplete: false,
        argumentErrors: h
      };
    }
  },
  20516: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getBoundNewMethod = u;
    exports.getBoundInitMethod = m;
    exports.getBoundCallMethod = y;
    exports.validateConstructorArgs = function (e, t, n, a, o, l) {
      var m;
      var y;
      const h = (m = a.props) === null || m === undefined ? undefined : m.typeAliasInfo;
      if ((h == null ? undefined : h.shared.typeParams) && !h.typeArgs) {
        a = c.applySolvedTypeVars(a, new i.ConstraintSolution(), {
          replaceUnsolved: {
            scopeIds: [h.shared.typeVarScopeId],
            tupleClassType: e.getTupleClassType()
          }
        });
      }
      const T = f(e, t, n, a, o, l, true);
      if (T) {
        const r = (y = T.returnType) !== null && y !== undefined ? y : d.UnknownType.create();
        if (T.argumentErrors || v(e, a, r)) {
          f(e, t, n, a, o, l, false);
          return T;
        }
      }
      const b = new r.DiagnosticAddendum();
      const _ = u(e, t, a, b);
      if (_ == null ? undefined : _.typeErrors) {
        e.addDiagnostic(s.DiagnosticRule.reportGeneralTypeIssues, b.getString(), t);
      }
      const C = p.hasConstructorTransform(a);
      const I = e.useSpeculativeMode(C ? t : undefined, () => g(e, t, n, a, o, l, _));
      let k = !C || I.argumentErrors;
      if (C) {
        if (I.argumentErrors) {
          g(e, t, n, a, o, l, _);
          k = true;
        } else {
          if (I.returnType) {
            const r = p.applyConstructorTransform(e, t, n, a, {
              argumentErrors: !!I.argumentErrors,
              returnType: I.returnType,
              isTypeIncomplete: !!I.isTypeIncomplete
            });
            if (r) {
              I.returnType = r.returnType;
              if (r.isTypeIncomplete) {
                I.isTypeIncomplete = true;
              }
              if (r.argumentErrors) {
                I.argumentErrors = true;
              }
              k = true;
            }
          }
        }
      }
      if (!k) {
        n.forEach(t => {
          if (t.valueExpression && !e.isSpeculativeModeInUse(t.valueExpression)) {
            e.getTypeOfExpression(t.valueExpression);
          }
        });
      }
      return I;
    };
    exports.createFunctionFromConstructor = function (e, t, n = undefined, a = 0) {
      const r = function (e, t, n) {
        const a = t.shared.effectiveMetaclass;
        if (!a || !d.isClass(a)) {
          return;
        }
        const r = c.lookUpClassMember(a, '__call__', 536);
        if (!r) {
          return;
        }
        const s = e.getTypeOfMember(r);
        if (!d.isFunction(s) && !d.isOverloaded(s)) {
          return;
        }
        const i = e.bindFunctionToClassOrObject(t, s, r && d.isInstantiableClass(r.classType) ? r.classType : undefined, false, t, undefined, n);
        if (!i) {
          return;
        }
        let o = false;
        c.doForEachSignature(i, n => {
          if (n.shared.declaredReturnType) {
            const a = d.FunctionType.getEffectiveReturnType(n);
            if (a && v(e, t, a)) {
              o = true;
            }
          }
        });
        if (o) {
          return i;
        } else {
          return undefined;
        }
      }(e, t, a);
      if (r) {
        return r;
      }
      let s = function (e, t, n, a) {
        const r = c.lookUpClassMember(t, '__new__', 532);
        if (!r) {
          return;
        }
        const s = e.getTypeOfMember(r);
        const i = s => {
          const i = s.shared.parameters.some((e, n) => {
            if (n === 0 || !e.name) {
              return false;
            }
            const a = d.FunctionType.getParamType(s, n);
            return c.getTypeVarArgsRecursive(a).some(e => e.priv.scopeId === c.getTypeVarScopeId(t));
          });
          const o = e.bindFunctionToClassOrObject(i ? c.selfSpecializeClass(t) : t, s, r && d.isInstantiableClass(r.classType) ? r.classType : undefined, true, n, undefined, a);
          if (!o) {
            return;
          }
          const l = d.FunctionType.clone(o);
          l.shared.typeVarScopeId = s.shared.typeVarScopeId;
          if (!l.shared.docString && t.shared.docString) {
            l.shared.docString = t.shared.docString;
          }
          l.shared.flags &= -6;
          l.priv.constructorTypeVarScopeId = c.getTypeVarScopeId(t);
          return l;
        };
        if (d.isFunction(s)) {
          return i(s);
        }
        if (!d.isOverloaded(s)) {
          return;
        }
        const o = [];
        d.OverloadedType.getOverloads(s).forEach(e => {
          const t = i(e);
          if (t) {
            o.push(t);
          }
        });
        if (o.length === 0) {
          return;
        }
        if (o.length === 1) {
          return o[0];
        }
        return d.OverloadedType.create(o);
      }(e, t, n, a);
      if (s) {
        let n = false;
        c.doForEachSignature(s, a => {
          const r = d.FunctionType.getEffectiveReturnType(a);
          if (r && b(e, t, r)) {
            n = true;
          }
        });
        if (n) {
          return s;
        }
      }
      const i = function (e, t, n, a) {
        const r = c.lookUpClassMember(t, '__init__', 532);
        if (!r) {
          return;
        }
        const s = e.getTypeOfMember(r);
        const i = d.ClassType.cloneAsInstance(t);
        function o(s) {
          var o;
          const p = e.bindFunctionToClassOrObject(i, s, r && d.isInstantiableClass(r.classType) ? r.classType : undefined, undefined, n, undefined, a);
          if (!p) {
            return;
          }
          const u = d.FunctionType.clone(p);
          let m = n;
          if (!m && (m = i, i.shared.typeParams.length > 0 && !i.priv.typeArgs)) {
            const t = new l.ConstraintTracker();
            const n = [];
            u.shared.parameters.forEach((e, t) => {
              const a = d.FunctionType.getParamType(u, t);
              c.addTypeVarsToListIfUnique(n, c.getTypeVarArgsRecursive(a));
            });
            n.forEach(e => {
              t.setBounds(e, e);
            });
            m = e.solveAndApplyConstraints(i, t, {
              replaceUnsolved: {
                scopeIds: c.getTypeVarScopeIds(i),
                tupleClassType: e.getTupleClassType()
              }
            });
          }
          u.shared.declaredReturnType = (o = p.priv.strippedFirstParamType) !== null && o !== undefined ? o : m;
          if (u.priv.specializedTypes) {
            u.priv.specializedTypes.returnType = m;
          }
          if (!u.shared.docString && t.shared.docString) {
            u.shared.docString = t.shared.docString;
          }
          u.shared.flags &= -5;
          u.priv.constructorTypeVarScopeId = c.getTypeVarScopeId(t);
          return u;
        }
        if (d.isFunction(s)) {
          return o(s);
        }
        if (!d.isOverloaded(s)) {
          return;
        }
        const p = [];
        d.OverloadedType.getOverloads(s).forEach(e => {
          const t = o(e);
          if (t) {
            p.push(t);
          }
        });
        if (p.length === 0) {
          return;
        }
        if (p.length === 1) {
          return p[0];
        }
        return d.OverloadedType.create(p);
      }(e, t, n, a);
      if (i && s && _(s)) {
        s = undefined;
      }
      if (s && i) {
        return d.combineTypes([i, s]);
      }
      if (s || i) {
        if (s != null) {
          return s;
        } else {
          return i;
        }
      }
      if (s != null) {
        return s;
      } else {
        return function (e) {
          const t = d.FunctionType.createSynthesizedInstance('__new__', 0);
          t.shared.declaredReturnType = d.ClassType.cloneAsInstance(e);
          if (e.priv.includeSubclasses || d.ClassType.isProtocolClass(e)) {
            d.FunctionType.addDefaultParams(t);
          }
          if (!t.shared.docString && e.shared.docString) {
            t.shared.docString = e.shared.docString;
          }
          return t;
        }(t);
      }
    };
    const a = require(58147);
    const r = require(11479);
    const s = require(65880);
    const i = require(70617);
    const o = require(10081);
    const l = require(86672);
    const p = require(10329);
    const d = require(21024);
    const c = require(92324);
    function u(e, t, n, a = undefined, r = 4) {
      const s = r | 800;
      return e.getTypeOfBoundMember(t, n, '__new__', {
        method: 'get'
      }, a, s);
    }
    function m(e, t, n, a = undefined, r = 4) {
      const s = r | 528;
      return e.getTypeOfBoundMember(t, n, '__init__', {
        method: 'get'
      }, a, s);
    }
    function y(e, t, n) {
      return e.getTypeOfBoundMember(t, n, '__call__', {
        method: 'get'
      }, undefined, 536);
    }
    function g(e, t, n, p, y, g, f) {
      var v;
      var C;
      let I;
      let k = false;
      let w = false;
      let S = false;
      const A = [];
      let x;
      let P;
      if (f) {
        const r = h(e, t, n, p, y, g, f, true);
        if (r.argumentErrors) {
          w = true;
        } else {
          a.appendArray(A, (v = r.overloadsUsedForCall) !== null && v !== undefined ? v : []);
        }
        if (r.isTypeIncomplete) {
          S = true;
        }
        x = r.returnType;
      }
      if (!x || _(f == null ? undefined : f.type)) {
        x = d.ClassType.cloneAsInstance(p);
      } else {
        if (d.isAnyOrUnknown(x)) {
          x = c.applySolvedTypeVars(d.ClassType.cloneAsInstance(p), new i.ConstraintSolution(), {
            replaceUnsolved: {
              scopeIds: c.getTypeVarScopeIds(p),
              tupleClassType: e.getTupleClassType()
            }
          });
        }
      }
      if (w) {
        P = {
          type: c.convertToInstance(p)
        };
      }
      if (!d.isNever(x) && !b(e, p, x) && d.isClassInstance(x)) {
        let a = x;
        if (a.priv.typeArgs && a.priv.typeArgs.some(e => d.isUnknown(e))) {
          a = d.ClassType.cloneAsInstance(p);
        }
        const i = new r.DiagnosticAddendum();
        P = m(e, t, a, i);
        if (P == null ? undefined : P.typeErrors) {
          e.addDiagnostic(s.DiagnosticRule.reportGeneralTypeIssues, i.getString(), t);
        }
        if (P) {
          const r = function (e, t, n, a, r, s, i) {
            let p = false;
            let u = false;
            const m = [];
            const y = new l.ConstraintTracker();
            if (a.priv.typeArgs) {
              o.addConstraintsForExpectedType(e, a, a, y, undefined);
            }
            const g = c.selfSpecializeClass(a);
            const h = e.validateCallArgs(t, n, {
              type: i
            }, y, r, s ? {
              ...s,
              returnTypeOverride: g
            } : undefined);
            let f = a;
            if (h.specializedInitSelfType && d.isClassInstance(h.specializedInitSelfType) && d.ClassType.isSameGenericClass(h.specializedInitSelfType, f)) {
              f = d.ClassType.cloneAsInstantiable(h.specializedInitSelfType);
            }
            const v = T(e, f, undefined, y);
            if (h.isTypeIncomplete) {
              p = true;
            }
            if (h.argumentErrors) {
              u = true;
            } else {
              if (h.overloadsUsedForCall) {
                m.push(...h.overloadsUsedForCall);
              }
            }
            return {
              argumentErrors: u,
              returnType: v,
              isTypeIncomplete: p,
              overloadsUsedForCall: m
            };
          }(e, t, n, a, y, g, P.type);
          if (r.argumentErrors) {
            w = true;
          } else {
            if (r.overloadsUsedForCall) {
              A.push(...r.overloadsUsedForCall);
            }
          }
          if (r.isTypeIncomplete) {
            S = true;
          }
          I = r.returnType;
          k = true;
          y = true;
        }
      }
      if (!k && f) {
        if (!e.isSpeculativeModeInUse(t)) {
          h(e, t, n, p, y, g, f, false);
        }
        k = true;
        I = x;
      }
      if (!f && !P) {
        const r = function (e, t, n, a, r) {
          var s;
          const i = (s = u(e, t, a, undefined, 0)) === null || s === undefined ? undefined : s.type;
          if (!i || !d.isFunction(i) && !d.isOverloaded(i)) {
            return {
              returnType: c.convertToInstance(a)
            };
          }
          return h(e, t, n, a, false, r, {
            type: i
          }, false);
        }(e, t, n, p, g);
        if (r.argumentErrors) {
          w = true;
        } else {
          if (r.overloadsUsedForCall) {
            a.appendArray(A, r.overloadsUsedForCall);
          }
        }
        if (r.isTypeIncomplete) {
          S = true;
        }
        I = (C = r.returnType) !== null && C !== undefined ? C : d.UnknownType.create();
      }
      return {
        argumentErrors: w,
        returnType: I,
        isTypeIncomplete: S,
        overloadsUsedForCall: A
      };
    }
    function h(e, t, n, a, r, s, i, o) {
      let p;
      let u = false;
      let m = false;
      const y = [];
      const g = new l.ConstraintTracker();
      const h = e.useSpeculativeMode(o ? t : undefined, () => e.validateCallArgs(t, n, i, g, r, s));
      if (h.isTypeIncomplete) {
        u = true;
      }
      if (h.argumentErrors) {
        m = true;
        e.validateCallArgs(t, n, i, g, r, s);
      } else {
        p = h.returnType;
        if (y.length === 0 && h.overloadsUsedForCall) {
          y.push(...h.overloadsUsedForCall);
        }
      }
      if (p) {
        if (d.isClassInstance(p) && c.isTupleClass(p) && !p.priv.tupleTypeArgs) {
          if (p.priv.typeArgs && p.priv.typeArgs.length === 1) {
            p = c.specializeTupleClass(p, [{
              type: p.priv.typeArgs[0],
              isUnbounded: true
            }]);
          }
          p = function (e, t) {
            let n = e;
            if (t && d.isClassInstance(t.expectedType) && c.isTupleClass(t.expectedType) && t.expectedType.priv.tupleTypeArgs) {
              n = c.specializeTupleClass(e, t.expectedType.priv.tupleTypeArgs);
            }
            return n;
          }(p, s);
        }
      } else {
        p = T(e, a, s, g);
      }
      return {
        argumentErrors: m,
        returnType: p,
        isTypeIncomplete: u,
        overloadsUsedForCall: y
      };
    }
    function f(e, t, n, a, r, s, i) {
      const o = y(e, t, a);
      if (!o) {
        return;
      }
      const l = e.useSpeculativeMode(i ? t : undefined, () => e.validateCallArgs(t, n, o, undefined, r, s));
      if (!l.argumentErrors) {
        const e = o.type;
        if (d.isFunction(e) && !e.shared.declaredReturnType) {
          return;
        }
        if (l.returnType && d.isUnknown(l.returnType)) {
          return;
        }
      }
      return l;
    }
    function T(e, t, n, a) {
      let r = true;
      if (t.shared.typeParams.length === 0 || t.priv.typeArgs) {
        return e.solveAndApplyConstraints(d.ClassType.cloneAsInstance(t), a, {
          replaceUnsolved: {
            scopeIds: [],
            tupleClassType: e.getTupleClassType()
          }
        });
      }
      if (n) {
        const s = c.mapSubtypes(n.expectedType, n => function (e, t, n, a) {
          const r = e.solveAndApplyConstraints(d.ClassType.cloneAsInstance(t), a, {
            replaceUnsolved: {
              scopeIds: [],
              tupleClassType: e.getTupleClassType()
            }
          });
          if (e.assignType(n, r)) {
            if (d.isAny(n)) {
              return n;
            } else {
              return r;
            }
          }
        }(e, t, n, a));
        if (!d.isNever(s)) {
          return s;
        }
        if (t.priv.typeArgs) {
          r = false;
        }
      }
      const s = e.solveAndApplyConstraints(t, a, {
        replaceUnsolved: r ? {
          scopeIds: c.getTypeVarScopeIds(t),
          tupleClassType: e.getTupleClassType()
        } : undefined
      });
      return d.ClassType.cloneAsInstance(s);
    }
    function v(e, t, n) {
      return !e.assignType(c.convertToInstance(t), n) || !!d.isNever(n) || !!d.findSubtype(n, e => d.isAny(e)) || !!d.ClassType.isEnumClass(t);
    }
    function b(e, t, n) {
      const a = e.makeTopLevelTypeVarsConcrete(n);
      let r = false;
      c.doForEachSubtype(a, e => {
        if (!d.isUnknown(e)) {
          if (d.isClassInstance(e)) {
            const n = [];
            if (!d.ClassType.isDerivedFrom(d.ClassType.cloneAsInstantiable(e), t, n)) {
              r = true;
            }
          } else {
            r = true;
          }
        }
      });
      return r;
    }
    function _(e) {
      var t;
      if (!e || !d.isFunction(e)) {
        return false;
      }
      const n = e.shared.parameters;
      if (n.length !== 2) {
        return false;
      }
      if (n[0].category !== 1 || n[1].category !== 2) {
        return false;
      }
      const a = (t = e.shared.declaredReturnType) !== null && t !== undefined ? t : e.priv.inferredReturnType;
      return !!a && !!d.isTypeVar(a) && !!d.TypeVarType.isSelf(a);
    }
  },
  57373: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.synthesizeDataClassMethods = function (e, t, n, a, r, s, S) {
      var A;
      i.assert(_.ClassType.isDataClass(n) || a);
      const x = C.synthesizeTypeVarForSelfCls(n, true);
      const P = _.FunctionType.createSynthesizedInstance('__new__', 1);
      P.priv.constructorTypeVarScopeId = C.getTypeVarScopeId(n);
      const D = _.FunctionType.createSynthesizedInstance('__init__');
      D.priv.constructorTypeVarScopeId = C.getTypeVarScopeId(n);
      _.FunctionType.addParam(P, _.FunctionParam.create(0, x, _.FunctionParamFlags.TypeDeclared, 'cls'));
      if (!a) {
        _.FunctionType.addDefaultParams(P);
        P.shared.flags |= 32768;
      }
      P.shared.declaredReturnType = C.convertToInstance(x);
      const N = C.synthesizeTypeVarForSelfCls(n, false);
      const F = _.FunctionParam.create(0, N, _.FunctionParamFlags.TypeDeclared, 'self');
      _.FunctionType.addParam(D, F);
      if (a) {
        _.FunctionType.addDefaultParams(D);
        D.shared.flags |= 32768;
      }
      let E;
      D.shared.declaredReturnType = e.getNoneType();
      if (p.PythonVersion.isGreaterOrEqualTo(c.getFileInfo(t).executionEnvironment.pythonVersion, p.pythonVersion3_13)) {
        E = _.FunctionType.createSynthesizedInstance('__replace__');
        _.FunctionType.addParam(E, F);
        _.FunctionType.addKeywordOnlyParamSeparator(E);
        E.shared.declaredReturnType = N;
      }
      const M = [];
      const O = [];
      const z = new Set();
      const U = k(n, O);
      if (!U) {
        _.FunctionType.addDefaultParams(D);
        if (E) {
          _.FunctionType.addDefaultParams(E);
        }
      }
      const V = a ? P : D;
      const R = [];
      let L = false;
      _.ClassType.getSymbolTable(n).forEach((s, i) => {
        var o;
        var p;
        var u;
        var m;
        var y;
        var g;
        var h;
        if (s.isIgnoredForProtocolMatch()) {
          return;
        }
        if (i === '__hash__') {
          return;
        }
        const v = s.getTypedDeclarations().find(e => {
          if (e.type !== 1) {
            return false;
          }
          const t = f.getEnclosingClassOrFunction(e.node);
          return !!t && t.nodeType === 10;
        });
        if (v) {
          let s;
          let i;
          let h;
          let f;
          let b = v.node;
          while (b && b.nodeType !== 3) {
            if (b.nodeType === 54) {
              if (((o = b.parent) === null || o === undefined ? undefined : o.nodeType) === 3) {
                b = b.parent;
              }
              break;
            }
            b = b.parent;
          }
          if (!b) {
            return;
          }
          let k;
          let S;
          let A = false;
          let x = false;
          let P = _.ClassType.isDataClassKeywordOnly(n) || L;
          let D = true;
          if (b.nodeType === 3) {
            if (b.d.leftExpr.nodeType === 54 && b.d.leftExpr.d.valueExpr.nodeType === 38) {
              s = b.d.leftExpr.d.valueExpr;
              i = b.d.leftExpr;
              const t = b;
              f = () => e.getTypeOfAnnotation(t.d.leftExpr.d.annotation, {
                varTypeAnnotation: true,
                allowFinal: true,
                allowClassVar: true
              });
            }
            A = true;
            k = b.d.rightExpr;
            if (b.d.rightExpr.nodeType === 9) {
              const r = e.getTypeOfExpression(b.d.rightExpr.d.leftExpr, 2);
              const s = r.type;
              if (!a && w(s, ((p = n.shared.dataClassBehaviors) === null || p === undefined ? undefined : p.fieldDescriptorNames) || [])) {
                const n = b.d.rightExpr.d.args.find(e => {
                  var t;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'init';
                });
                if (n && n.d.valueExpr) {
                  const e = c.getFileInfo(t);
                  D = (u = T.evaluateStaticBoolExpression(n.d.valueExpr, e.executionEnvironment, e.definedConstants)) !== null && u !== undefined ? u : D;
                } else {
                  D = (m = I(e, b.d.rightExpr, r, 'init')) !== null && m !== undefined ? m : D;
                }
                const a = b.d.rightExpr.d.args.find(e => {
                  var t;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'kw_only';
                });
                if (a && a.d.valueExpr) {
                  const e = c.getFileInfo(t);
                  P = (y = T.evaluateStaticBoolExpression(a.d.valueExpr, e.executionEnvironment, e.definedConstants)) !== null && y !== undefined ? y : P;
                } else {
                  P = (g = I(e, b.d.rightExpr, r, 'kw_only')) !== null && g !== undefined ? g : P;
                }
                const s = b.d.rightExpr.d.args.find(e => {
                  var t;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'default';
                });
                A = !!s;
                if (s == null ? undefined : s.d.valueExpr) {
                  k = s.d.valueExpr;
                }
                const i = b.d.rightExpr.d.args.find(e => {
                  var t;
                  var n;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'default_factory' || ((n = e.d.name) === null || n === undefined ? undefined : n.d.value) === 'factory';
                });
                if (i) {
                  A = true;
                  x = true;
                }
                if (i == null ? undefined : i.d.valueExpr) {
                  k = i.d.valueExpr;
                }
                const o = b.d.rightExpr.d.args.find(e => {
                  var t;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'alias';
                });
                if (o) {
                  const t = e.getTypeOfExpression(o.d.valueExpr).type;
                  if (_.isClassInstance(t) && _.ClassType.isBuiltIn(t, 'str') && C.isLiteralType(t)) {
                    h = t.priv.literalValue;
                  }
                }
                const l = b.d.rightExpr.d.args.find(e => {
                  var t;
                  return ((t = e.d.name) === null || t === undefined ? undefined : t.d.value) === 'converter';
                });
                if (l && l.d.valueExpr) {
                  S = l;
                }
              }
            }
          } else {
            if (b.nodeType === 54 && b.d.valueExpr.nodeType === 38) {
              s = b.d.valueExpr;
              i = b;
              const t = b;
              f = () => e.getTypeOfAnnotation(t.d.annotation, {
                varTypeAnnotation: true,
                allowFinal: true,
                allowClassVar: true
              });
              if (!a && b.d.valueExpr.d.value === '_') {
                const e = f();
                if (_.isClassInstance(e) && _.ClassType.isBuiltIn(e, 'KW_ONLY')) {
                  L = true;
                  s = undefined;
                  i = undefined;
                  f = undefined;
                }
              }
            }
          }
          if (s && f) {
            const t = s.d.value;
            const a = _.ClassType.getSymbolTable(n).get(t);
            z.add(t);
            if ((a == null ? undefined : a.isClassVar()) && !(a == null ? undefined : a.isFinalVarInClassBody())) {
              const e = O.findIndex(e => e.name === t);
              if (e >= 0) {
                O.splice(e, 1);
              }
              const a = {
                name: t,
                classType: n,
                alias: h,
                isKeywordOnly: false,
                hasDefault: A,
                isDefaultFactory: x,
                defaultExpr: k,
                includeInInit: D,
                nameNode: s,
                typeAnnotationNode: i,
                type: _.UnknownType.create(),
                isClassVar: true,
                converter: S
              };
              M.push(a);
            } else {
              const a = {
                name: t,
                classType: n,
                alias: h,
                isKeywordOnly: P,
                hasDefault: A,
                isDefaultFactory: x,
                defaultExpr: k,
                includeInInit: D,
                nameNode: s,
                typeAnnotationNode: i,
                type: _.UnknownType.create(),
                isClassVar: false,
                converter: S
              };
              R.push({
                entry: a,
                evaluator: f
              });
              let o = M.findIndex(e => e.name === t);
              if (o >= 0) {
                M[o] = a;
              } else {
                M.push(a);
              }
              o = O.findIndex(e => e.name === t);
              if (o >= 0) {
                const n = O[o];
                if (!a.hasDefault && n.hasDefault && n.includeInInit) {
                  a.hasDefault = true;
                  a.defaultExpr = n.defaultExpr;
                  A = true;
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassFieldInheritedDefault().format({
                    fieldName: t
                  }), s);
                }
                O[o] = a;
              } else {
                O.push(a);
                o = O.length - 1;
              }
              if (!P && D && !r && !A) {
                const t = O.findIndex(e => e.hasDefault && e.includeInInit && !e.isKeywordOnly);
                if (t >= 0 && t < o) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassFieldWithDefault(), s);
                }
              }
            }
          }
        } else {
          const t = s.getDeclarations();
          if (t.length === 0) {
            return;
          }
          const a = t[t.length - 1];
          if (a.type !== 1) {
            return;
          }
          const r = a.node.parent;
          if (!r || r.nodeType !== 3) {
            return;
          }
          if (r.d.rightExpr.nodeType === 9) {
            if (w(e.getTypeOfExpression(r.d.rightExpr.d.leftExpr, 2).type, ((h = n.shared.dataClassBehaviors) === null || h === undefined ? undefined : h.fieldDescriptorNames) || [])) {
              e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassFieldWithoutAnnotation(), r.d.rightExpr);
            }
          }
        }
      });
      if (a) {
        n.shared.namedTupleEntries = z;
      } else {
        n.shared.dataClassEntries = M;
      }
      R.forEach(e => {
        e.entry.type = e.evaluator();
      });
      const B = _.ClassType.getSymbolTable(n);
      const j = [];
      if (!r && !s) {
        if (U) {
          O.forEach(a => {
            if (a.includeInInit) {
              let r;
              let s = a.type;
              if (a.classType !== n && C.requiresSpecialization(s)) {
                const e = new m.ConstraintSolution();
                C.addSolutionForSelfType(e, a.classType, n);
                s = C.applySolvedTypeVars(s, e);
              }
              s = function (e, t) {
                if (!_.isClassInstance(t) || C.isMetaclassInstance(t)) {
                  return t;
                }
                const n = e.getBoundMagicMethod(t, '__set__');
                if (!n) {
                  return t;
                }
                if (!_.isFunction(n)) {
                  return t;
                }
                return _.FunctionType.getParamType(n, 1);
              }(e, s);
              if (a.converter) {
                const n = s;
                s = function (e, t, n, a) {
                  var r;
                  const s = function (e, t) {
                    if (_.isFunction(t) || _.isOverloaded(t)) {
                      return t;
                    }
                    if (_.isClassInstance(t)) {
                      return e.getBoundMagicMethod(t, '__call__');
                    }
                    if (_.isInstantiableClass(t)) {
                      let n = g.createFunctionFromConstructor(e, t);
                      if (n && (_.isUnion(n) && (n = n.priv.subtypes[0]), _.isFunction(n) || _.isOverloaded(n))) {
                        return n;
                      }
                    }
                    return;
                  }(e, e.getTypeOfExpression(t.d.valueExpr).type);
                  if (!s) {
                    return n;
                  }
                  const i = _.TypeVarType.createInstance('__converterInput');
                  i.priv.scopeId = f.getScopeIdForNode(t);
                  const p = _.FunctionType.createSynthesizedInstance('');
                  p.shared.typeVarScopeId = i.priv.scopeId;
                  p.shared.declaredReturnType = n;
                  _.FunctionType.addParam(p, _.FunctionParam.create(0, i, _.FunctionParamFlags.TypeDeclared | _.FunctionParamFlags.NameSynthesized, '__input'));
                  _.FunctionType.addPositionOnlyParamSeparator(p);
                  if (_.isFunction(s) || _.isOverloaded(s)) {
                    const c = [];
                    const u = new o.DiagnosticAddendum();
                    C.doForEachSignature(s, t => {
                      const r = new y.ConstraintTracker();
                      if (e.assignType(_.FunctionType.getEffectiveReturnType(t) ?? _.UnknownType.create(), n, undefined, r)) {
                        t = e.solveAndApplyConstraints(t, r);
                      }
                      const s = new y.ConstraintTracker();
                      if (e.assignType(p, t, u, s)) {
                        const t = e.solveAndApplyConstraints(i, s, {
                          replaceUnsolved: {
                            scopeIds: C.getTypeVarScopeIds(i),
                            tupleClassType: e.getTupleClassType()
                          }
                        });
                        c.push(t);
                      }
                    });
                    if (c.length > 0) {
                      return _.combineTypes(c);
                    }
                    if (_.isFunction(s)) {
                      e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassConverterFunction().format({
                        argType: e.printType(s),
                        fieldType: e.printType(n),
                        fieldName: a
                      }) + u.getString(), t, (r = u.getEffectiveTextRange()) !== null && r !== undefined ? r : t);
                    } else {
                      const r = _.OverloadedType.getOverloads(s);
                      e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassConverterOverloads().format({
                        funcName: r.length > 0 && r[0].shared.name ? r[0].shared.name : '<anonymous function>',
                        fieldType: e.printType(n),
                        fieldName: a
                      }) + u.getString(), t);
                    }
                  }
                  return n;
                }(e, a.converter, s, a.name);
                B.set(a.name, function (e, t, n, a, r, s, i, o) {
                  const l = u.getFileInfo(t);
                  const p = e.getBuiltInType(t, 'type');
                  const d = `__converterDescriptor_${s}`;
                  const c = _.ClassType.createInstantiable(d, f.getClassFullName(r, l.moduleName, d), l.moduleName, l.fileUri, 0, f.getTypeSourceId(r), undefined, _.isInstantiableClass(p) ? p : _.UnknownType.create());
                  c.shared.baseClasses.push(e.getBuiltInType(t, 'object'));
                  C.computeMroLinearization(c);
                  const m = _.ClassType.getSymbolTable(c);
                  const y = C.synthesizeTypeVarForSelfCls(c, false);
                  const g = _.FunctionType.createSynthesizedInstance('__set__');
                  _.FunctionType.addParam(g, _.FunctionParam.create(0, y, _.FunctionParamFlags.TypeDeclared, 'self'));
                  _.FunctionType.addParam(g, _.FunctionParam.create(0, _.AnyType.create(), _.FunctionParamFlags.TypeDeclared, 'obj'));
                  _.FunctionType.addParam(g, _.FunctionParam.create(0, o, _.FunctionParamFlags.TypeDeclared, 'value'));
                  g.shared.declaredReturnType = e.getNoneType();
                  const h = v.Symbol.createWithType(4, g);
                  m.set('__set__', h);
                  const T = _.FunctionType.createSynthesizedInstance('__get__');
                  _.FunctionType.addParam(T, _.FunctionParam.create(0, y, _.FunctionParamFlags.TypeDeclared, 'self'));
                  _.FunctionType.addParam(T, _.FunctionParam.create(0, _.AnyType.create(), _.FunctionParamFlags.TypeDeclared, 'obj'));
                  _.FunctionType.addParam(T, _.FunctionParam.create(0, _.AnyType.create(), _.FunctionParamFlags.TypeDeclared, 'objtype'));
                  T.shared.declaredReturnType = i;
                  const b = v.Symbol.createWithType(4, T);
                  m.set('__get__', b);
                  return v.Symbol.createWithType(4, _.ClassType.cloneAsInstance(c), n);
                }(e, t, a.nameNode, a.typeAnnotationNode, a.converter, a.name, n, s));
                if (a.hasDefault) {
                  r = a.type;
                }
              } else {
                if (a.hasDefault) {
                  if (a.isDefaultFactory || !a.defaultExpr) {
                    r = a.type;
                  } else {
                    const n = a.defaultExpr;
                    const i = c.getFileInfo(t).isStubFile ? 1 : 0;
                    const o = f.getTypeVarScopesForNode(a.defaultExpr);
                    const l = C.makeTypeVarsBound(s, o);
                    r = e.useSpeculativeMode(n, () => e.getTypeOfExpression(n, i, C.makeInferenceContext(l)).type);
                    r = C.makeTypeVarsFree(r, o);
                  }
                }
              }
              const i = a.alias || a.name;
              if (!a.alias && a.nameNode && b.isPrivateName(a.nameNode.d.value)) {
                e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassFieldWithPrivateName(), a.nameNode);
              }
              const p = _.FunctionParam.create(0, s, _.FunctionParamFlags.TypeDeclared, i, r, a.defaultExpr);
              if (a.isKeywordOnly) {
                j.push(p);
              } else {
                _.FunctionType.addParam(V, p);
              }
              if (E) {
                const e = _.FunctionParam.create(p.category, p._type, p.flags, p.name, _.AnyType.create(true));
                _.FunctionType.addParam(E, e);
              }
            }
          });
          if (j.length > 0) {
            _.FunctionType.addKeywordOnlyParamSeparator(V);
            j.forEach(e => {
              _.FunctionType.addParam(V, e);
            });
          }
        }
        B.set('__init__', v.Symbol.createWithType(4, D));
        B.set('__new__', v.Symbol.createWithType(4, P));
        if (E) {
          B.set('__replace__', v.Symbol.createWithType(4, E));
        }
      }
      const q = e.getBuiltInType(t, 'str');
      const G = e.getBuiltInType(t, 'tuple');
      if (G && _.isInstantiableClass(G) && q && _.isInstantiableClass(q) && !B.has('__match_args__')) {
        const e = [];
        O.forEach(t => {
          if (t.includeInInit && !t.isKeywordOnly) {
            e.push(t.name);
          }
        });
        const t = e.map(e => ({
          type: _.ClassType.cloneAsInstance(_.ClassType.cloneWithLiteral(q, e)),
          isUnbounded: false
        }));
        const n = _.ClassType.cloneAsInstance(C.specializeTupleClass(G, t));
        B.set('__match_args__', v.Symbol.createWithType(4, n));
      }
      const W = (n, a) => {
        const r = _.FunctionType.createSynthesizedInstance(n);
        _.FunctionType.addParam(r, F);
        _.FunctionType.addParam(r, _.FunctionParam.create(0, a, _.FunctionParamFlags.TypeDeclared, 'other'));
        r.shared.declaredReturnType = e.getBuiltInObject(t, 'bool');
        if (!B.get(n)) {
          B.set(n, v.Symbol.createWithType(4, r));
        }
      };
      if (!_.ClassType.isDataClassSkipGenerateEq(n)) {
        W('__eq__', e.getBuiltInObject(t, 'object'));
      }
      if (_.ClassType.isDataClassGenerateOrder(n)) {
        ['__lt__', '__le__', '__gt__', '__ge__'].forEach(e => {
          W(e, N);
        });
      }
      let K = _.ClassType.isDataClassFrozen(n);
      const $ = !a && !_.ClassType.isDataClassSkipGenerateEq(n) && !_.ClassType.isDataClassFrozen(n);
      if (S) {
        K = false;
      }
      if (_.ClassType.isDataClassGenerateHash(n)) {
        K = true;
      }
      if (K) {
        const n = _.FunctionType.createSynthesizedInstance('__hash__');
        _.FunctionType.addParam(n, F);
        n.shared.declaredReturnType = e.getBuiltInObject(t, 'int');
        B.set('__hash__', v.Symbol.createWithType(4100, n));
      } else {
        if ($ && !S) {
          B.set('__hash__', v.Symbol.createWithType(4100, e.getNoneType()));
        }
      }
      let H = e.getBuiltInType(t, 'dict');
      if (_.isInstantiableClass(H)) {
        H = _.ClassType.cloneAsInstance(_.ClassType.specialize(H, [e.getBuiltInObject(t, 'str'), _.AnyType.create()]));
      }
      if (!a) {
        B.set('__dataclass_fields__', v.Symbol.createWithType(132, H));
      }
      if (_.ClassType.isDataClassGenerateSlots(n) && n.shared.localSlotsNames === undefined) {
        n.shared.localSlotsNames = M.map(e => e.name);
      }
      if (_.ClassType.isDataClassGenerateSlots(n)) {
        let n = (A = e.getTypingType(t, 'Iterable')) !== null && A !== undefined ? A : _.UnknownType.create();
        if (_.isInstantiableClass(n)) {
          n = _.ClassType.cloneAsInstance(_.ClassType.specialize(n, [e.getBuiltInObject(t, 'str')]));
        }
        B.set('__slots__', v.Symbol.createWithType(132, n));
      }
      if (h.updateNamedTupleBaseClass(n, O.map(e => e.type), true)) {
        C.computeMroLinearization(n);
      }
    };
    exports.addInheritedDataClassEntries = k;
    exports.validateDataClassTransformDecorator = function (e, t) {
      const n = {
        skipGenerateInit: false,
        skipGenerateEq: false,
        generateOrder: false,
        generateSlots: false,
        generateHash: false,
        keywordOnly: false,
        frozen: false,
        frozenDefault: false,
        fieldDescriptorNames: []
      };
      const a = c.getFileInfo(t);
      t.d.args.forEach(t => {
        if (t.d.name && t.d.argCategory === 0) {
          switch (t.d.name.d.value) {
            case 'kw_only_default':
              {
                const r = T.evaluateStaticBoolExpression(t.d.valueExpr, a.executionEnvironment, a.definedConstants);
                if (r === undefined) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformExpectedBoolLiteral(), t.d.valueExpr);
                  return;
                }
                n.keywordOnly = r;
                break;
              }
            case 'eq_default':
              {
                const r = T.evaluateStaticBoolExpression(t.d.valueExpr, a.executionEnvironment, a.definedConstants);
                if (r === undefined) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformExpectedBoolLiteral(), t.d.valueExpr);
                  return;
                }
                n.skipGenerateEq = !r;
                break;
              }
            case 'order_default':
              {
                const r = T.evaluateStaticBoolExpression(t.d.valueExpr, a.executionEnvironment, a.definedConstants);
                if (r === undefined) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformExpectedBoolLiteral(), t.d.valueExpr);
                  return;
                }
                n.generateOrder = r;
                break;
              }
            case 'frozen_default':
              {
                const r = T.evaluateStaticBoolExpression(t.d.valueExpr, a.executionEnvironment, a.definedConstants);
                if (r === undefined) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformExpectedBoolLiteral(), t.d.valueExpr);
                  return;
                }
                n.frozen = r;
                n.frozenDefault = r;
                break;
              }
            case 'field_descriptors':
            case 'field_specifiers':
              {
                const a = e.getTypeOfExpression(t.d.valueExpr).type;
                if (!_.isClassInstance(a) || !_.ClassType.isBuiltIn(a, 'tuple') || !a.priv.tupleTypeArgs || a.priv.tupleTypeArgs.some(e => !_.isInstantiableClass(e.type) && !_.isFunction(e.type) && !_.isOverloaded(e.type))) {
                  e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformFieldSpecifier().format({
                    type: e.printType(a)
                  }), t.d.valueExpr);
                  return;
                }
                a.priv.tupleTypeArgs.forEach(e => {
                  if (_.isInstantiableClass(e.type) || _.isFunction(e.type)) {
                    n.fieldDescriptorNames.push(e.type.shared.fullName);
                  } else {
                    if (_.isOverloaded(e.type)) {
                      const t = _.OverloadedType.getOverloads(e.type);
                      if (t.length > 0) {
                        n.fieldDescriptorNames.push(t[0].shared.fullName);
                      }
                    }
                  }
                });
                break;
              }
            default:
              e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassTransformUnknownArgument().format({
                name: t.d.name.d.value
              }), t.d.valueExpr);
          }
        } else {
          e.addDiagnostic(l.DiagnosticRule.reportCallIssue, d.LocMessage.dataClassTransformPositionalParam(), t);
        }
      });
      return n;
    };
    exports.getDataclassDecoratorBehaviors = function (e) {
      let t;
      if (_.isFunction(e)) {
        t = e;
      } else {
        if (_.isOverloaded(e)) {
          const n = _.OverloadedType.getOverloads(e);
          const a = _.OverloadedType.getImplementation(e);
          t = n.find(e => !!e.shared.decoratorDataClassBehaviors);
          if (!t && a && _.isFunction(a) && a.shared.decoratorDataClassBehaviors) {
            t = a;
          }
          if (!t && n.length > 0) {
            t = n[0];
          }
        }
      }
      if (!t) {
        return;
      }
      if (t.shared.decoratorDataClassBehaviors) {
        return t.shared.decoratorDataClassBehaviors;
      }
      if (t.shared.fullName === 'dataclasses.dataclass') {
        return {
          fieldDescriptorNames: ['dataclasses.field', 'dataclasses.Field']
        };
      }
      return;
    };
    exports.applyDataClassClassBehaviorOverrides = A;
    exports.applyDataClassDecorator = function (e, t, n, a, r) {
      var s;
      A(e, t, n, ((s = r == null ? undefined : r.d.args) !== null && s !== undefined ? s : []).map(t => e.convertNodeToArg(t)), a);
    };
    const i = require(48281);
    const o = require(11479);
    const l = require(65880);
    const p = require(63808);
    const d = require(67703);
    const c = __importStar(require(26687));
    const u = require(26687);
    const m = require(70617);
    const y = require(86672);
    const g = require(20516);
    const h = require(60055);
    const f = require(41557);
    const T = require(28676);
    const v = require(58253);
    const b = require(12097);
    const _ = require(21024);
    const C = require(92324);
    function I(e, t, n, a) {
      const r = n.type;
      let s;
      if (_.isFunction(r)) {
        s = r;
      } else {
        if (_.isOverloaded(r)) {
          s = e.getBestOverloadForArgs(t, {
            type: r,
            isIncomplete: n.isIncomplete
          }, t.d.args.map(t => e.convertNodeToArg(t)));
        } else {
          if (_.isInstantiableClass(r)) {
            const n = g.getBoundInitMethod(e, t, r);
            if (n) {
              if (_.isFunction(n.type)) {
                s = n.type;
              } else {
                if (_.isOverloaded(n.type)) {
                  s = e.getBestOverloadForArgs(t, {
                    type: n.type
                  }, t.d.args.map(t => e.convertNodeToArg(t)));
                }
              }
            }
          }
        }
      }
      if (s) {
        const e = s.shared.parameters.findIndex(e => e.name === a);
        if (e >= 0) {
          const t = s.shared.parameters[e];
          const n = _.FunctionType.getParamType(s, e);
          if (_.FunctionParam.isTypeDeclared(t) && _.isClass(n) && typeof n.priv.literalValue == 'boolean') {
            return n.priv.literalValue;
          }
          const a = _.FunctionType.getParamDefaultType(s, e);
          if (a && _.isClass(a) && typeof a.priv.literalValue == 'boolean') {
            return a.priv.literalValue;
          }
        }
      }
    }
    function k(e, t) {
      let n = true;
      _.ClassType.getReverseMro(e).forEach(e => {
        if (_.isInstantiableClass(e)) {
          const n = C.buildSolutionFromSpecializedClass(e);
          _.ClassType.getDataClassEntries(e).forEach(e => {
            const a = t.findIndex(t => t.name === e.name);
            const r = {
              ...e
            };
            r.type = C.applySolvedTypeVars(r.type, n);
            if (e.isClassVar) {
              if (a >= 0) {
                t.splice(a, 1);
              }
            } else {
              if (a >= 0) {
                t[a] = r;
              } else {
                t.push(r);
              }
            }
          });
        } else {
          n = false;
        }
      });
      return n;
    }
    function w(e, t) {
      let n;
      if (_.isFunction(e)) {
        n = e.shared.fullName;
      } else {
        if (_.isOverloaded(e)) {
          const t = _.OverloadedType.getOverloads(e);
          if (t.length > 0) {
            n = t[0].shared.fullName;
          }
        } else {
          if (_.isInstantiableClass(e)) {
            n = e.shared.fullName;
          }
        }
      }
      return !!n && t.some(e => e === n);
    }
    function S(e, t, n, a, r, s) {
      switch (a) {
        case 'order':
          if (r !== undefined) {
            s.generateOrder = r;
          }
          break;
        case 'kw_only':
          if (r !== undefined) {
            s.keywordOnly = r;
          }
          break;
        case 'frozen':
          {
            let a = false;
            let i = false;
            if (r !== undefined) {
              s.frozen = r;
            }
            n.shared.baseClasses.forEach(e => {
              if (_.isInstantiableClass(e) && _.ClassType.isDataClass(e)) {
                if (_.ClassType.isDataClassFrozen(e)) {
                  i = true;
                } else {
                  if (!e.shared.classDataClassTransform && (!e.shared.declaredMetaclass || !_.isInstantiableClass(e.shared.declaredMetaclass) || !e.shared.declaredMetaclass.shared.classDataClassTransform)) {
                    a = true;
                  }
                }
              }
            });
            if (r) {
              if (a) {
                e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassBaseClassNotFrozen(), t);
              }
            } else {
              if (i) {
                e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassBaseClassFrozen(), t);
              }
            }
            break;
          }
        case 'init':
          if (r !== undefined) {
            s.skipGenerateInit = !r;
          }
          break;
        case 'eq':
          if (r !== undefined) {
            s.skipGenerateEq = !r;
          }
          break;
        case 'slots':
          if (r === true) {
            s.generateSlots = true;
            if (n.shared.localSlotsNames) {
              e.addDiagnostic(l.DiagnosticRule.reportGeneralTypeIssues, d.LocMessage.dataClassSlotsOverwrite(), t);
            }
          } else {
            if (r === false) {
              s.generateSlots = false;
            }
          }
          break;
        case 'hash':
        case 'unsafe_hash':
          if (r === true) {
            s.generateHash = true;
          }
      }
    }
    function A(e, t, n, a, r) {
      let s = false;
      const i = {
        ...r
      };
      i.frozen = i.frozenDefault;
      n.shared.dataClassBehaviors = i;
      a.forEach(t => {
        if (t.valueExpression && t.name) {
          (function (e, t, n, a, r, s) {
            const i = c.getFileInfo(t);
            S(e, t, n, a, T.evaluateStaticBoolExpression(r, i.executionEnvironment, i.definedConstants), s);
          })(e, t.name, n, t.name.d.value, t.valueExpression, i);
          if (t.name.d.value === 'frozen') {
            s = true;
          }
        }
      });
      if (!s) {
        S(e, t, n, 'frozen', r.frozenDefault, i);
      }
    }
  },
  28445: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.UnresolvedModuleMarker = undefined;
    exports.isFunctionDeclaration = function (e) {
      return e.type === 5;
    };
    exports.isClassDeclaration = function (e) {
      return e.type === 6;
    };
    exports.isParamDeclaration = function (e) {
      return e.type === 2;
    };
    exports.isTypeParamDeclaration = function (e) {
      return e.type === 3;
    };
    exports.isTypeAliasDeclaration = function (e) {
      return e.type === 4;
    };
    exports.isVariableDeclaration = function (e) {
      return e.type === 1;
    };
    exports.isAliasDeclaration = r;
    exports.isSpecialBuiltInClassDeclaration = function (e) {
      return e.type === 7;
    };
    exports.isIntrinsicDeclaration = function (e) {
      return e.type === 0;
    };
    exports.isUnresolvedAliasDeclaration = function (e) {
      return r(e) && e.uri.equals(exports.UnresolvedModuleMarker);
    };
    const a = require(27113);
    function r(e) {
      return e.type === 8;
    }
    exports.UnresolvedModuleMarker = a.Uri.constant('*** unresolved module ***');
  },
  83760: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.hasTypeForDeclaration = function (e) {
      switch (e.type) {
        case 0:
        case 6:
        case 7:
        case 5:
        case 3:
        case 4:
          return true;
        case 2:
          {
            if (e.node.d.annotation || e.node.d.annotationComment) {
              return true;
            }
            const t = e.node.parent;
            if ((t == null ? undefined : t.nodeType) === 31 && t.d.funcAnnotationComment && !t.d.funcAnnotationComment.d.isEllipsis) {
              const n = t.d.funcAnnotationComment.d.paramAnnotations;
              return !(t.d.params.length > n.length) || e.node !== t.d.params[0];
            }
            return false;
          }
        case 1:
          return !!e.typeAnnotationNode;
        case 8:
          return false;
      }
    };
    exports.areDeclarationsSame = function (e, t, n = false, a = false) {
      if (e.type !== t.type) {
        return false;
      }
      if (!e.uri.equals(t.uri)) {
        return false;
      }
      if ((!a || e.type !== 8) && (e.range.start.line !== t.range.start.line || e.range.start.character !== t.range.start.character)) {
        return false;
      }
      if (e.type === 8 && t.type === 8) {
        if (e.symbolName !== t.symbolName || e.usesLocalName !== t.usesLocalName) {
          return false;
        }
        if (n) {
          return true;
        }
        if (e.node !== t.node) {
          return false;
        }
      }
      return true;
    };
    exports.getNameFromDeclaration = function (e) {
      var t;
      switch (e.type) {
        case 8:
          return e.symbolName;
        case 6:
        case 5:
        case 3:
        case 4:
          return e.node.d.name.d.value;
        case 2:
          if ((t = e.node.d.name) === null || t === undefined) {
            return undefined;
          } else {
            return t.d.value;
          }
        case 1:
          if (e.node.nodeType === 38) {
            return e.node.d.value;
          } else {
            return undefined;
          }
        case 0:
        case 7:
          if (e.node.nodeType === 54 && e.node.d.valueExpr.nodeType === 38) {
            return e.node.d.valueExpr.d.value;
          } else {
            return undefined;
          }
        default:
          a.assertNever(e);
      }
      throw new Error('Shouldn\'t reach here');
    };
    exports.getNameNodeForDeclaration = function (e) {
      var t;
      var n;
      switch (e.type) {
        case 8:
          if (e.node.nodeType === 24) {
            if ((t = e.node.d.alias) !== null && t !== undefined) {
              return t;
            } else {
              return e.node.d.module.d.nameParts[0];
            }
          } else {
            if (e.node.nodeType === 26) {
              if ((n = e.node.d.alias) !== null && n !== undefined) {
                return n;
              } else {
                return e.node.d.name;
              }
            } else {
              return e.node.d.module.d.nameParts[0];
            }
          }
        case 6:
        case 5:
        case 3:
        case 2:
        case 4:
          return e.node.d.name;
        case 1:
          if (e.node.nodeType === 38) {
            return e.node;
          } else {
            return undefined;
          }
        case 0:
        case 7:
          return;
        default:
          a.assertNever(e);
      }
      throw new Error('Shouldn\'t reach here');
    };
    exports.isDefinedInFile = function (e, t) {
      var n;
      if (s.isAliasDeclaration(e)) {
        if ((n = i.getFileInfoFromNode(e.node)) === null || n === undefined) {
          return undefined;
        } else {
          return n.fileUri.equals(t);
        }
      }
      return e.uri.equals(t);
    };
    exports.getDeclarationsWithUsesLocalNameRemoved = function (e) {
      return e.map(e => {
        if (e.type !== 8) {
          return e;
        }
        const t = {
          ...e
        };
        t.usesLocalName = false;
        return t;
      });
    };
    exports.synthesizeAliasDeclaration = function (e) {
      return {
        type: 8,
        node: undefined,
        uri: e,
        loadSymbolsFromPath: false,
        range: r.getEmptyRange(),
        implicitImports: new Map(),
        usesLocalName: false,
        moduleName: '',
        isInExceptSuite: false
      };
    };
    exports.resolveAliasDeclaration = function e(t, n, a) {
      let r = n;
      const s = [];
      let i;
      let o;
      let l = false;
      let p = false;
      while (true) {
        if (r.type !== 8 || !r.symbolName) {
          return {
            declaration: r,
            isPrivate: l,
            privatePyTypedImported: i,
            privatePyTypedImporter: o
          };
        }
        if (!a.resolveLocalNames && r.usesLocalName) {
          return {
            declaration: r,
            isPrivate: l,
            privatePyTypedImported: i,
            privatePyTypedImporter: o
          };
        }
        let d;
        if (!r.uri.isEmpty() && r.loadSymbolsFromPath) {
          d = t(r.uri, {
            skipFileNeededCheck: a.skipFileNeededCheck
          });
        }
        const c = d ? d.symbolTable.get(r.symbolName) : undefined;
        if (!c) {
          if (r.submoduleFallback) {
            if (r.symbolName && !r.uri.isEmpty() && r.submoduleFallback.type === 8 && !r.submoduleFallback.uri.isEmpty()) {
              if (!t(r.submoduleFallback.uri, {
                skipFileNeededCheck: a.skipFileNeededCheck,
                skipParsing: true
              })) {
                return;
              }
            }
            let n = r.submoduleFallback;
            if (r.symbolName) {
              n = {
                ...r.submoduleFallback
              };
              let e = n.moduleName;
              if (e) {
                e = `${e}.`;
              }
              n.moduleName = `${e}${r.symbolName}`;
            }
            return e(t, n, a);
          }
          if (r.isNativeLib) {
            return {
              declaration: undefined,
              isPrivate: l
            };
          } else {
            return undefined;
          }
        }
        if (c.isPrivateMember() && !p) {
          l = true;
        }
        if (c.isExternallyHidden() && !a.allowExternallyHiddenAccess) {
          return;
        }
        let u = c.getTypedDeclarations();
        u = u.filter(e => !e.isInExceptSuite);
        if (u.length === 0) {
          u = c.getDeclarations();
          u = u.filter(e => !e.isInExceptSuite);
        }
        if (u.length === 0) {
          u = c.getDeclarations();
        }
        if (u.length === 0) {
          return;
        }
        const m = r;
        const y = u.filter(e => !s.includes(e));
        r = y.length > 0 ? y[y.length - 1] : u[u.length - 1];
        if (d == null ? undefined : d.isInPyTypedPackage) {
          if (p) {
            if (!c.isPrivatePyTypedImport()) {
              i = i ?? (r == null ? undefined : r.moduleName);
            }
          } else {
            if (c.isPrivatePyTypedImport()) {
              o = m == null ? undefined : m.moduleName;
            }
            p = true;
          }
        }
        if (s.find(e => e === r)) {
          if (r.type === 8 && r.submoduleFallback) {
            return e(t, r.submoduleFallback, a);
          } else {
            return {
              declaration: n,
              isPrivate: l,
              privatePyTypedImported: i,
              privatePyTypedImporter: o
            };
          }
        }
        s.push(r);
      }
    };
    const a = require(48281);
    const r = require(88754);
    const s = require(28445);
    const i = require(41557);
  },
  26163: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getFunctionInfoFromDecorators = function (e, t, n) {
      const a = r.getFileInfo(t);
      let s;
      let i = 0;
      if (n) {
        if (t.d.name.d.value === '__new__') {
          i |= 1;
        }
        if (['__init_subclass__', '__class_getitem__'].some(e => t.d.name.d.value === e)) {
          i |= 2;
        }
      }
      for (const r of t.d.decorators) {
        let t = a.isStubFile ? 4 : 0;
        if (r.d.expr.nodeType !== 9) {
          t |= 2;
        }
        const o = e.getTypeOfExpression(r.d.expr, t).type;
        if (p.isFunction(o)) {
          if (p.FunctionType.isBuiltIn(o, 'abstractmethod')) {
            if (n) {
              i |= 8;
            }
          } else {
            if (p.FunctionType.isBuiltIn(o, 'final')) {
              i |= 8192;
            } else {
              if (p.FunctionType.isBuiltIn(o, 'override')) {
                i |= 262144;
              } else {
                if (p.FunctionType.isBuiltIn(o, 'type_check_only')) {
                  i |= 128;
                } else {
                  if (p.FunctionType.isBuiltIn(o, 'no_type_check')) {
                    i |= 524288;
                  } else {
                    if (p.FunctionType.isBuiltIn(o, 'overload')) {
                      i |= 256;
                    }
                  }
                }
              }
            }
          }
        } else {
          if (p.isClass(o)) {
            if (p.TypeBase.isInstantiable(o)) {
              if (p.ClassType.isBuiltIn(o, 'staticmethod')) {
                if (n) {
                  i |= 4;
                }
              } else {
                if (p.ClassType.isBuiltIn(o, 'classmethod') && n) {
                  i |= 2;
                }
              }
            } else {
              if (p.ClassType.isBuiltIn(o, 'deprecated')) {
                s = o.priv.deprecatedInstanceMessage;
              }
            }
          }
        }
      }
      return {
        flags: i,
        deprecationMessage: s
      };
    };
    exports.applyFunctionDecorator = function (e, t, n, a, i) {
      let c = r.getFileInfo(a).isStubFile ? 4 : 0;
      if (a.d.expr.nodeType !== 9) {
        c |= 2;
      }
      const u = e.getTypeOfExpression(a.d.expr, c).type;
      if ((p.isInstantiableClass(u) && p.ClassType.isSpecialBuiltIn(u, 'overload') || p.isFunction(u) && p.FunctionType.isBuiltIn(u, 'overload')) && p.isFunction(t)) {
        t.shared.flags |= 256;
        n.shared.flags |= 256;
        return t;
      }
      if (a.d.expr.nodeType === 9) {
        const r = e.getTypeOfExpression(a.d.expr.d.leftExpr, c | 2).type;
        if (p.isFunction(r) && (r.shared.name === '__dataclass_transform__' || p.FunctionType.isBuiltIn(r, 'dataclass_transform'))) {
          n.shared.decoratorDataClassBehaviors = s.validateDataClassTransformDecorator(e, a.d.expr);
          return t;
        }
      }
      let m = d(e, a, t);
      if (p.isFunction(u)) {
        if (p.FunctionType.isBuiltIn(u, 'abstractmethod')) {
          return t;
        }
        if (p.FunctionType.isBuiltIn(u, 'type_check_only')) {
          n.shared.flags |= 128;
          return t;
        }
        if (a.d.expr.nodeType === 35) {
          const n = e.getTypeOfExpression(a.d.expr.d.leftExpr, c | 2).type;
          if (l.isProperty(n)) {
            const r = a.d.expr.d.member.d.value;
            if (r === 'setter') {
              if (p.isFunction(t)) {
                o.validatePropertyMethod(e, t, a);
                return o.clonePropertyWithSetter(e, n, t, i);
              } else {
                return t;
              }
            }
            if (r === 'deleter') {
              if (p.isFunction(t)) {
                o.validatePropertyMethod(e, t, a);
                return o.clonePropertyWithDeleter(e, n, t, i);
              } else {
                return t;
              }
            }
          }
        }
      } else {
        if (p.isInstantiableClass(u)) {
          if (p.ClassType.isBuiltIn(u)) {
            switch (u.shared.name) {
              case 'classmethod':
              case 'staticmethod':
                {
                  const e = u.shared.name === 'classmethod' ? 2 : 4;
                  if (p.isFunction(t) && !(t.shared.flags & e)) {
                    const n = p.FunctionType.clone(t);
                    n.shared.flags &= -8;
                    n.shared.flags |= e;
                    return n;
                  }
                  return t;
                }
              case 'decorator':
                return t;
            }
          }
          if (p.ClassType.isPropertyClass(u)) {
            if (p.isFunction(t)) {
              o.validatePropertyMethod(e, t, a);
              return o.createProperty(e, a, u, t);
            }
            if (p.isClassInstance(t)) {
              const n = e.getBoundMagicMethod(t, '__call__');
              if (n && p.isFunction(n)) {
                return o.createProperty(e, a, u, n);
              } else {
                return p.UnknownType.create();
              }
            }
          }
        }
      }
      if (p.isFunction(t) && p.isFunction(m)) {
        m = p.FunctionType.clone(m);
        if (p.FunctionType.isOverloaded(t)) {
          m.shared.flags |= 256;
        }
        if (!m.shared.docString) {
          m.shared.docString = t.shared.docString;
        }
      }
      return m;
    };
    exports.applyClassDecorator = function (e, t, n, a) {
      let i = r.getFileInfo(a).isStubFile ? 4 : 0;
      if (a.d.expr.nodeType !== 9) {
        i |= 2;
      }
      const o = e.getTypeOfExpression(a.d.expr, i).type;
      if (a.d.expr.nodeType === 9) {
        const t = e.getTypeOfExpression(a.d.expr.d.leftExpr, i | 2).type;
        if (p.isFunction(t) && (t.shared.name === '__dataclass_transform__' || p.FunctionType.isBuiltIn(t, 'dataclass_transform'))) {
          n.shared.classDataClassTransform = s.validateDataClassTransformDecorator(e, a.d.expr);
        }
      }
      if (p.isOverloaded(o)) {
        const r = s.getDataclassDecoratorBehaviors(o);
        if (r) {
          s.applyDataClassDecorator(e, a, n, r, undefined);
          return t;
        }
      } else {
        if (p.isFunction(o)) {
          if (p.FunctionType.isBuiltIn(o, 'final')) {
            n.shared.flags |= 256;
            return t;
          }
          if (p.FunctionType.isBuiltIn(o, 'type_check_only')) {
            n.shared.flags |= 1048576;
            return t;
          }
          if (p.FunctionType.isBuiltIn(o, 'runtime_checkable')) {
            n.shared.flags |= 2048;
            return t;
          }
          let r;
          let l;
          if (a.d.expr.nodeType === 9) {
            l = a.d.expr;
            const t = e.getTypeOfExpression(l.d.leftExpr, i | 2).type;
            r = s.getDataclassDecoratorBehaviors(t);
          } else {
            const t = e.getTypeOfExpression(a.d.expr, i).type;
            r = s.getDataclassDecoratorBehaviors(t);
          }
          if (r) {
            s.applyDataClassDecorator(e, a, n, r, l);
            return t;
          }
        } else {
          if (p.isClassInstance(o) && p.ClassType.isBuiltIn(o, 'deprecated')) {
            n.shared.deprecatedMessage = o.priv.deprecatedInstanceMessage;
            return t;
          }
        }
      }
      return d(e, a, t);
    };
    exports.addOverloadsToFunctionType = function (e, t, n) {
      let s;
      let i;
      const o = r.getDeclaration(t);
      if (o) {
        s = o;
      }
      const l = e.lookUpSymbolRecursive(t, t.d.name.d.value, false);
      if (l) {
        const t = l.symbol.getDeclarations();
        const r = t.findIndex(e => e === s);
        if (r > 0) {
          for (let n = 0; n < r; n++) {
            const a = t[n];
            if (a.type === 5) {
              e.getTypeOfFunction(a.node);
            }
          }
          let s = [];
          const o = t[r - 1];
          if (o.type === 5) {
            const t = e.getTypeOfFunction(o.node);
            if (t) {
              if (p.isFunction(t.decoratedType)) {
                if (p.FunctionType.isOverloaded(t.decoratedType)) {
                  s.push(t.decoratedType);
                }
              } else {
                if (p.isOverloaded(t.decoratedType)) {
                  i = p.OverloadedType.getImplementation(t.decoratedType);
                  if (i) {
                    return n;
                  }
                  a.appendArray(s, p.OverloadedType.getOverloads(t.decoratedType));
                }
              }
            }
          }
          if (p.isFunction(n) && p.FunctionType.isOverloaded(n)) {
            s.push(n);
          } else {
            i = n;
          }
          if (s.length === 1 && !i) {
            return s[0];
          }
          if (s.length === 0 && i) {
            return i;
          }
          if (i && p.isFunction(i) && i.shared.docString) {
            const e = i.shared.docString;
            s = s.map(t => p.FunctionType.isOverloaded(t) && !t.shared.docString ? p.FunctionType.cloneWithDocString(t, e) : t);
          }
          if (i && p.isFunction(i) && i.shared.deprecatedMessage !== undefined) {
            const e = i.shared.deprecatedMessage;
            s = s.map(t => p.FunctionType.isOverloaded(t) && t.shared.deprecatedMessage === undefined ? p.FunctionType.cloneWithDeprecatedMessage(t, e) : t);
          }
          return p.OverloadedType.create(s, i);
        }
      }
      return n;
    };
    exports.getDeprecatedMessageFromCall = function (e) {
      if (e.d.args.length > 0 && e.d.args[0].d.argCategory === 0 && e.d.args[0].d.valueExpr.nodeType === 48) {
        const t = e.d.args[0].d.valueExpr.d.strings.map(e => e.d.value).join('');
        return i.convertDocStringToPlainText(t);
      }
      return '';
    };
    const a = require(58147);
    const r = require(26687);
    const s = require(57373);
    const i = require(12670);
    const o = require(89460);
    const l = require(92324);
    const p = require(21024);
    function d(e, t, n) {
      var a;
      var s;
      let i = r.getFileInfo(t).isStubFile ? 4 : 0;
      if (t.d.expr.nodeType !== 9) {
        i |= 2;
      }
      const o = e.getTypeOfExpression(t.d.expr, i);
      if (p.isInstantiableClass(o.type) && p.ClassType.isBuiltIn(o.type, 'classmethod') && l.isProperty(n)) {
        return n;
      }
      const d = [{
        argCategory: 0,
        typeResult: {
          type: n
        }
      }];
      const c = e.validateCallArgs(t.d.expr, d, o, undefined, true, undefined);
      e.setTypeResultForNode(t, {
        type: (a = c.returnType) !== null && a !== undefined ? a : p.UnknownType.create(),
        overloadsUsedForCall: c.overloadsUsedForCall,
        isIncomplete: c.isTypeIncomplete
      });
      const u = (s = c.returnType) !== null && s !== undefined ? s : p.UnknownType.create();
      if (!p.isFunction(u) || u.shared.declaredReturnType || u.shared.parameters.some((e, t) => !e.name || !!p.FunctionParam.isTypeDeclared(e) || e.category === 0 && (t !== 0 || !p.FunctionParam.isTypeInferred(e)))) {
        if (l.isPartlyUnknown(u) && p.isFunction(o.type) && !o.type.shared.parameters.find(e => p.FunctionParam.isTypeDeclared(e)) && o.type.shared.declaredReturnType === undefined) {
          return n;
        } else {
          return u;
        }
      } else {
        return n;
      }
    }
  },
  45579: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.deprecatedSpecialForms = exports.deprecatedAliases = undefined;
    const a = require(63808);
    exports.deprecatedAliases = new Map([['Tuple', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.tuple',
      replacementText: 'tuple'
    }], ['List', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.list',
      replacementText: 'list'
    }], ['Dict', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.dict',
      replacementText: 'dict'
    }], ['Set', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.set',
      replacementText: 'set'
    }], ['FrozenSet', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.frozenset',
      replacementText: 'frozenset'
    }], ['Type', {
      version: a.pythonVersion3_9,
      fullName: 'builtins.type',
      replacementText: 'type'
    }], ['Deque', {
      version: a.pythonVersion3_9,
      fullName: 'collections.deque',
      replacementText: 'collections.deque'
    }], ['DefaultDict', {
      version: a.pythonVersion3_9,
      fullName: 'collections.defaultdict',
      replacementText: 'collections.defaultdict'
    }], ['OrderedDict', {
      version: a.pythonVersion3_9,
      fullName: 'collections.OrderedDict',
      replacementText: 'collections.OrderedDict',
      typingImportOnly: true
    }], ['Counter', {
      version: a.pythonVersion3_9,
      fullName: 'collections.Counter',
      replacementText: 'collections.Counter',
      typingImportOnly: true
    }], ['ChainMap', {
      version: a.pythonVersion3_9,
      fullName: 'collections.ChainMap',
      replacementText: 'collections.ChainMap',
      typingImportOnly: true
    }], ['Awaitable', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Awaitable',
      replacementText: 'collections.abc.Awaitable',
      typingImportOnly: true
    }], ['Coroutine', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Coroutine',
      replacementText: 'collections.abc.Coroutine',
      typingImportOnly: true
    }], ['AsyncIterable', {
      version: a.pythonVersion3_9,
      fullName: 'typing.AsyncIterable',
      replacementText: 'collections.abc.AsyncIterable',
      typingImportOnly: true
    }], ['AsyncIterator', {
      version: a.pythonVersion3_9,
      fullName: 'typing.AsyncIterator',
      replacementText: 'collections.abc.AsyncIterator',
      typingImportOnly: true
    }], ['AsyncGenerator', {
      version: a.pythonVersion3_9,
      fullName: 'typing.AsyncGenerator',
      replacementText: 'collections.abc.AsyncGenerator',
      typingImportOnly: true
    }], ['Iterable', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Iterable',
      replacementText: 'collections.abc.Iterable',
      typingImportOnly: true
    }], ['Iterator', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Iterator',
      replacementText: 'collections.abc.Iterator',
      typingImportOnly: true
    }], ['Generator', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Generator',
      replacementText: 'collections.abc.Generator',
      typingImportOnly: true
    }], ['Reversible', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Reversible',
      replacementText: 'collections.abc.Reversible',
      typingImportOnly: true
    }], ['Container', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Container',
      replacementText: 'collections.abc.Container',
      typingImportOnly: true
    }], ['Collection', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Collection',
      replacementText: 'collections.abc.Collection',
      typingImportOnly: true
    }], ['AbstractSet', {
      version: a.pythonVersion3_9,
      fullName: 'typing.AbstractSet',
      replacementText: 'collections.abc.Set',
      typingImportOnly: true
    }], ['MutableSet', {
      version: a.pythonVersion3_9,
      fullName: 'typing.MutableSet',
      replacementText: 'collections.abc.MutableSet',
      typingImportOnly: true
    }], ['Mapping', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Mapping',
      replacementText: 'collections.abc.Mapping',
      typingImportOnly: true
    }], ['MutableMapping', {
      version: a.pythonVersion3_9,
      fullName: 'typing.MutableMapping',
      replacementText: 'collections.abc.MutableMapping',
      typingImportOnly: true
    }], ['Sequence', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Sequence',
      replacementText: 'collections.abc.Sequence',
      typingImportOnly: true
    }], ['MutableSequence', {
      version: a.pythonVersion3_9,
      fullName: 'typing.MutableSequence',
      replacementText: 'collections.abc.MutableSequence',
      typingImportOnly: true
    }], ['ByteString', {
      version: a.pythonVersion3_9,
      fullName: 'typing.ByteString',
      replacementText: 'collections.abc.ByteString',
      typingImportOnly: true
    }], ['MappingView', {
      version: a.pythonVersion3_9,
      fullName: 'typing.MappingView',
      replacementText: 'collections.abc.MappingView',
      typingImportOnly: true
    }], ['KeysView', {
      version: a.pythonVersion3_9,
      fullName: 'typing.KeysView',
      replacementText: 'collections.abc.KeysView',
      typingImportOnly: true
    }], ['ItemsView', {
      version: a.pythonVersion3_9,
      fullName: 'typing.ItemsView',
      replacementText: 'collections.abc.ItemsView',
      typingImportOnly: true
    }], ['ValuesView', {
      version: a.pythonVersion3_9,
      fullName: 'typing.ValuesView',
      replacementText: 'collections.abc.ValuesView',
      typingImportOnly: true
    }], ['ContextManager', {
      version: a.pythonVersion3_9,
      fullName: 'typing.ContextManager',
      replacementText: 'contextlib.AbstractContextManager'
    }], ['AsyncContextManager', {
      version: a.pythonVersion3_9,
      fullName: 'typing.AsyncContextManager',
      replacementText: 'contextlib.AbstractAsyncContextManager'
    }], ['Pattern', {
      version: a.pythonVersion3_9,
      fullName: 're.Pattern',
      replacementText: 're.Pattern',
      typingImportOnly: true
    }], ['Match', {
      version: a.pythonVersion3_9,
      fullName: 're.Match',
      replacementText: 're.Match',
      typingImportOnly: true
    }]]);
    exports.deprecatedSpecialForms = new Map([['Optional', {
      version: a.pythonVersion3_10,
      fullName: 'typing.Optional',
      replacementText: '| None'
    }], ['Union', {
      version: a.pythonVersion3_10,
      fullName: 'typing.Union',
      replacementText: '|'
    }], ['Callable', {
      version: a.pythonVersion3_9,
      fullName: 'typing.Callable',
      replacementText: 'collections.abc.Callable',
      typingImportOnly: true
    }]]);
  },
  12670: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.convertDocStringToMarkdown = function (e) {
      return new E(e).convert();
    };
    exports.convertDocStringToPlainText = function (e) {
      const t = a.cleanAndSplitDocString(e);
      const n = [];
      for (const e of t) {
        const t = n.length > 0 ? n[n.length - 1] : undefined;
        if (!O(e) || !O(t)) {
          n.push(e);
        }
      }
      return n.join('\n').trimEnd();
    };
    const a = require(81073);
    const r = /\S|$/;
    const s = /\S/;
    const i = /^\s*~~~+$/;
    const o = /^\s*\+\+\++$/;
    const l = /^\s*===+\s+===+$/;
    const p = /^\s*---+\s+---+$/;
    const d = /^(\s*)-\s/;
    const c = /^(\s*)\*\s/;
    const u = /^(\s*)\d+\.\s/;
    const m = /^(\s+\* )(.*)$/;
    const y = /^\s*\.\. /;
    const g = /^\s*\.\.\s+(.*)::\s*(.*)$/;
    const h = / *>>> /;
    const f = /^\s*:(param|arg|type|return|rtype|raise|except|var|ivar|cvar|copyright|license)/;
    const T = /^\.[\s\t]+(@\w)/gm;
    const v = /^(\.\s{3})|^(\.)/;
    const b = [{
      exp: /^\s*=+(\s+=+)+$/,
      replacement: '='
    }, {
      exp: /^\s*-+(\s+-+)+$/,
      replacement: '-'
    }, {
      exp: /^\s*~+(\s+-+)+$/,
      replacement: '~'
    }, {
      exp: /^\s*\++(\s+\++)+$/,
      replacement: '+'
    }];
    const _ = /\s/g;
    const C = /``/g;
    const I = /~/g;
    const k = /\+/g;
    const w = /(?<!\\)([_*~[\]])/g;
    const S = /(\[.*\]\(.*\))/g;
    const A = /^\s*(?<block>`{3}(?!`)|~{3}(?!~))(\w*)/;
    const x = /^\s*(?<block>`{3}(?!`)|~{3}(?!~))/;
    const P = [{
      exp: /</g,
      replacement: '&lt;'
    }, {
      exp: />/g,
      replacement: '&gt;'
    }];
    const D = '  \n';
    const N = /^\s*::$/;
    const F = [{
      exp: /\s+::$/g,
      replacement: ''
    }, {
      exp: /(\S)\s*::$/g,
      replacement: '$1:'
    }, {
      exp: /:[\w_\-+:.]+:`/g,
      replacement: '`'
    }, {
      exp: /`:[\w_\-+:.]+:/g,
      replacement: '`'
    }];
    class E {
      constructor(e) {
        this._builder = '';
        this._skipAppendEmptyLine = true;
        this._insideInlineCode = false;
        this._appendDirectiveBlock = false;
        this._stateStack = [];
        this._lineNum = 0;
        this._blockIndent = 0;
        this._state = this._parseText;
        this._input = e;
        this._lines = a.cleanAndSplitDocString(e);
      }
      convert() {
        for (T.test(this._input) && (this._lines = this._lines.map(e => e.replace(v, ''))); this._currentLineOrUndefined() !== undefined;) {
          const e = this._state;
          const t = this._lineNum;
          this._state();
          if (this._state === e && this._lineNum === t) {
            break;
          }
        }
        if (this._state === this._parseBacktickBlock || this._state === this._parseDocTest || this._state === this._parseLiteralBlock) {
          this._trimOutputAndAppendLine(this._lastBacktickString || '```');
        } else {
          if (this._insideInlineCode) {
            this._trimOutputAndAppendLine('`', true);
          }
        }
        return this._builder.trim();
      }
      _eatLine() {
        this._lineNum++;
      }
      _currentLineOrUndefined() {
        if (this._lineNum < this._lines.length) {
          return this._lines[this._lineNum];
        } else {
          return undefined;
        }
      }
      _currentLine() {
        return this._currentLineOrUndefined() || '';
      }
      _currentIndent() {
        return M(this._currentLine());
      }
      _prevIndent() {
        var e;
        return M((e = this._lineAt(this._lineNum - 1)) !== null && e !== undefined ? e : '');
      }
      _lineAt(e) {
        if (e < this._lines.length) {
          return this._lines[e];
        } else {
          return undefined;
        }
      }
      _nextBlockIndent() {
        return M(this._lines.slice(this._lineNum + 1).find(e => !O(e)) || '');
      }
      _currentLineIsOutsideBlock() {
        return this._currentIndent() < this._blockIndent;
      }
      _currentLineWithinBlock() {
        return this._currentLine().substr(this._blockIndent);
      }
      _pushAndSetState(e) {
        if (this._state === this._parseText) {
          this._insideInlineCode = false;
        }
        this._stateStack.push(this._state);
        this._state = e;
      }
      _popState() {
        this._state = this._stateStack.splice(0, 1)[0];
        if (this._state === this._parseText) {
          this._insideInlineCode = false;
        }
      }
      _parseText() {
        if (O(this._currentLineOrUndefined())) {
          this._state = this._parseEmpty;
          return;
        }
        if (this._beginBacktickBlock()) {
          return;
        }
        if (this._beginLiteralBlock()) {
          return;
        }
        if (this._beginDocTest()) {
          return;
        }
        if (this._beginDirective()) {
          return;
        }
        if (this._beginList()) {
          return;
        }
        if (this._beginFieldList()) {
          return;
        }
        if (this._beginTableBlock()) {
          return;
        }
        const e = this._formatPlainTextIndent(this._currentLine());
        this._appendTextLine(e);
        this._eatLine();
      }
      _formatPlainTextIndent(e) {
        const t = this._lineAt(this._lineNum - 1);
        const n = this._prevIndent();
        const a = this._currentIndent();
        if (!!(a > n) && !O(t) && !this._builder.endsWith(D) && !this._builder.endsWith('\n\n') && !z(t)) {
          this._builder = this._builder.slice(0, -1) + D;
        }
        if (n > a && !O(t) && !this._builder.endsWith(D) && !this._builder.endsWith('\n\n')) {
          this._builder = this._builder.slice(0, -1) + D;
        }
        return e = n === 0 || this._builder.endsWith(D) || this._builder.endsWith('\n\n') ? this._convertIndent(e) : e.trimStart();
      }
      _convertIndent(e) {
        return e = e.replace(/^([ \t]+)(.+)$/g, (e, t, n) => '&nbsp;'.repeat(t.length) + n);
      }
      _escapeHtml(e) {
        P.forEach(t => {
          e = e.replace(t.exp, t.replacement);
        });
        return e;
      }
      _appendTextLine(e) {
        const t = (e = this._preprocessTextLine(e)).split('`');
        for (let e = 0; e < t.length; e++) {
          let n = t[e];
          if (e > 0) {
            this._insideInlineCode = !this._insideInlineCode;
            this._append('`');
          }
          if (this._insideInlineCode) {
            this._append(n);
            continue;
          }
          n = this._escapeHtml(n);
          if (e === 0) {
            if (t.length === 1) {
              for (const e of b) {
                if (e.exp.test(n)) {
                  n = n.replace(_, e.replacement);
                  break;
                }
              }
              if (i.test(n)) {
                this._append(n.replace(I, '-'));
                continue;
              }
              if (o.test(n)) {
                this._append(n.replace(k, '-'));
                continue;
              }
            }
            const e = m.exec(n);
            if (e !== null && e.length === 3) {
              this._append(e[1]);
              n = e[2];
            }
          }
          n.split(S).forEach(e => {
            if (S.test(e)) {
              this._append(e);
            } else {
              this._append(e.replace(w, '\\$1'));
            }
          });
        }
        this._builder += '\n';
      }
      _preprocessTextLine(e) {
        if (N.test(e)) {
          return '';
        } else {
          F.forEach(t => e = e.replace(t.exp, t.replacement));
          return e = e.replace(C, '`');
        }
      }
      _parseEmpty() {
        if (O(this._currentLineOrUndefined())) {
          this._appendLine();
          this._eatLine();
          return;
        }
        this._state = this._parseText;
      }
      _beginMinIndentCodeBlock(e) {
        this._appendLine('```');
        this._pushAndSetState(e);
        this._blockIndent = this._currentIndent();
      }
      _beginBacktickBlock() {
        const e = this._currentLine().match(A);
        return e !== null && (this._blockIndent = this._currentIndent(), this._lastBacktickString = e[1], this._appendLine(e[1] + e[2]), this._pushAndSetState(this._parseBacktickBlock), this._eatLine(), true);
      }
      _parseBacktickBlock() {
        if (x.test(this._currentLine()) && this._currentIndent() === this._blockIndent) {
          const e = this._currentLine().match(x);
          this._lastBacktickString = e ? e[1] : '```';
          this._appendLine(this._lastBacktickString);
          this._appendLine();
          this._popState();
        } else {
          this._appendLine(this._currentLine());
        }
        this._eatLine();
      }
      _beginDocTest() {
        return !!h.test(this._currentLine()) && (this._beginMinIndentCodeBlock(this._parseDocTest), this._appendLine(this._currentLineWithinBlock()), this._eatLine(), true);
      }
      _parseDocTest() {
        if (this._currentLineIsOutsideBlock() || O(this._currentLine())) {
          this._trimOutputAndAppendLine('```');
          this._appendLine();
          this._popState();
          return;
        }
        this._appendLine(this._currentLineWithinBlock());
        this._eatLine();
      }
      _beginLiteralBlock() {
        const e = this._lineAt(this._lineNum - 1);
        if (e === undefined) {
          return false;
        }
        if (!O(e)) {
          return false;
        }
        let t = this._lineNum - 2;
        for (; t >= 0; t--) {
          const e = this._lineAt(t);
          if (!O(e)) {
            if (e.endsWith('::')) {
              break;
            }
            return false;
          }
        }
        return !(t < 0) && (this._currentIndent() === 0 ? (this._appendLine('```'), this._pushAndSetState(this._parseLiteralBlockSingleLine), true) : (this._beginMinIndentCodeBlock(this._parseLiteralBlock), true));
      }
      _parseLiteralBlock() {
        if (O(this._currentLineOrUndefined())) {
          this._appendLine();
          this._eatLine();
          return;
        }
        const e = this._lineAt(this._lineNum - 1);
        if (this._currentLineIsOutsideBlock() && O(e)) {
          this._trimOutputAndAppendLine('```');
          this._appendLine();
          this._popState();
          return;
        }
        this._appendLine(this._currentLine());
        this._eatLine();
      }
      _parseLiteralBlockSingleLine() {
        this._appendLine(this._currentLine());
        this._appendLine('```');
        this._appendLine();
        this._popState();
        this._eatLine();
      }
      _beginDirective() {
        return !!y.test(this._currentLine()) && (this._pushAndSetState(this._parseDirective), this._blockIndent = this._nextBlockIndent(), this._appendDirectiveBlock = false, true);
      }
      _beginFieldList() {
        if (this._insideInlineCode) {
          return false;
        }
        let e = this._currentLine();
        if (e.startsWith('@')) {
          this._appendLine();
          this._appendTextLine(e);
          this._eatLine();
          return true;
        }
        const t = !(e == null ? undefined : e.endsWith(':')) && !(e == null ? undefined : e.endsWith('::')) && !!e.match(/.*?\s*:\s*(.+)/gu);
        const n = f.test(e);
        if (t || n) {
          const t = this._lineAt(this._lineNum - 1);
          if (!this._builder.endsWith(D) && !this._builder.endsWith('\n\n') && !z(t)) {
            this._builder = this._builder.slice(0, -1) + D;
          }
          e = this._convertIndent(e);
          this._appendTextLine(e);
          this._eatLine();
          return true;
        }
        return false;
      }
      _beginTableBlock() {
        if (this._insideInlineCode) {
          return false;
        }
        const e = this._currentLine();
        return !!l.test(e) && (this._tableState = {
          header: e.trimStart(),
          inHeader: true
        }, this._eatLine(), this._pushAndSetState(this._parseTableBlock), true);
      }
      _parseTableBlock() {
        if (O(this._currentLineOrUndefined()) || !this._tableState) {
          this._tableState = undefined;
          this._popState();
          return;
        }
        let e = this._currentLine();
        if (l.test(e)) {
          this._eatLine();
          this._appendLine('\n<br/>\n');
          this._popState();
          this._tableState = undefined;
          return;
        }
        {
          let t = '|';
          const n = this._tableState.header.split(' ');
          const a = [];
          if (this._tableState.inHeader) {
            do {
              let t = 0;
              for (let r = 0; r < n.length; r++) {
                const s = n[r].length + 1;
                const i = e.slice(t, t + s);
                if (a[r] === undefined) {
                  a[r] = `${i} `;
                } else {
                  a[r] = a[r].concat(`<br>${i} `);
                }
                t += s;
              }
              this._eatLine();
              e = this._currentLine();
            } while (!O(this._currentLineOrUndefined()) && !p.test(e) && !l.test(e));
            this._tableState.inHeader = false;
            a.forEach(e => {
              t += `${e}|`;
            });
            this._appendLine(t);
            const r = e.trimStart().replace(/=/g, '-').replace(' ', '|');
            this._appendLine(`|${r}|`);
            this._eatLine();
          } else {
            let a = 0;
            n.forEach(n => {
              const r = n.length + 1;
              const s = e.slice(a, a + r);
              t += `${s}|`;
              a += r;
            });
            this._appendLine(t);
            this._eatLine();
          }
        }
      }
      _beginList() {
        if (this._insideInlineCode) {
          return false;
        }
        let e = this._currentLine();
        const t = d.exec(e);
        if ((t == null ? undefined : t.length) === 2) {
          if (t[1].length >= 4) {
            e = ' '.repeat(t[1].length / 2) + e.trimLeft();
          }
          this._appendTextLine(e);
          this._eatLine();
          if (this._state !== this._parseList) {
            this._pushAndSetState(this._parseList);
          }
          return true;
        }
        const n = c.exec(e);
        if ((n == null ? undefined : n.length) === 2) {
          if (n[1].length === 0) {
            e = e = ` ${e}`;
          } else {
            if (n[1].length >= 4) {
              e = ' '.repeat(n[1].length / 2) + e.trimLeft();
            }
          }
          this._appendTextLine(e);
          this._eatLine();
          if (this._state !== this._parseList) {
            this._pushAndSetState(this._parseList);
          }
          return true;
        }
        const a = u.exec(e);
        return (a == null ? undefined : a.length) === 2 && (this._appendTextLine(e), this._eatLine(), true);
      }
      _parseList() {
        if (O(this._currentLineOrUndefined()) || this._currentLineIsOutsideBlock()) {
          this._popState();
          return;
        }
        if (!this._beginList()) {
          const e = this._currentLine().trimStart();
          this._appendTextLine(e);
          this._eatLine();
        }
      }
      _parseDirective() {
        const e = g.exec(this._currentLine());
        if (e !== null && e.length === 3) {
          const t = e[1];
          const n = e[2];
          if (t === 'class') {
            this._appendDirectiveBlock = true;
            this._appendLine();
            this._appendLine('```');
            this._appendLine(n);
            this._appendLine('```');
            this._appendLine();
          } else {
            if (t === 'code-block') {
              this._appendDirectiveBlock = true;
              this._beginMinIndentCodeBlock(this._parseLiteralBlock);
              this._eatLine();
              return;
            }
          }
        }
        if (this._blockIndent === 0) {
          this._popState();
        } else {
          this._state = this._parseDirectiveBlock;
        }
        this._eatLine();
      }
      _parseDirectiveBlock() {
        if (O(this._currentLineOrUndefined()) || !this._currentLineIsOutsideBlock()) {
          if (this._appendDirectiveBlock) {
            this._appendTextLine(this._currentLine().trimLeft());
          }
          this._eatLine();
        } else {
          this._popState();
        }
      }
      _appendLine(e) {
        if (O(e)) {
          if (!this._skipAppendEmptyLine) {
            this._builder += '\n';
            this._skipAppendEmptyLine = true;
          }
        } else {
          this._builder += e + '\n';
          this._skipAppendEmptyLine = false;
        }
      }
      _append(e) {
        this._builder += e;
        this._skipAppendEmptyLine = false;
      }
      _trimOutputAndAppendLine(e, t = false) {
        this._builder = this._builder.trimRight();
        this._skipAppendEmptyLine = false;
        if (!t) {
          this._appendLine();
        }
        this._appendLine(e);
      }
    }
    function M(e) {
      return e.search(r);
    }
    function O(e) {
      return e === undefined || !s.test(e);
    }
    function z(e) {
      var t;
      var n;
      return e !== undefined && ((n = (t = e.match(/^\s*[#`~=-]{3,}/)) === null || t === undefined ? undefined : t.length) !== null && n !== undefined ? n : 0) > 0;
    }
  },
  81073: (module, exports) => {
    function n(e) {
      const t = e.replace(/\r/g, '').replace(/\t/g, '        ').split('\n');
      let n = Number.MAX_VALUE;
      t.forEach((e, a) => {
        if (t.length <= 1 || a > 0) {
          const t = e.trimLeft();
          if (t) {
            n = Math.min(n, e.length - t.length);
          }
        }
      });
      if (n >= Number.MAX_VALUE) {
        n = 0;
      }
      const a = [];
      for (t.forEach((e, t) => {
        if (t === 0) {
          a.push(e.trim());
        } else {
          a.push(e.substr(n).trimRight());
        }
      }); a.length > 0 && a[0].length === 0;) {
        a.shift();
      }
      while (a.length > 0 && a[a.length - 1].length === 0) {
        a.pop();
      }
      return a;
    }
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.cleanAndSplitDocString = n;
    exports.extractParameterDocumentation = function (e, t) {
      if (!e || !t) {
        return;
      }
      const a = n(e);
      for (const e of a) {
        const n = e.trim();
        let a = n.indexOf(`@param ${t}`);
        if (a >= 0) {
          return n.substr(a + 7);
        }
        a = n.indexOf(`:param ${t}`);
        if (a >= 0) {
          return n.substr(a + 7);
        }
        a = n.indexOf(t + ': ');
        if (a >= 0) {
          return n.substr(a);
        }
        a = n.indexOf(t + ' (');
        if (a >= 0) {
          return n.substr(a);
        }
      }
      return;
    };
  },
  21451: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.isEnumMetaclass = function (e) {
      return e.shared.mro.some(e => c.isClass(e) && c.ClassType.isBuiltIn(e, ['EnumMeta', 'EnumType']));
    };
    exports.isEnumClassWithMembers = function (e, t) {
      if (!c.isClass(t) || !c.ClassType.isEnumClass(t)) {
        return false;
      }
      let n = false;
      c.ClassType.getSymbolTable(t).forEach((a, r) => {
        const s = u(e, t, r);
        if (s && c.isClassInstance(s) && c.ClassType.isSameGenericClass(s, c.ClassType.cloneAsInstance(t))) {
          n = true;
        }
      });
      return n;
    };
    exports.createEnumType = function (e, t, n, a) {
      const r = s.getFileInfo(t);
      const l = y(n);
      if (a.length === 0) {
        return;
      }
      const p = a[0];
      if (p.argCategory !== 0 || !p.valueExpression || p.valueExpression.nodeType !== 48 || p.valueExpression.d.strings.length !== 1 || p.valueExpression.d.strings[0].nodeType !== 49) {
        return;
      }
      const u = p.valueExpression.d.strings.map(e => e.d.value).join('');
      const m = c.ClassType.createInstantiable(u, i.getClassFullName(t, r.moduleName, u), r.moduleName, r.fileUri, 4259840, i.getTypeSourceId(t), undefined, n.shared.effectiveMetaclass);
      m.shared.baseClasses.push(n);
      d.computeMroLinearization(m);
      const g = c.ClassType.getSymbolTable(m);
      g.set('__class__', o.Symbol.createWithType(68, m));
      if (a.length < 2) {
        return;
      }
      const h = a[1];
      if (h.argCategory !== 0 || !h.valueExpression) {
        return;
      }
      const f = e.getBuiltInType(t, 'int');
      if (!f || !c.isInstantiableClass(f)) {
        return;
      }
      const T = c.ClassType.cloneAsInstance(m);
      if (h.valueExpression.nodeType === 48) {
        if (!h.valueExpression.d.strings.every(e => e.nodeType === 49)) {
          return;
        }
        const e = h.valueExpression.d.strings.map(e => e.d.value).join('').trim().split(/[\s,]+/);
        for (const [t, n] of e.entries()) {
          if (!n) {
            return;
          }
          const e = c.ClassType.cloneWithLiteral(c.ClassType.cloneAsInstance(f), t + 1);
          const a = new c.EnumLiteral(m.shared.fullName, m.shared.name, n, e, l);
          const r = o.Symbol.createWithType(4, c.ClassType.cloneWithLiteral(T, a));
          g.set(n, r);
        }
        return m;
      }
      if (h.valueExpression.nodeType === 34 || h.valueExpression.nodeType === 52) {
        h.valueExpression.nodeType;
        const t = h.valueExpression.d.items;
        if (t.length === 0) {
          return;
        }
        let n = false;
        for (const [a, r] of t.entries()) {
          let t;
          let s;
          if (a === 0) {
            n = r.nodeType === 48;
          }
          if (r.nodeType === 48) {
            if (!n) {
              return;
            }
            t = r;
            s = c.ClassType.cloneWithLiteral(c.ClassType.cloneAsInstance(f), a + 1);
          } else {
            if (r.nodeType !== 52) {
              return;
            }
            if (n) {
              return;
            }
            if (r.d.items.length !== 2) {
              return;
            }
            t = r.d.items[0];
            s = e.getTypeOfExpression(r.d.items[1]).type;
          }
          if (t.nodeType !== 48 || t.d.strings.length !== 1 || t.d.strings[0].nodeType !== 49) {
            return;
          }
          const i = t.d.strings[0].d.value;
          const p = new c.EnumLiteral(m.shared.fullName, m.shared.name, i, s, l);
          const d = o.Symbol.createWithType(4, c.ClassType.cloneWithLiteral(T, p));
          g.set(i, d);
        }
      }
      if (h.valueExpression.nodeType === 18) {
        const t = h.valueExpression.d.items;
        if (t.length === 0) {
          return;
        }
        for (const n of t) {
          if (n.nodeType !== 20) {
            return;
          }
          const t = n.d.keyExpr;
          const a = e.getTypeOfExpression(n.d.valueExpr).type;
          if (t.nodeType !== 48 || t.d.strings.length !== 1 || t.d.strings[0].nodeType !== 49) {
            return;
          }
          const r = t.d.strings[0].d.value;
          const s = new c.EnumLiteral(m.shared.fullName, m.shared.name, r, a, l);
          const i = o.Symbol.createWithType(4, c.ClassType.cloneWithLiteral(T, s));
          g.set(r, i);
        }
      }
      return m;
    };
    exports.transformTypeForEnumMember = u;
    exports.isDeclInEnumClass = function (e, t) {
      const n = i.getEnclosingClass(t.node, true);
      if (!n) {
        return false;
      }
      const a = e.getTypeOfClass(n);
      if (!a) {
        return false;
      }
      return c.ClassType.isEnumClass(a.classType);
    };
    exports.getEnumDeclaredValueType = m;
    exports.getTypeOfEnumMember = function (e, t, n, r, s) {
      if (!c.ClassType.isEnumClass(n)) {
        return;
      }
      const i = u(e, n, r);
      if (i) {
        return {
          type: i,
          isIncomplete: s
        };
      }
      if (c.TypeBase.isInstantiable(n)) {
        return;
      }
      const o = n.priv.literalValue;
      if (r === 'name' || r === '_name_') {
        const i = d.lookUpClassMember(n, r);
        if (i && c.isClass(i.classType) && !c.ClassType.isBuiltIn(i.classType, 'Enum')) {
          return;
        }
        const l = e.getBuiltInType(t, 'str');
        if (!c.isInstantiableClass(l)) {
          return;
        }
        const u = e => c.ClassType.cloneAsInstance(c.ClassType.cloneWithLiteral(l, e.itemName));
        if (o) {
          a.assert(o instanceof c.EnumLiteral);
          return {
            type: u(o),
            isIncomplete: s
          };
        }
        const m = p.enumerateLiteralsForType(e, n);
        if (m && m.length > 0) {
          return {
            type: c.combineTypes(m.map(e => {
              const t = e.priv.literalValue;
              a.assert(t instanceof c.EnumLiteral);
              return u(t);
            })),
            isIncomplete: s
          };
        }
      }
      const l = m(e, n);
      if (r === 'value' || r === '_value_') {
        const t = d.lookUpClassMember(n, r);
        if (t && c.isClass(t.classType) && !c.ClassType.isBuiltIn(t.classType)) {
          return;
        }
        const i = n.shared.effectiveMetaclass;
        if (i && c.isClass(i) && !c.ClassType.isBuiltIn(i)) {
          return {
            type: l ?? c.AnyType.create(),
            isIncomplete: s
          };
        }
        const u = d.lookUpClassMember(n, '__new__', 4);
        const m = d.lookUpClassMember(n, '__init__', 4);
        if (u && c.isClass(u.classType) && !c.ClassType.isBuiltIn(u.classType)) {
          return {
            type: l ?? c.AnyType.create(),
            isIncomplete: s
          };
        }
        if (m && c.isClass(m.classType) && !c.ClassType.isBuiltIn(m.classType)) {
          return {
            type: l ?? c.AnyType.create(),
            isIncomplete: s
          };
        }
        if (o) {
          a.assert(o instanceof c.EnumLiteral);
          if (c.isAny(o.itemType)) {
            if (l) {
              return {
                type: l,
                isIncomplete: s
              };
            } else {
              return undefined;
            }
          } else {
            return {
              type: o.itemType,
              isIncomplete: s
            };
          }
        }
        const y = p.enumerateLiteralsForType(e, n);
        if (y && y.length > 0) {
          return {
            type: c.combineTypes(y.map(e => {
              const t = e.priv.literalValue;
              a.assert(t instanceof c.EnumLiteral);
              return t.itemType;
            })),
            isIncomplete: s
          };
        }
      }
      return;
    };
    exports.getEnumAutoValueType = function (e, t) {
      const n = i.getEnclosingClass(t);
      if (n) {
        const a = e.getTypeOfClass(n);
        if (a) {
          const n = e.getTypeOfBoundMember(t, c.ClassType.cloneAsInstance(a.classType), '_generate_next_value_');
          if (n && !n.typeErrors && c.isFunction(n.type) && n.classType && c.isClass(n.classType) && !c.ClassType.isBuiltIn(n.classType, 'Enum') && n.type.shared.declaredReturnType) {
            return n.type.shared.declaredReturnType;
          }
        }
      }
      return e.getBuiltInObject(t, 'int');
    };
    const a = require(48281);
    const r = require(63808);
    const s = require(26687);
    const i = require(41557);
    const o = require(58253);
    const l = require(12097);
    const p = require(18891);
    const d = require(92324);
    const c = require(21024);
    function u(e, t, n, a = false, i = 0) {
      var o;
      var p;
      var m;
      var g;
      var h;
      var f;
      var T;
      var v;
      if (i > c.maxTypeRecursionCount) {
        return;
      }
      i++;
      if (!c.ClassType.isEnumClass(t)) {
        return;
      }
      const b = d.lookUpClassMember(t, n);
      if (!b || !c.isClass(b.classType) || !c.ClassType.isEnumClass(b.classType)) {
        return;
      }
      const _ = b.symbol.getDeclarations();
      if (_.length < 1) {
        return;
      }
      const C = _[0];
      let I;
      let k;
      let w;
      let S = false;
      let A = false;
      if (C.node.nodeType === 38) {
        w = C.node;
      } else {
        if (C.node.nodeType !== 31 && C.node.nodeType !== 10) {
          return;
        }
        w = C.node.d.name;
      }
      if (((o = w.parent) === null || o === undefined ? undefined : o.nodeType) === 3 && w.parent.d.leftExpr === w) {
        S = true;
        I = w.parent.d.rightExpr;
      } else {
        if (((p = w.parent) === null || p === undefined ? undefined : p.nodeType) === 52 && ((m = w.parent.parent) === null || m === undefined ? undefined : m.nodeType) === 3) {
          S = true;
          A = true;
          I = w.parent.parent.d.rightExpr;
        } else {
          if (((g = w.parent) === null || g === undefined ? undefined : g.nodeType) === 54 && w.parent.d.valueExpr === w) {
            if (a) {
              S = true;
            }
            k = w.parent.d.annotation;
          }
        }
      }
      if (l.isSingleDunderName(n)) {
        return;
      }
      if (n === 'name' || n === 'value') {
        return;
      }
      const x = k ? e.getTypeOfAnnotation(k) : undefined;
      let P;
      if (I) {
        const t = s.getFileInfo(I).isStubFile ? 1 : undefined;
        P = e.getTypeOfExpression(I, t).type;
      }
      if ((I == null ? undefined : I.nodeType) === 38 && I.d.value !== n) {
        const n = u(e, t, I.d.value, false, i);
        if (n && c.isClassInstance(n) && c.ClassType.isSameGenericClass(n, c.ClassType.cloneAsInstance(b.classType)) && n.priv.literalValue !== undefined) {
          return n;
        }
      }
      if (C.node.nodeType === 31) {
        const t = e.getTypeOfFunction(C.node);
        if (t) {
          P = t.decoratedType;
        }
      } else {
        if (C.node.nodeType === 10) {
          const t = e.getTypeOfClass(C.node);
          if (t && (P = t.decoratedType, c.isInstantiableClass(P))) {
            const e = s.getFileInfo(C.node);
            S = r.PythonVersion.isLessThan(e.executionEnvironment.pythonVersion, r.pythonVersion3_13);
          }
        }
      }
      let D = (h = x ?? P) !== null && h !== undefined ? h : c.UnknownType.create();
      if (A) {
        D = (T = (f = e.getTypeOfIterator({
          type: D
        }, false, w, false)) === null || f === undefined ? undefined : f.type) !== null && T !== undefined ? T : c.UnknownType.create();
      }
      if (c.isClassInstance(D) && c.ClassType.getSymbolTable(D).get('__get__')) {
        return;
      }
      if (l.isPrivateName(n)) {
        return;
      }
      if (!c.findSubtype(D, e => !c.isFunction(e) && !c.isOverloaded(e))) {
        return;
      }
      if (!P && ((v = w.parent) === null || v === undefined ? undefined : v.nodeType) === 3 && w.parent.d.leftExpr === w) {
        P = e.getTypeOfExpression(w.parent.d.rightExpr, undefined, d.makeInferenceContext(x)).type;
      }
      if (P && c.isClassInstance(P) && c.ClassType.isBuiltIn(P)) {
        if (P.shared.fullName === 'enum.nonmember') {
          const t = P.priv.typeArgs && P.priv.typeArgs.length > 0 ? P.priv.typeArgs[0] : c.UnknownType.create();
          if (x && e.assignType(x, t)) {
            return x;
          } else {
            return t;
          }
        }
        if (P.shared.fullName === 'enum.member') {
          D = P.priv.typeArgs && P.priv.typeArgs.length > 0 ? P.priv.typeArgs[0] : c.UnknownType.create();
          S = true;
        }
      }
      if (!S) {
        return;
      }
      const N = new c.EnumLiteral(b.classType.shared.fullName, b.classType.shared.name, n, D, y(t));
      return c.ClassType.cloneAsInstance(c.ClassType.cloneWithLiteral(b.classType, N));
    }
    function m(e, t, n = false) {
      let a;
      const r = d.lookUpClassMember(t, '_value_', n ? 64 : 0);
      if (r && r.classType && c.isClass(r.classType) && !c.ClassType.isBuiltIn(r.classType, 'Enum')) {
        a = e.getTypeOfMember(r);
      }
      return a;
    }
    function y(e) {
      return e.shared.mro.some(e => c.isClass(e) && c.ClassType.isBuiltIn(e, 'ReprEnum'));
    }
  },
  39245: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.applyFunctionTransform = function (e, t, n, l, p) {
      if (i.isFunction(l) && l.shared.fullName === 'functools.total_ordering') {
        return function (e, t, n, l) {
          var p;
          if (n.length !== 1) {
            return l;
          }
          const d = (p = n[0].typeResult) === null || p === undefined ? undefined : p.type;
          if (!d || !i.isInstantiableClass(d) || d.priv.includeSubclasses) {
            return l;
          }
          const c = ['__lt__', '__le__', '__gt__', '__ge__'];
          const u = i.ClassType.cloneAsInstance(d);
          let m;
          const y = c.filter(e => {
            const t = o.lookUpObjectMember(u, e, 16);
            if (t && !m) {
              m = t;
            }
            return !t;
          });
          if (!m) {
            e.addDiagnostic(a.DiagnosticRule.reportGeneralTypeIssues, r.LocMessage.totalOrderingMissingMethod(), t);
            return l;
          }
          let g;
          const h = e.getTypeOfMember(m);
          if (i.isFunction(h) && h.shared.parameters.length >= 2 && i.FunctionParam.isTypeDeclared(h.shared.parameters[1])) {
            g = i.FunctionType.getParamType(h, 1);
          }
          if (!g) {
            const n = e.getBuiltInObject(t, 'object');
            if (!n || !i.isClassInstance(n)) {
              return l;
            }
            g = n;
          }
          const f = e.getBuiltInObject(t, 'bool');
          if (!f || !i.isClassInstance(f)) {
            return l;
          }
          const T = i.FunctionParam.create(0, o.synthesizeTypeVarForSelfCls(d, false), i.FunctionParamFlags.TypeDeclared, 'self');
          const v = i.FunctionParam.create(0, g, i.FunctionParamFlags.TypeDeclared, '__value');
          y.forEach(e => {
            const t = i.FunctionType.createSynthesizedInstance(e);
            i.FunctionType.addParam(t, T);
            i.FunctionType.addParam(t, v);
            t.shared.declaredReturnType = f;
            i.ClassType.getSymbolTable(d).set(e, s.Symbol.createWithType(4, t));
          });
          return l;
        }(e, t, n, p);
      }
      return p;
    };
    const a = require(65880);
    const r = require(67703);
    const s = require(58253);
    const i = require(21024);
    const o = require(92324);
  },
  75130: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ImportResolver = exports.supportedFileExtensions = undefined;
    exports.createImportedModuleDescriptor = I;
    exports.formatImportName = A;
    exports.getParentImportResolutionRoot = x;
    exports.getModuleNameFromPath = P;
    const i = require(58147);
    const o = require(12522);
    const l = require(4883);
    const p = require(54010);
    const d = require(63808);
    const c = require(71745);
    const u = __importStar(require(89740));
    const m = require(89740);
    const y = require(27113);
    const g = require(5884);
    const h = require(49969);
    const f = require(47610);
    const T = require(27670);
    const v = require(92031);
    const b = __importStar(require(16259));
    const _ = __importStar(require(12097));
    const C = require(12097);
    function I(e) {
      if (e.length === 0) {
        return {
          leadingDots: 0,
          nameParts: [],
          importedSymbols: new Set()
        };
      }
      let t = 0;
      let n = 0;
      for (; t < e.length && e[t] === '.'; t++) {
        n++;
      }
      return {
        leadingDots: n,
        nameParts: e.slice(t).split('.'),
        importedSymbols: new Set()
      };
    }
    const k = ['.pyd', '.so', '.dylib'];
    const w = ['.py', '.pyi'];
    exports.supportedFileExtensions = [...w, ...k];
    class S {
      constructor(e, t, n) {
        this.serviceProvider = e;
        this._configOptions = t;
        this.host = n;
        this._cachedImportResults = new Map();
        this._cachedModuleNameResults = new Map();
        this._cachedEntriesForPath = new Map();
        this._cachedFilesForPath = new Map();
        this._cachedDirExistenceForRoot = new Map();
        this.cachedParentImportResults = new T.ParentDirectoryCache(() => this.getPythonSearchPaths([]));
      }
      get fileSystem() {
        return this.serviceProvider.fs();
      }
      get tmp() {
        return this.serviceProvider.tmp();
      }
      get partialStubs() {
        return this.serviceProvider.tryGet(c.ServiceKeys.partialStubs);
      }
      static isSupportedImportSourceFile(e) {
        const t = e.lastExtension.toLowerCase();
        return w.some(e => t === e);
      }
      static isSupportedImportFile(e) {
        const n = e.lastExtension.toLowerCase();
        return exports.supportedFileExtensions.some(e => n === e);
      }
      invalidateCache() {
        var e;
        this._cachedImportResults = new Map();
        this._cachedModuleNameResults = new Map();
        this.cachedParentImportResults.reset();
        this._stdlibModules = undefined;
        this._invalidateFileSystemCache();
        if ((e = this.partialStubs) !== null && e !== undefined) {
          e.clearPartialStubs();
        }
      }
      resolveImport(e, t, n) {
        return this.resolveImportInternal(e, t, n);
      }
      getCompletionSuggestions(e, t, n) {
        const a = this._getCompletionSuggestionsStrict(e, t, n);
        if (n.leadingDots > 0) {
          return a;
        }
        const r = x(e, t.root);
        let s = e.getDirectory();
        while (this._shouldWalkUp(s, r, t) && s) {
          this._getCompletionSuggestionsAbsolute(e, t, s, n, a, false);
          s = this._tryWalkUp(s);
        }
        return a;
      }
      getConfigOptions() {
        return this._configOptions;
      }
      setConfigOptions(e) {
        this._configOptions = e;
        this.invalidateCache();
      }
      getSourceFilesFromStub(e, t, n) {
        const a = [];
        this._cachedImportResults.forEach(t => {
          t.forEach(t => {
            if (t.isStubFile && t.isImportFound && t.nonStubImportResult && t.resolvedUris[t.resolvedUris.length - 1].equals(e) && t.nonStubImportResult.isImportFound) {
              const e = t.nonStubImportResult.resolvedUris[t.nonStubImportResult.resolvedUris.length - 1];
              if (e.hasExtension('.py') || e.hasExtension('.pyi')) {
                a.push(e);
              }
            }
          });
        });
        if (a.length === 0) {
          const t = e.replaceExtension('.py');
          if (this.dirExistsCached(t)) {
            a.push(t);
          }
        }
        if (a.length === 0) {
          const n = this.getImportRoots(t);
          const r = [];
          for (const t of n) {
            if (e.isChild(t)) {
              const n = Array.from(t.getRelativePathComponents(e));
              if (n.length >= 1) {
                if (n[0].endsWith(l.stubsSuffix)) {
                  n[0] = n[0].slice(0, n[0].length - l.stubsSuffix.length);
                }
                r.push(n.join('/'));
              }
            }
          }
          for (const e of r) {
            for (const t of n) {
              let n = t.resolvePaths(e).replaceExtension('.py');
              if (this.fileExistsCached(n)) {
                a.push(n);
              } else {
                const e = n.stripExtension();
                if (e.pathEndsWith('__init__')) {
                  n = e.getDirectory().packageUri;
                  if (this.fileExistsCached(n)) {
                    a.push(n);
                  }
                } else {
                  n = e.initPyUri;
                  if (this.fileExistsCached(n)) {
                    a.push(n);
                  }
                }
              }
            }
          }
        }
        return a;
      }
      getModuleNameForImport(e, t, n = false, a = false) {
        var r;
        const s = i.getOrAdd(this._cachedModuleNameResults, (r = t.root) === null || r === undefined ? undefined : r.key, () => new Map());
        const o = `${n}.${a}.${e.key}`;
        return i.getOrAdd(s, o, () => this._getModuleNameForImport(e, t, n, a));
      }
      getTypeshedStdLibPath(e) {
        return this._getStdlibTypeshedPath(this._configOptions.typeshedPath, e.pythonVersion, e.pythonPlatform, []);
      }
      getTypeshedThirdPartyPath(e) {
        return this._getThirdPartyTypeshedPath(this._configOptions.typeshedPath, []);
      }
      isStdlibModule(e, t) {
        if (!this._stdlibModules) {
          this._stdlibModules = this._buildStdlibCache(this.getTypeshedStdLibPath(t), t);
        }
        return this._stdlibModules.has(e.nameParts.join('.'));
      }
      getImportRoots(e, t = false) {
        const n = [];
        const a = [];
        const r = this._getStdlibTypeshedPath(this._configOptions.typeshedPath, e.pythonVersion, e.pythonPlatform, n);
        if (r) {
          a.push(r);
        }
        if (e.root) {
          a.push(e.root);
        }
        i.appendArray(a, e.extraPaths);
        if (this._configOptions.stubPath) {
          a.push(this._configOptions.stubPath);
        }
        if (t) {
          const e = this._getThirdPartyTypeshedPath(this._configOptions.typeshedPath, n);
          if (e) {
            a.push(e.resolvePaths('...'));
          }
        } else {
          const e = this._getThirdPartyTypeshedPackageRoots(n);
          i.appendArray(a, e);
        }
        const s = this.getTypeshedPathEx(e, n);
        if (s) {
          a.push(s);
        }
        const o = this.getPythonSearchPaths(n);
        if (o.length > 0) {
          i.appendArray(a, o);
        }
        return a;
      }
      ensurePartialStubPackages(e) {
        var t;
        if (!this.partialStubs) {
          return false;
        }
        if (this.partialStubs.isPartialStubPackagesScanned(e)) {
          return false;
        }
        const n = this.partialStubs;
        const a = [];
        const r = [];
        const s = this.getTypeshedPathEx(e, a);
        i(this._configOptions.stubPath);
        i((t = e.root) !== null && t !== undefined ? t : this._configOptions.projectRoot);
        e.extraPaths.forEach(e => i(e));
        i(s);
        this.getPythonSearchPaths(a).forEach(e => i(e));
        this.partialStubs.processPartialStubPackages(r, this.getImportRoots(e), s);
        this._invalidateFileSystemCache();
        return true;
        function i(e) {
          if (e && !n.isPathScanned(e)) {
            r.push(e);
          }
        }
      }
      getPythonSearchPaths(e) {
        if (!this._cachedPythonSearchPaths) {
          const e = [];
          const t = (b.findPythonSearchPaths(this.fileSystem, this._configOptions, this.host, e) || []).map(e => this.fileSystem.realCasePath(e));
          this._cachedPythonSearchPaths = {
            paths: Array.from(new Set(t)),
            failureInfo: e
          };
        }
        e.push(...this._cachedPythonSearchPaths.failureInfo);
        return this._cachedPythonSearchPaths.paths;
      }
      getTypeshedStdlibExcludeList(e, t, n) {
        const a = this._getStdlibTypeshedPath(e, t, n, []);
        const r = [];
        if (a) {
          if (!this._cachedTypeshedStdLibModuleVersionInfo) {
            this._cachedTypeshedStdLibModuleVersionInfo = this._readTypeshedStdLibVersions(e, []);
          }
          this._cachedTypeshedStdLibModuleVersionInfo.forEach((e, s) => {
            let i = false;
            if (e.max !== undefined && d.PythonVersion.isGreaterThan(t, e.max)) {
              i = true;
            }
            if (n !== undefined) {
              const t = n.toLowerCase();
              if (e.supportedPlatforms && e.supportedPlatforms.every(e => e.toLowerCase() !== t)) {
                i = true;
              }
              if (e.unsupportedPlatforms && e.unsupportedPlatforms.some(e => e.toLowerCase() === t)) {
                i = true;
              }
            }
            if (i) {
              const e = a.combinePaths(...s.split('.'));
              r.push(e);
              const t = e.replaceExtension('.pyi');
              r.push(t);
            }
          });
          return r;
        } else {
          return r;
        }
      }
      getTypeshedPathEx(e, t) {}
      readdirEntriesCached(e) {
        const t = this._cachedEntriesForPath.get(e.key);
        if (t) {
          return t;
        }
        let n;
        try {
          n = this.fileSystem.readdirEntriesSync(e);
        } catch {
          n = [];
        }
        this._cachedEntriesForPath.set(e.key, n);
        return n;
      }
      resolveImportInternal(e, t, n) {
        const a = A(n);
        const r = this._resolveImportStrict(a, e, t, n, []);
        if (r.isImportFound || n.leadingDots > 0) {
          return r;
        }
        const s = e.getDirectory();
        const i = this.cachedParentImportResults.getImportResult(s, a, r);
        if (i) {
          return this.filterImplicitImports(i, n.importedSymbols);
        }
        const o = x(e, t.root);
        if (!this.cachedParentImportResults.checkValidPath(this.fileSystem, e, o)) {
          return r;
        }
        const l = [`Attempting to resolve using local imports: ${a}`];
        const p = {
          importPath: undefined
        };
        let d = s;
        while (this._shouldWalkUp(d, o, t) && d) {
          const r = this.resolveAbsoluteImport(e, d, t, n, a, l, undefined, undefined, false, true);
          this.cachedParentImportResults.checked(d, a, p);
          if (r.isImportFound) {
            p.importPath = d;
            this.cachedParentImportResults.add({
              importResult: r,
              path: d,
              importName: a
            });
            return this.filterImplicitImports(r, n.importedSymbols);
          }
          d = this._tryWalkUp(d);
        }
        if (d) {
          this.cachedParentImportResults.checked(d, a, p);
        }
        if (this._configOptions.verboseOutput) {
          const e = this.serviceProvider.console();
          l.forEach(t => e.log(t));
        }
        return r;
      }
      fileExistsCached(e) {
        const t = e.getDirectory();
        if (t.equals(e)) {
          return false;
        }
        const n = e.fileName;
        const a = this.readdirEntriesCached(t).find(e => e.name === n);
        if (a == null ? undefined : a.isFile()) {
          return true;
        }
        if (a == null ? undefined : a.isSymbolicLink()) {
          const t = g.tryRealpath(this.fileSystem, e);
          if (t && this.fileSystem.existsSync(t) && g.isFile(this.fileSystem, t)) {
            return true;
          }
        }
        return false;
      }
      dirExistsCached(e) {
        var t;
        var n;
        const a = e.getDirectory();
        if (a.equals(e)) {
          let a = this._cachedDirExistenceForRoot.get(e.key);
          if (a === undefined) {
            a = (n = (t = g.tryStat(this.fileSystem, e)) === null || t === undefined ? undefined : t.isDirectory()) !== null && n !== undefined && n;
            this._cachedDirExistenceForRoot.set(e.key, a);
          }
          return a;
        }
        const r = e.fileName;
        const s = this.readdirEntriesCached(a).find(e => e.name === r);
        if (s == null ? undefined : s.isDirectory()) {
          return true;
        }
        if (s == null ? undefined : s.isSymbolicLink()) {
          const t = g.tryRealpath(this.fileSystem, e);
          if (t && this.fileSystem.existsSync(t) && g.isDirectory(this.fileSystem, t)) {
            return true;
          }
        }
        return false;
      }
      addResultsToCache(e, t, n, a, r, s) {
        var o;
        const l = r && r.leadingDots > 0 ? e : undefined;
        i.getOrAdd(this._cachedImportResults, (o = t.root) === null || o === undefined ? undefined : o.key, () => new Map()).set(this._getImportCacheKey(l, n, s), a);
        return this.filterImplicitImports(a, r == null ? undefined : r.importedSymbols);
      }
      resolveAbsoluteImport(e, t, n, a, r, s, i = false, o = false, l = false, p = true, d = false) {
        if (p && l) {
          const e = this._resolveAbsoluteImport(t, n, a, r, s, i, false, true, true, true);
          if (e.packageDirectory && (!e.isNamespacePackage || e.isImportFound)) {
            return e;
          }
        }
        return this._resolveAbsoluteImport(t, n, a, r, s, i, o, false, p, d);
      }
      resolveImportEx(e, t, n, a, r = [], s = true) {}
      resolveNativeImportEx(e, t, n = []) {}
      getNativeModuleName(e) {
        if (N(e.lastExtension.toLowerCase())) {
          return p.stripFileExtension(e.fileName, true);
        }
      }
      filterImplicitImports(e, t) {
        if (t === undefined) {
          const t = Object.assign({}, e);
          t.filteredImplicitImports = new Map();
          return t;
        }
        if (t.size === 0) {
          return e;
        }
        if (e.implicitImports.size === 0) {
          return e;
        }
        const n = new Map();
        e.implicitImports.forEach(e => {
          if (t.has(e.name)) {
            n.set(e.name, e);
          }
        });
        if (n.size === e.implicitImports.size) {
          return e;
        }
        const a = Object.assign({}, e);
        a.filteredImplicitImports = n;
        return a;
      }
      _resolveImportStrict(e, t, n, a, r) {
        const s = o.matchFileSpecs(this._configOptions, t);
        const i = {
          importName: e,
          isRelative: false,
          isImportFound: false,
          isPartlyResolved: false,
          isNamespacePackage: false,
          isInitFilePresent: false,
          isStubPackage: false,
          importFailureInfo: r,
          resolvedUris: [],
          importType: 2,
          isStubFile: false,
          isNativeLib: false,
          implicitImports: new Map(),
          filteredImplicitImports: new Map(),
          nonStubImportResult: undefined
        };
        this.ensurePartialStubPackages(n);
        if (a.leadingDots > 0) {
          const i = this._lookUpResultsInCache(t, n, e, a, s);
          if (i) {
            return i;
          }
          const o = this._resolveRelativeImport(t, n, a, e, r);
          if (o) {
            o.isRelative = true;
            return this.addResultsToCache(t, n, e, o, a, s);
          }
        } else {
          const r = this._lookUpResultsInCache(t, n, e, a, s);
          if (r) {
            if (!r.isImportFound || !r.isNamespacePackage || !!this._isNamespacePackageResolved(a, r.implicitImports)) {
              return r;
            }
          }
          const o = this._resolveBestAbsoluteImport(t, n, a, true);
          if (o) {
            if (o.isStubFile) {
              o.nonStubImportResult = this._resolveBestAbsoluteImport(t, n, a, false) || i;
            }
            return this.addResultsToCache(t, n, e, o, a, s);
          }
        }
        return this.addResultsToCache(t, n, e, i, undefined, s);
      }
      _getCompletionSuggestionsStrict(e, t, n) {
        const a = [];
        const r = new Map();
        if (n.leadingDots > 0) {
          this._getCompletionSuggestionsRelative(e, t, n, r);
        } else {
          if (n.nameParts.length > 0) {
            this._getCompletionSuggestionsTypeshedPath(e, t, n, true, r);
          }
          if (t.root) {
            this._getCompletionSuggestionsAbsolute(e, t, t.root, n, r);
          }
          for (const a of t.extraPaths) {
            this._getCompletionSuggestionsAbsolute(e, t, a, n, r);
          }
          if (this._configOptions.stubPath) {
            this._getCompletionSuggestionsAbsolute(e, t, this._configOptions.stubPath, n, r);
          }
          this._getCompletionSuggestionsTypeshedPath(e, t, n, false, r);
          const s = this.getPythonSearchPaths(a);
          for (const a of s) {
            this._getCompletionSuggestionsAbsolute(e, t, a, n, r);
          }
        }
        return r;
      }
      _getModuleNameForImport(e, t, n, a) {
        let r;
        let s = 0;
        let i = false;
        let o = false;
        let l = false;
        const p = [];
        let d;
        const c = this._getStdlibTypeshedPath(this._configOptions.typeshedPath, t.pythonVersion, t.pythonPlatform, p);
        if (c && (r = P(c, e), r)) {
          const e = {
            leadingDots: 0,
            nameParts: r.split('.'),
            importedSymbols: undefined
          };
          if (this._isStdlibTypeshedStubValidForVersion(e, this._configOptions.typeshedPath, t.pythonVersion, t.pythonPlatform, [])) {
            return {
              moduleName: r,
              importType: s,
              isTypeshedFile: true,
              isLocalTypingsFile: i,
              isThirdPartyPyTypedPresent: o
            };
          }
        }
        if (t.root) {
          const n = D(t.root, e);
          if (n) {
            if (n.containsInvalidCharacters) {
              d = n.moduleName;
            } else {
              r = n.moduleName;
            }
          }
          s = 2;
        }
        for (const n of t.extraPaths) {
          const t = D(n, e);
          if (t) {
            if (t.containsInvalidCharacters) {
              d = t.moduleName;
            } else {
              const e = t.moduleName;
              if (!r || e && e.length < r.length) {
                r = e;
                s = 2;
              }
            }
          }
        }
        if (this._configOptions.stubPath) {
          const t = D(this._configOptions.stubPath, e);
          if (t) {
            if (t.containsInvalidCharacters) {
              d = t.moduleName;
            } else {
              const e = t.moduleName;
              if (!r || e && e.length < r.length) {
                r = e;
                s = 2;
                i = true;
              }
            }
          }
        }
        const u = this._getThirdPartyTypeshedPath(this._configOptions.typeshedPath, p);
        if (u) {
          const t = P(u, e, true);
          if (!r || t && t.length < r.length) {
            r = t;
            s = 1;
            l = true;
          }
        }
        const m = this.getTypeshedPathEx(t, p);
        if (m) {
          const t = P(m, e);
          if (!r || t && t.length < r.length) {
            r = t;
            s = 1;
            l = true;
          }
        }
        const y = this.getPythonSearchPaths(p);
        for (const t of y) {
          const n = D(t, e);
          if (n) {
            if (n.containsInvalidCharacters) {
              d = n.moduleName;
            } else {
              const e = n.moduleName;
              if (!r || e && e.length < r.length) {
                r = e;
                s = 1;
                l = false;
              }
            }
          }
        }
        if (a && s === 1) {
          const n = x(e, t.root);
          let a = e.getDirectory();
          while (this._shouldWalkUp(a, n, t)) {
            const e = this._getPyTypedInfo(a);
            if (e) {
              if (!e.isPartiallyTyped) {
                o = true;
              }
              break;
            }
            a = this._tryWalkUp(a);
          }
        }
        if (r) {
          return {
            moduleName: r,
            importType: s,
            isTypeshedFile: l,
            isLocalTypingsFile: i,
            isThirdPartyPyTypedPresent: o
          };
        } else {
          if (n && d) {
            return {
              moduleName: d,
              isTypeshedFile: l,
              importType: s,
              isLocalTypingsFile: i,
              isThirdPartyPyTypedPresent: o
            };
          } else {
            return {
              moduleName: '',
              isTypeshedFile: l,
              importType: 2,
              isLocalTypingsFile: i,
              isThirdPartyPyTypedPresent: o
            };
          }
        }
      }
      _invalidateFileSystemCache() {
        this._cachedEntriesForPath.clear();
        this._cachedFilesForPath.clear();
        this._cachedDirExistenceForRoot.clear();
      }
      _resolveAbsoluteImport(e, t, n, a, r, s, i, o, p, d) {
        if (o) {
          r.push(`Attempting to resolve stub package using root path '${e}'`);
        } else {
          r.push(`Attempting to resolve using root path '${e}'`);
        }
        const c = [];
        let u;
        let m;
        let g;
        let h = e;
        let f = false;
        let T = false;
        let v = false;
        let b = false;
        let _ = false;
        let C = new Map();
        if (n.nameParts.length === 0) {
          const e = h.initPyUri;
          const t = h.initPyiUri;
          if (p && this.fileExistsCached(t)) {
            r.push(`Resolved import with file '${t}'`);
            c.push(t);
            b = true;
          } else {
            if (this.fileExistsCached(e)) {
              r.push(`Resolved import with file '${e}'`);
              c.push(e);
            } else {
              r.push(`Partially resolved import with directory '${h}'`);
              c.push(y.Uri.empty());
              f = true;
            }
          }
          C = this._findImplicitImports(a, h, [e, t]);
        } else {
          for (let e = 0; e < n.nameParts.length; e++) {
            const s = e === 0;
            const g = e === n.nameParts.length - 1;
            h = h.combinePaths(n.nameParts[e]);
            if (o && s) {
              h = h.addPath(l.stubsSuffix);
              v = true;
            }
            const I = this.dirExistsCached(h);
            if (I) {
              if (s) {
                u = h;
              }
              const e = h.initPyUri;
              const t = h.initPyiUri;
              T = false;
              if (p && this.fileExistsCached(t)) {
                r.push(`Resolved import with file '${t}'`);
                c.push(t);
                if (g) {
                  b = true;
                }
                T = true;
              } else {
                if (this.fileExistsCached(e)) {
                  r.push(`Resolved import with file '${e}'`);
                  c.push(e);
                  T = true;
                }
              }
              if (!m && d) {
                m = this._getPyTypedInfo(h);
              }
              if (T) {
                if (!g) {
                  continue;
                }
                C = this._findImplicitImports(n.nameParts.join('.'), h, [e, t]);
                break;
              }
            }
            const k = h.packageUri;
            const w = h.packageStubUri;
            const S = h.getDirectory();
            if (p && this.fileExistsCached(w)) {
              r.push(`Resolved import with file '${w}'`);
              c.push(w);
              if (g) {
                b = true;
              }
            } else {
              if (this.fileExistsCached(k)) {
                r.push(`Resolved import with file '${k}'`);
                c.push(k);
              } else {
                if (i && this._findAndResolveNativeModule(S, h, t, a, n, r, c)) {
                  _ = true;
                  r.push(`Did not find file '${w}' or '${k}'`);
                } else {
                  if (I) {
                    if (!g) {
                      c.push(y.Uri.empty());
                      f = true;
                      m = undefined;
                      continue;
                    }
                    r.push(`Partially resolved import with directory '${h}'`);
                    c.push(y.Uri.empty());
                    if (g) {
                      C = this._findImplicitImports(a, h, [k, w]);
                      f = true;
                    }
                  }
                }
              }
            }
            if (!m && d) {
              m = this._getPyTypedInfo(S);
            }
            break;
          }
        }
        const I = c.length > 0 && c.length < n.nameParts.length;
        g = s ? c.length > 0 : c.length >= n.nameParts.length;
        return {
          importName: a,
          isRelative: false,
          isNamespacePackage: f,
          isInitFilePresent: T,
          isStubPackage: v,
          isImportFound: g,
          isPartlyResolved: I,
          importFailureInfo: r,
          importType: 2,
          resolvedUris: c,
          searchPath: e,
          isStubFile: b,
          isNativeLib: _,
          implicitImports: C,
          pyTypedInfo: m,
          filteredImplicitImports: C,
          packageDirectory: u
        };
      }
      _getImportCacheKey(e, t, n) {
        var a;
        return `${(a = e == null ? undefined : e.key) !== null && a !== undefined ? a : ''}-${t}-${n}`;
      }
      _lookUpResultsInCache(e, t, n, a, r) {
        var s;
        var i;
        const o = this._cachedImportResults.get((i = (s = t.root) === null || s === undefined ? undefined : s.key) !== null && i !== undefined ? i : '');
        if (!o) {
          return;
        }
        const l = a.leadingDots > 0 ? e : undefined;
        const p = o.get(this._getImportCacheKey(l, n, r));
        if (p) {
          return this.filterImplicitImports(p, a.importedSymbols);
        } else {
          return undefined;
        }
      }
      _isNamespacePackageResolved(e, t) {
        if (e.importedSymbols) {
          if (!Array.from(e.importedSymbols.keys()).some(e => t.has(e))) {
            return false;
          }
        } else {
          if (t.size === 0) {
            return false;
          }
        }
        return true;
      }
      _resolveBestAbsoluteImport(e, t, n, a) {
        const r = A(n);
        const s = [];
        if (a && this._configOptions.stubPath) {
          s.push(`Looking in stubPath '${this._configOptions.stubPath}'`);
          const i = this.resolveAbsoluteImport(e, this._configOptions.stubPath, t, n, r, s, undefined, false, true, a, false);
          if (i.isImportFound) {
            i.importType = 2;
            i.isLocalTypingsFile = true;
            if (!i.isNamespacePackage || !i.resolvedUris[i.resolvedUris.length - 1].isEmpty()) {
              return i;
            }
            if (this._isNamespacePackageResolved(n, i.implicitImports)) {
              return i;
            }
          }
        }
        let i;
        let o;
        if (t.root) {
          s.push(`Looking in root directory of execution environment '${t.root}'`);
          o = this.resolveAbsoluteImport(e, t.root, t, n, r, s, undefined, true, true, a, false);
          i = o;
        }
        for (const l of t.extraPaths) {
          s.push(`Looking in extraPath '${l}'`);
          o = this.resolveAbsoluteImport(e, l, t, n, r, s, undefined, true, true, a, false);
          i = this._pickBestImport(i, o, n);
        }
        if (a && n.nameParts.length > 0) {
          s.push('Looking for typeshed stdlib path');
          const e = this._findTypeshedPath(t, n, r, true, s);
          if (e) {
            e.isStdlibTypeshedFile = true;
            return e;
          }
        }
        const l = this.getPythonSearchPaths(s);
        if (l.length > 0) {
          for (const o of l) {
            s.push(`Looking in python search path '${o}'`);
            const l = this.resolveAbsoluteImport(e, o, t, n, r, s, false, true, true, a, true);
            if (l) {
              l.importType = 1;
              i = this._pickBestImport(i, l, n);
            }
          }
        } else {
          s.push('No python interpreter search path');
        }
        if (t.root !== this._getTypeshedRoot(this._configOptions.typeshedPath, s) && (i == null ? undefined : i.pyTypedInfo) && !i.isPartlyResolved) {
          return i;
        }
        const p = this.resolveImportEx(e, t, n, r, s, a);
        if (p) {
          return p;
        }
        if (a && n.nameParts.length > 0) {
          s.push('Looking for typeshed third-party path');
          const e = this._findTypeshedPath(t, n, r, false, s);
          if (e) {
            e.isThirdPartyTypeshedFile = true;
            i = this._pickBestImport(i, e, n);
          }
        }
        return i;
      }
      _pickBestImport(e, t, n) {
        if (!e) {
          return t;
        }
        if (!t) {
          return e;
        }
        if (t.isImportFound) {
          const a = e.resolvedUris.findIndex(e => !e.isEmpty());
          const r = t.resolvedUris.findIndex(e => !e.isEmpty());
          if (a !== r) {
            if (a < 0) {
              return t;
            } else {
              if (r < 0 || a < r) {
                return e;
              } else {
                return t;
              }
            }
          }
          if (!e.isImportFound) {
            return t;
          }
          if (e.isNamespacePackage && t.isNamespacePackage && n.importedSymbols && !this._isNamespacePackageResolved(n, e.implicitImports)) {
            if (this._isNamespacePackageResolved(n, t.implicitImports)) {
              return t;
            }
            if (e.isInitFilePresent && !t.isInitFilePresent) {
              return e;
            }
            if (!e.isInitFilePresent && t.isInitFilePresent) {
              return t;
            }
          }
          if (e.importType === 2 && t.importType === 1) {
            return e;
          }
          if (e.pyTypedInfo && !t.pyTypedInfo) {
            return e;
          }
          if (!e.pyTypedInfo && t.pyTypedInfo && e.importType === t.importType) {
            return t;
          }
          if (e.isStubFile && !t.isStubFile) {
            return e;
          }
          if (!e.isStubFile && t.isStubFile) {
            return t;
          }
          if (e.resolvedUris.length > t.resolvedUris.length) {
            return t;
          }
        } else {
          if (t.isPartlyResolved) {
            const n = e.resolvedUris.findIndex(e => !e.isEmpty());
            const a = t.resolvedUris.findIndex(e => !e.isEmpty());
            if (n !== a) {
              if (n < 0) {
                return t;
              } else {
                if (a < 0 || n < a) {
                  return e;
                } else {
                  return t;
                }
              }
            }
          }
        }
        return e;
      }
      _findTypeshedPath(e, t, n, a, r) {
        let s;
        r.push(`Looking for typeshed ${a ? b.stdLibFolderName : b.thirdPartyFolderName} path`);
        if (a) {
          const n = this._getStdlibTypeshedPath(this._configOptions.typeshedPath, e.pythonVersion, e.pythonPlatform, r, t);
          if (n) {
            s = [n];
          }
        } else {
          s = this._getThirdPartyTypeshedPackagePaths(t, r);
        }
        if (s) {
          for (const i of s) {
            if (this.dirExistsCached(i)) {
              const s = this.resolveAbsoluteImport(undefined, i, e, t, n, r);
              if (s.isImportFound) {
                let e = a ? 0 : 1;
                if (n === 'typing_extensions') {
                  e = 1;
                }
                s.importType = e;
                return s;
              }
            }
          }
        }
        r.push('Typeshed path not found');
      }
      _buildStdlibCache(e, t) {
        const n = new Set();
        if (e) {
          const a = (e, r) => {
            this.readdirEntriesCached(e).forEach(s => {
              if (s.isDirectory()) {
                const t = e.combinePaths(s.name);
                a(t, r ? `${r}.${s.name}` : s.name);
              } else {
                if (s.name.includes('.py')) {
                  const a = p.stripFileExtension(s.name);
                  if (!a.startsWith('_')) {
                    if (this._isStdlibTypeshedStubValidForVersion(I(a), e, t.pythonVersion, t.pythonPlatform, [])) {
                      n.add(r ? `${r}.${a}` : a);
                    }
                  }
                }
              }
            });
          };
          a(e, undefined);
        }
        return n;
      }
      _buildTypeshedThirdPartyPackageMap(e) {
        this._cachedTypeshedThirdPartyPackagePaths = new Map();
        if (e) {
          this.readdirEntriesCached(e).forEach(t => {
            if (t.isDirectory()) {
              const n = e.combinePaths(t.name);
              this.readdirEntriesCached(n).forEach(e => {
                if (e.name !== '@python2') {
                  if (e.isDirectory()) {
                    const t = this._cachedTypeshedThirdPartyPackagePaths.get(e.name);
                    if (t) {
                      t.push(n);
                    } else {
                      this._cachedTypeshedThirdPartyPackagePaths.set(e.name, [n]);
                    }
                  } else {
                    if (e.isFile() && e.name.endsWith('.pyi')) {
                      const t = p.stripFileExtension(e.name);
                      const a = this._cachedTypeshedThirdPartyPackagePaths.get(t);
                      if (a) {
                        a.push(n);
                      } else {
                        this._cachedTypeshedThirdPartyPackagePaths.set(t, [n]);
                      }
                    }
                  }
                }
              });
            }
          });
        }
        const t = Array.from(this._cachedTypeshedThirdPartyPackagePaths.values()).flatMap(e => e);
        this._cachedTypeshedThirdPartyPackageRoots = Array.from(new Set(t)).sort();
      }
      _getCompletionSuggestionsTypeshedPath(e, t, n, a, r) {
        const s = [];
        let i;
        if (a) {
          const e = this._getStdlibTypeshedPath(this._configOptions.typeshedPath, t.pythonVersion, t.pythonPlatform, s, n);
          if (e) {
            i = [e];
          }
        } else {
          i = this._getThirdPartyTypeshedPackagePaths(n, s, false);
          const e = this.getTypeshedPathEx(t, s);
          if (e) {
            i = i ?? [];
            i.push(e);
          }
        }
        if (i) {
          i.forEach(a => {
            if (this.dirExistsCached(a)) {
              this._getCompletionSuggestionsAbsolute(e, t, a, n, r);
            }
          });
        }
      }
      _getStdlibTypeshedPath(e, t, n, a, r) {
        const s = this._getTypeshedSubdirectory(true, e, a);
        if (!s || !r || this._isStdlibTypeshedStubValidForVersion(r, e, t, n, a)) {
          return s;
        }
      }
      _getThirdPartyTypeshedPath(e, t) {
        return this._getTypeshedSubdirectory(false, e, t);
      }
      _isStdlibTypeshedStubValidForVersion(e, t, n, a, r) {
        if (!this._cachedTypeshedStdLibModuleVersionInfo) {
          this._cachedTypeshedStdLibModuleVersionInfo = this._readTypeshedStdLibVersions(t, r);
        }
        for (let t = 1; t <= e.nameParts.length; t++) {
          const r = e.nameParts.slice(0, t);
          const s = this._cachedTypeshedStdLibModuleVersionInfo.get(r.join('.'));
          if (s) {
            if (d.PythonVersion.isLessThan(n, s.min)) {
              return false;
            }
            if (s.max !== undefined && d.PythonVersion.isGreaterThan(n, s.max)) {
              return false;
            }
            if (a !== undefined) {
              const e = a.toLowerCase();
              if (s.supportedPlatforms && s.supportedPlatforms.every(t => t.toLowerCase() !== e)) {
                return false;
              }
              if (s.unsupportedPlatforms && s.unsupportedPlatforms.some(t => t.toLowerCase() === e)) {
                return false;
              }
            }
          }
        }
        return true;
      }
      _readTypeshedStdLibVersions(e, t) {
        const n = new Map();
        const a = this._getTypeshedSubdirectory(true, e, t);
        if (a) {
          const e = a.combinePaths('VERSIONS');
          try {
            const a = this.fileSystem.statSync(e);
            if (a.size > 0 && a.size < 262144) {
              this.fileSystem.readFileSync(e, 'utf8').split(/\r?\n/).forEach(e => {
                const t = e.split('#')[0].split(';').map(e => e.trim());
                const a = t[0].split(':');
                if (a.length !== 2) {
                  return;
                }
                const r = a[1].split('-');
                if (r.length > 2) {
                  return;
                }
                const s = a[0].trim();
                if (!s) {
                  return;
                }
                let i = r[0].trim();
                if (i.endsWith('+')) {
                  i = i.substr(0, i.length - 1);
                }
                let o;
                let l;
                let p;
                let c = d.PythonVersion.fromString(i);
                if (!c) {
                  c = d.pythonVersion3_0;
                }
                if (r.length > 1) {
                  o = d.PythonVersion.fromString(r[1].trim());
                }
                const u = 'platforms=';
                let m = t.slice(1).find(e => e.startsWith(u));
                if (m) {
                  m = m.trim().substring(10);
                  const e = m.split(',');
                  for (let t of e) {
                    t = t.trim();
                    let e = false;
                    if (t.startsWith('!')) {
                      e = true;
                      t = t.substring(1);
                    }
                    if (e) {
                      p = p ?? [];
                      p.push(t);
                    } else {
                      l = l ?? [];
                      l.push(t);
                    }
                  }
                }
                n.set(s, {
                  min: c,
                  max: o,
                  supportedPlatforms: l,
                  unsupportedPlatforms: p
                });
              });
            } else {
              t.push('Typeshed stdlib VERSIONS file is unexpectedly large');
            }
          } catch (e) {
            t.push(`Could not read typeshed stdlib VERSIONS file: '${JSON.stringify(e)}'`);
          }
        }
        return n;
      }
      _getThirdPartyTypeshedPackagePaths(e, t, n = true) {
        const a = this._getThirdPartyTypeshedPath(this._configOptions.typeshedPath, t);
        if (!this._cachedTypeshedThirdPartyPackagePaths) {
          this._buildTypeshedThirdPartyPackageMap(a);
        }
        const r = e.nameParts.length > 0 ? e.nameParts[0] : '';
        if (n) {
          return this._cachedTypeshedThirdPartyPackagePaths.get(r);
        } else {
          if (r) {
            return i.flatten(i.getMapValues(this._cachedTypeshedThirdPartyPackagePaths, e => e.startsWith(r)));
          } else {
            return [];
          }
        }
      }
      _getThirdPartyTypeshedPackageRoots(e) {
        const t = this._getThirdPartyTypeshedPath(this._configOptions.typeshedPath, e);
        if (!this._cachedTypeshedThirdPartyPackagePaths) {
          this._buildTypeshedThirdPartyPackageMap(t);
        }
        return this._cachedTypeshedThirdPartyPackageRoots;
      }
      _getTypeshedRoot(e, t) {
        var n;
        if (this._cachedTypeshedRoot === undefined) {
          let t;
          if (e && this.dirExistsCached(e)) {
            t = e;
          }
          if (!t) {
            t = (n = b.getTypeShedFallbackPath(this.fileSystem)) !== null && n !== undefined ? n : y.Uri.empty();
          }
          this._cachedTypeshedRoot = t;
        }
        if (this._cachedTypeshedRoot.isEmpty()) {
          return undefined;
        } else {
          return this._cachedTypeshedRoot;
        }
      }
      _getTypeshedSubdirectory(e, t, n) {
        if (e) {
          if (this._cachedTypeshedStdLibPath !== undefined) {
            return this._cachedTypeshedStdLibPath;
          }
        } else {
          if (this._cachedTypeshedThirdPartyPath !== undefined) {
            return this._cachedTypeshedThirdPartyPath;
          }
        }
        let a = this._getTypeshedRoot(t, n);
        if (a !== undefined && (a = b.getTypeshedSubdirectory(a, e), this.dirExistsCached(a))) {
          if (e) {
            this._cachedTypeshedStdLibPath = a;
          } else {
            this._cachedTypeshedThirdPartyPath = a;
          }
          return a;
        }
      }
      _resolveRelativeImport(e, t, n, a, r) {
        r.push('Attempting to resolve relative import');
        const s = f.getDirectoryLeadingDotsPointsTo(e.getDirectory(), n.leadingDots);
        if (!s) {
          r.push(`Invalid relative path '${a}'`);
          return;
        }
        const i = this.resolveAbsoluteImport(e, s, t, n, a, r, false, true);
        if (i && i.isStubFile) {
          i.nonStubImportResult = this.resolveAbsoluteImport(e, s, t, n, a, r, false, true, false, false) || {
            importName: a,
            isRelative: true,
            isImportFound: false,
            isPartlyResolved: false,
            isNamespacePackage: false,
            isStubPackage: false,
            importFailureInfo: r,
            resolvedUris: [],
            importType: 2,
            isStubFile: false,
            isNativeLib: false,
            implicitImports: [],
            filteredImplicitImports: [],
            nonStubImportResult: undefined
          };
        }
        return i;
      }
      _getCompletionSuggestionsRelative(e, t, n, a) {
        const r = f.getDirectoryLeadingDotsPointsTo(e.getDirectory(), n.leadingDots);
        if (r) {
          this._getCompletionSuggestionsAbsolute(e, t, r, n, a);
        }
      }
      _getFilesInDirectory(e) {
        const t = this._cachedFilesForPath.get(e.key);
        if (t) {
          return t;
        }
        let n = [];
        try {
          const t = this.readdirEntriesCached(e);
          const a = t.filter(e => e.isFile());
          t.forEach(t => {
            var n;
            if (t.isSymbolicLink() && ((n = g.tryStat(this.fileSystem, e.combinePaths(t.name))) === null || n === undefined ? undefined : n.isFile())) {
              a.push(t);
            }
          });
          n = a.map(t => e.combinePaths(t.name));
        } catch {
          n = [];
        }
        this._cachedFilesForPath.set(e.key, n);
        return n;
      }
      _getCompletionSuggestionsAbsolute(e, t, n, a, r, s = true) {
        let i = n;
        const o = a.nameParts.map(e => e);
        if (a.hasTrailingDot) {
          o.push('');
        }
        const l = a.leadingDots;
        const p = o.slice(0, -1);
        if (o.length === 0) {
          this._addFilteredSuggestionsAbsolute(e, t, i, '', r, l, p, s);
        } else {
          for (let n = 0; n < o.length && (n === o.length - 1 && this._addFilteredSuggestionsAbsolute(e, t, i, o[n], r, l, p, s), i = i.combinePaths(o[n]), this.dirExistsCached(i)); n++);
        }
      }
      _addFilteredSuggestionsAbsolute(e, t, n, a, r, s, i, o) {
        const l = g.getFileSystemEntriesFromDirEntries(this.readdirEntriesCached(n), this.fileSystem, n);
        l.files.forEach(n => {
          const l = n.stripAllExtensions().fileName;
          if (S.isSupportedImportFile(n)) {
            if (l === '__init__') {
              return;
            }
            if (a && !u.isPatternInSymbol(a, l)) {
              return;
            }
            if (!this._isUniqueValidSuggestion(l, r) || !this._isResolvableSuggestion(l, s, i, e, t, o)) {
              return;
            }
            r.set(l, n);
          }
        });
        l.directories.forEach(n => {
          const l = n.fileName;
          if (a && !l.startsWith(a)) {
            return;
          }
          if (!this._isUniqueValidSuggestion(l, r) || !this._isResolvableSuggestion(l, s, i, e, t, o)) {
            return;
          }
          const p = n.initPyiUri;
          if (this.fileExistsCached(p)) {
            r.set(l, p);
            return;
          }
          const d = n.initPyUri;
          if (this.fileExistsCached(d)) {
            r.set(l, d);
          } else {
            r.set(l, y.Uri.empty());
          }
        });
      }
      _isResolvableSuggestion(e, t, n, a, r, s) {
        const i = {
          leadingDots: t,
          nameParts: [...n, e],
          importedSymbols: new Set()
        };
        let o;
        if (s) {
          const e = A(i);
          const t = [];
          o = this._resolveImportStrict(e, a, r, i, t);
        } else {
          o = this.resolveImportInternal(a, r, i);
        }
        return !!o && !!o.isImportFound && (!_.isPrivateOrProtectedName(e) || o.pyTypedInfo === undefined);
      }
      _isUniqueValidSuggestion(e, t) {
        return !t.has(e) && !/[.-]/.test(e) && (!C.isDunderName(e) || e === '__future__');
      }
      _findImplicitImports(e, t, n) {
        const a = new Map();
        const r = g.getFileSystemEntriesFromDirEntries(this.readdirEntriesCached(t), this.fileSystem, t);
        for (const t of r.files) {
          const r = t.lastExtension;
          let s;
          let i = false;
          if (r === '.py' || r === '.pyi') {
            s = p.stripFileExtension(t.fileName);
          } else {
            if (!N(r) || this.fileExistsCached(t.packageUri) || this.fileExistsCached(t.packageStubUri)) {
              continue;
            }
            s = t.stripAllExtensions().fileName;
            i = true;
          }
          if (!n.find(e => e.equals(t))) {
            const n = {
              isStubFile: t.hasExtension('.pyi'),
              isNativeLib: i,
              name: s,
              uri: t
            };
            const r = a.get(n.name);
            if (!r || !r.isStubFile) {
              if (i) {
                const a = t;
                const r = this.resolveNativeImportEx(a, `${e}.${s}`, []);
                if (r) {
                  n.uri = r;
                  n.isNativeLib = false;
                }
              }
              a.set(n.name, n);
            }
          }
        }
        for (const e of r.directories) {
          const t = e.initPyUri;
          const r = e.initPyiUri;
          let s;
          let i = false;
          if (this.fileExistsCached(r)) {
            i = true;
            s = r;
          } else {
            if (this.fileExistsCached(t)) {
              s = t;
            }
          }
          if (s && !n.find(e => e.equals(s))) {
            const t = {
              isStubFile: i,
              isNativeLib: false,
              name: e.fileName,
              uri: s,
              pyTypedInfo: this._getPyTypedInfo(e)
            };
            a.set(t.name, t);
          }
        }
        return a;
      }
      _getPyTypedInfo(e) {
        if (this.fileExistsCached(e.pytypedUri)) {
          return v.getPyTypedInfoForPyTypedFile(this.fileSystem, e.pytypedUri);
        }
      }
      _findAndResolveNativeModule(e, t, n, a, r, s, i) {
        let o = false;
        if (!n.skipNativeLibraries && this.dirExistsCached(e)) {
          const l = this._getFilesInDirectory(e);
          const p = t.fileName;
          const d = l.find(e => this._isNativeModuleFileName(p, e));
          if (d) {
            o = this._resolveNativeModuleWithStub(d, n, a, r, s, i);
            if (o) {
              s.push(`Resolved with native lib '${d.toUserVisibleString()}'`);
            }
          }
        }
        return o;
      }
      _resolveNativeModuleWithStub(e, t, n, a, r, s) {
        let i = n;
        if (a.leadingDots > 0) {
          const n = this.getModuleNameForImport(e, t);
          i = n.moduleName.length > 0 ? n.moduleName : i;
        }
        const o = this.resolveNativeImportEx(e, i, r);
        if (o) {
          r.push(`Resolved native import ${n} with stub '${o}'`);
          s.push(o);
          return false;
        } else {
          r.push(`Resolved import with file '${e}'`);
          s.push(e);
          return true;
        }
      }
      _isNativeModuleFileName(e, t) {
        const n = t.lastExtension.toLowerCase();
        const a = p.stripFileExtension(t.fileName, true);
        return N(n) && m.equateStringsCaseInsensitive(e, a);
      }
      _tryWalkUp(e) {
        if (!e || e.isEmpty() || e.isRoot()) {
          return;
        }
        const t = e.resolvePaths('..');
        if (t.equals(e)) {
          return undefined;
        } else {
          return t;
        }
      }
      _shouldWalkUp(e, t, n) {
        return e && !e.isEmpty() && (e.isChild(t) || e.equals(t) && F(n.root));
      }
    }
    function A(e) {
      return '.'.repeat(e.leadingDots) + e.nameParts.join('.');
    }
    function x(e, t) {
      if (F(t)) {
        return e.getDirectory();
      } else {
        return t;
      }
    }
    function P(e, t, n = false) {
      const a = D(e, t, n);
      if (a && !a.containsInvalidCharacters) {
        return a.moduleName;
      }
    }
    function D(e, t, n = false) {
      let a = t.stripExtension();
      if (N(t.lastExtension)) {
        a = a.stripExtension();
      }
      if (!a.startsWith(e)) {
        return;
      }
      if (a.pathEndsWith('__init__')) {
        a = a.getDirectory();
      }
      const r = Array.from(e.getRelativePathComponents(a));
      if (n) {
        if (r.length === 0) {
          return;
        }
        r.shift();
      }
      if (r.length === 0) {
        return;
      }
      if (r[0].endsWith(l.stubsSuffix)) {
        r[0] = r[0].substr(0, r[0].length - l.stubsSuffix.length);
      }
      const s = r.some(e => !h.Tokenizer.isPythonIdentifier(e));
      return {
        moduleName: r.join('.'),
        containsInvalidCharacters: s
      };
    }
    function N(e) {
      return k.some(t => t === e);
    }
    function F(e) {
      return !e || e.isEmpty() || y.Uri.isDefaultWorkspace(e);
    }
    exports.ImportResolver = S;
  },
  47610: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getImportGroup = h;
    exports.compareImportStatements = function (e, t) {
      const n = h(e);
      const a = h(t);
      if (n < a) {
        return -1;
      }
      if (n > a) {
        return 1;
      }
      if (e.moduleName < t.moduleName) {
        return -1;
      } else {
        return 1;
      }
    };
    exports.getTopLevelImports = function (e, t = false) {
      const n = {
        orderedImports: [],
        mapByFilePath: new Map()
      };
      let a = false;
      let r = false;
      e.d.statements.forEach(e => {
        if (e.nodeType === 47) {
          e.d.statements.forEach(e => {
            if (e.nodeType === 23) {
              r = true;
              (function (e, t, n) {
                e.d.list.forEach(a => {
                  const r = m.getImportInfo(a.d.module);
                  let s;
                  if (r && r.isImportFound) {
                    s = r.resolvedUris[r.resolvedUris.length - 1];
                  }
                  const i = {
                    node: e,
                    subnode: a,
                    importResult: r,
                    resolvedPath: s,
                    moduleName: C(a.d.module),
                    followsNonImportStatement: n
                  };
                  t.orderedImports.push(i);
                  if (s && !s.isEmpty()) {
                    if (!t.mapByFilePath.has(s.key)) {
                      t.mapByFilePath.set(s.key, i);
                    }
                  }
                });
              })(e, n, a);
              a = false;
            } else {
              if (e.nodeType === 25) {
                r = true;
                (function (e, t, n, a) {
                  var r;
                  const s = m.getImportInfo(e.d.module);
                  let i;
                  if (s && s.isImportFound) {
                    i = s.resolvedUris[s.resolvedUris.length - 1];
                  }
                  if (a && s) {
                    t.implicitImports = (r = t.implicitImports) !== null && r !== undefined ? r : new Map();
                    for (const n of s.implicitImports.values()) {
                      const a = e.d.imports.find(e => e.d.name.d.value === n.name);
                      if (a) {
                        t.implicitImports.set(n.uri.key, a);
                      }
                    }
                  }
                  const o = {
                    node: e,
                    importResult: s,
                    resolvedPath: i,
                    moduleName: C(e.d.module),
                    followsNonImportStatement: n
                  };
                  t.orderedImports.push(o);
                  if (i && !i.isEmpty()) {
                    const e = t.mapByFilePath.get(i.key);
                    if (!e || e.node.nodeType === 23 || e.moduleName.length > o.moduleName.length) {
                      t.mapByFilePath.set(i.key, o);
                    }
                  }
                })(e, n, a, t);
                a = false;
              } else {
                a = r;
              }
            }
          });
        } else {
          a = r;
        }
      });
      return n;
    };
    exports.getTextEditsForAutoImportSymbolAddition = function (e, t, n) {
      const a = [];
      if (!t.node || t.node.nodeType !== 25 || t.node.d.isWildcardImport) {
        return a;
      }
      const r = t.node;
      if ((e = (Array.isArray(e) ? e : [e]).filter(e => !!e.name && !r.d.imports.some(t => {
        var n;
        return t.d.name.d.value === e.name && ((n = t.d.alias) === null || n === undefined ? undefined : n.d.value) === e.alias;
      }))).length === 0) {
        return a;
      }
      for (const r of e) {
        a.push(v(r.name, r.alias, t.node, n));
      }
      const s = o.createMapFromItems(a, e => d.Range.print(e.range));
      const i = [];
      for (const e of s.values()) {
        if (e.length === 1) {
          i.push(e[0]);
        } else {
          i.push({
            range: e[0].range,
            replacementText: e.sort((e, t) => T(e.importName, t.importName)).map(e => e.replacementText).join('')
          });
        }
      }
      return i;
    };
    exports.getTextEditsForAutoImportInsertions = function (e, t, n, a) {
      const r = [];
      if ((e = Array.isArray(e) ? e : [e]).length === 0) {
        return [];
      }
      const s = o.createMapFromItems(e, e => {
        return `${e.module.moduleName}-${e.nameForImportFrom ?? ''}`;
      });
      for (const e of s.values()) {
        o.appendArray(r, _(e, {
          name: e[0].module.moduleName,
          nameForImportFrom: e[0].nameForImportFrom
        }, t, I(e[0].module), n, a));
      }
      return b(n, r);
    };
    exports.getTextEditsForAutoImportInsertion = function (e, t, n, a, r, s) {
      const i = _(e, t, n, a, r, s);
      return b(r, i);
    };
    exports.getContainingImportStatement = function (e, t) {
      while (e && (i.throwIfCancellationRequested(t), e.nodeType !== 23 && e.nodeType !== 25)) {
        e = e.parent;
      }
      return e;
    };
    exports.getAllImportNames = function (e) {
      if (e.nodeType === 23) {
        return e.d.list;
      }
      return e.d.imports;
    };
    exports.getImportGroupFromModuleNameAndType = I;
    exports.getTextRangeForImportNameDeletion = function (e, t, ...n) {
      const a = [];
      for (const r of function (e) {
        if (e.length === 0) {
          return [];
        }
        if (e.length === 1) {
          return [{
            start: e[0],
            end: e[0]
          }];
        }
        const t = [];
        let n = e[0];
        let a = n;
        for (const r of e) {
          if (a !== r) {
            if (a + 1 !== r) {
              t.push({
                start: n,
                end: a
              });
              n = r;
              a = r;
            } else {
              a = r;
            }
          }
        }
        t.push({
          start: n,
          end: a
        });
        return t;
      }(n)) {
        const n = t[r.start];
        const s = t[r.end];
        if (r.start === 0 && t.length === r.end + 1) {
          a.push(d.TextRange.fromBounds(n.start, d.TextRange.getEnd(s)));
        } else {
          if (r.end === t.length - 1) {
            const i = t[r.start - 1];
            a.push(...k(e, i, n, s));
          } else {
            const e = n.start;
            const s = t[r.end + 1].start - e;
            a.push({
              start: e,
              length: s
            });
          }
        }
      }
      return a;
    };
    exports.getRelativeModuleName = function (e, t, n, a, r = false, s) {
      let i;
      let o = t;
      if (s = s !== undefined ? s : u.isFile(e, t)) {
        o = t.getDirectory();
      }
      let l = n;
      if (a.stubPath && l.isChild(a.stubPath) || a.typeshedPath && l.isChild(a.typeshedPath)) {
        return;
      }
      if (s) {
        l = n.getDirectory();
        const e = n.stripAllExtensions().fileName;
        if (e !== '__init__') {
          i = e;
        } else {
          if (r) {
            i = l.fileName;
            l = l.getDirectory();
          }
        }
      }
      const p = o.getRelativePathComponents(l);
      let d = '.';
      for (let e = 0; e < p.length; e++) {
        const t = p[e];
        d += t === '..' ? '.' : t;
        if (t !== '..' && e !== p.length - 1) {
          d += '.';
        }
      }
      if (i) {
        d = d[d.length - 1] === '.' ? d + i : d + '.' + i;
      }
      return d;
    };
    exports.getDirectoryLeadingDotsPointsTo = function (e, t) {
      let n = e;
      for (let e = 1; e < t; e++) {
        if (n.isRoot()) {
          return;
        }
        n = n.getDirectory();
      }
      return n;
    };
    exports.getResolvedFilePath = function (e) {
      if (!e || !e.isImportFound || e.resolvedUris.length === 0) {
        return;
      }
      if (e.resolvedUris.length === 1 && e.resolvedUris[0].equals(c.Uri.empty())) {
        if (e.packageDirectory) {
          return e.packageDirectory;
        } else {
          if (e.searchPath) {
            return e.searchPath;
          } else {
            return undefined;
          }
        }
      }
      return e.resolvedUris[e.resolvedUris.length - 1];
    };
    exports.haveSameParentModule = function (e, t) {
      if (e.length !== t.length) {
        return false;
      }
      let n = 0;
      for (n = 0; n < e.length - 1 && e[n] === t[n]; n++);
      return n === e.length - 1;
    };
    const i = require(91426);
    const o = require(58147);
    const l = require(56814);
    const p = require(89740);
    const d = require(88754);
    const c = require(27113);
    const u = require(5884);
    const m = __importStar(require(26687));
    const y = require(41557);
    const g = __importStar(require(12097));
    function h(e) {
      if (e.importResult) {
        if (e.importResult.importType === 0) {
          return 0;
        } else {
          if (e.importResult.importType === 1 || e.importResult.isLocalTypingsFile) {
            return 1;
          } else {
            if (e.importResult.isRelative) {
              return 3;
            } else {
              return 2;
            }
          }
        }
      } else {
        return 2;
      }
    }
    function f(e) {
      if (g.isConstantName(e)) {
        return 0;
      } else {
        if (g.isTypeAliasName(e)) {
          return 1;
        } else {
          return 2;
        }
      }
    }
    function T(e, t) {
      const n = f(e) - f(t);
      if (n !== 0) {
        return n;
      }
      const a = e.replace(/_/g, '=');
      const r = t.replace(/_/g, '=');
      return p.compareStringsCaseSensitive(a, r);
    }
    function v(e, t, n, a) {
      let r;
      for (const t of n.d.imports) {
        if (T(t.d.name.d.value, e) > 0) {
          break;
        }
        r = t;
      }
      let s = false;
      let i = '';
      if (n.d.imports.length > 0) {
        const e = l.convertOffsetToPosition(n.start, a.tokenizerOutput.lines);
        const t = l.convertOffsetToPosition(n.d.imports[0].start, a.tokenizerOutput.lines);
        const r = n.d.imports.length > 1 ? l.convertOffsetToPosition(n.d.imports[1].start, a.tokenizerOutput.lines) : undefined;
        if (t.line > e.line && (r === undefined || r.line > t.line)) {
          const e = a.tokenizerOutput.lines.getItemAt(t.line);
          i = a.text.substr(e.start, t.character);
          if (/^\s*$/.test(i)) {
            s = true;
          }
        }
      }
      const o = r ? d.TextRange.getEnd(r) : n.d.imports.length > 0 ? n.d.imports[0].start : n.start + n.length;
      const p = l.convertOffsetToPosition(o, a.tokenizerOutput.lines);
      const c = t ? `${e} as ${t}` : `${e}`;
      let u;
      if (s) {
        const e = a.tokenizerOutput.predominantEndOfLineSequence;
        u = r ? `,${e}${i}${c}` : `${c},${e}${i}`;
      } else {
        u = r ? `, ${c}` : `${c}, `;
      }
      return {
        range: {
          start: p,
          end: p
        },
        importName: e,
        replacementText: u
      };
    }
    function b(e, t) {
      if (t.length < 2) {
        return t.map(e => r(e));
      }
      const n = [...o.createMapFromItems(t, e => `${e.importGroup} ${d.Range.print(e.range)}`)].sort((e, t) => p.compareStringsCaseSensitive(e[0], t[0])).map(e => e[1]);
      const a = [];
      for (const t of n) {
        if (t.length === 1) {
          a.push(r(t[0]));
        } else {
          a.push({
            range: t[0].range,
            replacementText: t[0].preChange + t.map(e => e.importStatement).sort((e, t) => s(e, t)).join(e.tokenizerOutput.predominantEndOfLineSequence) + t[0].postChange
          });
        }
      }
      return a;
      function r(e) {
        return {
          range: e.range,
          replacementText: e.preChange + e.importStatement + e.postChange
        };
      }
      function s(e, t) {
        const n = e.startsWith('import');
        if (n === t.startsWith('import')) {
          if (e < t) {
            return -1;
          } else {
            return 1;
          }
        } else {
          if (n) {
            return -1;
          } else {
            return 1;
          }
        }
      }
    }
    function _(e, t, n, a, r, s) {
      const i = [];
      if ((e = Array.isArray(e) ? e : [e]).length === 0) {
        e.push({});
      }
      const p = o.createMapFromItems(e, e => e.name ? 'from' : 'import');
      const c = p.get('import');
      if (c) {
        m(c, e => `import ${e.join(', ')}`);
      }
      const u = p.get('from');
      if (u) {
        m(u, e => {
          var n;
          return `from ${(n = t.nameForImportFrom) !== null && n !== undefined ? n : t.name} import ${e.join(', ')}`;
        });
      }
      return i;
      function m(e, p) {
        const c = e.map(e => function (e, t) {
          const n = e.name ? e.name : t;
          return {
            sortText: n,
            text: e.alias ? `${n} as ${e.alias}` : n
          };
        }(e, t.name)).sort((e, t) => T(e.sortText, t.sortText)).reduce((e, t) => o.addIfUnique(e, t.text), []);
        i.push(function (e, t, n, a, r, s) {
          let i;
          let o = '';
          let p = '';
          const c = l.convertPositionToOffset(s, r.tokenizerOutput.lines);
          if (t.orderedImports.length > 0 && c > t.orderedImports[0].node.start) {
            let e = true;
            let s = t.orderedImports[0];
            let c = 0;
            for (const i of t.orderedImports) {
              const l = i.importResult ? h(i) : c;
              if (a < l) {
                if (!e && c < a) {
                  o = r.tokenizerOutput.predominantEndOfLineSequence + o;
                }
                break;
              }
              if (a === l && i.moduleName > n) {
                e = true;
                s = i;
                break;
              }
              if (i.followsNonImportStatement) {
                if (a > c) {
                  o = r.tokenizerOutput.predominantEndOfLineSequence + o;
                }
                break;
              }
              if (i === t.orderedImports[t.orderedImports.length - 1] && a > l) {
                o = r.tokenizerOutput.predominantEndOfLineSequence + o;
              }
              e = !e && a < c && a === l;
              c = l;
              s = i;
            }
            if (s) {
              if (e) {
                p += r.tokenizerOutput.predominantEndOfLineSequence;
              } else {
                o = r.tokenizerOutput.predominantEndOfLineSequence + o;
              }
              i = l.convertOffsetToPosition(e ? s.node.start : d.TextRange.getEnd(s.node), r.tokenizerOutput.lines);
            } else {
              i = {
                line: 0,
                character: 0
              };
            }
          } else {
            i = {
              line: 0,
              character: 0
            };
            let e = false;
            for (const t of r.parserOutput.parseTree.d.statements) {
              let n = true;
              if (t.nodeType === 47 && t.d.statements.length === 1) {
                const e = t.d.statements[0];
                if (e.nodeType === 48 || e.nodeType === 3 && e.d.leftExpr.nodeType === 38 && g.isDunderName(e.d.leftExpr.d.value)) {
                  n = false;
                }
              }
              if (n) {
                i = l.convertOffsetToPosition(t.start, r.tokenizerOutput.lines);
                e = false;
                break;
              }
              i = l.convertOffsetToPosition(t.start + t.length, r.tokenizerOutput.lines);
              e = true;
            }
            p = p + r.tokenizerOutput.predominantEndOfLineSequence + r.tokenizerOutput.predominantEndOfLineSequence;
            if (e) {
              o = r.tokenizerOutput.predominantEndOfLineSequence + o;
            } else {
              p += r.tokenizerOutput.predominantEndOfLineSequence;
            }
          }
          return {
            range: {
              start: i,
              end: i
            },
            preChange: o,
            importStatement: e,
            postChange: p,
            importGroup: a
          };
        }(p(c), n, t.name, a, r, s));
      }
    }
    function C(e) {
      let t = '';
      for (let n = 0; n < e.d.leadingDots; n++) {
        t += '.';
      }
      t += e.d.nameParts.map(e => e.d.value).join('.');
      return t;
    }
    function I(e) {
      let t = 2;
      if (e.isLocalTypingsFile || e.importType === 1) {
        t = 1;
      } else {
        if (e.importType === 0) {
          t = 0;
        }
      }
      return t;
    }
    function k(e, t, n, a) {
      const r = d.TextRange.getEnd(t);
      const s = y.getTokenAt(e.tokenizerOutput.tokens, n.start);
      if (!s || !s.comments || s.comments.length === 0) {
        return [{
          start: r,
          length: d.TextRange.getEnd(a) - r
        }];
      }
      const i = y.findTokenAfter(e.tokenizerOutput, d.TextRange.getEnd(t), e => e.type === 12);
      if (!i) {
        return [{
          start: r,
          length: d.TextRange.getEnd(a) - r
        }];
      }
      const o = d.TextRange.getEnd(i) - r;
      const l = d.TextRange.getEnd(s.comments[s.comments.length - 1]);
      return [{
        start: r,
        length: o
      }, {
        start: l,
        length: d.TextRange.getEnd(a) - l
      }];
    }
  },
  60055: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createNamedTupleType = function (e, t, n, a) {
      var r;
      var s;
      var d;
      const v = c.getFileInfo(t);
      let b = 'namedtuple';
      const _ = new Set();
      let C = false;
      if (!a) {
        const e = n.find(e => {
          var t;
          return e.argCategory === 0 && ((t = e.name) === null || t === undefined ? undefined : t.d.value) === 'rename';
        });
        if (e == null ? undefined : e.valueExpression) {
          if (m.evaluateStaticBoolExpression(e.valueExpression, v.executionEnvironment, v.definedConstants) === true) {
            C = true;
          }
        }
      }
      if (n.length === 0) {
        e.addDiagnostic(i.DiagnosticRule.reportCallIssue, p.LocMessage.namedTupleFirstArg(), t);
      } else {
        const a = n[0];
        if (a.argCategory !== 0) {
          e.addDiagnostic(i.DiagnosticRule.reportArgumentType, p.LocMessage.namedTupleFirstArg(), n[0].valueExpression || t);
        } else {
          if (a.valueExpression && a.valueExpression.nodeType === 48) {
            b = a.valueExpression.d.strings.map(e => e.d.value).join('');
          }
        }
      }
      const I = n.find(e => {
        var t;
        return ((t = e.name) === null || t === undefined ? undefined : t.d.value) === 'defaults';
      });
      let k = 0;
      if (I && I.valueExpression) {
        const t = e.getTypeOfExpression(I.valueExpression).type;
        k = h.isClassInstance(t) && g.isTupleClass(t) && !g.isUnboundedTupleClass(t) && t.priv.tupleTypeArgs ? t.priv.tupleTypeArgs.length : undefined;
      }
      const w = e.getTypingType(t, 'NamedTuple') || h.UnknownType.create();
      const S = h.ClassType.createInstantiable(b, u.getClassFullName(t, v.moduleName, b), v.moduleName, v.fileUri, 4194304, u.getTypeSourceId(t), undefined, h.isInstantiableClass(w) ? w.shared.effectiveMetaclass : h.UnknownType.create());
      S.shared.baseClasses.push(w);
      S.shared.typeVarScopeId = u.getScopeIdForNode(t);
      const A = h.ClassType.getSymbolTable(S);
      A.set('__class__', y.Symbol.createWithType(68, S));
      const x = g.synthesizeTypeVarForSelfCls(S, true);
      const P = h.FunctionType.createSynthesizedInstance('__new__', 1);
      P.shared.declaredReturnType = g.convertToInstance(x);
      P.priv.constructorTypeVarScopeId = g.getTypeVarScopeId(S);
      if (u.isAssignmentToDefaultsFollowingNamedTuple(t)) {
        P.shared.flags |= 32;
      }
      P.shared.typeVarScopeId = S.shared.typeVarScopeId;
      h.FunctionType.addParam(P, h.FunctionParam.create(0, x, h.FunctionParamFlags.TypeDeclared, 'cls'));
      const D = [];
      const N = h.FunctionParam.create(0, g.synthesizeTypeVarForSelfCls(S, false), h.FunctionParamFlags.TypeDeclared, 'self');
      let F = false;
      const E = [];
      if (n.length < 2) {
        e.addDiagnostic(i.DiagnosticRule.reportCallIssue, p.LocMessage.namedTupleSecondArg(), t);
        F = true;
      } else {
        const t = n[1];
        if (t.argCategory !== 0) {
          F = true;
        } else {
          if (!a && t.valueExpression && t.valueExpression.nodeType === 48) {
            const n = t.valueExpression.d.strings.map(e => e.d.value).join('').split(/[,\s]+/);
            const a = k === undefined ? 0 : Math.max(0, n.length - k);
            n.forEach((n, r) => {
              if (n = n.trim()) {
                n = T(e, n, C, t.valueExpression, r);
                const s = h.UnknownType.create();
                const i = h.FunctionParam.create(0, s, h.FunctionParamFlags.TypeDeclared, n, r >= a ? s : undefined);
                h.FunctionType.addParam(P, i);
                const p = y.Symbol.createWithType(8, s);
                D.push(n);
                const d = t.valueExpression;
                const c = {
                  type: 1,
                  node: d,
                  isRuntimeTypeExpression: true,
                  uri: v.fileUri,
                  range: o.convertOffsetsToRange(d.start, l.TextRange.getEnd(d), v.lines),
                  moduleName: v.moduleName,
                  isInExceptSuite: false
                };
                p.addDeclaration(c);
                A.set(n, p);
                E.push(s);
              }
            });
          } else {
            if (((r = t.valueExpression) === null || r === undefined ? undefined : r.nodeType) === 34 || ((s = t.valueExpression) === null || s === undefined ? undefined : s.nodeType) === 52) {
              const n = t.valueExpression;
              const r = new Map();
              if ((d = t.valueExpression) !== null && d !== undefined) {
                d.nodeType;
              }
              const s = t.valueExpression.d.items;
              const c = k === undefined ? 0 : Math.max(0, s.length - k);
              s.forEach((t, n) => {
                let s;
                let d;
                let u;
                let m = '';
                if (a) {
                  if (t.nodeType === 52 && t.d.items.length === 2) {
                    u = t.d.items[0];
                    s = t.d.items[1];
                    d = g.convertToInstance(e.getTypeOfExpressionExpectingType(s).type);
                  } else {
                    e.addDiagnostic(i.DiagnosticRule.reportArgumentType, p.LocMessage.namedTupleNameType(), t);
                  }
                } else {
                  u = t;
                  d = h.UnknownType.create();
                }
                if (u) {
                  const t = e.getTypeOfExpression(u);
                  if (h.isClassInstance(t.type) && h.ClassType.isBuiltIn(t.type, 'str') && g.isLiteralType(t.type)) {
                    m = t.type.priv.literalValue;
                    if (m) {
                      m = T(e, m, C, u, n);
                    } else {
                      e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, p.LocMessage.namedTupleEmptyName(), u);
                    }
                  } else {
                    F = true;
                  }
                } else {
                  F = true;
                }
                if (!m) {
                  m = `_${n.toString()}`;
                }
                if (r.has(m)) {
                  e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, p.LocMessage.namedTupleNameUnique(), u || t);
                }
                r.set(m, m);
                if (!d) {
                  d = h.UnknownType.create();
                }
                const f = h.FunctionParam.create(0, d, a ? h.FunctionParamFlags.TypeDeclared : h.FunctionParamFlags.None, m, n >= c ? d : undefined);
                h.FunctionType.addParam(P, f);
                E.push(d);
                D.push(m);
                const b = y.Symbol.createWithType(2056, d);
                if (u && u.nodeType === 48) {
                  const e = {
                    type: 1,
                    node: u,
                    uri: v.fileUri,
                    typeAnnotationNode: s,
                    range: o.convertOffsetsToRange(u.start, l.TextRange.getEnd(u), v.lines),
                    moduleName: v.moduleName,
                    isInExceptSuite: false
                  };
                  b.addDeclaration(e);
                }
                A.set(m, b);
                _.add(m);
              });
              e.setTypeResultForNode(n, {
                type: h.UnknownType.create()
              });
            } else {
              F = true;
            }
          }
          if (t.valueExpression && !F) {
            e.setTypeResultForNode(t.valueExpression, {
              type: h.AnyType.create()
            });
          }
        }
      }
      S.shared.namedTupleEntries = _;
      if (F) {
        P.shared.parameters = [];
        h.FunctionType.addDefaultParams(P);
        E.push(h.AnyType.create(false));
        E.push(h.AnyType.create(true));
      }
      const M = h.FunctionType.createSynthesizedInstance('__init__');
      h.FunctionType.addParam(M, N);
      h.FunctionType.addDefaultParams(M);
      M.shared.declaredReturnType = e.getNoneType();
      M.priv.constructorTypeVarScopeId = g.getTypeVarScopeId(S);
      A.set('__new__', y.Symbol.createWithType(4, P));
      A.set('__init__', y.Symbol.createWithType(4, M));
      const O = h.FunctionType.createSynthesizedInstance('__len__');
      O.shared.declaredReturnType = e.getBuiltInObject(t, 'int');
      h.FunctionType.addParam(O, N);
      A.set('__len__', y.Symbol.createWithType(4, O));
      if (F) {
        const n = h.FunctionType.createSynthesizedInstance('__getattribute__');
        n.shared.declaredReturnType = h.AnyType.create();
        h.FunctionType.addParam(n, N);
        h.FunctionType.addParam(n, h.FunctionParam.create(0, e.getBuiltInObject(t, 'str'), h.FunctionParamFlags.TypeDeclared, 'name'));
        A.set('__getattribute__', y.Symbol.createWithType(4, n));
      }
      const z = e.getBuiltInType(t, 'tuple');
      const U = e.getBuiltInType(t, 'str');
      if (!F && U && h.isInstantiableClass(U) && z && h.isInstantiableClass(z)) {
        const e = D.map(e => ({
          type: h.ClassType.cloneAsInstance(h.ClassType.cloneWithLiteral(U, e)),
          isUnbounded: false
        }));
        const t = h.ClassType.cloneAsInstance(g.specializeTupleClass(z, e));
        A.set('__match_args__', y.Symbol.createWithType(4, t));
      }
      f(S, E, !F);
      g.computeMroLinearization(S);
      return S;
    };
    exports.updateNamedTupleBaseClass = f;
    const i = require(65880);
    const o = require(56814);
    const l = require(88754);
    const p = require(67703);
    const d = require(49969);
    const c = require(26687);
    const u = __importStar(require(41557));
    const m = require(28676);
    const y = require(58253);
    const g = require(92324);
    const h = require(21024);
    function f(e, t, n) {
      let a = false;
      e.shared.baseClasses = e.shared.baseClasses.map(e => {
        if (!h.isInstantiableClass(e) || !h.ClassType.isBuiltIn(e, 'NamedTuple')) {
          return e;
        }
        const r = [];
        if (n) {
          t.forEach(e => {
            r.push({
              type: e,
              isUnbounded: false
            });
          });
        } else {
          r.push({
            type: t.length > 0 ? h.combineTypes(t) : h.UnknownType.create(),
            isUnbounded: true
          });
        }
        const s = h.ClassType.specialize(e, undefined, n);
        s.shared = {
          ...s.shared
        };
        s.shared.baseClasses = s.shared.baseClasses.map(e => h.isInstantiableClass(e) && h.ClassType.isBuiltIn(e, 'tuple') ? g.specializeTupleClass(e, r, n) : e);
        g.computeMroLinearization(s);
        a = true;
        return s;
      });
      return a;
    }
    function T(e, t, n, a, r) {
      if (d.Tokenizer.isPythonKeyword(t)) {
        if (n) {
          return `_${r}`;
        } else {
          e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, p.LocMessage.namedTupleNameKeyword(), a);
          return t;
        }
      } else {
        return t;
      }
    }
  },
  19327: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.validateBinaryOperation = h;
    exports.getTypeOfBinaryOperation = function e(t, n, p, d) {
      const m = n.d.leftExpr;
      let g = n.d.rightExpr;
      let T = false;
      let v = false;
      if (l.operatorSupportsChaining(n.d.operator) && g.nodeType === 7 && !g.d.hasParens && l.operatorSupportsChaining(g.d.operator)) {
        e(t, g, p, d);
        g = g.d.leftExpr;
      }
      let b;
      let _ = n.d.operator === 37 || n.d.operator === 36 ? d == null ? undefined : d.expectedType : undefined;
      if (n.d.operator === 26 && d && u.isClassInstance(d.expectedType) && u.ClassType.isBuiltIn(d.expectedType, 'list') && d.expectedType.priv.typeArgs && d.expectedType.priv.typeArgs.length >= 1 && n.d.leftExpr.nodeType === 34) {
        b = d.expectedType;
      }
      const C = _ ?? b;
      const I = t.getTypeOfExpression(m, p, c.makeInferenceContext(C));
      let k = I.type;
      if (!_) {
        if (n.d.operator === 37 || n.d.operator === 36) {
          if (c.someSubtypes(k, e => !!u.isClassInstance(e) && (u.ClassType.isTypedDictClass(e) || e.shared.typeParams.length > 0))) {
            _ = k;
          }
        } else {
          if (n.d.operator === 0 && n.d.rightExpr.nodeType === 34 || n.d.operator === 6 && u.isClassInstance(k) && u.ClassType.isTypedDictClass(k)) {
            _ = k;
          }
        }
      }
      const w = t.getTypeOfExpression(g, p, c.makeInferenceContext(_));
      let S = w.type;
      if (I.isIncomplete || w.isIncomplete) {
        T = true;
      }
      if (n.d.operator === 6 && !f(k, '__or__') && !f(S, '__ror__')) {
        let e = S;
        let a = k;
        if (!c.isNoneInstance(k) && c.isNoneInstance(S)) {
          e = c.convertToInstantiable(t.getNoneType());
        } else {
          if (!c.isNoneInstance(S) && c.isNoneInstance(k)) {
            a = c.convertToInstantiable(t.getNoneType());
          }
        }
        if (c.isUnionableType([a, e])) {
          if (u.isInstantiableClass(a)) {
            a = c.specializeWithDefaultTypeArgs(a);
          }
          if (u.isInstantiableClass(e)) {
            e = c.specializeWithDefaultTypeArgs(e);
          }
          return function (e, t, n, a, l, p, d) {
            var c;
            var m;
            const y = t.d.leftExpr;
            const g = t.d.rightExpr;
            const h = o.getFileInfo(t);
            const f = h.isStubFile || !!(n & 4) || s.PythonVersion.isGreaterOrEqualTo(h.executionEnvironment.pythonVersion, s.pythonVersion3_10);
            if (!f && !u.isAnyOrUnknown(d)) {
              e.addDiagnostic(r.DiagnosticRule.reportGeneralTypeIssues, i.LocMessage.unionSyntaxIllegal(), t, t.d.operatorToken);
            }
            const T = e.validateTypeArg({
              ...a,
              node: y
            });
            const v = e.validateTypeArg({
              ...l,
              node: g
            });
            if (!T || !v) {
              return {
                type: u.UnknownType.create()
              };
            }
            d = e.reportMissingTypeArgs(t.d.leftExpr, d, n | 128);
            p = e.reportMissingTypeArgs(t.d.rightExpr, p, n | 128);
            let b = u.combineTypes([d, p], {
              skipElideRedundantLiterals: true
            });
            const _ = e.getUnionClassType();
            if (_ && u.isInstantiableClass(_)) {
              b = u.TypeBase.cloneAsSpecialForm(b, u.ClassType.cloneAsInstance(_));
            }
            if (((c = a.type.props) === null || c === undefined ? undefined : c.typeForm) && ((m = l.type.props) === null || m === undefined ? undefined : m.typeForm)) {
              const e = u.combineTypes([a.type.props.typeForm, l.type.props.typeForm]);
              b = u.TypeBase.cloneWithTypeForm(b, e);
            }
            if (!h.isStubFile) {
              let t;
              let n;
              let s;
              if (y.nodeType === 48) {
                t = y;
                n = g;
                s = l.type;
              } else {
                if (g.nodeType === 48) {
                  t = g;
                  n = y;
                  s = a.type;
                }
              }
              if (t && n && s) {
                let n = true;
                if (u.isClass(s)) {
                  if (!s.priv.isTypeArgExplicit || !!u.isClassInstance(s)) {
                    n = false;
                  }
                }
                if (!n) {
                  e.addDiagnostic(r.DiagnosticRule.reportGeneralTypeIssues, i.LocMessage.unionForwardReferenceNotAllowed(), t);
                }
              }
            }
            return {
              type: b
            };
          }(t, n, p, I, w, e, a);
        }
      }
      if (p & 256 && n.d.operator !== 6) {
        t.addDiagnostic(r.DiagnosticRule.reportInvalidTypeForm, i.LocMessage.binaryOperationNotAllowed(), n);
        return {
          type: u.UnknownType.create()
        };
      }
      let A = false;
      if (y[n.d.operator] === undefined) {
        if (n.d.operator === 12 || n.d.operator === 28) {
          k = c.removeNoneFromUnion(k);
        } else {
          A = c.isOptionalType(k);
        }
        if (n.d.operator === 12 || n.d.operator === 28) {
          S = c.removeNoneFromUnion(S);
        }
      }
      const x = new a.DiagnosticAddendum();
      const P = !l.isWithinLoop(n) && !l.getEnclosingLambda(n);
      const D = !u.isUnion(k);
      const N = h(t, n.d.operator, {
        type: k,
        isIncomplete: I.isIncomplete
      }, {
        type: S,
        isIncomplete: w.isIncomplete
      }, n, d, x, {
        isLiteralMathAllowed: P,
        isTupleAddAllowed: D
      });
      if (N.isIncomplete) {
        T = true;
      }
      if (!x.isEmpty() && (v = true, !T)) {
        if (A && x.getMessages().length === 1) {
          t.addDiagnostic(r.DiagnosticRule.reportOptionalOperand, i.LocMessage.noneOperator().format({
            operator: l.printOperator(n.d.operator)
          }), n.d.leftExpr);
        } else {
          let e = '';
          if (u.isUnion(t.makeTopLevelTypeVarsConcrete(k)) || u.isUnion(t.makeTopLevelTypeVarsConcrete(S))) {
            e = x.getString();
          }
          t.addDiagnostic(r.DiagnosticRule.reportOperatorIssue, i.LocMessage.typeNotSupportBinaryOperator().format({
            operator: l.printOperator(n.d.operator),
            leftType: t.printType(k),
            rightType: t.printType(S)
          }) + e, n);
        }
      }
      return {
        type: N.type,
        isIncomplete: T,
        typeErrors: v,
        magicMethodDeprecationInfo: N.magicMethodDeprecationInfo
      };
    };
    exports.getTypeOfAugmentedAssignment = function (e, t, n) {
      const s = {
        1: ['__iadd__', 0],
        34: ['__isub__', 33],
        27: ['__imul__', 26],
        14: ['__ifloordiv__', 13],
        11: ['__itruediv__', 10],
        25: ['__imod__', 24],
        30: ['__ipow__', 29],
        23: ['__imatmul__', 22],
        4: ['__iand__', 3],
        7: ['__ior__', 6],
        9: ['__ixor__', 8],
        18: ['__ilshift__', 17],
        32: ['__irshift__', 31]
      };
      let o;
      let d;
      const m = new a.DiagnosticAddendum();
      let y;
      const f = e.getTypeOfExpression(t.d.leftExpr);
      const T = f.type;
      let v;
      if (t.d.operator === 7) {
        v = T;
      }
      const b = e.getTypeOfExpression(t.d.rightExpr, undefined, c.makeInferenceContext(v));
      const _ = b.type;
      const C = !!b.isIncomplete || !!f.isIncomplete;
      if (u.isNever(T) || u.isNever(_)) {
        d = {
          type: u.NeverType.createNever(),
          isIncomplete: C
        };
      } else {
        o = e.mapSubtypesExpandTypeVars(T, undefined, (a, r) => e.mapSubtypesExpandTypeVars(_, {
          conditionFilter: c.getTypeCondition(a)
        }, (i, o) => {
          if (u.isAnyOrUnknown(r) || u.isAnyOrUnknown(o)) {
            return c.preserveUnknown(r, o);
          }
          const d = s[t.d.operator][0];
          let v = e.getTypeOfMagicMethodCall(r, d, [{
            type: o,
            isIncomplete: b.isIncomplete
          }], t, n);
          if (!v && r !== a) {
            v = e.getTypeOfMagicMethodCall(a, d, [{
              type: o,
              isIncomplete: b.isIncomplete
            }], t, n);
          }
          if (!v && o !== i) {
            v = e.getTypeOfMagicMethodCall(a, d, [{
              type: i,
              isIncomplete: b.isIncomplete
            }], t, n);
          }
          if (!v) {
            const a = s[t.d.operator][1];
            const i = !l.isWithinLoop(t) && function (e, t) {
              if (t.nodeType !== 38) {
                return false;
              }
              const n = e.lookUpSymbolRecursive(t, t.d.value, false);
              if (!n) {
                return false;
              }
              const a = p.getScopeForNode(t);
              return a === n.scope;
            }(e, t.d.leftExpr) && c.getUnionSubtypeCount(T) * c.getUnionSubtypeCount(_) < g;
            const d = !u.isUnion(T);
            v = h(e, a, {
              type: r,
              isIncomplete: f.isIncomplete
            }, {
              type: o,
              isIncomplete: b.isIncomplete
            }, t, n, m, {
              isLiteralMathAllowed: i,
              isTupleAddAllowed: d
            });
          }
          if (v == null ? undefined : v.magicMethodDeprecationInfo) {
            y = v.magicMethodDeprecationInfo;
          }
          if (v == null) {
            return undefined;
          } else {
            return v.type;
          }
        }));
        if ((!m.isEmpty() || !o || !!u.isNever(o)) && !C) {
          e.addDiagnostic(r.DiagnosticRule.reportOperatorIssue, i.LocMessage.typeNotSupportBinaryOperator().format({
            operator: l.printOperator(t.d.operator),
            leftType: e.printType(T),
            rightType: e.printType(_)
          }) + m.getString(), t);
        }
        d = {
          type: o,
          isIncomplete: C,
          magicMethodDeprecationInfo: y
        };
      }
      e.assignTypeToExpression(t.d.destExpr, d, t.d.rightExpr);
      return d;
    };
    exports.getTypeOfUnaryOperation = function (e, t, n, a) {
      if (n & 256) {
        e.addDiagnostic(r.DiagnosticRule.reportInvalidTypeForm, i.LocMessage.unaryOperationNotAllowed(), t);
        return {
          type: u.UnknownType.create()
        };
      }
      const s = e.getTypeOfExpression(t.d.expr);
      let o = e.makeTopLevelTypeVarsConcrete(c.transformPossibleRecursiveTypeAlias(s.type));
      const p = s.isIncomplete;
      if (u.isNever(o)) {
        return {
          type: u.NeverType.createNever(),
          isIncomplete: p
        };
      }
      const d = {
        0: '__pos__',
        33: '__neg__',
        5: '__invert__',
        38: '__bool__'
      };
      let m;
      let y;
      if (t.d.operator !== 38 && c.isOptionalType(o)) {
        e.addDiagnostic(r.DiagnosticRule.reportOptionalOperand, i.LocMessage.noneOperator().format({
          operator: l.printOperator(t.d.operator)
        }), t.d.expr);
        o = c.removeNoneFromUnion(o);
      }
      if (!s.isIncomplete) {
        m = function (e, t) {
          let n;
          if (c.getUnionSubtypeCount(t) >= g) {
            return;
          }
          if (c.getTypeCondition(t) || c.someSubtypes(t, e => !!c.getTypeCondition(e))) {
            return;
          }
          const a = c.getLiteralTypeClassName(t);
          if (a === 'int') {
            if (e === 0) {
              n = t;
            } else {
              if (e === 33) {
                n = c.mapSubtypes(t, e => {
                  const t = e;
                  return u.ClassType.cloneWithLiteral(t, -t.priv.literalValue);
                });
              } else {
                if (e === 5) {
                  n = c.mapSubtypes(t, e => {
                    const t = e;
                    return u.ClassType.cloneWithLiteral(t, ~t.priv.literalValue);
                  });
                }
              }
            }
          } else {
            if (a === 'bool' && e === 38) {
              n = c.mapSubtypes(t, e => {
                const t = e;
                return u.ClassType.cloneWithLiteral(t, !t.priv.literalValue);
              });
            }
          }
          return n;
        }(t.d.operator, o);
      }
      if (!m) {
        if (u.isAnyOrUnknown(o)) {
          m = o;
        } else {
          const n = d[t.d.operator];
          let r = true;
          m = e.mapSubtypesExpandTypeVars(o, undefined, s => {
            const i = e.getTypeOfMagicMethodCall(s, n, [], t, a);
            if (!i) {
              r = false;
            }
            if (i == null ? undefined : i.magicMethodDeprecationInfo) {
              y = i.magicMethodDeprecationInfo;
            }
            if (i == null) {
              return undefined;
            } else {
              return i.type;
            }
          });
          if (!r) {
            m = undefined;
          }
        }
        if (t.d.operator === 38) {
          m = e.getBuiltInObject(t, 'bool');
          if (!m) {
            m = u.UnknownType.create();
          }
        }
        if (!m) {
          if (!p) {
            if (a) {
              e.addDiagnostic(r.DiagnosticRule.reportOperatorIssue, i.LocMessage.typeNotSupportUnaryOperatorBidirectional().format({
                operator: l.printOperator(t.d.operator),
                type: e.printType(o),
                expectedType: e.printType(a.expectedType)
              }), t);
            } else {
              e.addDiagnostic(r.DiagnosticRule.reportOperatorIssue, i.LocMessage.typeNotSupportUnaryOperator().format({
                operator: l.printOperator(t.d.operator),
                type: e.printType(o)
              }), t);
            }
          }
          m = u.UnknownType.create(p);
        }
      }
      return {
        type: m,
        isIncomplete: p,
        magicMethodDeprecationInfo: y
      };
    };
    exports.getTypeOfTernaryOperation = function (e, t, n, a) {
      const s = o.getFileInfo(t);
      if (n & 256) {
        e.addDiagnostic(r.DiagnosticRule.reportInvalidTypeForm, i.LocMessage.ternaryNotAllowed(), t);
        return {
          type: u.UnknownType.create()
        };
      }
      e.getTypeOfExpression(t.d.testExpr);
      const l = [];
      let p = false;
      let c = false;
      const m = d.evaluateStaticBoolExpression(t.d.testExpr, s.executionEnvironment, s.definedConstants);
      if (m !== false && e.isNodeReachable(t.d.ifExpr)) {
        const r = e.getTypeOfExpression(t.d.ifExpr, n, a);
        l.push(r.type);
        if (r.isIncomplete) {
          p = true;
        }
        if (r.typeErrors) {
          c = true;
        }
      }
      if (m !== true && e.isNodeReachable(t.d.elseExpr)) {
        const r = e.getTypeOfExpression(t.d.elseExpr, n, a);
        l.push(r.type);
        if (r.isIncomplete) {
          p = true;
        }
        if (r.typeErrors) {
          c = true;
        }
      }
      return {
        type: u.combineTypes(l),
        isIncomplete: p,
        typeErrors: c
      };
    };
    const a = require(11479);
    const r = require(65880);
    const s = require(63808);
    const i = require(67703);
    const o = require(26687);
    const l = require(41557);
    const p = require(95952);
    const d = require(28676);
    const c = require(92324);
    const u = require(21024);
    const m = {
      0: ['__add__', '__radd__'],
      33: ['__sub__', '__rsub__'],
      26: ['__mul__', '__rmul__'],
      13: ['__floordiv__', '__rfloordiv__'],
      10: ['__truediv__', '__rtruediv__'],
      24: ['__mod__', '__rmod__'],
      29: ['__pow__', '__rpow__'],
      22: ['__matmul__', '__rmatmul__'],
      3: ['__and__', '__rand__'],
      6: ['__or__', '__ror__'],
      8: ['__xor__', '__rxor__'],
      17: ['__lshift__', '__rlshift__'],
      31: ['__rshift__', '__rrshift__'],
      12: ['__eq__', '__eq__'],
      28: ['__ne__', '__ne__'],
      20: ['__lt__', '__gt__'],
      21: ['__le__', '__ge__'],
      15: ['__gt__', '__lt__'],
      16: ['__ge__', '__le__']
    };
    const y = {
      36: true,
      37: true,
      39: true,
      40: true,
      41: true,
      42: true
    };
    const g = 64;
    function h(e, t, n, a, r, s, o, p) {
      const d = n.type;
      const h = a.type;
      const f = !!n.isIncomplete || !!a.isIncomplete;
      let v;
      let b;
      let _ = e.makeTopLevelTypeVarsConcrete(d);
      if (y[t] !== undefined) {
        if (t === 36) {
          if (!e.canBeTruthy(_)) {
            return {
              type: d
            };
          }
          if (!e.canBeFalsy(_)) {
            return {
              type: h
            };
          }
          _ = e.removeTruthinessFromType(_);
          if (u.isNever(h)) {
            return {
              type: _
            };
          }
        } else {
          if (t === 37) {
            if (!e.canBeFalsy(_)) {
              return {
                type: d
              };
            }
            if (!e.canBeTruthy(_)) {
              return {
                type: h
              };
            }
            _ = e.removeFalsinessFromType(_);
            if (u.isNever(h)) {
              return {
                type: _
              };
            }
          }
        }
        if (u.isNever(d) || u.isNever(h)) {
          return {
            type: u.NeverType.createNever()
          };
        }
        if (t === 41 || t === 42) {
          const s = function (e, t, n, a, r, s, o) {
            let p;
            const d = e.mapSubtypesExpandTypeVars(r.type, undefined, (d, m) => e.mapSubtypesExpandTypeVars(a, {
              conditionFilter: c.getTypeCondition(d)
            }, a => {
              var y;
              var g;
              if (u.isAnyOrUnknown(a) || u.isAnyOrUnknown(m)) {
                return c.preserveUnknown(a, d);
              }
              let h = e.getTypeOfMagicMethodCall(d, '__contains__', [{
                type: a,
                isIncomplete: n.isIncomplete
              }], s, undefined);
              if (!h) {
                const t = (y = e.getTypeOfIterator({
                  type: d,
                  isIncomplete: r.isIncomplete
                }, false, s, false)) === null || y === undefined ? undefined : y.type;
                if (t && e.assignType(t, a)) {
                  h = {
                    type: e.getBuiltInObject(s, 'bool')
                  };
                }
              }
              if (!h) {
                o.addMessage(i.LocMessage.typeNotSupportBinaryOperator().format({
                  operator: l.printOperator(t),
                  leftType: e.printType(a),
                  rightType: e.printType(d)
                }));
              }
              if (h == null ? undefined : h.magicMethodDeprecationInfo) {
                p = h.magicMethodDeprecationInfo;
              }
              if ((g = h == null ? undefined : h.type) !== null && g !== undefined) {
                return g;
              } else {
                return e.getBuiltInObject(s, 'bool');
              }
            }));
            return {
              type: d,
              magicMethodDeprecationInfo: p
            };
          }(e, t, n, _, a, r, o);
          if (s.magicMethodDeprecationInfo) {
            b = s.magicMethodDeprecationInfo;
          }
          v = s.type;
          if (v && !u.isNever(v)) {
            v = e.getBuiltInObject(r, 'bool');
          }
        } else {
          v = e.mapSubtypesExpandTypeVars(_, undefined, (n, a) => e.mapSubtypesExpandTypeVars(h, {
            conditionFilter: c.getTypeCondition(n)
          }, (n, s) => t === 36 || t === 37 ? u.combineTypes([a, s]) : e.getBuiltInObject(r, 'bool')));
        }
      } else {
        if (m[t]) {
          if (u.isNever(d) || u.isNever(h)) {
            return {
              type: u.NeverType.createNever()
            };
          }
          if (p.isLiteralMathAllowed) {
            v = function (e, t, n) {
              const a = c.getLiteralTypeClassName(t);
              if (!a || c.getTypeCondition(t) || c.someSubtypes(t, e => !!c.getTypeCondition(e))) {
                return;
              }
              const r = c.getLiteralTypeClassName(n);
              if (a !== r || c.getTypeCondition(n) || c.someSubtypes(n, e => !!c.getTypeCondition(e)) || c.getUnionSubtypeCount(t) * c.getUnionSubtypeCount(n) >= g) {
                return;
              }
              if ((a === 'str' || a === 'bytes') && e === 0) {
                return c.mapSubtypes(t, e => c.mapSubtypes(n, t => {
                  const n = e;
                  const a = t;
                  return u.ClassType.cloneWithLiteral(n, n.priv.literalValue + a.priv.literalValue);
                }));
              }
              if (a === 'int') {
                if (![0, 33, 26, 13, 24, 29, 17, 31, 3, 6, 8].includes(e)) {
                  return;
                }
                let a = true;
                const r = c.mapSubtypes(t, t => c.mapSubtypes(n, n => {
                  try {
                    const r = t;
                    const s = n;
                    const i = BigInt(r.priv.literalValue);
                    const o = BigInt(s.priv.literalValue);
                    let l;
                    if (e === 0) {
                      l = i + o;
                    } else {
                      if (e === 33) {
                        l = i - o;
                      } else {
                        if (e === 26) {
                          l = i * o;
                        } else {
                          if (e === 13) {
                            if (o !== BigInt(0)) {
                              l = i / o;
                            }
                          } else {
                            if (e === 24) {
                              if (o !== BigInt(0)) {
                                l = i % o;
                              }
                            } else {
                              if (e === 29) {
                                if (o >= BigInt(0)) {
                                  try {
                                    l = i ** o;
                                  } catch {}
                                }
                              } else {
                                if (e === 17) {
                                  l = i << o;
                                } else {
                                  if (e === 31) {
                                    l = i >> o;
                                  } else {
                                    if (e === 3) {
                                      l = i & o;
                                    } else {
                                      if (e === 6) {
                                        l = i | o;
                                      } else {
                                        if (e === 8) {
                                          l = i ^ o;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    if (l === undefined || typeof l == 'number' && isNaN(l)) {
                      a = false;
                      return;
                    } else {
                      if (l >= Number.MIN_SAFE_INTEGER && l <= Number.MAX_SAFE_INTEGER) {
                        l = Number(l);
                      }
                      return u.ClassType.cloneWithLiteral(r, l);
                    }
                  } catch {
                    a = false;
                    return;
                  }
                }));
                if (a) {
                  return r;
                }
              }
              return;
            }(t, d, h);
          }
          if (!v) {
            const d = function (e, t, n, a, r, s, o, p) {
              let d;
              const y = !!n.isIncomplete || !!a.isIncomplete;
              const g = e.mapSubtypesExpandTypeVars(n.type, undefined, (g, h) => e.mapSubtypesExpandTypeVars(a.type, {
                conditionFilter: c.getTypeCondition(g)
              }, (f, v) => {
                var b;
                if (u.isAnyOrUnknown(h) || u.isAnyOrUnknown(v)) {
                  return c.preserveUnknown(h, v);
                }
                const _ = e.getTupleClassType();
                if (p.isTupleAddAllowed && t === 0 && u.isClassInstance(g) && c.isTupleClass(g) && g.priv.tupleTypeArgs && u.isClassInstance(f) && c.isTupleClass(f) && f.priv.tupleTypeArgs && _ && u.isInstantiableClass(_) && (!c.isUnboundedTupleClass(g) || !c.isUnboundedTupleClass(f))) {
                  return u.ClassType.cloneAsInstance(c.specializeTupleClass(_, [...g.priv.tupleTypeArgs, ...f.priv.tupleTypeArgs]));
                }
                const C = m[t][0];
                let I = e.getTypeOfMagicMethodCall(T(e, h), C, [{
                  type: v,
                  isIncomplete: a.isIncomplete
                }], r, s);
                if (!I && h !== g) {
                  I = e.getTypeOfMagicMethodCall(T(e, g), C, [{
                    type: v,
                    isIncomplete: a.isIncomplete
                  }], r, s);
                }
                if (!I && v !== f) {
                  I = e.getTypeOfMagicMethodCall(T(e, g), C, [{
                    type: f,
                    isIncomplete: a.isIncomplete
                  }], r, s);
                }
                if (!I) {
                  const a = m[t][1];
                  I = e.getTypeOfMagicMethodCall(T(e, v), a, [{
                    type: h,
                    isIncomplete: n.isIncomplete
                  }], r, s);
                  if (!I && v !== f) {
                    I = e.getTypeOfMagicMethodCall(T(e, f), a, [{
                      type: h,
                      isIncomplete: n.isIncomplete
                    }], r, s);
                  }
                  if (!I && h !== g) {
                    I = e.getTypeOfMagicMethodCall(T(e, f), a, [{
                      type: g,
                      isIncomplete: n.isIncomplete
                    }], r, s);
                  }
                }
                if (!I) {
                  if (s) {
                    o.addMessage(i.LocMessage.typeNotSupportBinaryOperatorBidirectional().format({
                      operator: l.printOperator(t),
                      leftType: e.printType(g),
                      rightType: e.printType(f),
                      expectedType: e.printType(s.expectedType)
                    }));
                  } else {
                    o.addMessage(i.LocMessage.typeNotSupportBinaryOperator().format({
                      operator: l.printOperator(t),
                      leftType: e.printType(g),
                      rightType: e.printType(f)
                    }));
                  }
                }
                if (I == null ? undefined : I.magicMethodDeprecationInfo) {
                  d = I.magicMethodDeprecationInfo;
                }
                if ((b = I == null ? undefined : I.type) !== null && b !== undefined) {
                  return b;
                } else {
                  return u.UnknownType.create(y);
                }
              }));
              return {
                type: g,
                magicMethodDeprecationInfo: d
              };
            }(e, t, n, a, r, s, o, p);
            if (d.magicMethodDeprecationInfo) {
              b = d.magicMethodDeprecationInfo;
            }
            v = d.type;
          }
        }
      }
      return {
        type: v ?? u.UnknownType.create(f),
        magicMethodDeprecationInfo: b
      };
    }
    function f(e, t) {
      if (!u.isInstantiableClass(e)) {
        return false;
      }
      const n = e.shared.effectiveMetaclass;
      if (!n || !u.isInstantiableClass(n)) {
        return false;
      }
      if (u.ClassType.isBuiltIn(n, 'type')) {
        return false;
      }
      const a = c.lookUpClassMember(n, t);
      return !!a && !u.isAnyOrUnknown(a.classType) && (!u.isInstantiableClass(a.classType) || !u.ClassType.isBuiltIn(a.classType, 'type'));
    }
    function T(e, t) {
      if (u.isFunction(t) || u.isOverloaded(t)) {
        return e.getObjectType();
      } else {
        return t;
      }
    }
  },
  44321: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ParamKind = undefined;
    exports.isTypedKwargs = function (e, t) {
      return e.category === 2 && r.isClassInstance(t) && r.isUnpackedClass(t) && r.ClassType.isTypedDictClass(t) && !!t.shared.typedDictEntries;
    };
    exports.getParamListDetails = function (e) {
      const t = {
        firstPositionOrKeywordIndex: 0,
        positionParamCount: 0,
        positionOnlyParamCount: 0,
        params: [],
        hasUnpackedTypeVarTuple: false,
        hasUnpackedTypedDict: false
      };
      let n = e.shared.parameters.findIndex(e => r.isPositionOnlySeparator(e));
      if (n < 0) {
        for (let t = 0; t < e.shared.parameters.length; t++) {
          const s = e.shared.parameters[t];
          if (s.category !== 0) {
            break;
          }
          if (!s.name) {
            break;
          }
          if (!a.isDunderName(s.name) && s.name.startsWith('__')) {
            n = t + 1;
          } else {
            if (t > 0 || r.FunctionType.isStaticMethod(e)) {
              break;
            }
          }
        }
      }
      for (let a = 0; a < n && !r.FunctionType.getParamDefaultType(e, a); a++) {
        t.positionOnlyParamCount++;
      }
      let o = false;
      const l = (a, s, l, p, d) => {
        if (a.name) {
          let c;
          c = d !== undefined ? d : a.category === 1 ? i.Positional : o ? i.Keyword : n >= 0 && s < n ? i.Positional : i.Standard;
          t.params.push({
            param: a,
            index: s,
            type: l ?? r.FunctionType.getParamType(e, s),
            declaredType: r.FunctionType.getDeclaredParamType(e, s),
            defaultType: p ?? r.FunctionType.getParamDefaultType(e, s),
            kind: c
          });
        }
      };
      e.shared.parameters.forEach((a, p) => {
        var d;
        var c;
        if (a.category === 1) {
          const s = r.FunctionType.getParamType(e, p);
          if (a.name && r.isUnpackedClass(s) && s.priv.tupleTypeArgs) {
            const d = p < t.positionOnlyParamCount;
            s.priv.tupleTypeArgs.forEach((n, s) => {
              const o = r.isTypeVarTuple(n.type) || n.isUnbounded ? 1 : 0;
              if (o === 1) {
                t.argsIndex = t.params.length;
              }
              if (r.isTypeVarTuple(r.FunctionType.getParamType(e, p))) {
                t.hasUnpackedTypeVarTuple = true;
              }
              l(r.FunctionParam.create(o, n.type, r.FunctionParamFlags.NameSynthesized | r.FunctionParamFlags.TypeDeclared, `${a.name}[${s.toString()}]`), p, n.type, undefined, i.ExpandedArgs);
              if (o === 0) {
                t.positionParamCount++;
              }
              if (s > 0 && d) {
                t.positionOnlyParamCount++;
              }
            });
            if (!o && (n < 0 || p >= n)) {
              t.firstKeywordOnlyIndex = t.params.length;
              o = true;
            }
          } else {
            if (a.name && t.argsIndex === undefined) {
              t.argsIndex = t.params.length;
              if (r.isTypeVarTuple(s)) {
                t.hasUnpackedTypeVarTuple = true;
              }
            }
            if (!o && (n < 0 || p >= n)) {
              t.firstKeywordOnlyIndex = t.params.length;
              if (a.name) {
                t.firstKeywordOnlyIndex++;
              }
              o = true;
            }
            l(a, p);
          }
        } else {
          if (a.category === 2) {
            o = true;
            const n = r.FunctionType.getParamType(e, p);
            if (r.isClassInstance(n) && r.isUnpackedClass(n) && n.shared.typedDictEntries) {
              if (t.firstKeywordOnlyIndex === undefined) {
                t.firstKeywordOnlyIndex = t.params.length;
              }
              const e = n;
              n.shared.typedDictEntries.knownItems.forEach((t, a) => {
                var i;
                var o;
                t = (o = (i = n.priv.typedDictNarrowedEntries) === null || i === undefined ? undefined : i.get(a)) !== null && o !== undefined ? o : t;
                const d = s.partiallySpecializeType(t.valueType, e, undefined);
                const c = t.isRequired ? undefined : d;
                l(r.FunctionParam.create(0, d, r.FunctionParamFlags.TypeDeclared, a, c), p, d, c);
              });
              if (n.shared.typedDictEntries.extraItems) {
                l(r.FunctionParam.create(2, n.shared.typedDictEntries.extraItems.valueType, r.FunctionParamFlags.TypeDeclared, 'kwargs'), p, n.shared.typedDictEntries.extraItems.valueType);
                t.kwargsIndex = t.params.length - 1;
              }
              t.hasUnpackedTypedDict = true;
              t.unpackedKwargsTypedDictType = n;
            } else {
              if (a.name) {
                if (t.kwargsIndex === undefined) {
                  t.kwargsIndex = t.params.length;
                }
                if (t.firstKeywordOnlyIndex === undefined) {
                  t.firstKeywordOnlyIndex = t.params.length;
                }
                l(a, p);
              }
            }
          } else {
            if (a.category === 0) {
              if (a.name && !o) {
                t.positionParamCount++;
              }
              l(a, p, undefined, ((d = e.priv.specializedTypes) === null || d === undefined ? undefined : d.parameterDefaultTypes) ? (c = e.priv.specializedTypes) === null || c === undefined ? undefined : c.parameterDefaultTypes[p] : undefined);
            }
          }
        }
      });
      t.paramSpec = r.FunctionType.getParamSpecFromArgsKwargs(e);
      t.firstPositionOrKeywordIndex = t.params.findIndex(e => e.kind !== i.Positional);
      if (t.firstPositionOrKeywordIndex < 0) {
        t.firstPositionOrKeywordIndex = t.params.length;
      }
      return t;
    };
    exports.isParamSpecArgs = function (e, t) {
      let n = true;
      s.doForEachSubtype(t, t => {
        if ((!r.isParamSpec(t) || t.priv.paramSpecAccess !== 'args' || !r.isTypeSame(t, e, {
          ignoreTypeFlags: true
        })) && (!r.isClassInstance(t) || !t.priv.tupleTypeArgs || t.priv.tupleTypeArgs.length !== 1 || !t.priv.tupleTypeArgs[0].isUnbounded || !r.isAnyOrUnknown(t.priv.tupleTypeArgs[0].type)) && !r.isAnyOrUnknown(t)) {
          n = false;
        }
      });
      return n;
    };
    exports.isParamSpecKwargs = function (e, t) {
      let n = true;
      s.doForEachSubtype(t, t => {
        if ((!r.isParamSpec(t) || t.priv.paramSpecAccess !== 'kwargs' || !r.isTypeSame(t, e, {
          ignoreTypeFlags: true
        })) && (!r.isClassInstance(t) || !r.ClassType.isBuiltIn(t, 'dict') || !t.priv.typeArgs || t.priv.typeArgs.length !== 2 || !r.isClassInstance(t.priv.typeArgs[0]) || !r.ClassType.isBuiltIn(t.priv.typeArgs[0], 'str') || !r.isAnyOrUnknown(t.priv.typeArgs[1])) && !r.isAnyOrUnknown(t)) {
          n = false;
        }
      });
      return n;
    };
    const a = require(12097);
    const r = require(21024);
    const s = require(92324);
    var i;
    (function (e) {
      e[e.Positional = 0] = 'Positional';
      e[e.Standard = 1] = 'Standard';
      e[e.Keyword = 2] = 'Keyword';
      e[e.ExpandedArgs = 3] = 'ExpandedArgs';
    })(i || (exports.ParamKind = i = {}));
  },
  27670: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ParentDirectoryCache = undefined;
    const a = require(58147);
    exports.ParentDirectoryCache = class {
      constructor(e) {
        this._importRootGetter = e;
        this._importChecked = new Map();
        this._cachedResults = new Map();
        this._libPathCache = undefined;
      }
      getImportResult(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        const o = (a = this._cachedResults.get(t)) === null || a === undefined ? undefined : a.get(e.key);
        if (o) {
          return o;
        }
        const l = (r = this._importChecked.get(t)) === null || r === undefined ? undefined : r.get(e.key);
        if (l) {
          if (l.importPath && (i = (s = this._cachedResults.get(t)) === null || s === undefined ? undefined : s.get(l.importPath.key)) !== null && i !== undefined) {
            return i;
          } else {
            return n;
          }
        } else {
          return undefined;
        }
      }
      checkValidPath(e, t, n) {
        var a;
        return !!t.startsWith(n) && (this._libPathCache = (a = this._libPathCache) !== null && a !== undefined ? a : this._importRootGetter().map(t => e.realCasePath(t)).filter(e => e !== n).filter(e => e.startsWith(n)), !this._libPathCache.some(e => t.startsWith(e)));
      }
      checked(e, t, n) {
        a.getOrAdd(this._importChecked, t, () => new Map()).set(e.key, n);
      }
      add(e) {
        a.getOrAdd(this._cachedResults, e.importName, () => new Map()).set(e.path.key, e.importResult);
      }
      reset() {
        this._importChecked.clear();
        this._cachedResults.clear();
        this._libPathCache = undefined;
      }
    };
  },
  25454: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ParseTreeCleanerWalker = undefined;
    const i = __importStar(require(26687));
    const o = require(88744);
    class l extends o.ParseTreeWalker {
      constructor(e) {
        super();
        this._parseTree = e;
      }
      clean() {
        this.walk(this._parseTree);
      }
      visitNode(e) {
        i.cleanNodeAnalysisInfo(e);
        return super.visitNode(e);
      }
    }
    exports.ParseTreeCleanerWalker = l;
  },
  41557: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CallNodeWalker = exports.NameNodeWalker = undefined;
    exports.getNodeDepth = function (e) {
      let t = 0;
      let n = e;
      while (n) {
        t++;
        n = n.parent;
      }
      return t;
    };
    exports.findNodeByPosition = function (e, t, n) {
      const a = p.convertPositionToOffset(t, n);
      if (a === undefined) {
        return;
      }
      return g(e, a);
    };
    exports.findNodeByOffset = g;
    exports.isCompliantWithNodeRangeRules = h;
    exports.getClassFullName = function (e, t, n) {
      const a = [n];
      let r = e;
      while (r) {
        r = b(r);
        if (r) {
          a.push(r.d.name.d.value);
        }
      }
      a.push(t);
      return a.reverse().join('.');
    };
    exports.getTypeSourceId = function (e) {
      return e.start;
    };
    exports.printArg = f;
    exports.printExpression = T;
    exports.printOperator = v;
    exports.getCallForName = function (e) {
      var t;
      var n;
      var a;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 9 && e.parent.d.leftExpr === e) {
        return e.parent;
      }
      if (((n = e.parent) === null || n === undefined ? undefined : n.nodeType) === 35 && e.parent.d.member === e && ((a = e.parent.parent) === null || a === undefined ? undefined : a.nodeType) === 9 && e.parent.parent.d.leftExpr === e.parent) {
        return e.parent.parent;
      }
      return;
    };
    exports.getDecoratorForName = function (e) {
      var t;
      var n;
      var a;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 16 && e.parent.d.expr === e) {
        return e.parent;
      }
      if (((n = e.parent) === null || n === undefined ? undefined : n.nodeType) === 35 && e.parent.d.member === e && ((a = e.parent.parent) === null || a === undefined ? undefined : a.nodeType) === 16 && e.parent.parent.d.expr === e.parent) {
        return e.parent.parent;
      }
      return;
    };
    exports.getEnclosingSuite = function (e) {
      let t = e.parent;
      while (t) {
        if (t.nodeType === 50) {
          return t;
        }
        t = t.parent;
      }
      return;
    };
    exports.getEnclosingClass = b;
    exports.getEnclosingModule = function (e) {
      let t = e.parent;
      while (t) {
        if (t.nodeType === 36) {
          return t;
        }
        t = t.parent;
      }
      l.fail('Module node not found');
      return;
    };
    exports.getEnclosingClassOrModule = function (e, t = false) {
      let n = e.parent;
      while (n) {
        if (n.nodeType === 10) {
          return n;
        }
        if (n.nodeType === 36) {
          return n;
        }
        if (n.nodeType === 31 && t) {
          return;
        }
        n = n.parent;
      }
      return;
    };
    exports.getEnclosingFunction = _;
    exports.getEnclosingFunctionEvaluationScope = function (e) {
      let t = C(e).node;
      while (t) {
        if (t.nodeType === 31) {
          return t;
        }
        if (t.nodeType === 10 || !t.parent) {
          return;
        }
        t = C(t.parent).node;
      }
      return;
    };
    exports.getEnclosingLambda = function (e) {
      let t = e.parent;
      while (t) {
        if (t.nodeType === 33) {
          return t;
        }
        if (t.nodeType === 50) {
          return;
        }
        t = t.parent;
      }
      return;
    };
    exports.getEnclosingClassOrFunction = function (e) {
      let t = e.parent;
      while (t) {
        if (t.nodeType === 31) {
          return t;
        }
        if (t.nodeType === 10) {
          return t;
        }
        t = t.parent;
      }
      return;
    };
    exports.getEnclosingClassOrFunctionSuite = function (e) {
      var t;
      var n;
      let a = e.parent;
      while (a) {
        if (a.nodeType === 50 && (((t = a.parent) === null || t === undefined ? undefined : t.nodeType) === 31 || ((n = a.parent) === null || n === undefined ? undefined : n.nodeType) === 10)) {
          return a;
        }
        a = a.parent;
      }
      return;
    };
    exports.getEnclosingSuiteOrModule = function (e, t = false, n = true) {
      let a = e.parent;
      while (a) {
        if (a.nodeType === 50) {
          return a;
        }
        if (a.nodeType === 36) {
          return a;
        }
        if (a.nodeType === 33 && n) {
          return;
        }
        if (a.nodeType === 31 && t) {
          return;
        }
        a = a.parent;
      }
      return;
    };
    exports.getEvaluationNodeForAssignmentExpression = function (e) {
      let t = false;
      let n = C(e).node;
      while (n !== undefined) {
        switch (n.nodeType) {
          case 31:
          case 33:
          case 36:
            return n;
          case 10:
            if (t) {
              return undefined;
            } else {
              return n;
            }
          case 11:
            t = true;
            n = C(n.parent).node;
            break;
          default:
            return;
        }
      }
      return;
    };
    exports.getEvaluationScopeNode = C;
    exports.getTypeVarScopeNode = I;
    exports.getExecutionScopeNode = function (e) {
      let t = C(e).node;
      while (t.nodeType === 76 || t.nodeType === 10 || t.nodeType === 11) {
        t = C(t.parent).node;
      }
      return t;
    };
    exports.getTypeAnnotationNode = function (e) {
      let t = e;
      let n = e.parent;
      while (n) {
        if (n.nodeType === 54) {
          if (n.d.annotation === t) {
            return n;
          }
          break;
        }
        t = n;
        n = n.parent;
      }
      return;
    };
    exports.getArgsByRuntimeOrder = function (e) {
      const t = e.d.args.filter(e => !e.d.name && e.d.argCategory !== 2);
      const n = e.d.args.filter(e => !!e.d.name || e.d.argCategory === 2);
      return t.concat(n);
    };
    exports.isFinalAllowedForAssignmentTarget = function (e) {
      if (e.nodeType === 38) {
        return true;
      }
      if (e.nodeType === 35) {
        if (e.d.leftExpr.nodeType !== 38) {
          return false;
        }
        if (!b(e)) {
          return false;
        }
        const t = _(e);
        return !!t && t.d.name.d.value === '__init__';
      }
      return false;
    };
    exports.isClassVarAllowedForAssignmentTarget = function (e) {
      if (!b(e, true)) {
        return false;
      }
      return true;
    };
    exports.isRequiredAllowedForAssignmentTarget = function (e) {
      if (!b(e, true)) {
        return false;
      }
      return true;
    };
    exports.isNodeContainedWithin = function (e, t) {
      let n = e;
      while (n) {
        if (n === t) {
          return true;
        }
        n = n.parent;
      }
      return false;
    };
    exports.getParentNodeOfType = k;
    exports.getParentAnnotationNode = function (e) {
      let t;
      let n = e;
      while (n) {
        if (n.nodeType === 31) {
          if (t === n.d.returnAnnotation) {
            return t;
          } else {
            return undefined;
          }
        }
        if (n.nodeType === 41) {
          if (t === n.d.annotation || t === n.d.annotationComment) {
            return t;
          } else {
            return undefined;
          }
        }
        if (n.nodeType === 3) {
          if (t === n.d.annotationComment) {
            return t;
          } else {
            return undefined;
          }
        }
        if (n.nodeType === 54) {
          if (t === n.d.annotation) {
            return t;
          } else {
            return undefined;
          }
        }
        if (n.nodeType === 62) {
          if (t === n.d.returnAnnotation || n.d.paramAnnotations.some(e => e === t)) {
            l.assert(!t || u.isExpressionNode(t));
            return t;
          } else {
            return undefined;
          }
        }
        t = n;
        n = n.parent;
      }
      return;
    };
    exports.isNodeContainedWithinNodeType = function (e, t) {
      return k(e, t) !== undefined;
    };
    exports.isSuiteEmpty = function (e) {
      let t = false;
      for (const n of e.d.statements) {
        if (n.nodeType !== 47) {
          return false;
        }
        for (const e of n.d.statements) {
          if (e.nodeType === 21) {
            t = true;
          } else {
            if (e.nodeType !== 48) {
              return false;
            }
          }
        }
      }
      return t;
    };
    exports.containsAwaitNode = function (e) {
      let t = false;
      class n extends y.ParseTreeWalker {
        visitAwait(e) {
          t = true;
          return false;
        }
      }
      new n().walk(e);
      return t;
    };
    exports.isMatchingExpression = w;
    exports.isPartialMatchingExpression = function e(t, n) {
      if (t.nodeType === 35) {
        return w(t.d.leftExpr, n) || e(t.d.leftExpr, n);
      }
      if (t.nodeType === 27) {
        return w(t.d.leftExpr, n) || e(t.d.leftExpr, n);
      }
      return false;
    };
    exports.isWithinDefaultParamInitializer = function (e) {
      let t;
      let n = e;
      while (n) {
        if (n.nodeType === 41 && t === n.d.defaultValue) {
          return true;
        }
        if (n.nodeType === 33 || n.nodeType === 31 || n.nodeType === 10 || n.nodeType === 36) {
          return false;
        }
        t = n;
        n = n.parent;
      }
      return false;
    };
    exports.isWithinTypeAnnotation = function (e, t) {
      let n;
      let a = e;
      let r = false;
      while (a) {
        if (a.nodeType === 41 && (n === a.d.annotation || n === a.d.annotationComment)) {
          return r || !t;
        }
        if (a.nodeType === 31 && n === a.d.returnAnnotation) {
          return r || !t;
        }
        if (a.nodeType === 31 && n === a.d.funcAnnotationComment) {
          return true;
        }
        if (a.nodeType === 54 && n === a.d.annotation) {
          return r || !t;
        }
        if (a.nodeType === 3 && n === a.d.annotationComment) {
          return true;
        }
        if (a.nodeType === 48 && n === a.d.annotation) {
          r = true;
        }
        if (a.nodeType === 33 || a.nodeType === 31 || a.nodeType === 10 || a.nodeType === 36) {
          return false;
        }
        n = a;
        a = a.parent;
      }
      return false;
    };
    exports.isWithinAnnotationComment = function (e) {
      let t;
      let n = e;
      while (n) {
        if (n.nodeType === 31 && t === n.d.funcAnnotationComment) {
          return true;
        }
        if (n.nodeType === 3 && t === n.d.annotationComment) {
          return true;
        }
        if (n.nodeType === 33 || n.nodeType === 31 || n.nodeType === 10 || n.nodeType === 36) {
          return false;
        }
        t = n;
        n = n.parent;
      }
      return false;
    };
    exports.isWithinLoop = function (e) {
      let t = e;
      while (t) {
        switch (t.nodeType) {
          case 29:
          case 57:
            return true;
        }
        t = t.parent;
      }
      return false;
    };
    exports.isWithinAssertExpression = function (e) {
      let t;
      let n = e;
      while (n) {
        if (n.nodeType === 2) {
          return n.d.testExpr === t;
        }
        t = n;
        n = n.parent;
      }
      return false;
    };
    exports.getDocString = function (e) {
      if (e.length === 0) {
        return;
      }
      if (e[0].nodeType !== 47) {
        return;
      }
      if (!S(e[0])) {
        return;
      }
      const t = e[0].d.statements[0].d.strings;
      if (t.length === 1) {
        return t[0].d.value;
      }
      return t.map(e => e.d.value).join('');
    };
    exports.isDocString = S;
    exports.isAssignmentToDefaultsFollowingNamedTuple = function (e) {
      var t;
      var n;
      if (e.nodeType !== 9 || !e.parent || e.parent.nodeType !== 3 || e.parent.d.leftExpr.nodeType !== 38 || !e.parent.parent || e.parent.parent.nodeType !== 47) {
        return false;
      }
      const a = e.parent.d.leftExpr.d.value;
      const r = e.parent.parent;
      if (r.d.statements[0] !== e.parent || !r.parent || r.parent.nodeType !== 36 && r.parent.nodeType !== 50) {
        return false;
      }
      const s = r.parent;
      let i = s.d.statements.findIndex(e => e === r);
      if (i < 0) {
        return false;
      }
      i++;
      while (i < s.d.statements.length) {
        const e = s.d.statements[i];
        if (e.nodeType !== 47) {
          break;
        }
        if (((t = e.d.statements[0]) === null || t === undefined ? undefined : t.nodeType) !== 48) {
          if (((n = e.d.statements[0]) === null || n === undefined ? undefined : n.nodeType) === 3) {
            const t = e.d.statements[0];
            if (t.d.leftExpr.nodeType === 35 && t.d.leftExpr.d.member.d.value === '__defaults__') {
              const e = t.d.leftExpr.d.leftExpr;
              if (e.nodeType === 35 && e.d.member.d.value === '__new__' && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === a) {
                return true;
              }
            }
          }
          break;
        }
        i++;
      }
      return false;
    };
    exports.getEnclosingParam = function (e) {
      let t = e;
      while (t) {
        if (t.nodeType === 41) {
          return t;
        }
        if (t.nodeType === 31) {
          return;
        }
        t = t.parent;
      }
      return;
    };
    exports.getCallNodeAndActiveParamIndex = function (e, t, n) {
      let a;
      let r = e;
      while (r !== undefined) {
        if (r.nodeType === 9 && c(n, r, t)) {
          a = r;
          break;
        }
        r = r.parent;
      }
      if (!a || !a.d.args) {
        return;
      }
      const s = d.TextRange.getEnd(a);
      if (t > s) {
        return;
      }
      const i = F(n, s - 1);
      if (t === s && (i == null ? undefined : i.type) === 14) {
        return;
      }
      let o = false;
      let l = -1;
      let p = false;
      a.d.args.forEach((e, a) => {
        if (o) {
          return;
        }
        let r = e.start;
        const s = n.getItemAtPosition(r);
        if (s >= 0) {
          r = d.TextRange.getEnd(n.getItemAt(s - 1));
        }
        let i = d.TextRange.getEnd(e);
        const c = n.getItemAtPosition(i);
        if (c >= 0) {
          for (let e = c; e < n.count; e++) {
            const t = n.getItemAt(e);
            switch (t.type) {
              case 12:
              case 14:
                break;
              default:
                continue;
            }
            i = d.TextRange.getEnd(t);
            break;
          }
        }
        if (t < i) {
          l = a;
          p = t >= r;
          o = true;
        }
      });
      if (!o) {
        l = a.d.args.length + 1;
      }
      return {
        callNode: a,
        activeIndex: l,
        activeOrFake: p
      };
      function c(e, t, n) {
        const a = t.d.leftExpr.length > 0 ? d.TextRange.getEnd(t.d.leftExpr) - 1 : t.d.leftExpr.start;
        const r = d.TextRange.getEnd(t);
        if (n < a || r < n) {
          return false;
        }
        if (t.d.args.length > 0) {
          const e = t.d.args[0].start;
          const a = d.TextRange.getEnd(t.d.args[t.d.args.length - 1]);
          if (e <= n && n < a) {
            return true;
          }
        }
        const s = e.getItemAtPosition(a);
        if (s < 0 || e.count <= s) {
          return true;
        }
        const i = e.getItemAt(s + 1);
        return i.type !== 13 || !(n < d.TextRange.getEnd(i));
      }
    };
    exports.getTokenIndexAtLeft = P;
    exports.getTokenAtLeft = function (e, t, n = false, a = false) {
      const r = P(e, t, n, a);
      if (r < 0) {
        return;
      }
      return e.getItemAt(r);
    };
    exports.isWhitespace = D;
    exports.getTokenAtIndex = N;
    exports.getTokenAt = F;
    exports.getTokenOverlapping = function (e, t) {
      const n = E(e, t);
      return N(e, n);
    };
    exports.getIndexOfTokenOverlapping = E;
    exports.findTokenAfter = function (e, t, n) {
      const a = e.tokens;
      const r = a.getItemAtPosition(t);
      if (r < 0) {
        return;
      }
      for (let e = r; e < a.length; e++) {
        const t = a.getItemAt(e);
        if (n(t)) {
          return t;
        }
      }
      return;
    };
    exports.getCommentsAtTokenIndex = function (e, t) {
      let n = N(e, t);
      if (!n) {
        return;
      }
      for (let a = t - 1; a >= 0; --a) {
        const t = N(e, a);
        if (!t || t.start !== n.start) {
          break;
        }
        n = t;
      }
      return n.comments;
    };
    exports.printParseNodeType = function (e) {
      switch (e) {
        case 0:
          return 'Error';
        case 1:
          return 'Argument';
        case 2:
          return 'Assert';
        case 3:
          return 'Assignment';
        case 4:
          return 'AssignmentExpression';
        case 5:
          return 'AugmentedAssignment';
        case 6:
          return 'Await';
        case 7:
          return 'BinaryOperation';
        case 8:
          return 'Break';
        case 9:
          return 'Call';
        case 10:
          return 'Class';
        case 14:
          return 'Constant';
        case 15:
          return 'Continue';
        case 16:
          return 'Decorator';
        case 17:
          return 'Del';
        case 18:
          return 'Dictionary';
        case 19:
          return 'DictionaryExpandEntry';
        case 20:
          return 'DictionaryKeyEntry';
        case 21:
          return 'Ellipsis';
        case 22:
          return 'If';
        case 23:
          return 'Import';
        case 24:
          return 'ImportAs';
        case 25:
          return 'ImportFrom';
        case 26:
          return 'ImportFromAs';
        case 27:
          return 'Index';
        case 28:
          return 'Except';
        case 29:
          return 'For';
        case 30:
          return 'FormatString';
        case 31:
          return 'Function';
        case 32:
          return 'Global';
        case 33:
          return 'Lambda';
        case 34:
          return 'List';
        case 11:
          return 'Comprehension';
        case 12:
          return 'ComprehensionFor';
        case 13:
          return 'ComprehensionIf';
        case 35:
          return 'MemberAccess';
        case 36:
          return 'Module';
        case 37:
          return 'ModuleName';
        case 38:
          return 'Name';
        case 39:
          return 'Nonlocal';
        case 40:
          return 'Number';
        case 41:
          return 'Parameter';
        case 42:
          return 'Pass';
        case 43:
          return 'Raise';
        case 44:
          return 'Return';
        case 45:
          return 'Set';
        case 46:
          return 'Slice';
        case 47:
          return 'StatementList';
        case 48:
          return 'StringList';
        case 49:
          return 'String';
        case 50:
          return 'Suite';
        case 51:
          return 'Ternary';
        case 52:
          return 'Tuple';
        case 53:
          return 'Try';
        case 54:
          return 'TypeAnnotation';
        case 55:
          return 'UnaryOperation';
        case 56:
          return 'Unpack';
        case 57:
          return 'While';
        case 58:
          return 'With';
        case 59:
          return 'WithItem';
        case 60:
          return 'Yield';
        case 61:
          return 'YieldFrom';
        case 62:
          return 'FunctionAnnotation';
        case 63:
          return 'Match';
        case 64:
          return 'Case';
        case 65:
          return 'PatternSequence';
        case 66:
          return 'PatternAs';
        case 67:
          return 'PatternLiteral';
        case 68:
          return 'PatternClass';
        case 69:
          return 'PatternCapture';
        case 70:
          return 'PatternMapping';
        case 71:
          return 'PatternMappingKeyEntry';
        case 72:
          return 'PatternMappingExpandEntry';
        case 73:
          return 'PatternValue';
        case 74:
          return 'PatternClassArgument';
        case 75:
          return 'TypeParameter';
        case 76:
          return 'TypeParameterList';
        case 77:
          return 'TypeAlias';
      }
      l.assertNever(e);
    };
    exports.isWriteAccess = function (e) {
      let t = e;
      let n = t.parent;
      while (n) {
        switch (n.nodeType) {
          case 3:
          case 5:
            return t === n.d.leftExpr;
          case 4:
          case 28:
            return t === n.d.name;
          case 17:
            return true;
          case 29:
          case 12:
            return t === n.d.targetExpr;
          case 24:
            return t === n.d.alias || n.d.module.d.nameParts.length > 0 && t === n.d.module.d.nameParts[0];
          case 26:
            return t === n.d.alias || !n.d.alias && t === n.d.name;
          case 35:
            if (t !== n.d.member) {
              return false;
            }
            break;
          case 58:
            return n.d.withItems.some(e => e === t);
          case 54:
            if (t === n.d.annotation) {
              return false;
            }
            break;
          case 31:
          case 10:
          case 36:
            return false;
        }
        t = n;
        n = n.parent;
      }
      return false;
    };
    exports.getModuleNode = M;
    exports.getFileInfoFromNode = function (e) {
      const t = M(e);
      if (t) {
        return i.getFileInfo(t);
      } else {
        return undefined;
      }
    };
    exports.isFunctionSuiteEmpty = function (e) {
      let t = true;
      e.d.suite.d.statements.forEach(e => {
        if (e.nodeType !== 0) {
          if (e.nodeType === 47) {
            e.d.statements.forEach(e => {
              if (e.nodeType !== 21 && e.nodeType !== 48 && e.nodeType !== 42) {
                t = false;
              }
            });
          } else {
            t = false;
          }
        }
      });
      return t;
    };
    exports.getTypeAnnotationForParam = function (e, t) {
      if (t >= e.d.params.length) {
        return;
      }
      const n = e.d.params[t];
      if (n.d.annotation) {
        return n.d.annotation;
      }
      if (n.d.annotationComment) {
        return n.d.annotationComment;
      }
      if (!e.d.funcAnnotationComment || e.d.funcAnnotationComment.d.isEllipsis) {
        return;
      }
      let a = 0;
      const r = e.d.funcAnnotationComment.d.paramAnnotations;
      if (r.length < e.d.params.length) {
        a = 1;
      }
      const s = t - a;
      if (s < 0 || s >= r.length) {
        return;
      }
      return r[s];
    };
    exports.isImportModuleName = function (e) {
      var t;
      var n;
      return ((n = (t = z(e, 37)) === null || t === undefined ? undefined : t.parent) === null || n === undefined ? undefined : n.nodeType) === 24;
    };
    exports.isImportAlias = function (e) {
      var t;
      return ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 24 && e.parent.d.alias === e;
    };
    exports.isFromImportModuleName = function (e) {
      var t;
      var n;
      return ((n = (t = z(e, 37)) === null || t === undefined ? undefined : t.parent) === null || n === undefined ? undefined : n.nodeType) === 25;
    };
    exports.isFromImportName = function (e) {
      var t;
      return ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 26 && e.parent.d.name === e;
    };
    exports.isFromImportAlias = function (e) {
      var t;
      return ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 26 && e.parent.d.alias === e;
    };
    exports.isLastNameOfModuleName = function (e) {
      var t;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 37) {
        return false;
      }
      const n = e.parent;
      if (n.d.nameParts.length === 0) {
        return false;
      }
      return n.d.nameParts[n.d.nameParts.length - 1] === e;
    };
    exports.getAncestorsIncludingSelf = O;
    exports.getFirstAncestorOrSelfOfKind = z;
    exports.getFirstAncestorOrSelf = U;
    exports.getDottedNameWithGivenNodeAsLastName = function (e) {
      var t;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 35) {
        return e;
      }
      if (e.parent.d.leftExpr === e) {
        return e;
      }
      return e.parent;
    };
    exports.getDecoratorName = function (e) {
      return function e(t) {
        var n;
        if (t.nodeType === 38 || t.nodeType === 35) {
          if ((n = V(t)) === null || n === undefined) {
            return undefined;
          } else {
            return n.map(e => e.d.value).join('.');
          }
        } else {
          if (t.nodeType === 9) {
            return e(t.d.leftExpr);
          } else {
            return undefined;
          }
        }
      }(e.d.expr);
    };
    exports.getDottedName = V;
    exports.getFirstNameOfDottedName = function e(t) {
      if (t.nodeType === 38) {
        return t;
      }
      if (t.d.leftExpr.nodeType === 38 || t.d.leftExpr.nodeType === 35) {
        return e(t.d.leftExpr);
      }
      return;
    };
    exports.isFirstNameOfDottedName = function (e) {
      var t;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 35) {
        return true;
      }
      if (e.parent.d.leftExpr === e) {
        return true;
      }
      return false;
    };
    exports.isLastNameOfDottedName = function (e) {
      var t;
      var n;
      if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 35) {
        return true;
      }
      if (e.parent.d.leftExpr.nodeType !== 38 && e.parent.d.leftExpr.nodeType !== 35) {
        return false;
      }
      if (e.parent.d.leftExpr === e) {
        return false;
      }
      return ((n = e.parent.parent) === null || n === undefined ? undefined : n.nodeType) !== 35;
    };
    exports.getStringNodeValueRange = function (e) {
      return R(e.d.token);
    };
    exports.getStringValueRange = R;
    exports.getFullStatementRange = function (e, t, n) {
      var a;
      const r = p.convertTextRangeToRange(e, t.tokenizerOutput.lines);
      const s = (a = function (e, t, n) {
        const a = n.tokens.getItemAtPosition(t);
        if (a < 0) {
          return;
        }
        let r = a;
        for (; r > 0; r--) {
          const t = n.tokens.getItemAt(r);
          if (p.convertTextRangeToRange(t, n.lines).end.line !== e.start.line) {
            break;
          }
        }
        for (let t = a - 1; t > r; t--) {
          const a = n.tokens.getItemAt(t);
          if (a.type !== 3 && a.type !== 4) {
            if (a.type === 2) {
              return;
            }
            return e.start;
          }
        }
        return;
      }(r, e.start, t.tokenizerOutput)) !== null && a !== undefined ? a : {
        line: r.start.line,
        character: 0
      };
      const i = function (e, t, n) {
        const a = n.tokens.getItemAtPosition(t);
        if (a < 0) {
          return;
        }
        let r = a;
        for (; r < n.tokens.count; r++) {
          const t = n.tokens.getItemAt(r);
          const a = p.convertTextRangeToRange(t, n.lines);
          if (e.end.line !== a.start.line) {
            break;
          }
        }
        let s = false;
        for (let e = a; e < r; e++) {
          const t = n.tokens.getItemAt(e);
          if (t.type === 11 || t.type === 2) {
            s = true;
            continue;
          }
          if (!s) {
            continue;
          }
          return p.convertTextRangeToRange(t, n.lines).start;
        }
        return;
      }(r, d.TextRange.getEnd(e), t.tokenizerOutput);
      if (i) {
        return {
          start: s,
          end: i
        };
      }
      if (r.end.line === t.tokenizerOutput.lines.count - 1) {
        return {
          start: s,
          end: r.end
        };
      }
      let o = 1;
      if (n && n.includeTrailingBlankLines) {
        for (let e = o; r.end.line + e < t.tokenizerOutput.lines.count; e++) {
          if (!L(t.tokenizerOutput, t.text, r.end.line + e)) {
            o = e;
            break;
          }
        }
      }
      return {
        start: s,
        end: {
          line: r.end.line + o,
          character: 0
        }
      };
    };
    exports.isBlankLine = L;
    exports.isUnannotatedFunction = function (e) {
      return e.d.returnAnnotation === undefined && e.d.params.every(e => e.d.annotation === undefined && e.d.annotationComment === undefined);
    };
    exports.isValidLocationForFutureImport = function (e) {
      const t = M(e);
      l.assert(t);
      let n = false;
      for (const a of t.d.statements) {
        if (a.nodeType !== 47) {
          return false;
        }
        for (const t of a.d.statements) {
          if (t === e) {
            return true;
          }
          if (t.nodeType === 48) {
            if (n) {
              return false;
            }
            n = true;
          } else {
            if (t.nodeType !== 25) {
              return false;
            }
            if (t.d.module.d.leadingDots !== 0 || t.d.module.d.nameParts.length !== 1 || t.d.module.d.nameParts[0].d.value !== '__future__') {
              return false;
            }
          }
        }
      }
      return false;
    };
    exports.operatorSupportsChaining = function (e) {
      switch (e) {
        case 12:
        case 28:
        case 20:
        case 21:
        case 15:
        case 16:
        case 39:
        case 40:
        case 41:
        case 42:
          return true;
      }
      return false;
    };
    exports.getVariableDocStringNode = function (e) {
      var t;
      var n;
      var a;
      var r;
      let s;
      let i = e;
      while (i && i.nodeType !== 3 && i.nodeType !== 77 && i.nodeType !== 50) {
        if (i.nodeType === 54 && !s) {
          s = i;
        }
        i = i.parent;
      }
      if ((i == null ? undefined : i.nodeType) !== 3 && (i == null ? undefined : i.nodeType) !== 77) {
        if (!s) {
          return;
        }
        i = s;
      }
      const o = i.parent;
      if ((o == null ? undefined : o.nodeType) !== 47) {
        return;
      }
      const l = o.parent;
      if (!l || l.nodeType !== 36 && l.nodeType !== 50) {
        return;
      }
      const p = l.d.statements.findIndex(e => e === o);
      if (p < 0 || p === l.d.statements.length - 1) {
        return;
      }
      const d = l.d.statements[p + 1];
      if (d.nodeType !== 47 || !S(d)) {
        return;
      }
      let c = false;
      if (((t = o == null ? undefined : o.parent) === null || t === undefined ? undefined : t.nodeType) === 36) {
        c = true;
      } else {
        if (((n = o == null ? undefined : o.parent) === null || n === undefined ? undefined : n.nodeType) === 50 && ((r = (a = o == null ? undefined : o.parent) === null || a === undefined ? undefined : a.parent) === null || r === undefined ? undefined : r.nodeType) === 10) {
          c = true;
        } else {
          const e = _(o);
          if (e && e.d.name.d.value === '__init__' && b(e, true)) {
            c = true;
          }
        }
      }
      if (!c) {
        return;
      }
      return d.d.statements[0];
    };
    exports.getScopeIdForNode = B;
    exports.getTypeVarScopesForNode = function (e) {
      const t = [];
      let n = e;
      while (n && (n = I(n), n)) {
        t.push(B(n));
        n = n.parent;
      }
      return t;
    };
    exports.checkDecorator = function (e, t) {
      return e.d.expr.nodeType === 38 && e.d.expr.d.value === t;
    };
    exports.isSimpleDefault = function e(t) {
      switch (t.nodeType) {
        case 40:
        case 14:
        case 35:
          return true;
        case 49:
          return !(t.d.token.flags & 64);
        case 48:
          return t.d.strings.every(e);
        case 55:
          return e(t.d.expr);
        case 7:
          return e(t.d.leftExpr) && e(t.d.rightExpr);
        default:
          return false;
      }
    };
    const i = __importStar(require(26687));
    const o = require(34455);
    const l = require(48281);
    const p = require(56814);
    const d = require(88754);
    const c = require(95418);
    const u = require(85114);
    const m = require(26687);
    const y = require(88744);
    function g(e, t) {
      if (!d.TextRange.overlaps(e, t)) {
        return;
      }
      let n = y.getChildNodes(e);
      if (h(e) && n.length > 20) {
        let e = c.getIndexContaining(n, t, d.TextRange.overlaps);
        if (e >= 0) {
          let a = e - 1;
          while (a >= 0) {
            const r = n[a];
            if (r) {
              if (!d.TextRange.overlaps(r, t)) {
                break;
              }
              e = a;
            }
            a--;
          }
          n = [n[e]];
        }
      }
      for (const a of n) {
        if (!a) {
          continue;
        }
        const n = g(a, t);
        if (n) {
          if (e.nodeType === 5 && n === e.d.leftExpr) {
            return e.d.destExpr;
          } else {
            return n;
          }
        }
      }
      return e;
    }
    function h(e) {
      return e.nodeType !== 3 && e.nodeType !== 48 && (e.nodeType !== 1 || !e.d.isNameSameAsValue);
    }
    function f(e, t) {
      let n = '';
      if (e.d.argCategory === 1) {
        n = '*';
      } else {
        if (e.d.argCategory === 2) {
          n = '**';
        }
      }
      if (e.d.name) {
        n += e.d.name.d.value + '=';
      }
      if (!e.d.isNameSameAsValue) {
        n += T(e.d.valueExpr, t);
      }
      return n;
    }
    function T(e, t = 0) {
      switch (e.nodeType) {
        case 38:
          return e.d.value;
        case 35:
          return T(e.d.leftExpr, t) + '.' + e.d.member.d.value;
        case 9:
          {
            let n = T(e.d.leftExpr, t);
            if (e.d.leftExpr.nodeType !== 35 && e.d.leftExpr.nodeType !== 38 && e.d.leftExpr.nodeType !== 27 && e.d.leftExpr.nodeType !== 9) {
              n = `(${n})`;
            }
            return n + '(' + e.d.args.map(e => f(e, t)).join(', ') + ')';
          }
        case 27:
          return T(e.d.leftExpr, t) + '[' + e.d.items.map(e => f(e, t)).join(', ') + (e.d.trailingComma ? ',' : '') + ']';
        case 55:
          {
            const n = v(e.d.operator) + T(e.d.expr, t);
            if (e.d.hasParens) {
              return `(${n})`;
            } else {
              return n;
            }
          }
        case 7:
          {
            const n = T(e.d.leftExpr, t) + ' ' + v(e.d.operator) + ' ' + T(e.d.rightExpr, t);
            if (e.d.hasParens) {
              return `(${n})`;
            } else {
              return n;
            }
          }
        case 40:
          {
            let t = e.d.value.toString();
            if (t.endsWith('n')) {
              t = t.substring(0, t.length - 1);
            }
            if (e.d.isImaginary) {
              t += 'j';
            }
            return t;
          }
        case 48:
          if (t & 1 && e.d.annotation) {
            return T(e.d.annotation, t);
          } else {
            return e.d.strings.map(e => T(e, t)).join(' ');
          }
        case 49:
          {
            let n = '';
            if (e.d.token.flags & 8) {
              n += 'r';
            }
            if (e.d.token.flags & 16) {
              n += 'u';
            }
            if (e.d.token.flags & 32) {
              n += 'b';
            }
            if (e.d.token.flags & 64) {
              n += 'f';
            }
            let a = e.d.token.escapedValue;
            if (!(t & 2)) {
              const e = 32;
              a = a.slice(0, e);
            }
            if (e.d.token.flags & 4) {
              if (e.d.token.flags & 1) {
                n += `'''${a}'''`;
              } else {
                n += `"""${a}"""`;
              }
            } else {
              if (e.d.token.flags & 1) {
                n += `'${a}'`;
              } else {
                n += `"${a}"`;
              }
            }
            return n;
          }
        case 30:
          {
            let t = 'f';
            let n = '';
            const a = [...e.d.middleTokens, ...e.d.fieldExprs].sort((e, t) => e.start - t.start);
            while (a.length > 0) {
              const e = a.shift();
              n += 'nodeType' in e ? `{${T(e)}}` : e.escapedValue;
            }
            if (e.d.token.flags & 4) {
              if (e.d.token.flags & 1) {
                t += `'''${n}'''`;
              } else {
                t += `"""${n}"""`;
              }
            } else {
              if (e.d.token.flags & 1) {
                t += `'${n}'`;
              } else {
                t += `"${n}"`;
              }
            }
            return t;
          }
        case 3:
          return T(e.d.leftExpr, t) + ' = ' + T(e.d.rightExpr, t);
        case 4:
          return T(e.d.name, t) + ' := ' + T(e.d.rightExpr, t);
        case 54:
          return T(e.d.valueExpr, t) + ': ' + T(e.d.annotation, t);
        case 5:
          return T(e.d.leftExpr, t) + ' ' + v(e.d.operator) + ' ' + T(e.d.rightExpr, t);
        case 6:
          {
            const n = `await ${T(e.d.expr, t)}`;
            if (e.d.hasParens) {
              return `(${n})`;
            } else {
              return n;
            }
          }
        case 51:
          return T(e.d.ifExpr, t) + ' if ' + T(e.d.testExpr, t) + ' else ' + T(e.d.elseExpr, t);
        case 34:
          return `[${e.d.items.map(e => T(e, t)).join(', ')}]`;
        case 56:
          return `*${T(e.d.expr, t)}`;
        case 52:
          {
            const n = e.d.items.map(e => T(e, t));
            if (n.length === 1) {
              return `(${n[0]}, )`;
            } else {
              return `(${n.join(', ')})`;
            }
          }
        case 60:
          if (e.d.expr) {
            return `yield ${T(e.d.expr, t)}`;
          } else {
            return 'yield';
          }
        case 61:
          return `yield from ${T(e.d.expr, t)}`;
        case 21:
          return '...';
        case 11:
          {
            let n = '<ListExpression>';
            if (u.isExpressionNode(e.d.expr)) {
              n = T(e.d.expr, t);
            } else {
              if (e.d.expr.nodeType === 20) {
                n = `${T(e.d.expr.d.keyExpr, t)}: ${T(e.d.expr.d.valueExpr, t)}`;
              }
            }
            n = n + ' ' + e.d.forIfNodes.map(e => e.nodeType === 12 ? `${(e.d.isAsync ? 'async ' : '') + 'for ' + T(e.d.targetExpr, t)} in ${T(e.d.iterableExpr, t)}` : `if ${T(e.d.testExpr, t)}`).join(' ');
            if (e.d.hasParens) {
              return `(${n})`;
            } else {
              return n;
            }
          }
        case 46:
          {
            let n = '';
            if (e.d.startValue || e.d.endValue || e.d.stepValue) {
              if (e.d.startValue) {
                n += T(e.d.startValue, t);
              }
              if (e.d.endValue) {
                n += `: ${T(e.d.endValue, t)}`;
              }
              if (e.d.stepValue) {
                n += `: ${T(e.d.stepValue, t)}`;
              }
            } else {
              n += ':';
            }
            return n;
          }
        case 33:
          return `lambda ${e.d.params.map(e => {
            let n = '';
            if (e.d.category === 1) {
              n += '*';
            } else {
              if (e.d.category === 2) {
                n += '**';
              }
            }
            if (e.d.name) {
              n += e.d.name.d.value;
            } else {
              if (e.d.category === 0) {
                n += '/';
              }
            }
            if (e.d.defaultValue) {
              n += ` = ${T(e.d.defaultValue, t)}`;
            }
            return n;
          }).join(', ')}: ${T(e.d.expr, t)}`;
        case 14:
          if (e.d.constType === 33) {
            return 'True';
          }
          if (e.d.constType === 15) {
            return 'False';
          }
          if (e.d.constType === 9) {
            return '__debug__';
          }
          if (e.d.constType === 26) {
            return 'None';
          }
          break;
        case 18:
          {
            const n = `${e.d.items.map(e => e.nodeType === 20 ? `${T(e.d.keyExpr, t)}: ${T(e.d.valueExpr, t)}` : e.nodeType === 19 ? `**${T(e.d.expr, t)}` : T(e, t))}`;
            if (n) {
              return `{ ${n} }`;
            } else {
              return '{}';
            }
          }
        case 45:
          return e.d.items.map(e => T(e, t)).join(', ');
        case 0:
          return '<Parse Error>';
        default:
          l.assertNever(e);
      }
      return '<Expression>';
    }
    function v(e) {
      const t = {
        0: '+',
        1: '+=',
        2: '=',
        3: '&',
        4: '&=',
        5: '~',
        6: '|',
        7: '|=',
        8: '^',
        9: '^=',
        10: '/',
        11: '/=',
        12: '==',
        13: '//',
        14: '//=',
        15: '>',
        16: '>=',
        17: '<<',
        18: '<<=',
        19: '<>',
        20: '<',
        21: '<=',
        22: '@',
        23: '@=',
        24: '%',
        25: '%=',
        26: '*',
        27: '*=',
        28: '!=',
        29: '**',
        30: '**=',
        31: '>>',
        32: '>>=',
        33: '-',
        34: '-=',
        36: 'and',
        37: 'or',
        38: 'not ',
        39: 'is',
        40: 'is not',
        41: 'in',
        42: 'not in'
      };
      if (t[e]) {
        return t[e];
      } else {
        return 'unknown';
      }
    }
    function b(e, t = false) {
      let n = e.parent;
      while (n) {
        if (n.nodeType === 10) {
          return n;
        }
        if (n.nodeType === 36) {
          return;
        }
        if (n.nodeType === 31 && t) {
          return;
        }
        n = n.parent;
      }
    }
    function _(e) {
      let t;
      let n = e.parent;
      while (n) {
        if (n.nodeType === 31 && !n.d.decorators.some(e => e === t)) {
          return n;
        }
        if (n.nodeType === 10) {
          return;
        }
        t = n;
        n = n.parent;
      }
    }
    function C(e) {
      let t;
      let n;
      let a = e;
      let r = false;
      let s = false;
      while (a) {
        if (a.nodeType === 41) {
          if (t === a.d.name) {
            r = true;
          } else {
            if (t === a.d.defaultValue) {
              s = true;
            }
          }
        }
        switch (a.nodeType) {
          case 76:
            return {
              node: a,
              useProxyScope: true
            };
          case 31:
            if (!t) {
              break;
            }
            if (a.d.decorators.some(e => e === t)) {
              break;
            }
            if (t === a.d.name) {
              break;
            }
            if (a.d.params.some(e => e === t)) {
              if (s) {
                break;
              }
              if (r && m.getScope(a) !== undefined) {
                return {
                  node: a
                };
              }
            }
            if (t === a.d.suite && m.getScope(a) !== undefined) {
              return {
                node: a
              };
            }
            if (a.d.typeParams) {
              const e = a.d.typeParams;
              if (m.getScope(e) !== undefined) {
                return {
                  node: e,
                  useProxyScope: true
                };
              }
            }
            break;
          case 33:
            if (a.d.params.some(e => e === t)) {
              if (r && m.getScope(a) !== undefined) {
                return {
                  node: a
                };
              }
            } else {
              if ((!t || t === a.d.expr) && m.getScope(a) !== undefined) {
                return {
                  node: a
                };
              }
            }
            break;
          case 10:
            if (!t) {
              break;
            }
            if (a.d.decorators.some(e => e === t)) {
              break;
            }
            if (t === a.d.suite && m.getScope(a) !== undefined) {
              return {
                node: a
              };
            }
            if (a.d.typeParams) {
              const e = a.d.typeParams;
              if (m.getScope(e) !== undefined) {
                return {
                  node: e,
                  useProxyScope: true
                };
              }
            }
            break;
          case 11:
            if (m.getScope(a) !== undefined) {
              if (t !== a.d.forIfNodes[0] || a.d.forIfNodes[0].nodeType !== 12 || a.d.forIfNodes[0].d.iterableExpr !== n) {
                return {
                  node: a
                };
              }
            }
            break;
          case 77:
            if (t === a.d.expr && a.d.typeParams) {
              const e = a.d.typeParams;
              if (m.getScope(e) !== undefined) {
                return {
                  node: e
                };
              }
            }
            break;
          case 36:
            if (m.getScope(a) !== undefined) {
              return {
                node: a
              };
            }
        }
        n = t;
        t = a;
        a = a.parent;
      }
      l.fail('Did not find evaluation scope');
    }
    function I(e) {
      let t;
      let n = e;
      while (n) {
        switch (n.nodeType) {
          case 31:
          case 10:
            if (!n.d.decorators.some(e => e === t)) {
              return n;
            }
            break;
          case 77:
            return n;
        }
        t = n;
        n = n.parent;
      }
    }
    function k(e, t) {
      let n = e;
      while (n) {
        if (n.nodeType === t) {
          return n;
        }
        n = n.parent;
      }
    }
    function w(e, t) {
      if (e.nodeType === 38) {
        if (t.nodeType === 38) {
          return e.d.value === t.d.value;
        } else {
          return t.nodeType === 4 && e.d.value === t.d.name.d.value;
        }
      }
      if (e.nodeType === 35 && t.nodeType === 35) {
        return w(e.d.leftExpr, t.d.leftExpr) && e.d.member.d.value === t.d.member.d.value;
      }
      if (e.nodeType === 27 && t.nodeType === 27) {
        if (!w(e.d.leftExpr, t.d.leftExpr)) {
          return false;
        }
        if (t.d.items.length !== 1 || t.d.trailingComma || t.d.items[0].d.name || t.d.items[0].d.argCategory !== 0) {
          return false;
        }
        const n = e.d.items[0].d.valueExpr;
        if (n.nodeType === 40) {
          const e = t.d.items[0].d.valueExpr;
          return e.nodeType === 40 && !e.d.isImaginary && !!e.d.isInteger && n.d.value === e.d.value;
        }
        if (n.nodeType === 55 && n.d.operator === 33 && n.d.expr.nodeType === 40) {
          const e = t.d.items[0].d.valueExpr;
          return e.nodeType === 55 && e.d.operator === 33 && e.d.expr.nodeType === 40 && !e.d.expr.d.isImaginary && !!e.d.expr.d.isInteger && n.d.expr.d.value === e.d.expr.d.value;
        }
        if (n.nodeType === 48) {
          const e = n;
          const a = t.d.items[0].d.valueExpr;
          if (e.d.strings.length === 1 && e.d.strings[0].nodeType === 49 && a.nodeType === 48 && a.d.strings.length === 1 && a.d.strings[0].nodeType === 49) {
            return e.d.strings[0].d.value === a.d.strings[0].d.value;
          }
        }
        return false;
      }
      return false;
    }
    function S(e) {
      if (e.d.statements.length === 0 || e.d.statements[0].nodeType !== 48) {
        return false;
      }
      const t = e.d.statements[0].d.strings;
      return t.length !== 0 && !t.some(e => e.nodeType === 30);
    }
    class A extends y.ParseTreeWalker {
      constructor(e) {
        super();
        this._callback = e;
      }
      visitName(e) {
        this._callback(e, this._subscriptIndex, this._baseExpression);
        return true;
      }
      visitIndex(e) {
        this.walk(e.d.leftExpr);
        const t = this._subscriptIndex;
        const n = this._baseExpression;
        this._baseExpression = e.d.leftExpr;
        e.d.items.forEach((e, t) => {
          this._subscriptIndex = t;
          this.walk(e);
        });
        this._subscriptIndex = t;
        this._baseExpression = n;
        return false;
      }
    }
    exports.NameNodeWalker = A;
    class x extends y.ParseTreeWalker {
      constructor(e) {
        super();
        this._callback = e;
      }
      visitCall(e) {
        this._callback(e);
        return true;
      }
    }
    function P(e, t, n = false, a = false) {
      const r = e.getItemAtPosition(t);
      if (r < 0) {
        return -1;
      }
      for (let s = r; s >= 0; s--) {
        const r = e.getItemAt(s);
        if ((a || r.length !== 0) && (n || !D(r)) && d.TextRange.getEnd(r) <= t) {
          return s;
        }
      }
      return -1;
    }
    function D(e) {
      return e.type === 2 || e.type === 3 || e.type === 4;
    }
    function N(e, t) {
      if (!(t < 0)) {
        return e.getItemAt(t);
      }
    }
    function F(e, t) {
      return N(e, e.getItemAtPosition(t));
    }
    function E(e, t) {
      const n = e.getItemAtPosition(t);
      if (n < 0) {
        return -1;
      }
      const a = e.getItemAt(n);
      if (d.TextRange.overlaps(a, t)) {
        return n;
      } else {
        return -1;
      }
    }
    function M(e) {
      let t = e;
      while (t && t.nodeType !== 36) {
        t = t.parent;
      }
      return t;
    }
    function* O(e) {
      while (e !== undefined) {
        yield e;
        e = e.parent;
      }
    }
    function z(e, t) {
      return U(e, e => e.nodeType === t);
    }
    function U(e, t) {
      for (const n of O(e)) {
        if (t(n)) {
          return n;
        }
      }
    }
    function V(e) {
      if (e.nodeType === 38) {
        return [e];
      }
      const t = [];
      if (function e(t, n) {
        if (t.nodeType === 38) {
          n.push(t);
          return true;
        }
        n.push(t.d.member);
        if (t.d.leftExpr.nodeType === 38 || t.d.leftExpr.nodeType === 35) {
          return e(t.d.leftExpr, n);
        }
        return false;
      }(e, t)) {
        return t.reverse();
      } else {
        return undefined;
      }
    }
    function R(e) {
      const t = e.quoteMarkLength;
      const n = !(e.flags & 65536);
      return d.TextRange.create(e.start + t, e.length - t - (n ? t : 0));
    }
    function L(e, t, n) {
      const a = e.lines.getItemAt(n);
      return o.containsOnlyWhitespace(t, a);
    }
    function B(e) {
      let t = '';
      if (e.nodeType === 10 || e.nodeType === 31) {
        t = e.d.name.d.value;
      }
      return `${i.getFileInfo(e).fileId}.${e.start.toString()}-${t}`;
    }
    exports.CallNodeWalker = x;
  },
  88744: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ParseTreeWalker = exports.ParseTreeVisitor = undefined;
    exports.getChildNodes = o;
    const i = __importStar(require(48281));
    function o(e) {
      var t;
      var n;
      switch (e.nodeType) {
        case 0:
          return [e.d.child, ...((t = e.d.decorators) !== null && t !== undefined ? t : [])];
        case 1:
          return [e.d.name, e.d.valueExpr];
        case 2:
          return [e.d.testExpr, e.d.exceptionExpr];
        case 4:
          return [e.d.name, e.d.rightExpr];
        case 3:
          return [e.d.leftExpr, e.d.rightExpr, e.d.annotationComment];
        case 5:
        case 7:
          return [e.d.leftExpr, e.d.rightExpr];
        case 6:
        case 16:
        case 19:
        case 67:
        case 73:
        case 44:
        case 55:
        case 56:
        case 60:
        case 61:
          return [e.d.expr];
        case 8:
        case 14:
        case 15:
        case 21:
        case 38:
        case 40:
        case 42:
        case 49:
          return [];
        case 9:
          return [e.d.leftExpr, ...e.d.args];
        case 64:
          return [e.d.pattern, e.d.guardExpr, e.d.suite];
        case 10:
          return [...e.d.decorators, e.d.name, e.d.typeParams, ...e.d.arguments, e.d.suite];
        case 11:
          return [e.d.expr, ...e.d.forIfNodes];
        case 12:
          return [e.d.targetExpr, e.d.iterableExpr];
        case 13:
          return [e.d.testExpr];
        case 17:
        case 32:
        case 39:
          return e.d.targets;
        case 18:
        case 34:
        case 45:
        case 52:
          return e.d.items;
        case 20:
          return [e.d.keyExpr, e.d.valueExpr];
        case 22:
          return [e.d.testExpr, e.d.ifSuite, e.d.elseSuite];
        case 23:
          return e.d.list;
        case 24:
          return [e.d.module, e.d.alias];
        case 25:
          return [e.d.module, ...e.d.imports];
        case 26:
          return [e.d.name, e.d.alias];
        case 27:
          return [e.d.leftExpr, ...e.d.items];
        case 28:
          return [e.d.typeExpr, e.d.name, e.d.exceptSuite];
        case 29:
          return [e.d.targetExpr, e.d.iterableExpr, e.d.forSuite, e.d.elseSuite];
        case 30:
          return [...e.d.fieldExprs, ...((n = e.d.formatExprs) !== null && n !== undefined ? n : [])];
        case 31:
          return [...e.d.decorators, e.d.name, e.d.typeParams, ...e.d.params, e.d.returnAnnotation, e.d.funcAnnotationComment, e.d.suite];
        case 62:
          return [...e.d.paramAnnotations, e.d.returnAnnotation];
        case 33:
          return [...e.d.params, e.d.expr];
        case 63:
          return [e.d.expr, ...e.d.cases];
        case 35:
          return [e.d.leftExpr, e.d.member];
        case 37:
          return e.d.nameParts;
        case 36:
        case 50:
          return [...e.d.statements];
        case 41:
          return [e.d.name, e.d.annotation, e.d.annotationComment, e.d.defaultValue];
        case 66:
          return [...e.d.orPatterns, e.d.target];
        case 68:
          return [e.d.className, ...e.d.args];
        case 74:
          return [e.d.name, e.d.pattern];
        case 69:
        case 72:
          return [e.d.target];
        case 71:
          return [e.d.keyPattern, e.d.valuePattern];
        case 70:
        case 65:
          return [...e.d.entries];
        case 43:
          return [e.d.expr, e.d.fromExpr];
        case 46:
          return [e.d.startValue, e.d.endValue, e.d.stepValue];
        case 47:
          return e.d.statements;
        case 48:
          return [e.d.annotation, ...e.d.strings];
        case 51:
          return [e.d.ifExpr, e.d.testExpr, e.d.elseExpr];
        case 53:
          return [e.d.trySuite, ...e.d.exceptClauses, e.d.elseSuite, e.d.finallySuite];
        case 77:
          return [e.d.name, e.d.typeParams, e.d.expr];
        case 54:
          return [e.d.valueExpr, e.d.annotation];
        case 75:
          return [e.d.name, e.d.boundExpr, e.d.defaultExpr];
        case 76:
          return [...e.d.params];
        case 57:
          return [e.d.testExpr, e.d.whileSuite, e.d.elseSuite];
        case 58:
          return [...e.d.withItems, e.d.suite];
        case 59:
          return [e.d.expr, e.d.target];
        default:
          i.assertNever(e, `Unknown node type ${e}`);
      }
    }
    class l {
      constructor(e) {
        this._default = e;
      }
      visit(e) {
        switch (e.nodeType) {
          case 0:
            return this.visitError(e);
          case 1:
            return this.visitArgument(e);
          case 2:
            return this.visitAssert(e);
          case 4:
            return this.visitAssignmentExpression(e);
          case 3:
            return this.visitAssignment(e);
          case 5:
            return this.visitAugmentedAssignment(e);
          case 6:
            return this.visitAwait(e);
          case 7:
            return this.visitBinaryOperation(e);
          case 8:
            return this.visitBreak(e);
          case 9:
            return this.visitCall(e);
          case 64:
            return this.visitCase(e);
          case 10:
            return this.visitClass(e);
          case 11:
            return this.visitComprehension(e);
          case 12:
            return this.visitComprehensionFor(e);
          case 13:
            return this.visitComprehensionIf(e);
          case 14:
            return this.visitConstant(e);
          case 15:
            return this.visitContinue(e);
          case 16:
            return this.visitDecorator(e);
          case 17:
            return this.visitDel(e);
          case 18:
            return this.visitDictionary(e);
          case 19:
            return this.visitDictionaryExpandEntry(e);
          case 20:
            return this.visitDictionaryKeyEntry(e);
          case 21:
            return this.visitEllipsis(e);
          case 22:
            return this.visitIf(e);
          case 23:
            return this.visitImport(e);
          case 24:
            return this.visitImportAs(e);
          case 25:
            return this.visitImportFrom(e);
          case 26:
            return this.visitImportFromAs(e);
          case 27:
            return this.visitIndex(e);
          case 28:
            return this.visitExcept(e);
          case 29:
            return this.visitFor(e);
          case 30:
            return this.visitFormatString(e);
          case 31:
            return this.visitFunction(e);
          case 62:
            return this.visitFunctionAnnotation(e);
          case 32:
            return this.visitGlobal(e);
          case 33:
            return this.visitLambda(e);
          case 34:
            return this.visitList(e);
          case 63:
            return this.visitMatch(e);
          case 35:
            return this.visitMemberAccess(e);
          case 37:
            return this.visitModuleName(e);
          case 36:
            return this.visitModule(e);
          case 38:
            return this.visitName(e);
          case 39:
            return this.visitNonlocal(e);
          case 40:
            return this.visitNumber(e);
          case 41:
            return this.visitParameter(e);
          case 42:
            return this.visitPass(e);
          case 66:
            return this.visitPatternAs(e);
          case 68:
            return this.visitPatternClass(e);
          case 74:
            return this.visitPatternClassArgument(e);
          case 69:
            return this.visitPatternCapture(e);
          case 67:
            return this.visitPatternLiteral(e);
          case 72:
            return this.visitPatternMappingExpandEntry(e);
          case 71:
            return this.visitPatternMappingKeyEntry(e);
          case 70:
            return this.visitPatternMapping(e);
          case 65:
            return this.visitPatternSequence(e);
          case 73:
            return this.visitPatternValue(e);
          case 43:
            return this.visitRaise(e);
          case 44:
            return this.visitReturn(e);
          case 45:
            return this.visitSet(e);
          case 46:
            return this.visitSlice(e);
          case 47:
            return this.visitStatementList(e);
          case 48:
            return this.visitStringList(e);
          case 49:
            return this.visitString(e);
          case 50:
            return this.visitSuite(e);
          case 51:
            return this.visitTernary(e);
          case 52:
            return this.visitTuple(e);
          case 53:
            return this.visitTry(e);
          case 77:
            return this.visitTypeAlias(e);
          case 54:
            return this.visitTypeAnnotation(e);
          case 75:
            return this.visitTypeParameter(e);
          case 76:
            return this.visitTypeParameterList(e);
          case 55:
            return this.visitUnaryOperation(e);
          case 56:
            return this.visitUnpack(e);
          case 57:
            return this.visitWhile(e);
          case 58:
            return this.visitWith(e);
          case 59:
            return this.visitWithItem(e);
          case 60:
            return this.visitYield(e);
          case 61:
            return this.visitYieldFrom(e);
          default:
            i.assertNever(e, `Unknown node type ${e}`);
        }
      }
      visitArgument(e) {
        return this._default;
      }
      visitAssert(e) {
        return this._default;
      }
      visitAssignment(e) {
        return this._default;
      }
      visitAssignmentExpression(e) {
        return this._default;
      }
      visitAugmentedAssignment(e) {
        return this._default;
      }
      visitAwait(e) {
        return this._default;
      }
      visitBinaryOperation(e) {
        return this._default;
      }
      visitBreak(e) {
        return this._default;
      }
      visitCall(e) {
        return this._default;
      }
      visitCase(e) {
        return this._default;
      }
      visitClass(e) {
        return this._default;
      }
      visitComprehension(e) {
        return this._default;
      }
      visitComprehensionFor(e) {
        return this._default;
      }
      visitComprehensionIf(e) {
        return this._default;
      }
      visitContinue(e) {
        return this._default;
      }
      visitConstant(e) {
        return this._default;
      }
      visitDecorator(e) {
        return this._default;
      }
      visitDel(e) {
        return this._default;
      }
      visitDictionary(e) {
        return this._default;
      }
      visitDictionaryKeyEntry(e) {
        return this._default;
      }
      visitDictionaryExpandEntry(e) {
        return this._default;
      }
      visitError(e) {
        return this._default;
      }
      visitEllipsis(e) {
        return this._default;
      }
      visitIf(e) {
        return this._default;
      }
      visitImport(e) {
        return this._default;
      }
      visitImportAs(e) {
        return this._default;
      }
      visitImportFrom(e) {
        return this._default;
      }
      visitImportFromAs(e) {
        return this._default;
      }
      visitIndex(e) {
        return this._default;
      }
      visitExcept(e) {
        return this._default;
      }
      visitFor(e) {
        return this._default;
      }
      visitFormatString(e) {
        return this._default;
      }
      visitFunction(e) {
        return this._default;
      }
      visitFunctionAnnotation(e) {
        return this._default;
      }
      visitGlobal(e) {
        return this._default;
      }
      visitLambda(e) {
        return this._default;
      }
      visitList(e) {
        return this._default;
      }
      visitMatch(e) {
        return this._default;
      }
      visitMemberAccess(e) {
        return this._default;
      }
      visitModule(e) {
        return this._default;
      }
      visitModuleName(e) {
        return this._default;
      }
      visitName(e) {
        return this._default;
      }
      visitNonlocal(e) {
        return this._default;
      }
      visitNumber(e) {
        return this._default;
      }
      visitParameter(e) {
        return this._default;
      }
      visitPass(e) {
        return this._default;
      }
      visitPatternCapture(e) {
        return this._default;
      }
      visitPatternClass(e) {
        return this._default;
      }
      visitPatternClassArgument(e) {
        return this._default;
      }
      visitPatternAs(e) {
        return this._default;
      }
      visitPatternLiteral(e) {
        return this._default;
      }
      visitPatternMapping(e) {
        return this._default;
      }
      visitPatternMappingExpandEntry(e) {
        return this._default;
      }
      visitPatternMappingKeyEntry(e) {
        return this._default;
      }
      visitPatternSequence(e) {
        return this._default;
      }
      visitPatternValue(e) {
        return this._default;
      }
      visitRaise(e) {
        return this._default;
      }
      visitReturn(e) {
        return this._default;
      }
      visitSet(e) {
        return this._default;
      }
      visitSlice(e) {
        return this._default;
      }
      visitStatementList(e) {
        return this._default;
      }
      visitString(e) {
        return this._default;
      }
      visitStringList(e) {
        return this._default;
      }
      visitSuite(e) {
        return this._default;
      }
      visitTernary(e) {
        return this._default;
      }
      visitTuple(e) {
        return this._default;
      }
      visitTry(e) {
        return this._default;
      }
      visitTypeAlias(e) {
        return this._default;
      }
      visitTypeAnnotation(e) {
        return this._default;
      }
      visitTypeParameter(e) {
        return this._default;
      }
      visitTypeParameterList(e) {
        return this._default;
      }
      visitUnaryOperation(e) {
        return this._default;
      }
      visitUnpack(e) {
        return this._default;
      }
      visitWhile(e) {
        return this._default;
      }
      visitWith(e) {
        return this._default;
      }
      visitWithItem(e) {
        return this._default;
      }
      visitYield(e) {
        return this._default;
      }
      visitYieldFrom(e) {
        return this._default;
      }
    }
    exports.ParseTreeVisitor = l;
    exports.ParseTreeWalker = class extends l {
      constructor() {
        super(true);
      }
      walk(e) {
        const t = this.visitNode(e);
        if (t.length > 0) {
          this.walkMultiple(t);
        }
      }
      walkMultiple(e) {
        e.forEach(e => {
          if (e) {
            this.walk(e);
          }
        });
      }
      visitNode(e) {
        if (this.visit(e)) {
          return o(e);
        } else {
          return [];
        }
      }
    };
  },
  69932: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.narrowTypeBasedOnPattern = f;
    exports.checkForUnusedPattern = function (e, t, n) {
      if (m.isNever(n)) {
        w(e, t, n);
      } else {
        if (t.nodeType === 66 && t.d.orPatterns.length > 1) {
          t.d.orPatterns.forEach(t => {
            const a = f(e, n, t, true);
            if (m.isNever(a)) {
              w(e, t, n);
            }
            n = f(e, n, t, false);
          });
        } else {
          const a = f(e, n, t, true);
          if (m.isNever(a)) {
            w(e, t, n);
          }
        }
      }
    };
    exports.assignTypeToPatternTargets = function e(t, n, a, r) {
      const l = f(t, n, r, true);
      switch (r.nodeType) {
        case 65:
          {
            const n = C(t, r, l).filter(e => !e.isDefiniteNoMatch);
            r.d.entries.forEach((s, i) => {
              const o = m.combineTypes(n.map(e => I(t, r, e, i, r.d.entries.length, r.d.starEntryIndex, false)));
              e(t, o, a, s);
            });
            break;
          }
        case 66:
          {
            if (r.d.target) {
              t.assignTypeToExpression(r.d.target, {
                type: l,
                isIncomplete: a
              }, r.d.target);
            }
            let n = l;
            r.d.orPatterns.forEach(r => {
              e(t, n, a, r);
              n = f(t, n, r, false);
            });
            break;
          }
        case 69:
          if (r.d.isWildcard) {
            if (!a) {
              if (m.isUnknown(l)) {
                t.addDiagnostic(i.DiagnosticRule.reportUnknownVariableType, o.LocMessage.wildcardPatternTypeUnknown(), r.d.target);
              } else {
                if (y.isPartlyUnknown(l)) {
                  const e = new s.DiagnosticAddendum();
                  e.addMessage(o.LocAddendum.typeOfSymbol().format({
                    name: '_',
                    type: t.printType(l, {
                      expandTypeAlias: true
                    })
                  }));
                  t.addDiagnostic(i.DiagnosticRule.reportUnknownVariableType, o.LocMessage.wildcardPatternTypePartiallyUnknown() + e.getString(), r.d.target);
                }
              }
            }
          } else {
            t.assignTypeToExpression(r.d.target, {
              type: l,
              isIncomplete: a
            }, r.d.target);
          }
          break;
        case 70:
          {
            const n = _(t, l, r);
            r.d.entries.forEach(s => {
              const i = [];
              const o = [];
              n.forEach(e => {
                if (e.typedDict) {
                  if (s.nodeType === 71) {
                    const n = f(t, t.getBuiltInObject(r, 'str'), s.d.keyPattern, true);
                    i.push(n);
                    y.doForEachSubtype(n, n => {
                      if (m.isClassInstance(n) && m.ClassType.isBuiltIn(n, 'str') && y.isLiteralType(n)) {
                        const a = c.getTypedDictMembersForClass(t, e.typedDict).knownItems.get(n.priv.literalValue);
                        o.push(a ? a.valueType : m.UnknownType.create());
                      } else {
                        o.push(m.UnknownType.create());
                      }
                    });
                  } else {
                    if (s.nodeType === 72) {
                      i.push(t.getBuiltInObject(r, 'str'));
                      o.push(t.getObjectType());
                    }
                  }
                } else {
                  if (e.dictTypeArgs) {
                    if (s.nodeType === 71) {
                      const n = f(t, e.dictTypeArgs.key, s.d.keyPattern, true);
                      i.push(n);
                      o.push(f(t, e.dictTypeArgs.value, s.d.valuePattern, true));
                    } else {
                      if (s.nodeType === 72) {
                        i.push(e.dictTypeArgs.key);
                        o.push(e.dictTypeArgs.value);
                      }
                    }
                  }
                }
              });
              const l = m.combineTypes(i);
              const p = m.combineTypes(o);
              if (s.nodeType === 71) {
                e(t, l, a, s.d.keyPattern);
                e(t, p, a, s.d.valuePattern);
              } else {
                if (s.nodeType === 72) {
                  const e = t.getBuiltInType(r, 'dict');
                  const n = t.getBuiltInObject(r, 'str');
                  const i = e && m.isInstantiableClass(e) && m.isClassInstance(n) ? m.ClassType.cloneAsInstance(m.ClassType.specialize(e, [l, p])) : m.UnknownType.create();
                  t.assignTypeToExpression(s.d.target, {
                    type: i,
                    isIncomplete: a
                  }, s.d.target);
                }
              }
            });
            break;
          }
        case 68:
          {
            const n = r.d.args.map(e => []);
            t.mapSubtypesExpandTypeVars(l, undefined, e => {
              if (m.isClassInstance(e)) {
                y.doForEachSubtype(l, a => {
                  const s = t.makeTopLevelTypeVarsConcrete(a);
                  if (m.isAnyOrUnknown(s)) {
                    r.d.args.forEach((e, t) => {
                      n[t].push(s);
                    });
                  } else {
                    if (m.isClassInstance(s)) {
                      let a = [];
                      if (r.d.args.some(e => !e.d.name)) {
                        a = T(t, m.ClassType.cloneAsInstantiable(e));
                      }
                      r.d.args.forEach((r, s) => {
                        const i = b(t, r, s, a, m.ClassType.cloneAsInstantiable(e), true);
                        n[s].push(i);
                      });
                    }
                  }
                });
              } else {
                r.d.args.forEach((e, t) => {
                  n[t].push(m.UnknownType.create());
                });
              }
            });
            r.d.args.forEach((r, s) => {
              e(t, m.combineTypes(n[s]), a, r.d.pattern);
            });
            break;
          }
      }
      return l;
    };
    exports.validateClassPattern = function (e, t) {
      var n;
      var a;
      let r = e.getTypeOfExpression(t.d.className, 2).type;
      if ((n = r.props) === null || n === undefined ? undefined : n.specialForm) {
        r = r.props.specialForm;
      }
      if (m.isAnyOrUnknown(r)) {
        return;
      }
      if (((a = r.props) === null || a === undefined ? undefined : a.typeAliasInfo) && m.isInstantiableClass(r) && r.priv.typeArgs && r.priv.isTypeArgExplicit) {
        e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocMessage.classPatternTypeAlias().format({
          type: e.printType(r)
        }), t.d.className);
      } else {
        if (m.isInstantiableClass(r)) {
          const n = v(r);
          if (n && t.d.args.length === 1 && t.d.args[0].d.name) {
            e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocMessage.classPatternBuiltInArgPositional(), t.d.args[0].d.name);
          }
          let a = t.d.args.findIndex(e => e.d.name !== undefined);
          if (a < 0) {
            a = t.d.args.length;
          }
          let s = 1;
          if (!n) {
            let n = [];
            if (t.d.args.some(e => !e.d.name)) {
              n = T(e, r);
            }
            s = n.length;
          }
          if (a > s) {
            e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocMessage.classPatternPositionalArgCount().format({
              type: r.shared.name,
              expected: s,
              received: a
            }), t.d.args[s]);
          }
        } else {
          if (!m.isNever(r)) {
            e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocAddendum.typeNotClass().format({
              type: e.printType(r)
            }), t.d.className);
          }
        }
      }
    };
    exports.getPatternSubtypeNarrowingCallback = function (e, t, n) {
      if (n.nodeType === 27 && n.d.items.length === 1 && !n.d.trailingComma && n.d.items[0].d.argCategory === 0 && d.isMatchingExpression(t, n.d.leftExpr)) {
        const t = e.getTypeOfExpression(n.d.items[0].d.valueExpr);
        const a = t.type;
        if (m.isClassInstance(a) && y.isLiteralType(a) && m.ClassType.isBuiltIn(a, ['int', 'str'])) {
          const r = e.getTypeOfExpression(n.d.leftExpr, 2);
          const s = r.type;
          return n => {
            let i = true;
            const o = [];
            y.doForEachSubtype(n, t => {
              t = e.makeTopLevelTypeVarsConcrete(t);
              if (m.isClassInstance(t) && t.priv.literalValue !== undefined) {
                if (m.ClassType.isBuiltIn(a, 'str')) {
                  o.push(u.narrowTypeForDiscriminatedDictEntryComparison(e, s, a, t, true));
                } else {
                  o.push(u.narrowTypeForDiscriminatedTupleComparison(e, s, a, t, true));
                }
              } else {
                if (!m.isNever(t)) {
                  i = false;
                }
              }
            });
            if (i) {
              return {
                type: m.combineTypes(o),
                isIncomplete: t.isIncomplete || r.isIncomplete
              };
            }
          };
        }
      }
      if (n.nodeType === 52) {
        const a = n.d.items.findIndex(e => d.isMatchingExpression(t, e));
        if (a >= 0) {
          const t = e.getTypeOfExpression(n.d.items[a]);
          return e => {
            let n = true;
            const r = [];
            y.doForEachSubtype(e, t => {
              if (m.isClassInstance(t) && m.ClassType.isBuiltIn(t, 'tuple') && t.priv.tupleTypeArgs && a < t.priv.tupleTypeArgs.length && t.priv.tupleTypeArgs.every(e => !e.isUnbounded)) {
                r.push(t.priv.tupleTypeArgs[a].type);
              } else {
                if (m.isNever(e)) {
                  r.push(e);
                } else {
                  n = false;
                }
              }
            });
            if (n) {
              return {
                type: m.combineTypes(r),
                isIncomplete: t.isIncomplete
              };
            } else {
              return undefined;
            }
          };
        }
      }
      if (n.nodeType === 35 && d.isMatchingExpression(t, n.d.leftExpr)) {
        const t = e.getTypeOfExpression(n.d.leftExpr, 2).type;
        return a => {
          if (m.isNever(a)) {
            return {
              type: m.NeverType.createNever()
            };
          }
          if (!y.isLiteralTypeOrUnion(a)) {
            return;
          }
          return {
            type: y.mapSubtypes(a, a => {
              r.assert(m.isClassInstance(a) && a.priv.literalValue !== undefined);
              return u.narrowTypeForDiscriminatedLiteralFieldComparison(e, t, n.d.member.d.value, a, true);
            })
          };
        };
      }
      return;
    };
    const a = require(58147);
    const r = require(48281);
    const s = require(11479);
    const i = require(65880);
    const o = require(67703);
    const l = require(10081);
    const p = require(86672);
    const d = require(41557);
    const c = require(66308);
    const u = require(18891);
    const m = require(21024);
    const y = require(92324);
    const g = ['builtins.bool', 'builtins.bytearray', 'builtins.bytes', 'builtins.dict', 'builtins.float', 'builtins.frozenset', 'builtins.int', 'builtins.list', 'builtins.set', 'builtins.str', 'builtins.tuple'];
    const h = 128;
    function f(e, t, n, r) {
      switch (n.nodeType) {
        case 65:
          return function (e, t, n, r) {
            let s = false;
            t = y.transformPossibleRecursiveTypeAlias(t);
            let i = C(e, n, t);
            i = i.filter(t => {
              var i;
              if (t.isDefiniteNoMatch) {
                return !r;
              }
              let o = true;
              let l = true;
              const p = [];
              const d = [];
              let c = t.isTuple;
              if (!r && ((t.isIndeterminateLength || t.isUnboundedTuple) && (c = false), m.isClassInstance(t.subtype) && t.subtype.priv.tupleTypeArgs)) {
                const e = t.subtype.priv.tupleTypeArgs.findIndex(e => e.isUnbounded);
                if (e >= 0) {
                  if (n.d.starEntryIndex === undefined || n.d.starEntryIndex !== e) {
                    c = false;
                  }
                }
              }
              if (t.isIndeterminateLength) {
                if (n.d.entries.length !== 1 || n.d.starEntryIndex !== 0) {
                  l = false;
                }
              }
              const u = [];
              n.d.entries.forEach((s, i) => {
                const g = I(e, n, t, i, n.d.entries.length, n.d.starEntryIndex, true);
                d.push(g);
                const h = f(e, g, s, r);
                if (r) {
                  if (i === n.d.starEntryIndex) {
                    if (m.isClassInstance(h) && h.priv.tupleTypeArgs && !y.isUnboundedTupleClass(h) && h.priv.tupleTypeArgs) {
                      a.appendArray(p, h.priv.tupleTypeArgs.map(e => e.type));
                    } else {
                      p.push(h);
                      c = false;
                    }
                  } else {
                    p.push(h);
                    if (m.isNever(h)) {
                      o = false;
                    }
                  }
                } else {
                  if (t.isPotentialNoMatch) {
                    l = false;
                  }
                  if (m.isNever(h)) {
                    p.push(g);
                  } else {
                    l = false;
                    u.push(i);
                    p.push(h);
                  }
                  if (i === n.d.starEntryIndex) {
                    c = false;
                  }
                }
              });
              if (n.d.entries.length === 0) {
                if (t.entryTypes.length > 0) {
                  p.push(m.combineTypes(t.entryTypes));
                }
                if (t.isPotentialNoMatch) {
                  l = false;
                }
              }
              if (!r) {
                if (l) {
                  return false;
                }
                if (c && u.length > 0) {
                  const a = e.getBuiltInType(n, 'tuple');
                  if (a && m.isInstantiableClass(a)) {
                    const e = [];
                    for (const t of u) {
                      const n = [...d];
                      n[t] = p[t];
                      e.push(n);
                    }
                    t.subtype = m.combineTypes(e.map(e => m.ClassType.cloneAsInstance(y.specializeTupleClass(a, e.map(e => ({
                      type: e,
                      isUnbounded: false
                    }))))));
                    s = true;
                  }
                }
                return true;
              }
              if (o) {
                if (c) {
                  const a = e.getBuiltInType(n, 'tuple');
                  if (a && m.isInstantiableClass(a)) {
                    t.subtype = m.ClassType.cloneAsInstance(y.specializeTupleClass(a, p.map(e => ({
                      type: e,
                      isUnbounded: false
                    }))));
                  }
                }
                if (t.isPotentialNoMatch && !t.isTuple) {
                  const a = e.getTypingType(n, 'Sequence');
                  if (a && m.isInstantiableClass(a)) {
                    let n = e.stripLiteralValue(m.combineTypes(p));
                    n = (i = y.containsAnyOrUnknown(n, false)) !== null && i !== undefined ? i : n;
                    t.subtype = m.ClassType.cloneAsInstance(m.ClassType.specialize(a, [n]));
                  }
                }
              }
              return o;
            });
            return m.combineTypes(i.map(e => e.subtype), {
              maxSubtypeCount: s ? h : undefined
            });
          }(e, t, n, r);
        case 67:
          return function (e, t, n, a) {
            const r = e.getTypeOfExpression(n.d.expr).type;
            if (!a) {
              return e.mapSubtypesExpandTypeVars(t, undefined, t => {
                if ((!m.isClassInstance(r) || !y.isLiteralType(r) || !m.isClassInstance(t) || !y.isLiteralType(t) || !e.assignType(r, t)) && (!y.isNoneInstance(t) || !y.isNoneInstance(r))) {
                  if (m.isClassInstance(t) && m.ClassType.isBuiltIn(t, 'bool') && t.priv.literalValue === undefined && m.isClassInstance(r) && m.ClassType.isBuiltIn(r, 'bool') && r.priv.literalValue !== undefined) {
                    return m.ClassType.cloneWithLiteral(r, !r.priv.literalValue);
                  } else {
                    return t;
                  }
                }
              });
            }
            return e.mapSubtypesExpandTypeVars(t, undefined, (t, n) => e.assignType(t, r) ? r : m.isClassInstance(r) && y.isLiteralType(r) && m.isClassInstance(t) && !y.isLiteralType(t) && e.assignType(m.ClassType.cloneWithLiteral(r, undefined), t) ? t : undefined);
          }(e, t, n, r);
        case 68:
          return function (e, t, n, a) {
            var r;
            let s = e.getTypeOfExpression(n.d.className, 2).type;
            if (m.isClass(s) && !((r = s.props) === null || r === undefined ? undefined : r.typeAliasInfo)) {
              s = m.ClassType.cloneRemoveTypePromotions(s);
              s = y.specializeWithUnknownTypeArgs(s, e.getTupleClassType());
            }
            let d = [];
            if (n.d.args.some(e => !e.d.name) && m.isInstantiableClass(s)) {
              d = T(e, s);
            }
            if (!a) {
              if (!m.isInstantiableClass(s)) {
                return t;
              }
              let r = s;
              if (r.shared.typeParams.length > 0) {
                r = m.ClassType.specialize(r, undefined);
              }
              const i = m.ClassType.cloneAsInstance(r);
              const o = y.isMetaclassInstance(i);
              return e.mapSubtypesExpandTypeVars(t, {
                expandCallback: t => e.expandPromotionTypes(n, t)
              }, (t, s) => {
                var l;
                if (o && m.isInstantiableClass(t)) {
                  const n = (l = t.shared.effectiveMetaclass) !== null && l !== undefined ? l : m.UnknownType.create();
                  if (m.isInstantiableClass(r) && e.assignType(r, n)) {
                    return;
                  }
                  return t;
                }
                if (m.isAnyOrUnknown(t) || !m.isInstantiableClass(r) || !m.ClassType.isBuiltIn(r, 'Callable') || !e.assignType(y.getUnknownTypeForCallable(), t)) {
                  if (!y.isNoneInstance(t) && !m.isClassInstance(t)) {
                    return s;
                  }
                  if (!y.isNoneInstance(t) || !m.isInstantiableClass(r) || !m.ClassType.isBuiltIn(r, 'NoneType')) {
                    if (!e.assignType(i, t)) {
                      return t;
                    }
                    if (n.d.args.length === 0) {
                      if (m.isClass(i) && m.isClass(t)) {
                        return;
                      }
                      return t;
                    }
                    if (!e.assignType(t, i) && m.isClass(t) && !m.ClassType.isFinal(t) && !m.ClassType.isProtocolClass(i)) {
                      return t;
                    }
                    for (let r = 0; r < n.d.args.length; r++) {
                      const i = b(e, n.d.args[r], r, d, t, a);
                      if (!m.isNever(i)) {
                        return s;
                      }
                    }
                  }
                }
              });
            }
            if (!m.TypeBase.isInstantiable(s) && !m.isNever(s)) {
              e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocAddendum.typeNotClass().format({
                type: e.printType(s)
              }), n.d.className);
              if (a) {
                return m.UnknownType.create();
              } else {
                return t;
              }
            }
            if (m.isInstantiableClass(s)) {
              if (m.ClassType.isProtocolClass(s) && !m.ClassType.isRuntimeCheckable(s)) {
                e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocAddendum.protocolRequiresRuntimeCheckable(), n.d.className);
                if (a) {
                  return m.UnknownType.create();
                } else {
                  return t;
                }
              }
              if (m.ClassType.isTypedDictClass(s)) {
                e.addDiagnostic(i.DiagnosticRule.reportGeneralTypeIssues, o.LocMessage.typedDictInClassPattern(), n.d.className);
                if (a) {
                  return m.UnknownType.create();
                } else {
                  return t;
                }
              }
            }
            return e.mapSubtypesExpandTypeVars(s, undefined, (r, s) => {
              if (m.isAnyOrUnknown(r)) {
                return s;
              }
              if (m.isInstantiableClass(r)) {
                const i = y.convertToInstance(r);
                const o = y.isMetaclassInstance(i);
                return e.mapSubtypesExpandTypeVars(t, undefined, t => {
                  var i;
                  if (m.isAnyOrUnknown(t)) {
                    if (m.isInstantiableClass(r) && m.ClassType.isBuiltIn(r, 'Callable')) {
                      const e = m.FunctionType.createSynthesizedInstance('', 32768);
                      m.FunctionType.addDefaultParams(e, m.isUnknown(t));
                      e.shared.declaredReturnType = t;
                      return e;
                    }
                    return y.convertToInstance(s);
                  }
                  if (o && m.isInstantiableClass(t)) {
                    const n = (i = t.shared.effectiveMetaclass) !== null && i !== undefined ? i : m.UnknownType.create();
                    if (e.assignType(r, n) || e.assignType(n, r)) {
                      return t;
                    } else {
                      return undefined;
                    }
                  }
                  if (y.isNoneInstance(t) && m.isInstantiableClass(r) && m.ClassType.isBuiltIn(r, 'NoneType')) {
                    return t;
                  }
                  if (m.isInstantiableClass(r) && m.ClassType.isBuiltIn(r, 'Callable')) {
                    const n = y.getUnknownTypeForCallable();
                    if (e.assignType(n, t)) {
                      return t;
                    }
                    const a = y.convertToInstance(t);
                    if (e.assignType(a, n)) {
                      return n;
                    } else {
                      return undefined;
                    }
                  }
                  if (m.isClassInstance(t)) {
                    let i;
                    if (e.assignType(m.ClassType.cloneAsInstance(r), t)) {
                      i = t;
                    } else {
                      if (!e.assignType(t, m.ClassType.cloneAsInstance(r))) {
                        return;
                      }
                      i = y.addConditionToType(y.convertToInstance(s), y.getTypeCondition(t));
                      if (m.isInstantiableClass(s) && m.isClassInstance(t) && (m.ClassType.isSpecialBuiltIn(s) || s.shared.typeParams.length > 0)) {
                        const n = new p.ConstraintTracker();
                        const a = m.ClassType.specialize(s, undefined);
                        const r = m.ClassType.cloneAsInstance(a);
                        if (l.addConstraintsForExpectedType(e, r, t, n, undefined, undefined)) {
                          i = e.solveAndApplyConstraints(r, n, {
                            replaceUnsolved: {
                              scopeIds: y.getTypeVarScopeIds(s),
                              tupleClassType: e.getTupleClassType()
                            }
                          });
                        }
                      }
                    }
                    let o = [];
                    if (n.d.args.some(e => !e.d.name)) {
                      o = T(e, r);
                    }
                    let d = true;
                    n.d.args.forEach((t, n) => {
                      const r = b(e, t, n, o, i, a);
                      if (m.isNever(r)) {
                        d = false;
                      }
                    });
                    if (d) {
                      return i;
                    }
                  }
                });
              }
            });
          }(e, t, n, r);
        case 66:
          return function (e, t, n, a) {
            let r = t;
            if (!a) {
              n.d.orPatterns.forEach(t => {
                r = f(e, r, t, false);
              });
              return r;
            }
            const s = n.d.orPatterns.map(t => {
              const n = f(e, r, t, true);
              r = f(e, r, t, false);
              return n;
            });
            return m.combineTypes(s);
          }(e, t, n, r);
        case 70:
          return function (e, t, n, a) {
            t = y.transformPossibleRecursiveTypeAlias(t);
            if (!a) {
              if (n.d.entries.length === 1 && n.d.entries[0].nodeType === 72) {
                const a = _(e, t, n);
                return m.combineTypes(a.filter(e => !e.isDefinitelyMapping).map(e => e.subtype));
              }
              if (n.d.entries.length !== 1 || n.d.entries[0].nodeType !== 71) {
                return t;
              }
              const a = n.d.entries[0].d.keyPattern;
              const r = n.d.entries[0].d.valuePattern;
              if (a.nodeType !== 67 || r.nodeType !== 66 || !r.d.orPatterns.every(e => e.nodeType === 67)) {
                return t;
              }
              const s = e.getTypeOfExpression(a.d.expr).type;
              if (!m.isClassInstance(s) || !m.ClassType.isBuiltIn(s, 'str') || s.priv.literalValue === undefined) {
                return t;
              }
              const i = s.priv.literalValue;
              const o = r.d.orPatterns.map(t => e.getTypeOfExpression(t.d.expr).type);
              return y.mapSubtypes(t, t => {
                if (m.isClassInstance(t) && m.ClassType.isTypedDictClass(t)) {
                  const n = c.getTypedDictMembersForClass(e, t, true).knownItems.get(i);
                  if (n && (n.isRequired || n.isProvided) && m.isClassInstance(n.valueType)) {
                    const e = n.valueType;
                    if (o.some(t => m.isClassInstance(t) && m.ClassType.isSameGenericClass(t, e) && t.priv.literalValue === e.priv.literalValue)) {
                      return;
                    }
                  }
                }
                return t;
              });
            }
            let r = _(e, t, n);
            r = r.filter(t => {
              if (t.isDefinitelyNotMapping) {
                return false;
              }
              let r = true;
              n.d.entries.forEach(s => {
                if (t.typedDict) {
                  if (s.nodeType === 71) {
                    const i = f(e, e.getBuiltInObject(n, 'str'), s.d.keyPattern, a);
                    if (m.isNever(i)) {
                      r = false;
                    }
                    const o = y.mapSubtypes(i, n => {
                      if (m.isAnyOrUnknown(n)) {
                        return n;
                      }
                      if (m.isClassInstance(n) && m.ClassType.isBuiltIn(n, 'str')) {
                        if (!y.isLiteralType(n)) {
                          return m.UnknownType.create();
                        }
                        const r = c.getTypedDictMembersForClass(e, t.typedDict).knownItems.get(n.priv.literalValue);
                        if (r) {
                          const i = f(e, r.valueType, s.d.valuePattern, true);
                          if (!m.isNever(i)) {
                            if (!r.isRequired && !r.isProvided && m.isTypeSame(t.subtype, t.typedDict)) {
                              const e = new Map(t.typedDict.priv.typedDictNarrowedEntries ?? []);
                              e.set(n.priv.literalValue, {
                                valueType: r.valueType,
                                isReadOnly: r.isReadOnly,
                                isRequired: false,
                                isProvided: true
                              });
                              t.subtype = m.ClassType.cloneAsInstance(m.ClassType.cloneForNarrowedTypedDictEntries(m.ClassType.cloneAsInstantiable(t.typedDict), e));
                              t.typedDict = t.subtype;
                            }
                            return i;
                          }
                        }
                      }
                    });
                    if (m.isNever(o)) {
                      r = false;
                    }
                  }
                } else {
                  if (t.dictTypeArgs && s.nodeType === 71) {
                    const n = f(e, t.dictTypeArgs.key, s.d.keyPattern, a);
                    const i = f(e, t.dictTypeArgs.value, s.d.valuePattern, a);
                    if (m.isNever(n) || m.isNever(i)) {
                      r = false;
                    }
                  }
                }
              });
              return r;
            });
            return m.combineTypes(r.map(e => e.subtype));
          }(e, t, n, r);
        case 73:
          return function (e, t, n, a) {
            const r = e.getTypeOfExpression(n.d.expr).type;
            const s = [];
            e.mapSubtypesExpandTypeVars(r, undefined, (r, i) => {
              s.push(e.mapSubtypesExpandTypeVars(t, {
                conditionFilter: y.getTypeCondition(r)
              }, t => {
                if (!a) {
                  if (m.isClassInstance(t) && m.isClassInstance(r) && m.isSameWithoutLiteralValue(t, r)) {
                    if (!y.isLiteralType(t) && y.isLiteralType(r)) {
                      const n = u.enumerateLiteralsForType(e, t);
                      if (n) {
                        return m.combineTypes(n.filter(e => !m.ClassType.isLiteralValueSame(r, e)));
                      }
                    }
                    if (y.isLiteralType(t) && m.ClassType.isLiteralValueSame(r, t)) {
                      return;
                    }
                  }
                  return t;
                }
                if (m.isNever(r) || m.isNever(t)) {
                  return m.NeverType.createNever();
                }
                if (m.isAnyOrUnknown(r) || m.isAnyOrUnknown(t)) {
                  if (m.isUnknown(r) || m.isUnknown(t)) {
                    return y.preserveUnknown(r, t);
                  } else {
                    return m.AnyType.create();
                  }
                }
                if (m.isClassInstance(t) && y.isLiteralType(t) && m.isClassInstance(r) && y.isLiteralType(r)) {
                  if (m.isSameWithoutLiteralValue(t, r) && m.ClassType.isLiteralValueSame(r, t)) {
                    return i;
                  } else {
                    return undefined;
                  }
                }
                if (e.useSpeculativeMode(n.d.expr, () => e.getTypeOfMagicMethodCall(r, '__eq__', [{
                  type: t
                }], n.d.expr, undefined))) {
                  return i;
                } else {
                  return undefined;
                }
              }));
            });
            return m.combineTypes(s);
          }(e, t, n, r);
        case 69:
          if (r) {
            return t;
          } else {
            return m.NeverType.createNever();
          }
        case 0:
          return t;
      }
    }
    function T(e, t) {
      const n = y.lookUpClassMember(t, '__match_args__');
      if (n) {
        const t = e.getTypeOfMember(n);
        if (m.isClassInstance(t) && y.isTupleClass(t) && !y.isUnboundedTupleClass(t) && t.priv.tupleTypeArgs) {
          const e = t.priv.tupleTypeArgs;
          if (e.every(e => m.isClassInstance(e.type) && m.ClassType.isBuiltIn(e.type, 'str') && y.isLiteralType(e.type))) {
            return e.map(e => e.type.priv.literalValue);
          }
        }
      }
      return [];
    }
    function v(e) {
      if (g.some(t => e.shared.fullName === t)) {
        return true;
      }
      if (y.lookUpClassMember(e, '__match_args__')) {
        return false;
      }
      for (const t of e.shared.mro) {
        if (m.isClass(t) && g.some(e => t.shared.fullName === e)) {
          return true;
        }
      }
      return false;
    }
    function b(e, t, n, a, r, s) {
      var i;
      let o;
      if (t.d.name) {
        o = t.d.name.d.value;
      } else {
        if (n < a.length) {
          o = a[n];
        }
      }
      if (m.isAnyOrUnknown(r)) {
        return r;
      }
      if (!m.isClass(r)) {
        return m.UnknownType.create();
      }
      let l;
      let p = false;
      let d = r;
      if (!t.d.name && m.isClass(r) && n === 0) {
        if (v(r)) {
          p = true;
        } else {
          if (a.length === 0) {
            r.shared.mro.forEach(e => {
              if (m.isClass(e) && v(e)) {
                d = e;
                p = true;
              }
            });
          }
        }
      }
      if (p) {
        l = m.ClassType.cloneAsInstance(d);
      } else {
        if (o) {
          l = (i = e.useSpeculativeMode(t, () => e.getTypeOfBoundMember(t, m.ClassType.cloneAsInstance(r), o))) === null || i === undefined ? undefined : i.type;
        }
        if (!l) {
          if (!s) {
            return r;
          }
          if (m.ClassType.isFinal(r)) {
            return m.NeverType.createNever();
          }
          l = m.UnknownType.create();
        }
      }
      return f(e, l, t.d.pattern, s);
    }
    function _(e, t, n) {
      const a = [];
      y.doForEachSubtype(t, t => {
        const r = e.makeTopLevelTypeVarsConcrete(t);
        if (m.isAnyOrUnknown(r)) {
          a.push({
            subtype: t,
            isDefinitelyMapping: false,
            isDefinitelyNotMapping: false,
            dictTypeArgs: {
              key: r,
              value: r
            }
          });
        } else {
          if (m.isClassInstance(r)) {
            if (m.ClassType.isTypedDictClass(r)) {
              a.push({
                subtype: t,
                isDefinitelyMapping: true,
                isDefinitelyNotMapping: false,
                typedDict: r
              });
              return;
            }
            const s = e.getTypingType(n, 'Mapping');
            if (!s || !m.isInstantiableClass(s)) {
              return;
            }
            const i = m.ClassType.cloneAsInstance(s);
            const o = new p.ConstraintTracker();
            if (e.assignType(i, t, undefined, o)) {
              const n = e.solveAndApplyConstraints(i, o);
              if (n.priv.typeArgs && n.priv.typeArgs.length >= 2) {
                a.push({
                  subtype: t,
                  isDefinitelyMapping: true,
                  isDefinitelyNotMapping: false,
                  dictTypeArgs: {
                    key: n.priv.typeArgs[0],
                    value: n.priv.typeArgs[1]
                  }
                });
              }
              return;
            }
            if (e.assignType(t, i)) {
              a.push({
                subtype: t,
                isDefinitelyMapping: false,
                isDefinitelyNotMapping: false,
                dictTypeArgs: {
                  key: m.UnknownType.create(),
                  value: m.UnknownType.create()
                }
              });
              return;
            }
            a.push({
              subtype: t,
              isDefinitelyMapping: false,
              isDefinitelyNotMapping: true
            });
          }
        }
      });
      return a;
    }
    function C(e, t, n) {
      const a = t.d.entries.length;
      const r = t.d.starEntryIndex;
      const s = [];
      y.doForEachSubtype(n, n => {
        const o = e.makeTopLevelTypeVarsConcrete(n);
        let c;
        if (m.isClassInstance(o)) {
          for (const e of o.shared.mro) {
            if (!m.isInstantiableClass(e)) {
              break;
            }
            if (m.ClassType.isBuiltIn(e, 'str') || m.ClassType.isBuiltIn(e, 'bytes') || m.ClassType.isBuiltIn(e, 'bytearray')) {
              s.push({
                subtype: n,
                entryTypes: [],
                isIndeterminateLength: true,
                isDefiniteNoMatch: true
              });
              return;
            }
            if (m.ClassType.isBuiltIn(e, 'Sequence')) {
              c = e;
              break;
            }
            if (y.isTupleClass(e)) {
              c = e;
              break;
            }
          }
          if (c) {
            const l = y.partiallySpecializeType(c, o, e.getTypeClassType());
            if (!y.isTupleClass(l)) {
              s.push({
                subtype: n,
                entryTypes: [l.priv.typeArgs && l.priv.typeArgs.length > 0 ? l.priv.typeArgs[0] : m.UnknownType.create()],
                isIndeterminateLength: true,
                isDefiniteNoMatch: false
              });
              return;
            }
            {
              const o = l.priv.tupleTypeArgs ?? [{
                type: m.UnknownType.create(),
                isUnbounded: true
              }];
              const p = o.findIndex(e => e.isUnbounded || m.isUnpackedTypeVarTuple(e.type) || m.isUnpackedTypeVar(e.type));
              let d = o.length;
              if (p >= 0) {
                for (d--; o.length < a;) {
                  o.splice(p, 0, o[p]);
                }
                if (o.length > a && r === undefined) {
                  o.splice(p, 1);
                }
              }
              if (r !== undefined && o.length >= 2 && o.length > a) {
                const e = o.length - a + 1;
                const t = o.splice(r, e);
                o.splice(r, 0, {
                  type: m.combineTypes(t.map(e => e.type)),
                  isUnbounded: t.every(e => e.isUnbounded || m.isUnpackedTypeVarTuple(e.type) || m.isUnpackedTypeVar(e.type))
                });
              }
              if (o.length === a) {
                let i = false;
                let l = p >= 0;
                if (r !== undefined && p >= 0 && t.d.entries.length - 1 === d && r === p) {
                  l = false;
                }
                for (let n = 0; n < a; n++) {
                  const a = t.d.entries[n];
                  const r = o[n].type;
                  const s = f(e, r, a, true);
                  if (m.isNever(s)) {
                    i = true;
                  }
                }
                s.push({
                  subtype: n,
                  entryTypes: i ? [] : o.map(e => e.type),
                  isIndeterminateLength: false,
                  isTuple: true,
                  isUnboundedTuple: p >= 0,
                  isDefiniteNoMatch: i,
                  isPotentialNoMatch: l
                });
                return;
              }
              if (r !== undefined) {
                let i = false;
                if (o.length === a - 1) {
                  i = true;
                  o.splice(r, 0, {
                    type: m.AnyType.create(),
                    isUnbounded: true
                  });
                } else {
                  if (o.length === a && o[r].isUnbounded) {
                    i = true;
                  }
                }
                if (i) {
                  let i = false;
                  for (let n = 0; n < a; n++) {
                    if (n === r) {
                      continue;
                    }
                    const a = t.d.entries[n];
                    const s = o[n].type;
                    const l = f(e, s, a, true);
                    if (m.isNever(l)) {
                      i = true;
                    }
                  }
                  s.push({
                    subtype: n,
                    entryTypes: i ? [] : o.map(e => e.type),
                    isIndeterminateLength: false,
                    isTuple: true,
                    isUnboundedTuple: p >= 0,
                    isDefiniteNoMatch: i
                  });
                  return;
                }
              }
            }
          }
        }
        if (!c) {
          const a = e.getTypingType(t, 'Sequence');
          if (a && m.isInstantiableClass(a)) {
            const r = m.ClassType.cloneAsInstance(a);
            const i = new p.ConstraintTracker();
            if (e.assignType(r, n, undefined, i)) {
              const t = e.solveAndApplyConstraints(r, i);
              if (t.priv.typeArgs && t.priv.typeArgs.length > 0) {
                s.push({
                  subtype: n,
                  entryTypes: [t.priv.typeArgs[0]],
                  isIndeterminateLength: true,
                  isDefiniteNoMatch: false,
                  isPotentialNoMatch: false
                });
                return;
              }
            }
            const o = new p.ConstraintTracker();
            if (l.addConstraintsForExpectedType(e, m.ClassType.cloneAsInstance(a), n, o, d.getTypeVarScopesForNode(t), t.start)) {
              const t = e.solveAndApplyConstraints(m.ClassType.cloneAsInstantiable(a), o);
              if (t.priv.typeArgs && t.priv.typeArgs.length > 0) {
                s.push({
                  subtype: n,
                  entryTypes: [t.priv.typeArgs[0]],
                  isIndeterminateLength: true,
                  isDefiniteNoMatch: false,
                  isPotentialNoMatch: true
                });
                return;
              }
            }
            if (e.assignType(n, m.ClassType.specialize(m.ClassType.cloneAsInstance(a), [m.UnknownType.create()]))) {
              s.push({
                subtype: n,
                entryTypes: [m.UnknownType.create()],
                isIndeterminateLength: true,
                isDefiniteNoMatch: false,
                isPotentialNoMatch: true
              });
              return;
            }
          }
        }
        s.push({
          subtype: n,
          entryTypes: [],
          isIndeterminateLength: true,
          isDefiniteNoMatch: true
        });
      });
      return s;
    }
    function I(e, t, n, a, s, i, o) {
      if (n.isIndeterminateLength) {
        let r = n.entryTypes[0];
        if (!o && a === i && !m.isNever(r)) {
          r = k(e, t, r);
        }
        return r;
      }
      if (i === undefined || a < i) {
        return n.entryTypes[a];
      }
      if (a === i) {
        const a = n.entryTypes.slice(i, i + n.entryTypes.length - s + 1).map(t => m.isTypeVarTuple(t) && !t.priv.isInUnion ? m.UnknownType.create() : e.stripLiteralValue(t));
        let r = m.combineTypes(a);
        if (!o) {
          r = k(e, t, r);
        }
        return r;
      }
      const l = n.entryTypes.length - (s - a);
      r.assert(l >= 0 && l < n.entryTypes.length);
      return n.entryTypes[l];
    }
    function k(e, t, n) {
      var a;
      if (m.isNever(n)) {
        return n;
      }
      const r = y.convertToInstance(e.getBuiltInObject(t, 'list'));
      if (r && m.isClassInstance(r)) {
        n = (a = y.containsAnyOrUnknown(n, false)) !== null && a !== undefined ? a : n;
        return m.ClassType.specialize(r, [n]);
      } else {
        return m.UnknownType.create();
      }
    }
    function w(e, t, n) {
      e.addDiagnostic(i.DiagnosticRule.reportUnnecessaryComparison, o.LocMessage.patternNeverMatches().format({
        type: e.printType(n)
      }), t);
    }
  },
  79253: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Program = undefined;
    const i = require(56911);
    const o = require(55890);
    const l = require(91426);
    const p = require(12522);
    const d = require(25075);
    const c = __importStar(require(48281));
    const u = require(48281);
    const m = require(51862);
    const y = require(56814);
    const g = require(71745);
    require(23070);
    const h = require(88754);
    const f = require(71582);
    const T = require(27113);
    const v = require(5884);
    const b = __importStar(require(26687));
    const _ = require(32720);
    const C = require(1693);
    const I = require(41557);
    const k = require(53266);
    const w = require(67238);
    const S = require(3433);
    const A = require(3113);
    const x = require(15794);
    const P = require(23274);
    const D = require(70930);
    class N {
      constructor() {
        this._isEditMode = false;
        this._mutatedFiles = [];
      }
      get isEditMode() {
        return this._isEditMode;
      }
      addMutatedFiles(e) {
        this._mutatedFiles.push(e);
      }
      enable() {
        this._isEditMode = true;
        this._mutatedFiles = [];
      }
      disable() {
        this._isEditMode = false;
        const e = this._mutatedFiles;
        this._mutatedFiles = [];
        return e;
      }
    }
    class F {
      constructor(e, t, n, a, r, s) {
        var i;
        this.serviceProvider = n;
        this._disableChecker = r;
        this._sourceFileList = [];
        this._sourceFileMap = new Map();
        this._parsedFileCount = 0;
        this._editModeTracker = new N();
        this._lookUpImport = (e, t) => {
          var n;
          let a;
          if (T.Uri.is(e)) {
            a = this.getSourceFileInfo(e);
          } else {
            const t = this._importResolver.resolveImport(e.importingFileUri, this._configOptions.findExecEnvironment(e.importingFileUri), {
              leadingDots: 0,
              nameParts: e.nameParts,
              importedSymbols: undefined
            });
            if (t.isImportFound && !t.isNativeLib && t.resolvedUris.length > 0) {
              const e = t.resolvedUris[t.resolvedUris.length - 1];
              if (!e.isEmpty()) {
                a = this.getSourceFileInfo(e);
                if (!a) {
                  this.addTrackedFile(e);
                  a = this.getSourceFileInfo(e);
                }
              }
            }
          }
          if (!a) {
            return;
          }
          if (t == null ? undefined : t.skipParsing) {
            return {
              symbolTable: new Map(),
              dunderAllNames: undefined,
              usesUnsupportedDunderAllForm: false,
              get docString() {},
              isInPyTypedPackage: false
            };
          }
          if (a.sourceFile.isBindingRequired()) {
            f.timingStats.typeCheckerTime.subtractFromTime(() => {
              this._bindFile(a, undefined, t == null ? undefined : t.skipFileNeededCheck);
            });
          }
          const r = a.sourceFile.getModuleSymbolTable();
          if (!r) {
            return;
          }
          const s = a.sourceFile.getParserOutput();
          const i = s.parseTree;
          const o = b.getFileInfo(i);
          const l = b.getDunderAllInfo(s.parseTree);
          return {
            symbolTable: r,
            dunderAllNames: l == null ? undefined : l.names,
            usesUnsupportedDunderAllForm: (n = l == null ? undefined : l.usesUnsupportedDunderAllForm) !== null && n !== undefined && n,
            get docString() {
              return I.getDocString(i.d.statements);
            },
            isInPyTypedPackage: o.isInPyTypedPackage
          };
        };
        this._console = n.tryGet(g.ServiceKeys.console) || new d.StandardConsole();
        this._logTracker = a ?? new m.LogTracker(this._console, 'FG');
        this._importResolver = e;
        this._configOptions = t;
        this._sourceFileFactory = n.sourceFileFactory();
        this._cacheManager = (i = n.tryGet(g.ServiceKeys.cacheManager)) !== null && i !== undefined ? i : new _.CacheManager();
        this._cacheManager.registerCacheOwner(this);
        this._createNewEvaluator();
        this._id = s ?? `Prog_${F._nextId}`;
        F._nextId += 1;
      }
      get id() {
        return this._id;
      }
      get console() {
        return this._console;
      }
      get rootPath() {
        return this._configOptions.projectRoot;
      }
      get evaluator() {
        return this._evaluator;
      }
      get configOptions() {
        return this._configOptions;
      }
      get importResolver() {
        return this._importResolver;
      }
      get fileSystem() {
        return this._importResolver.fileSystem;
      }
      dispose() {
        this._cacheManager.unregisterCacheOwner(this);
      }
      enterEditMode() {
        this._editModeTracker.enable();
      }
      exitEditMode() {
        const e = this._editModeTracker.disable();
        const t = new Set();
        const n = [];
        e.forEach(e => {
          if (e.isCreatedInEditMode) {
            t.add(e);
          }
          const a = e.restore();
          if (a) {
            const t = o.TextDocument.create(e.sourceFile.getUri().toString(), 'python', 1, e.sourceFile.getFileContent() || '');
            n.push({
              fileUri: e.sourceFile.getUri(),
              range: {
                start: {
                  line: 0,
                  character: 0
                },
                end: {
                  line: t.lineCount,
                  character: 0
                }
              },
              replacementText: a
            });
          }
        });
        if (t.size > 0) {
          for (let e = this._sourceFileList.length - 1; e >= 0; e--) {
            const n = this._sourceFileList[e];
            if (t.has(n)) {
              n.sourceFile.prepareForClose();
              this._removeSourceFileFromListAndMap(n.sourceFile.getUri(), e);
            }
          }
        }
        if (e.length > 0) {
          this._createNewEvaluator();
        }
        return n;
      }
      setConfigOptions(e) {
        this._configOptions = e;
        this._importResolver.setConfigOptions(e);
        this._createNewEvaluator();
      }
      setImportResolver(e) {
        this._importResolver = e;
        this._createNewEvaluator();
      }
      setTrackedFiles(e) {
        if (this._sourceFileList.length > 0) {
          const t = new Map();
          e.forEach(e => {
            t.set(e.key, e);
          });
          this._sourceFileList.forEach(e => {
            const n = e.sourceFile.getUri();
            if (!t.has(n.key)) {
              e.isTracked = false;
            }
          });
        }
        this.addTrackedFiles(e);
        return this._removeUnneededFiles();
      }
      setPreCheckCallback(e) {
        this._preCheckCallback = e;
      }
      setAllowedThirdPartyImports(e) {
        this._allowedThirdPartyImports = e;
      }
      addTrackedFiles(e, t = false, n = false) {
        e.forEach(e => {
          this.addTrackedFile(e, t, n);
        });
      }
      addInterimFile(e) {
        let t = this.getSourceFileInfo(e);
        if (!t) {
          t = this._createInterimFileInfo(e);
          this._addToSourceFileListAndMap(t);
        }
        return t;
      }
      addTrackedFile(e, t = false, n = false) {
        let a = this.getSourceFileInfo(e);
        const r = this._getModuleImportInfoForFile(e).moduleName;
        if (a) {
          a.sourceFile.setModuleName(r);
          a.isTracked = true;
          return a.sourceFile;
        }
        const s = this._sourceFileFactory.createSourceFile(this.serviceProvider, e, r, t, n, this._editModeTracker, this._console, this._logTracker);
        a = new w.SourceFileInfo(s, false, t, n, this._editModeTracker, {
          isTracked: true
        });
        this._addToSourceFileListAndMap(a);
        return s;
      }
      setFileOpened(e, t, n, a) {
        var r;
        var s;
        let i = this.getSourceFileInfo(e);
        if (i) {
          i.isOpenByClient = true;
          i.diagnosticsVersion = 0;
        } else {
          const t = this._getModuleImportInfoForFile(e);
          const n = this._sourceFileFactory.createSourceFile(this.serviceProvider, e, t.moduleName, false, t.isThirdPartyPyTypedPresent, this._editModeTracker, this._console, this._logTracker, (r = a == null ? undefined : a.ipythonMode) !== null && r !== undefined ? r : k.IPythonMode.None);
          const o = a == null ? undefined : a.chainedFileUri;
          i = new w.SourceFileInfo(n, false, false, false, this._editModeTracker, {
            isTracked: (s = a == null ? undefined : a.isTracked) !== null && s !== undefined && s,
            chainedSourceFile: o ? this.getSourceFileInfo(o) : undefined,
            isOpenByClient: true
          });
          this._addToSourceFileListAndMap(i);
        }
        S.verifyNoCyclesInChainedFiles(this, i);
        i.sourceFile.setClientVersion(t, n);
      }
      getChainedUri(e) {
        var t;
        const n = this.getSourceFileInfo(e);
        if ((t = n == null ? undefined : n.chainedSourceFile) === null || t === undefined) {
          return undefined;
        } else {
          return t.sourceFile.getUri();
        }
      }
      updateChainedUri(e, t) {
        const n = this.getSourceFileInfo(e);
        if (n) {
          n.chainedSourceFile = t ? this.getSourceFileInfo(t) : undefined;
          n.sourceFile.markDirty();
          this._markFileDirtyRecursive(n, new Set());
          S.verifyNoCyclesInChainedFiles(this, n);
        }
      }
      setFileClosed(e, t) {
        const n = this.getSourceFileInfo(e);
        if (n) {
          n.isOpenByClient = false;
          n.isTracked = t ?? n.isTracked;
          n.sourceFile.setClientVersion(null, '');
          if (n.sourceFile.didContentsChangeOnDisk()) {
            n.sourceFile.markDirty();
            this._markFileDirtyRecursive(n, new Set());
          }
        }
        return this._removeUnneededFiles();
      }
      markAllFilesDirty(e) {
        const t = new Set();
        this._sourceFileList.forEach(n => {
          if (e) {
            n.sourceFile.markDirty();
          } else {
            if (n.sourceFile.didContentsChangeOnDisk()) {
              n.sourceFile.markDirty();
              this._markFileDirtyRecursive(n, t);
            }
          }
        });
        if (t.size > 0) {
          this._createNewEvaluator();
        }
      }
      markFilesDirty(e, t) {
        const n = new Set();
        e.forEach(e => {
          const a = this.getSourceFileInfo(e);
          if (a) {
            const r = e.fileName;
            if (r === 'builtins.pyi' || r === '__builtins__.pyi') {
              this.markAllFilesDirty(t);
              return;
            }
            if (t || !a.isOpenByClient && a.sourceFile.didContentsChangeOnDisk()) {
              a.sourceFile.markDirty();
              this._markFileDirtyRecursive(a, n);
            }
          }
        });
        if (n.size > 0) {
          this._createNewEvaluator();
        }
      }
      getFileCount(e = true) {
        if (e) {
          return this._sourceFileList.filter(e => S.isUserCode(e)).length;
        } else {
          return this._sourceFileList.length;
        }
      }
      getUserFileCount() {
        return this._sourceFileList.filter(e => S.isUserCode(e)).length;
      }
      getUserFiles() {
        return this._sourceFileList.filter(e => S.isUserCode(e));
      }
      getOpened() {
        return this._sourceFileList.filter(e => e.isOpenByClient);
      }
      getFilesToAnalyzeCount() {
        let e = 0;
        let t = 0;
        if (this._disableChecker) {
          return {
            files: 0,
            cells: 0
          };
        } else {
          this._sourceFileList.forEach(n => {
            const a = n.sourceFile;
            if (a.isCheckingRequired() && this._shouldCheckFile(n)) {
              if (a.getIPythonMode() === k.IPythonMode.CellDocs) {
                t++;
              } else {
                e++;
              }
            }
          });
          return {
            files: e,
            cells: t
          };
        }
      }
      isCheckingOnlyOpenFiles() {
        return this._configOptions.checkOnlyOpenFiles || false;
      }
      functionSignatureDisplay() {
        return this._configOptions.functionSignatureDisplay;
      }
      containsSourceFileIn(e) {
        for (const t of this._sourceFileMap.values()) {
          if (t.sourceFile.getUri().startsWith(e)) {
            return true;
          }
        }
        return false;
      }
      owns(e) {
        const t = this.getSourceFileInfo(e);
        if (t) {
          return t.isTracked;
        } else {
          return p.matchFileSpecs(this._configOptions, e);
        }
      }
      getSourceFile(e) {
        const t = this.getSourceFileInfo(e);
        if (t) {
          return t.sourceFile;
        }
      }
      getBoundSourceFile(e) {
        var t;
        if ((t = this.getBoundSourceFileInfo(e)) === null || t === undefined) {
          return undefined;
        } else {
          return t.sourceFile;
        }
      }
      getSourceFileInfoList() {
        return this._sourceFileList;
      }
      getSourceFileInfo(e) {
        if (!e.isEmpty()) {
          return this._sourceFileMap.get(e.key);
        }
      }
      getBoundSourceFileInfo(e, t, n) {
        const a = this.getSourceFileInfo(e);
        if (a) {
          this._bindFile(a, t, n);
          return a;
        }
      }
      analyze(e, t = i.CancellationToken.None) {
        return this._runEvaluatorWithCancellationToken(t, () => {
          const n = new f.Duration();
          const a = this._sourceFileList.filter(e => e.isOpenByClient && e.sourceFile.isCheckingRequired());
          if (a.length > 0) {
            const r = e ? e.openFilesTimeInMs : Number.MAX_VALUE;
            for (const e of a) {
              if (this._checkTypes(e, t) && n.getDurationInMilliseconds() > r) {
                return true;
              }
            }
            if (e !== undefined) {
              return true;
            }
          }
          if (!this._configOptions.checkOnlyOpenFiles) {
            const a = e ? e.noOpenFilesTimeInMs : Number.MAX_VALUE;
            for (const e of this._sourceFileList) {
              if (S.isUserCode(e) && this._checkTypes(e, t) && n.getDurationInMilliseconds() > a) {
                return true;
              }
            }
          }
          return false;
        });
      }
      analyzeFile(e, t = i.CancellationToken.None) {
        return this._runEvaluatorWithCancellationToken(t, () => {
          const n = this.getSourceFileInfo(e);
          return !!n && !!this._checkTypes(n, t);
        });
      }
      run(e, t) {
        return this._runEvaluatorWithCancellationToken(t, () => e(this));
      }
      runEditMode(e, t) {
        if (this._editModeTracker.isEditMode) {
          return this._runEvaluatorWithCancellationToken(t, () => e(this));
        }
      }
      getSourceMapper(e, t, n, a) {
        const r = this.getSourceFileInfo(e);
        const s = this._configOptions.findExecEnvironment(e);
        return this._createSourceMapper(s, t, r, n, a);
      }
      getParserOutput(e) {
        var t;
        if ((t = this.getBoundSourceFileInfo(e, undefined, true)) === null || t === undefined) {
          return undefined;
        } else {
          return t.sourceFile.getParserOutput();
        }
      }
      getParseResults(e) {
        var t;
        if ((t = this.getBoundSourceFileInfo(e, undefined, true)) === null || t === undefined) {
          return undefined;
        } else {
          return t.sourceFile.getParseResults();
        }
      }
      handleMemoryHighUsage() {
        this._handleMemoryHighUsage();
      }
      printDetailedAnalysisTimes() {
        const e = this._sourceFileList.filter(e => e.sourceFile.getCheckTime() !== undefined).sort((e, t) => t.sourceFile.getCheckTime() - e.sourceFile.getCheckTime());
        this._console.info('');
        this._console.info('Analysis time by file');
        e.forEach(e => {
          const t = e.sourceFile.getCheckTime();
          this._console.info(`${t}ms: ${e.sourceFile.getUri()}`);
        });
      }
      printDependencies(e, t) {
        const n = this._importResolver.fileSystem;
        const a = this._sourceFileList.filter(e => !e.isTypeshedFile).sort((e, t) => n.getOriginalUri(e.sourceFile.getUri()) < n.getOriginalUri(t.sourceFile.getUri()) ? 1 : -1);
        const r = [];
        a.forEach(a => {
          this._console.info('');
          const s = n.getOriginalUri(a.sourceFile.getUri());
          let i = s.toString();
          const o = e.getRelativePathComponents(s);
          if (o) {
            i = o.join('/');
          }
          this._console.info(`${i}`);
          this._console.info(` Imports     ${a.imports.length} file${a.imports.length === 1 ? '' : 's'}`);
          if (t) {
            a.imports.forEach(e => {
              this._console.info(`    ${n.getOriginalUri(e.sourceFile.getUri())}`);
            });
          }
          this._console.info(` Imported by ${a.importedBy.length} file${a.importedBy.length === 1 ? '' : 's'}`);
          if (t) {
            a.importedBy.forEach(e => {
              this._console.info(`    ${n.getOriginalUri(e.sourceFile.getUri())}`);
            });
          }
          if (a.importedBy.length === 0) {
            r.push(a.sourceFile);
          }
        });
        if (r.length > 0) {
          this._console.info('');
          this._console.info(`${r.length} file${r.length === 1 ? '' : 's'} not explicitly imported`);
          r.forEach(e => {
            this._console.info(`    ${n.getOriginalUri(e.getUri())}`);
          });
        }
      }
      writeTypeStub(e, t, n, a) {
        for (const r of this._sourceFileList) {
          l.throwIfCancellationRequested(a);
          const s = r.sourceFile.getUri();
          const i = e.getRelativePath(s);
          if (i !== undefined) {
            let e = n.resolvePaths(i);
            e = t ? e.getDirectory().initPyiUri : e.replaceExtension('.pyi');
            const s = e.getDirectory();
            try {
              v.makeDirectories(this.fileSystem, s, n);
            } catch (e) {
              throw new Error(`Could not create directory for '${s}'`);
            }
            this._bindFile(r);
            this._runEvaluatorWithCancellationToken(a, () => {
              new D.TypeStubWriter(e, r.sourceFile, this._evaluator).write();
            });
            this._handleMemoryHighUsage();
          }
        }
      }
      getTypeOfSymbol(e) {
        this._handleMemoryHighUsage();
        return (this._evaluator || this._createNewEvaluator()).getEffectiveTypeOfSymbol(e);
      }
      printType(e, t) {
        this._handleMemoryHighUsage();
        return (this._evaluator || this._createNewEvaluator()).printType(e, t);
      }
      getTextOnRange(e, t, n) {
        const a = this.getSourceFileInfo(e);
        if (!a) {
          return;
        }
        const r = a.sourceFile;
        const s = r.getOpenFileContents();
        if (s !== undefined) {
          return this._runEvaluatorWithCancellationToken(n, () => {
            this._parseFile(a);
            const e = r.getParseResults();
            const n = y.convertRangeToTextRange(t, e.tokenizerOutput.lines);
            if (n) {
              return s.substr(n.start, n.length);
            }
          });
        } else {
          return undefined;
        }
      }
      getDiagnostics(e, t = true) {
        const n = this._removeUnneededFiles();
        this._sourceFileList.forEach(a => {
          if (this._shouldCheckFile(a)) {
            let r = a.sourceFile.getDiagnostics(e, t ? a.diagnosticsVersion : undefined);
            if (r !== undefined) {
              if (e.disableTaggedHints) {
                r = r.filter(e => e.category !== 4 && e.category !== 3 && e.category !== 5);
              }
              n.push({
                fileUri: a.sourceFile.getUri(),
                version: a.sourceFile.getClientVersion(),
                diagnostics: r
              });
              a.diagnosticsVersion = a.sourceFile.getDiagnosticVersion();
            }
          } else {
            if (!a.isOpenByClient && e.checkOnlyOpenFiles && a.diagnosticsVersion !== undefined) {
              n.push({
                fileUri: a.sourceFile.getUri(),
                version: a.sourceFile.getClientVersion(),
                diagnostics: []
              });
              a.diagnosticsVersion = undefined;
            }
          }
        });
        return n;
      }
      getDiagnosticsForRange(e, t) {
        const n = this.getSourceFile(e);
        if (!n) {
          return [];
        }
        const a = n.getDiagnostics(this._configOptions);
        if (a) {
          return a.filter(e => h.doRangesIntersect(e.range, t));
        } else {
          return [];
        }
      }
      clone() {
        var e;
        var t;
        const n = new F(this._importResolver, this._configOptions, this.serviceProvider, new m.LogTracker(this._console, 'Cloned'), this._disableChecker);
        const a = this.getUserFiles();
        n.setTrackedFiles(a.map(e => e.sourceFile.getUri()));
        n.markAllFilesDirty(true);
        for (const a of this.getOpened()) {
          const r = a.sourceFile.getClientVersion();
          if (r !== undefined) {
            n.setFileOpened(a.sourceFile.getUri(), r, (e = a.sourceFile.getOpenFileContents()) !== null && e !== undefined ? e : '', {
              chainedFileUri: (t = a.chainedSourceFile) === null || t === undefined ? undefined : t.sourceFile.getUri(),
              ipythonMode: a.sourceFile.getIPythonMode(),
              isTracked: a.isTracked
            });
          }
        }
        return n;
      }
      getCacheUsage() {
        const e = this._evaluator.getTypeCacheEntryCount() / 750000;
        const t = this._parsedFileCount / 1000;
        return Math.max(e, t);
      }
      emptyCache() {
        var e;
        this._createNewEvaluator();
        this._discardCachedParseResults();
        this._parsedFileCount = 0;
        if ((e = this.serviceProvider.tryGet(g.ServiceKeys.stateMutationListeners)) !== null && e !== undefined) {
          e.forEach(e => {
            var t;
            if ((t = e.onClearCache) === null || t === undefined) {
              return undefined;
            } else {
              return t.call(e);
            }
          });
        }
      }
      _handleMemoryHighUsage() {
        const e = this._cacheManager.getCacheUsage();
        const t = this._cacheManager.getUsedHeapRatio(this._configOptions.verboseOutput ? this._console : undefined);
        if (e > 0.75 || t > 0.9) {
          const e = 15099494.4;
          if (this._evaluator.getTypeCacheEntryCount() > e || t > 0.9) {
            this._cacheManager.emptyCache(this._console);
          }
        }
      }
      _discardCachedParseResults() {
        for (const e of this._sourceFileList) {
          e.sourceFile.dropParseAndBindInfo();
        }
      }
      _runEvaluatorWithCancellationToken(e, t) {
        try {
          if (e) {
            return this._evaluator.runWithCancellationToken(e, t);
          } else {
            return t();
          }
        } catch (e) {
          if (!l.OperationCanceledException.is(e) || !!e.isTypeCacheInvalid) {
            this._createNewEvaluator();
          }
          throw e;
        }
      }
      _removeUnneededFiles() {
        const e = [];
        for (let t = 0; t < this._sourceFileList.length;) {
          const n = this._sourceFileList[t];
          if (this._isFileNeeded(n)) {
            if (!this._shouldCheckFile(n) && n.diagnosticsVersion !== undefined) {
              e.push({
                fileUri: n.sourceFile.getUri(),
                version: n.sourceFile.getClientVersion(),
                diagnostics: []
              });
              n.diagnosticsVersion = undefined;
            }
            t++;
          } else {
            if (n.diagnosticsVersion !== undefined) {
              e.push({
                fileUri: n.sourceFile.getUri(),
                version: n.sourceFile.getClientVersion(),
                diagnostics: []
              });
            }
            n.sourceFile.prepareForClose();
            this._removeSourceFileFromListAndMap(n.sourceFile.getUri(), t);
            n.imports.forEach(a => {
              const r = a.importedBy.findIndex(e => e === n);
              if (!(r < 0) && !(a.mutate(e => e.importedBy.splice(r, 1)), this._isFileNeeded(a))) {
                const n = this._sourceFileList.findIndex(e => e === a);
                if (n >= 0 && n < t) {
                  if (a.diagnosticsVersion !== undefined) {
                    e.push({
                      fileUri: a.sourceFile.getUri(),
                      version: a.sourceFile.getClientVersion(),
                      diagnostics: []
                    });
                  }
                  a.sourceFile.prepareForClose();
                  this._removeSourceFileFromListAndMap(a.sourceFile.getUri(), n);
                  t--;
                }
              }
            });
            n.shadowedBy.forEach(e => {
              e.mutate(e => e.shadows = e.shadows.filter(e => e !== n));
            });
            n.mutate(e => e.shadowedBy = []);
          }
        }
        return e;
      }
      _isFileNeeded(e, t) {
        return !e.sourceFile.isFileDeleted() && (!!t || !!e.isTracked || !!e.isOpenByClient || e.shadows.length > 0 || e.importedBy.length !== 0 && this._isImportNeededRecursive(e, new Set()));
      }
      _isImportNeededRecursive(e, t) {
        if (e.isTracked || e.isOpenByClient || e.shadows.length > 0) {
          return true;
        }
        const n = e.sourceFile.getUri();
        if (t.has(n.key)) {
          return false;
        }
        t.add(n.key);
        for (const n of e.importedBy) {
          if (this._isImportNeededRecursive(n, t)) {
            return true;
          }
        }
        return false;
      }
      _createSourceMapper(e, t, n, a, r) {
        return new A.SourceMapper(this._importResolver, e, this._evaluator, (e, t) => {
          let n = this.getSourceFileInfo(e);
          if (!n) {
            if (!this.fileSystem.existsSync(e)) {
              return;
            }
            n = this.addInterimFile(e);
          }
          this._addShadowedFile(n, t);
          return this.getBoundSourceFile(t);
        }, e => {
          let t = this.getBoundSourceFileInfo(e);
          if (!t) {
            if (!this.fileSystem.existsSync(e)) {
              return;
            }
            t = this.addInterimFile(e);
            this._parseFile(t, undefined, true);
          }
          return t;
        }, a != null && a, r != null && r, n, t);
      }
      _isImportAllowed(e, t, n) {
        if (t.isNativeLib) {
          return false;
        }
        let a = this._configOptions.useLibraryCodeForTypes || t.importType === 1 && !!t.pyTypedInfo || t.importType === 2 && e.isThirdPartyPyTypedPresent;
        return t.importType !== 1 && (!e.isThirdPartyImport || t.importType !== 2) || !(this._allowedThirdPartyImports ? (t.isRelative || this._allowedThirdPartyImports.some(e => t.importName === e || !!t.importName.startsWith(e + '.'))) && (a = true) : (e.isThirdPartyImport && this._configOptions.useLibraryCodeForTypes || t.isNamespacePackage && Array.from(t.filteredImplicitImports.values()).some(e => !!e.pyTypedInfo)) && (a = true), !n) || a;
      }
      _getSourceFileInfoFromKey(e) {
        return this._sourceFileMap.get(e);
      }
      _updateSourceFileImports(e, t) {
        const n = [];
        const a = e.sourceFile.getImports();
        const r = t => {
          let n = false;
          let a = false;
          if (t.importType === 1) {
            n = true;
            if (t.pyTypedInfo) {
              a = true;
            }
          } else {
            if (e.isThirdPartyImport && t.importType === 2) {
              n = true;
              if (e.isThirdPartyPyTypedPresent) {
                a = true;
              }
            }
          }
          return {
            isThirdPartyImport: n,
            isPyTypedPresent: a
          };
        };
        const s = new Map();
        if (e.chainedSourceFile) {
          if (e.chainedSourceFile.sourceFile.isFileDeleted()) {
            e.chainedSourceFile = undefined;
          } else {
            const t = e.chainedSourceFile.sourceFile.getUri();
            s.set(t.key, {
              path: t,
              isTypeshedFile: false,
              isThirdPartyImport: false,
              isPyTypedPresent: false
            });
          }
        }
        a.forEach(n => {
          if (n.isImportFound) {
            if (this._isImportAllowed(e, n, n.isStubFile) && n.resolvedUris.length > 0) {
              const e = n.resolvedUris[n.resolvedUris.length - 1];
              if (!e.isEmpty()) {
                const t = r(n);
                s.set(e.key, {
                  path: e,
                  isTypeshedFile: !!n.isStdlibTypeshedFile || !!n.isThirdPartyTypeshedFile,
                  isThirdPartyImport: t.isThirdPartyImport,
                  isPyTypedPresent: t.isPyTypedPresent
                });
              }
            }
            n.filteredImplicitImports.forEach(t => {
              if (this._isImportAllowed(e, n, t.isStubFile) && !t.isNativeLib) {
                const e = r(n);
                s.set(t.uri.key, {
                  path: t.uri,
                  isTypeshedFile: !!n.isStdlibTypeshedFile || !!n.isThirdPartyTypeshedFile,
                  isThirdPartyImport: e.isThirdPartyImport,
                  isPyTypedPresent: e.isPyTypedPresent
                });
              }
            });
            if (n.nonStubImportResult && !n.nonStubImportResult.isImportFound) {
              if (!e.sourceFile.isStubFile() && !n.isStdlibTypeshedFile) {
                if (t.verboseOutput) {
                  this._console.info(`Could not resolve source for '${n.importName}' in file '${e.sourceFile.getUri().toUserVisibleString()}'`);
                  if (n.nonStubImportResult.importFailureInfo) {
                    n.nonStubImportResult.importFailureInfo.forEach(e => {
                      this._console.info(`  ${e}`);
                    });
                  }
                }
              }
            }
          } else {
            if (t.verboseOutput) {
              this._console.info(`Could not import '${n.importName}' in file '${e.sourceFile.getUri().toUserVisibleString()}'`);
              if (n.importFailureInfo) {
                n.importFailureInfo.forEach(e => {
                  this._console.info(`  ${e}`);
                });
              }
            }
          }
        });
        const i = new Map();
        e.imports.forEach(t => {
          const n = t.sourceFile.getUri();
          if (s.has(n.key)) {
            i.set(n.key, t);
          } else {
            t.mutate(t => {
              t.importedBy = t.importedBy.filter(t => !t.sourceFile.getUri().equals(e.sourceFile.getUri()));
            });
          }
        });
        s.forEach((t, a) => {
          if (!i.has(a)) {
            let r = this.getSourceFileInfo(t.path);
            if (!r) {
              const e = this._getModuleImportInfoForFile(t.path);
              const a = this._sourceFileFactory.createSourceFile(this.serviceProvider, t.path, e.moduleName, t.isThirdPartyImport, t.isPyTypedPresent, this._editModeTracker, this._console, this._logTracker);
              r = new w.SourceFileInfo(a, t.isTypeshedFile, t.isThirdPartyImport, t.isPyTypedPresent, this._editModeTracker);
              this._addToSourceFileListAndMap(r);
              n.push(r);
            }
            r.mutate(t => t.importedBy.push(e));
            i.set(a, r);
          }
        });
        const o = [];
        s.forEach((e, t) => {
          const n = this._getSourceFileInfoFromKey(t);
          if (n) {
            o.push(n);
          }
        });
        if (o.length !== e.imports.length || !o.every(t => e.imports.includes(t))) {
          e.mutate(e => e.imports = o);
        }
        e.builtinsImport = undefined;
        const l = e.sourceFile.getBuiltinsImport();
        if (l && l.isImportFound) {
          const t = l.resolvedUris[l.resolvedUris.length - 1];
          e.builtinsImport = this.getSourceFileInfo(t);
        }
        return n;
      }
      _removeSourceFileFromListAndMap(e, t) {
        this._sourceFileMap.delete(e.key);
        this._sourceFileList.splice(t, 1);
      }
      _addToSourceFileListAndMap(e) {
        const t = e.sourceFile.getUri();
        u.assert(!this._sourceFileMap.has(t.key));
        u.assert(!t.isEmpty());
        this._sourceFileList.push(e);
        this._sourceFileMap.set(t.key, e);
      }
      static _getPrintTypeFlags(e) {
        let t = 0;
        if (e.diagnosticRuleSet.printUnknownAsAny) {
          t |= 1;
        }
        if (e.diagnosticRuleSet.omitConditionalConstraint) {
          t |= 64;
        }
        if (e.diagnosticRuleSet.omitTypeArgsIfUnknown) {
          t |= 2;
        }
        if (e.diagnosticRuleSet.omitUnannotatedParamType) {
          t |= 4;
        }
        if (e.diagnosticRuleSet.pep604Printing) {
          t |= 8;
        }
        return t;
      }
      _getModuleImportInfoForFile(e) {
        return this._importResolver.getModuleNameForImport(e, this._configOptions.getDefaultExecEnvironment(), true, true);
      }
      _addShadowedFile(e, t) {
        let n = this.getSourceFileInfo(t);
        if (!n) {
          n = this.addInterimFile(t);
        }
        if (!n.shadows.includes(e)) {
          n.mutate(t => t.shadows.push(e));
        }
        if (!e.shadowedBy.includes(n)) {
          e.mutate(e => e.shadowedBy.push(n));
        }
        return n.sourceFile;
      }
      _createInterimFileInfo(e) {
        const t = this._getModuleImportInfoForFile(e);
        const n = this._sourceFileFactory.createSourceFile(this.serviceProvider, e, t.moduleName, false, false, this._editModeTracker, this._console, this._logTracker);
        return new w.SourceFileInfo(n, false, false, false, this._editModeTracker);
      }
      _createNewEvaluator() {
        if (this._evaluator) {
          this._evaluator.disposeEvaluator();
        }
        this._evaluator = P.createTypeEvaluatorWithTracker(this._lookUpImport, {
          printTypeFlags: F._getPrintTypeFlags(this._configOptions),
          logCalls: this._configOptions.logTypeEvaluationTime,
          minimumLoggingThreshold: this._configOptions.typeEvaluationTimeThreshold,
          evaluateUnknownImportsAsAny: !!this._configOptions.evaluateUnknownImportsAsAny,
          verifyTypeCacheEvaluatorFlags: !!this._configOptions.internalTestMode
        }, this._logTracker, this._configOptions.logTypeEvaluationTime ? x.createTracePrinter(this._importResolver.getImportRoots(this._configOptions.findExecEnvironment(this._configOptions.projectRoot))) : undefined);
        return this._evaluator;
      }
      _parseFile(e, t, n) {
        if (this._isFileNeeded(e, n) && e.sourceFile.isParseRequired() && (e.sourceFile.parse(this._configOptions, this._importResolver, t) && (this._parsedFileCount++, this._updateSourceFileImports(e, this._configOptions)), e.sourceFile.isFileDeleted())) {
          e.isTracked = false;
          const t = new Set();
          this._markFileDirtyRecursive(e, t);
          this._importResolver.invalidateCache();
        }
      }
      _getImplicitImports(e) {
        if (e.builtinsImport !== e) {
          if (e.chainedSourceFile && !e.chainedSourceFile.sourceFile.isFileDeleted()) {
            return e.chainedSourceFile;
          } else {
            return e.builtinsImport;
          }
        }
      }
      _bindImplicitImports(e, t) {
        var n;
        var a;
        const r = [];
        const s = new Set();
        let i = this._getImplicitImports(e);
        while (i) {
          const e = i.sourceFile.getUri();
          if (s.has(e.key)) {
            c.fail((a = (n = this.serviceProvider.tryGet(g.ServiceKeys.debugInfoInspector)) === null || n === undefined ? undefined : n.getCycleDetail(this, i)) !== null && a !== undefined ? a : 'Found a cycle in implicit imports files');
          }
          s.add(e.key);
          r.push(i);
          this._parseFile(i, undefined, t);
          i = this._getImplicitImports(i);
        }
        if (r.length === 0) {
          return;
        }
        let o = r.pop();
        while (o) {
          this._bindFile(o, undefined, t, true);
          o = r.pop();
        }
      }
      _bindFile(e, t, n = false, a = false) {
        var r;
        if (!this._isFileNeeded(e, n) || !e.sourceFile.isBindingRequired()) {
          return !e.sourceFile.isBindingRequired();
        }
        this._parseFile(e, t, n);
        const s = t => {
          if (!t || t === e) {
            return;
          }
          if (t.sourceFile.isFileDeleted()) {
            return;
          }
          const n = t.sourceFile.getParserOutput();
          if (!n) {
            return;
          }
          return b.getScope(n.parseTree);
        };
        let i;
        if (e.builtinsImport && e.builtinsImport !== e) {
          if (!a) {
            this._bindImplicitImports(e);
          }
          i = (r = s(e.chainedSourceFile)) !== null && r !== undefined ? r : s(e.builtinsImport);
        }
        let o = e.sourceFile.getParserOutput().futureImports;
        if (e.chainedSourceFile) {
          o = this._getEffectiveFutureImports(o, e.chainedSourceFile);
        }
        e.effectiveFutureImports = o.size > 0 ? o : undefined;
        e.sourceFile.bind(this._configOptions, this._lookUpImport, i, o);
        return true;
      }
      _getEffectiveFutureImports(e, t) {
        var n;
        const a = new Set(e);
        if ((n = t.effectiveFutureImports) !== null && n !== undefined) {
          n.forEach(e => {
            a.add(e);
          });
        }
        return a;
      }
      _shouldCheckFile(e) {
        return !!e.isOpenByClient || !this._configOptions.checkOnlyOpenFiles && !!e.isTracked;
      }
      _checkTypes(e, t, n) {
        return this._logTracker.log(`analyzing: ${e.sourceFile.getUri()}`, a => {
          if (!this._isFileNeeded(e)) {
            a.suppress();
            return false;
          }
          if (!e.sourceFile.isCheckingRequired()) {
            a.suppress();
            return false;
          }
          if (!this._shouldCheckFile(e)) {
            a.suppress();
            return false;
          }
          const r = this._bindFile(e, undefined, e.sourceFile.isBindingRequired());
          if (!this._disableChecker) {
            const a = this._checkDependentFiles(e, n, t);
            if (this._preCheckCallback) {
              const t = e.sourceFile.getParserOutput();
              if (t) {
                this._preCheckCallback(t, this._evaluator);
              }
            }
            if (r) {
              const n = this._configOptions.findExecEnvironment(e.sourceFile.getUri());
              e.sourceFile.check(this.configOptions, this._importResolver, this._evaluator, this._createSourceMapper(n, t, e), a);
            }
          }
          this._handleMemoryHighUsage();
          if (this._configOptions.diagnosticRuleSet.reportImportCycles !== 'none' && !this._allowedThirdPartyImports && e.sourceFile.getIPythonMode() !== k.IPythonMode.CellDocs) {
            const t = new Map();
            this._getImportsRecursive(e, t, 0);
            t.forEach(e => {
              f.timingStats.cycleDetectionTime.timeOperation(() => {
                const t = new Map();
                if (!this._detectAndReportImportCycles(e, t)) {
                  t.forEach(e => {
                    e.sourceFile.setNoCircularDependencyConfirmed();
                  });
                }
              });
            });
          }
          return true;
        });
      }
      _checkDependentFiles(e, t, n) {
        if (e.sourceFile.getIPythonMode() !== k.IPythonMode.CellDocs) {
          return;
        }
        const a = !t;
        const r = (t = t ?? S.createChainedByList(this, e)).findIndex(t => t === e);
        if (r < 0) {
          return;
        }
        const s = r + 1;
        if (s >= t.length) {
          return;
        }
        if (a) {
          const e = this._cacheManager.pauseTracking();
          try {
            for (let e = t.length - 1; e >= s; e--) {
              this._checkTypes(t[e], n, t);
            }
          } finally {
            e.dispose();
          }
        }
        const i = [];
        for (let e = s; e < t.length; e++) {
          const n = t[e];
          const a = n == null ? undefined : n.sourceFile.getParserOutput();
          if (!a) {
            continue;
          }
          if (n.sourceFile.isBindingRequired()) {
            continue;
          }
          if (b.getFileInfo(a.parseTree).accessedSymbolSet) {
            i.push(a);
          }
        }
        return i;
      }
      _getImportsRecursive(e, t, n) {
        const a = e.sourceFile.getUri();
        if (!t.has(a.key)) {
          if (n > 256) {
            e.sourceFile.setHitMaxImportDepth(256);
          } else {
            t.set(a.key, e);
            if (S.isUserCode(e)) {
              this._parseFile(e);
            }
            for (const a of e.imports) {
              this._getImportsRecursive(a, t, n + 1);
            }
          }
        }
      }
      _detectAndReportImportCycles(e, t, n = [], a = new Map()) {
        if (e.sourceFile.isStubFile() || e.isThirdPartyImport) {
          return false;
        }
        if (e.sourceFile.isNoCircularDependencyConfirmed()) {
          return false;
        }
        const r = e.sourceFile.getUri();
        t.set(r.key, e);
        let s = false;
        if (a.has(r.key)) {
          s = true;
          if (n.length > 1 && e === n[0]) {
            this._logImportCycle(n);
          }
        } else {
          if (a.has(r.key)) {
            return false;
          }
          a.set(r.key, true);
          n.push(e);
          for (const r of e.imports) {
            if (this._detectAndReportImportCycles(r, t, n, a)) {
              s = true;
            }
          }
          a.set(r.key, false);
          n.pop();
        }
        return s;
      }
      _logImportCycle(e) {
        const t = new C.CircularDependency();
        e.forEach(e => {
          t.appendPath(e.sourceFile.getUri());
        });
        t.normalizeOrder();
        const n = t.getPaths()[0];
        const a = this.getSourceFileInfo(n);
        u.assert(a !== undefined);
        a.sourceFile.addCircularDependency(this.configOptions, t);
      }
      _markFileDirtyRecursive(e, t, n = false) {
        const a = e.sourceFile.getUri();
        if (t.has(a.key)) {
          return;
        }
        e.sourceFile.markReanalysisRequired(n);
        t.add(a.key);
        e.importedBy.forEach(n => {
          const a = n.chainedSourceFile === e;
          this._markFileDirtyRecursive(n, t, a);
        });
        let r = false;
        let s = e.chainedSourceFile;
        while (s) {
          if (s.sourceFile.isCheckingRequired()) {
            return;
          }
          r = true;
          s.sourceFile.markReanalysisRequired(false);
          s = s.chainedSourceFile;
        }
        if (r) {
          this._createNewEvaluator();
        }
      }
    }
    exports.Program = F;
    F._nextId = 0;
  },
  60356: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ISourceFileFactory = undefined;
    (function (e) {
      e.is = function (e) {
        return e.createSourceFile !== undefined;
      };
    })(n || (exports.ISourceFileFactory = n = {}));
  },
  89460: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.validatePropertyMethod = function (e, t, n) {
      if (p.FunctionType.isStaticMethod(t)) {
        e.addDiagnostic(r.DiagnosticRule.reportGeneralTypeIssues, s.LocMessage.propertyStaticMethod(), n);
      }
    };
    exports.createProperty = function (e, t, n, a) {
      const r = i.getFileInfo(t);
      const s = e.getBuiltInType(t, 'type');
      const l = p.ClassType.isBuiltIn(n, 'property') ? o.getTypeSourceId(t) : n.shared.typeSourceId;
      const u = p.ClassType.createInstantiable(n.shared.name, o.getClassFullName(t, r.moduleName, `__property_${a.shared.name}`), r.moduleName, r.fileUri, 129, l, undefined, p.isInstantiableClass(s) ? s : p.UnknownType.create());
      u.shared.declaration = n.shared.declaration;
      u.shared.typeVarScopeId = n.shared.typeVarScopeId;
      const m = e.getBuiltInType(t, 'object');
      u.shared.baseClasses.push(p.isInstantiableClass(m) ? m : p.UnknownType.create());
      d.computeMroLinearization(u);
      const h = p.ClassType.getSymbolTable(u);
      p.ClassType.getSymbolTable(n).forEach((e, t) => {
        const n = ['__get__', '__set__', '__delete__'];
        if (!e.isIgnoredForProtocolMatch() && !n.some(e => e === t)) {
          h.set(t, e);
        }
      });
      const f = p.ClassType.cloneAsInstance(u);
      u.priv.isAsymmetricDescriptor = false;
      y(e, f);
      f.priv.fgetInfo = {
        methodType: p.FunctionType.cloneWithNewFlags(a, a.shared.flags | 4),
        classType: a.shared.methodClass
      };
      if (p.FunctionType.isClassMethod(a)) {
        u.shared.flags |= 131072;
      }
      c(e, f, a);
      g(f);
      return f;
    };
    exports.clonePropertyWithSetter = function (e, t, n, l) {
      if (!d.isProperty(t)) {
        return t;
      }
      const c = t;
      const m = c.shared.flags;
      let h = !!c.priv.isAsymmetricDescriptor;
      const f = i.getFileInfo(l);
      if (l.d.params.length >= 2) {
        const t = o.getTypeAnnotationForParam(l, 1);
        if (t) {
          const n = e.getGetterTypeFromProperty(c, false);
          if (n && !p.isAnyOrUnknown(n)) {
            const i = e.getTypeOfAnnotation(t, {
              typeVarGetsCurScope: true
            });
            if (f.diagnosticRuleSet.reportPropertyTypeMismatch !== 'none') {
              const o = new a.DiagnosticAddendum();
              if (!e.assignType(n, i, o)) {
                e.addDiagnostic(r.DiagnosticRule.reportPropertyTypeMismatch, s.LocMessage.setterGetterTypeMismatch() + o.getString(), t);
              }
            }
            if (!p.isTypeSame(n, i)) {
              h = true;
            }
          }
        }
      }
      const T = p.ClassType.createInstantiable(c.shared.name, c.shared.fullName, c.shared.moduleName, i.getFileInfo(l).fileUri, m, c.shared.typeSourceId, c.shared.declaredMetaclass, c.shared.effectiveMetaclass);
      T.shared.declaration = c.shared.declaration;
      T.shared.typeVarScopeId = c.shared.typeVarScopeId;
      const v = e.getBuiltInType(l, 'object');
      T.shared.baseClasses.push(p.isInstantiableClass(v) ? v : p.UnknownType.create());
      d.computeMroLinearization(T);
      T.priv.fgetInfo = c.priv.fgetInfo;
      T.priv.fdelInfo = c.priv.fdelInfo;
      T.priv.isAsymmetricDescriptor = h;
      const b = p.ClassType.cloneAsInstance(T);
      const _ = p.ClassType.getSymbolTable(T);
      p.ClassType.getSymbolTable(c).forEach((e, t) => {
        if (!e.isIgnoredForProtocolMatch()) {
          _.set(t, e);
        }
      });
      y(e, b);
      b.priv.fsetInfo = {
        methodType: p.FunctionType.cloneWithNewFlags(n, n.shared.flags | 4),
        classType: n.shared.methodClass
      };
      u(e, b, n);
      g(b);
      return b;
    };
    exports.clonePropertyWithDeleter = function (e, t, n, a) {
      var r;
      if (!d.isProperty(t)) {
        return t;
      }
      const s = t;
      const o = p.ClassType.createInstantiable(s.shared.name, s.shared.fullName, s.shared.moduleName, i.getFileInfo(a).fileUri, s.shared.flags, s.shared.typeSourceId, s.shared.declaredMetaclass, s.shared.effectiveMetaclass);
      o.shared.declaration = s.shared.declaration;
      o.shared.typeVarScopeId = s.shared.typeVarScopeId;
      const l = e.getBuiltInType(a, 'object');
      o.shared.baseClasses.push(p.isInstantiableClass(l) ? l : p.UnknownType.create());
      d.computeMroLinearization(o);
      o.priv.fgetInfo = s.priv.fgetInfo;
      o.priv.fsetInfo = s.priv.fsetInfo;
      const c = p.ClassType.cloneAsInstance(o);
      o.priv.isAsymmetricDescriptor = (r = s.priv.isAsymmetricDescriptor) !== null && r !== undefined && r;
      const u = p.ClassType.getSymbolTable(o);
      p.ClassType.getSymbolTable(s).forEach((e, t) => {
        if (!e.isIgnoredForProtocolMatch()) {
          u.set(t, e);
        }
      });
      y(e, c);
      c.priv.fdelInfo = {
        methodType: p.FunctionType.cloneWithNewFlags(n, n.shared.flags | 4),
        classType: n.shared.methodClass
      };
      m(e, c, n);
      g(c);
      return c;
    };
    exports.assignProperty = function (e, t, n, a, r, i, o, l, c = 0) {
      const u = p.isClass(r) ? p.ClassType.cloneAsInstance(r) : undefined;
      const m = p.ClassType.cloneAsInstance(a);
      let y = true;
      [{
        getFunction: e => {
          var t;
          if ((t = e.priv.fgetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        },
        missingDiagMsg: s.LocAddendum.missingGetter,
        incompatibleDiagMsg: s.LocAddendum.incompatibleGetter
      }, {
        getFunction: e => {
          var t;
          if ((t = e.priv.fsetInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        },
        missingDiagMsg: s.LocAddendum.missingSetter,
        incompatibleDiagMsg: s.LocAddendum.incompatibleSetter
      }, {
        getFunction: e => {
          var t;
          if ((t = e.priv.fdelInfo) === null || t === undefined) {
            return undefined;
          } else {
            return t.methodType;
          }
        },
        missingDiagMsg: s.LocAddendum.missingDeleter,
        incompatibleDiagMsg: s.LocAddendum.incompatibleDeleter
      }].forEach(a => {
        let r = a.getFunction(t);
        if (r && p.isFunction(r)) {
          let t = a.getFunction(n);
          if (!t || !p.isFunction(t)) {
            if (i != null) {
              i.addMessage(a.missingDiagMsg());
            }
            y = false;
            return;
          }
          e.inferReturnTypeIfNecessary(t);
          e.inferReturnTypeIfNecessary(r);
          if (l) {
            r = d.applySolvedTypeVars(r, l);
          }
          r = p.FunctionType.cloneWithNewFlags(r, r.shared.flags & -5);
          t = p.FunctionType.cloneWithNewFlags(t, t.shared.flags & -5);
          const s = e.bindFunctionToClassOrObject(m, r, undefined, undefined, undefined, i == null ? undefined : i.createAddendum(), c);
          const g = e.bindFunctionToClassOrObject(u, t, undefined, undefined, undefined, i == null ? undefined : i.createAddendum(), c);
          if (!s || !g || !e.assignType(s, g, i, o, 0, c)) {
            y = false;
          }
        }
      });
      return y;
    };
    const a = require(11479);
    const r = require(65880);
    const s = require(67703);
    const i = require(26687);
    const o = require(41557);
    const l = require(58253);
    const p = require(21024);
    const d = require(92324);
    function c(e, t, n) {
      const a = p.ClassType.getSymbolTable(t);
      const r = p.FunctionType.createSynthesizedInstance('__get__', 256);
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'self'));
      p.FunctionType.addParam(r, p.FunctionParam.create(0, e.getNoneType(), p.FunctionParamFlags.TypeDeclared, 'obj'));
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'objtype', p.AnyType.create(true)));
      r.shared.declaredReturnType = p.FunctionType.isClassMethod(n) ? p.FunctionType.getEffectiveReturnType(n) : t;
      r.shared.declaration = n.shared.declaration;
      r.shared.deprecatedMessage = n.shared.deprecatedMessage;
      r.shared.methodClass = n.shared.methodClass;
      r.shared.typeVarScopeId = d.getTypeVarScopeId(n);
      const s = p.FunctionType.createSynthesizedInstance('__get__', 256);
      p.FunctionType.addParam(s, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'self'));
      const i = n.shared.parameters.length > 0 ? p.FunctionType.getParamType(n, 0) : p.AnyType.create();
      p.FunctionType.addParam(s, p.FunctionParam.create(0, i, p.FunctionParamFlags.TypeDeclared, 'obj'));
      p.FunctionType.addParam(s, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'objtype', p.AnyType.create(true)));
      s.shared.declaredReturnType = p.FunctionType.getEffectiveReturnType(n);
      s.shared.declaration = n.shared.declaration;
      s.shared.deprecatedMessage = n.shared.deprecatedMessage;
      s.shared.methodClass = n.shared.methodClass;
      s.shared.typeVarScopeId = d.getTypeVarScopeId(n);
      const o = p.OverloadedType.create([s, r]);
      const c = l.Symbol.createWithType(4, o);
      a.set('__get__', c);
    }
    function u(e, t, n) {
      const a = p.ClassType.getSymbolTable(t);
      const r = p.FunctionType.createSynthesizedInstance('__set__');
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'self'));
      let s = n.shared.parameters.length > 0 ? p.FunctionType.getParamType(n, 0) : p.AnyType.create();
      if (p.isTypeVar(s) && p.TypeVarType.isSelf(s)) {
        s = e.makeTopLevelTypeVarsConcrete(s);
      }
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.combineTypes([s, e.getNoneType()]), p.FunctionParamFlags.TypeDeclared, 'obj'));
      r.shared.declaredReturnType = e.getNoneType();
      r.shared.typeVarScopeId = d.getTypeVarScopeId(n);
      r.shared.deprecatedMessage = n.shared.deprecatedMessage;
      r.shared.methodClass = n.shared.methodClass;
      let i = p.UnknownType.create();
      if (n.shared.parameters.length >= 2 && n.shared.parameters[1].category === 0 && n.shared.parameters[1].name) {
        i = p.FunctionType.getParamType(n, 1);
      }
      p.FunctionType.addParam(r, p.FunctionParam.create(0, i, p.FunctionParamFlags.TypeDeclared, 'value'));
      const o = l.Symbol.createWithType(4, r);
      a.set('__set__', o);
    }
    function m(e, t, n) {
      const a = p.ClassType.getSymbolTable(t);
      const r = p.FunctionType.createSynthesizedInstance('__delete__');
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'self'));
      r.shared.typeVarScopeId = d.getTypeVarScopeId(n);
      r.shared.deprecatedMessage = n.shared.deprecatedMessage;
      r.shared.methodClass = n.shared.methodClass;
      let s = n.shared.parameters.length > 0 ? p.FunctionType.getParamType(n, 0) : p.AnyType.create();
      if (p.isTypeVar(s) && p.TypeVarType.isSelf(s)) {
        s = e.makeTopLevelTypeVarsConcrete(s);
      }
      p.FunctionType.addParam(r, p.FunctionParam.create(0, p.combineTypes([s, e.getNoneType()]), p.FunctionParamFlags.TypeDeclared, 'obj'));
      r.shared.declaredReturnType = e.getNoneType();
      const i = l.Symbol.createWithType(4, r);
      a.set('__delete__', i);
    }
    function y(e, t) {
      const n = t.priv.fgetInfo;
      if (n && p.isFunction(n.methodType)) {
        c(e, t, n.methodType);
      }
      const a = t.priv.fsetInfo;
      if (a && p.isFunction(a.methodType)) {
        u(e, t, a.methodType);
      }
      const r = t.priv.fdelInfo;
      if (r && p.isFunction(r.methodType)) {
        m(e, t, r.methodType);
      }
    }
    function g(e) {
      const t = p.ClassType.getSymbolTable(e);
      ['getter', 'setter', 'deleter'].forEach(n => {
        const a = p.FunctionType.createSynthesizedInstance(n);
        p.FunctionType.addParam(a, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'self'));
        p.FunctionType.addParam(a, p.FunctionParam.create(0, p.AnyType.create(), p.FunctionParamFlags.TypeDeclared, 'accessor'));
        a.shared.declaredReturnType = e;
        const r = l.Symbol.createWithType(4, a);
        t.set(n, r);
      });
    }
  },
  54500: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.assignClassToProtocol = function (e, t, n, s, i, o, l) {
      a.assert(c.isInstantiableClass(t) && c.ClassType.isProtocolClass(t));
      if (n.priv.literalValue !== undefined) {
        n = e.stripLiteralValue(n);
      }
      const p = !!(o & 1);
      if (m.some(e => c.isTypeSame(e.srcType, n) && c.isTypeSame(e.destType, t))) {
        return !p;
      }
      const d = function (e, t, n, a) {
        const r = t.shared.protocolCompatibility;
        const s = r == null ? undefined : r.get(e.shared.fullName);
        if (s === undefined) {
          return;
        }
        for (const r of s) {
          if (r.flags === n) {
            if (r.srcType !== undefined) {
              if (c.isTypeSame(r.destType, e, {
                honorIsTypeArgExplicit: true,
                honorTypeForm: true
              }) && c.isTypeSame(r.srcType, t, {
                honorIsTypeArgExplicit: true,
                honorTypeForm: true
              }) && g(a, r.preConstraints)) {
                return r;
              }
            } else {
              if (c.ClassType.isSameGenericClass(r.destType, e)) {
                return r;
              }
            }
          }
        }
        return;
      }(t, n, o, i);
      if (d !== undefined) {
        if (d.isCompatible) {
          if (d.postConstraints) {
            if (i != null) {
              i.copyFromClone(d.postConstraints);
            }
          }
          return true;
        }
        if (!s || s.getNestLevel() > r.defaultMaxDiagnosticDepth) {
          return false;
        }
      }
      m.push({
        srcType: n,
        destType: t
      });
      let f = true;
      const T = i == null ? undefined : i.clone();
      try {
        f = h(e, t, n, s, i, o, l);
      } catch (e) {
        m.pop();
        throw e;
      }
      m.pop();
      if (!d) {
        (function (e, t, n, a, r, s, i, o) {
          let l = n.shared.protocolCompatibility;
          if (!l) {
            l = new Map();
            n.shared.protocolCompatibility = l;
          }
          let p = l.get(t.shared.fullName);
          if (!p) {
            p = [];
            l.set(t.shared.fullName, p);
          }
          let d = false;
          if (!i && !p.some(e => e.flags === a && c.ClassType.isSameGenericClass(e.destType, t))) {
            if (!h(e, u.requiresTypeArgs(t) ? u.selfSpecializeClass(t, {
              overrideTypeArgs: true
            }) : t, u.requiresTypeArgs(n) ? u.selfSpecializeClass(n, {
              overrideTypeArgs: true
            }) : n, undefined, undefined, a, o)) {
              d = true;
            }
          }
          const m = {
            destType: t,
            srcType: d ? undefined : n,
            flags: a,
            preConstraints: r,
            postConstraints: s,
            isCompatible: i
          };
          p.push(m);
          if (p.length > y) {
            p.shift();
          }
        })(e, t, n, o, T, i == null ? undefined : i.clone(), f, l);
      }
      return f;
    };
    exports.assignModuleToProtocol = function (e, t, n, a, r, s, i) {
      return h(e, t, n, a, r, s, i);
    };
    exports.isMethodOnlyProtocol = function e(t) {
      if (!c.ClassType.isProtocolClass(t)) {
        return false;
      }
      for (const n of t.shared.baseClasses) {
        if (c.isClass(n) && c.ClassType.isProtocolClass(n) && !e(n)) {
          return false;
        }
      }
      for (const [, e] of c.ClassType.getSymbolTable(t)) {
        if (!e.isIgnoredForProtocolMatch() && e.getDeclarations().some(e => e.type !== 5)) {
          return false;
        }
      }
      return true;
    };
    exports.isProtocolUnsafeOverlap = function (e, t, n) {
      if (e.assignType(t, n)) {
        return false;
      }
      let a = true;
      t.shared.mro.forEach(e => {
        if (a && c.isInstantiableClass(e) && c.ClassType.isProtocolClass(e)) {
          c.ClassType.getSymbolTable(e).forEach((e, t) => {
            if (!a || !e.isClassMember() || e.isIgnoredForProtocolMatch()) {
              return;
            }
            if (!u.lookUpClassMember(n, t)) {
              a = false;
            }
          });
        }
      });
      return a;
    };
    const a = require(48281);
    const r = require(11479);
    const s = require(67703);
    const i = require(70617);
    const o = require(10081);
    const l = require(86672);
    const p = require(89460);
    const d = require(4064);
    const c = require(21024);
    const u = require(92324);
    const m = [];
    const y = 64;
    function g(e, t) {
      if (e && t) {
        return e.isSame(t);
      } else {
        return e === t;
      }
    }
    function h(e, t, n, r, m, y, g) {
      var h;
      var f;
      if (y & 1) {
        return c.isTypeSame(t, n);
      }
      e.inferVarianceForClass(t);
      const T = c.isClass(n) && c.TypeBase.isInstantiable(n);
      const v = function (e, t, n) {
        const a = new l.ConstraintTracker();
        t.shared.typeParams.forEach((r, s) => {
          const i = n == null ? undefined : n.getMainConstraintSet().getTypeVar(r);
          if (i) {
            a.copyBounds(i);
          } else {
            if (t.priv.typeArgs && s < t.priv.typeArgs.length) {
              let i;
              let l = t.priv.typeArgs[s];
              let p = u.requiresSpecialization(l);
              if (p && n) {
                l = e.solveAndApplyConstraints(l, n, undefined, {
                  useLowerBoundOnly: true
                });
                i = 0;
                p = u.requiresSpecialization(l);
              } else {
                i = 2048;
                const e = c.TypeVarType.getVariance(r);
                if (e === 2) {
                  i |= 1;
                } else {
                  if (e === 4) {
                    i |= 2;
                  }
                }
              }
              if (!p) {
                o.assignTypeVar(e, r, l, undefined, a, i);
              }
            }
          }
        });
        return a;
      }(e, t, m);
      const b = new i.ConstraintSolution();
      let _;
      if (c.isClass(n)) {
        const e = (f = (h = n.props) === null || h === undefined ? undefined : h.condition) === null || f === undefined ? undefined : f.find(e => c.TypeVarType.isSelf(e.typeVar));
        if (e) {
          _ = u.synthesizeTypeVarForSelfCls(c.TypeBase.cloneForCondition(n, undefined), false);
          if (c.TypeVarType.isBound(e.typeVar)) {
            _ = c.TypeVarType.cloneAsBound(_);
          }
        } else {
          _ = n;
        }
        u.addSolutionForSelfType(b, t, _);
      }
      if (c.isClass(n) && c.ClassType.isTypedDictClass(n)) {
        const t = e.getTypedDictClassType();
        if (t && c.isInstantiableClass(t)) {
          n = t;
        }
      }
      let C = true;
      const I = new Set();
      let k = y & 48;
      k |= u.containsLiteralType(n, true) ? 256 : 0;
      t.shared.mro.forEach(i => {
        if (c.isInstantiableClass(i) && c.ClassType.isProtocolClass(i) && (C || r)) {
          c.ClassType.getSymbolTable(i).forEach((o, l) => {
            var m;
            if (!C && !r) {
              return;
            }
            if (!o.isClassMember() || o.isIgnoredForProtocolMatch() || I.has(l)) {
              return;
            }
            let y;
            let h;
            let f = false;
            if (!T && l === '__class_getitem__') {
              return;
            }
            if (l === '__slots__') {
              return;
            }
            I.add(l);
            let w;
            let S = (m = e.getDeclaredTypeOfSymbol(o)) === null || m === undefined ? undefined : m.type;
            if (!S) {
              return;
            }
            let A = false;
            let x = false;
            if (c.isClass(n)) {
              if (T && n.shared.effectiveMetaclass && c.isInstantiableClass(n.shared.effectiveMetaclass)) {
                y = u.lookUpClassMember(n.shared.effectiveMetaclass, l);
                if (y) {
                  f = true;
                }
              }
              if (!y) {
                y = u.lookUpClassMember(n, l);
              }
              if (!y) {
                if (r != null) {
                  r.addMessage(s.LocAddendum.protocolMemberMissing().format({
                    name: l
                  }));
                }
                C = false;
                return;
              }
              h = y.symbol;
              if (!c.ClassType.isSameGenericClass(i, t)) {
                S = u.partiallySpecializeType(S, i, e.getTypeClassType(), _);
              }
              if (c.isInstantiableClass(y.classType)) {
                const t = e.getEffectiveTypeOfSymbol(y.symbol);
                if (c.isFunction(t)) {
                  e.inferReturnTypeIfNecessary(t);
                }
                w = u.partiallySpecializeType(t, y.classType, e.getTypeClassType(), _);
              } else {
                w = c.UnknownType.create();
              }
              if ((c.isFunction(w) || c.isOverloaded(w)) && (f || c.isInstantiableClass(y.classType))) {
                let t = !y.symbol.isClassMember();
                if (c.ClassType.isDataClass(n)) {
                  if (c.ClassType.getDataClassEntries(n).some(e => e.name === l)) {
                    t = true;
                  }
                }
                if (f) {
                  t = false;
                }
                if (!t) {
                  const t = e.bindFunctionToClassOrObject(T && !f ? n : c.ClassType.cloneAsInstance(n), w, f ? undefined : y.classType, undefined, f ? n : _, r == null ? undefined : r.createAddendum(), g);
                  if (!t) {
                    C = false;
                    return;
                  }
                  w = t;
                }
              }
              if (y.isReadOnly) {
                A = true;
              }
            } else {
              h = n.priv.fields.get(l);
              if (!h) {
                if (r != null) {
                  r.addMessage(s.LocAddendum.protocolMemberMissing().format({
                    name: l
                  }));
                }
                C = false;
                return;
              }
              w = e.getEffectiveTypeOfSymbol(h);
            }
            S = u.applySolvedTypeVars(S, b);
            if (!o.isInstanceMember() && (c.isFunction(S) || c.isOverloaded(S))) {
              let s;
              x = true;
              if (c.isClass(n)) {
                a.assert(y);
                if (f || c.isInstantiableClass(y.classType)) {
                  s = e.bindFunctionToClassOrObject(c.ClassType.cloneAsInstance(n), S, f ? undefined : y.classType, undefined, f ? n : _, r, g);
                }
              } else {
                s = e.bindFunctionToClassOrObject(c.ClassType.cloneAsInstance(t), S, t, undefined, undefined, r, g);
              }
              if (!s) {
                C = false;
                return;
              }
              s = u.makeFunctionTypeVarsBound(s);
              S = s;
            }
            const P = r == null ? undefined : r.createAddendum();
            const D = o.getTypedDeclarations().some(e => e.type === 1 && !!e.isFinal);
            if (h.getTypedDeclarations().some(e => e.type === 1 && !!e.isFinal)) {
              A = true;
            }
            if (D) {
              x = true;
            }
            if (c.isClassInstance(S) && c.ClassType.isPropertyClass(S)) {
              if (c.isClassInstance(w) && c.ClassType.isPropertyClass(w) && !T) {
                if (!p.assignProperty(e, c.ClassType.cloneAsInstantiable(S), c.ClassType.cloneAsInstantiable(w), i, n, P == null ? undefined : P.createAddendum(), v, b, g)) {
                  if (P) {
                    P.addMessage(s.LocAddendum.memberTypeMismatch().format({
                      name: l
                    }));
                  }
                  C = false;
                }
              } else {
                let t = e.getGetterTypeFromProperty(S, true);
                if (t) {
                  t = u.partiallySpecializeType(t, i, e.getTypeClassType());
                }
                if (!t || !e.assignType(t, w, P == null ? undefined : P.createAddendum(), v, k, g)) {
                  if (P) {
                    P.addMessage(s.LocAddendum.memberTypeMismatch().format({
                      name: l
                    }));
                  }
                  C = false;
                }
                if (!u.lookUpClassMember(S, '__set__', 16) && !u.lookUpClassMember(S, '__delete__', 16)) {
                  x = true;
                }
                if (A) {
                  if (!x) {
                    if (P) {
                      P.addMessage(s.LocAddendum.memberIsWritableInProtocol().format({
                        name: l
                      }));
                    }
                    C = false;
                  }
                }
              }
            } else {
              const t = o.getDeclarations()[0];
              const n = (t == null ? undefined : t.type) === 1 && !t.isFinal;
              const a = v.clone();
              if (e.assignType(S, w, P == null ? undefined : P.createAddendum(), a, n ? k | 1 : k, g)) {
                v.copyFromClone(a);
              } else {
                if (P) {
                  if (n) {
                    P.addMessage(s.LocAddendum.memberIsInvariant().format({
                      name: l
                    }));
                  }
                  P.addMessage(s.LocAddendum.memberTypeMismatch().format({
                    name: l
                  }));
                }
                C = false;
              }
            }
            if (!x && A) {
              if (P) {
                P.addMessage(s.LocAddendum.memberIsNotReadOnlyInProtocol().format({
                  name: l
                }));
              }
              C = false;
            }
            const N = d.isEffectivelyClassVar(o, false);
            const F = d.isEffectivelyClassVar(h, c.isClass(n) && c.ClassType.isDataClass(n));
            const E = h.getDeclarations().some(e => e.type === 1);
            if (T) {
              if (N) {
                if (P != null) {
                  P.addMessage(s.LocAddendum.memberIsClassVarInProtocol().format({
                    name: l
                  }));
                }
                C = false;
              } else {
                if (E && !F) {
                  if (!f) {
                    if (P != null) {
                      P.addMessage(s.LocAddendum.memberIsNotClassVarInClass().format({
                        name: l
                      }));
                    }
                    C = false;
                  }
                }
              }
            } else {
              if (N !== F) {
                if (N) {
                  if (P != null) {
                    P.addMessage(s.LocAddendum.memberIsClassVarInProtocol().format({
                      name: l
                    }));
                  }
                } else {
                  if (P != null) {
                    P.addMessage(s.LocAddendum.memberIsNotClassVarInProtocol().format({
                      name: l
                    }));
                  }
                }
                C = false;
              }
            }
            const M = d.getLastTypedDeclarationForSymbol(o);
            const O = d.getLastTypedDeclarationForSymbol(h);
            if ((M == null ? undefined : M.type) === 1 && (O == null ? undefined : O.type) === 1) {
              const e = !!M.isConstant || !!M.isFinal;
              let t = !!O.isConstant;
              if (y && c.isClass(y.classType) && y.isReadOnly) {
                t = true;
              }
              if (!e && t) {
                if (P) {
                  P.addMessage(s.LocAddendum.memberIsWritableInProtocol().format({
                    name: l
                  }));
                }
                C = false;
              }
            }
          });
        }
      });
      if (C && t.shared.typeParams.length > 0) {
        const n = c.ClassType.specialize(t, undefined);
        const a = e.solveAndApplyConstraints(n, v);
        if (t.priv.typeArgs) {
          if (!e.assignTypeArgs(t, a, r, m, y, g)) {
            C = false;
          }
        } else {
          if (m) {
            for (const e of t.shared.typeParams) {
              const t = v.getMainConstraintSet().getTypeVar(e);
              if (t) {
                m.copyBounds(t);
              }
            }
          }
        }
      }
      return C;
    }
  },
  92031: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getPyTypedInfo = function (e, t) {
      if (!e.existsSync(t) || !a.isDirectory(e, t)) {
        return;
      }
      const n = t.pytypedUri;
      if (!e.existsSync(n) || !a.isFile(e, n)) {
        return;
      }
      return r(e, n);
    };
    exports.getPyTypedInfoForPyTypedFile = r;
    const a = require(5884);
    function r(e, t) {
      let n = false;
      const a = e.statSync(t);
      if (a.size > 0 && a.size < 65536) {
        const a = e.readFileSync(t, 'utf8');
        if (a.match(/partial\n/) || a.match(/partial\r\n/)) {
          n = true;
        }
      }
      return {
        pyTypedPath: t,
        isPartiallyTyped: n
      };
    }
  },
  16259: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.thirdPartyFolderName = exports.stdLibFolderName = undefined;
    exports.getTypeShedFallbackPath = function (e) {
      const t = e.getModulePath();
      if (!t || t.isEmpty()) {
        return;
      }
      const n = t.combinePaths(o.typeshedFallback);
      if (e.existsSync(n)) {
        return e.realCasePath(n);
      }
      const a = t.getDirectory().combinePaths(o.typeshedFallback);
      if (e.existsSync(a)) {
        return e.realCasePath(a);
      }
      return;
    };
    exports.getTypeshedSubdirectory = function (e, n) {
      return e.combinePaths(n ? exports.stdLibFolderName : exports.thirdPartyFolderName);
    };
    exports.findPythonSearchPaths = function (e, t, n, a, r, s) {
      a.push('Finding python search paths');
      if (t.venvPath !== undefined && t.venv) {
        const n = t.venv;
        const r = t.venvPath.combinePaths(n);
        const s = [];
        const i = [];
        [o.lib, o.lib64, o.libAlternate].forEach(n => {
          const d = function (e, t, n, a) {
            if (!e.existsSync(t)) {
              a.push(`Did not find '${t}'`);
              return;
            }
            a.push(`Found path '${t}'; looking for ${o.sitePackages}`);
            const r = t.combinePaths(o.sitePackages);
            if (e.existsSync(r)) {
              a.push(`Found path '${r}'`);
              return r;
            }
            a.push(`Did not find '${r}', so looking for python subdirectory`);
            const s = p.getFileSystemEntries(e, t);
            const i = s.directories.filter(t => {
              if (t.fileName.startsWith('python3.')) {
                const n = t.combinePaths(o.sitePackages);
                return e.existsSync(n);
              }
              return false;
            });
            if (n) {
              const e = i.find(e => e.fileName === `python${l.PythonVersion.toMajorMinorString(n)}`);
              if (e) {
                const t = e.combinePaths(o.sitePackages);
                a.push(`Found path '${t}'`);
                return t;
              }
            }
            if (i.length > 0) {
              const e = i[0].combinePaths(o.sitePackages);
              a.push(`Found path '${e}'`);
              return e;
            }
            return;
          }(e, r.combinePaths(n), t.defaultPythonVersion, a);
          if (d) {
            c(s, d);
            i.push(e.realCasePath(d));
          }
        });
        i.forEach(t => {
          d(e, t).forEach(e => {
            c(s, e);
          });
        });
        if (s.length > 0) {
          a.push(`Found the following '${o.sitePackages}' dirs`);
          s.forEach(e => {
            a.push(`  ${e}`);
          });
          return s;
        }
        a.push(`Did not find any '${o.sitePackages}' dirs. Falling back on python interpreter.`);
      }
      const i = n.getPythonSearchPaths(t.pythonPath, a);
      if (r && s && !s.isEmpty()) {
        return i.paths.filter(e => !e.startsWith(s) || e.startsWith(i.prefix)).map(t => e.realCasePath(t));
      }
      return i.paths.map(t => e.realCasePath(t));
    };
    exports.isPythonBinary = function (e) {
      return (e = e.trim()) === 'python' || e === 'python3';
    };
    exports.getPathsFromPthFiles = d;
    const i = require(34455);
    const o = __importStar(require(4883));
    const l = require(63808);
    const p = require(5884);
    function d(e, t) {
      const n = [];
      e.readdirEntriesSync(t).filter(e => (e.isFile() || e.isSymbolicLink()) && e.name.endsWith('.pth')).sort((e, t) => i.compareComparableValues(e.name, t.name)).forEach(a => {
        const r = e.realCasePath(t.combinePaths(a.name));
        const s = p.tryStat(e, r);
        if ((s == null ? undefined : s.isFile()) && s.size > 0 && s.size < 65536) {
          e.readFileSync(r, 'utf8').split(/\r?\n/).forEach(a => {
            const r = a.trim();
            if (r.length > 0 && !r.startsWith('#') && !r.match(/^import\s/)) {
              const a = t.combinePaths(r);
              if (e.existsSync(a) && p.isDirectory(e, a)) {
                n.push(e.realCasePath(a));
              }
            }
          });
        }
      });
      return n;
    }
    function c(e, t) {
      return !e.some(e => e.key === t.key) && (e.push(t), true);
    }
    exports.stdLibFolderName = 'stdlib';
    exports.thirdPartyFolderName = 'stubs';
  },
  35197: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Scope = undefined;
    const a = require(48281);
    const r = require(58253);
    exports.Scope = class {
      constructor(e, t, n) {
        this.symbolTable = new Map();
        this.notLocalBindings = new Map();
        this.type = e;
        this.parent = t;
        this.proxy = n;
      }
      getGlobalScope() {
        let e = this;
        let t = false;
        while (e) {
          if (e.type === 4 || e.type === 5) {
            return {
              scope: e,
              isBeyondExecutionScope: t
            };
          }
          if (e.type === 2) {
            t = true;
          }
          e = e.parent;
        }
        a.fail('failed to find scope');
        return {
          scope: this,
          isBeyondExecutionScope: t
        };
      }
      isIndependentlyExecutable() {
        return this.type === 4 || this.type === 2;
      }
      lookUpSymbol(e) {
        return this.symbolTable.get(e);
      }
      lookUpSymbolRecursive(e, t) {
        let n;
        let a = this;
        let r = this.symbolTable.get(e);
        if (!r && (t == null ? undefined : t.useProxyScope) && this.proxy) {
          r = this.proxy.symbolTable.get(e);
          a = this.proxy;
        }
        if (r) {
          if ((t == null ? undefined : t.isOutsideCallerModule) && r.isExternallyHidden()) {
            return;
          }
          const e = r.getDeclarations();
          if (e.length === 0 || e.some(e => e.type !== 1 || !e.isDefinedByMemberAccess)) {
            return {
              symbol: r,
              isOutsideCallerModule: !!(t == null ? undefined : t.isOutsideCallerModule),
              isBeyondExecutionScope: !!(t == null ? undefined : t.isBeyondExecutionScope),
              scope: a,
              usesNonlocalBinding: !!(t == null ? undefined : t.usesNonlocalBinding),
              usesGlobalBinding: !!(t == null ? undefined : t.usesGlobalBinding)
            };
          }
        }
        let s = (t == null ? undefined : t.isBeyondExecutionScope) || this.isIndependentlyExecutable();
        const i = this.notLocalBindings.get(e);
        if (i === 1) {
          const e = this.getGlobalScope();
          if (e.scope !== this) {
            n = e.scope;
            if (e.isBeyondExecutionScope) {
              s = true;
            }
          }
        } else {
          n = this.parent;
        }
        if (n) {
          return n.lookUpSymbolRecursive(e, {
            isOutsideCallerModule: !!(t == null ? undefined : t.isOutsideCallerModule) || this.type === 4,
            isBeyondExecutionScope: s,
            usesNonlocalBinding: i === 0 || !!(t == null ? undefined : t.usesNonlocalBinding),
            usesGlobalBinding: i === 1 || !!(t == null ? undefined : t.usesGlobalBinding)
          });
        }
      }
      addSymbol(e, t) {
        const n = new r.Symbol(t);
        this.symbolTable.set(e, n);
        return n;
      }
      getBindingType(e) {
        return this.notLocalBindings.get(e);
      }
      setBindingType(e, t) {
        return this.notLocalBindings.set(e, t);
      }
      setSlotsNames(e) {
        this.slotsNames = e;
      }
      getSlotsNames() {
        return this.slotsNames;
      }
    };
  },
  95952: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getBuiltInScope = function (e) {
      let t = e;
      while (t.type !== 5) {
        t = t.parent;
      }
      return t;
    };
    exports.getScopeForNode = function (e) {
      const t = r.getEvaluationScopeNode(e).node;
      return a.getScope(t);
    };
    exports.getScopeHierarchy = function (e, t) {
      const n = [];
      let s = e;
      while (s) {
        const e = r.getEvaluationScopeNode(s).node;
        const i = a.getScope(e);
        if (!i) {
          return;
        }
        if (n.length === 0 || n[n.length - 1] !== i) {
          n.push(i);
        }
        if (i === t) {
          return n;
        }
        s = e.parent;
      }
      if (t) {
        return undefined;
      } else {
        return n;
      }
    };
    exports.findTopNodeInScope = function (e, t) {
      let n;
      let r = e;
      let s = false;
      while (r) {
        if (a.getScope(r) === t) {
          s = true;
        } else {
          if (s) {
            return n;
          }
        }
        n = r;
        r = r.parent;
      }
      return;
    };
    exports.isScopeContainedWithin = function (e, t) {
      let n = e;
      while (n) {
        if (n.parent === t) {
          return true;
        }
        n = n.parent;
      }
      return false;
    };
    const a = require(26687);
    const r = require(41557);
  },
  33970: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.AnalyzerService = undefined;
    exports.getNextServiceId = P;
    const i = __importStar(require(8753));
    const o = require(33351);
    const l = require(91426);
    const p = require(12522);
    const d = require(25075);
    const c = require(34455);
    const u = require(12060);
    const m = require(50918);
    const y = require(4883);
    const g = require(54010);
    const h = require(63808);
    const f = require(71745);
    const T = require(71582);
    const v = require(27113);
    const b = require(5884);
    const _ = require(67703);
    const C = require(82695);
    const I = require(75130);
    const k = require(16259);
    const w = require(39045);
    const S = require(53266);
    const A = g.normalizeSlashes('/.git/');
    let x = 1;
    function P(e) {
      return `${e}_${x++}`;
    }
    class D {
      constructor(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        var o;
        this._typeStubTargetIsSingleFile = false;
        this._extendedConfigFileUris = [];
        this._requireTrackedFileUpdate = true;
        this._lastUserInteractionTime = 0;
        this._disposed = false;
        this._pendingLibraryChanges = {
          changesOnly: true
        };
        this._instanceName = e;
        this._executionRootUri = v.Uri.empty();
        this.options = n;
        this.options.serviceId = (a = this.options.serviceId) !== null && a !== undefined ? a : P(e);
        this.options.console = n.console || new d.StandardConsole();
        this._serviceProvider = t.clone();
        if (this.options.console) {
          this._serviceProvider.add(f.ServiceKeys.console, this.options.console);
        }
        if (this.options.fileSystem) {
          this._serviceProvider.add(f.ServiceKeys.fs, this.options.fileSystem);
        }
        this.options.importResolverFactory = (r = n.importResolverFactory) !== null && r !== undefined ? r : D.createImportResolver;
        this.options.cancellationProvider = (s = n.cancellationProvider) !== null && s !== undefined ? s : new l.DefaultCancellationProvider();
        this.options.hostFactory = (i = n.hostFactory) !== null && i !== undefined ? i : () => new m.NoAccessHost();
        this.options.configOptions = (o = n.configOptions) !== null && o !== undefined ? o : new p.ConfigOptions(v.Uri.file(process.cwd(), this._serviceProvider));
        const c = this.options.importResolverFactory(this._serviceProvider, this.options.configOptions, this.options.hostFactory());
        this._backgroundAnalysisProgram = this.options.backgroundAnalysisProgramFactory !== undefined ? this.options.backgroundAnalysisProgramFactory(this.options.serviceId, this._serviceProvider, this.options.configOptions, c, this.options.backgroundAnalysis, this.options.maxAnalysisTime) : new C.BackgroundAnalysisProgram(this.options.serviceId, this._serviceProvider, this.options.configOptions, c, this.options.backgroundAnalysis, this.options.maxAnalysisTime, undefined);
      }
      get fs() {
        return this._backgroundAnalysisProgram.importResolver.fileSystem;
      }
      get serviceProvider() {
        return this._serviceProvider;
      }
      get cancellationProvider() {
        return this.options.cancellationProvider;
      }
      get librarySearchUrisToWatch() {
        return this._librarySearchUrisToWatch;
      }
      get backgroundAnalysisProgram() {
        return this._backgroundAnalysisProgram;
      }
      get test_program() {
        return this._program;
      }
      get id() {
        return this.options.serviceId;
      }
      setServiceName(e) {
        this._instanceName = e;
      }
      clone(e, t, n, a) {
        var r;
        const s = new D(e, this._serviceProvider, {
          ...this.options,
          serviceId: t,
          backgroundAnalysis: n,
          skipScanningUserFiles: true,
          fileSystem: a
        });
        const i = this.getUserFiles();
        s.backgroundAnalysisProgram.setTrackedFiles(i);
        s.backgroundAnalysisProgram.markAllFilesDirty(true);
        for (const e of this.backgroundAnalysisProgram.program.getOpened()) {
          const t = e.sourceFile.getClientVersion();
          if (t !== undefined) {
            s.setFileOpened(e.sourceFile.getUri(), t, e.sourceFile.getOpenFileContents(), e.sourceFile.getIPythonMode(), (r = e.chainedSourceFile) === null || r === undefined ? undefined : r.sourceFile.getUri());
          }
        }
        return s;
      }
      runEditMode(e, t) {
        let n = [];
        this._backgroundAnalysisProgram.enterEditMode();
        try {
          this._program.runEditMode(e, t);
        } finally {
          n = this._backgroundAnalysisProgram.exitEditMode();
        }
        if (t.isCancellationRequested) {
          return [];
        } else {
          return n;
        }
      }
      dispose() {
        if (!this._disposed) {
          this._backgroundAnalysisProgram.dispose();
        }
        this._disposed = true;
        this._removeSourceFileWatchers();
        this._removeConfigFileWatcher();
        this._removeLibraryFileWatcher();
        this._clearReloadConfigTimer();
        this._clearReanalysisTimer();
        this._clearLibraryReanalysisTimer();
      }
      static createImportResolver(e, t, n) {
        return new I.ImportResolver(e, t, n);
      }
      setCompletionCallback(e) {
        this._onCompletionCallback = e;
        this._backgroundAnalysisProgram.setCompletionCallback(e);
      }
      setOptions(e) {
        this._commandLineOptions = e;
        const t = this._hostFactory();
        const n = this._getConfigOptions(t, e);
        this._backgroundAnalysisProgram.setConfigOptions(n);
        this._executionRootUri = n.projectRoot;
        this.applyConfigOptions(t);
      }
      hasSourceFile(e) {
        return this.backgroundAnalysisProgram.hasSourceFile(e);
      }
      isTracked(e) {
        return this._program.owns(e);
      }
      getUserFiles() {
        return this._program.getUserFiles().map(e => e.sourceFile.getUri());
      }
      getOpenFiles() {
        return this._program.getOpened().map(e => e.sourceFile.getUri());
      }
      setFileOpened(e, t, n, a = S.IPythonMode.None, r) {
        this._backgroundAnalysisProgram.setFileOpened(e, t, n, {
          isTracked: this.isTracked(e) || a !== S.IPythonMode.None,
          ipythonMode: a,
          chainedFileUri: r
        });
        this._scheduleReanalysis(false);
      }
      getChainedUri(e) {
        return this._backgroundAnalysisProgram.getChainedUri(e);
      }
      updateChainedUri(e, t) {
        this._backgroundAnalysisProgram.updateChainedUri(e, t);
        this._scheduleReanalysis(false);
      }
      updateOpenFileContents(e, t, n, a = S.IPythonMode.None) {
        this._backgroundAnalysisProgram.updateOpenFileContents(e, t, n, {
          isTracked: this.isTracked(e),
          ipythonMode: a,
          chainedFileUri: undefined
        });
        this._scheduleReanalysis(false);
      }
      setFileClosed(e, t) {
        this._backgroundAnalysisProgram.setFileClosed(e, t);
        this._scheduleReanalysis(false);
      }
      addInterimFile(e) {
        this._backgroundAnalysisProgram.addInterimFile(e);
      }
      getParserOutput(e) {
        return this._program.getParserOutput(e);
      }
      getParseResults(e) {
        return this._program.getParseResults(e);
      }
      getSourceFile(e) {
        return this._program.getBoundSourceFile(e);
      }
      getTextOnRange(e, t, n) {
        return this._program.getTextOnRange(e, t, n);
      }
      run(e, t) {
        return this._program.run(e, t);
      }
      printStats() {
        this._console.info('');
        this._console.info('Analysis stats');
        const e = this._program.getFileCount(false);
        this._console.info(`Total files parsed and bound: ${e.toString()}`);
        const t = this._program.getUserFileCount();
        this._console.info(`Total files checked: ${t.toString()}`);
      }
      printDetailedAnalysisTimes() {
        this._program.printDetailedAnalysisTimes();
      }
      printDependencies(e) {
        this._program.printDependencies(this._executionRootUri, e);
      }
      analyzeFile(e, t) {
        return this._backgroundAnalysisProgram.analyzeFile(e, t);
      }
      getDiagnosticsForRange(e, t, n) {
        return this._backgroundAnalysisProgram.getDiagnosticsForRange(e, t, n);
      }
      getConfigOptions() {
        return this._configOptions;
      }
      getImportResolver() {
        return this._backgroundAnalysisProgram.importResolver;
      }
      recordUserInteractionTime() {
        this._lastUserInteractionTime = Date.now();
        if (this._analyzeTimer) {
          this._scheduleReanalysis(false);
        }
      }
      test_getConfigOptions(e) {
        return this._getConfigOptions(this._backgroundAnalysisProgram.host, e);
      }
      test_getFileNamesFromFileSpecs() {
        return this._getFileNamesFromFileSpecs();
      }
      test_shouldHandleSourceFileWatchChanges(e, t) {
        return this._shouldHandleSourceFileWatchChanges(e, t);
      }
      test_shouldHandleLibraryFileWatchChanges(e, t) {
        return this._shouldHandleLibraryFileWatchChanges(e, t);
      }
      writeTypeStub(e) {
        var t;
        const n = this._getTypeStubFolder();
        this._program.writeTypeStub((t = this._typeStubTargetUri) !== null && t !== undefined ? t : v.Uri.empty(), this._typeStubTargetIsSingleFile, n, e);
      }
      writeTypeStubInBackground(e) {
        var t;
        const n = this._getTypeStubFolder();
        return this._backgroundAnalysisProgram.writeTypeStub((t = this._typeStubTargetUri) !== null && t !== undefined ? t : v.Uri.empty(), this._typeStubTargetIsSingleFile, n, e);
      }
      invalidateAndForceReanalysis(e) {
        this._backgroundAnalysisProgram.invalidateAndForceReanalysis(e);
      }
      restart() {
        this.applyConfigOptions(this._hostFactory());
        this._backgroundAnalysisProgram.restart();
      }
      runAnalysis(e) {
        if (this._backgroundAnalysisProgram.startAnalysis(e)) {
          this._scheduleReanalysis(false);
        }
      }
      applyConfigOptions(e) {
        var t;
        var n;
        const a = this._importResolverFactory(this._serviceProvider, this._backgroundAnalysisProgram.configOptions, e);
        this._backgroundAnalysisProgram.setImportResolver(a);
        if (((t = this._commandLineOptions) === null || t === undefined ? undefined : t.fromLanguageServer) || this._configOptions.verboseOutput) {
          const e = this._configOptions.verboseOutput ? d.LogLevel.Info : d.LogLevel.Log;
          const t = this._configOptions.getExecutionEnvironments();
          for (const r of t) {
            d.log(this._console, e, `Execution environment: ${r.name}`);
            d.log(this._console, e, '  Extra paths:');
            if (r.extraPaths.length > 0) {
              r.extraPaths.forEach(t => {
                d.log(this._console, e, `    ${t.toUserVisibleString()}`);
              });
            } else {
              d.log(this._console, e, '    (none)');
            }
            d.log(this._console, e, `  Python version: ${h.PythonVersion.toString(r.pythonVersion)}`);
            d.log(this._console, e, `  Python platform: ${(n = r.pythonPlatform) !== null && n !== undefined ? n : 'All'}`);
            d.log(this._console, e, '  Search paths:');
            a.getImportRoots(r, true).forEach(t => {
              d.log(this._console, e, `    ${t.toUserVisibleString()}`);
            });
          }
        }
        this._updateLibraryFileWatcher();
        this._updateConfigFileWatcher();
        this._updateSourceFileWatchers();
        this._updateTrackedFileList(true);
        this._scheduleReanalysis(false);
      }
      get _console() {
        return this.options.console;
      }
      get _hostFactory() {
        return this.options.hostFactory;
      }
      get _importResolverFactory() {
        return this.options.importResolverFactory;
      }
      get _program() {
        return this._backgroundAnalysisProgram.program;
      }
      get _configOptions() {
        return this._backgroundAnalysisProgram.configOptions;
      }
      get _watchForSourceChanges() {
        var e;
        return !!((e = this._commandLineOptions) === null || e === undefined ? undefined : e.languageServerSettings.watchForSourceChanges);
      }
      get _watchForLibraryChanges() {
        var e;
        return !!((e = this._commandLineOptions) === null || e === undefined ? undefined : e.languageServerSettings.watchForLibraryChanges) && !!this.options.libraryReanalysisTimeProvider;
      }
      get _watchForConfigChanges() {
        var e;
        return !!((e = this._commandLineOptions) === null || e === undefined ? undefined : e.languageServerSettings.watchForConfigChanges);
      }
      get _typeCheckingMode() {
        var e;
        if ((e = this._commandLineOptions) === null || e === undefined) {
          return undefined;
        } else {
          return e.configSettings.typeCheckingMode;
        }
      }
      get _verboseOutput() {
        return !!this._configOptions.verboseOutput;
      }
      get _typeStubTargetImportName() {
        var e;
        if ((e = this._commandLineOptions) === null || e === undefined) {
          return undefined;
        } else {
          return e.languageServerSettings.typeStubTargetImportName;
        }
      }
      _getConfigOptions(e, t) {
        const n = t.executionRoot;
        const a = v.Uri.is(n) ? n : c.isString(n) && n.length > 0 ? v.Uri.file(n, this.serviceProvider, true) : v.Uri.defaultWorkspace(this.serviceProvider);
        const r = this.fs.realCasePath(a);
        let s;
        let i;
        let o = r;
        if (t.configFilePath) {
          s = this.fs.realCasePath(g.isRootedDiskPath(t.configFilePath) ? v.Uri.file(t.configFilePath, this.serviceProvider, true) : o.resolvePaths(t.configFilePath));
          if (this.fs.existsSync(s)) {
            if (s.lastExtension.endsWith('.json') || s.lastExtension.endsWith('.toml')) {
              o = s.getDirectory();
            } else {
              o = s;
              s = w.findConfigFile(this.fs, s);
              if (!s) {
                this._console.info(`Configuration file not found at ${o.toUserVisibleString()}.`);
              }
            }
          } else {
            this._console.info(`Configuration file not found at ${s.toUserVisibleString()}.`);
            s = o;
          }
        } else {
          if (t.executionRoot) {
            s = w.findConfigFile(this.fs, o);
            if (!s && !t.fromLanguageServer) {
              s = w.findConfigFileHereOrUp(this.fs, o);
            }
            if (s) {
              o = s.getDirectory();
            } else {
              this._console.log('No configuration file found.');
              s = undefined;
            }
          }
        }
        if (!s) {
          i = w.findPyprojectTomlFile(this.fs, o);
          if (!i && !t.fromLanguageServer) {
            i = w.findPyprojectTomlFileHereOrUp(this.fs, o);
          }
          if (i) {
            o = i.getDirectory();
            this._console.log(`pyproject.toml file found at ${o.toUserVisibleString()}.`);
          } else {
            this._console.log('No pyproject.toml file found.');
          }
        }
        const l = new p.ConfigOptions(o);
        const d = this._getExtendedConfigurations(s ?? i);
        if (d && d.length > 0) {
          l.initializeTypeCheckingMode('standard');
          for (const t of d) {
            l.initializeFromJson(t.configFileJsonObj, t.configFileDirUri, this.serviceProvider, e);
          }
          l.configFileSource = s ?? i;
          if (!t.fromLanguageServer) {
            this._applyCommandLineOverrides(l, t.configSettings, o, false);
          }
        } else {
          l.initializeTypeCheckingMode(t.fromLanguageServer ? 'off' : 'standard');
          this._applyCommandLineOverrides(l, t.configSettings, o, t.fromLanguageServer);
        }
        this._applyLanguageServerOptions(l, o, t.languageServerSettings);
        this._ensureDefaultOptions(e, l, o, r, t);
        if (d) {
          for (const e of d) {
            l.setupExecutionEnvironments(e.configFileJsonObj, e.configFileDirUri, this.serviceProvider.console());
          }
        }
        return l;
      }
      _ensureDefaultOptions(e, t, n, a, r) {
        var s;
        var i;
        const o = ['**/node_modules', '**/__pycache__', '**/.*'];
        if (t.include.length === 0) {
          this._console.info(`No include entries specified; assuming ${n.toUserVisibleString()}`);
          t.include.push(b.getFileSpec(n, '.'));
        }
        if (t.exclude.length === 0) {
          o.forEach(e => {
            this._console.info(`Auto-excluding ${e}`);
            t.exclude.push(b.getFileSpec(n, e));
          });
          if (t.autoExcludeVenv === undefined) {
            t.autoExcludeVenv = true;
          }
        }
        if (!t.defaultExtraPaths) {
          t.ensureDefaultExtraPaths(this.fs, (s = r.configSettings.autoSearchPaths) !== null && s !== undefined && s, r.configSettings.extraPaths);
        }
        if (t.defaultPythonPlatform === undefined) {
          t.defaultPythonPlatform = r.configSettings.pythonPlatform;
        }
        if (t.defaultPythonVersion === undefined) {
          t.defaultPythonVersion = r.configSettings.pythonVersion;
        }
        if (t.typeshedPath && t.typeshedPath === n && t.defaultPythonVersion !== undefined) {
          const e = this.getImportResolver().getTypeshedStdlibExcludeList(t.typeshedPath, t.defaultPythonVersion, t.defaultPythonPlatform);
          this._console.info('Excluding typeshed stdlib stubs according to VERSIONS file:');
          e.forEach(e => {
            this._console.info(`    ${e}`);
            t.exclude.push(b.getFileSpec(a, e.getFilePath()));
          });
        }
        if (t.useLibraryCodeForTypes === undefined) {
          t.useLibraryCodeForTypes = true;
        }
        if (t.stubPath) {
          if (!this.fs.existsSync(t.stubPath) || !b.isDirectory(this.fs, t.stubPath)) {
            this._console.warn(`stubPath ${t.stubPath} is not a valid directory.`);
          }
        } else {
          t.stubPath = t.projectRoot.resolvePaths(y.defaultStubsDirectory);
        }
        if (t.venvPath && (this.fs.existsSync(t.venvPath) && b.isDirectory(this.fs, t.venvPath) || this._console.error(`venvPath ${t.venvPath.toUserVisibleString()} is not a valid directory.`), t.venv = (i = t.venv) !== null && i !== undefined ? i : this._configOptions.venv, t.venv && t.venvPath)) {
          const n = t.venvPath.resolvePaths(t.venv);
          if (this.fs.existsSync(n) && b.isDirectory(this.fs, n)) {
            const n = [];
            if (k.findPythonSearchPaths(this.fs, t, e, n) === undefined) {
              this._console.error(`site-packages directory cannot be located for venvPath ${t.venvPath.toUserVisibleString()} and venv ${t.venv}.`);
              if (t.verboseOutput) {
                n.forEach(e => {
                  this._console.error(`  ${e}`);
                });
              }
            }
          } else {
            this._console.error(`venv ${t.venv} subdirectory not found in venv path ${t.venvPath.toUserVisibleString()}.`);
          }
        }
        if (t.venv) {
          if (!t.venvPath) {
            this._console.warn('venvPath not specified, so venv settings will be ignored.');
          }
        }
        if (t.typeshedPath) {
          if (!this.fs.existsSync(t.typeshedPath) || !b.isDirectory(this.fs, t.typeshedPath)) {
            this._console.error(`typeshedPath ${t.typeshedPath.toUserVisibleString()} is not a valid directory.`);
          }
        }
        if (r.configSettings.verboseOutput !== undefined) {
          t.verboseOutput = r.configSettings.verboseOutput;
        }
        if (t.pythonPath) {
          t.ensureDefaultPythonVersion(e, this._console);
        }
        t.ensureDefaultPythonPlatform(e, this._console);
      }
      _applyLanguageServerOptions(e, t, n) {
        e.disableTaggedHints = !!n.disableTaggedHints;
        if (n.checkOnlyOpenFiles !== undefined) {
          e.checkOnlyOpenFiles = n.checkOnlyOpenFiles;
        }
        if (n.autoImportCompletions !== undefined) {
          e.autoImportCompletions = n.autoImportCompletions;
        }
        if (n.indexing !== undefined) {
          e.indexing = n.indexing;
        }
        if (n.taskListTokens) {
          e.taskListTokens = n.taskListTokens;
        }
        if (n.logTypeEvaluationTime !== undefined) {
          e.logTypeEvaluationTime = n.logTypeEvaluationTime;
        }
        e.typeEvaluationTimeThreshold = n.typeEvaluationTimeThreshold;
        if (n.pythonPath) {
          this._console.info(`Setting pythonPath for service "${this._instanceName}": "${n.pythonPath}"`);
          e.pythonPath = this.fs.realCasePath(v.Uri.file(n.pythonPath, this.serviceProvider, true));
        }
        if (n.venvPath) {
          if (!e.venvPath) {
            e.venvPath = t.resolvePaths(n.venvPath);
          }
        }
      }
      _applyCommandLineOverrides(e, t, n, a) {
        var r;
        var s;
        var i;
        if (t.typeCheckingMode) {
          e.initializeTypeCheckingMode(t.typeCheckingMode);
        }
        if (t.extraPaths) {
          e.ensureDefaultExtraPaths(this.fs, (r = t.autoSearchPaths) !== null && r !== undefined && r, t.extraPaths);
        }
        if (t.pythonVersion || t.pythonPlatform) {
          e.defaultPythonVersion = (s = t.pythonVersion) !== null && s !== undefined ? s : e.defaultPythonVersion;
          e.defaultPythonPlatform = (i = t.pythonPlatform) !== null && i !== undefined ? i : e.defaultPythonPlatform;
        }
        if (t.pythonPath) {
          this._console.info(`Setting pythonPath for service "${this._instanceName}": "${t.pythonPath}"`);
          e.pythonPath = this.fs.realCasePath(v.Uri.file(t.pythonPath, this.serviceProvider, true));
        }
        if (t.pythonEnvironmentName) {
          this._console.info(`Setting environmentName for service "${this._instanceName}": "${t.pythonEnvironmentName}"`);
          e.pythonEnvironmentName = t.pythonEnvironmentName;
        }
        t.includeFileSpecs.forEach(t => {
          e.include.push(b.getFileSpec(n, t));
        });
        t.excludeFileSpecs.forEach(t => {
          e.exclude.push(b.getFileSpec(n, t));
        });
        t.ignoreFileSpecs.forEach(t => {
          e.ignore.push(b.getFileSpec(n, t));
        });
        e.applyDiagnosticOverrides(t.diagnosticSeverityOverrides);
        e.applyDiagnosticOverrides(t.diagnosticBooleanOverrides);
        if (t.analyzeUnannotatedFunctions !== undefined) {
          e.diagnosticRuleSet.analyzeUnannotatedFunctions = t.analyzeUnannotatedFunctions;
        }
        if (t.includeFileSpecsOverride) {
          e.include = [];
          t.includeFileSpecsOverride.forEach(t => {
            e.include.push(b.getFileSpec(v.Uri.file(t, this.serviceProvider, true), '.'));
          });
        }
        if (t.venvPath) {
          e.venvPath = n.resolvePaths(t.venvPath);
        }
        const o = (e, t) => {
          const n = a ? 'the client settings' : 'a command-line option';
          this._console.warn(`The ${e} has been specified in both the config file and ${n}. The value in the config file (${t}) will take precedence`);
        };
        if (t.typeshedPath) {
          if (e.typeshedPath) {
            o('typeshedPath', e.typeshedPath.toUserVisibleString());
          } else {
            e.typeshedPath = n.resolvePaths(t.typeshedPath);
          }
        }
        if (e.useLibraryCodeForTypes === undefined) {
          e.useLibraryCodeForTypes = t.useLibraryCodeForTypes;
        } else {
          if (t.useLibraryCodeForTypes !== undefined) {
            o('useLibraryCodeForTypes', e.useLibraryCodeForTypes);
          }
        }
        if (t.stubPath) {
          if (e.stubPath) {
            o('stubPath', e.stubPath.toUserVisibleString());
          } else {
            e.stubPath = this.fs.realCasePath(n.resolvePaths(t.stubPath));
          }
        }
      }
      _getExtendedConfigurations(e) {
        this._primaryConfigFileUri = e;
        this._extendedConfigFileUris = [];
        if (!e) {
          return;
        }
        let t = e;
        const n = [];
        while (true) {
          let e;
          this._extendedConfigFileUris.push(t);
          if (t.lastExtension.endsWith('.toml')) {
            this._console.info(`Loading pyproject.toml file at ${t.toUserVisibleString()}`);
            e = this._parsePyprojectTomlFile(t);
          } else {
            this._console.info(`Loading configuration file at ${t.toUserVisibleString()}`);
            e = this._parseJsonConfigFile(t);
          }
          if (!e) {
            break;
          }
          n.unshift({
            configFileJsonObj: e,
            configFileDirUri: t.getDirectory()
          });
          const a = p.ConfigOptions.resolveExtends(e, t.getDirectory());
          if (!a) {
            break;
          }
          if (this._extendedConfigFileUris.some(e => e.equals(a))) {
            this._console.error(`Circular reference in configuration file "extends" setting: ${t.toUserVisibleString()} extends ${a.toUserVisibleString()}`);
            break;
          }
          t = a;
        }
        return n;
      }
      _getTypeStubFolder() {
        var e;
        const t = (e = this._configOptions.stubPath) !== null && e !== undefined ? e : this.fs.realCasePath(this._configOptions.projectRoot.resolvePaths(y.defaultStubsDirectory));
        if (!this._typeStubTargetUri || !this._typeStubTargetImportName) {
          const e = `Import '${this._typeStubTargetImportName}' could not be resolved`;
          this._console.error(e);
          throw new Error(e);
        }
        const n = this._typeStubTargetImportName.split('.');
        if (n[0].length === 0) {
          const e = `Import '${this._typeStubTargetImportName}' could not be resolved`;
          this._console.error(e);
          throw new Error(e);
        }
        try {
          if (!this.fs.existsSync(t)) {
            this.fs.mkdirSync(t);
          }
        } catch (e) {
          const n = `Could not create typings directory '${t.toUserVisibleString()}'`;
          this._console.error(n);
          throw new Error(n);
        }
        const a = t.resolvePaths(n[0]);
        const r = t.resolvePaths(...n);
        try {
          if (!this.fs.existsSync(r)) {
            b.makeDirectories(this.fs, r, t);
          }
        } catch (e) {
          const t = `Could not create typings subdirectory '${r.toUserVisibleString()}'`;
          this._console.error(t);
          throw new Error(t);
        }
        return a;
      }
      _parseJsonConfigFile(e) {
        return this._attemptParseFile(e, e => {
          const t = [];
          const n = i.parse(e, t, {
            allowTrailingComma: true
          });
          if (t.length > 0) {
            throw new Error('Errors parsing JSON file');
          }
          return n;
        });
      }
      _parsePyprojectTomlFile(e) {
        return this._attemptParseFile(e, (t, n) => {
          try {
            const e = o.parse(t);
            if (e && 'tool' in e) {
              return e.tool.pyright;
            }
          } catch (e) {
            this._console.error(`Pyproject file parse attempt ${n} error: ${JSON.stringify(e)}`);
            throw e;
          }
          this._console.info(`Pyproject file "${e.toUserVisibleString()}" has no "[tool.pyright]" section.`);
        });
      }
      _attemptParseFile(e, t) {
        let n = '';
        let a = 0;
        while (true) {
          try {
            n = this.fs.readFileSync(e, 'utf8');
          } catch {
            this._console.error(`Config file "${e.toUserVisibleString()}" could not be read.`);
            this._reportConfigParseError();
            return;
          }
          let r = false;
          try {
            return t(n, a + 1);
          } catch (e) {
            r = true;
          }
          if (!r) {
            break;
          }
          if (a++ >= 5) {
            this._console.error(`Config file "${e.toUserVisibleString()}" could not be parsed. Verify that format is correct.`);
            this._reportConfigParseError();
            return;
          }
        }
      }
      _getFileNamesFromFileSpecs() {
        const e = new Map();
        T.timingStats.findFilesTime.timeOperation(() => {
          const t = this._matchFiles(this._configOptions.include, this._configOptions.exclude);
          for (const n of t) {
            e.set(n.key, n);
          }
        });
        this._backgroundAnalysisProgram.program.getOpened().map(e => e.sourceFile.getUri()).filter(e => p.matchFileSpecs(this._program.configOptions, e)).forEach(t => e.set(t.key, t));
        return Array.from(e.values());
      }
      _updateTrackedFileList(e) {
        if (this._typeStubTargetImportName) {
          const e = this._configOptions.findExecEnvironment(this._executionRootUri);
          const t = I.createImportedModuleDescriptor(this._typeStubTargetImportName);
          const n = this._backgroundAnalysisProgram.importResolver.resolveImport(v.Uri.empty(), e, t);
          if (n.isImportFound) {
            const e = [];
            const t = n.resolvedUris[n.resolvedUris.length - 1];
            const a = b.isFile(this.fs, t);
            const r = a && t.stripAllExtensions().fileName === '__init__';
            let s = t;
            if (a) {
              s = s.getDirectory();
            }
            for (let e = n.resolvedUris.length - 2; e >= 0; e--) {
              s = n.resolvedUris[e].isEmpty() ? s.getDirectory() : n.resolvedUris[e];
            }
            if (b.isDirectory(this.fs, s)) {
              this._typeStubTargetUri = s;
            } else {
              if (b.isFile(this.fs, s)) {
                this._typeStubTargetUri = s.getDirectory();
              }
            }
            if (t.isEmpty()) {
              this._typeStubTargetIsSingleFile = false;
            } else {
              e.push(t);
              this._typeStubTargetIsSingleFile = n.resolvedUris.length === 1 && !r;
            }
            n.filteredImplicitImports.forEach(t => {
              if (I.ImportResolver.isSupportedImportSourceFile(t.uri)) {
                e.push(t.uri);
              }
            });
            this._backgroundAnalysisProgram.setAllowedThirdPartyImports([this._typeStubTargetImportName]);
            this._backgroundAnalysisProgram.setTrackedFiles(e);
          } else {
            this._console.error(`Import '${this._typeStubTargetImportName}' not found`);
          }
        } else {
          if (!this.options.skipScanningUserFiles) {
            let t = [];
            this._console.log('Searching for source files');
            t = this._getFileNamesFromFileSpecs();
            this._backgroundAnalysisProgram.setConfigOptions(this._configOptions);
            this._backgroundAnalysisProgram.setTrackedFiles(t);
            this._backgroundAnalysisProgram.markAllFilesDirty(e);
            if (t.length === 0) {
              this._console.info('No source files found.');
            } else {
              this._console.info(`Found ${t.length} source ${t.length === 1 ? 'file' : 'files'}`);
            }
          }
        }
        this._requireTrackedFileUpdate = false;
      }
      _tryShowLongOperationMessageBox() {
        const e = this.serviceProvider.tryGet(f.ServiceKeys.windowService);
        if (!e) {
          return;
        }
        const t = _.Localizer.Service.longOperation();
        const n = e.createGoToOutputAction();
        e.showInformationMessage(t, n);
      }
      _matchFiles(e, t) {
        if (this._executionRootUri.isEmpty()) {
          return [];
        }
        const n = [['bin', 'activate'], ['Scripts', 'activate'], ['pyvenv.cfg'], ['conda-meta']];
        const a = [];
        const r = Date.now();
        let s = false;
        let i = 0;
        const o = (e, o, l) => {
          if (!s) {
            if ((Date.now() - r) * 0.001 >= 10 && i >= 50) {
              this._console.error('Enumeration of workspace source files is taking longer than 10 seconds.\nThis may be because:\n* You have opened your home directory or entire hard drive as a workspace\n* Your workspace contains a very large number of directories and files\n* Your workspace contains a symlink to a directory with many files\n* Your workspace is remote, and file enumeration is slow\nTo reduce this time, open a workspace directory with fewer files or add a pyrightconfig.json configuration file with an "exclude" section to exclude subdirectories from your workspace. For more details, refer to https://github.com/microsoft/pyright/blob/main/docs/configuration.md.');
              this._tryShowLongOperationMessageBox();
              s = true;
            }
          }
          if (this._configOptions.autoExcludeVenv && n.some(t => this.fs.existsSync(e.resolvePaths(...t)))) {
            if (!b.FileSpec.isInPath(e, t)) {
              t.push(b.getFileSpec(this._configOptions.projectRoot, `${e}/**`));
            }
            this._console.info(`Auto-excluding ${e.toUserVisibleString()}`);
            return;
          }
          const {
            files: d,
            directories: c
          } = b.getFileSystemEntries(this.fs, e);
          for (const e of d) {
            if (b.FileSpec.matchIncludeFileSpec(o, t, e)) {
              i++;
              a.push(e);
            }
          }
          for (const e of c) {
            if (e.matchesRegex(o) || l) {
              if (!b.FileSpec.isInPath(e, t)) {
                p(e, o, l);
              }
            }
          }
        };
        const l = new Set();
        const p = (e, t, n) => {
          const a = b.tryRealpath(this.fs, e);
          if (a) {
            if (l.has(a.key)) {
              this._console.warn(`Skipping recursive symlink "${e}" -> "${a}"`);
            } else {
              l.add(a.key);
              try {
                o(e, t, n);
              } finally {
                l.delete(a.key);
              }
            }
          } else {
            this._console.warn(`Skipping broken link "${e}"`);
          }
        };
        e.forEach(e => {
          if (!b.FileSpec.isInPath(e.wildcardRoot, t)) {
            let t = false;
            const n = b.tryStat(this.fs, e.wildcardRoot);
            if (n == null ? undefined : n.isFile()) {
              a.push(e.wildcardRoot);
              t = true;
            } else {
              if (n == null ? undefined : n.isDirectory()) {
                p(e.wildcardRoot, e.regExp, e.hasDirectoryWildcard);
                t = true;
              }
            }
            if (!t) {
              this._console.error(`File or directory "${e.wildcardRoot.toUserVisibleString()}" does not exist.`);
            }
          }
        });
        return a;
      }
      _removeSourceFileWatchers() {
        if (this._sourceFileWatcher) {
          this._sourceFileWatcher.close();
          this._sourceFileWatcher = undefined;
        }
      }
      _updateSourceFileWatchers() {
        this._removeSourceFileWatchers();
        if (this._watchForSourceChanges && this._configOptions.include.length > 0) {
          const e = this._configOptions.include.map(e => e.wildcardRoot);
          try {
            if (this._verboseOutput) {
              this._console.info(`Adding fs watcher for directories:\n ${e.join('\n')}`);
            }
            const t = u.ignoredWatchEventFunction(e.map(e => e.getFilePath()));
            this._sourceFileWatcher = this.fs.createFileSystemWatcher(e, (e, n) => {
              if (!n) {
                return;
              }
              if (this._verboseOutput) {
                this._console.info(`SourceFile: Received fs event '${e}' for path '${n}'`);
              }
              if (t(n)) {
                return;
              }
              if (n.endsWith('.tmp') || n.endsWith('.git') || n.includes(A)) {
                return;
              }
              let a = v.Uri.file(n, this.serviceProvider, true);
              a = this.fs.realCasePath(a);
              const r = function (e, t, n, a, r) {
                const s = b.tryStat(e, r);
                if (a === 'add') {
                  if (!s) {
                    return;
                  }
                  return {
                    event: a,
                    isFile: s.isFile()
                  };
                }
                if (a === 'change') {
                  if (!s) {
                    const e = !!n.getSourceFile(r);
                    if (!e && !n.containsSourceFileIn(r)) {
                      return;
                    }
                    return {
                      event: 'unlink',
                      isFile: e
                    };
                  }
                  return {
                    event: a,
                    isFile: s.isFile()
                  };
                }
                t.warn(`Received unknown file change event: '${a}' for '${r}'`);
                return;
              }(this.fs, this._console, this._program, e, a);
              if (r && this._shouldHandleSourceFileWatchChanges(a, r.isFile)) {
                if (r.isFile && r.event === 'change') {
                  this._backgroundAnalysisProgram.markFilesDirty([a], false);
                  this._scheduleReanalysis(false);
                  return;
                }
                this.invalidateAndForceReanalysis(C.InvalidatedReason.SourceWatcherChanged);
                this._scheduleReanalysis(true);
              }
            });
          } catch {
            this._console.error(`Exception caught when installing fs watcher for:\n ${e.map(e => e.toUserVisibleString()).join('\n')}`);
          }
        }
      }
      _shouldHandleSourceFileWatchChanges(e, t) {
        if (t) {
          return !!b.hasPythonExtension(e) && !function (e) {
            const t = e.fileName;
            const n = t.split('.');
            if (n.length === 4 && n[3] === n[1] && n[2].length === 32) {
              return true;
            }
            return false;
          }(e) && (!!this.isTracked(e) || !!this._program.getSourceFileInfo(e));
        }
        if (!p.matchFileSpecs(this._program.configOptions, e, false)) {
          return false;
        }
        const n = e.getDirectory();
        return !!n.startsWith(this._configOptions.projectRoot) && (!!this.fs.existsSync(n.initPyUri) || !!this.fs.existsSync(n.initPyiUri)) || !!this._program.containsSourceFileIn(e);
      }
      _removeLibraryFileWatcher() {
        if (this._libraryFileWatcher) {
          this._libraryFileWatcher.close();
          this._libraryFileWatcher = undefined;
        }
      }
      _updateLibraryFileWatcher() {
        this._removeLibraryFileWatcher();
        if (!this._watchForLibraryChanges) {
          this._librarySearchUrisToWatch = undefined;
          return;
        }
        this._librarySearchUrisToWatch = k.findPythonSearchPaths(this.fs, this._backgroundAnalysisProgram.configOptions, this._backgroundAnalysisProgram.host, [], true, this._executionRootUri);
        const e = this._configOptions.getExecutionEnvironments().map(e => e.extraPaths.filter(e => !p.matchFileSpecs(this._configOptions, e, false))).flat();
        const t = b.deduplicateFolders([this._librarySearchUrisToWatch, e]);
        if (t.length > 0) {
          try {
            if (this._verboseOutput) {
              this._console.info(`Adding fs watcher for library directories:\n ${t.join('\n')}`);
            }
            const e = u.ignoredWatchEventFunction(t.map(e => e.getFilePath()));
            this._libraryFileWatcher = this.fs.createFileSystemWatcher(t, (n, a) => {
              if (!a) {
                return;
              }
              if (this._verboseOutput) {
                this._console.info(`LibraryFile: Received fs event '${n}' for path '${a}'`);
              }
              if (e(a)) {
                return;
              }
              const r = v.Uri.file(a, this.serviceProvider, true);
              if (!this._shouldHandleLibraryFileWatchChanges(r, t)) {
                return;
              }
              const s = n === 'change' && this.fs.existsSync(r);
              this._scheduleLibraryAnalysis(s);
            });
          } catch {
            this._console.error(`Exception caught when installing fs watcher for:\n ${t.map(e => e.toUserVisibleString()).join('\n')}`);
          }
        }
      }
      _shouldHandleLibraryFileWatchChanges(e, t) {
        if (this._program.getSourceFileInfo(e)) {
          return true;
        }
        let n;
        for (const a of t) {
          if (e.isChild(a) && (!n || n.getPathLength() < a.getPathLength())) {
            n = a;
          }
        }
        if (!n) {
          return true;
        }
        const a = n.getPathComponents();
        const r = e.getPathComponents();
        for (let e = a.length; e < r.length; e++) {
          if (r[e].startsWith('.')) {
            return false;
          }
        }
        return true;
      }
      _clearLibraryReanalysisTimer() {
        var e;
        var t;
        var n;
        if (this._libraryReanalysisTimer) {
          clearTimeout(this._libraryReanalysisTimer);
          this._libraryReanalysisTimer = undefined;
          const a = (e = this._backgroundAnalysisProgram) === null || e === undefined ? undefined : e.libraryUpdated();
          if ((n = (t = this.options.libraryReanalysisTimeProvider) === null || t === undefined ? undefined : t.libraryUpdated) !== null && n !== undefined) {
            n.call(t, a);
          }
        }
      }
      _scheduleLibraryAnalysis(e) {
        if (this._disposed) {
          return;
        }
        this._clearLibraryReanalysisTimer();
        const t = this.options.libraryReanalysisTimeProvider;
        const n = t == null ? undefined : t();
        if (n) {
          this._pendingLibraryChanges.changesOnly = this._pendingLibraryChanges.changesOnly && e;
          this._libraryReanalysisTimer = setTimeout(() => {
            var e;
            var n;
            this._clearLibraryReanalysisTimer();
            this.invalidateAndForceReanalysis(this._pendingLibraryChanges.changesOnly ? C.InvalidatedReason.LibraryWatcherContentOnlyChanged : C.InvalidatedReason.LibraryWatcherChanged);
            this._scheduleReanalysis(false);
            if ((n = (e = t).libraryReanalysisStarted) !== null && n !== undefined) {
              n.call(e);
            }
            this._pendingLibraryChanges.changesOnly = true;
          }, n);
        }
      }
      _removeConfigFileWatcher() {
        if (this._configFileWatcher) {
          this._configFileWatcher.close();
          this._configFileWatcher = undefined;
        }
      }
      _updateConfigFileWatcher() {
        this._removeConfigFileWatcher();
        if (this._watchForConfigChanges) {
          if (this._primaryConfigFileUri) {
            this._configFileWatcher = this.fs.createFileSystemWatcher(this._extendedConfigFileUris, e => {
              if (this._verboseOutput) {
                this._console.info(`Received fs event '${e}' for config file`);
              }
              this._scheduleReloadConfigFile();
            });
          } else {
            if (!this._executionRootUri.isEmpty()) {
              this._configFileWatcher = this.fs.createFileSystemWatcher([this._executionRootUri], (e, t) => {
                if (t && (e === 'add' || e === 'change')) {
                  if (g.getFileName(t) === y.configFileName) {
                    if (this._verboseOutput) {
                      this._console.info(`Received fs event '${e}' for config file`);
                    }
                    if (this._commandLineOptions) {
                      this.setOptions(this._commandLineOptions);
                    }
                  }
                }
              });
            }
          }
        }
      }
      _clearReloadConfigTimer() {
        if (this._reloadConfigTimer) {
          clearTimeout(this._reloadConfigTimer);
          this._reloadConfigTimer = undefined;
        }
      }
      _scheduleReloadConfigFile() {
        this._clearReloadConfigTimer();
        this._reloadConfigTimer = setTimeout(() => {
          this._clearReloadConfigTimer();
          this._reloadConfigFile();
        }, 100);
      }
      _reloadConfigFile() {
        this._updateConfigFileWatcher();
        if (this._primaryConfigFileUri) {
          this._console.info(`Reloading configuration file at ${this._primaryConfigFileUri.toUserVisibleString()}`);
          const e = this._backgroundAnalysisProgram.host;
          const t = this._getConfigOptions(e, this._commandLineOptions);
          this._backgroundAnalysisProgram.setConfigOptions(t);
          this.applyConfigOptions(e);
        }
      }
      _clearReanalysisTimer() {
        if (this._analyzeTimer) {
          clearTimeout(this._analyzeTimer);
          this._analyzeTimer = undefined;
        }
      }
      _scheduleReanalysis(e) {
        var t;
        var n;
        if (this._disposed || !((t = this._commandLineOptions) === null || t === undefined ? undefined : t.languageServerSettings.enableAmbientAnalysis)) {
          return;
        }
        if (e) {
          this._requireTrackedFileUpdate = true;
        }
        if ((n = this._backgroundAnalysisCancellationSource) !== null && n !== undefined) {
          n.cancel();
        }
        this._clearReanalysisTimer();
        const a = Date.now() - this._lastUserInteractionTime;
        const r = Math.max(250 - a, 5);
        this._analyzeTimer = setTimeout(() => {
          this._analyzeTimer = undefined;
          if (this._requireTrackedFileUpdate) {
            this._updateTrackedFileList(false);
          }
          this._backgroundAnalysisCancellationSource = this.cancellationProvider.createCancellationTokenSource();
          this.runAnalysis(this._backgroundAnalysisCancellationSource.token);
        }, r);
      }
      _reportConfigParseError() {
        if (this._onCompletionCallback) {
          this._onCompletionCallback({
            diagnostics: [],
            filesInProgram: 0,
            requiringAnalysisCount: {
              files: 0,
              cells: 0
            },
            checkingOnlyOpenFiles: true,
            fatalErrorOccurred: false,
            configParseErrorOccurred: true,
            elapsedTime: 0,
            reason: 'analysis'
          });
        }
      }
    }
    exports.AnalyzerService = D;
  },
  39045: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.findPyprojectTomlFileHereOrUp = function (e, t) {
      return r.forEachAncestorDirectory(t, t => s(e, t));
    };
    exports.findPyprojectTomlFile = s;
    exports.findConfigFileHereOrUp = function (e, t) {
      return r.forEachAncestorDirectory(t, t => i(e, t));
    };
    exports.findConfigFile = i;
    const a = require(4883);
    const r = require(5884);
    function s(e, t) {
      const n = t.resolvePaths(a.pyprojectTomlName);
      if (e.existsSync(n)) {
        return e.realCasePath(n);
      }
    }
    function i(e, t) {
      const n = t.resolvePaths(a.configFileName);
      if (e.existsSync(n)) {
        return e.realCasePath(n);
      }
    }
  },
  53266: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SourceFile = exports.IPythonMode = exports.maxSourceFileSize = undefined;
    const i = require(28167);
    const o = require(91426);
    const l = require(58147);
    const p = require(12522);
    const d = require(25075);
    const c = require(48281);
    const u = require(11479);
    const m = require(65880);
    const y = require(36316);
    const g = require(51862);
    const h = require(54010);
    const f = require(56814);
    const T = require(71745);
    require(23070);
    const v = __importStar(require(89740));
    const b = require(88754);
    const _ = require(95418);
    const C = require(71582);
    const I = require(67703);
    const k = require(85114);
    const w = require(96941);
    const S = require(49969);
    const A = __importStar(require(26687));
    const x = require(15157);
    const P = require(56798);
    const D = __importStar(require(22415));
    const N = require(25454);
    const F = require(22519);
    var E;
    exports.maxSourceFileSize = 52428800;
    (function (e) {
      e[e.None = 0] = 'None';
      e[e.CellDocs = 1] = 'CellDocs';
    })(E || (exports.IPythonMode = E = {}));
    let M = 1;
    class O {
      constructor() {
        this.diagnosticVersion = 0;
        this.fileContentsVersion = 0;
        this.lastFileContentLength = undefined;
        this.lastFileContentHash = undefined;
        this.analyzedFileContentsVersion = -1;
        this.parseTreeNeedsCleaning = false;
        this.isBindingInProgress = false;
        this.parseDiagnostics = [];
        this.commentDiagnostics = [];
        this.bindDiagnostics = [];
        this.checkerDiagnostics = [];
        this.taskListDiagnostics = [];
        this.typeIgnoreLines = new Map();
        this.pyrightIgnoreLines = new Map();
        this.accumulatedDiagnostics = [];
        this.circularDependencies = [];
        this.noCircularDependencyConfirmed = false;
        this.isBindingNeeded = true;
        this.isCheckingNeeded = true;
        this.isFileDeleted = false;
      }
      debugPrint() {
        var e;
        var t;
        var n;
        var a;
        var r;
        var s;
        var i;
        var o;
        var l;
        var p;
        var d;
        var c;
        var u;
        return `WritableData: \n diagnosticVersion=${this.diagnosticVersion}, \n noCircularDependencyConfirmed=${this.noCircularDependencyConfirmed}, \n isBindingNeeded=${this.isBindingNeeded},\n isBindingInProgress=${this.isBindingInProgress},\n isCheckingNeeded=${this.isCheckingNeeded},\n isFileDeleted=${this.isFileDeleted},\n hitMaxImportDepth=${this.hitMaxImportDepth},\n parseTreeNeedsCleaning=${this.parseTreeNeedsCleaning},\n fileContentsVersion=${this.fileContentsVersion},\n analyzedFileContentsVersion=${this.analyzedFileContentsVersion},\n clientDocumentVersion=${this.clientDocumentVersion},\n lastFileContentLength=${this.lastFileContentLength},\n lastFileContentHash=${this.lastFileContentHash},\n typeIgnoreAll=${this.typeIgnoreAll},\n imports=${(e = this.imports) === null || e === undefined ? undefined : e.length},\n builtinsImport=${(t = this.builtinsImport) === null || t === undefined ? undefined : t.importName},\n circularDependencies=${(n = this.circularDependencies) === null || n === undefined ? undefined : n.length},\n parseDiagnostics=${(a = this.parseDiagnostics) === null || a === undefined ? undefined : a.length},\n commentDiagnostics=${(r = this.commentDiagnostics) === null || r === undefined ? undefined : r.length},\n bindDiagnostics=${(s = this.bindDiagnostics) === null || s === undefined ? undefined : s.length},\n checkerDiagnostics=${(i = this.checkerDiagnostics) === null || i === undefined ? undefined : i.length},\n taskListDiagnostics=${(o = this.taskListDiagnostics) === null || o === undefined ? undefined : o.length},\n accumulatedDiagnostics=${(l = this.accumulatedDiagnostics) === null || l === undefined ? undefined : l.length},\n typeIgnoreLines=${(p = this.typeIgnoreLines) === null || p === undefined ? undefined : p.size},\n pyrightIgnoreLines=${(d = this.pyrightIgnoreLines) === null || d === undefined ? undefined : d.size},\n checkTime=${this.checkTime},\n clientDocumentContents=${(c = this.clientDocumentContents) === null || c === undefined ? undefined : c.length},\n parseResults=${(u = this.parserOutput) === null || u === undefined ? undefined : u.parseTree.length}`;
      }
    }
    exports.SourceFile = class {
      constructor(e, t, n, a, r, s, o, l, c) {
        this.serviceProvider = e;
        this._diagnosticRuleSet = p.getBasicDiagnosticRuleSet();
        this._ipythonMode = E.None;
        this.fileSystem = e.get(T.ServiceKeys.fs);
        this._console = o || new d.StandardConsole();
        this._writableData = new O();
        this._editMode = s;
        this._uri = t;
        this._fileId = this._makeFileId(t);
        this._moduleName = n;
        this._isStubFile = t.hasExtension('.pyi');
        this._isThirdPartyImport = a;
        this._isThirdPartyPyTypedPresent = r;
        const u = t.fileName;
        this._isTypingStubFile = this._isStubFile && (this._uri.pathEndsWith('stdlib/typing.pyi') || u === 'typing_extensions.pyi');
        this._isTypingExtensionsStubFile = this._isStubFile && u === 'typing_extensions.pyi';
        this._isTypeshedStubFile = this._isStubFile && this._uri.pathEndsWith('stdlib/_typeshed/__init__.pyi');
        this._isBuiltInStubFile = false;
        if (this._isStubFile && (this._uri.pathEndsWith('stdlib/collections/__init__.pyi') || this._uri.pathEndsWith('stdlib/asyncio/futures.pyi') || this._uri.pathEndsWith('stdlib/asyncio/tasks.pyi') || this._uri.pathEndsWith('stdlib/builtins.pyi') || this._uri.pathEndsWith('stdlib/_importlib_modulespec.pyi') || this._uri.pathEndsWith('stdlib/dataclasses.pyi') || this._uri.pathEndsWith('stdlib/abc.pyi') || this._uri.pathEndsWith('stdlib/enum.pyi') || this._uri.pathEndsWith('stdlib/queue.pyi') || this._uri.pathEndsWith('stdlib/types.pyi') || this._uri.pathEndsWith('stdlib/warnings.pyi'))) {
          this._isBuiltInStubFile = true;
        }
        this._logTracker = l ?? new g.LogTracker(o, i.isMainThread ? 'FG' : 'BG');
        this._ipythonMode = c ?? E.None;
      }
      getIPythonMode() {
        return this._ipythonMode;
      }
      getUri() {
        return this._uri;
      }
      getModuleName() {
        if (this._moduleName) {
          return this._moduleName;
        } else {
          return h.stripFileExtension(this._uri.fileName);
        }
      }
      setModuleName(e) {
        this._moduleName = e;
      }
      getDiagnosticVersion() {
        return this._writableData.diagnosticVersion;
      }
      isStubFile() {
        return this._isStubFile;
      }
      isTypingStubFile() {
        return this._isTypingStubFile;
      }
      isThirdPartyPyTypedPresent() {
        return this._isThirdPartyPyTypedPresent;
      }
      getDiagnostics(e, t) {
        if (this._writableData.diagnosticVersion !== t) {
          return this._writableData.accumulatedDiagnostics;
        }
      }
      getImports() {
        return this._writableData.imports || [];
      }
      getBuiltinsImport() {
        return this._writableData.builtinsImport;
      }
      getModuleSymbolTable() {
        return this._writableData.moduleSymbolTable;
      }
      getCheckTime() {
        return this._writableData.checkTime;
      }
      restore() {
        if (this._preEditData) {
          const e = this._writableData.clientDocumentContents;
          this._writableData = this._preEditData;
          this._preEditData = undefined;
          return e;
        }
      }
      didContentsChangeOnDisk() {
        if (this._writableData.clientDocumentContents) {
          return false;
        }
        if (this._writableData.lastFileContentLength === undefined) {
          return false;
        }
        try {
          if (!this.fileSystem.existsSync(this._uri)) {
            return true;
          }
          {
            const e = this.fileSystem.readFileSync(this._uri, 'utf8');
            if (e.length !== this._writableData.lastFileContentLength) {
              return true;
            }
            if (v.hashString(e) !== this._writableData.lastFileContentHash) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
        return false;
      }
      dropParseAndBindInfo() {
        this._fireFileDirtyEvent();
        this._writableData.parserOutput = undefined;
        this._writableData.tokenizerLines = undefined;
        this._writableData.tokenizerOutput = undefined;
        this._writableData.parsedFileContents = undefined;
        this._writableData.moduleSymbolTable = undefined;
        this._writableData.isBindingNeeded = true;
      }
      markDirty() {
        this._writableData.fileContentsVersion++;
        this._writableData.noCircularDependencyConfirmed = false;
        this._writableData.isCheckingNeeded = true;
        this._writableData.isBindingNeeded = true;
        this._writableData.moduleSymbolTable = undefined;
        this._fireFileDirtyEvent();
      }
      markReanalysisRequired(e) {
        this._writableData.isCheckingNeeded = true;
        this._writableData.noCircularDependencyConfirmed = false;
        if (this._writableData.parserOutput && (this._writableData.parserOutput.containsWildcardImport || A.getDunderAllInfo(this._writableData.parserOutput.parseTree) !== undefined || e)) {
          this._writableData.parseTreeNeedsCleaning = true;
          this._writableData.isBindingNeeded = true;
          this._writableData.moduleSymbolTable = undefined;
        }
      }
      getFileContentsVersion() {
        return this._writableData.fileContentsVersion;
      }
      getClientVersion() {
        return this._writableData.clientDocumentVersion;
      }
      getOpenFileContents() {
        return this._writableData.clientDocumentContents;
      }
      getFileContent() {
        const e = this.getOpenFileContents();
        if (e !== undefined) {
          return e;
        }
        try {
          const e = this.fileSystem.statSync(this._uri);
          if (e.size > exports.maxSourceFileSize) {
            this._console.error(`File length of "${this._uri}" is ${e.size} which exceeds the maximum supported file size of ${exports.maxSourceFileSize}`);
            throw new Error('File larger than max');
          }
          return this.fileSystem.readFileSync(this._uri, 'utf8');
        } catch (e) {
          return;
        }
      }
      setClientVersion(e, t) {
        this._cachePreEditState();
        if (e === null) {
          this._writableData.clientDocumentVersion = undefined;
          this._writableData.clientDocumentContents = undefined;
          this._writableData.tokenizerOutput = undefined;
        } else {
          this._writableData.clientDocumentVersion = e;
          this._writableData.clientDocumentContents = t;
          const n = v.hashString(t);
          if (t.length !== this._writableData.lastFileContentLength || n !== this._writableData.lastFileContentHash) {
            this.markDirty();
          }
          this._writableData.lastFileContentLength = t.length;
          this._writableData.lastFileContentHash = n;
          this._writableData.isFileDeleted = false;
        }
      }
      prepareForClose() {
        this._fireFileDirtyEvent();
      }
      isFileDeleted() {
        return this._writableData.isFileDeleted;
      }
      isParseRequired() {
        return !this._writableData.parserOutput || this._writableData.analyzedFileContentsVersion !== this._writableData.fileContentsVersion;
      }
      isBindingRequired() {
        return !this._writableData.isBindingInProgress && (!!this.isParseRequired() || this._writableData.isBindingNeeded);
      }
      isCheckingRequired() {
        return this._writableData.isCheckingNeeded;
      }
      getParseResults() {
        var e;
        if (this.isParseRequired()) {
          return;
        }
        c.assert(this._writableData.parserOutput !== undefined && this._writableData.parsedFileContents !== undefined);
        const t = (e = this._writableData.tokenizerOutput) !== null && e !== undefined ? e : this._tokenizeContents(this._writableData.parsedFileContents);
        return {
          parserOutput: this._writableData.parserOutput,
          tokenizerOutput: t,
          text: this._writableData.parsedFileContents
        };
      }
      getParserOutput() {
        if (!this.isParseRequired()) {
          c.assert(this._writableData.parserOutput !== undefined);
          return this._writableData.parserOutput;
        }
      }
      addCircularDependency(e, t) {
        let n = false;
        if (this._writableData.circularDependencies.length < 4) {
          if (!this._writableData.circularDependencies.some(e => e.isEqual(t))) {
            this._writableData.circularDependencies.push(t);
            n = true;
          }
        }
        if (n) {
          this._recomputeDiagnostics(e);
        }
      }
      setNoCircularDependencyConfirmed() {
        this._writableData.noCircularDependencyConfirmed = true;
      }
      isNoCircularDependencyConfirmed() {
        return !this.isParseRequired() && this._writableData.noCircularDependencyConfirmed;
      }
      setHitMaxImportDepth(e) {
        this._writableData.hitMaxImportDepth = e;
      }
      parse(e, t, n) {
        return this._logTracker.log(`parsing: ${this._getPathForLogging(this._uri)}`, a => {
          if (!this.isParseRequired()) {
            a.suppress();
            return false;
          }
          const r = this.createDiagnosticSink();
          let s = this.getOpenFileContents();
          if (s === undefined) {
            try {
              const e = C.timingStats.readFileTime.totalTime;
              C.timingStats.readFileTime.timeOperation(() => {
                s = n ?? this.getFileContent();
                if (s === undefined) {
                  throw new Error('Can\'t get file content');
                }
                this._writableData.lastFileContentLength = s.length;
                this._writableData.lastFileContentHash = v.hashString(s);
              });
              a.add(`fs read ${C.timingStats.readFileTime.totalTime - e}ms`);
            } catch (e) {
              r.addError('Source file could not be read', b.getEmptyRange());
              s = '';
              if (!this.fileSystem.existsSync(this._uri)) {
                this._writableData.isFileDeleted = true;
              }
            }
          }
          try {
            const n = this._parseFile(e, this._uri, s, this._ipythonMode, r);
            c.assert(n !== undefined && n.tokenizerOutput !== undefined);
            this._writableData.parserOutput = n.parserOutput;
            this._writableData.tokenizerLines = n.tokenizerOutput.lines;
            this._writableData.parsedFileContents = s;
            this._writableData.typeIgnoreLines = n.tokenizerOutput.typeIgnoreLines;
            this._writableData.typeIgnoreAll = n.tokenizerOutput.typeIgnoreAll;
            this._writableData.pyrightIgnoreLines = n.tokenizerOutput.pyrightIgnoreLines;
            if (this._writableData.clientDocumentContents !== undefined) {
              this._writableData.tokenizerOutput = n.tokenizerOutput;
            }
            const a = e.findExecEnvironment(this._uri);
            C.timingStats.resolveImportsTime.timeOperation(() => {
              const s = this._resolveImports(t, n.parserOutput.importedModules, a);
              this._writableData.imports = s.imports;
              this._writableData.builtinsImport = s.builtinsImportResult;
              this._writableData.parseDiagnostics = r.fetchAndClear();
              this._writableData.taskListDiagnostics = [];
              this._addTaskListDiagnostics(e.taskListTokens, n.tokenizerOutput, this._writableData.taskListDiagnostics);
            });
            const i = e.strict.find(e => this._uri.matchesRegex(e.regExp)) !== undefined;
            const o = [];
            this._diagnosticRuleSet = D.getFileLevelDirectives(n.tokenizerOutput.tokens, n.tokenizerOutput.lines, a.diagnosticRuleSet, i, o);
            this._writableData.commentDiagnostics = [];
            o.forEach(e => {
              this._writableData.commentDiagnostics.push(new u.Diagnostic(0, e.message, f.convertTextRangeToRange(e.range, n.tokenizerOutput.lines)));
            });
          } catch (e) {
            const t = (e.stack ? e.stack.toString() : undefined) || (typeof e.message == 'string' ? e.message : undefined) || JSON.stringify(e);
            this._console.error(I.LocMessage.internalParseError().format({
              file: this.getUri().toUserVisibleString(),
              message: t
            }));
            this._writableData.parsedFileContents = '';
            this._writableData.parserOutput = {
              parseTree: k.ModuleNode.create({
                start: 0,
                length: 0
              }),
              importedModules: [],
              futureImports: new Set(),
              containsWildcardImport: false,
              typingSymbolAliases: new Map()
            };
            this._writableData.tokenizerLines = new _.TextRangeCollection([]);
            this._writableData.tokenizerOutput = {
              tokens: new _.TextRangeCollection([]),
              lines: this._writableData.tokenizerLines,
              typeIgnoreAll: undefined,
              typeIgnoreLines: new Map(),
              pyrightIgnoreLines: new Map(),
              predominantEndOfLineSequence: '\n',
              hasPredominantTabSequence: false,
              predominantTabSequence: '    ',
              predominantSingleQuoteCharacter: '\''
            };
            this._writableData.imports = undefined;
            this._writableData.builtinsImport = undefined;
            const n = this.createDiagnosticSink();
            n.addError(I.LocMessage.internalParseError().format({
              file: this.getUri().toUserVisibleString(),
              message: t
            }), b.getEmptyRange());
            this._writableData.parseDiagnostics = n.fetchAndClear();
            this._writableData.taskListDiagnostics = n.fetchAndClear();
          }
          this._writableData.analyzedFileContentsVersion = this._writableData.fileContentsVersion;
          this._writableData.isBindingNeeded = true;
          this._writableData.isCheckingNeeded = true;
          this._writableData.parseTreeNeedsCleaning = false;
          this._writableData.hitMaxImportDepth = undefined;
          this._recomputeDiagnostics(e);
          return true;
        });
      }
      bind(e, t, n, a) {
        c.assert(!this.isParseRequired(), 'Bind called before parsing');
        c.assert(this.isBindingRequired(), 'Bind called unnecessarily');
        c.assert(!this._writableData.isBindingInProgress, 'Bind called while binding in progress');
        c.assert(this._writableData.parserOutput !== undefined, 'Parse results not available');
        return this._logTracker.log(`binding: ${this._getPathForLogging(this._uri)}`, () => {
          try {
            C.timingStats.bindTime.timeOperation(() => {
              this._cleanParseTreeIfRequired();
              const r = this._buildFileInfo(e, this._writableData.parsedFileContents, t, n, a);
              A.setFileInfo(this._writableData.parserOutput.parseTree, r);
              const s = new x.Binder(r, e.indexGenerationMode);
              this._writableData.isBindingInProgress = true;
              s.bindModule(this._writableData.parserOutput.parseTree);
              if (e.internalTestMode) {
                new F.TestWalker().walk(this._writableData.parserOutput.parseTree);
              }
              this._writableData.bindDiagnostics = r.diagnosticSink.fetchAndClear();
              const i = A.getScope(this._writableData.parserOutput.parseTree);
              c.assert(i !== undefined, 'Module scope not returned by binder');
              this._writableData.moduleSymbolTable = i.symbolTable;
            });
          } catch (e) {
            const t = (e.stack ? e.stack.toString() : undefined) || (typeof e.message == 'string' ? e.message : undefined) || JSON.stringify(e);
            this._console.error(I.LocMessage.internalBindError().format({
              file: this.getUri().toUserVisibleString(),
              message: t
            }));
            const n = this.createDiagnosticSink();
            n.addError(I.LocMessage.internalBindError().format({
              file: this.getUri().toUserVisibleString(),
              message: t
            }), b.getEmptyRange());
            this._writableData.bindDiagnostics = n.fetchAndClear();
          } finally {
            this._writableData.isBindingInProgress = false;
          }
          this._writableData.isCheckingNeeded = true;
          this._writableData.isBindingNeeded = false;
          this._recomputeDiagnostics(e);
        });
      }
      check(e, t, n, a, r) {
        c.assert(!this.isParseRequired(), `Check called before parsing: state=${this._writableData.debugPrint()}`);
        c.assert(!this.isBindingRequired(), `Check called before binding: state=${this._writableData.debugPrint()}`);
        c.assert(!this._writableData.isBindingInProgress, 'Check called while binding in progress');
        c.assert(this.isCheckingRequired(), 'Check called unnecessarily');
        c.assert(this._writableData.parserOutput !== undefined, 'Parse results not available');
        return this._logTracker.log(`checking: ${this._getPathForLogging(this._uri)}`, () => {
          try {
            C.timingStats.typeCheckerTime.timeOperation(() => {
              const e = new C.Duration();
              new P.Checker(t, n, this._writableData.parserOutput, a, r).check();
              this._writableData.isCheckingNeeded = false;
              const s = A.getFileInfo(this._writableData.parserOutput.parseTree);
              this._writableData.checkerDiagnostics = s.diagnosticSink.fetchAndClear();
              this._writableData.checkTime = e.getDurationInMilliseconds();
            });
          } catch (e) {
            if (!o.OperationCanceledException.is(e)) {
              const t = (e.stack ? e.stack.toString() : undefined) || (typeof e.message == 'string' ? e.message : undefined) || JSON.stringify(e);
              this._console.error(I.LocMessage.internalTypeCheckingError().format({
                file: this.getUri().toUserVisibleString(),
                message: t
              }));
              const n = this.createDiagnosticSink();
              n.addError(I.LocMessage.internalTypeCheckingError().format({
                file: this.getUri().toUserVisibleString(),
                message: t
              }), b.getEmptyRange());
              this._writableData.checkerDiagnostics = n.fetchAndClear();
              this._writableData.isCheckingNeeded = false;
            }
            throw e;
          } finally {
            this._writableData.circularDependencies = [];
            this._recomputeDiagnostics(e);
          }
        });
      }
      test_enableIPythonMode(e) {
        this._ipythonMode = e ? E.CellDocs : E.None;
      }
      createDiagnosticSink() {
        return new y.DiagnosticSink();
      }
      createTextRangeDiagnosticSink(e) {
        return new y.TextRangeDiagnosticSink(e);
      }
      _makeFileId(e) {
        let t = e.fileNameWithoutExtensions;
        if (t.length > 8) {
          t = t.substring(t.length - 8);
        }
        return `${t}/${(M++).toString()}`;
      }
      _recomputeDiagnostics(e) {
        this._writableData.diagnosticVersion++;
        let t = true;
        if (this._isThirdPartyImport) {
          t = false;
        }
        let n = [];
        l.appendArray(n, this._writableData.parseDiagnostics);
        l.appendArray(n, this._writableData.commentDiagnostics);
        l.appendArray(n, this._writableData.bindDiagnostics);
        l.appendArray(n, this._writableData.checkerDiagnostics);
        l.appendArray(n, this._writableData.taskListDiagnostics);
        const a = n;
        const r = new Map(this._writableData.typeIgnoreLines);
        const s = new Map(this._writableData.pyrightIgnoreLines);
        if (this._diagnosticRuleSet.enableTypeIgnoreComments && this._writableData.typeIgnoreLines.size > 0) {
          n = n.filter(e => {
            if (e.category !== 3 && e.category !== 4 && e.category !== 5) {
              for (let t = e.range.start.line; t <= e.range.end.line; t++) {
                if (this._writableData.typeIgnoreLines.has(t)) {
                  r.delete(t);
                  return false;
                }
              }
            }
            return true;
          });
        }
        if (this._writableData.pyrightIgnoreLines.size > 0) {
          n = n.filter(e => {
            if (e.category !== 3 && e.category !== 4 && e.category !== 5) {
              for (let t = e.range.start.line; t <= e.range.end.line; t++) {
                const n = this._writableData.pyrightIgnoreLines.get(t);
                if (n) {
                  if (!n.rulesList) {
                    s.delete(t);
                    return false;
                  }
                  const a = e.getRule();
                  if (!a) {
                    return true;
                  }
                  if (n.rulesList.find(e => e.text === a)) {
                    const e = s.get(t);
                    if (e == null ? undefined : e.rulesList) {
                      const n = e.rulesList.filter(e => e.text !== a);
                      if (n.length === 0) {
                        s.delete(t);
                      } else {
                        s.set(t, {
                          range: e.range,
                          rulesList: n
                        });
                      }
                    }
                    return false;
                  }
                  return true;
                }
              }
            }
            return true;
          });
        }
        const i = [];
        if (this._diagnosticRuleSet.reportUnnecessaryTypeIgnoreComment !== 'none' && !this._writableData.isCheckingNeeded) {
          const e = u.convertLevelToCategory(this._diagnosticRuleSet.reportUnnecessaryTypeIgnoreComment);
          const t = a.filter(e => e.category === 0 || e.category === 1 || e.category === 2);
          const n = e => a.find(t => t.category === 4 && t.range.start.line <= e.start.line && t.range.end.line >= e.end.line);
          if (t.length === 0 && this._writableData.typeIgnoreAll !== undefined) {
            const t = this._writableData.typeIgnoreAll.range.start;
            const a = t + this._writableData.typeIgnoreAll.range.length;
            const r = f.convertOffsetsToRange(t, a, this._writableData.tokenizerLines);
            if (!n(r) && this._diagnosticRuleSet.enableTypeIgnoreComments) {
              const t = new u.Diagnostic(e, I.LocMessage.unnecessaryTypeIgnore(), r);
              t.setRule(m.DiagnosticRule.reportUnnecessaryTypeIgnoreComment);
              i.push(t);
            }
          }
          r.forEach(t => {
            if (this._writableData.tokenizerLines) {
              const a = t.range.start;
              const r = a + t.range.length;
              const s = f.convertOffsetsToRange(a, r, this._writableData.tokenizerLines);
              if (!n(s) && this._diagnosticRuleSet.enableTypeIgnoreComments) {
                const t = new u.Diagnostic(e, I.LocMessage.unnecessaryTypeIgnore(), s);
                t.setRule(m.DiagnosticRule.reportUnnecessaryTypeIgnoreComment);
                i.push(t);
              }
            }
          });
          s.forEach(t => {
            if (this._writableData.tokenizerLines) {
              if (t.rulesList) {
                t.rulesList.forEach(t => {
                  const a = t.range.start;
                  const r = a + t.range.length;
                  const s = f.convertOffsetsToRange(a, r, this._writableData.tokenizerLines);
                  if (!n(s)) {
                    const n = new u.Diagnostic(e, I.LocMessage.unnecessaryPyrightIgnoreRule().format({
                      name: t.text
                    }), s);
                    n.setRule(m.DiagnosticRule.reportUnnecessaryTypeIgnoreComment);
                    i.push(n);
                  }
                });
              } else {
                const a = t.range.start;
                const r = a + t.range.length;
                const s = f.convertOffsetsToRange(a, r, this._writableData.tokenizerLines);
                if (!n(s)) {
                  const t = new u.Diagnostic(e, I.LocMessage.unnecessaryTypeIgnore(), s);
                  t.setRule(m.DiagnosticRule.reportUnnecessaryTypeIgnoreComment);
                  i.push(t);
                }
              }
            }
          });
        }
        if (this._diagnosticRuleSet.reportImportCycles !== 'none' && this._writableData.circularDependencies.length > 0) {
          const e = u.convertLevelToCategory(this._diagnosticRuleSet.reportImportCycles);
          this._writableData.circularDependencies.forEach(t => {
            const a = new u.Diagnostic(e, I.LocMessage.importCycleDetected() + '\n' + t.getPaths().map(e => `  ${e.toUserVisibleString()}`).join('\n'), b.getEmptyRange());
            a.setRule(m.DiagnosticRule.reportImportCycles);
            n.push(a);
          });
        }
        if (this._writableData.hitMaxImportDepth !== undefined) {
          n.push(new u.Diagnostic(0, I.LocMessage.importDepthExceeded().format({
            depth: this._writableData.hitMaxImportDepth
          }), b.getEmptyRange()));
        }
        if (this._diagnosticRuleSet.enableTypeIgnoreComments && this._writableData.typeIgnoreAll !== undefined) {
          n = n.filter(e => e.category !== 0 && e.category !== 1 && e.category !== 2);
        }
        n = n.concat(i);
        if (!t) {
          n = n.filter(e => e.category === 3 || e.category === 4 || e.category === 5);
        }
        if (e.ignore.find(e => this._uri.matchesRegex(e.regExp))) {
          n = [];
        }
        this._writableData.accumulatedDiagnostics = n;
      }
      _cachePreEditState() {
        if (this._editMode.isEditMode && !this._preEditData) {
          this._preEditData = this._writableData;
          this._writableData = new O();
        }
      }
      _addTaskListDiagnostics(e, t, n) {
        if (e && e.length !== 0 && n) {
          for (let a = 0; a < t.tokens.count; a++) {
            const r = t.tokens.getItemAt(a);
            if (r.comments && r.comments.length !== 0) {
              for (const a of r.comments) {
                for (const r of e) {
                  const e = `^[\\s]*${r.text}([\\s]*\$|[\\W]+)`;
                  if (!RegExp(e, 'i').test(a.value)) {
                    continue;
                  }
                  let s = a.start;
                  s += a.value.toLowerCase().indexOf(r.text.toLowerCase());
                  const i = b.TextRange.getEnd(a);
                  const o = f.convertOffsetsToRange(s, i, t.lines);
                  n.push(new u.Diagnostic(6, a.value.trim(), o, r.priority));
                }
              }
            }
          }
        }
      }
      _buildFileInfo(e, t, n, a, r) {
        c.assert(this._writableData.parserOutput !== undefined, 'Parse results not available');
        return {
          importLookup: n,
          futureImports: r,
          builtinsScope: a,
          diagnosticSink: this.createTextRangeDiagnosticSink(this._writableData.tokenizerLines),
          executionEnvironment: e.findExecEnvironment(this._uri),
          diagnosticRuleSet: this._diagnosticRuleSet,
          lines: this._writableData.tokenizerLines,
          typingSymbolAliases: this._writableData.parserOutput.typingSymbolAliases,
          definedConstants: e.defineConstant,
          fileId: this._fileId,
          fileUri: this._uri,
          moduleName: this.getModuleName(),
          isStubFile: this._isStubFile,
          isTypingStubFile: this._isTypingStubFile,
          isTypingExtensionsStubFile: this._isTypingExtensionsStubFile,
          isTypeshedStubFile: this._isTypeshedStubFile,
          isBuiltInStubFile: this._isBuiltInStubFile,
          isInPyTypedPackage: this._isThirdPartyPyTypedPresent,
          ipythonMode: this._ipythonMode,
          accessedSymbolSet: new Set()
        };
      }
      _cleanParseTreeIfRequired() {
        if (this._writableData.parserOutput && this._writableData.parseTreeNeedsCleaning) {
          new N.ParseTreeCleanerWalker(this._writableData.parserOutput.parseTree).clean();
          this._writableData.parseTreeNeedsCleaning = false;
        }
      }
      _resolveImports(e, t, n) {
        const a = [];
        const r = (t, r = false) => {
          const s = e.resolveImport(this._uri, n, {
            leadingDots: 0,
            nameParts: t,
            importedSymbols: undefined
          });
          if (!r || s.isImportFound) {
            if (s.resolvedUris.length === 0 || s.resolvedUris[0] !== this._uri) {
              a.push(s);
              return s;
            } else {
              return undefined;
            }
          }
        };
        let s;
        if (!this._isThirdPartyImport && !this._isStubFile) {
          s = r(['__builtins__'], true);
        }
        if (!s) {
          s = r(['builtins']);
        }
        for (const r of t) {
          const t = e.resolveImport(this._uri, n, {
            leadingDots: r.leadingDots,
            nameParts: r.nameParts,
            importedSymbols: r.importedSymbols
          });
          a.push(t);
          if (r.nameParts.length === r.nameNode.d.nameParts.length) {
            A.setImportInfo(r.nameNode, t);
          } else {
            c.assert(r.nameParts.length > 0);
            c.assert(r.nameParts.length - 1 < r.nameNode.d.nameParts.length);
            A.setImportInfo(r.nameNode.d.nameParts[r.nameParts.length - 1], t);
          }
        }
        return {
          imports: a,
          builtinsImportResult: s
        };
      }
      _getPathForLogging(e) {
        return g.getPathForLogging(this.fileSystem, e);
      }
      _parseFile(e, t, n, a, r) {
        var s;
        const i = e.findExecEnvironment(t);
        const o = new w.ParseOptions();
        o.ipythonMode = a;
        if (t.pathEndsWith('pyi')) {
          o.isStubFile = true;
        }
        o.pythonVersion = i.pythonVersion;
        o.skipFunctionAndClassBody = (s = e.indexGenerationMode) !== null && s !== undefined && s;
        return new w.Parser().parseSourceFile(n, o, r);
      }
      _tokenizeContents(e) {
        const t = new S.Tokenizer().tokenize(e);
        if (this._writableData.clientDocumentContents !== undefined) {
          this._writableData.tokenizerOutput = t;
          this._writableData.tokenizerLines = t.lines;
        }
        return t;
      }
      _fireFileDirtyEvent() {
        var e;
        if ((e = this.serviceProvider.tryGet(T.ServiceKeys.stateMutationListeners)) !== null && e !== undefined) {
          e.forEach(e => {
            var t;
            try {
              if ((t = e.onFileDirty) !== null && t !== undefined) {
                t.call(e, this._uri);
              }
            } catch (e) {
              const t = this.serviceProvider.tryGet(T.ServiceKeys.console);
              if (t) {
                t.error(`State mutation listener exception: ${e.message}`);
              }
            }
          });
        }
      }
    };
  },
  67238: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SourceFileInfo = undefined;
    exports.SourceFileInfo = class {
      constructor(e, t, n, a, r, s = {}) {
        this.sourceFile = e;
        this.isTypeshedFile = t;
        this.isThirdPartyImport = n;
        this.isThirdPartyPyTypedPresent = a;
        this._editModeTracker = r;
        this.isCreatedInEditMode = this._editModeTracker.isEditMode;
        this._writableData = this._createWriteableData(s);
        this._cachePreEditState();
      }
      get diagnosticsVersion() {
        return this._writableData.diagnosticsVersion;
      }
      get builtinsImport() {
        return this._writableData.builtinsImport;
      }
      get chainedSourceFile() {
        return this._writableData.chainedSourceFile;
      }
      get effectiveFutureImports() {
        return this._writableData.effectiveFutureImports;
      }
      get isTracked() {
        return this._writableData.isTracked;
      }
      get isOpenByClient() {
        return this._writableData.isOpenByClient;
      }
      get imports() {
        return this._writableData.imports;
      }
      get importedBy() {
        return this._writableData.importedBy;
      }
      get shadows() {
        return this._writableData.shadows;
      }
      get shadowedBy() {
        return this._writableData.shadowedBy;
      }
      set diagnosticsVersion(e) {
        this._cachePreEditState();
        this._writableData.diagnosticsVersion = e;
      }
      set builtinsImport(e) {
        this._cachePreEditState();
        this._writableData.builtinsImport = e;
      }
      set chainedSourceFile(e) {
        this._cachePreEditState();
        this._writableData.chainedSourceFile = e;
      }
      set effectiveFutureImports(e) {
        this._cachePreEditState();
        this._writableData.effectiveFutureImports = e;
      }
      set isTracked(e) {
        this._cachePreEditState();
        this._writableData.isTracked = e;
      }
      set isOpenByClient(e) {
        this._cachePreEditState();
        this._writableData.isOpenByClient = e;
      }
      mutate(e) {
        this._cachePreEditState();
        e(this._writableData);
      }
      restore() {
        if (this._preEditData) {
          this._writableData = this._preEditData;
          this._preEditData = undefined;
          this.sourceFile.dropParseAndBindInfo();
        }
        return this.sourceFile.restore();
      }
      _cachePreEditState() {
        if (this._editModeTracker.isEditMode && !this._preEditData) {
          this._preEditData = this._writableData;
          this._writableData = this._cloneWriteableData(this._writableData);
          this._editModeTracker.addMutatedFiles(this);
        }
      }
      _createWriteableData(e) {
        var t;
        var n;
        return {
          isTracked: (t = e.isTracked) !== null && t !== undefined && t,
          isOpenByClient: (n = e.isOpenByClient) !== null && n !== undefined && n,
          builtinsImport: e.builtinsImport,
          chainedSourceFile: e.chainedSourceFile,
          diagnosticsVersion: e.diagnosticsVersion,
          effectiveFutureImports: e.effectiveFutureImports,
          imports: [],
          importedBy: [],
          shadows: [],
          shadowedBy: []
        };
      }
      _cloneWriteableData(e) {
        return {
          isTracked: e.isTracked,
          isOpenByClient: e.isOpenByClient,
          builtinsImport: e.builtinsImport,
          chainedSourceFile: e.chainedSourceFile,
          diagnosticsVersion: e.diagnosticsVersion,
          effectiveFutureImports: e.effectiveFutureImports,
          imports: e.imports.slice(),
          importedBy: e.importedBy.slice(),
          shadows: e.shadows.slice(),
          shadowedBy: e.shadowedBy.slice()
        };
      }
    };
  },
  3433: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.isUserCode = function (e) {
      return !!e && e.isTracked && !e.isThirdPartyImport && !e.isTypeshedFile;
    };
    exports.collectImportedByCells = function (e, t) {
      (function (e) {
        for (const t of e.getSourceFileInfoList()) {
          if (t.sourceFile.getIPythonMode() === s.IPythonMode.CellDocs) {
            e.getParserOutput(t.sourceFile.getUri());
            e.handleMemoryHighUsage();
          }
        }
      })(e);
      const n = new Set();
      i(t, n);
      return n;
    };
    exports.verifyNoCyclesInChainedFiles = function (e, t) {
      var n;
      var s;
      let i = t.chainedSourceFile;
      if (!i) {
        return;
      }
      const o = new Set([t.sourceFile.getUri().key]);
      while (i) {
        const t = i.sourceFile.getUri().key;
        if (o.has(t)) {
          a.fail((s = (n = e.serviceProvider.tryGet(r.ServiceKeys.debugInfoInspector)) === null || n === undefined ? undefined : n.getCycleDetail(e, i)) !== null && s !== undefined ? s : `Found a cycle in implicit imports files for ${t}`);
        }
        o.add(t);
        i = i.chainedSourceFile;
      }
    };
    exports.createChainedByList = function (e, t) {
      var n;
      var s;
      const i = new Map();
      for (const t of e.getSourceFileInfoList()) {
        if (t.chainedSourceFile) {
          i.set(t.chainedSourceFile, t);
        }
      }
      const o = new Set();
      const l = [t];
      let p = t;
      while (p) {
        if (o.has(p)) {
          a.fail((s = (n = e.serviceProvider.tryGet(r.ServiceKeys.debugInfoInspector)) === null || n === undefined ? undefined : n.getCycleDetail(e, p)) !== null && s !== undefined ? s : 'detected a cycle in chained files');
        }
        o.add(p);
        p = i.get(p);
        if (p) {
          l.push(p);
        }
      }
      return l;
    };
    const a = require(48281);
    const r = require(71745);
    const s = require(53266);
    function i(e, t) {
      e.importedBy.forEach(e => {
        if (!t.has(e)) {
          t.add(e);
          i(e, t);
        }
      });
    }
  },
  3113: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SourceMapper = undefined;
    exports.isStubFile = h;
    const i = __importStar(require(26687));
    const o = __importStar(require(41557));
    const l = require(58147);
    const p = require(34455);
    const d = require(48281);
    const c = require(28445);
    const u = require(3433);
    const m = require(15132);
    const y = require(92324);
    const g = require(21024);
    function h(e) {
      return e.lastExtension === '.pyi';
    }
    exports.SourceMapper = class {
      constructor(e, t, n, a, r, s, i, o, l) {
        this._importResolver = e;
        this._execEnv = t;
        this._evaluator = n;
        this._fileBinder = a;
        this._boundSourceGetter = r;
        this._mapCompiled = s;
        this._preferStubs = i;
        this._fromFile = o;
        this._cancelToken = l;
      }
      findModules(e) {
        var t;
        return (this._isStubThatShouldBeMappedToImplementation(e) ? this._getBoundSourceFilesFromStubFile(e) : [(t = this._boundSourceGetter(e)) === null || t === undefined ? undefined : t.sourceFile]).filter(p.isDefined).map(e => {
          var t;
          if ((t = e.getParserOutput()) === null || t === undefined) {
            return undefined;
          } else {
            return t.parseTree;
          }
        }).filter(p.isDefined);
      }
      getModuleNode(e) {
        var t;
        var n;
        if ((n = (t = this._boundSourceGetter(e)) === null || t === undefined ? undefined : t.sourceFile.getParserOutput()) === null || n === undefined) {
          return undefined;
        } else {
          return n.parseTree;
        }
      }
      findDeclarations(e) {
        if (c.isClassDeclaration(e)) {
          return this._findClassOrTypeAliasDeclarations(e);
        } else {
          if (c.isFunctionDeclaration(e)) {
            return this._findFunctionOrTypeAliasDeclarations(e);
          } else {
            if (c.isVariableDeclaration(e)) {
              return this._findVariableDeclarations(e);
            } else {
              if (c.isParamDeclaration(e)) {
                return this._findParamDeclarations(e);
              } else {
                if (c.isSpecialBuiltInClassDeclaration(e)) {
                  return this._findSpecialBuiltInClassDeclarations(e);
                } else {
                  return [];
                }
              }
            }
          }
        }
      }
      findDeclarationsByType(e, t, n = false) {
        const a = [];
        this._addClassTypeDeclarations(e, t, a, new Set(), n);
        return a;
      }
      findClassDeclarationsByType(e, t) {
        return this.findDeclarationsByType(e, t).filter(e => c.isClassDeclaration(e)).map(e => e);
      }
      findFunctionDeclarations(e) {
        return this._findFunctionOrTypeAliasDeclarations(e).filter(e => c.isFunctionDeclaration(e)).map(e => e);
      }
      isUserCode(e) {
        return u.isUserCode(this._boundSourceGetter(e));
      }
      getNextFileName(e) {
        const t = e.stripExtension();
        let n = 1;
        let a = t.addExtension(`_${n}.py`);
        while (this.isUserCode(a) && n < 1000) {
          n += 1;
          a = t.addExtension(`_${n}.py`);
        }
        return a;
      }
      _findSpecialBuiltInClassDeclarations(e, t = new Set()) {
        if (e.node.d.valueExpr.nodeType === 38) {
          const n = e.node.d.valueExpr.d.value;
          return this._getBoundSourceFilesFromStubFile(e.uri).flatMap(e => this._findClassDeclarationsByName(e, n, t));
        }
        return [];
      }
      _findClassOrTypeAliasDeclarations(e, t = new Set()) {
        const n = this._getFullClassName(e.node);
        return this._getBoundSourceFilesFromStubFile(e.uri).flatMap(e => this._findClassDeclarationsByName(e, n, t));
      }
      _findFunctionOrTypeAliasDeclarations(e, t = new Set()) {
        const n = e.node.d.name.d.value;
        const a = this._getBoundSourceFilesFromStubFile(e.uri);
        if (e.isMethod) {
          const r = o.getEnclosingClass(e.node);
          if (r === undefined) {
            return [];
          }
          const s = this._getFullClassName(r);
          return a.flatMap(e => this._findMethodDeclarationsByName(e, s, n, t));
        }
        return a.flatMap(e => this._findFunctionDeclarationsByName(e, n, t));
      }
      _findVariableDeclarations(e, t = new Set()) {
        if (e.node.nodeType !== 38) {
          return [];
        }
        const n = e.node.d.value;
        const a = this._getBoundSourceFilesFromStubFile(e.uri);
        const r = o.getEnclosingClass(e.node);
        if (r) {
          const e = this._getFullClassName(r);
          return a.flatMap(a => this._findFieldDeclarationsByName(a, e, n, t));
        }
        return a.flatMap(e => this._findVariableDeclarationsByName(e, n, t));
      }
      _findParamDeclarations(e) {
        var t;
        const n = [];
        if (!e.node.d.name) {
          return n;
        }
        const a = o.getEnclosingFunction(e.node);
        if (!a) {
          return n;
        }
        const r = (t = this._evaluator.getDeclInfoForNameNode(a.d.name)) === null || t === undefined ? undefined : t.decls;
        if (!r) {
          return n;
        }
        const s = new Set();
        for (const t of r) {
          if (c.isFunctionDeclaration(t)) {
            for (const a of this._findFunctionOrTypeAliasDeclarations(t, s)) {
              l.appendArray(n, this._lookUpSymbolDeclarations(a.node, e.node.d.name.d.value).filter(e => c.isParamDeclaration(e)).map(e => e));
            }
          }
        }
        return n;
      }
      _findMemberDeclarationsByName(e, t, n, a, r) {
        const s = [];
        const i = this._findClassDeclarationsByName(e, t, r);
        for (const e of i.filter(e => c.isClassDeclaration(e)).map(e => e)) {
          const t = this._evaluator.getTypeOfClass(e.node);
          if (!t) {
            continue;
          }
          const i = y.lookUpClassMember(t.classType, n);
          if (i) {
            for (const e of i.symbol.getDeclarations()) {
              a(e, r, s);
            }
          }
        }
        return s;
      }
      _findFieldDeclarationsByName(e, t, n, a) {
        let r = [];
        const s = `@${e.getUri()}/c/${t}/v/${n}`;
        if (!a.has(s)) {
          a.add(s);
          r = this._findMemberDeclarationsByName(e, t, n, (e, t, n) => {
            if (c.isVariableDeclaration(e)) {
              if (this._isStubThatShouldBeMappedToImplementation(e.uri)) {
                for (const a of this._findVariableDeclarations(e, t)) {
                  if (c.isVariableDeclaration(a)) {
                    n.push(a);
                  }
                }
              } else {
                n.push(e);
              }
            }
          }, a);
          a.delete(s);
        }
        return r;
      }
      _findMethodDeclarationsByName(e, t, n, a) {
        let r = [];
        const s = `@${e.getUri()}/c/${t}/f/${n}`;
        if (!a.has(s)) {
          a.add(s);
          r = this._findMemberDeclarationsByName(e, t, n, (e, t, n) => {
            if (c.isFunctionDeclaration(e)) {
              if (this._isStubThatShouldBeMappedToImplementation(e.uri)) {
                l.appendArray(n, this._findFunctionOrTypeAliasDeclarations(e, t));
              } else {
                n.push(e);
              }
            }
          }, a);
          a.delete(s);
        }
        return r;
      }
      _findVariableDeclarationsByName(e, t, n) {
        var a;
        const r = [];
        const s = `@${e.getUri()}/v/${t}`;
        if (n.has(s)) {
          return r;
        }
        n.add(s);
        const i = (a = e.getParserOutput()) === null || a === undefined ? undefined : a.parseTree;
        if (!i) {
          return r;
        }
        const o = this._lookUpSymbolDeclarations(i, t);
        if (o.length === 0) {
          this._addDeclarationsFollowingWildcardImports(i, t, r, n);
        } else {
          for (const e of o) {
            this._addVariableDeclarations(e, r, n);
          }
        }
        n.delete(s);
        return r;
      }
      _findFunctionDeclarationsByName(e, t, n) {
        var a;
        const r = [];
        const s = `@${e.getUri()}/f/${t}`;
        if (n.has(s)) {
          return r;
        }
        n.add(s);
        const i = (a = e.getParserOutput()) === null || a === undefined ? undefined : a.parseTree;
        if (!i) {
          return r;
        }
        const o = this._lookUpSymbolDeclarations(i, t);
        if (o.length === 0) {
          this._addDeclarationsFollowingWildcardImports(i, t, r, n);
        } else {
          for (const e of o) {
            this._addClassOrFunctionDeclarations(e, r, n);
          }
        }
        n.delete(s);
        return r;
      }
      _findClassDeclarationsByName(e, t, n) {
        var a;
        let r = [];
        const s = (a = e.getParserOutput()) === null || a === undefined ? undefined : a.parseTree;
        if (s) {
          let a = t.split('.');
          if (a.length > 0) {
            r = this._findClassDeclarations(e, a[0], s, n);
            a = a.slice(1);
          }
          for (const t of a) {
            r = r.flatMap(a => this._findClassDeclarations(e, t, a.node, n));
          }
        }
        return r;
      }
      _findClassDeclarations(e, t, n, a) {
        const r = [];
        const s = `@${e.getUri()}[${n.start}]${t}`;
        if (a.has(s)) {
          return r;
        }
        a.add(s);
        const i = this._lookUpSymbolDeclarations(n, t);
        if (i.length === 0 && n.nodeType === 36) {
          this._addDeclarationsFollowingWildcardImports(n, t, r, a);
        } else {
          for (const e of i) {
            this._addClassOrFunctionDeclarations(e, r, a);
          }
        }
        a.delete(s);
        return r;
      }
      _addVariableDeclarations(e, t, n) {
        if (c.isVariableDeclaration(e)) {
          if (this._isStubThatShouldBeMappedToImplementation(e.uri)) {
            l.appendArray(t, this._findVariableDeclarations(e, n));
          } else {
            t.push(e);
          }
        } else {
          if (c.isAliasDeclaration(e)) {
            const a = this._evaluator.resolveAliasDeclaration(e, true);
            if (a) {
              if (c.isVariableDeclaration(a)) {
                this._addVariableDeclarations(a, t, n);
              } else {
                if (c.isClassDeclaration(a) || c.isFunctionDeclaration(a)) {
                  this._addClassOrFunctionDeclarations(a, t, n);
                }
              }
            }
          }
        }
      }
      _addClassOrFunctionDeclarations(e, t, n) {
        var a;
        if (c.isClassDeclaration(e)) {
          if (this._isStubThatShouldBeMappedToImplementation(e.uri)) {
            l.appendArray(t, this._findClassOrTypeAliasDeclarations(e, n));
          } else {
            t.push(e);
          }
        } else {
          if (c.isSpecialBuiltInClassDeclaration(e)) {
            t.push(e);
          } else {
            if (c.isFunctionDeclaration(e)) {
              if (this._isStubThatShouldBeMappedToImplementation(e.uri)) {
                l.appendArray(t, this._findFunctionOrTypeAliasDeclarations(e, n));
              } else {
                t.push(e);
              }
            } else {
              if (c.isAliasDeclaration(e)) {
                const a = this._handleSpecialBuiltInModule(e);
                const r = this._evaluator.resolveAliasDeclaration(a, true);
                if (r && !c.isAliasDeclaration(r)) {
                  this._addClassOrFunctionDeclarations(r, t, n);
                }
              } else {
                if (c.isVariableDeclaration(e)) {
                  this._addVariableDeclarations(e, t, n);
                  const r = (a = e.typeAliasName) !== null && a !== undefined ? a : e.node;
                  const s = this._evaluator.getType(r);
                  if (!s) {
                    return;
                  }
                  if (g.isFunction(s) && s.shared.declaration) {
                    this._addClassOrFunctionDeclarations(s.shared.declaration, t, n);
                  } else {
                    if (g.isOverloaded(s)) {
                      const e = g.OverloadedType.getOverloads(s);
                      for (const a of e.map(e => e.shared.declaration).filter(p.isDefined)) {
                        this._addClassOrFunctionDeclarations(a, t, n);
                      }
                    } else {
                      if (g.isInstantiableClass(s)) {
                        this._addClassTypeDeclarations(e.uri, s, t, n);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      _handleSpecialBuiltInModule(e) {
        if (!e.uri.isEmpty() || !e.node) {
          return e;
        }
        if (e.moduleName !== 'io' && e.moduleName !== 'collections') {
          return e;
        }
        const t = this._importResolver.getTypeshedStdLibPath(this._execEnv);
        if (!t) {
          return e;
        }
        const n = o.getFileInfoFromNode(e.node);
        if (!n) {
          return e;
        }
        const a = t.combinePaths(function () {
          var t;
          switch (e.node.nodeType) {
            case 24:
            case 25:
              return e.node.d.module;
            case 26:
              d.assert(((t = e.node.parent) === null || t === undefined ? undefined : t.nodeType) === 25);
              return e.node.parent.d.module;
            default:
              return d.assertNever(e.node);
          }
        }().d.nameParts.map(e => e.d.value).join('.') + '.pyi');
        const r = this._getSourceFiles(a, n.fileUri);
        if (r.length === 0) {
          return e;
        }
        const s = {
          ...e
        };
        s.uri = r[0].getUri();
        return s;
      }
      _addClassTypeDeclarations(e, t, n, a, r = false) {
        var s;
        var i;
        var o;
        const p = r && ((s = t.props) === null || s === undefined ? undefined : s.typeAliasInfo) ? t.props.typeAliasInfo.shared.fileUri : t.shared.fileUri;
        const d = this._getSourceFiles(p, undefined, e);
        const c = r && ((i = t.props) === null || i === undefined ? undefined : i.typeAliasInfo) ? t.props.typeAliasInfo.shared.fullName : t.shared.fullName;
        const u = r && ((o = t.props) === null || o === undefined ? undefined : o.typeAliasInfo) ? t.props.typeAliasInfo.shared.moduleName : t.shared.moduleName;
        const m = c.substring(u.length + 1);
        for (const e of d) {
          l.appendArray(n, this._findClassDeclarationsByName(e, m, a));
        }
      }
      _getSourceFiles(e, t, n) {
        const a = [];
        if (this._isStubThatShouldBeMappedToImplementation(e)) {
          l.appendArray(a, this._getBoundSourceFilesFromStubFile(e, t, n));
        } else {
          const t = this._boundSourceGetter(e);
          if (t) {
            a.push(t.sourceFile);
          }
        }
        return a;
      }
      _addDeclarationsFollowingWildcardImports(e, t, n, a) {
        var r;
        var s;
        const o = (r = i.getScope(e)) === null || r === undefined ? undefined : r.symbolTable;
        if (o) {
          for (const e of o.values()) {
            for (const r of e.getDeclarations()) {
              if (!c.isAliasDeclaration(r) || r.uri.isEmpty() || r.node.nodeType !== 25 || !r.node.d.isWildcardImport) {
                continue;
              }
              const e = `@${r.uri.key}/l/${t}`;
              if (a.has(e)) {
                continue;
              }
              a.add(e);
              const i = this._getSourceFiles(r.uri);
              for (const e of i) {
                const r = (s = e.getParserOutput()) === null || s === undefined ? undefined : s.parseTree;
                if (!r) {
                  continue;
                }
                const i = this._lookUpSymbolDeclarations(r, t);
                if (i.length === 0) {
                  this._addDeclarationsFollowingWildcardImports(r, t, n, a);
                } else {
                  for (const e of i) {
                    const t = this._evaluator.resolveAliasDeclaration(e, true);
                    if (t) {
                      if (c.isFunctionDeclaration(t) || c.isClassDeclaration(t)) {
                        this._addClassOrFunctionDeclarations(t, n, a);
                      } else {
                        if (c.isVariableDeclaration(t)) {
                          this._addVariableDeclarations(t, n, a);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      _lookUpSymbolDeclarations(e, t) {
        if (e === undefined) {
          return [];
        }
        const n = i.getScope(e);
        const a = n == null ? undefined : n.lookUpSymbol(t);
        const r = a == null ? undefined : a.getDeclarations();
        if (r != null) {
          return r;
        } else {
          return [];
        }
      }
      _getFullClassName(e) {
        const t = [];
        let n = e;
        while (n !== undefined) {
          t.push(n.d.name.d.value);
          n = o.getEnclosingClass(n);
        }
        return t.reverse().join('.');
      }
      _getBoundSourceFilesFromStubFile(e, t, n) {
        var a;
        return this._getSourcePathsFromStub(e, n ?? ((a = this._fromFile) === null || a === undefined ? undefined : a.sourceFile.getUri())).map(n => this._fileBinder(t ?? e, n)).filter(p.isDefined);
      }
      _getSourcePathsFromStub(e, t) {
        let n = this._importResolver.getSourceFilesFromStub(e, this._execEnv, this._mapCompiled);
        if (n.length > 0) {
          return n;
        }
        const a = this._getStubFileImportTree(e, t);
        for (let e = 0; e < a.length; e++) {
          n = this._importResolver.getSourceFilesFromStub(a[e], this._execEnv, this._mapCompiled);
          if (n.length > 0) {
            return n;
          }
        }
        return [];
      }
      _getStubFileImportTree(e, t) {
        if (t && this._isStubThatShouldBeMappedToImplementation(e)) {
          return m.buildImportTree(t, e, e => {
            const t = this._boundSourceGetter(e);
            if (t) {
              return t.importedBy.map(e => e.sourceFile.getUri());
            } else {
              return [];
            }
          }, this._cancelToken).filter(e => this._isStubThatShouldBeMappedToImplementation(e));
        } else {
          return [e];
        }
      }
      _isStubThatShouldBeMappedToImplementation(e) {
        if (this._preferStubs) {
          return false;
        }
        return !!h(e) && this._importResolver.getSourceFilesFromStub(e, this._execEnv, this._mapCompiled).every(t => t !== e);
      }
    };
  },
  15132: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.buildImportTree = function (e, t, n, s) {
      const i = new a();
      const o = r(e, t, n, [], i, s);
      if (o.length > 0) {
        return o;
      } else {
        return [t];
      }
    };
    const n = 1000;
    class a {
      constructor() {
        this.value = 0;
      }
    }
    function r(e, t, a, s, i, o) {
      if (i.value > n || o.isCancellationRequested) {
        return [];
      }
      i.value += 1;
      if (t.equals(e)) {
        if (s.length) {
          return s;
        } else {
          return [t];
        }
      }
      if (s.length > 1 && s.find(e => e.equals(t))) {
        return [];
      }
      const l = a(t);
      for (let n = 0; n < l.length && !o.isCancellationRequested; n++) {
        const p = r(e, l[n], a, [...s, t], i, o);
        if (p.length > 0) {
          return p;
        }
      }
      return [];
    }
  },
  28676: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.evaluateStaticBoolExpression = s;
    exports.evaluateStaticBoolLikeExpression = i;
    const a = require(12522);
    const r = require(63808);
    function s(e, t, n, d, c) {
      if (e.nodeType === 4) {
        return s(e.d.rightExpr, t, n, d, c);
      }
      if (e.nodeType === 55) {
        if (e.d.operator === 38) {
          const a = i(e.d.expr, t, n, d, c);
          if (a !== undefined) {
            return !a;
          }
        }
      } else {
        if (e.nodeType === 7) {
          if (e.d.operator === 37 || e.d.operator === 36) {
            const a = s(e.d.leftExpr, t, n, d, c);
            const r = s(e.d.rightExpr, t, n, d, c);
            if (a === undefined || r === undefined) {
              return;
            }
            if (e.d.operator === 37) {
              return a || r;
            } else {
              return a && r;
            }
          }
          if (p(e.d.leftExpr, c) && e.d.rightExpr.nodeType === 52) {
            const n = function (e) {
              if (e.d.items.length >= 2) {
                if (e.d.items[0].nodeType === 40 && !e.d.items[0].d.isImaginary && e.d.items[1].nodeType === 40 && !e.d.items[1].d.isImaginary) {
                  const t = e.d.items[0];
                  const n = e.d.items[1];
                  if (typeof t.d.value != 'number' || typeof n.d.value != 'number') {
                    return;
                  }
                  const a = t.d.value;
                  const s = n.d.value;
                  let i;
                  let o;
                  let l;
                  if (e.d.items.length >= 3 && e.d.items[2].nodeType === 40 && !e.d.items[2].d.isImaginary && typeof e.d.items[2].d.value == 'number') {
                    i = e.d.items[2].d.value;
                  }
                  if (e.d.items.length >= 4 && e.d.items[3].nodeType === 48 && e.d.items[3].d.strings.length === 1 && e.d.items[3].d.strings[0].nodeType === 49) {
                    o = e.d.items[3].d.strings[0].d.value;
                  }
                  if (e.d.items.length >= 5 && e.d.items[4].nodeType === 40 && !e.d.items[4].d.isImaginary && typeof e.d.items[4].d.value == 'number') {
                    l = e.d.items[4].d.value;
                  }
                  return r.PythonVersion.create(a, s, i, o, l);
                }
              } else {
                if (e.d.items.length === 1) {
                  const t = e.d.items[0];
                  if (typeof t.d.value == 'number') {
                    return r.PythonVersion.create(t.d.value, 0);
                  }
                }
              }
              return;
            }(e.d.rightExpr);
            return o(e.d.operator, t.pythonVersion, n);
          }
          if (e.d.leftExpr.nodeType === 27 && p(e.d.leftExpr.d.leftExpr, c) && e.d.leftExpr.d.items.length === 1 && !e.d.leftExpr.d.trailingComma && !e.d.leftExpr.d.items[0].d.name && e.d.leftExpr.d.items[0].d.argCategory === 0 && e.d.leftExpr.d.items[0].d.valueExpr.nodeType === 40 && !e.d.leftExpr.d.items[0].d.valueExpr.d.isImaginary && e.d.leftExpr.d.items[0].d.valueExpr.d.value === 0 && e.d.rightExpr.nodeType === 40 && e.d.rightExpr.d.isInteger && typeof e.d.rightExpr.d.value == 'number') {
            return o(e.d.operator, r.PythonVersion.create(t.pythonVersion.major, 0), r.PythonVersion.create(e.d.rightExpr.d.value, 0));
          }
          if (function (e, t = ['sys']) {
            if (e.nodeType === 35 && e.d.leftExpr.nodeType === 38 && e.d.member.d.value === 'platform' && t.some(t => t === e.d.leftExpr.d.value)) {
              return true;
            }
            return false;
          }(e.d.leftExpr, c) && e.d.rightExpr.nodeType === 48) {
            const n = e.d.rightExpr.d.strings.map(e => e.d.value).join('');
            const r = function (e) {
              if (e.pythonPlatform === a.PythonPlatform.Darwin) {
                return 'darwin';
              }
              if (e.pythonPlatform === a.PythonPlatform.Windows) {
                return 'win32';
              }
              if (e.pythonPlatform === a.PythonPlatform.Linux) {
                return 'linux';
              }
              return;
            }(t);
            return l(e.d.operator, r, n);
          }
          if (function (e) {
            if (e.nodeType === 35 && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'os' && e.d.member.d.value === 'name') {
              return true;
            }
            return false;
          }(e.d.leftExpr) && e.d.rightExpr.nodeType === 48) {
            const n = e.d.rightExpr.d.strings.map(e => e.d.value).join('');
            const r = function (e) {
              if (e.pythonPlatform === a.PythonPlatform.Darwin) {
                return 'posix';
              }
              if (e.pythonPlatform === a.PythonPlatform.Windows) {
                return 'nt';
              }
              if (e.pythonPlatform === a.PythonPlatform.Linux) {
                return 'posix';
              }
              return;
            }(t);
            if (r !== undefined) {
              return l(e.d.operator, r, n);
            }
          } else {
            if (e.d.rightExpr.nodeType === 48) {
              let t;
              if (e.d.leftExpr.nodeType === 38) {
                t = n.get(e.d.leftExpr.d.value);
              } else {
                if (e.d.leftExpr.nodeType === 35) {
                  t = n.get(e.d.leftExpr.d.member.d.value);
                }
              }
              if (t !== undefined && typeof t == 'string') {
                const n = e.d.rightExpr.d.strings.map(e => e.d.value).join('');
                return l(e.d.operator, t, n);
              }
            }
          }
        } else {
          if (e.nodeType === 14) {
            if (e.d.constType === 33) {
              return true;
            }
            if (e.d.constType === 15) {
              return false;
            }
          } else {
            if (e.nodeType === 38) {
              if (e.d.value === 'TYPE_CHECKING') {
                return true;
              }
              const t = n.get(e.d.value);
              if (t !== undefined) {
                return !!t;
              }
            } else {
              if (e.nodeType === 35) {
                if (d && e.d.member.d.value === 'TYPE_CHECKING' && e.d.leftExpr.nodeType === 38 && d.some(t => t === e.d.leftExpr.d.value)) {
                  return true;
                }
                const t = n.get(e.d.member.d.value);
                if (t !== undefined) {
                  return !!t;
                }
              }
            }
          }
        }
      }
    }
    function i(e, t, n, a, r) {
      return (e.nodeType !== 14 || e.d.constType !== 26) && s(e, t, n, a, r);
    }
    function o(e, t, n) {
      if (t !== undefined && n !== undefined) {
        if (e === 20) {
          return r.PythonVersion.isLessThan(t, n);
        }
        if (e === 21) {
          return r.PythonVersion.isLessOrEqualTo(t, n);
        }
        if (e === 15) {
          return r.PythonVersion.isGreaterThan(t, n);
        }
        if (e === 16) {
          return r.PythonVersion.isGreaterOrEqualTo(t, n);
        }
        if (e === 12) {
          return r.PythonVersion.isEqualTo(t, n);
        }
        if (e === 28) {
          return !r.PythonVersion.isEqualTo(t, n);
        }
      }
    }
    function l(e, t, n) {
      if (t !== undefined && n !== undefined) {
        if (e === 12) {
          return t === n;
        }
        if (e === 28) {
          return t !== n;
        }
      }
    }
    function p(e, t = ['sys']) {
      return e.nodeType === 35 && e.d.leftExpr.nodeType === 38 && e.d.member.d.value === 'version_info' && !!t.some(t => t === e.d.leftExpr.d.value);
    }
  },
  58253: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Symbol = exports.indeterminateSymbolId = undefined;
    const a = require(83760);
    let r = 1;
    exports.indeterminateSymbolId = 0;
    class s {
      constructor(e) {
        this.id = r++;
        this._flags = e;
      }
      static createWithType(e, t, n) {
        const a = new s(e);
        a._synthesizedTypeInfo = {
          type: t,
          node: n
        };
        return a;
      }
      isInitiallyUnbound() {
        return !!(this._flags & 1);
      }
      setIsExternallyHidden() {
        this._flags |= 2;
      }
      isExternallyHidden() {
        return !!(this._flags & 2);
      }
      setIsIgnoredForProtocolMatch() {
        this._flags |= 64;
      }
      isIgnoredForProtocolMatch() {
        return !!(this._flags & 64);
      }
      setIsClassMember() {
        this._flags |= 4;
      }
      isClassMember() {
        return !!(this._flags & 4);
      }
      setIsInstanceMember() {
        this._flags |= 8;
      }
      isInstanceMember() {
        return !!(this._flags & 8);
      }
      setIsClassVar() {
        this._flags |= 128;
      }
      isClassVar() {
        return !!(this._flags & 128);
      }
      setIsFinalVarInClassBody() {
        this._flags |= 8192;
      }
      isFinalVarInClassBody() {
        return !!(this._flags & 8192);
      }
      setIsInitVar() {
        this._flags |= 1024;
      }
      isInitVar() {
        return !!(this._flags & 1024);
      }
      setIsInDunderAll() {
        this._flags |= 256;
      }
      isInDunderAll() {
        return !!(this._flags & 256);
      }
      setIsPrivateMember() {
        this._flags |= 32;
      }
      isPrivateMember() {
        return !!(this._flags & 32);
      }
      setPrivatePyTypedImport() {
        this._flags |= 512;
      }
      isPrivatePyTypedImport() {
        return !!(this._flags & 512);
      }
      isNamedTupleMemberMember() {
        return !!(this._flags & 2048);
      }
      isIgnoredForOverrideChecks() {
        return !!(this._flags & 4096);
      }
      setTypingSymbolAlias(e) {
        this._typingSymbolAlias = e;
      }
      getTypingSymbolAlias() {
        return this._typingSymbolAlias;
      }
      addDeclaration(e) {
        if (this._declarations) {
          const t = this._declarations.findIndex(t => a.areDeclarationsSame(t, e));
          if (t < 0) {
            this._declarations.push(e);
            this._declarations.forEach(e => {
              if (e.type === 1 && e.typeAliasName) {
                delete e.typeAliasName;
              }
            });
          } else {
            const n = this._declarations[t];
            if (a.hasTypeForDeclaration(e)) {
              this._declarations[t] = e;
              if (n.type === 1 && e.type === 1 && !e.inferredTypeSource && n.inferredTypeSource) {
                e.inferredTypeSource = n.inferredTypeSource;
              }
            } else {
              if (e.type === 1 && n.type === 1) {
                if (e.isFinal) {
                  n.isFinal = true;
                }
                n.typeAliasName = e.typeAliasName;
                if (!n.inferredTypeSource && e.inferredTypeSource) {
                  n.inferredTypeSource = e.inferredTypeSource;
                }
              }
            }
          }
        } else {
          this._declarations = [e];
        }
      }
      hasDeclarations() {
        return !!this._declarations && this._declarations.length > 0;
      }
      getDeclarations() {
        if (this._declarations) {
          return this._declarations;
        } else {
          return [];
        }
      }
      hasTypedDeclarations() {
        return !!this._synthesizedTypeInfo || this.getDeclarations().some(e => a.hasTypeForDeclaration(e));
      }
      getTypedDeclarations() {
        return this.getDeclarations().filter(e => a.hasTypeForDeclaration(e));
      }
      getSynthesizedType() {
        return this._synthesizedTypeInfo;
      }
    }
    exports.Symbol = s;
  },
  12097: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.isPrivateName = s;
    exports.isProtectedName = i;
    exports.isPrivateOrProtectedName = o;
    exports.isDunderName = function (e) {
      return e.length > 4 && e.startsWith('__') && e.endsWith('__');
    };
    exports.isSingleDunderName = function (e) {
      return e.length > 2 && e.startsWith('_') && e.endsWith('_');
    };
    exports.isConstantName = l;
    exports.isTypeAliasName = p;
    exports.isPublicConstantOrTypeAlias = function (e) {
      return !o(e) && (l(e) || p(e));
    };
    const n = /^[A-Z0-9_]+$/;
    const a = /^[_]+$/;
    const r = /^_{0,2}[A-Z][A-Za-z0-9_]+$/;
    function s(e) {
      return e.length > 2 && e.startsWith('__') && !e.endsWith('__');
    }
    function i(e) {
      return e.length > 1 && e.startsWith('_') && !e.startsWith('__');
    }
    function o(e) {
      return s(e) || i(e);
    }
    function l(e) {
      return !!e.match(n) && !e.match(a);
    }
    function p(e) {
      return !!e.match(r);
    }
  },
  4064: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getLastTypedDeclarationForSymbol = function (e) {
      const t = e.getTypedDeclarations();
      if (t.length > 0) {
        return t[t.length - 1];
      }
      return;
    };
    exports.isTypedDictMemberAccessedThroughIndex = function (e) {
      const t = e.getTypedDeclarations();
      if (t.length > 0) {
        if (t[t.length - 1].type === 1) {
          return true;
        }
      }
      return false;
    };
    exports.isVisibleExternally = function (e) {
      return !e.isExternallyHidden() && !e.isPrivatePyTypedImport();
    };
    exports.isEffectivelyClassVar = function (e, t) {
      if (e.isClassVar()) {
        return true;
      }
      if (e.isFinalVarInClassBody()) {
        return !t;
      }
      return false;
    };
  },
  22519: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.NameTypeWalker = exports.TestWalker = undefined;
    const a = require(88744);
    const r = require(48281);
    const s = require(88754);
    const i = require(41557);
    class o extends a.ParseTreeWalker {
      constructor() {
        super();
      }
      visitNode(e) {
        const t = super.visitNode(e);
        this._verifyParentChildLinks(e, t);
        this._verifyChildRanges(e, t);
        return t;
      }
      _verifyParentChildLinks(e, t) {
        t.forEach(t => {
          if (t && t.parent !== e) {
            r.fail(`Child node ${t.nodeType} does not contain a reference to its parent ${e.nodeType}`);
          }
        });
      }
      _verifyChildRanges(e, t) {
        let n;
        const a = i.isCompliantWithNodeRangeRules(e);
        t.forEach(t => {
          if (t) {
            let i = false;
            if (!a) {
              switch (e.nodeType) {
                case 3:
                  if (t === e.d.annotationComment) {
                    i = true;
                  }
                  if (t.nodeType === 3) {
                    i = true;
                  }
                  break;
                case 48:
                  if (t === e.d.annotation) {
                    i = true;
                  }
                  break;
                case 1:
                  if (e.d.isNameSameAsValue) {
                    i = true;
                  }
                  break;
                default:
                  r.fail(`node ${e.nodeType} is not marked as not following range rules.`);
              }
            }
            if (!i) {
              if (t.start < e.start || s.TextRange.getEnd(t) > s.TextRange.getEnd(e)) {
                r.fail(`Child node ${t.nodeType} is not contained within its parent ${e.nodeType}`);
              }
              if (n && t.start < s.TextRange.getEnd(n)) {
                let t = n.nodeType === 62;
                if (e.nodeType === 1 && e.d.isNameSameAsValue) {
                  t = true;
                }
                if (!t) {
                  r.fail('Child node is not after previous child node');
                }
              }
              n = t;
            }
          }
        });
      }
    }
    exports.TestWalker = o;
    class l extends a.ParseTreeWalker {
      constructor(e) {
        super();
        this._evaluator = e;
      }
      visitName(e) {
        var t;
        var n;
        if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 26 && ((n = e.parent) === null || n === undefined ? undefined : n.nodeType) !== 24 && this._evaluator.isNodeReachable(e, undefined)) {
          this._evaluator.getType(e);
        }
        return true;
      }
    }
    exports.NameTypeWalker = l;
  },
  15794: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createTracePrinter = function (e) {
      function t(e, t = '\'') {
        if (e) {
          return `${t}${e}${t}`;
        } else {
          return '';
        }
      }
      e = e.sort((e, t) => e.key.localeCompare(t.key)).reverse();
      const n = /[\\/]/g;
      function a(t) {
        if (t) {
          if (d.Uri.is(t)) {
            for (const a of e) {
              if (t.isChild(a)) {
                const e = a.getRelativePath(t);
                return l.stripFileExtension(e).replace(n, '.');
              }
            }
            return t.toUserVisibleString();
          }
          if (t.nameParts) {
            return t.nameParts.join('.');
          }
        }
        return '';
      }
      function r(e) {
        var n;
        var a;
        var s;
        var i;
        var l;
        var p;
        var d;
        var c;
        var u;
        var m;
        if (e) {
          switch (e.category) {
            case 2:
              return `Any ${t((a = (n = e.props) === null || n === undefined ? undefined : n.typeAliasInfo) === null || a === undefined ? undefined : a.shared.fullName)}`;
            case 6:
              if (g.TypeBase.isInstantiable(e)) {
                return `Class '${e.shared.name}' (${e.shared.moduleName})`;
              } else {
                return `Object '${e.shared.name}' (${e.shared.moduleName})`;
              }
            case 4:
              return `Function '${e.shared.name}' (${e.shared.moduleName})`;
            case 7:
              return `Module '${e.priv.moduleName}' (${e.priv.moduleName})`;
            case 3:
              return `Never ${t((i = (s = e.props) === null || s === undefined ? undefined : s.typeAliasInfo) === null || i === undefined ? undefined : i.shared.fullName)}`;
            case 5:
              return `Overloaded [${g.OverloadedType.getOverloads(e).map(e => t(r(e), '"')).join(',')}]`;
            case 9:
              return `TypeVar '${e.shared.name}' ${t((p = (l = e.props) === null || l === undefined ? undefined : l.typeAliasInfo) === null || p === undefined ? undefined : p.shared.fullName)}`;
            case 0:
              return `Unbound ${t((c = (d = e.props) === null || d === undefined ? undefined : d.typeAliasInfo) === null || c === undefined ? undefined : c.shared.fullName)}`;
            case 8:
              return `Union [${e.priv.subtypes.map(e => t(r(e), '"')).join(',')}]`;
            case 1:
              return `Unknown ${t((m = (u = e.props) === null || u === undefined ? undefined : u.typeAliasInfo) === null || m === undefined ? undefined : m.shared.fullName)}`;
            default:
              o.assertNever(e);
          }
        }
        return '';
      }
      function s(e) {
        if (e) {
          switch (e.type) {
            case 8:
              return `Alias, ${f(e.node)} (${a(e.uri)})`;
            case 6:
              return `Class, ${f(e.node)} (${a(e.uri)})`;
            case 5:
              return `Function, ${f(e.node)} (${a(e.uri)})`;
            case 0:
              return `Intrinsic, ${f(e.node)} ${e.intrinsicType} (${a(e.uri)})`;
            case 2:
              return `Param, ${f(e.node)} (${a(e.uri)})`;
            case 3:
              return `TypeParam, ${f(e.node)} (${a(e.uri)})`;
            case 7:
              return `SpecialBuiltInClass, ${f(e.node)} (${a(e.uri)})`;
            case 1:
              return `Variable, ${f(e.node)} (${a(e.uri)})`;
            case 4:
              return `TypeAlias, ${f(e.node)} (${a(e.uri)})`;
            default:
              o.assertNever(e);
          }
        }
        return '';
      }
      function h(e) {
        while (e.nodeType !== 36 && e.parent) {
          e = e.parent;
        }
        if (e.nodeType === 36) {
          return u.getFileInfo(e);
        } else {
          return undefined;
        }
      }
      function f(e, n = false) {
        var r;
        if (!e) {
          return '';
        }
        let s = n ? `(${a((r = h(e)) === null || r === undefined ? undefined : r.fileUri)})` : '';
        const i = h(e);
        if (i == null ? undefined : i.lines) {
          const t = p.convertOffsetToPosition(e.start, i.lines);
          s += ` [${t.line + 1}:${t.character + 1}]`;
        }
        if (c.isExpressionNode(e)) {
          return `${t(function (e, t = 30) {
            if (e.length < t) {
              return e;
            } else {
              return e.substring(0, t) + ' <shortened> ';
            }
          }(m.printExpression(e)), '"')} ${s}`;
        }
        switch (e.nodeType) {
          case 24:
            return `importAs '${f(e.d.module)}' ${t(e.d.alias ? f(e.d.alias) : '')} ${s}`;
          case 25:
            return `importFrom [${e.d.imports.map(e => t(f(e), '"')).join(',')}]`;
          case 26:
            return `ImportFromAs '${f(e.d.name)}' ${t(e.d.alias ? f(e.d.alias) : '')} ${s}`;
          case 36:
            return `module ${s}`;
          case 10:
            return `class '${f(e.d.name)}' ${s}`;
          case 31:
            return `function '${f(e.d.name)}' ${s}`;
          case 37:
            return `moduleName '${e.d.nameParts.map(e => f(e)).join('.')}' ${s}`;
          case 1:
            return `argument '${e.d.name ? f(e.d.name) : 'N/A'}' ${s}`;
          case 41:
            return `parameter '${e.d.name ? f(e.d.name) : 'N/A'}' ${s}`;
          default:
            return `${m.printParseNodeType(e.nodeType)} ${s}`;
        }
      }
      return {
        print: function (e) {
          if (e) {
            if (function (e) {
              const t = e;
              return t && i.isNumber(t.nodeType);
            }(e)) {
              return f(e, true);
            } else {
              if (function (e) {
                const t = e;
                return t && i.isNumber(t.type) && d.Uri.is(t.uri) && i.isString(t.moduleName);
              }(e)) {
                return s(e);
              } else {
                if (e instanceof y.Symbol) {
                  if (t = e) {
                    if (t.hasDeclarations()) {
                      return `symbol ${s(t.getDeclarations()[0])}`;
                    } else {
                      return '<symbol>';
                    }
                  } else {
                    return '';
                  }
                } else {
                  if (function (e) {
                    const t = e;
                    return t && i.isNumber(t.category) && i.isNumber(t.flags);
                  }(e)) {
                    return r(e);
                  } else {
                    return '';
                  }
                }
              }
            }
          } else {
            return '';
          }
          var t;
        },
        printFileOrModuleName: a
      };
    };
    const i = require(34455);
    const o = require(48281);
    const l = require(54010);
    const p = require(56814);
    const d = require(27113);
    const c = require(85114);
    const u = __importStar(require(26687));
    const m = __importStar(require(41557));
    const y = require(58253);
    const g = require(21024);
  },
  63278: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.makeTupleObject = m;
    exports.getTypeOfTuple = function (e, t, n, i) {
      var o;
      if (n & 256 && ((o = t.parent) === null || o === undefined ? undefined : o.nodeType) !== 1) {
        const n = new a.DiagnosticAddendum();
        n.addMessage(s.LocAddendum.useTupleInstead());
        e.addDiagnostic(r.DiagnosticRule.reportInvalidTypeForm, s.LocMessage.tupleInAnnotation() + n.getString(), t);
        return {
          type: d.UnknownType.create()
        };
      }
      if (n & 128 && t.d.items.length === 0 && !i) {
        return {
          type: m(e, []),
          isEmptyTupleShorthand: true
        };
      }
      n &= -393;
      let l;
      let p = i == null ? undefined : i.expectedType;
      let u = i && d.isAny(i.expectedType);
      if (i && d.isUnion(i.expectedType)) {
        let a;
        c.doForEachSubtype(i.expectedType, r => {
          if (d.isAny(r)) {
            u = true;
          }
          if (!a) {
            const s = e.useSpeculativeMode(t, () => y(e, t, n, c.makeInferenceContext(r)));
            if (s && e.assignType(r, s.type)) {
              a = r;
            }
          }
        }, true);
        p = a;
      }
      if (p) {
        const a = y(e, t, n, c.makeInferenceContext(p));
        if (a && !a.typeErrors) {
          return a;
        }
        l = a == null ? undefined : a.expectedTypeDiagAddendum;
      }
      const h = g(e, t, n);
      if (u) {
        h.type = d.AnyType.create();
      }
      return {
        ...h,
        expectedTypeDiagAddendum: l
      };
    };
    exports.getTypeOfTupleWithContext = y;
    exports.getTypeOfTupleInferred = g;
    exports.assignTupleTypeArgs = function (e, t, n, a, r, i, o) {
      var l;
      var p;
      const u = [...((l = t.priv.tupleTypeArgs) !== null && l !== undefined ? l : [])];
      const m = [...((p = n.priv.tupleTypeArgs) !== null && p !== undefined ? p : [])];
      if (!h(e, u, m, i)) {
        const e = u.some(e => e.isUnbounded || d.isTypeVarTuple(e.type));
        if (m.some(e => e.isUnbounded || d.isTypeVarTuple(e.type))) {
          if (e) {
            if (a != null) {
              a.addMessage(s.LocAddendum.tupleSizeIndeterminateSrcDest().format({
                expected: u.length - 1
              }));
            }
          } else {
            if (a != null) {
              a.addMessage(s.LocAddendum.tupleSizeIndeterminateSrc().format({
                expected: u.length
              }));
            }
          }
        } else {
          if (e) {
            if (a != null) {
              a.addMessage(s.LocAddendum.tupleSizeMismatchIndeterminateDest().format({
                expected: u.length - 1,
                received: m.length
              }));
            }
          } else {
            if (a != null) {
              a.addMessage(s.LocAddendum.tupleSizeMismatch().format({
                expected: u.length,
                received: m.length
              }));
            }
          }
        }
        return false;
      }
      for (let t = 0; t < m.length; t++) {
        const n = a == null ? undefined : a.createAddendum();
        const l = u[t].type;
        const p = m[t].type;
        if (d.isTypeVarTuple(l) && l.priv.isUnpacked && !l.priv.isInUnion && c.isTupleGradualForm(p)) {
          return true;
        }
        if (!e.assignType(l, p, n == null ? undefined : n.createAddendum(), r, i, o)) {
          if (n) {
            n.addMessage(s.LocAddendum.tupleEntryTypeMismatch().format({
              entry: t + 1
            }));
          }
          return false;
        }
      }
      return true;
    };
    exports.adjustTupleTypeArgs = h;
    exports.getSlicedTupleType = function (e, t, n) {
      if (n.d.stepValue || !t.priv.tupleTypeArgs) {
        return;
      }
      const a = t.priv.tupleTypeArgs;
      const r = f(e, n.d.startValue, 0, a);
      const s = f(e, n.d.endValue, a.length, a);
      if (r === undefined || s === undefined || s < r) {
        return;
      }
      const i = a.slice(r, s);
      return d.ClassType.cloneAsInstance(c.specializeTupleClass(t, i));
    };
    const a = require(11479);
    const r = require(65880);
    const s = require(67703);
    const i = require(10081);
    const o = require(86672);
    const l = require(41557);
    const p = require(83055);
    const d = require(21024);
    const c = require(92324);
    const u = 256;
    function m(e, t, n = false) {
      const a = e.getTupleClassType();
      if (a && d.isInstantiableClass(a)) {
        return c.convertToInstance(c.specializeTupleClass(a, t, true, n));
      } else {
        return d.UnknownType.create();
      }
    }
    function y(e, t, n, r) {
      r.expectedType = c.transformPossibleRecursiveTypeAlias(r.expectedType);
      if (!d.isClassInstance(r.expectedType)) {
        return;
      }
      const s = e.getTupleClassType();
      if (!s || !d.isInstantiableClass(s)) {
        return;
      }
      let p = [];
      if (c.isTupleClass(r.expectedType) && r.expectedType.priv.tupleTypeArgs) {
        p = r.expectedType.priv.tupleTypeArgs.map(e => c.transformPossibleRecursiveTypeAlias(e.type));
        const e = r.expectedType.priv.tupleTypeArgs.findIndex(e => e.isUnbounded);
        if (e >= 0) {
          if (p.length > t.d.items.length) {
            p.splice(e, 1);
          } else {
            while (p.length < t.d.items.length) {
              p.splice(e, 0, p[e]);
            }
          }
        }
      } else {
        const n = new o.ConstraintTracker();
        if (!i.addConstraintsForExpectedType(e, d.ClassType.cloneAsInstance(s), r.expectedType, n, l.getTypeVarScopesForNode(t), t.start)) {
          return;
        }
        const a = e.solveAndApplyConstraints(s, n);
        if (!a.priv.typeArgs || a.priv.typeArgs.length !== 1) {
          return;
        }
        const u = c.transformPossibleRecursiveTypeAlias(a.priv.typeArgs[0]);
        for (let e = 0; e < t.d.items.length; e++) {
          p.push(u);
        }
      }
      const y = t.d.items.map((t, a) => e.getTypeOfExpression(t, n | 268435456, c.makeInferenceContext(a < p.length ? p[a] : undefined, r.isTypeIncomplete)));
      const g = y.some(e => e.isIncomplete);
      let h;
      let f;
      if (y.some(e => e.expectedTypeDiagAddendum)) {
        h = new a.DiagnosticAddendum();
        y.forEach(e => {
          if (e.expectedTypeDiagAddendum) {
            h.addAddendum(e.expectedTypeDiagAddendum);
          }
        });
      }
      f = t.d.items.length > u && y.some(e => e.typeErrors) ? m(e, [{
        type: d.UnknownType.create(),
        isUnbounded: true
      }]) : m(e, e.buildTupleTypesList(y, false));
      return {
        type: f,
        expectedTypeDiagAddendum: h,
        isIncomplete: g
      };
    }
    function g(e, t, n) {
      const a = t.d.items.map(t => e.getTypeOfExpression(t, n | 268435456));
      const r = a.some(e => e.isIncomplete);
      if (t.d.items.length > u) {
        return {
          type: m(e, [{
            type: d.UnknownType.create(),
            isUnbounded: true
          }])
        };
      }
      const s = m(e, e.buildTupleTypesList(a, !!(n & 268435456)));
      if (r && c.getContainerDepth(s) > p.maxInferredContainerDepth) {
        return {
          type: d.UnknownType.create()
        };
      } else {
        return {
          type: s,
          isIncomplete: r
        };
      }
    }
    function h(e, t, n, a) {
      const r = t.findIndex(e => e.isUnbounded || d.isUnpackedTypeVarTuple(e.type) || d.isUnpackedTypeVar(e.type));
      const s = n.findIndex(e => e.isUnbounded);
      const i = n.findIndex(e => d.isUnpackedTypeVarTuple(e.type) || d.isUnpackedTypeVar(e.type));
      if (s >= 0) {
        if (d.isAnyOrUnknown(n[s].type)) {
          const e = n.length > 0 ? n[s].type : d.AnyType.create();
          while (n.length < t.length) {
            n.splice(s, 0, {
              type: e,
              isUnbounded: true
            });
          }
          if (n.length > t.length) {
            n.splice(s, 1);
          }
        } else {
          if (r < 0) {
            return false;
          }
        }
      }
      if (r >= 0 && t[r].isUnbounded && d.isAnyOrUnknown(t[r].type)) {
        while (t.length < n.length) {
          t.splice(r, 0, t[r]);
        }
      }
      while (n.length > t.length && n[n.length - 1].isOptional) {
        n.splice(n.length - 1, 1);
      }
      while (t.length > n.length && t[t.length - 1].isOptional) {
        t.splice(t.length - 1, 1);
      }
      const o = n.length - t.length + 1;
      let l = false;
      if (a & 2) {
        const a = t.length - n.length + 1;
        if (i >= 0 && a >= 0) {
          const n = a === 1 && d.isTypeVarTuple(t[i].type);
          const r = e.getTupleClassType();
          if (!n && r && d.isInstantiableClass(r)) {
            const e = t.splice(i, a);
            const n = d.ClassType.cloneAsInstance(c.specializeTupleClass(r, e.map(e => ({
              type: e.type,
              isUnbounded: e.isUnbounded,
              isOptional: e.isOptional
            })), true, true));
            t.splice(i, 0, {
              type: n,
              isUnbounded: false
            });
          }
          l = true;
        }
      } else {
        if (r >= 0 && o >= 0 && d.isTypeVarTuple(t[r].type)) {
          const t = e.getTupleClassType();
          if (t && d.isInstantiableClass(t)) {
            const e = n.splice(r, o);
            let a;
            a = e.length === 1 && d.isUnpackedTypeVarTuple(e[0].type) ? e[0].type : d.ClassType.cloneAsInstance(c.specializeTupleClass(t, e.map(e => ({
              type: e.type,
              isUnbounded: e.isUnbounded,
              isOptional: e.isOptional
            })), true, true));
            n.splice(r, 0, {
              type: a,
              isUnbounded: false
            });
          }
          l = true;
        }
      }
      if (!l && r >= 0 && o >= 0 && (s < 0 || s >= r && s < r + o)) {
        const e = n.splice(r, o).map(e => d.isTypeVar(e.type) && d.isUnpackedTypeVarTuple(e.type) ? d.TypeVarType.cloneForUnpacked(e.type, true) : e.type);
        n.splice(r, 0, {
          type: e.length > 0 ? d.combineTypes(e) : d.AnyType.create(),
          isUnbounded: false
        });
      }
      return t.length === n.length;
    }
    function f(e, t, n, a) {
      let r = n;
      if (t) {
        const n = e.getTypeOfExpression(t).type;
        if (!d.isClassInstance(n) || !d.ClassType.isBuiltIn(n, 'int') || !c.isLiteralType(n)) {
          return;
        }
        r = n.priv.literalValue;
        const s = a.findIndex(e => e.isUnbounded || d.isTypeVarTuple(e.type));
        if (r < 0) {
          r = a.length + r;
          if (s >= 0 && r <= s) {
            return;
          }
          if (r < 0) {
            return 0;
          }
        } else {
          if (s >= 0 && r > s) {
            return;
          }
          if (r > a.length) {
            return a.length;
          }
        }
      }
      return r;
    }
  },
  17486: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SpeculativeTypeTracker = undefined;
    const i = require(48281);
    const o = __importStar(require(41557));
    const l = require(21024);
    exports.SpeculativeTypeTracker = class {
      constructor() {
        this._speculativeContextStack = [];
        this._speculativeTypeCache = new Map();
        this._activeDependentTypes = [];
      }
      enterSpeculativeContext(e, t) {
        this._speculativeContextStack.push({
          speculativeRootNode: e,
          entriesToUndo: [],
          dependentType: t == null ? undefined : t.dependentType,
          allowDiagnostics: t == null ? undefined : t.allowDiagnostics
        });
        if (t == null ? undefined : t.dependentType) {
          this._activeDependentTypes.push({
            speculativeRootNode: e,
            dependentType: t.dependentType
          });
        }
      }
      leaveSpeculativeContext() {
        i.assert(this._speculativeContextStack.length > 0);
        const e = this._speculativeContextStack.pop();
        if (e == null ? undefined : e.dependentType) {
          i.assert(this._activeDependentTypes.length > 0);
          this._activeDependentTypes.pop();
        }
        e.entriesToUndo.forEach(e => {
          e.cache.delete(e.id);
        });
      }
      isSpeculative(e, t = false) {
        if (this._speculativeContextStack.length === 0) {
          return false;
        }
        if (!e) {
          return true;
        }
        for (let n = this._speculativeContextStack.length - 1; n >= 0; n--) {
          const a = this._speculativeContextStack[n];
          if (o.isNodeContainedWithin(e, a.speculativeRootNode) && (!t || !a.allowDiagnostics)) {
            return true;
          }
        }
        return false;
      }
      trackEntry(e, t) {
        const n = this._speculativeContextStack.length;
        if (n > 0) {
          this._speculativeContextStack[n - 1].entriesToUndo.push({
            cache: e,
            id: t
          });
        }
      }
      disableSpeculativeMode() {
        const e = this._speculativeContextStack;
        this._speculativeContextStack = [];
        return e;
      }
      enableSpeculativeMode(e) {
        i.assert(this._speculativeContextStack.length === 0);
        this._speculativeContextStack = e;
      }
      addSpeculativeType(e, t, n, a) {
        i.assert(this._speculativeContextStack.length > 0);
        let r = this._speculativeTypeCache.get(e.id);
        if (r) {
          r = r.filter(e => (!e.typeResult.isIncomplete || e.incompleteGenerationCount === n) && (a ? !e.expectedType || !l.isTypeSame(e.expectedType, a) : !!e.expectedType));
          if (r.length >= 8) {
            r.slice(1);
          }
        } else {
          r = [];
        }
        const s = {
          typeResult: t,
          expectedType: a,
          incompleteGenerationCount: n
        };
        if (this._activeDependentTypes.length > 0) {
          s.dependentTypes = Array.from(this._activeDependentTypes);
        }
        r.push(s);
        this._speculativeTypeCache.set(e.id, r);
      }
      getSpeculativeType(e, t) {
        if (this._speculativeContextStack.some(t => o.isNodeContainedWithin(e, t.speculativeRootNode))) {
          const n = this._speculativeTypeCache.get(e.id);
          if (n) {
            for (const e of n) {
              if (t) {
                if (e.expectedType && l.isTypeSame(t, e.expectedType) && this._dependentTypesMatch(e)) {
                  return e;
                }
              } else {
                if (!e.expectedType && this._dependentTypesMatch(e)) {
                  return e;
                }
              }
            }
          }
        }
      }
      _dependentTypesMatch(e) {
        var t;
        const n = (t = e.dependentTypes) !== null && t !== undefined ? t : [];
        return n.length === this._activeDependentTypes.length && n.every((e, t) => {
          const n = this._activeDependentTypes[t];
          return e.speculativeRootNode === n.speculativeRootNode && l.isTypeSame(e.dependentType, n.dependentType);
        });
      }
    };
  },
  53529: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getComplexityScoreForType = r;
    const a = require(21024);
    function r(e, t = 0) {
      if (t > a.maxTypeRecursionCount) {
        return 1;
      }
      t++;
      switch (e.category) {
        case 1:
        case 2:
          return 0.5;
        case 9:
          if (a.TypeBase.isInstantiable(e)) {
            return 0.55;
          } else {
            return 0.5;
          }
        case 4:
        case 5:
          if (a.TypeBase.isInstantiable(e)) {
            return 0.85;
          } else {
            return 0.8;
          }
        case 0:
        case 3:
          return 1;
        case 8:
          {
            let n = 0;
            if (e.priv.subtypes.length < 16) {
              e.priv.subtypes.forEach(e => {
                const a = r(e, t);
                n = Math.max(n, a);
              });
            } else {
              n = 0.5;
            }
            return n;
          }
        case 6:
          return function (e, t) {
            let n = 0;
            let s = 0;
            if (e.priv.tupleTypeArgs) {
              e.priv.tupleTypeArgs.forEach(e => {
                n += r(e.type, t);
                s++;
              });
            } else {
              if (e.priv.typeArgs) {
                e.priv.typeArgs.forEach(e => {
                  n += r(e, t);
                  s++;
                });
              } else {
                if (e.shared.typeParams) {
                  e.shared.typeParams.forEach(e => {
                    n += r(a.AnyType.create(), t);
                    s++;
                  });
                }
              }
            }
            let i = 0.5 + (s > 0 ? n / s : 0) * 0.25;
            if (a.isInstantiableClass(e)) {
              i += 0.05;
            }
            return i;
          }(e, t);
      }
      return 0;
    }
  },
  30889: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getFunctionDocStringInherited = function (e, t, n, a) {
      let r;
      if (!m(e, a) && t && i.isFunctionDeclaration(t)) {
        r = function (e, t, n) {
          if (!p.isFunction(e)) {
            return;
          }
          let a = e.shared.docString;
          if (!a && t) {
            a = v(t, n);
          }
          if (!a && e.shared.declaration) {
            a = v(e.shared.declaration, n);
          }
          return a;
        }(e, t, n);
      }
      if (!r && a) {
        const t = e.shared.name;
        const s = c.getClassMemberIterator(a, t, u);
        for (const e of s) {
          if (e.symbol.getDeclarations().length > 0) {
            const t = e.symbol.getDeclarations().slice(-1)[0];
            if (i.isFunctionDeclaration(t) && (r = v(t, n), r)) {
              break;
            }
          }
        }
      }
      return r || e.shared.docString;
    };
    exports.getOverloadedDocStringsInherited = function (e, t, n, a, r) {
      var s;
      let i;
      if (!m(e, r)) {
        for (const a of t) {
          i = T(e, a, n);
          if (i && i.length > 0) {
            return i;
          }
        }
      }
      const o = p.OverloadedType.getOverloads(e);
      if (r && o.length > 0) {
        const e = o[0].shared.name;
        const t = c.getClassMemberIterator(r, e, u);
        for (const e of t) {
          const t = e.symbol.getDeclarations().slice(-1)[0];
          const r = (s = a.getTypeForDeclaration(t)) === null || s === undefined ? undefined : s.type;
          if (r && (i = T(r, t, n), i && i.length > 0)) {
            break;
          }
        }
      }
      if (i != null) {
        return i;
      } else {
        return [];
      }
    };
    exports.getPropertyDocStringInherited = function (e, t, n) {
      const a = o.getEnclosingClass(e.node.d.name, false);
      const r = a ? n.getTypeOfClass(a) : undefined;
      if (r) {
        return function (e, t, n, a) {
          var r;
          var s;
          if (!e || !i.isFunctionDeclaration(e)) {
            return;
          }
          const o = (r = n.getTypeForDeclaration(e)) === null || r === undefined ? undefined : r.type;
          if (!o || !c.isMaybeDescriptorInstance(o)) {
            return;
          }
          const l = e.node.nodeType === 31 ? e.node.d.name.d.value : undefined;
          if (!l) {
            return;
          }
          const d = c.getClassIterator(a, 0);
          for (const [e] of d) {
            if (!p.isInstantiableClass(e)) {
              continue;
            }
            const a = p.ClassType.getSymbolTable(e).get(l);
            const r = a == null ? undefined : a.getDeclarations();
            if (r) {
              for (const e of r) {
                if (i.isFunctionDeclaration(e)) {
                  const a = (s = n.getTypeForDeclaration(e)) === null || s === undefined ? undefined : s.type;
                  if (a && c.isMaybeDescriptorInstance(a)) {
                    const n = v(e, t);
                    if (n) {
                      return n;
                    }
                  }
                }
              }
            }
          }
          return;
        }(e, t, n, r.classType);
      }
      return;
    };
    exports.getVariableInStubFileDocStrings = y;
    exports.isBuiltInModule = function (e) {
      if (e) {
        return e.getPath().includes('typeshed-fallback/stdlib');
      }
      return false;
    };
    exports.getModuleDocStringFromModuleNodes = g;
    exports.getModuleDocStringFromUris = h;
    exports.getModuleDocString = function (e, t, n) {
      var a;
      let r = e.priv.docString;
      if (!r) {
        r = h([(a = t == null ? undefined : t.uri) !== null && a !== undefined ? a : e.priv.fileUri], n);
      }
      return r;
    };
    exports.getClassDocString = function (e, t, n) {
      let a = e.shared.docString;
      if (!a && t && (r = t, i.isClassDeclaration(r) || i.isSpecialBuiltInClassDeclaration(r)) && (a = i.isClassDeclaration(t) ? b([t]) : undefined, !a && t && l.isStubFile(t.uri))) {
        for (const e of n.findDeclarations(t)) {
          if (i.isVariableDeclaration(e) && e.docString) {
            a = e.docString;
            break;
          }
          if (i.isClassDeclaration(e) || i.isFunctionDeclaration(e)) {
            a = f(e);
            break;
          }
        }
      }
      var r;
      if (!a && t) {
        const r = n.findClassDeclarationsByType(t.uri, e);
        if (r) {
          a = b(r.filter(e => i.isClassDeclaration(e)).map(e => e));
        }
      }
      return a;
    };
    exports.getFunctionOrClassDeclDocString = f;
    exports.getVariableDocString = function (e, t) {
      if (!e) {
        return;
      }
      if (e.docString !== undefined) {
        return e.docString;
      } else {
        return y(e, t).find(e => e);
      }
    };
    const i = require(28445);
    const o = __importStar(require(41557));
    const l = require(3113);
    const p = require(21024);
    const d = require(58147);
    const c = require(92324);
    const u = 85;
    function m(e, t) {
      if (e.category === 5) {
        const t = p.OverloadedType.getOverloads(e);
        if (t.length === 0) {
          return false;
        }
        e = t[0];
      }
      return !!e.shared.methodClass && p.ClassType.isBuiltIn(e.shared.methodClass) && !!e.priv.boundToType && !p.ClassType.isBuiltIn(e.priv.boundToType);
    }
    function y(e, t) {
      const n = [];
      if (!l.isStubFile(e.uri)) {
        return n;
      }
      for (const a of t.findDeclarations(e)) {
        if (i.isVariableDeclaration(a) && a.docString) {
          n.push(a.docString);
        } else {
          if (i.isClassDeclaration(a) || i.isFunctionDeclaration(a)) {
            const e = f(a);
            if (e) {
              n.push(e);
            }
          }
        }
      }
      return n;
    }
    function g(e) {
      for (const t of e) {
        if (t.d.statements) {
          const e = o.getDocString(t.d.statements);
          if (e) {
            return e;
          }
        }
      }
    }
    function h(e, t) {
      const n = [];
      for (const a of e) {
        if (l.isStubFile(a)) {
          d.addIfNotNull(n, t.getModuleNode(a));
        }
        d.appendArray(n, t.findModules(a));
      }
      return g(n);
    }
    function f(e) {
      var t;
      var n;
      var a;
      return o.getDocString((a = (n = (t = e.node) === null || t === undefined ? undefined : t.d.suite) === null || n === undefined ? undefined : n.d.statements) !== null && a !== undefined ? a : []);
    }
    function T(e, t, n) {
      if (!p.isOverloaded(e)) {
        return;
      }
      const a = [];
      const r = p.OverloadedType.getOverloads(e);
      const s = p.OverloadedType.getImplementation(e);
      if (r.some(e => e.shared.docString)) {
        r.forEach(e => {
          if (e.shared.docString) {
            a.push(e.shared.docString);
          }
        });
      }
      if (s && p.isFunction(s) && s.shared.docString) {
        a.push(s.shared.docString);
      }
      if (a.length === 0 && t && l.isStubFile(t.uri) && i.isFunctionDeclaration(t)) {
        const e = b(n.findFunctionDeclarations(t));
        if (e) {
          a.push(e);
        }
      }
      return a;
    }
    function v(e, t) {
      let n = b([e]);
      if (!n && l.isStubFile(e.uri)) {
        n = b(t.findFunctionDeclarations(e));
      }
      return n;
    }
    function b(e) {
      for (const t of e) {
        const e = f(t);
        if (e) {
          return e;
        }
      }
    }
  },
  90080: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.maxCodeComplexity = undefined;
    exports.createTypeEvaluator = function (e, n, a) {
      const r = [];
      const s = new Set();
      const ue = new G.SpeculativeTypeTracker();
      const me = [];
      const ye = [];
      let ge;
      let he = new Set();
      let fe = new Map();
      let Te = new Map();
      let ve = new Map();
      let be = new Map();
      let _e = [];
      let Ce = 0;
      let Ie = 0;
      const ke = [];
      let we;
      const Se = [];
      let Ae;
      function xe() {
        if (ge) {
          i.throwIfCancellationRequested(ge);
        }
      }
      function Pe(e) {
        if (we && Me(e)) {
          return we.get(e.id);
        } else {
          return Te.get(e.id);
        }
      }
      function De(e) {
        const t = Pe(e);
        return !!t && (!t.typeResult.isIncomplete || t.incompleteGenerationCount === Ie);
      }
      function Ne(e, t) {
        var a;
        var r;
        const s = Pe(e);
        if (s && !s.typeResult.isIncomplete) {
          if ((n.verifyTypeCacheEvaluatorFlags || de) && t !== undefined) {
            const i = s.flags;
            if (i !== undefined && t !== i) {
              const s = v.getFileInfo(e);
              const o = c.convertOffsetToPosition(e.start, s.lines);
              const p = `Type cache flag mismatch for node type ${e.nodeType} (parent ${(r = (a = e.parent) === null || a === undefined ? undefined : a.nodeType) !== null && r !== undefined ? r : 'none'}): cached flags = ${i}, access flags = ${t}, file = {${s.fileUri} [${o.line + 1}:${o.character + 1}]}`;
              if (n.verifyTypeCacheEvaluatorFlags) {
                l.fail(p);
              } else {
                console.log(p);
              }
            }
          }
          return s.typeResult.type;
        }
      }
      function Fe(e, t, n, a, r = false) {
        const s = we && Me(e) ? we : Te;
        if (t.isIncomplete) {
          const n = s.get(e.id);
          if (n !== undefined && !H.isTypeSame(t.type, n.typeResult.type)) {
            Ie++;
          }
        } else {
          Ie++;
        }
        s.set(e.id, {
          typeResult: t,
          flags: n,
          incompleteGenerationCount: Ie
        });
        if (ar(e)) {
          ue.trackEntry(s, e.id);
          if (r) {
            ue.addSpeculativeType(e, t, Ie, a == null ? undefined : a.expectedType);
          }
        }
      }
      function Ee(e, t, n = 0) {
        Fe(e, t, n);
      }
      function Me(e) {
        const t = ke.length;
        if (t === 0) {
          return false;
        }
        const n = ke[t - 1];
        let a = e;
        while (a) {
          if (a === n.functionNode) {
            return true;
          }
          a = a.parent;
        }
        return false;
      }
      function Oe(e, t) {
        return r.findIndex(n => n.symbolId === e.id && n.declaration === t);
      }
      function ze(e, t) {
        const n = Oe(e, t);
        if (n >= 0) {
          for (let e = n + 1; e < r.length; e++) {
            r[e].isResultValid = false;
          }
          return false;
        }
        r.push({
          symbolId: e.id,
          declaration: t,
          isResultValid: true
        });
        return true;
      }
      function Ue(e) {
        const t = r.pop();
        l.assert(t.symbolId === e.id);
        return t.isResultValid;
      }
      function Ve(e, t, n) {
        const a = Oe(e, t);
        if (a >= 0) {
          r[a].partialType = n;
        }
      }
      function Re(e, t) {
        const n = Oe(e, t);
        if (n >= 0) {
          return r[n].partialType;
        }
      }
      function Le(e) {
        var t;
        var n;
        var a;
        var r;
        je(e);
        let s = (t = Ba(e, () => {
          Va(e);
        })) === null || t === undefined ? undefined : t.type;
        if (s && H.isTypeVar(s) && s.shared.declaredVariance === 0) {
          const t = s;
          const i = M.getParentNodeOfType(e, 76);
          if (((n = i == null ? undefined : i.parent) === null || n === undefined ? undefined : n.nodeType) === 10) {
            const e = ca(i.parent);
            if (e) {
              ya(e.classType);
              const n = e.classType.shared.typeParams.find(e => H.isTypeSame(e, t, {
                ignoreTypeFlags: true
              }));
              if ((n == null ? undefined : n.priv.computedVariance) !== undefined) {
                s = H.TypeVarType.cloneWithComputedVariance(s, n.priv.computedVariance);
              }
            }
          } else {
            if (((a = i == null ? undefined : i.parent) === null || a === undefined ? undefined : a.nodeType) === 77) {
              const t = oa(i.parent);
              const n = i.d.params.findIndex(t => t.d.name === e);
              if (n >= 0) {
                Ht(t);
                const e = (r = t.props) === null || r === undefined ? undefined : r.typeAliasInfo;
                if (e == null ? undefined : e.shared.computedVariance) {
                  const t = e.shared.computedVariance[n];
                  s = H.TypeVarType.cloneWithComputedVariance(s, t);
                }
              }
            }
          }
        }
        if (s) {
          s = Z.transformPossibleRecursiveTypeAlias(s);
        }
        return s;
      }
      function Be(e) {
        je(e);
        let t = e;
        let n = e;
        while (n) {
          if (h.isExpressionNode(n)) {
            t = n;
          }
          n = n.parent;
        }
        Va(t);
        n = e;
        while (n) {
          const e = be.get(n.id);
          if (e) {
            return {
              type: e,
              node: n
            };
          }
          if (n === t) {
            break;
          }
          n = n.parent;
        }
      }
      function je(e) {
        var t;
        if (!Ae && (Ae = {}, Ae.objectClass = Za(e, 'object'), Ae.typeClass = Za(e, 'type'), Ae.functionClass = Za(e, 'function'), Ae.unionTypeClass = function (e, t) {
          return mt(e, t, ['types']);
        }(e, 'UnionType'), Ae.unionTypeClass && H.isClass(Ae.unionTypeClass) && (Ae.unionTypeClass.shared.flags |= 8388608), ct(e, 'Collection'), Ae.noneTypeClass = (t = ut(e, 'NoneType')) !== null && t !== undefined ? t : H.UnknownType.create(), Ae.tupleClass = Za(e, 'tuple'), Ae.boolClass = Za(e, 'bool'), Ae.intClass = Za(e, 'int'), Ae.strClass = Za(e, 'str'), Ae.dictClass = Za(e, 'dict'), Ae.moduleTypeClass = ct(e, 'ModuleType'), Ae.typedDictClass = ct(e, 'TypedDict'), Ae.typedDictPrivateClass = ct(e, '_TypedDict'), Ae.awaitableClass = ct(e, 'Awaitable'), Ae.mappingClass = ct(e, 'Mapping'), Ae.supportsKeysAndGetItemClass = ut(e, 'SupportsKeysAndGetItem'), Ae.supportsKeysAndGetItemClass ||= Ae.mappingClass, Ae.objectClass && H.isInstantiableClass(Ae.objectClass) && Ae.typeClass && H.isInstantiableClass(Ae.typeClass))) {
          const t = H.ClassType.createInstantiable('Any', 'typing.Any', 'typing', y.Uri.empty(), 25165825, -1, undefined, Ae.typeClass);
          t.shared.baseClasses.push(Ae.objectClass);
          Z.computeMroLinearization(t);
          const n = H.AnyType.createSpecialForm();
          if (H.isAny(n)) {
            H.TypeBase.setSpecialForm(n, t);
            if (Zr(e)) {
              H.TypeBase.setTypeForm(n, Z.convertToInstance(n));
            }
          }
        }
      }
      function qe(e, t = 0, n) {
        const a = Pe(e);
        if (a && (!a.typeResult.isIncomplete || a.incompleteGenerationCount === Ie)) {
          if (ce) {
            console.log(`${Jr()}${M.printExpression(e)} (${Qr(e)}): Cached ${Yr(a.typeResult.type)} ${a.typeResult.typeErrors ? ' Errors' : ''}`);
          }
          return a.typeResult;
        }
        {
          const t = ue.getSpeculativeType(e, n == null ? undefined : n.expectedType);
          if (t && (!t.typeResult.isIncomplete || t.incompleteGenerationCount === Ie)) {
            if (ce) {
              console.log(`${Jr()}${M.printExpression(e)} (${Qr(e)}): Speculative ${Yr(t.typeResult.type)}`);
            }
            return t.typeResult;
          }
        }
        if (ce) {
          console.log(`${Jr()}${M.printExpression(e)} (${Qr(e)}): Pre`);
          Ce++;
        }
        xe();
        if (n) {
          n.expectedType = Z.transformPossibleRecursiveTypeAlias(n.expectedType);
        }
        je(e);
        let r = function (e, t = 0, n) {
          var a;
          var r;
          let s;
          let i = !!(t & 128);
          switch (e.nodeType) {
            case 38:
              s = function (e, t) {
                const n = v.getFileInfo(e);
                const a = e.d.value;
                let r;
                let s;
                let i = false;
                const o = !!(t & 4) || n.isStubFile;
                let p = Ja(e, a, !o, o && !!(t & 256));
                if (!p) {
                  const n = sr(e);
                  if (n) {
                    p = Ja(n, n.d.value, !o, o && !!(t & 256));
                  }
                }
                if (p) {
                  let c = !o;
                  if (p.scope.type === 5) {
                    c = false;
                  }
                  r = p.symbol;
                  Et(n, r, e);
                  if (!n.diagnosticRuleSet.analyzeUnannotatedFunctions) {
                    const t = M.getEnclosingFunction(e);
                    if (t && M.isUnannotatedFunction(t)) {
                      return {
                        type: H.AnyType.create(),
                        isIncomplete: false
                      };
                    }
                  }
                  const u = ur(r, c ? e : undefined);
                  let m = Z.transformPossibleRecursiveTypeAlias(u.type);
                  if (u.isIncomplete) {
                    if (H.isUnbound(m)) {
                      m = H.UnknownType.create(true);
                    }
                    i = true;
                  }
                  if (u.isRecursiveDefinition && gt(e)) {
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.recursiveDefinition().format({
                      name: a
                    }), e);
                  }
                  const y = !!m && H.isInstantiableClass(m) && H.ClassType.isSpecialBuiltIn(m);
                  s = m;
                  if (c && !y) {
                    let n = m;
                    let o = false;
                    if (!p.isBeyondExecutionScope && r.isInitiallyUnbound() && (n = H.UnboundType.create(), p.scope.type === 4)) {
                      l.assert(p.scope.parent);
                      const e = p.scope.parent.lookUpSymbol(a);
                      if (e) {
                        n = ur(e).type;
                      }
                    }
                    if (p.isBeyondExecutionScope) {
                      const t = function (e, t, n) {
                        if (t.usesGlobalBinding || t.usesNonlocalBinding) {
                          return;
                        }
                        const a = t.symbol.getDeclarations();
                        if (!a.every(e => e.type === 1 || e.type === 2 || e.type === 8)) {
                          return;
                        }
                        if (!a.every(e => e.type === 2 || V.getScopeForNode(e.node) === t.scope)) {
                          return;
                        }
                        if (!a.every(e => {
                          var t;
                          return e.type !== 1 || e.isFinal || ((t = V.getScopeForNode(e.node)) === null || t === undefined ? undefined : t.type) !== 4;
                        })) {
                          return;
                        }
                        const r = V.getScopeHierarchy(e, t.scope);
                        if (r && r.length >= 2) {
                          const a = V.findTopNodeInScope(e, r[r.length - 2]);
                          if ((a == null ? undefined : a.nodeType) === 31 || (a == null ? undefined : a.nodeType) === 33 || (a == null ? undefined : a.nodeType) === 10) {
                            const r = v.getFlowNode(a);
                            if (r && t.symbol.getDeclarations().every(e => {
                              if (e.type === 2) {
                                return true;
                              }
                              const t = v.getFlowNode(e.node);
                              return !!t && ts.getFlowNodeReachability(t, r, true) !== K.Reachability.Reachable;
                            })) {
                              let r = n;
                              if (t.symbol.isInitiallyUnbound()) {
                                r = H.UnboundType.create();
                              }
                              return qa(e, a, {
                                targetSymbolId: t.symbol.id,
                                typeAtStart: {
                                  type: r
                                }
                              });
                            }
                          }
                        }
                        return;
                      }(e, p, m);
                      if (t == null ? undefined : t.type) {
                        s = t.type;
                        n = s;
                        o = !!t.isIncomplete;
                      }
                    }
                    const d = qa(e, undefined, {
                      targetSymbolId: r.id,
                      typeAtStart: {
                        type: n,
                        isIncomplete: o
                      },
                      skipConditionalNarrowing: !!(t & 256)
                    });
                    if (d.type) {
                      s = d.type;
                    }
                    if (d.isIncomplete) {
                      i = true;
                    }
                  }
                  s = Rt(e, s, t);
                  if (t & 256) {
                    s = zt(e, s, !!u.includesVariableDecl);
                  }
                  if (H.isTypeVar(s) && !s.shared.isSynthesized) {
                    s = Vt(e, s, t);
                  }
                  s = Mt(e, s, t, !!u.includesVariableDecl);
                } else {
                  if (a === 'reveal_type' || a === 'reveal_locals') {
                    s = H.AnyType.create();
                  } else {
                    kt(d.DiagnosticRule.reportUndefinedVariable, g.LocMessage.symbolIsUndefined().format({
                      name: a
                    }), e);
                    s = H.UnknownType.create();
                  }
                }
                if (H.isParamSpec(s) && s.priv.scopeId && t & 32) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.paramSpecContext(), e);
                  s = H.UnknownType.create();
                }
                s = Ut(s, t);
                if (!(t & 256)) {
                  Ge(s, e);
                }
                if (t & 128) {
                  if (!(t & 1024)) {
                    if (H.isInstantiableClass(s) && H.ClassType.isBuiltIn(s, 'Generic')) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.genericNotAllowed(), e);
                    }
                  }
                }
                return {
                  type: s,
                  isIncomplete: i
                };
              }(e, t);
              break;
            case 35:
              s = function (e, t) {
                var n;
                var a;
                let r = 2;
                r |= t & 567556;
                if (t & 128) {
                  const t = e.d.member.d.value;
                  if (t === 'args' || t === 'kwargs') {
                    r |= 33554432;
                  }
                }
                const s = qe(e.d.leftExpr, r);
                if (Z.isTypeAliasPlaceholder(s.type)) {
                  return {
                    type: H.UnknownType.create(true),
                    isIncomplete: true
                  };
                }
                const i = Bt(e, s, {
                  method: 'get'
                }, t | 2);
                if (_.isCodeFlowSupportedForReference(e)) {
                  Fe(e, {
                    ...i,
                    isIncomplete: true
                  }, t);
                  Fe(e.d.member, {
                    ...i,
                    isIncomplete: true
                  }, t);
                  let n = i.type;
                  let a = !!i.isIncomplete;
                  if (H.isUnbound(n)) {
                    const t = Pt(s.type);
                    let r;
                    if (H.isInstantiableClass(t)) {
                      r = Z.lookUpClassMember(t, e.d.member.d.value, 1);
                    } else {
                      if (H.isClassInstance(t)) {
                        r = Z.lookUpObjectMember(t, e.d.member.d.value, 1);
                      }
                    }
                    if (r) {
                      n = Tr(r);
                      a = false;
                    }
                  }
                  const r = qa(e, undefined, {
                    targetSymbolId: L.indeterminateSymbolId,
                    typeAtStart: {
                      type: n,
                      isIncomplete: a
                    },
                    skipConditionalNarrowing: !!(t & 256)
                  });
                  if (r.type) {
                    i.type = r.type;
                  }
                  if (r.isIncomplete) {
                    i.isIncomplete = true;
                  }
                  i.type = Rt(e, i.type, t);
                  i.type = Mt(e, i.type, t, false);
                }
                if (s.isIncomplete) {
                  i.isIncomplete = true;
                }
                let o = i.isIncomplete;
                if (H.isInstantiableClass(i.type) && !i.type.priv.includeSubclasses || ((n = i.type.props) === null || n === undefined ? undefined : n.specialForm)) {
                  const t = M.getParentNodeOfType(e, 1);
                  if (t && ((a = t == null ? undefined : t.parent) === null || a === undefined ? undefined : a.nodeType) === 9) {
                    o = true;
                  }
                }
                if (!o) {
                  Un(v.getFileInfo(e).diagnosticRuleSet.reportUnknownMemberType, d.DiagnosticRule.reportUnknownMemberType, e.d.member, i.type, e, false);
                }
                Fe(e.d.member, i, t);
                return i;
              }(e, t);
              break;
            case 27:
              s = function (e, t = 0) {
                const n = qe(e.d.leftExpr, t | 2);
                if (t & 128 && e.d.leftExpr.nodeType === 48) {
                  kt(d.DiagnosticRule.reportIndexIssue, g.LocMessage.stringNotSubscriptable(), e.d.leftExpr);
                }
                if (!(t & 4)) {
                  let a = !!(t & 32768);
                  if (a) {
                    const t = M.getExecutionScopeNode(e);
                    if ((t == null ? undefined : t.nodeType) === 36) {
                      a = false;
                    }
                  }
                  if (!a) {
                    const t = v.getFileInfo(e);
                    if (H.isInstantiableClass(n.type) && H.ClassType.isBuiltIn(n.type) && !n.type.priv.aliasName) {
                      const a = Y.get(n.type.shared.fullName);
                      if (a !== undefined && u.PythonVersion.isLessThan(t.executionEnvironment.pythonVersion, a) && !t.isStubFile) {
                        kt(d.DiagnosticRule.reportIndexIssue, g.LocMessage.classNotRuntimeSubscriptable().format({
                          name: n.type.priv.aliasName || n.type.shared.name
                        }), e.d.leftExpr);
                      }
                    }
                  }
                }
                const a = $t(e, n, {
                  method: 'get'
                }, t);
                if (_.isCodeFlowSupportedForReference(e)) {
                  let r = !H.isAny(n.type);
                  Dt(n.type, undefined, e => {
                    if (!H.isClassInstance(e) || !H.ClassType.isBuiltIn(e) && !H.ClassType.isTypedDictClass(e)) {
                      r = false;
                    }
                  });
                  if (r) {
                    Fe(e, {
                      ...a,
                      isIncomplete: true
                    }, t);
                    const r = qa(e, undefined, {
                      targetSymbolId: L.indeterminateSymbolId,
                      typeAtStart: {
                        type: a.type,
                        isIncomplete: !!n.isIncomplete || !!a.isIncomplete
                      },
                      skipConditionalNarrowing: !!(t & 256)
                    });
                    if (r.type) {
                      a.type = r.type;
                    }
                    if (r.isIncomplete) {
                      a.isIncomplete = true;
                    }
                  }
                }
                if (n.isIncomplete) {
                  a.isIncomplete = true;
                }
                return a;
              }(e, t);
              break;
            case 9:
              s = er(e, () => function (e, t, n) {
                var a;
                let r;
                if (t & 256 && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'type') {
                  const t = new p.DiagnosticAddendum();
                  t.addMessage(g.LocAddendum.useTypeInstead());
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeCallNotAllowed() + t.getString(), e);
                }
                r = e.d.leftExpr.nodeType === 33 ? function (e, t) {
                  l.assert(e.d.leftExpr.nodeType === 33);
                  const n = H.FunctionType.createSynthesizedInstance('');
                  n.shared.declaredReturnType = t ? t.expectedType : H.UnknownType.create();
                  let a = false;
                  e.d.args.forEach((e, t) => {
                    const r = qe(e.d.valueExpr);
                    if (r.isIncomplete) {
                      a = true;
                    }
                    H.FunctionType.addParam(n, H.FunctionParam.create(0, r.type, H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `p${t.toString()}`));
                  });
                  const r = e.d.leftExpr.d.params;
                  if (r.length > 0) {
                    const e = r[r.length - 1];
                    if (e.d.category === 0 && !e.d.name) {
                      H.FunctionType.addPositionOnlyParamSeparator(n);
                    }
                  }
                  function s() {
                    return qe(e.d.leftExpr, 2, Z.makeInferenceContext(n));
                  }
                  let i = a || ar(e) || (t == null ? undefined : t.isTypeIncomplete) ? nr(e.d.leftExpr, s) : s();
                  if (i.typeErrors) {
                    i = qe(e.d.leftExpr, 2);
                  }
                  return i;
                }(e, n) : qe(e.d.leftExpr, t & 4 | 2);
                const s = M.getArgsByRuntimeOrder(e).map(e => ({
                  valueExpression: e.d.valueExpr,
                  argCategory: e.d.argCategory,
                  node: e,
                  name: e.d.name
                }));
                let i = {
                  type: H.UnknownType.create()
                };
                r.type = tr(r.type, e);
                if (Z.isTypeAliasPlaceholder(r.type)) {
                  i.isIncomplete = true;
                } else {
                  if (e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'super') {
                    i = function (e) {
                      var t;
                      var n;
                      var a;
                      if (e.d.args.length > 2) {
                        kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.superCallArgCount(), e.d.args[2]);
                      }
                      const r = M.getEnclosingFunctionEvaluationScope(e);
                      const s = r ? M.getEnclosingClass(r) : undefined;
                      const i = s ? (t = ca(s)) === null || t === undefined ? undefined : t.classType : undefined;
                      let o;
                      if (e.d.args.length > 0) {
                        o = qe(e.d.args[0].d.valueExpr).type;
                        const t = Pt(o);
                        if (!H.isAnyOrUnknown(t) && !H.isInstantiableClass(t) && !Z.isMetaclassInstance(t)) {
                          kt(d.DiagnosticRule.reportArgumentType, g.LocMessage.superCallFirstArg().format({
                            type: Yr(o)
                          }), e.d.args[0].d.valueExpr);
                        }
                      } else {
                        if (i) {
                          o = i ?? H.UnknownType.create();
                          if (r) {
                            const t = x.getFunctionInfoFromDecorators(es, r, true);
                            if ((t == null ? undefined : t.flags) & 4) {
                              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.superCallZeroArgFormStaticMethod(), e.d.leftExpr);
                            }
                          }
                        } else {
                          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.superCallZeroArgForm(), e.d.leftExpr);
                          o = H.UnknownType.create();
                        }
                      }
                      const l = Pt(o);
                      let p;
                      let c;
                      if (e.d.args.length > 1) {
                        p = qe(e.d.args[1].d.valueExpr).type;
                        const t = Pt(p);
                        let n = false;
                        if (!H.isAnyOrUnknown(t)) {
                          if (H.isClassInstance(t)) {
                            if (H.isInstantiableClass(l)) {
                              if (!Z.derivesFromClassRecursive(H.ClassType.cloneAsInstantiable(t), l, true)) {
                                n = true;
                              }
                            }
                            c = t;
                          } else {
                            if (H.isInstantiableClass(t)) {
                              if (H.isInstantiableClass(l)) {
                                if (!H.ClassType.isBuiltIn(l, 'type') && !Z.derivesFromClassRecursive(t, l, true)) {
                                  n = true;
                                }
                              }
                              c = t;
                            } else {
                              n = true;
                            }
                          }
                        }
                        if (n) {
                          kt(d.DiagnosticRule.reportArgumentType, g.LocMessage.superCallSecondArg().format({
                            type: Yr(o)
                          }), e.d.args[1].d.valueExpr);
                          return {
                            type: H.UnknownType.create()
                          };
                        }
                      } else {
                        if (i) {
                          c = H.ClassType.cloneAsInstance(i);
                          const t = M.getEnclosingFunction(e);
                          let n;
                          if (t) {
                            const a = va(t);
                            if (a) {
                              const t = a.functionType;
                              if ((H.FunctionType.isClassMethod(t) || H.FunctionType.isConstructorMethod(t) || H.FunctionType.isInstanceMethod(t)) && t.shared.parameters.length > 0 && H.FunctionParam.isTypeDeclared(t.shared.parameters[0])) {
                                let a = H.FunctionType.getParamType(t, 0);
                                const r = M.getTypeVarScopesForNode(e);
                                a = Z.makeTypeVarsBound(a, r);
                                n = Pt(a);
                              }
                            }
                          }
                          if (c && n) {
                            const e = Z.getTypeCondition(n);
                            if (e) {
                              c = Z.addConditionToType(c, e);
                            } else {
                              if (H.isClass(n)) {
                                c = n;
                              }
                            }
                          }
                        }
                      }
                      let u = true;
                      if (e.d.args.length <= 1) {
                        const t = M.getEnclosingFunction(e);
                        if (t) {
                          const e = va(t);
                          if (e && (H.FunctionType.isStaticMethod(e.functionType) || H.FunctionType.isConstructorMethod(e.functionType) || H.FunctionType.isClassMethod(e.functionType))) {
                            u = false;
                          }
                        }
                      }
                      const m = e.parent;
                      if ((m == null ? undefined : m.nodeType) === 35) {
                        const e = m.d.member.d.value;
                        let t = H.isClass(l) ? l : undefined;
                        let r = false;
                        if (c && H.ClassType.isProtocolClass(c) && t && !H.ClassType.isSameGenericClass(H.TypeBase.isInstance(c) ? H.ClassType.cloneAsInstantiable(c) : c, t)) {
                          r = true;
                          t = undefined;
                        }
                        if (c) {
                          c = Z.selfSpecializeClass(c, {
                            useBoundTypeVars: true
                          });
                        }
                        const s = c ? Z.lookUpClassMember(c, e, 0, t) : undefined;
                        let i;
                        let o;
                        if (s && H.isInstantiableClass(s.classType)) {
                          i = s.classType;
                          if (r) {
                            i = H.ClassType.cloneIncludeSubclasses(i);
                          }
                        } else {
                          i = !t || H.isAnyOrUnknown(t) || Z.derivesFromAnyOrUnknown(t) ? H.UnknownType.create() : (n = Ae == null ? undefined : Ae.objectClass) !== null && n !== undefined ? n : H.UnknownType.create();
                        }
                        if (c) {
                          if (p) {
                            if (H.isTypeVar(p)) {
                              o = Z.convertToInstance(p);
                            }
                          } else {
                            o = H.TypeBase.cloneForCondition(H.TypeVarType.cloneAsBound(Z.synthesizeTypeVarForSelfCls(H.ClassType.cloneIncludeSubclasses(c, false), false)), (a = c.props) === null || a === undefined ? undefined : a.condition);
                          }
                        }
                        return {
                          type: u ? Z.convertToInstance(i, false) : i,
                          bindToSelfType: o
                        };
                      }
                      if (H.isInstantiableClass(l)) {
                        if (c) {
                          let e;
                          if (H.ClassType.isSameGenericClass(H.TypeBase.isInstance(c) ? H.ClassType.cloneAsInstantiable(c) : c, l)) {
                            if (c.shared.baseClasses.length > 0) {
                              e = c.shared.baseClasses[0];
                            }
                          } else {
                            const t = c.shared.baseClasses.findIndex(e => H.isClass(e) && H.ClassType.isSameGenericClass(e, l));
                            if (t >= 0 && t < c.shared.baseClasses.length - 1) {
                              e = c.shared.baseClasses[t + 1];
                            }
                          }
                          if (e) {
                            if (H.isInstantiableClass(e)) {
                              e = Z.specializeForBaseClass(c, e);
                            }
                            return {
                              type: u ? Z.convertToInstance(e) : e
                            };
                          }
                          if ((Ae == null ? undefined : Ae.typeClass) && H.isInstantiableClass(Ae.typeClass)) {
                            return {
                              type: u ? lt() : Z.convertToInstance(Ae.typeClass)
                            };
                          }
                        } else {
                          if (l.shared.mro.some(e => H.isAnyOrUnknown(e))) {
                            return {
                              type: H.UnknownType.create()
                            };
                          }
                          const e = l.shared.baseClasses;
                          if (e.length > 0) {
                            const t = e[0];
                            if (H.isInstantiableClass(t)) {
                              return {
                                type: u ? H.ClassType.cloneAsInstance(t) : t
                              };
                            }
                          }
                        }
                      }
                      return {
                        type: H.UnknownType.create()
                      };
                    }(e);
                  } else {
                    if (H.isAnyOrUnknown(r.type) && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'reveal_type') {
                      i = tn(e, n);
                    } else {
                      if (H.isFunction(r.type) && H.FunctionType.isBuiltIn(r.type, 'reveal_type')) {
                        i = tn(e, n);
                      } else {
                        if (H.isFunction(r.type) && H.FunctionType.isBuiltIn(r.type, 'assert_type')) {
                          i = function (e, t) {
                            if (e.d.args.length !== 2 || e.d.args[0].d.argCategory !== 0 || e.d.args[0].d.name !== undefined || e.d.args[0].d.argCategory !== 0 || e.d.args[1].d.name !== undefined) {
                              kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.assertTypeArgs(), e);
                              return {
                                type: H.UnknownType.create()
                              };
                            }
                            const n = qe(e.d.args[0].d.valueExpr, undefined, t);
                            if (n.isIncomplete) {
                              return {
                                type: H.UnknownType.create(true),
                                isIncomplete: true
                              };
                            }
                            const a = Z.convertToInstance($a(en(e.d.args[1]), {
                              typeExpression: true
                            }).type);
                            const r = Qe(n.type);
                            if (!H.isTypeSame(a, r, {
                              treatAnySameAsUnknown: true,
                              ignorePseudoGeneric: true,
                              ignoreConditions: true
                            })) {
                              const t = Hr(n.type, a, {
                                expandTypeAlias: true
                              });
                              kt(d.DiagnosticRule.reportAssertTypeFailure, g.LocMessage.assertTypeTypeMismatch().format({
                                expected: t.destType,
                                received: t.sourceType
                              }), e.d.args[0].d.valueExpr);
                            }
                            return {
                              type: n.type
                            };
                          }(e, n);
                        } else {
                          if (H.isClass(r.type) && H.ClassType.isBuiltIn(r.type, 'TypeForm')) {
                            i = function (e, t) {
                              var n;
                              if (e.d.args.length !== 1 || e.d.args[0].d.argCategory !== 0 || e.d.args[0].d.name !== undefined) {
                                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.typeFormArgs(), e);
                                return {
                                  type: H.UnknownType.create()
                                };
                              }
                              const a = $a(en(e.d.args[0]), {
                                typeFormArg: Zr(e),
                                noNonTypeSpecialForms: true,
                                typeExpression: true
                              });
                              if (!a.typeErrors && ((n = a.type.props) === null || n === undefined ? undefined : n.typeForm)) {
                                a.type = Z.convertToInstance(H.ClassType.specialize(t, [Z.convertToInstance(a.type.props.typeForm)]));
                              }
                              return a;
                            }(e, r.type);
                          } else {
                            if (H.isAnyOrUnknown(r.type) && e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === 'reveal_locals') {
                              if (e.d.args.length === 0) {
                                i.type = function (e) {
                                  let t;
                                  let n = e;
                                  while (n && (t = V.getScopeForNode(n), !t || t.type === 1)) {
                                    n = n.parent;
                                  }
                                  const a = [];
                                  if (t) {
                                    t.symbolTable.forEach((e, t) => {
                                      if (!e.isIgnoredForProtocolMatch()) {
                                        const n = cr(e);
                                        a.push(g.LocAddendum.typeOfSymbol().format({
                                          name: t,
                                          type: Yr(n, {
                                            expandTypeAlias: true
                                          })
                                        }));
                                      }
                                    });
                                  }
                                  if (a.length > 0) {
                                    bt(a.join('\n'), e);
                                  } else {
                                    bt(g.LocMessage.revealLocalsNone(), e);
                                  }
                                  return pt();
                                }(e);
                              } else {
                                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.revealLocalsArgs(), e);
                              }
                            } else {
                              const t = pn(e, s, r, undefined, false, n);
                              i.type = (a = t.returnType) !== null && a !== undefined ? a : H.UnknownType.create();
                              if (t.argumentErrors) {
                                i.typeErrors = true;
                              } else {
                                i.overloadsUsedForCall = t.overloadsUsedForCall;
                              }
                              if (t.isTypeIncomplete) {
                                i.isIncomplete = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (r.isIncomplete) {
                    i.isIncomplete = true;
                  }
                }
                if (!ar(e) && !r.isIncomplete) {
                  if (!H.isInstantiableClass(r.type) || !H.ClassType.isBuiltIn(r.type, 'TypeVar') || !v.getFileInfo(e).isTypingStubFile) {
                    s.forEach(e => {
                      if (e.valueExpression && e.valueExpression.nodeType !== 48 && !De(e.valueExpression)) {
                        qe(e.valueExpression);
                      }
                    });
                  }
                }
                if (t & 256) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeAnnotationCall(), e);
                  i = {
                    type: H.UnknownType.create()
                  };
                }
                return i;
              }(e, t, n));
              break;
            case 52:
              s = q.getTypeOfTuple(es, e, t, n);
              break;
            case 14:
              s = function (e, t) {
                let n;
                if (e.d.constType === 26) {
                  if (Ae == null ? undefined : Ae.noneTypeClass) {
                    n = t & 128 ? Ae.noneTypeClass : Z.convertToInstance(Ae.noneTypeClass);
                    if (Zr(e)) {
                      n = H.TypeBase.cloneWithTypeForm(n, Z.convertToInstance(n));
                    }
                  }
                } else {
                  if (e.d.constType === 33 || e.d.constType === 15 || e.d.constType === 9) {
                    n = Ya(e, 'bool');
                    if (n && H.isClassInstance(n)) {
                      if (e.d.constType === 33) {
                        n = H.ClassType.cloneWithLiteral(n, true);
                      } else {
                        if (e.d.constType === 15) {
                          n = H.ClassType.cloneWithLiteral(n, false);
                        }
                      }
                    }
                  }
                }
                return {
                  type: n ?? H.UnknownType.create()
                };
              }(e, t);
              break;
            case 48:
              if (t & 8) {
                i = false;
              }
              s = function (e, t) {
                var n;
                let a;
                if (t & 8 && !(t & 1073741824)) {
                  return We(e, t);
                }
                const r = e => !!(e.d.token.flags & 32);
                const s = e.d.strings.findIndex(e => !r(e));
                const i = e.d.strings.findIndex(e => r(e));
                if (s >= 0 && i >= 0) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.mixingBytesAndStr(), e.d.strings[Math.max(i, s)]);
                  return {
                    type: H.UnknownType.create()
                  };
                }
                const o = i >= 0;
                let l = true;
                let p = false;
                e.d.strings.forEach(e => {
                  const t = Ke(e);
                  if (t.isIncomplete) {
                    p = true;
                  }
                  let n = false;
                  if (H.isClassInstance(t.type) && (H.ClassType.isBuiltIn(t.type, 'str') && t.type.priv.literalValue !== undefined || H.ClassType.isBuiltIn(t == null ? undefined : t.type, 'LiteralString'))) {
                    n = true;
                  }
                  if (!n) {
                    l = false;
                  }
                });
                if (e.d.strings.some(e => e.nodeType === 30)) {
                  if (l) {
                    const t = ct(e, 'LiteralString');
                    if (t && H.isInstantiableClass(t)) {
                      a = {
                        type: H.ClassType.cloneAsInstance(t)
                      };
                    }
                  }
                  if (!a) {
                    a = {
                      type: Ya(e, o ? 'bytes' : 'str'),
                      isIncomplete: p
                    };
                  }
                } else {
                  a = {
                    type: qn(e, o ? 'bytes' : 'str', e.d.strings.map(e => e.d.value).join('')),
                    isIncomplete: p
                  };
                }
                if (e.d.strings.length !== 1 || e.d.strings[0].nodeType !== 49 || !Zr(e)) {
                  return a;
                }
                const c = e.d.strings[0];
                const u = c.d.token.flags;
                const m = 256;
                if (u & 108 || c.d.token.escapedValue.length >= m) {
                  return a;
                }
                const y = We(e, t);
                if ((n = y.type.props) === null || n === undefined ? undefined : n.typeForm) {
                  a.type = H.TypeBase.cloneWithTypeForm(a.type, y.type.props.typeForm);
                }
                return a;
              }(e, t);
              break;
            case 40:
              s = function (e, t) {
                t = e.d.isImaginary ? {
                  type: Ya(e, 'complex')
                } : e.d.isInteger ? {
                  type: qn(e, 'int', e.d.value)
                } : {
                  type: Ya(e, 'float')
                };
                return t;
              }(e, s);
              break;
            case 21:
              s = function (e, t, n) {
                var a;
                var r;
                if (e & 1) {
                  t = {
                    type: H.AnyType.create(true)
                  };
                } else {
                  if (e & 256 && !(e & 65536)) {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisContext(), n);
                    t = {
                      type: H.UnknownType.create()
                    };
                  } else {
                    t = {
                      type: (r = (a = Ya(n, 'EllipsisType')) !== null && a !== undefined ? a : Ya(n, 'ellipsis')) !== null && r !== undefined ? r : H.AnyType.create()
                    };
                  }
                }
                return t;
              }(t, s, e);
              break;
            case 55:
              s = F.getTypeOfUnaryOperation(es, e, t, n);
              break;
            case 7:
              {
                let a = t;
                if (i && e.d.operator !== 6) {
                  a &= -129;
                }
                s = F.getTypeOfBinaryOperation(es, e, a, n);
                break;
              }
            case 5:
              s = F.getTypeOfAugmentedAssignment(es, e, n);
              break;
            case 34:
            case 45:
              s = function (e, t, n) {
                var a;
                if (t & 256 && e.nodeType === 34 && ((a = e.parent) === null || a === undefined ? undefined : a.nodeType) !== 1) {
                  const t = new p.DiagnosticAddendum();
                  t.addMessage(g.LocAddendum.useListInstead());
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.listInAnnotation() + t.getString(), e);
                }
                t &= -393;
                let r;
                let s = n == null ? undefined : n.expectedType;
                if (n && H.isUnion(n.expectedType)) {
                  let a;
                  let r;
                  Z.doForEachSubtype(n.expectedType, n => {
                    if (r && !r.typeErrors) {
                      return;
                    }
                    const s = nr(e, () => Fn(e, t, Z.makeInferenceContext(n)));
                    if (s && Ir(n, s.type) && (!r || r.typeErrors && !s.typeErrors)) {
                      a = n;
                      r = s;
                    }
                  }, true);
                  s = a;
                }
                if (s) {
                  const n = Fn(e, t, Z.makeInferenceContext(s));
                  if (n && !n.typeErrors) {
                    return n;
                  }
                  r = n == null ? undefined : n.expectedTypeDiagAddendum;
                }
                const i = function (e, t, n) {
                  const a = e.nodeType === 34 ? 'list' : 'set';
                  const r = e.nodeType === 45;
                  let s = false;
                  let i = false;
                  let o = false;
                  let l = [];
                  e.d.items.forEach((e, a) => {
                    let s;
                    s = e.nodeType !== 11 || e.d.isGenerator ? qe(e, t | 268435456) : Rn(e, t | 268435456);
                    s.type = Z.stripTypeForm(Ut(s.type, t, true));
                    if (s.isIncomplete) {
                      i = true;
                    }
                    if (s.typeErrors) {
                      o = true;
                    }
                    if (n || a < ae) {
                      l.push(s.type);
                    }
                    if (!!r && !s.isIncomplete && !s.typeErrors) {
                      Mn(e, s.type, false);
                    }
                  });
                  l = l.map(e => $e(e));
                  let p = n ? H.AnyType.create() : H.UnknownType.create();
                  if (l.length > 0) {
                    const t = v.getFileInfo(e);
                    p = a === 'list' && t.diagnosticRuleSet.strictListInference || a === 'set' && t.diagnosticRuleSet.strictSetInference || n ? H.combineTypes(l, {
                      maxSubtypeCount: K.maxSubtypesForInferredType
                    }) : Z.areTypesSame(l, {
                      ignorePseudoGeneric: true
                    }) ? l[0] : p;
                  } else {
                    s = true;
                  }
                  const d = Za(e, a);
                  const c = H.isInstantiableClass(d) ? H.ClassType.cloneAsInstance(H.ClassType.specialize(d, [p], true, undefined, undefined, s)) : H.UnknownType.create();
                  if (i && Z.getContainerDepth(c) > K.maxInferredContainerDepth) {
                    return {
                      type: H.UnknownType.create()
                    };
                  }
                  return {
                    type: c,
                    isIncomplete: i,
                    typeErrors: o
                  };
                }(e, t, !!(n == null ? undefined : n.expectedType));
                return {
                  ...i,
                  expectedTypeDiagAddendum: r
                };
              }(e, t, n);
              break;
            case 46:
              s = function (e) {
                if (!ar(e)) {
                  if (e.d.startValue) {
                    qe(e.d.startValue);
                  }
                  if (e.d.endValue) {
                    qe(e.d.endValue);
                  }
                  if (e.d.stepValue) {
                    qe(e.d.stepValue);
                  }
                }
                return {
                  type: Ya(e, 'slice')
                };
              }(e);
              break;
            case 6:
              s = function (e, t, n) {
                if (t & 256) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.awaitNotAllowed(), e);
                  return {
                    type: H.UnknownType.create()
                  };
                }
                const a = n ? Sa(e, n.expectedType, false, false) : undefined;
                const r = qe(e.d.expr, t, Z.makeInferenceContext(a));
                const s = {
                  type: rt(r.type, e.d.expr),
                  isIncomplete: r.isIncomplete,
                  typeErrors: r.typeErrors
                };
                if (r.isIncomplete) {
                  s.isIncomplete = true;
                }
                return s;
              }(e, t, n);
              break;
            case 51:
              s = F.getTypeOfTernaryOperation(es, e, t, n);
              break;
            case 11:
              s = function (e, t, n) {
                let a = false;
                let r = false;
                let s = e.d.forIfNodes.some((e, t) => e.nodeType === 12 && !!e.d.isAsync || t > 0 && M.containsAwaitNode(e));
                let i = H.UnknownType.create();
                if (M.containsAwaitNode(e.d.expr)) {
                  s = true;
                }
                const o = ct(e, s ? 'AsyncGenerator' : 'Generator');
                const l = En(e, o, n);
                const p = Rn(e, t | 268435456, l);
                if (p.isIncomplete) {
                  a = true;
                }
                if (p.typeErrors) {
                  r = true;
                }
                let d = p.type;
                if (!l || !Z.containsLiteralType(l)) {
                  d = $e(d);
                }
                if (o && H.isInstantiableClass(o)) {
                  i = H.ClassType.cloneAsInstance(H.ClassType.specialize(o, s ? [d, pt()] : [d, pt(), pt()]));
                }
                return {
                  type: i,
                  isIncomplete: a,
                  typeErrors: r
                };
              }(e, t, n);
              break;
            case 18:
              s = function (e, t, n) {
                var a;
                if (t & 256 && ((a = e.parent) === null || a === undefined ? undefined : a.nodeType) !== 1) {
                  const t = new p.DiagnosticAddendum();
                  t.addMessage(g.LocAddendum.useDictInstead());
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.dictInAnnotation() + t.getString(), e);
                }
                let r = n == null ? undefined : n.expectedType;
                if (n && H.isUnion(n.expectedType)) {
                  let a;
                  let s;
                  Z.doForEachSubtype(n.expectedType, n => {
                    if (s && !s.typeErrors) {
                      return;
                    }
                    const r = nr(e, () => Dn(e, t, Z.makeInferenceContext(n)));
                    if (r && Ir(n, r.type) && (!s || s.typeErrors && !r.typeErrors)) {
                      a = n;
                      s = r;
                    }
                  }, true);
                  r = a;
                }
                let s;
                if (r) {
                  s = new p.DiagnosticAddendum();
                  const n = Dn(e, t, Z.makeInferenceContext(r), s);
                  if (n) {
                    return n;
                  }
                }
                const i = function (e, t, n) {
                  const a = n ? H.AnyType.create() : H.UnknownType.create();
                  let r = a;
                  let s = a;
                  const i = [];
                  const o = [];
                  let l = false;
                  let p = false;
                  let d = false;
                  const c = Nn(e, t, i, o, n, false);
                  if (c.isIncomplete) {
                    p = true;
                  }
                  if (c.typeErrors) {
                    d = true;
                  }
                  const u = i.map(e => Z.stripTypeForm(Ut($e(e.type), t, true)));
                  const m = o.map(e => Z.stripTypeForm(Ut($e(e.type), t, true)));
                  r = u.length > 0 ? H.combineTypes(u) : a;
                  if (m.length > 0) {
                    s = v.getFileInfo(e).diagnosticRuleSet.strictDictionaryInference || n ? H.combineTypes(m) : Z.areTypesSame(m, {
                      ignorePseudoGeneric: true
                    }) ? m[0] : a;
                  } else {
                    s = a;
                    l = true;
                  }
                  const y = Za(e, 'dict');
                  const g = H.isInstantiableClass(y) ? H.ClassType.cloneAsInstance(H.ClassType.specialize(y, [r, s], true, undefined, undefined, l)) : H.UnknownType.create();
                  if (p && Z.getContainerDepth(g) > K.maxInferredContainerDepth) {
                    return {
                      type: H.UnknownType.create()
                    };
                  }
                  return {
                    type: g,
                    isIncomplete: p,
                    typeErrors: d
                  };
                }(e, t, !!(n == null ? undefined : n.expectedType));
                return {
                  ...i,
                  expectedTypeDiagAddendum: s
                };
              }(e, t, n);
              break;
            case 33:
              s = function (e, t) {
                let n;
                let a = [];
                if (t) {
                  Z.mapSubtypes(t.expectedType, e => {
                    if (H.isFunction(e)) {
                      a.push(e);
                    }
                    if (H.isClassInstance(e)) {
                      const t = tt(e, '__call__');
                      if (t && H.isFunction(t)) {
                        a.push(t);
                      }
                    }
                  });
                }
                if (a.length > 1) {
                  a = Z.sortTypes(a);
                  for (const r of a) {
                    if (!zn(e, r, t, true).typeErrors) {
                      n = r;
                      break;
                    }
                  }
                }
                if (!n && a.length > 0) {
                  n = a[0];
                }
                return zn(e, n, t, false);
              }(e, n);
              break;
            case 3:
              s = qe(e.d.rightExpr, t, n);
              Nt(e.d.leftExpr, s, e.d.rightExpr, true, true);
              break;
            case 4:
              if (t & 256) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.walrusNotAllowed(), e);
              }
              s = qe(e.d.rightExpr, t, n);
              Nt(e.d.name, s, e.d.rightExpr, true);
              break;
            case 60:
              s = function (e) {
                let t;
                let n;
                let a = false;
                const r = M.getEnclosingFunction(e);
                if (r) {
                  const a = va(r);
                  if (a) {
                    let s = H.FunctionType.getEffectiveReturnType(a.functionType);
                    if (s) {
                      const a = M.getTypeVarScopesForNode(e);
                      s = Z.makeTypeVarsBound(s, a);
                      t = Z.getGeneratorYieldType(s, !!r.d.isAsync);
                      const i = Z.getGeneratorTypeArgs(s);
                      if (i && i.length >= 2) {
                        n = Z.makeTypeVarsBound(i[1], a);
                      }
                    }
                  }
                }
                if (e.d.expr) {
                  if (qe(e.d.expr, undefined, Z.makeInferenceContext(t)).isIncomplete) {
                    a = true;
                  }
                }
                return {
                  type: n || H.UnknownType.create(),
                  isIncomplete: a
                };
              }(e);
              break;
            case 61:
              s = function (e) {
                const t = qe(e.d.expr);
                const n = t.type;
                const a = Z.mapSubtypes(n, n => {
                  let s = Z.getGeneratorTypeArgs(n);
                  if (s) {
                    if (s.length >= 2) {
                      return s[2];
                    } else {
                      return H.UnknownType.create();
                    }
                  }
                  if (H.isClassInstance(n) && H.ClassType.isBuiltIn(n, 'Coroutine')) {
                    return H.UnknownType.create();
                  }
                  const i = it(t, false, e)?.type ?? H.UnknownType.create();
                  s = Z.getGeneratorTypeArgs(i);
                  if (s && s.length >= 2) {
                    return s[2];
                  } else {
                    return H.UnknownType.create();
                  }
                });
                return {
                  type: a
                };
              }(e);
              break;
            case 56:
              s = function (e, t, n) {
                var a;
                let r;
                let s;
                if (n) {
                  const t = Za(e, 'Iterable');
                  if (t && H.isInstantiableClass(t)) {
                    s = H.ClassType.cloneAsInstance(H.ClassType.specialize(t, [n.expectedType]));
                  }
                }
                const i = qe(e.d.expr, t, Z.makeInferenceContext(s));
                const o = i.type;
                if (t & 64 || !H.isTypeVarTuple(o) || o.priv.isUnpacked) {
                  if (t & 4194304 && H.isInstantiableClass(o) && H.ClassType.isBuiltIn(o, 'tuple')) {
                    r = {
                      type: H.ClassType.cloneForUnpacked(o)
                    };
                  } else {
                    if (t & 256) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackInAnnotation(), e, e.d.starToken);
                      r = {
                        type: H.UnknownType.create()
                      };
                    } else {
                      const t = (a = st(i, false, e)) !== null && a !== undefined ? a : {
                        type: H.UnknownType.create(!!i.isIncomplete),
                        isIncomplete: i.isIncomplete
                      };
                      r = {
                        type: t.type,
                        typeErrors: i.typeErrors,
                        unpackedType: o,
                        isIncomplete: t.isIncomplete
                      };
                    }
                  }
                } else {
                  r = {
                    type: H.TypeVarType.cloneForUnpacked(o)
                  };
                }
                return r;
              }(e, t, n);
              break;
            case 54:
              s = qe(e.d.annotation, 33256);
              break;
            case 49:
            case 30:
              s = Ke(e);
              break;
            case 0:
              Qa(e, () => {
                if (e.d.child) {
                  qe(e.d.child);
                }
              });
              s = {
                type: H.UnknownType.create()
              };
              break;
            default:
              l.assertNever(e, `Illegal node type: ${e.nodeType}`);
          }
          if (!s) {
            l.fail(`Unhandled expression type '${M.printExpression(e)}'`);
          }
          if (i) {
            (function (e, t, n) {
              if (e.isIncomplete) {
                return;
              }
              if (t & 64 && H.isTypeVarTuple(e.type) && !e.type.priv.isInUnion) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeVarTupleContext(), n);
                e.type = H.UnknownType.create();
              }
              if (Z.isEffectivelyInstantiable(e.type, {
                honorTypeVarBounds: true
              })) {
                return;
              }
              if (H.isClassInstance(e.type) && H.ClassType.isBuiltIn(e.type, ['EllipsisType', 'ellipsis'])) {
                return;
              }
              if (t & 256) {
                const t = new p.DiagnosticAddendum();
                if (H.isUnion(e.type)) {
                  Z.doForEachSubtype(e.type, e => {
                    if (!Z.isEffectivelyInstantiable(e, {
                      honorTypeVarBounds: true
                    })) {
                      t.addMessage(g.LocAddendum.typeNotClass().format({
                        type: Yr(e)
                      }));
                    }
                  });
                }
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeExpectedClass().format({
                  type: Yr(e.type)
                }) + t.getString(), n);
                e.type = H.UnknownType.create();
              }
              e.typeErrors = true;
            })(s, t, e);
          }
          if (t & 256 && ((a = s.type.props) === null || a === undefined ? undefined : a.typeForm) === undefined) {
            const e = (r = s.type.props) === null || r === undefined ? undefined : r.specialForm;
            if (e && H.ClassType.isBuiltIn(e, 'TypeAliasType')) {
              s.type = H.TypeBase.cloneAsSpecialForm(s.type, undefined);
            }
          }
          return s;
        }(e, t, n);
        if (H.isInstantiableClass(r.type) && r.type.priv.includePromotions && !r.type.priv.includeSubclasses && H.ClassType.isBuiltIn(r.type, 'bytes') && v.getFileInfo(e).diagnosticRuleSet.disableBytesTypePromotions) {
          r = {
            ...r,
            type: H.ClassType.cloneRemoveTypePromotions(r.type)
          };
        }
        if (n) {
          r.type = function (e, t) {
            var n;
            var a;
            var r;
            if (!((n = t.props) === null || n === undefined ? undefined : n.typeForm)) {
              return t;
            }
            let s;
            let i;
            if ((a = t.props) === null || a === undefined ? undefined : a.typeForm) {
              s = t.props.typeForm;
            } else {
              if (H.isClass(t)) {
                if (H.TypeBase.isInstantiable(t)) {
                  if (!H.ClassType.isSpecialBuiltIn(t)) {
                    s = H.ClassType.cloneAsInstance(t);
                  }
                } else {
                  if (H.ClassType.isBuiltIn(t, 'type')) {
                    s = ((r = t.priv.typeArgs) === null || r === undefined ? undefined : r.length) && t.priv.typeArgs.length > 0 ? t.priv.typeArgs[0] : H.UnknownType.create();
                  }
                }
              } else {
                if (H.isTypeVar(t) && H.TypeBase.isInstantiable(t)) {
                  if (!H.isTypeVarTuple(t) || !t.priv.isInUnion) {
                    s = Z.convertToInstance(t);
                  }
                }
              }
            }
            if (!s) {
              return t;
            }
            Z.doForEachSubtype(e, e => {
              if (i || !H.isClassInstance(e) || !H.ClassType.isBuiltIn(e, 'TypeForm')) {
                return;
              }
              if (Ir(e.priv.typeArgs && e.priv.typeArgs.length > 0 ? e.priv.typeArgs[0] : H.UnknownType.create(), s)) {
                i = H.ClassType.specialize(e, [s]);
              }
            });
            if (i != null) {
              return i;
            } else {
              return t;
            }
          }(n.expectedType, r.type);
        }
        Fe(e, r, t, n, e.nodeType !== 4);
        if (e.nodeType === 38 || e.nodeType === 35) {
          r.type = tr(r.type, e);
        }
        if (n && !H.isAnyOrUnknown(n.expectedType) && !H.isNever(n.expectedType) && (be.set(e.id, n.expectedType), !r.isIncomplete && !r.expectedTypeDiagAddendum)) {
          const t = new p.DiagnosticAddendum();
          if (!Ir(n.expectedType, r.type, t, undefined, 0)) {
            r.typeErrors = true;
            r.expectedTypeDiagAddendum = t;
            t.addTextRange(e);
          }
        }
        if (ce) {
          Ce--;
          console.log(`${Jr()}${M.printExpression(e)} (${Qr(e)}): Post ${Yr(r.type)}${r.isIncomplete ? ' Incomplete' : ''}`);
        }
        return r;
      }
      function Ge(e, t) {
        let n = false;
        let a = '';
        if (H.isInstantiableClass(e) && !e.priv.includeSubclasses) {
          n = H.ClassType.isTypeCheckOnly(e);
          a = e.shared.name;
        } else {
          if (H.isFunction(e)) {
            n = H.FunctionType.isTypeCheckOnly(e);
            a = e.shared.name;
          }
        }
        if (n) {
          if (!v.getFileInfo(t).isStubFile) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeCheckOnly().format({
              name: a
            }), t);
          }
        }
      }
      function We(e, t) {
        const n = !!(t & 8);
        let a;
        let r = t | 132;
        if (!(t & 16777216)) {
          r |= 524288;
        }
        r &= -1073741825;
        if (e.d.annotation && t & 256) {
          return qe(e.d.annotation, r);
        }
        if (e.d.strings.length === 1) {
          const t = e.d.strings[0].d.token.flags;
          if (t & 32) {
            if (n) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.annotationBytesString(), e);
            }
            return {
              type: H.UnknownType.create()
            };
          }
          if (t & 8) {
            if (n) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.annotationRawString(), e);
            }
            return {
              type: H.UnknownType.create()
            };
          }
          if (t & 64) {
            if (n) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.annotationFormatString(), e);
            }
            return {
              type: H.UnknownType.create()
            };
          }
          const s = function (e, t) {
            const n = v.getFileInfo(e);
            const a = new f.Parser();
            const r = e.d.strings[0].d.value;
            let s = e.d.strings[0].start;
            if (e.d.strings[0].nodeType === 49) {
              s += e.d.strings[0].d.token.prefixLength + e.d.strings[0].d.token.quoteMarkLength;
            }
            const i = ' '.repeat(s) + r;
            const o = new f.ParseOptions();
            o.isStubFile = n.isStubFile;
            o.pythonVersion = n.executionEnvironment.pythonVersion;
            o.reportErrorsForParsedStringContents = true;
            const l = a.parseTextExpression(i, s, r.length, o, 0, undefined, n.typingSymbolAliases);
            if (l.parseTree) {
              if (!t && l.diagnostics.length > 0) {
                return;
              }
              const n = v.getFileInfo(e);
              l.diagnostics.forEach(t => {
                n.diagnosticSink.addDiagnosticWithTextRange('error', t.message, e);
              });
              l.parseTree.parent = e;
              if (t) {
                e.d.annotation = l.parseTree;
              }
              return l.parseTree;
            }
            return;
          }(e, n);
          if (s) {
            a = nr(n ? undefined : e, () => qe(s, r));
          }
        }
        if (!a) {
          if (n) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.expectedTypeNotString(), e);
          }
          a = {
            type: H.UnknownType.create()
          };
        }
        return a;
      }
      function Ke(e) {
        const t = !!(e.d.token.flags & 32);
        let n;
        let a = false;
        if (e.nodeType === 30) {
          let r = true;
          e.d.fieldExprs.forEach(e => {
            const t = qe(e);
            const n = t.type;
            if (t.isIncomplete) {
              a = true;
            }
            Z.doForEachSubtype(n, e => {
              if (!H.isClassInstance(e) || !H.ClassType.isBuiltIn(e, 'LiteralString') && (!H.ClassType.isBuiltIn(e, 'str') || e.priv.literalValue === undefined)) {
                r = false;
              }
            });
          });
          if (!t && r) {
            const t = ct(e, 'LiteralString');
            if (t && H.isInstantiableClass(t)) {
              n = {
                type: H.ClassType.cloneAsInstance(t),
                isIncomplete: a
              };
            }
          }
          if (!n) {
            n = {
              type: Ya(e, t ? 'bytes' : 'str'),
              isIncomplete: a
            };
            if (H.isClass(n.type) && n.type.priv.includePromotions) {
              n.type = H.ClassType.cloneRemoveTypePromotions(n.type);
            }
          }
        } else {
          n = {
            type: qn(e, t ? 'bytes' : 'str', e.d.value),
            isIncomplete: a
          };
        }
        return n;
      }
      function $e(e) {
        var t;
        var n;
        var a;
        if (H.isUnion(e) && e.priv.subtypes.length > 0 && (((t = e.priv.literalInstances.literalStrMap) === null || t === undefined ? undefined : t.size) === e.priv.subtypes.length || ((n = e.priv.literalInstances.literalIntMap) === null || n === undefined ? undefined : n.size) === e.priv.subtypes.length || ((a = e.priv.literalInstances.literalEnumMap) === null || a === undefined ? undefined : a.size) === e.priv.subtypes.length)) {
          return $e(e.priv.subtypes[0]);
        } else {
          return Z.mapSubtypes(e, e => {
            if (H.isClass(e) && (e.priv.literalValue !== undefined && (e = H.ClassType.cloneWithLiteral(e, undefined)), H.ClassType.isBuiltIn(e, 'LiteralString') && (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass))) {
              let t = H.ClassType.cloneAsInstance(Ae.strClass);
              t = H.TypeBase.cloneForCondition(t, Z.getTypeCondition(e));
              return t;
            }
            return e;
          });
        }
      }
      function He(e, t) {
        return Ze(e, {
          typeVarGetsCurScope: true,
          allowUnpackedTuple: t === 1,
          allowUnpackedTypedDict: t === 2
        });
      }
      function Ze(e, t) {
        var n;
        var a;
        var r;
        const s = v.getFileInfo(e);
        if (s.isTypingStubFile || s.isTypingExtensionsStubFile) {
          const t = function (e) {
            var t;
            if (!e.parent || e.parent.nodeType !== 54) {
              return;
            }
            if (e.parent.d.valueExpr.nodeType !== 38) {
              return;
            }
            const n = e.parent.d.valueExpr;
            const a = n.d.value;
            const r = new Map([['Tuple', {
              alias: 'tuple',
              module: 'builtins'
            }], ['Generic', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Protocol', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Callable', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Type', {
              alias: 'type',
              module: 'builtins'
            }], ['ClassVar', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Final', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Literal', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['TypedDict', {
              alias: '_TypedDict',
              module: 'self'
            }], ['Union', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Optional', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Annotated', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true,
              isIllegalInIsinstance: true
            }], ['TypeAlias', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Concatenate', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['TypeGuard', {
              alias: '',
              module: 'builtins',
              implicitBaseClass: 'bool',
              isSpecialForm: true,
              typeParamVariance: 3
            }], ['Unpack', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Required', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['NotRequired', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Self', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['NoReturn', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['Never', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['LiteralString', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['ReadOnly', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true
            }], ['TypeIs', {
              alias: '',
              module: 'builtins',
              implicitBaseClass: 'bool',
              isSpecialForm: true,
              typeParamVariance: 2
            }], ['TypeForm', {
              alias: '',
              module: 'builtins',
              isSpecialForm: true,
              typeParamVariance: 3,
              isIllegalInIsinstance: true
            }]]).get(a);
            if (r) {
              const n = Ne(e, 0);
              if (n) {
                return n;
              }
              let s = ra(e, a, r);
              if (a === 'LiteralString') {
                s.shared.baseClasses.push((t = Ae == null ? undefined : Ae.strClass) !== null && t !== undefined ? t : H.AnyType.create());
                Z.computeMroLinearization(s);
                if (Zr(e)) {
                  s = H.TypeBase.cloneWithTypeForm(s, Z.convertToInstance(s));
                }
              }
              if (a === 'Never' || a === 'NoReturn') {
                s = H.TypeBase.cloneAsSpecialForm(a === 'Never' ? H.NeverType.createNever() : H.NeverType.createNoReturn(), s);
                if (Zr(e)) {
                  s = H.TypeBase.cloneWithTypeForm(s, Z.convertToInstance(s));
                }
              }
              Fe(e, {
                type: s
              }, 0);
              return s;
            }
            return;
          }(e);
          if (t) {
            return t;
          }
        }
        const i = t ? {
          ...t
        } : {};
        i.typeExpression = true;
        i.convertEllipsisToAny = true;
        if (((n = e == null ? undefined : e.parent) === null || n === undefined ? undefined : n.nodeType) === 3 && e.parent.d.annotationComment === e) {
          i.forwardRefs = true;
          i.notParsed = true;
        } else {
          if (((a = e == null ? undefined : e.parent) === null || a === undefined ? undefined : a.nodeType) === 62) {
            if (e.parent.d.returnAnnotation === e || e.parent.d.paramAnnotations.some(t => t === e)) {
              i.forwardRefs = true;
              i.notParsed = true;
            }
          } else {
            if (((r = e == null ? undefined : e.parent) === null || r === undefined ? undefined : r.nodeType) === 41 && e.parent.d.annotationComment === e) {
              i.forwardRefs = true;
              i.notParsed = true;
            }
          }
        }
        const o = Ha(e, i).type;
        if (H.isModule(o)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.moduleAsType(), e);
        }
        return Z.convertToInstance(o);
      }
      function Ye(e, t = 0) {
        e = Pt(e);
        if (t > H.maxTypeRecursionCount) {
          return true;
        }
        t++;
        switch (e.category) {
          case 0:
          case 1:
          case 2:
          case 3:
            return true;
          case 8:
            return H.findSubtype(e, e => Ye(e, t)) !== undefined;
          case 4:
          case 5:
          case 7:
          case 9:
            return false;
          case 6:
            {
              if (H.TypeBase.isInstantiable(e)) {
                return false;
              }
              if (Z.isTupleClass(e) && e.priv.tupleTypeArgs) {
                return Z.isUnboundedTupleClass(e) || e.priv.tupleTypeArgs.length === 0;
              }
              const n = e.shared.mro.find(e => !H.isClass(e) || Z.isTupleClass(e));
              if (n && H.isClass(n) && n.priv.tupleTypeArgs) {
                return Z.isUnboundedTupleClass(n) || n.priv.tupleTypeArgs.length === 0;
              }
              if (H.ClassType.isTypedDictClass(e)) {
                const t = W.getTypedDictMembersForClass(es, e, true);
                if (t) {
                  for (const e of t.knownItems.values()) {
                    if (e.isRequired || e.isProvided) {
                      return false;
                    }
                  }
                }
              }
              if (e.priv.literalValue !== undefined) {
                if (H.ClassType.isBuiltIn(e, ['bool', 'int', 'str', 'bytes'])) {
                  return !e.priv.literalValue || e.priv.literalValue === BigInt(0);
                }
                if (e.priv.literalValue instanceof H.EnumLiteral && e.priv.literalValue.isReprEnum) {
                  return Ye(e.priv.literalValue.itemType, t);
                }
              }
              if (H.ClassType.isProtocolClass(e)) {
                return true;
              }
              if (Z.lookUpObjectMember(e, '__len__')) {
                return true;
              }
              const a = Z.lookUpObjectMember(e, '__bool__');
              if (a) {
                const e = Tr(a);
                if (H.isFunction(e) && e.shared.declaredReturnType) {
                  const t = e.shared.declaredReturnType;
                  if (H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'bool') && t.priv.literalValue === true) {
                    return false;
                  }
                }
                return true;
              }
              return H.ClassType.isBuiltIn(e, 'object');
            }
        }
      }
      function Je(e, t = 0) {
        e = Pt(e);
        if (t > H.maxTypeRecursionCount) {
          return true;
        }
        t++;
        switch (e.category) {
          case 1:
          case 4:
          case 5:
          case 7:
          case 9:
          case 3:
          case 2:
            return true;
          case 8:
            return H.findSubtype(e, e => Je(e, t)) !== undefined;
          case 0:
            return false;
          case 6:
            {
              if (H.TypeBase.isInstantiable(e)) {
                return true;
              }
              if (Z.isNoneInstance(e)) {
                return false;
              }
              if (e.priv.tupleTypeArgs && e.priv.tupleTypeArgs.length === 0) {
                return false;
              }
              if (e.priv.literalValue !== undefined) {
                if (H.ClassType.isBuiltIn(e, ['bool', 'int', 'str', 'bytes'])) {
                  return !!e.priv.literalValue && e.priv.literalValue !== BigInt(0);
                }
                if (e.priv.literalValue instanceof H.EnumLiteral && e.priv.literalValue.isReprEnum) {
                  return Je(e.priv.literalValue.itemType, t);
                }
              }
              if (H.ClassType.isProtocolClass(e)) {
                return true;
              }
              const n = Z.lookUpObjectMember(e, '__bool__');
              if (n) {
                const e = Tr(n);
                if (H.isFunction(e) && e.shared.declaredReturnType) {
                  const t = e.shared.declaredReturnType;
                  if (H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'bool') && t.priv.literalValue === false) {
                    return false;
                  }
                }
              }
              return true;
            }
        }
      }
      function Qe(e) {
        return Z.mapSubtypes(e, e => H.isClassInstance(e) && H.ClassType.isBuiltIn(e, ['TypeGuard', 'TypeIs']) ? (Ae == null ? undefined : Ae.boolClass) ? Z.convertToInstance(Ae.boolClass) : H.UnknownType.create() : e);
      }
      function Xe(e, t, n, a) {
        const r = I.solveConstraints(es, t, a);
        return Z.applySolvedTypeVars(e, r, n);
      }
      function et(e, t, n, a = {
        method: 'get'
      }, r = undefined, s = 0, i, o = 0) {
        if (H.ClassType.isPartiallyEvaluated(t)) {
          if (e) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.classDefinitionCycle().format({
              name: t.shared.name
            }), e);
          }
          return {
            type: H.UnknownType.create()
          };
        }
        if (H.isInstantiableClass(t) && !t.priv.includeSubclasses && t.shared.typeParams.length > 0) {
          if (!(s & 512)) {
            t = Z.specializeWithDefaultTypeArgs(t);
          }
        }
        const l = H.TypeBase.isInstantiable(t);
        const c = t.shared.effectiveMetaclass;
        let u;
        let m;
        let y = l && !!(s & 16);
        if (a.method === 'get' && l && c && H.isInstantiableClass(c) && !H.ClassType.isBuiltIn(c, 'type') && !H.ClassType.isSameGenericClass(c, t)) {
          const r = jt(e, c, n, a, undefined, s | 512, t, o);
          if (r) {
            const e = H.isClassInstance(r.type) && H.ClassType.isPropertyClass(r.type);
            if (Z.isDescriptorInstance(r.type, true) || e) {
              y = true;
            }
          }
        }
        if (!y) {
          let d = s;
          if (l) {
            d |= 1552;
            d &= -33;
          } else {
            d |= 128;
          }
          m = r ? new p.DiagnosticAddendum() : undefined;
          u = jt(e, t, n, a, m, d, i, o);
        }
        if (!u && c && H.isInstantiableClass(c)) {
          let i = s;
          if (!l) {
            i |= 552;
            i &= -17;
          }
          const d = r ? new p.DiagnosticAddendum() : undefined;
          u = jt(e, H.ClassType.cloneAsInstance(c), n, a, d, i, l ? t : H.ClassType.cloneAsInstantiable(t), o);
          if (u == null ? undefined : u.isDescriptorError) {
            m = d;
          }
        }
        if (u) {
          if (u.isDescriptorError && r && m) {
            r.addAddendum(m);
          }
          return {
            type: u.type,
            classType: u.classType,
            isIncomplete: !!u.isTypeIncomplete,
            isAsymmetricAccessor: u.isAsymmetricAccessor,
            narrowedTypeForSet: u.narrowedTypeForSet,
            memberAccessDeprecationInfo: u.memberAccessDeprecationInfo,
            typeErrors: u.isDescriptorError
          };
        }
        if (H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'type') && t.priv.includeSubclasses && !(s & 520)) {
          const e = t.priv.typeArgs && t.priv.typeArgs.length >= 1 ? t.priv.typeArgs[0] : H.UnknownType.create();
          if (H.isAnyOrUnknown(e)) {
            return {
              type: e,
              classType: H.UnknownType.create()
            };
          }
        }
        if (r && m) {
          r.addAddendum(m);
        }
      }
      function tt(e, t, n, a, r = 0) {
        const s = et(undefined, e, t, undefined, a, 528, n, r);
        if (s && !s.typeErrors) {
          if (H.isFunction(s.type) || H.isOverloaded(s.type)) {
            return s.type;
          }
          if (H.isClassInstance(s.type)) {
            if (r > H.maxTypeRecursionCount) {
              return;
            }
            r++;
            return tt(s.type, '__call__', n ?? H.ClassType.cloneAsInstance(e), a, r);
          }
          if (H.isAnyOrUnknown(s.type)) {
            return Z.getUnknownTypeForCallable();
          } else {
            return undefined;
          }
        }
      }
      function nt(e) {
        var t;
        var n;
        const a = e.shared.parameters.findIndex(e => e.category === 2);
        if (a < 0) {
          return e;
        }
        l.assert(a === e.shared.parameters.length - 1);
        const r = H.FunctionType.getParamType(e, a);
        if (!H.isClassInstance(r) || !H.ClassType.isTypedDictClass(r) || !r.priv.isUnpacked) {
          return e;
        }
        const s = (t = r.priv.typedDictNarrowedEntries) !== null && t !== undefined ? t : (n = r.shared.typedDictEntries) === null || n === undefined ? undefined : n.knownItems;
        if (!s) {
          return e;
        }
        const i = H.FunctionType.clone(e);
        i.shared.parameters.splice(a);
        if (i.priv.specializedTypes) {
          i.priv.specializedTypes.parameterTypes.splice(a);
        }
        if (e.shared.parameters.findIndex(e => e.category === 1) < 0 && s.size > 0) {
          H.FunctionType.addKeywordOnlyParamSeparator(i);
        }
        s.forEach((e, t) => {
          H.FunctionType.addParam(i, H.FunctionParam.create(0, e.valueType, H.FunctionParamFlags.TypeDeclared, t, e.isRequired ? undefined : e.valueType));
        });
        return i;
      }
      function at(e, t) {
        var n;
        var a;
        let r;
        let s;
        let i;
        let o;
        let l = true;
        let p = false;
        switch (e.nodeType) {
          case 38:
            {
              const t = Ja(e, e.d.value, true);
              if (t && (r = t.symbol, !((n = yr(r, e)) === null || n === undefined ? undefined : n.type) && t.scope.type === 3)) {
                const t = M.getEnclosingClassOrFunction(e);
                if (t && t.nodeType === 10) {
                  const n = ca(t);
                  if (n) {
                    const t = Z.lookUpClassMember(n.classType, e.d.value, 80);
                    if (t) {
                      r = t.symbol;
                    }
                  }
                }
              }
              break;
            }
          case 54:
            return at(e.d.valueExpr, t);
          case 35:
            {
              const t = qe(e.d.leftExpr, 2).type;
              const n = Pt(t);
              let a;
              if (H.isClassInstance(n)) {
                a = Z.lookUpObjectMember(n, e.d.member.d.value, 64);
                i = n;
                o = a == null ? undefined : a.classType;
                if (a == null ? undefined : a.isInstanceMember) {
                  l = false;
                }
                p = true;
              } else {
                if (H.isInstantiableClass(n)) {
                  a = Z.lookUpClassMember(n, e.d.member.d.value, 80);
                  i = n;
                  o = a == null ? undefined : a.classType;
                }
              }
              if (H.isTypeVar(t)) {
                s = t;
              }
              if (a) {
                r = a.symbol;
              }
              break;
            }
          case 27:
            {
              const n = Pt(qe(e.d.leftExpr, 2).type);
              if (n && H.isClassInstance(n)) {
                const a = tt(n, '__setitem__');
                if (a && H.isFunction(a) && a.shared.parameters.length >= 2) {
                  const e = H.FunctionType.getParamType(a, 1);
                  if (!H.isAnyOrUnknown(e)) {
                    return e;
                  }
                } else {
                  if (H.ClassType.isTypedDictClass(n)) {
                    const a = W.getTypeOfIndexedTypedDict(es, e, n, t || {
                      method: 'get'
                    });
                    if (a) {
                      return a.type;
                    }
                  }
                }
              }
              break;
            }
        }
        if (r) {
          let e = (a = yr(r)) === null || a === undefined ? undefined : a.type;
          if (e) {
            if (p && H.isClassInstance(e)) {
              const t = tt(e, '__set__');
              if (t && H.isFunction(t) && t.shared.parameters.length >= 2 && (e = H.FunctionType.getParamType(t, 1), H.isAnyOrUnknown(e))) {
                return;
              }
            }
            if (i) {
              if (o && H.isInstantiableClass(o)) {
                e = Z.partiallySpecializeType(e, o, dt(), s);
              }
              if ((H.isFunction(e) || H.isOverloaded(e)) && l) {
                e = Ur(i, e, undefined, undefined, s);
              }
            }
            return e;
          }
        }
      }
      function rt(e, t) {
        if (!(Ae == null ? undefined : Ae.awaitableClass) || !H.isInstantiableClass(Ae.awaitableClass) || Ae.awaitableClass.shared.typeParams.length !== 1) {
          return H.UnknownType.create();
        }
        const n = H.ClassType.cloneAsInstance(Ae.awaitableClass);
        return Z.mapSubtypes(e, e => {
          e = Pt(e);
          if (H.isAnyOrUnknown(e)) {
            return e;
          }
          const a = t ? new p.DiagnosticAddendum() : undefined;
          if (H.isClassInstance(e)) {
            const t = new k.ConstraintTracker();
            if (Ir(n, e, a, t)) {
              const e = Xe(n, t);
              if (H.isClass(e) && e.priv.typeArgs && e.priv.typeArgs.length > 0) {
                return e.priv.typeArgs[0];
              } else {
                return H.UnknownType.create();
              }
            }
          }
          if (t) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeNotAwaitable().format({
              type: Yr(e)
            }) + (a == null ? undefined : a.getString()), t);
          }
          return H.UnknownType.create();
        });
      }
      function st(e, t, n, a = true) {
        const r = t ? '__aiter__' : '__iter__';
        const s = t ? '__anext__' : '__next__';
        let i = true;
        let o = Z.transformPossibleRecursiveTypeAlias(e.type);
        o = Pt(o);
        o = H.removeUnbound(o);
        if (Z.isOptionalType(o) && a) {
          if (!e.isIncomplete) {
            kt(d.DiagnosticRule.reportOptionalIterable, g.LocMessage.noneNotIterable(), n);
          }
          o = Z.removeNoneFromUnion(o);
        }
        const l = Z.mapSubtypes(o, o => {
          o = Pt(o);
          if (H.isAnyOrUnknown(o)) {
            return o;
          }
          const u = new p.DiagnosticAddendum();
          if (H.isClass(o)) {
            if (H.TypeBase.isInstance(o) && Z.isTupleClass(o) && o.priv.tupleTypeArgs && o.priv.tupleTypeArgs.length === 0) {
              return H.NeverType.createNever();
            }
            const e = Pn(o, r, [], n)?.type;
            if (e) {
              const a = new p.DiagnosticAddendum();
              const r = Dt(e, undefined, e => {
                var r;
                if (H.isAnyOrUnknown(e)) {
                  return e;
                }
                let i = (r = Pn(e, s, [], n)) === null || r === undefined ? undefined : r.type;
                if (i) {
                  i = Z.mapSubtypes(i, e => H.isTypeVar(e) && H.isUnpackedTypeVarTuple(e) ? lt() : e);
                  if (t) {
                    return rt(i, n);
                  } else {
                    return i;
                  }
                }
                a.addMessage(g.LocMessage.methodNotDefinedOnType().format({
                  name: s,
                  type: Yr(e)
                }));
              });
              if (a.isEmpty()) {
                return r;
              }
              u.addAddendum(a);
            } else {
              if (!t && H.isClassInstance(o)) {
                const e = Pn(o, '__getitem__', [{
                  type: (Ae == null ? undefined : Ae.intClass) && H.isInstantiableClass(Ae.intClass) ? H.ClassType.cloneAsInstance(Ae.intClass) : H.UnknownType.create()
                }], n)?.type;
                if (e) {
                  return e;
                }
              }
              u.addMessage(g.LocMessage.methodNotDefined().format({
                name: r
              }));
            }
          }
          if (!e.isIncomplete && a) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeNotIterable().format({
              type: Yr(o)
            }) + u.getString(), n);
          }
          i = false;
        });
        if (i) {
          return {
            type: l,
            isIncomplete: e.isIncomplete
          };
        } else {
          return undefined;
        }
      }
      function it(e, t, n, a = true) {
        const r = t ? '__aiter__' : '__iter__';
        let s = true;
        let i = Pt(e.type);
        if (Z.isOptionalType(i)) {
          if (!e.isIncomplete && a) {
            kt(d.DiagnosticRule.reportOptionalIterable, g.LocMessage.noneNotIterable(), n);
          }
          i = Z.removeNoneFromUnion(i);
        }
        const o = Z.mapSubtypes(i, e => {
          if (H.isAnyOrUnknown(e)) {
            return e;
          }
          if (H.isClass(e)) {
            const a = Pn(e, r, [], n)?.type;
            if (a) {
              return Pt(a);
            }
          }
          if (a) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeNotIterable().format({
              type: Yr(e)
            }), n);
          }
          s = false;
        });
        if (s) {
          return {
            type: o,
            isIncomplete: e.isIncomplete
          };
        } else {
          return undefined;
        }
      }
      function ot() {
        if ((Ae == null ? undefined : Ae.tupleClass) && H.isInstantiableClass(Ae.tupleClass)) {
          return Ae.tupleClass;
        } else {
          return undefined;
        }
      }
      function lt() {
        if (Ae == null ? undefined : Ae.objectClass) {
          return Z.convertToInstance(Ae.objectClass);
        } else {
          return H.UnknownType.create();
        }
      }
      function pt() {
        if (Ae == null ? undefined : Ae.noneTypeClass) {
          return Z.convertToInstance(Ae.noneTypeClass);
        } else {
          return H.UnknownType.create();
        }
      }
      function dt() {
        if ((Ae == null ? undefined : Ae.typeClass) && H.isInstantiableClass(Ae.typeClass)) {
          return Ae.typeClass;
        }
      }
      function ct(e, t) {
        var n;
        if ((n = mt(e, t, ['typing'])) !== null && n !== undefined) {
          return n;
        } else {
          return mt(e, t, ['typing_extensions']);
        }
      }
      function ut(e, t) {
        return mt(e, t, ['_typeshed']);
      }
      function mt(t, n, a) {
        const r = v.getFileInfo(t);
        const s = e({
          nameParts: a,
          importingFileUri: r.fileUri
        });
        if (!s) {
          return;
        }
        const i = s.symbolTable.get(n);
        if (i) {
          return cr(i);
        } else {
          return undefined;
        }
      }
      function yt(e) {
        const n = e.nodeType === 31 ? e : M.getExecutionScopeNode(e);
        if (v.getCodeFlowComplexity(n) > exports.maxCodeComplexity) {
          let t = n;
          if (n.nodeType === 31) {
            t = n.d.name;
          } else {
            if (n.nodeType === 36) {
              t = {
                start: 0,
                length: 0
              };
            }
          }
          wt(v.getFileInfo(e), d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.codeTooComplexToAnalyze(), t);
          return true;
        }
        return false;
      }
      function gt(e, t) {
        return ft(e, t) === K.Reachability.Reachable;
      }
      function ht(e) {
        return Tt(e) === K.Reachability.Reachable;
      }
      function ft(e, t) {
        if (yt(e)) {
          return K.Reachability.Reachable;
        }
        const n = v.getFlowNode(e);
        if (!n) {
          if (e.parent) {
            return ft(e.parent, t);
          } else {
            return K.Reachability.UnreachableAlways;
          }
        }
        const a = t ? v.getFlowNode(t) : undefined;
        return ts.getFlowNodeReachability(n, a);
      }
      function Tt(e) {
        const t = v.getAfterFlowNode(e);
        if (!t) {
          return K.Reachability.UnreachableAlways;
        }
        if (yt(e)) {
          return K.Reachability.Reachable;
        }
        const n = ts.getFlowNodeReachability(t);
        if (n !== K.Reachability.Reachable) {
          return n;
        } else {
          if (function (e, t) {
            const n = ja(e.id, undefined);
            if (yt(e)) {
              return true;
            }
            const a = n.getTypeFromCodeFlow(t, undefined, {
              typeAtStart: {
                type: H.UnboundType.create()
              }
            });
            return a.type !== undefined && !H.isNever(a.type);
          }(e, t)) {
            return K.Reachability.Reachable;
          } else {
            return K.Reachability.UnreachableByAnalysis;
          }
        }
      }
      function vt(e, t, n = true) {
        if (yt(e)) {
          return true;
        }
        const a = v.getFlowNode(e);
        const r = v.getFlowNode(t);
        return !!a && !!r && (a === r ? n : ts.getFlowNodeReachability(r, a, true) === K.Reachability.Reachable);
      }
      function bt(e, t, n) {
        return _t('information', e, t, n);
      }
      function _t(e, t, n, a) {
        var r;
        if (Ct(n)) {
          const e = me.find(e => M.isNodeContainedWithin(n, e.node) && e.suppressedDiags);
          if ((r = e == null ? undefined : e.suppressedDiags) !== null && r !== undefined) {
            r.push(t);
          }
        } else {
          if (gt(n)) {
            return v.getFileInfo(n).diagnosticSink.addDiagnosticWithTextRange(e, t, a ?? n);
          }
        }
      }
      function Ct(e) {
        return !!ue.isSpeculative(e, true) || me.some(t => M.isNodeContainedWithin(e, t.node));
      }
      function It(e) {
        if (ue.isSpeculative(e, true)) {
          return true;
        }
        const t = me.filter(t => M.isNodeContainedWithin(e, t.node));
        return t.length !== 0 && t.every(e => !e.suppressedDiags);
      }
      function kt(e, t, n, a) {
        const r = v.getFileInfo(n).diagnosticRuleSet[e];
        if (r === 'none') {
          return;
        }
        const s = M.getEnclosingFunction(n);
        if (s) {
          if (!v.getFileInfo(n).diagnosticRuleSet.analyzeUnannotatedFunctions && M.isUnannotatedFunction(s) && M.isNodeContainedWithin(n, s.d.suite)) {
            return;
          }
          const e = M.getEnclosingClass(s, true);
          if (x.getFunctionInfoFromDecorators(es, s, !!e).flags & 524288) {
            return;
          }
        }
        const i = _t(r, t, n, a);
        if (i) {
          i.setRule(e);
        }
        return i;
      }
      function wt(e, t, n, a) {
        const r = e.diagnosticRuleSet[t];
        if (r === 'none') {
          return;
        }
        const s = e.diagnosticSink.addDiagnosticWithTextRange(r, n, a);
        if (t) {
          s.setRule(t);
        }
        return s;
      }
      function St(e, t, n, a, r = false, s) {
        var i;
        var o;
        var l;
        const c = e.d.value;
        const u = Ja(e, c, false);
        if (!u) {
          return;
        }
        const m = u.symbol.getDeclarations();
        let y = (i = yr(u.symbol)) === null || i === undefined ? undefined : i.type;
        const h = v.getFileInfo(e);
        if (y === undefined && u.scope.type === 3) {
          const t = M.getEnclosingClass(e);
          if (t) {
            const n = ca(t);
            if (n) {
              const t = Z.lookUpClassMember(n.classType, e.d.value, 1);
              if (t == null ? undefined : t.isTypeDeclared) {
                y = Tr(t);
              }
            }
          }
        }
        let f = t.type;
        const T = !!y && H.isClassInstance(y) && H.ClassType.isBuiltIn(y, 'TypeAlias');
        if (y && !T) {
          let n = new p.DiagnosticAddendum();
          const r = M.getTypeVarScopesForNode(e);
          if (Ir(Z.makeTypeVarsBound(y, r), Z.makeTypeVarsBound(t.type, r), n)) {
            f = Er(e, y, t).type;
          } else {
            if (s) {
              n = s;
            }
            if (!t.isIncomplete) {
              kt(d.DiagnosticRule.reportAssignmentType, g.LocMessage.typeAssignmentMismatch().format(Hr(t.type, y)) + n.getString(), a ?? e, (l = (o = n.getEffectiveTextRange()) !== null && o !== undefined ? o : a) !== null && l !== undefined ? l : e);
            }
            f = y;
          }
        } else {
          const t = V.getScopeForNode(e);
          if ((t == null ? undefined : t.type) === 3) {
            if (!!H.TypeBase.isInstance(f) && !B.isConstantName(c) && !Rr(u.symbol)) {
              f = Z.stripTypeForm($e(f));
            }
          }
        }
        const b = m.findIndex(e => e.type === 1);
        const _ = b >= 0 ? m[b] : undefined;
        const C = m.find((e, t) => b < t && e.type !== 1);
        if (_ && _.type === 1) {
          if (_.isConstant) {
            if (e !== A.getNameNodeForDeclaration(m[0]) || C) {
              kt(d.DiagnosticRule.reportConstantRedefinition, g.LocMessage.constantRedefinition().format({
                name: c
              }), e);
            }
          } else {
            if (Lr(_) && !r) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.finalReassigned().format({
                name: c
              }), e);
            }
          }
        }
        if (!t.isIncomplete) {
          Un(h.diagnosticRuleSet.reportUnknownVariableType, d.DiagnosticRule.reportUnknownVariableType, e, f, e, n);
        }
        Fe(e, {
          type: f,
          isIncomplete: t.isIncomplete
        }, 0);
      }
      function At(e, t, n, a) {
        var r;
        const i = qe(e.d.leftExpr, 2);
        const o = Pt(i.type);
        let l;
        if (e.d.leftExpr.nodeType === 38) {
          const a = M.getEnclosingClass(e);
          if (a) {
            const r = ca(a);
            if (r && H.isInstantiableClass(r.classType) && (l = r.classType, H.isClassInstance(o) ? H.ClassType.isSameGenericClass(H.ClassType.cloneAsInstantiable(o), r.classType) && xt(e, t, true, n) : H.isInstantiableClass(o) && H.ClassType.isSameGenericClass(o, r.classType) && xt(e, t, false, n), H.ClassType.isProtocolClass(r.classType))) {
              const t = H.ClassType.getSymbolTable(r.classType).get(e.d.member.d.value);
              if (t) {
                if (t.getDeclarations().filter(e => !M.getEnclosingFunction(e.node)).length === 0) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.assignmentInProtocol(), e.d.member);
                }
              }
            }
          }
        }
        const p = Bt(e, i, {
          method: 'set',
          setType: t,
          setErrorNode: n,
          setExpectedTypeDiag: a
        }, 0);
        var c;
        if (p.isAsymmetricAccessor) {
          c = e;
          if (!ar(undefined)) {
            s.add(c.id);
          }
        }
        const u = {
          type: (r = p.narrowedTypeForSet) !== null && r !== undefined ? r : t.type,
          isIncomplete: t.isIncomplete,
          memberAccessDeprecationInfo: p.memberAccessDeprecationInfo
        };
        Fe(e, u, 0);
        let m = u;
        if (l == null ? undefined : l.shared.typeVarScopeId) {
          m = {
            ...u,
            type: Z.makeTypeVarsFree(u.type, [l.shared.typeVarScopeId]),
            memberAccessDeprecationInfo: p.memberAccessDeprecationInfo
          };
        }
        Fe(e.d.member, m, 0);
      }
      function xt(e, t, n, a) {
        var r;
        const s = e.d.member.d.value;
        const i = v.getFileInfo(e);
        const o = M.getEnclosingClass(e);
        if (!o) {
          return;
        }
        const p = ca(o);
        if (p && H.isInstantiableClass(p.classType)) {
          let o = Z.lookUpClassMember(p.classType, s, n ? 0 : 16);
          const c = H.ClassType.getSymbolTable(p.classType);
          if (o) {
            const u = H.isInstantiableClass(o.classType) ? o.classType : undefined;
            const m = u && H.ClassType.isSameGenericClass(p.classType, u);
            if (m && n && u) {
              const t = H.ClassType.getInheritedSlotsNames(u);
              if (t && u.shared.localSlotsNames && (u.shared.localSlotsNames.length > 0 || H.ClassType.isFinal(u)) && !t.some(e => e === s)) {
                const t = Z.lookUpClassMember(u, s, 16);
                let n = false;
                if (t) {
                  const e = cr(t.symbol);
                  if (H.isAnyOrUnknown(e) || H.isUnbound(e) || Z.isMaybeDescriptorInstance(e)) {
                    n = true;
                  }
                }
                if (!n) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.slotsAttributeError().format({
                    name: s
                  }), e.d.member);
                }
              }
            }
            if (m && o.isInstanceMember === n) {
              const t = c.get(s);
              l.assert(t !== undefined);
              const n = t.getDeclarations();
              if (n.length > 0 && n[0].type === 1 && a && e.d.member !== n[0].node && n[0].isConstant) {
                kt(d.DiagnosticRule.reportConstantRedefinition, g.LocMessage.constantRedefinition().format({
                  name: e.d.member.d.value
                }), e.d.member);
              }
            } else {
              const a = (r = yr(o.symbol)) === null || r === undefined ? undefined : r.type;
              if (a && !Z.isProperty(a) && !o.isInstanceMember && n) {
                Et(i, o.symbol, e.d.member);
                const n = Tr(o);
                t = {
                  ...t,
                  type: H.combineTypes([t.type, n])
                };
              }
            }
          }
          o = Z.lookUpClassMember(p.classType, s, 64);
          if (!o && !!a && !t.isIncomplete) {
            Un(i.diagnosticRuleSet.reportUnknownMemberType, d.DiagnosticRule.reportUnknownMemberType, e.d.member, t.type, e, true);
          }
        }
      }
      function Pt(e, t = false, n) {
        e = Z.transformPossibleRecursiveTypeAlias(e);
        return Z.mapSubtypes(e, e => {
          if (H.isParamSpec(e)) {
            if (e.priv.paramSpecAccess === 'args') {
              return q.makeTupleObject(es, [{
                type: lt(),
                isUnbounded: true
              }]);
            }
            if (e.priv.paramSpecAccess === 'kwargs') {
              if ((Ae == null ? undefined : Ae.dictClass) && H.isInstantiableClass(Ae.dictClass) && (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass)) {
                return H.ClassType.cloneAsInstance(H.ClassType.specialize(Ae.dictClass, [Z.convertToInstance(Ae.strClass), lt()]));
              } else {
                return H.UnknownType.create();
              }
            }
          }
          if (t && H.isFunction(e)) {
            const t = Z.simplifyFunctionToParamSpec(e);
            if (H.isParamSpec(t)) {
              return H.ParamSpecType.getUnknown();
            }
          }
          if (H.isTypeVarTuple(e)) {
            if (e.priv.isInUnion) {
              if (H.TypeBase.isInstantiable(e)) {
                if ((Ae == null ? undefined : Ae.typeClass) && H.isInstantiableClass(Ae.typeClass)) {
                  return Ae.typeClass;
                } else {
                  return H.AnyType.create();
                }
              } else {
                return lt();
              }
            } else {
              return q.makeTupleObject(es, [{
                type: lt(),
                isUnbounded: true
              }], true);
            }
          }
          if (H.isTypeVar(e)) {
            if (e.shared.recursiveAlias) {
              return e;
            }
            if (H.TypeVarType.hasConstraints(e)) {
              const t = [];
              e.shared.constraints.forEach((a, r) => {
                if (n) {
                  const t = H.TypeVarType.getNameWithScope(e);
                  const a = n.find(e => e.typeVar.priv.nameWithScope === t);
                  if (a && a.constraintIndex !== r) {
                    return;
                  }
                }
                if (H.TypeBase.isInstantiable(e)) {
                  a = Z.convertToInstantiable(a);
                }
                t.push(Z.addConditionToType(a, [{
                  typeVar: e,
                  constraintIndex: r
                }]));
              });
              return H.combineTypes(t);
            }
            if (e.shared.isExemptFromBoundCheck) {
              return H.AnyType.create();
            }
            let t = e.shared.boundType ?? lt();
            if (H.TypeVarType.isSelf(e) && H.isClass(t) && !H.ClassType.isPseudoGenericClass(t)) {
              t = Z.selfSpecializeClass(t, {
                useBoundTypeVars: H.TypeVarType.isBound(e)
              });
            }
            if (e.priv.isUnpacked && H.isClass(t)) {
              t = H.ClassType.cloneForUnpacked(t);
            }
            t = H.TypeBase.isInstantiable(e) ? Z.convertToInstantiable(t) : t;
            return Z.addConditionToType(t, [{
              typeVar: e,
              constraintIndex: 0
            }]);
          }
          return e;
        });
      }
      function Dt(e, t, n, a = 0) {
        const r = [];
        let s = false;
        function i(e, i) {
          let o = H.isUnion(e) ? e : Pt(e);
          o = Z.transformPossibleRecursiveTypeAlias(o);
          if (t == null ? undefined : t.expandCallback) {
            o = t.expandCallback(o);
          }
          Z.doForEachSubtype(o, (o, l, p) => {
            var d;
            if (t == null ? undefined : t.conditionFilter) {
              const e = function (e, t, n) {
                if (n > H.maxTypeRecursionCount) {
                  return e;
                }
                n++;
                if (!H.TypeCondition.isCompatible(Z.getTypeCondition(e), t)) {
                  return;
                }
                if (H.isClass(e) && e.priv.typeArgs && !e.priv.tupleTypeArgs) {
                  ya(e);
                  let a = false;
                  const r = e.priv.typeArgs.map((r, s) => {
                    if (s >= e.shared.typeParams.length) {
                      return r;
                    }
                    if (H.TypeVarType.getVariance(e.shared.typeParams[s]) !== 3) {
                      return r;
                    }
                    if (H.isTypeVar(r) && r.shared.recursiveAlias) {
                      return r;
                    }
                    const i = Dt(r, {
                      conditionFilter: t
                    }, e => e, n);
                    if (i !== r) {
                      a = true;
                    }
                    return i;
                  });
                  if (a) {
                    return H.ClassType.specialize(e, r);
                  }
                }
                return e;
              }(o, t.conditionFilter, a);
              if (!e) {
                return;
              }
              o = e;
            }
            let c = n(o, e, i && l === p.length - 1);
            if (c !== e) {
              s = true;
            }
            if (c) {
              const e = (d = Z.getTypeCondition(o)) === null || d === undefined ? undefined : d.filter(e => H.TypeVarType.hasConstraints(e.typeVar));
              if (e && e.length > 0) {
                c = Z.addConditionToType(c, e);
              }
              if (r.length === 0 || !H.isTypeSame(c, r[r.length - 1])) {
                r.push(c);
              }
            }
          }, t == null ? undefined : t.sortSubtypes);
        }
        if (H.isUnion(e)) {
          ((t == null ? undefined : t.sortSubtypes) ? Z.sortTypes(e.priv.subtypes) : e.priv.subtypes).forEach((t, n) => {
            i(t, n === e.priv.subtypes.length - 1);
          });
        } else {
          i(e, true);
        }
        if (!s) {
          return e;
        }
        const o = H.combineTypes(r);
        if (o.category === 8) {
          H.UnionType.addTypeAliasSource(o, e);
        }
        return o;
      }
      function Nt(e, t, n, a = false, r = false, s) {
        if (H.isTypeVar(t.type) && n && n.nodeType === 9) {
          const a = qe(n.d.leftExpr, 2).type;
          if (H.isInstantiableClass(a) && (H.ClassType.isBuiltIn(a, 'TypeVar') || H.ClassType.isBuiltIn(a, 'TypeVarTuple') || H.ClassType.isBuiltIn(a, 'ParamSpec'))) {
            const n = e.nodeType === 54 ? e.d.valueExpr : e;
            if (n.nodeType !== 38 || n.d.value !== t.type.shared.name) {
              const e = H.TypeVarType.getReadableName(t.type);
              kt(d.DiagnosticRule.reportGeneralTypeIssues, H.isParamSpec(t.type) ? g.LocMessage.paramSpecAssignedName().format({
                name: e
              }) : g.LocMessage.typeVarAssignedName().format({
                name: e
              }), n);
            }
          }
        }
        if (H.findSubtype(t.type, e => H.isUnbound(e))) {
          t = {
            ...t,
            type: H.removeUnbound(t.type)
          };
        }
        switch (e.nodeType) {
          case 38:
            St(e, t, a, n, r, s);
            break;
          case 35:
            At(e, t, n, s);
            break;
          case 27:
            {
              const a = qe(e.d.leftExpr, 2);
              $t(e, a, {
                method: 'set',
                setType: t,
                setErrorNode: n,
                setExpectedTypeDiag: s
              }, 0);
              Fe(e, t, 0);
              break;
            }
          case 34:
          case 52:
            (function (e, t, n) {
              e.nodeType;
              const a = e.d.items;
              const r = new Array(a.length);
              for (let e = 0; e < a.length; e++) {
                r[e] = [];
              }
              const s = a.findIndex(e => e.nodeType === 56);
              const i = a.findIndex(e => e.nodeType === 56);
              t = {
                ...t,
                type: Pt(t.type)
              };
              const o = new p.DiagnosticAddendum();
              Z.doForEachSubtype(t.type, l => {
                const c = Z.getSpecializedTupleType(l);
                if (c && c.priv.tupleTypeArgs) {
                  const t = c.priv.tupleTypeArgs.map(e => Z.addConditionToType(e.type, Z.getTypeCondition(l), {
                    skipSelfCondition: true
                  }));
                  const n = c.priv.tupleTypeArgs.findIndex(e => e.isUnbounded);
                  if (n >= 0 && t.length < r.length) {
                    const e = t.length > 0 ? t[n] : H.AnyType.create();
                    while (t.length < r.length) {
                      t.splice(n, 0, e);
                    }
                  }
                  if (s >= 0) {
                    if (t.length > r.length) {
                      const n = t.splice(s, t.length - r.length + 1);
                      let a = H.combineTypes(n);
                      if (e.nodeType === 34) {
                        a = $e(a);
                      }
                      t.splice(s, 0, a);
                    } else {
                      if (t.length === r.length - 1) {
                        t.splice(s, 0, H.NeverType.createNever());
                      }
                    }
                  }
                  t.forEach((e, t) => {
                    if (t < r.length) {
                      r[t].push(e);
                    }
                  });
                  if (t.length !== a.length) {
                    const n = o.createAddendum();
                    n.addMessage((e.nodeType === 34 ? g.LocAddendum.listAssignmentMismatch() : g.LocAddendum.tupleAssignmentMismatch()).format({
                      type: Yr(l)
                    }));
                    n.createAddendum().addMessage((i >= 0 ? g.LocAddendum.tupleSizeMismatchIndeterminateDest() : g.LocAddendum.tupleSizeMismatch()).format({
                      expected: i >= 0 ? a.length - 1 : a.length,
                      received: t.length
                    }));
                  }
                } else {
                  const e = st({
                    type: l,
                    isIncomplete: t.isIncomplete
                  }, false, n)?.type ?? H.UnknownType.create();
                  for (let t = 0; t < a.length; t++) {
                    r[t].push(Z.addConditionToType(e, Z.getTypeCondition(l)));
                  }
                }
              });
              if (!o.isEmpty()) {
                kt(d.DiagnosticRule.reportAssignmentType, (e.nodeType === 34 ? g.LocMessage.listAssignmentMismatch() : g.LocMessage.tupleAssignmentMismatch()).format({
                  type: Yr(t.type)
                }) + o.getString(), e);
              }
              a.forEach((e, a) => {
                const s = r[a];
                Nt(e, {
                  type: s.length === 0 ? H.UnknownType.create() : H.combineTypes(s),
                  isIncomplete: t.isIncomplete
                }, n, true);
              });
              Fe(e, t, 0);
            })(e, t, n);
            break;
          case 54:
            {
              let i = Ze(e.d.annotation, {
                varTypeAnnotation: true,
                allowFinal: M.isFinalAllowedForAssignmentTarget(e.d.valueExpr),
                allowClassVar: M.isClassVarAllowedForAssignmentTarget(e.d.valueExpr)
              });
              if (i) {
                const t = M.getTypeVarScopesForNode(e);
                i = Z.makeTypeVarsBound(i, t);
              }
              if (!H.isClassInstance(i) || !H.ClassType.isBuiltIn(i, 'Final') && !H.ClassType.isBuiltIn(i, 'ClassVar')) {
                if (!H.isClassInstance(i) || !H.ClassType.isBuiltIn(i, 'TypeAlias')) {
                  if (Ir(i, t.type)) {
                    if (!H.isClassInstance(t.type) || !H.ClassType.isEnumClass(t.type)) {
                      t = Er(e, i, t);
                    }
                  }
                }
              }
              Nt(e.d.valueExpr, t, n, a, r, s);
              break;
            }
          case 56:
            if (e.d.expr.nodeType === 38) {
              St(e.d.expr, {
                type: Ya(e.d.expr, 'list', [t.type]),
                isIncomplete: t.isIncomplete
              }, a, n);
            }
            break;
          case 0:
            if (e.d.child) {
              Qa(e.d.child, () => {
                qe(e.d.child);
              });
            }
            break;
          default:
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.assignmentTargetExpr(), e);
        }
      }
      function Ft(e) {
        switch (e.nodeType) {
          case 38:
            qe(e);
            break;
          case 35:
            {
              const t = qe(e.d.leftExpr, 2);
              const n = Bt(e, t, {
                method: 'del'
              }, 0);
              const a = {
                type: n.type,
                memberAccessDeprecationInfo: n.memberAccessDeprecationInfo
              };
              Fe(e.d.member, a, 0);
              Fe(e, a, 0);
              break;
            }
          case 27:
            {
              const t = qe(e.d.leftExpr, 2);
              $t(e, t, {
                method: 'del'
              }, 0);
              Fe(e, {
                type: H.UnboundType.create()
              }, 0);
              break;
            }
          case 52:
            e.d.items.forEach(e => {
              Ft(e);
            });
            break;
          case 0:
            if (e.d.child) {
              Qa(e.d.child, () => {
                qe(e.d.child);
              });
            }
            break;
          default:
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.delTargetExpr(), e);
        }
      }
      function Et(e, t, n) {
        if (!ar(n)) {
          e.accessedSymbolSet.add(t.id);
        }
      }
      function Mt(e, t, n, a) {
        var r;
        var s;
        if (!Zr(e)) {
          return t;
        }
        const i = Ot(t, a);
        if ((r = t.props) === null || r === undefined ? undefined : r.typeForm) {
          if (n & 33554432 && !i) {
            t = H.TypeBase.cloneWithTypeForm(t, undefined);
          }
          return t;
        }
        if (!i) {
          return t;
        }
        if (H.isTypeVar(t) && t.priv.scopeId && !t.shared.isSynthesized) {
          if (!H.isTypeVarTuple(t) || !t.priv.isInUnion) {
            const n = M.getTypeVarScopesForNode(e);
            t = H.TypeBase.cloneWithTypeForm(t, Z.convertToInstance(Z.makeTypeVarsBound(t, n)));
          }
        } else {
          if (!!H.isInstantiableClass(t) && !t.priv.includeSubclasses && !H.ClassType.isSpecialBuiltIn(t)) {
            t = H.ClassType.isBuiltIn(t, 'Any') ? H.TypeBase.cloneWithTypeForm(t, H.AnyType.create()) : H.TypeBase.cloneWithTypeForm(t, H.ClassType.cloneAsInstance(Z.specializeWithDefaultTypeArgs(t)));
          }
        }
        if (((s = t.props) === null || s === undefined ? undefined : s.typeAliasInfo) && H.TypeBase.isInstantiable(t)) {
          let e = t;
          if (!(n & 2)) {
            e = Wt(e, undefined);
          }
          t = H.TypeBase.cloneWithTypeForm(t, Z.convertToInstance(e));
        }
        return t;
      }
      function Ot(e, t) {
        var n;
        return !t || !!((n = e.props) === null || n === undefined ? undefined : n.typeAliasInfo) || !!Z.isTypeAliasPlaceholder(e) || !!H.isTypeVar(e) || !!H.isClass(e) && !e.priv.includeSubclasses && !!H.ClassType.isValidTypeAliasClass(e);
      }
      function zt(e, t, n) {
        if (Ot(t, n)) {
          return t;
        }
        if (v.getFileInfo(e).isTypingStubFile) {
          return t;
        } else {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeAnnotationVariable(), e);
          return H.UnknownType.create();
        }
      }
      function Ut(e, t, n = false) {
        var a;
        var r;
        var s;
        var i;
        if (t & 33554816) {
          return e;
        } else {
          if (n && H.isModule(e) && (Ae == null ? undefined : Ae.moduleTypeClass) && H.isInstantiableClass(Ae.moduleTypeClass)) {
            return H.ClassType.cloneAsInstance(Ae.moduleTypeClass);
          } else {
            if (t & 536870912 && H.isUnion(e) && ((a = e.props) === null || a === undefined ? undefined : a.typeAliasInfo) && !e.props.typeAliasInfo.shared.isPep695Syntax) {
              return e;
            } else {
              if ((r = e.props) === null || r === undefined ? undefined : r.specialForm) {
                if (t & 2 && ((s = e.props) === null || s === undefined ? undefined : s.typeAliasInfo) && !H.ClassType.isBuiltIn(e.props.specialForm, 'TypeAliasType')) {
                  return e;
                } else {
                  if ((i = e.props) === null || i === undefined ? undefined : i.typeForm) {
                    return H.TypeBase.cloneWithTypeForm(e.props.specialForm, e.props.typeForm);
                  } else {
                    return e.props.specialForm;
                  }
                }
              } else {
                return e;
              }
            }
          }
        }
      }
      function Vt(e, t, n) {
        var a;
        if (!H.TypeBase.isInstantiable(t) || Z.isTypeAliasPlaceholder(t)) {
          return t;
        }
        if (!t.priv.scopeId) {
          t = function (e, t, n) {
            var a;
            const r = Lt(e, t);
            t = r.type;
            if (!!(n & 2048) && !!t.priv.scopeId) {
              if (t.shared.isSynthesized || H.isParamSpec(t)) {
                return t;
              }
              if (t.shared.isTypeParamSyntax) {
                return t;
              }
              const n = M.getTypeVarScopeNode(e);
              if (!n || !n.d.typeParams || !!n.d.typeParams.d.params.some(t => t.d.name === e)) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarUsedByOuterScope().format({
                  name: t.shared.name
                }), e);
              }
              return t;
            }
            if (n & 8192) {
              if (t.priv.scopeId) {
                return t;
              }
              if (r.foundInterveningClass) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarUsedByOuterScope().format({
                  name: t.shared.name
                }), e);
                return t;
              }
              let n = M.getEnclosingClassOrFunction(e);
              if (n && ((a = e.parent) === null || a === undefined ? undefined : a.nodeType) === 35 && e.parent.d.leftExpr === e) {
                const a = e.parent.d.member.d.value;
                if (a === 'args' || a === 'kwargs') {
                  const a = M.getEnclosingClassOrFunction(n);
                  if ((a == null ? undefined : a.nodeType) === 31) {
                    n = a;
                  } else {
                    if (!r.type.priv.scopeId) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecNotUsedByOuterScope().format({
                        name: t.shared.name
                      }), e);
                    }
                  }
                }
              }
              if (!n) {
                l.fail('AssociateTypeVarsWithCurrentScope flag was set but enclosing scope not found');
              }
              if (n.d.typeParams && !n.d.typeParams.d.params.some(e => e.d.name.d.value === t.shared.name)) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeParameterNotDeclared().format({
                  name: t.shared.name,
                  container: n.d.name.d.value
                }), e);
              }
              const s = M.getScopeIdForNode(n);
              return H.TypeVarType.cloneForScopeId(t, s, n.d.name.d.value, n.nodeType === 31 ? 1 : 0);
            }
            if (!(n & 4096)) {
              if (t.priv.scopeId && !r.foundInterveningClass) {
                return t;
              }
              if (!t.shared.isSynthesized && n & 128) {
                const n = H.isParamSpec(t) ? g.LocMessage.paramSpecNotUsedByOuterScope() : g.LocMessage.typeVarNotUsedByOuterScope();
                kt(d.DiagnosticRule.reportGeneralTypeIssues, n.format({
                  name: t.shared.name
                }), e);
              }
            }
            return t;
          }(e, t, n);
        }
        if (t.priv.scopeId && !H.TypeVarType.isBound(t)) {
          const n = (a = Lt(e, t)) === null || a === undefined ? undefined : a.scopeNode;
          if (n) {
            const a = M.getEnclosingClassOrFunctionSuite(e);
            if (a && M.isNodeContainedWithin(a, n)) {
              if (n.nodeType !== 10 || n.d.suite !== a) {
                t = H.TypeVarType.cloneAsBound(t);
              }
            }
          }
        }
        if (H.isUnpackedTypeVarTuple(t)) {
          t = H.TypeVarType.cloneForPacked(t);
        }
        if (n & -2147483648 && !function (e, t) {
          var n;
          var a;
          const r = (a = (n = t.priv.freeTypeVar) === null || n === undefined ? undefined : n.priv.scopeId) !== null && a !== undefined ? a : t.priv.scopeId;
          if (!r) {
            return true;
          }
          const s = M.getEnclosingClass(e);
          if (s) {
            if (!M.getTypeVarScopesForNode(s).includes(r)) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarInvalidForMemberVariable().format({
                name: H.TypeVarType.getReadableName(t)
              }), e);
              return false;
            }
          }
          return true;
        }(e, t)) {
          return H.UnknownType.create();
        } else {
          return t;
        }
      }
      function Rt(e, t, n) {
        var a;
        var r;
        if (!(n & 2)) {
          if (H.isInstantiableClass(t)) {
            if (n & 128 && !(n & 512) && !((a = t.props) === null || a === undefined ? undefined : a.typeAliasInfo) && Z.requiresTypeArgs(t)) {
              if (!t.priv.typeArgs || !t.priv.isTypeArgExplicit) {
                kt(d.DiagnosticRule.reportMissingTypeArgument, g.LocMessage.typeArgsMissingForClass().format({
                  name: t.priv.aliasName || t.shared.name
                }), e);
              }
            }
            if (!t.priv.typeArgs) {
              t = (r = Ga(t, undefined, n, e)) === null || r === undefined ? undefined : r.type;
            }
          }
          if (n & 128) {
            t = Wt(t, e);
          }
        }
        return t;
      }
      function Lt(e, t) {
        var n;
        var a;
        let r = e;
        let s = 0;
        for (l.assert(H.TypeBase.isInstantiable(t)); r;) {
          const e = M.getTypeVarScopeNode(r);
          if (!e) {
            break;
          }
          let n;
          r = e;
          let a = false;
          if (r.nodeType === 10) {
            const e = ca(r);
            if (e && !H.ClassType.isPartiallyEvaluated(e.classType)) {
              n = e.classType.shared.typeParams;
            }
            a = !!r.d.typeParams;
            s++;
          } else {
            if (r.nodeType === 31) {
              const e = ba(r);
              if (e) {
                n = e.shared.typeParams;
              }
              a = !!r.d.typeParams;
            } else {
              if (r.nodeType === 77) {
                a = !!r.d.typeParams;
              }
            }
          }
          if (n) {
            const r = n.find(e => e.shared.name === t.shared.name);
            if ((r == null ? undefined : r.priv.scopeId) !== undefined && r.priv.scopeName !== undefined && r.priv.scopeType !== undefined) {
              return {
                type: t = H.TypeVarType.cloneForScopeId(t, r.priv.scopeId, r.priv.scopeName, r.priv.scopeType),
                scopeNode: e,
                foundInterveningClass: s > 1 && !a
              };
            }
          }
          r = r.parent;
        }
        for (r = e; r;) {
          let s;
          let i;
          let o;
          if (r.nodeType === 77) {
            s = Ne(r.d.name, 0);
            i = r;
            o = r;
          } else {
            if (r.nodeType === 3) {
              s = Ne(r.d.leftExpr, 0);
              o = r;
            }
          }
          if (s && o && s && H.isTypeVar(s) && s.shared.recursiveAlias) {
            if (!i || t.shared.isTypeParamSyntax || ((n = t.props) === null || n === undefined ? undefined : n.typeAliasInfo)) {
              const e = (a = s.shared.recursiveAlias) === null || a === undefined ? undefined : a.typeParams;
              if (e && !e.some(e => e.shared.name === t.shared.name)) {
                return {
                  type: t,
                  scopeNode: o,
                  foundInterveningClass: false
                };
              }
            } else {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeParameterNotDeclared().format({
                name: t.shared.name,
                container: i.d.name.d.value
              }), e);
            }
            return {
              type: H.TypeVarType.cloneForScopeId(t, s.shared.recursiveAlias.typeVarScopeId, s.shared.recursiveAlias.name, 2),
              scopeNode: o,
              foundInterveningClass: false
            };
          }
          r = r.parent;
        }
        return {
          type: t,
          scopeNode: undefined,
          foundInterveningClass: false
        };
      }
      function Bt(e, t, a, r) {
        var s;
        var i;
        var o;
        var c;
        let m = Z.transformPossibleRecursiveTypeAlias(t.type);
        const y = e.d.member.d.value;
        let h = new p.DiagnosticAddendum();
        const f = v.getFileInfo(e);
        let T;
        let b;
        let _;
        let C = false;
        let I = !!t.isIncomplete;
        let k;
        if ((s = a == null ? undefined : a.setType) === null || s === undefined ? undefined : s.isIncomplete) {
          I = true;
        }
        if (t.isIncomplete && H.isUnbound(m)) {
          return {
            type: H.UnknownType.create(true),
            isIncomplete: true
          };
        }
        if (!!((i = m.props) === null || i === undefined ? undefined : i.specialForm) && !(r & 256)) {
          m = m.props.specialForm;
        }
        if (H.isParamSpec(m) && m.priv.paramSpecAccess) {
          m = Pt(m);
        }
        switch (m.category) {
          case 2:
          case 1:
          case 3:
            T = m;
            break;
          case 0:
            break;
          case 9:
            if (H.isParamSpec(m)) {
              if (y === 'args' || y === 'kwargs') {
                const t = y === 'args';
                const n = M.getEnclosingParam(e);
                const a = t ? 1 : 2;
                if (!n || n.d.category !== a) {
                  const n = t ? g.LocMessage.paramSpecArgsUsage() : g.LocMessage.paramSpecKwargsUsage();
                  kt(d.DiagnosticRule.reportInvalidTypeForm, n, e);
                  T = H.UnknownType.create(I);
                  break;
                }
                T = H.TypeVarType.cloneForParamSpecAccess(m, y);
                break;
              }
              if (!I) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecUnknownMember().format({
                  name: y
                }), e);
              }
              T = H.UnknownType.create(I);
              break;
            }
            if (r & 256) {
              if (!I) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarNoMember().format({
                  type: Yr(m),
                  name: y
                }), e.d.leftExpr);
              }
              T = H.UnknownType.create(I);
              break;
            }
            if (m.shared.recursiveAlias) {
              T = H.UnknownType.create(true);
              I = true;
              break;
            }
            if (H.isTypeVarTuple(m)) {
              break;
            }
            return Bt(e, {
              type: Pt(m),
              bindToSelfType: H.TypeBase.isInstantiable(m) ? Z.convertToInstance(m) : m,
              isIncomplete: I
            }, a, 0);
          case 6:
            {
              let n;
              const s = P.getTypeOfEnumMember(es, e, m, y, I);
              if (s) {
                if (a.method === 'get') {
                  n = s;
                } else {
                  if (H.isClassInstance(s.type) && H.ClassType.isSameGenericClass(s.type, H.ClassType.cloneAsInstance(m)) && s.type.priv.literalValue !== undefined) {
                    const t = a.method === 'set' ? g.LocMessage.enumMemberSet() : g.LocMessage.enumMemberDelete();
                    kt(d.DiagnosticRule.reportAttributeAccessIssue, t.format({
                      name: y
                    }) + h.getString(), e.d.member, (o = h.getEffectiveTextRange()) !== null && o !== undefined ? o : e.d.member);
                  }
                }
              }
              if (!n) {
                n = et(e.d.member, m, y, a, h, r & 256 ? 2048 : undefined, t.bindToSelfType);
              }
              if (n) {
                if (n.typeErrors) {
                  C = true;
                } else {
                  T = Z.addConditionToType(n.type, Z.getTypeCondition(m), {
                    skipSelfCondition: true,
                    skipBoundTypeVars: true
                  });
                }
                if (n.isAsymmetricAccessor) {
                  _ = true;
                }
                if (n.isIncomplete) {
                  I = true;
                }
                if (n.narrowedTypeForSet) {
                  b = Z.addConditionToType(n.narrowedTypeForSet, Z.getTypeCondition(m), {
                    skipSelfCondition: true,
                    skipBoundTypeVars: true
                  });
                }
                if (n.memberAccessDeprecationInfo) {
                  k = n.memberAccessDeprecationInfo;
                }
              }
              break;
            }
          case 7:
            {
              const t = H.ModuleType.getField(m, y);
              if (t && !t.isExternallyHidden()) {
                if (a.method === 'get') {
                  Et(f, t, e.d.member);
                }
                const n = ur(t, undefined, true);
                T = n.type;
                if (r & 256) {
                  T = zt(e, T, !!n.includesVariableDecl);
                }
                T = Mt(e, T, r, !!n.includesVariableDecl);
                if (H.isTypeVar(T)) {
                  T = Vt(e, T, r);
                }
                if (H.isUnbound(T)) {
                  T = H.UnknownType.create(true);
                }
                if (t.isPrivateMember()) {
                  kt(d.DiagnosticRule.reportPrivateUsage, g.LocMessage.privateUsedOutsideOfModule().format({
                    name: y
                  }), e.d.member);
                }
                if (t.isPrivatePyTypedImport()) {
                  kt(d.DiagnosticRule.reportPrivateImportUsage, g.LocMessage.privateImportFromPyTypedModule().format({
                    name: y,
                    module: m.priv.moduleName
                  }), e.d.member);
                }
              } else {
                if (a.method === 'get') {
                  const e = H.ModuleType.getField(m, '__getattr__');
                  if (e) {
                    if (u.PythonVersion.isGreaterOrEqualTo(f.executionEnvironment.pythonVersion, u.pythonVersion3_7) || e.getDeclarations().some(e => e.uri.hasExtension('.pyi'))) {
                      const t = ur(e);
                      if (H.isFunction(t.type)) {
                        T = hr(t.type);
                        if (t.isIncomplete) {
                          I = true;
                        }
                      }
                    }
                  }
                }
                if (!T && m.priv.notPresentFieldType) {
                  T = m.priv.notPresentFieldType;
                }
                if (!T) {
                  if (!I) {
                    kt(d.DiagnosticRule.reportAttributeAccessIssue, g.LocMessage.moduleUnknownMember().format({
                      memberName: y,
                      moduleName: m.priv.moduleName
                    }), e.d.member);
                  }
                  T = n.evaluateUnknownImportsAsAny ? H.AnyType.create() : H.UnknownType.create();
                }
              }
              break;
            }
          case 8:
            T = Z.mapSubtypes(m, n => {
              if (H.isUnbound(n)) {
                return;
              }
              if (Z.isNoneInstance(n)) {
                l.assert(H.isClassInstance(n));
                const t = et(e.d.member, n, y, a, h);
                if (t && !t.typeErrors) {
                  T = Z.addConditionToType(t.type, Z.getTypeCondition(m), {
                    skipBoundTypeVars: true
                  });
                  if (t.isIncomplete) {
                    I = true;
                  }
                  return T;
                } else {
                  if (!I) {
                    kt(d.DiagnosticRule.reportOptionalMemberAccess, g.LocMessage.noneUnknownMember().format({
                      name: y
                    }), e.d.member);
                  }
                  return;
                }
              }
              const r = Bt(e, {
                type: n,
                isIncomplete: t.isIncomplete
              }, a, 0);
              if (r.isIncomplete) {
                I = true;
              }
              if (r.memberAccessDeprecationInfo) {
                k = r.memberAccessDeprecationInfo;
              }
              if (r.typeErrors) {
                C = true;
              }
              return r.type;
            });
            break;
          case 4:
          case 5:
            if (y === '__self__') {
              let e;
              if (H.isFunction(m)) {
                e = m;
              } else {
                const t = H.OverloadedType.getOverloads(m);
                if (t.length > 0) {
                  e = t[0];
                }
              }
              if (!!e && e.priv.preBoundFlags !== undefined && !(e.priv.preBoundFlags & 4)) {
                T = e.priv.boundToType;
              }
            } else {
              T = Bt(e, {
                type: (Ae == null ? undefined : Ae.functionClass) ? Z.convertToInstance(Ae.functionClass) : H.UnknownType.create()
              }, a, r).type;
            }
            break;
          default:
            l.assertNever(m);
        }
        if (!T) {
          const n = H.isFunction(m) || H.isOverloaded(m) || H.isClassInstance(m) && H.ClassType.isBuiltIn(m, 'function');
          if (!t.isIncomplete) {
            let t = g.LocMessage.memberAccess();
            if (a.method === 'set') {
              t = g.LocMessage.memberSet();
            } else {
              if (a.method === 'del') {
                t = g.LocMessage.memberDelete();
              }
            }
            if (a.setExpectedTypeDiag) {
              h = a.setExpectedTypeDiag;
            }
            if (H.isClass(m) && m.shared.typedDictEntries) {
              if (m.shared.typedDictEntries.knownItems.get(y)) {
                const e = new p.DiagnosticAddendum();
                e.addMessage(g.LocAddendum.typedDictKeyAccess().format({
                  name: y
                }));
                h.addAddendum(e);
              }
            }
            kt(n ? d.DiagnosticRule.reportFunctionMemberAccess : d.DiagnosticRule.reportAttributeAccessIssue, t.format({
              name: y,
              type: Yr(m)
            }) + h.getString(), e.d.member, (c = h.getEffectiveTextRange()) !== null && c !== undefined ? c : e.d.member);
          }
          T = n ? H.AnyType.create() : H.UnknownType.create();
        }
        if (!(r & 256)) {
          Ge(T, e.d.member);
        }
        T = Ut(T, r);
        return {
          type: T,
          isIncomplete: I,
          isAsymmetricAccessor: _,
          narrowedTypeForSet: b,
          isRequired: false,
          isNotRequired: false,
          memberAccessDeprecationInfo: k,
          typeErrors: C
        };
      }
      function jt(e, t, n, a, r, s, i, o = 0) {
        var d;
        var c;
        var u;
        const m = H.TypeBase.isInstance(t);
        let y;
        let h = Z.lookUpClassMember(t, n, s | 64);
        if (!h) {
          h = Z.lookUpClassMember(t, n, s);
        }
        if (!h) {
          if (!(s & 512) && e) {
            const r = function (e, t, n, a, r) {
              var s;
              var i;
              var o;
              var p;
              var d;
              const c = n => {
                var a;
                if ((a = et(e, t, n, undefined, undefined, 540, r)) === null || a === undefined) {
                  return undefined;
                } else {
                  return a.type;
                }
              };
              let u;
              if (n.method === 'get') {
                u = (s = c('__getattribute__')) !== null && s !== undefined ? s : c('__getattr__');
              } else {
                if (n.method === 'set') {
                  u = c('__setattr__');
                } else {
                  l.assert(n.method === 'del');
                  u = c('__delattr__');
                }
              }
              if (!u) {
                return;
              }
              const m = [];
              m.push({
                argCategory: 0,
                typeResult: {
                  type: (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass) ? H.ClassType.cloneWithLiteral(H.ClassType.cloneAsInstance(Ae.strClass), a) : H.AnyType.create()
                }
              });
              if (n.method === 'set') {
                m.push({
                  argCategory: 0,
                  typeResult: {
                    type: (o = (i = n.setType) === null || i === undefined ? undefined : i.type) !== null && o !== undefined ? o : H.UnknownType.create(),
                    isIncomplete: !!((p = n.setType) === null || p === undefined ? undefined : p.isIncomplete)
                  }
                });
              }
              if (!H.isFunction(u) && !H.isOverloaded(u)) {
                if (H.isAnyOrUnknown(u)) {
                  return {
                    type: u
                  };
                } else {
                  return undefined;
                }
              }
              const y = pn(e, m, {
                type: u
              }, undefined, true, undefined);
              let g = false;
              if (n.method === 'set') {
                g = function (e) {
                  var t;
                  if (e.priv.isAsymmetricAttributeAccessor !== undefined) {
                    return e.priv.isAsymmetricAttributeAccessor;
                  }
                  let n = false;
                  const a = Z.lookUpClassMember(e, '__getattr__', 2);
                  const r = Z.lookUpClassMember(e, '__setattr__', 2);
                  if (a && r) {
                    const e = cr(a.symbol);
                    const s = cr(r.symbol);
                    if (H.isFunction(e) && H.isFunction(s) && s.shared.parameters.length >= 3 && e.shared.declaredReturnType) {
                      const a = H.FunctionType.getParamType(s, 2);
                      const r = (t = H.FunctionType.getEffectiveReturnType(e)) !== null && t !== undefined ? t : H.UnknownType.create();
                      if (!H.isTypeSame(a, r)) {
                        n = true;
                      }
                    }
                  } else {
                    n = false;
                  }
                  e.priv.isAsymmetricAttributeAccessor = n;
                  return n;
                }(t);
              }
              return {
                type: (d = y.returnType) !== null && d !== undefined ? d : H.UnknownType.create(),
                typeErrors: y.argumentErrors,
                isAsymmetricAccessor: g
              };
            }(e, t, a, n, i);
            if (r) {
              return {
                symbol: undefined,
                type: r.type,
                isTypeIncomplete: false,
                isDescriptorError: false,
                isClassMember: false,
                isClassVar: false,
                isAsymmetricAccessor: !!r.isAsymmetricAccessor
              };
            }
          }
          if (r != null) {
            r.addMessage(g.LocAddendum.memberUnknown().format({
              name: n
            }));
          }
          return;
        }
        let f;
        let T = false;
        if (h.symbol.isInitVar()) {
          if (r != null) {
            r.addMessage(g.LocAddendum.memberIsInitVar().format({
              name: n
            }));
          }
          return;
        }
        if (a.method !== 'get' && e) {
          const r = M.getEnclosingClass(e);
          if (r) {
            const o = (d = ca(r)) === null || d === undefined ? undefined : d.classType;
            if (o && H.isInstantiableClass(o) && H.ClassType.isSameGenericClass(m ? H.ClassType.cloneAsInstance(o) : o, t)) {
              y = (c = yr(h.symbol)) === null || c === undefined ? undefined : c.type;
              if (y && H.isInstantiableClass(h.classType)) {
                y = Z.partiallySpecializeType(y, h.classType, undefined, i);
              }
              if (a.method === 'set' && j.isEffectivelyClassVar(h.symbol, H.ClassType.isDataClass(o)) && m) {
                const a = vr(e, h, i ?? n === '__new__' ? undefined : t, s);
                if (a && Z.isDescriptorInstance(a.type, true)) {
                  y = a.type;
                  s &= 128;
                }
              }
              if (!y) {
                y = H.UnknownType.create();
              }
            }
          }
        }
        if (!y) {
          let a;
          if (i) {
            a = Z.convertToInstantiable(i);
          } else {
            if (n !== '__new__') {
              a = t;
            }
          }
          const r = vr(e, h, a, s);
          y = (u = r == null ? undefined : r.type) !== null && u !== undefined ? u : H.UnknownType.create();
          if (r == null ? undefined : r.isIncomplete) {
            T = true;
          }
        }
        if (H.isClass(h.classType) && H.ClassType.isTypedDictClass(h.classType)) {
          const e = h.symbol.getTypedDeclarations();
          if (e.length > 0 && e[0].type === 1) {
            if (r != null) {
              r.addMessage(g.LocAddendum.memberUnknown().format({
                name: n
              }));
            }
            return;
          }
        }
        if (a.method === 'get') {
          if (e && H.isInstantiableClass(h.classType) && H.ClassType.isSameGenericClass(h.classType, m ? H.ClassType.cloneAsInstantiable(t) : t)) {
            Et(v.getFileInfo(e), h.symbol, e);
          }
          if (n === '__init_subclass__' || n === '__class_getitem__') {
            if (H.isFunction(y) && !H.FunctionType.isClassMethod(y)) {
              y = H.FunctionType.cloneWithNewFlags(y, y.shared.flags | 2);
            }
          }
        }
        let b;
        let _ = false;
        let C = false;
        let I = false;
        y = Z.mapSubtypes(y, l => {
          const d = Pt(l);
          const c = !h || h.isClassMember;
          let u;
          if (H.isClass(d) && c && e) {
            const o = function (e, t, n, a, r, s, i, o, l, d) {
              var c;
              var u;
              var m;
              var y;
              var h;
              var f;
              var T;
              const v = H.TypeBase.isInstance(a);
              let b;
              b = l.method === 'get' ? '__get__' : l.method === 'set' ? '__set__' : '__delete__';
              const _ = d ? new p.DiagnosticAddendum() : undefined;
              const C = et(i, t, b, undefined, _, 528);
              if (!C || C.typeErrors) {
                if (H.ClassType.isPropertyClass(t) && l.method !== 'get') {
                  const e = l.method === 'set' ? g.LocAddendum.propertyMissingSetter() : g.LocAddendum.propertyMissingDeleter();
                  if (d != null) {
                    d.addMessage(e.format({
                      name: o
                    }));
                  }
                  return {
                    type: H.AnyType.create(),
                    typeErrors: true
                  };
                }
                if (a.shared.typeVarScopeId) {
                  e = Z.makeTypeVarsBound(e, [a.shared.typeVarScopeId]);
                }
                return {
                  type: e
                };
              }
              const I = C.classType;
              let w = C.type;
              if (C.typeErrors || !I) {
                if (d && _) {
                  d.addAddendum(_);
                }
                return {
                  type: H.UnknownType.create(),
                  typeErrors: true
                };
              }
              if (!H.isFunction(w) && !H.isOverloaded(w)) {
                if (H.isAnyOrUnknown(w)) {
                  return {
                    type: w
                  };
                } else {
                  return {
                    type: e,
                    typeErrors: true
                  };
                }
              }
              if (H.ClassType.isPropertyClass(t) && n && H.isInstantiableClass(n.classType) && w) {
                if (s & 16 && H.ClassType.isProtocolClass(a)) {
                  if (d != null) {
                    d.addMessage(g.LocAddendum.propertyAccessFromProtocolClass());
                  }
                  return {
                    type: e,
                    typeErrors: true
                  };
                }
                let i;
                gr(w);
                i = l.method === 'get' ? (c = t.priv.fgetInfo) === null || c === undefined ? undefined : c.classType : l.method === 'set' ? (u = t.priv.fsetInfo) === null || u === undefined ? undefined : u.classType : (m = t.priv.fdelInfo) === null || m === undefined ? undefined : m.classType;
                if (i) {
                  const e = new k.ConstraintTracker();
                  i = Z.selfSpecializeClass(i);
                  Ir(H.ClassType.cloneAsInstance(i), H.ClassType.cloneAsInstance(n.classType), undefined, e);
                  i = Xe(i, e);
                  const t = Z.partiallySpecializeType(w, i, dt(), r ? Z.convertToInstantiable(r) : a);
                  if (H.isFunction(t) || H.isOverloaded(t)) {
                    w = t;
                  }
                }
              }
              let S = false;
              if (l.method === 'set' && H.isClass(I) && function (e) {
                var t;
                if (e.priv.isAsymmetricDescriptor !== undefined) {
                  return e.priv.isAsymmetricDescriptor;
                }
                let n = false;
                const a = Z.lookUpClassMember(e, '__get__', 2);
                const r = Z.lookUpClassMember(e, '__set__', 2);
                if (a && r) {
                  let e = Tr(a);
                  const s = Tr(r);
                  if (H.isOverloaded(e)) {
                    const t = H.OverloadedType.getOverloads(e).filter(e => {
                      if (e.shared.parameters.length < 2) {
                        return false;
                      }
                      const t = H.FunctionType.getParamType(e, 1);
                      return !Z.isNoneInstance(t);
                    });
                    if (t.length === 1) {
                      e = t[0];
                    } else {
                      n = true;
                    }
                  }
                  if (H.isOverloaded(s)) {
                    n = true;
                  }
                  if (H.isFunction(e) && H.isFunction(s) && s.shared.parameters.length >= 3 && e.shared.declaredReturnType) {
                    const a = H.FunctionType.getParamType(s, 2);
                    const r = (t = H.FunctionType.getEffectiveReturnType(e)) !== null && t !== undefined ? t : H.UnknownType.create();
                    if (!H.isTypeSame(a, r)) {
                      n = true;
                    }
                  }
                } else {
                  n = false;
                }
                e.priv.isAsymmetricDescriptor = n;
                return n;
              }(I)) {
                S = true;
              }
              if (!w) {
                if (d != null) {
                  d.addMessage(g.LocAddendum.descriptorAccessBindingFailed().format({
                    name: b,
                    className: Yr(Z.convertToInstance(I))
                  }));
                }
                return {
                  type: H.UnknownType.create(),
                  typeErrors: true,
                  isDescriptorApplied: true,
                  isAsymmetricAccessor: S
                };
              }
              const A = [];
              let x;
              x = H.ClassType.isClassProperty(t) ? v ? H.ClassType.cloneAsInstantiable(a) : a : v ? r ?? H.ClassType.cloneAsInstance(a) : pt();
              A.push({
                argCategory: 0,
                typeResult: {
                  type: x
                }
              });
              if (l.method === 'get') {
                let e;
                e = r ? Z.convertToInstantiable(r) : v ? H.ClassType.cloneAsInstantiable(a) : a;
                A.push({
                  argCategory: 0,
                  typeResult: {
                    type: e
                  }
                });
              } else {
                if (l.method === 'set') {
                  A.push({
                    argCategory: 0,
                    typeResult: {
                      type: (h = (y = l.setType) === null || y === undefined ? undefined : y.type) !== null && h !== undefined ? h : H.UnknownType.create(),
                      isIncomplete: !!((f = l.setType) === null || f === undefined ? undefined : f.isIncomplete)
                    }
                  });
                }
              }
              const P = Qa(i, () => pn(i, A, {
                type: w
              }, undefined, true, undefined), e => {
                if (d) {
                  e.forEach(e => {
                    if (d != null) {
                      d.addMessageMultiline(e);
                    }
                  });
                }
              });
              let D;
              if (P.overloadsUsedForCall && P.overloadsUsedForCall.length >= 1) {
                const e = P.overloadsUsedForCall[0];
                if (e.shared.deprecatedMessage) {
                  D = {
                    deprecatedMessage: e.shared.deprecatedMessage,
                    accessType: H.ClassType.isPropertyClass(t) ? 'property' : 'descriptor',
                    accessMethod: l.method
                  };
                }
              }
              if (!P.argumentErrors) {
                return {
                  type: l.method === 'get' ? (T = P.returnType) !== null && T !== undefined ? T : H.UnknownType.create() : H.AnyType.create(),
                  isDescriptorApplied: true,
                  isAsymmetricAccessor: S,
                  memberAccessDeprecationInfo: D
                };
              }
              return {
                type: H.UnknownType.create(),
                typeErrors: true,
                isDescriptorApplied: true,
                isAsymmetricAccessor: S,
                memberAccessDeprecationInfo: D
              };
            }(l, d, h, t, i, s, e, n, a, r);
            if (o.isAsymmetricAccessor) {
              C = true;
            }
            if (o.memberAccessDeprecationInfo) {
              b = o.memberAccessDeprecationInfo;
            }
            if (o.typeErrors) {
              _ = true;
            }
            if (o.isDescriptorApplied) {
              I = true;
            }
            u = o.type;
          } else {
            if (H.isFunction(d) || H.isOverloaded(d)) {
              const e = function (e, t, n, a, r, s, i, o, l, p = 0) {
                if (o.method === 'set') {
                  const e = H.isFunction(t) ? t : H.OverloadedType.getImplementation(t);
                  if (e && H.isFunction(e) && H.FunctionType.isFinal(e) && n && H.isClass(n.classType)) {
                    if (l != null) {
                      l.addMessage(g.LocMessage.finalMethodOverride().format({
                        name: i,
                        className: n.classType.shared.name
                      }));
                    }
                    return {
                      type: H.UnknownType.create(),
                      typeErrors: true
                    };
                  }
                }
                if (H.TypeBase.isInstance(a) && (!n || n.isInstanceMember)) {
                  return {
                    type: e
                  };
                }
                const d = Ur(a, t, n && H.isInstantiableClass(n.classType) ? n.classType : undefined, !!(s & 256), r && H.isClass(r) ? H.ClassType.cloneIncludeSubclasses(r) : r, l, p);
                return {
                  type: d ?? H.UnknownType.create(),
                  typeErrors: !d
                };
              }(l, d, h, t, i, s, n, a, r, o);
              u = e.type;
              if (e.typeErrors) {
                _ = true;
              }
            } else {
              u = l;
            }
          }
          if (a.method === 'get') {
            return u;
          }
          if (!I && h && j.isEffectivelyClassVar(h.symbol, H.ClassType.isDataClass(t)) && s & 128) {
            if (r != null) {
              r.addMessage(g.LocAddendum.memberSetClassVar().format({
                name: n
              }));
            }
            _ = true;
          }
          const m = h == null ? undefined : h.symbol.getDeclarations().find(e => Lr(e));
          if (m && e && !M.isNodeContainedWithin(e, m.node)) {
            const a = M.getEnclosingFunction(e);
            if (!a || a.d.name.d.value !== '__init__' || m.inferredTypeSource !== undefined || !!H.isInstantiableClass(t)) {
              if (r != null) {
                r.addMessage(g.LocMessage.finalReassigned().format({
                  name: n
                }));
              }
              _ = true;
            }
          }
          if ((h == null ? undefined : h.isInstanceMember) && H.isClass(h.classType) && h.isReadOnly) {
            if (r != null) {
              r.addMessage(g.LocAddendum.readOnlyAttribute().format({
                name: n
              }));
            }
            _ = true;
          }
          return u;
        });
        if (!_ && a.method === 'set' && a.setType) {
          if (e && h.symbol.hasTypedDeclarations()) {
            f = I ? a.setType.type : Er(e, y, a.setType).type;
          }
          if (!Ir(y, a.setType.type, r == null ? undefined : r.createAddendum())) {
            if (!a.setType.isIncomplete && r != null) {
              r.addMessage(g.LocAddendum.memberAssignment().format({
                type: Yr(a.setType.type),
                name: n,
                classType: $r(t)
              }));
            }
            f = y;
            _ = true;
          }
          if (H.isInstantiableClass(h.classType) && H.ClassType.isDataClassFrozen(h.classType) && m) {
            if (r != null) {
              r.addMessage(g.LocAddendum.dataClassFrozen().format({
                name: Yr(H.ClassType.cloneAsInstance(h.classType))
              }));
            }
            _ = true;
          }
        }
        return {
          symbol: h.symbol,
          type: y,
          isTypeIncomplete: T,
          isDescriptorError: _,
          isClassMember: !h.isInstanceMember,
          isClassVar: h.isClassVar,
          classType: h.classType,
          isAsymmetricAccessor: C,
          narrowedTypeForSet: f,
          memberAccessDeprecationInfo: b
        };
      }
      function qt(e, t, n) {
        const a = t.findIndex(e => H.isTypeVarTuple(e));
        let r;
        let s = e.findIndex(e => !!H.isUnpackedClass(e.type) && !!e.type.priv.tupleTypeArgs && e.type.priv.tupleTypeArgs.length === 1 && !!e.type.priv.tupleTypeArgs[0].isUnbounded && (r = e.type.priv.tupleTypeArgs[0].type, true));
        if (r && s >= 0 && a >= 0 && e.length < t.length) {
          while (a > s) {
            e = [...e.slice(0, s), {
              node: e[s].node,
              type: r
            }, ...e.slice(s)];
            s++;
          }
          while (e.length < t.length) {
            e = [...e.slice(0, s + 1), {
              node: e[s].node,
              type: r
            }, ...e.slice(s + 1)];
          }
        }
        if (a >= 0) {
          const r = t[a];
          let s = t.length;
          while (s > 0) {
            const e = t[s - 1];
            if (!H.isParamSpec(e) || !e.shared.isDefaultExplicit) {
              break;
            }
            s--;
          }
          if (a < e.length) {
            let t = a + 1 + e.length - s;
            while (t > a && e[t - 1].typeList) {
              t--;
            }
            const n = e.slice(a, t);
            if (n.length === 1 && H.isTypeVarTuple(n[0].type)) {
              Gt(n[0].type, n[0].node);
            } else {
              n.forEach((e, t) => {
                Ln(e, {
                  allowEmptyTuple: t === 0,
                  allowTypeVarTuple: true,
                  allowUnpackedTuples: true
                });
              });
              const r = [];
              if (n.length !== 1 || !n[0].isEmptyTupleShorthand) {
                n.forEach(e => {
                  if (H.isUnpackedClass(e.type) && e.type.priv.tupleTypeArgs) {
                    o.appendArray(r, e.type.priv.tupleTypeArgs);
                  } else {
                    r.push({
                      type: Z.convertToInstance(e.type),
                      isUnbounded: false
                    });
                  }
                });
              }
              const s = q.makeTupleObject(es, r, true);
              e = [...e.slice(0, a), {
                node: e[a].node,
                type: s
              }, ...e.slice(t, e.length)];
            }
          } else {
            if (!r.shared.isDefaultExplicit) {
              e.push({
                node: n,
                type: q.makeTupleObject(es, [], true)
              });
            }
          }
        }
        return e;
      }
      function Gt(e, t) {
        return !!e.priv.isUnpacked || (kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackedTypeVarTupleExpected().format({
          name1: e.shared.name,
          name2: e.shared.name
        }), t), false);
      }
      function Wt(e, t) {
        var n;
        const a = (n = e.props) === null || n === undefined ? undefined : n.typeAliasInfo;
        if (!a) {
          return e;
        }
        if (!a.shared.typeParams || a.shared.typeParams.length === 0 || a.typeArgs) {
          return e;
        }
        let r = false;
        const s = [];
        const i = new k.ConstraintTracker();
        a.shared.typeParams.forEach(e => {
          let t;
          if (!e.shared.isDefaultExplicit) {
            r = true;
          }
          t = e.shared.isDefaultExplicit || H.isParamSpec(e) ? Xe(e, i, {
            replaceUnsolved: {
              scopeIds: [a.shared.typeVarScopeId],
              tupleClassType: ot()
            }
          }) : H.isTypeVarTuple(e) && (Ae == null ? undefined : Ae.tupleClass) && H.isInstantiableClass(Ae.tupleClass) ? q.makeTupleObject(es, [{
            type: H.UnknownType.create(),
            isUnbounded: true
          }], true) : H.UnknownType.create();
          s.push(t);
          i.setBounds(e, t);
        });
        if (r && t) {
          kt(d.DiagnosticRule.reportMissingTypeArgument, g.LocMessage.typeArgsMissingForAlias().format({
            name: a.shared.name
          }), t);
        }
        return e = H.TypeBase.cloneForTypeAlias(Xe(e, i, {
          replaceUnsolved: {
            scopeIds: [a.shared.typeVarScopeId],
            tupleClassType: ot()
          }
        }), {
          ...a,
          typeArgs: s
        });
      }
      function Kt(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        var o;
        var l;
        var c;
        let u = (a = t.props) === null || a === undefined ? undefined : a.typeAliasInfo;
        let m = t;
        if (!u && ((r = t.props) === null || r === undefined ? undefined : r.typeForm)) {
          u = (i = (s = t.props.typeForm) === null || s === undefined ? undefined : s.props) === null || i === undefined ? undefined : i.typeAliasInfo;
          m = Z.convertToInstantiable(t.props.typeForm);
        }
        if (!(u == null ? undefined : u.shared.typeParams) || u.shared.typeParams.length === 0 && u.typeArgs) {
          return;
        }
        if (!H.TypeBase.isInstantiable(m)) {
          return;
        }
        if (u.typeArgs) {
          return;
        }
        Ht(t);
        const y = u.shared.typeParams;
        let h;
        h = qt(Qt(e, n), y, e);
        let f = false;
        h = Wa(y, h, e);
        if (!h) {
          h = [];
          f = true;
        }
        let T = y.length;
        const v = y.findIndex(e => !!e.shared.isDefaultExplicit);
        if (v >= 0) {
          T = v;
        }
        if (h.length > y.length) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsTooMany().format({
            name: Yr(m),
            expected: y.length,
            received: h.length
          }), h[y.length].node);
          f = true;
        } else {
          if (h.length < T) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsTooFew().format({
              name: Yr(m),
              expected: y.length,
              received: h.length
            }), e.d.items[e.d.items.length - 1]);
            f = true;
          }
        }
        if (H.isInstantiableClass(m) && m.shared.fullName === 'mypy_extensions.FlexibleAlias' && h.length >= 1) {
          return {
            node: e,
            type: h[0].type
          };
        }
        const b = new k.ConstraintTracker();
        const _ = new p.DiagnosticAddendum();
        y.forEach((e, t) => {
          if (H.isParamSpec(e) && t < h.length) {
            const n = h[t].type;
            const a = h[t].typeList;
            if (a) {
              const t = H.FunctionType.createSynthesizedInstance('', 65536);
              a.forEach((e, n) => {
                let a = e.type;
                if (!Ln(e)) {
                  a = H.UnknownType.create();
                }
                H.FunctionType.addParam(t, H.FunctionParam.create(0, Z.convertToInstance(a), H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${n}`));
              });
              if (a.length > 0) {
                H.FunctionType.addPositionOnlyParamSeparator(t);
              }
              I.assignTypeVar(es, e, t, _, b, 256);
            } else {
              if (H.isParamSpec(n)) {
                I.assignTypeVar(es, e, Z.convertToInstance(n), _, b, 256);
              } else {
                if (H.isInstantiableClass(n) && H.ClassType.isBuiltIn(n, 'Concatenate')) {
                  const t = n.priv.typeArgs;
                  const a = H.FunctionType.createInstance('', '', '', 0);
                  if (t && t.length > 0) {
                    t.forEach((e, n) => {
                      if (n === t.length - 1) {
                        H.FunctionType.addPositionOnlyParamSeparator(a);
                        if (H.isParamSpec(e)) {
                          H.FunctionType.addParamSpecVariadics(a, e);
                        } else {
                          if (Z.isEllipsisType(e)) {
                            H.FunctionType.addDefaultParams(a);
                            a.shared.flags |= 32768;
                          }
                        }
                      } else {
                        H.FunctionType.addParam(a, H.FunctionParam.create(0, e, H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${n}`));
                      }
                    });
                  }
                  I.assignTypeVar(es, e, a, _, b, 256);
                } else {
                  if (Z.isEllipsisType(n)) {
                    const t = H.FunctionType.createSynthesizedInstance('', 98304);
                    H.FunctionType.addDefaultParams(t);
                    I.assignTypeVar(es, e, t, _, b);
                  } else {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgListExpected(), h[t].node);
                    f = true;
                  }
                }
              }
            }
          } else {
            let a;
            if (t < h.length && h[t].typeList) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgListNotAllowed(), h[t].node);
              f = true;
            }
            a = t < h.length ? Z.convertToInstance(h[t].type) : e.shared.isDefaultExplicit ? Xe(e, b, {
              replaceUnsolved: {
                scopeIds: [u.shared.typeVarScopeId],
                tupleClassType: ot()
              }
            }) : H.UnknownType.create();
            if (n & 16384) {
              const e = Ht(m);
              if (e && t < e.length) {
                const n = e[t];
                if (!Z.isVarianceOfTypeArgCompatible(a, n)) {
                  const e = _.createAddendum();
                  e.addMessage(g.LocAddendum.varianceMismatchForTypeAlias().format({
                    typeVarName: Yr(a),
                    typeAliasParam: Yr(y[t])
                  }));
                  e.addTextRange(h[t].node);
                }
              }
            }
            if (H.isUnpacked(a) && !H.isTypeVarTuple(e)) {
              const e = _.createAddendum();
              e.addMessage(g.LocMessage.unpackedArgInTypeArgument());
              e.addTextRange(h[t].node);
              a = H.UnknownType.create();
            }
            I.assignTypeVar(es, e, a, _, b, 256);
          }
        });
        if (!_.isEmpty()) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeNotSpecializable().format({
            type: Yr(m)
          }) + _.getString(), e, (o = _.getEffectiveTextRange()) !== null && o !== undefined ? o : e);
          f = true;
        }
        const C = I.solveConstraints(es, b).getMainSolutionSet();
        const w = [];
        if ((l = u.shared.typeParams) !== null && l !== undefined) {
          l.forEach(e => {
            let t = C.getType(e);
            if (!t) {
              t = Z.getUnknownForTypeVar(e, ot());
              b.setBounds(e, t);
            }
            w.push(t);
          });
        }
        let S = H.TypeBase.cloneForTypeAlias(Xe(m, b), {
          ...u,
          typeArgs: w
        });
        if (Zr(e)) {
          S = H.TypeBase.cloneWithTypeForm(S, f ? undefined : Z.convertToInstance(S));
        }
        if ((c = t.props) === null || c === undefined ? undefined : c.typeAliasInfo) {
          return {
            type: S,
            node: e
          };
        } else {
          return {
            type: H.TypeBase.cloneWithTypeForm(t, Z.convertToInstance(S)),
            node: e
          };
        }
      }
      function $t(e, t, n, a) {
        var r;
        var s;
        var i;
        const o = Kt(e, t.type, a);
        if (o) {
          return o;
        }
        if (H.isNever(t.type) && ((r = t.type.props) === null || r === undefined ? undefined : r.specialForm)) {
          t = {
            ...t,
            type: t.type.props.specialForm
          };
        }
        if (H.isClassInstance(t.type) && H.ClassType.isBuiltIn(t.type, 'TypeAliasType') && ((s = t.type.props) === null || s === undefined ? undefined : s.typeForm)) {
          const n = (i = t.type.props.typeForm.props) === null || i === undefined ? undefined : i.typeAliasInfo;
          if (n && n.shared.typeParams) {
            const r = H.TypeBase.cloneForTypeAlias(Z.convertToInstantiable(t.type.props.typeForm), {
              ...n,
              typeArgs: undefined
            });
            const s = Kt(e, r, a);
            if (s) {
              return {
                type: H.TypeBase.cloneWithTypeForm(t.type, Z.convertToInstance(s.type))
              };
            }
          }
        }
        if (H.isTypeVar(t.type) && Z.isTypeAliasPlaceholder(t.type)) {
          const n = Qt(e, a).map(e => Z.convertToInstance(e.type));
          return {
            type: H.TypeBase.cloneForTypeAlias(t.type, {
              shared: t.type.shared.recursiveAlias,
              typeArgs: n
            })
          };
        }
        let l = t.isIncomplete;
        let p = false;
        let c = false;
        let u = false;
        const m = Dt(t.type, undefined, (t, r) => {
          var s;
          const i = H.isTypeVar(r) ? r : undefined;
          if (H.isAnyOrUnknown(t)) {
            if (a & 256) {
              Qt(e, a);
            }
            return t;
          }
          if (a & 128 && H.isTypeVar(r)) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarNotSubscriptable().format({
              type: Yr(r)
            }), e.d.leftExpr);
            Qt(e, a);
            return H.UnknownType.create();
          }
          if (H.isInstantiableClass(t)) {
            if (t.shared.effectiveMetaclass && H.isInstantiableClass(t.shared.effectiveMetaclass) && !H.ClassType.isBuiltIn(t.shared.effectiveMetaclass, ['type', '_InitVarMeta']) && !(a & 128)) {
              const r = tt(t, Yt(n));
              if (a & 256) {
                kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsExpectingNone().format({
                  name: Yr(H.ClassType.cloneAsInstance(t))
                }), e);
              }
              if (r) {
                return Jt(e, t, i, n).type;
              }
            }
            if (n.method === 'set') {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.genericClassAssigned(), e.d.leftExpr);
            } else {
              if (n.method === 'del') {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.genericClassDeleted(), e.d.leftExpr);
              }
            }
            if (H.ClassType.isSpecialBuiltIn(t, 'Literal')) {
              return function (e, t, n) {
                var a;
                if (t.d.items.length === 0) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.literalEmptyArgs(), t.d.leftExpr);
                  return H.UnknownType.create();
                }
                const r = [];
                let s = true;
                for (const i of t.d.items) {
                  let o;
                  const l = i.d.valueExpr;
                  if (i.d.argCategory !== 0) {
                    if (n & 256) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackedArgInTypeArgument(), l);
                      o = H.UnknownType.create();
                      s = false;
                    }
                  } else {
                    if (i.d.name) {
                      if (n & 256) {
                        kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.keywordArgInTypeArgument(), l);
                        o = H.UnknownType.create();
                        s = false;
                      }
                    } else {
                      if (l.nodeType === 48) {
                        const a = !!(l.d.strings[0].d.token.flags & 32);
                        const r = l.d.strings.map(e => e.d.value).join('');
                        o = Gn(t, e, a ? 'bytes' : 'str', r);
                        if (n & 256) {
                          l.d.strings.forEach(e => {
                            if (e.d.token.flags & 512) {
                              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.literalNamedUnicodeEscape(), e);
                              s = false;
                            }
                          });
                        }
                      } else {
                        if (l.nodeType === 40) {
                          if (!l.d.isImaginary && l.d.isInteger) {
                            o = Gn(t, e, 'int', l.d.value);
                          }
                        } else {
                          if (l.nodeType === 14) {
                            if (l.d.constType === 33) {
                              o = Gn(t, e, 'bool', true);
                            } else {
                              if (l.d.constType === 15) {
                                o = Gn(t, e, 'bool', false);
                              } else {
                                if (l.d.constType === 26) {
                                  o = (a = Ae == null ? undefined : Ae.noneTypeClass) !== null && a !== undefined ? a : H.UnknownType.create();
                                }
                              }
                            }
                          } else {
                            if (l.nodeType === 55) {
                              if (l.d.operator === 33 || l.d.operator === 0) {
                                if (l.d.expr.nodeType === 40 && !l.d.expr.d.isImaginary && l.d.expr.d.isInteger) {
                                  o = Gn(t, e, 'int', l.d.operator === 33 ? -l.d.expr.d.value : l.d.expr.d.value);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (!o) {
                    const e = qe(l, n & 260 | 33554432);
                    if (H.isClassInstance(e.type) && H.ClassType.isEnumClass(e.type) && e.type.priv.literalValue !== undefined) {
                      o = H.ClassType.cloneAsInstantiable(e.type);
                    } else {
                      let t = true;
                      Z.doForEachSubtype(e.type, e => {
                        if ((!H.isInstantiableClass(e) || e.priv.literalValue === undefined) && !Z.isNoneTypeClass(e)) {
                          t = false;
                        }
                      });
                      if (t) {
                        o = e.type;
                      }
                    }
                  }
                  if (!o) {
                    if (!(n & 256)) {
                      return H.ClassType.cloneAsInstance(e);
                    }
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.literalUnsupportedType(), i);
                    o = H.UnknownType.create();
                    s = false;
                  }
                  r.push(o);
                }
                let i = H.combineTypes(r, {
                  skipElideRedundantLiterals: true
                });
                if (H.isUnion(i) && (Ae == null ? undefined : Ae.unionTypeClass) && H.isInstantiableClass(Ae.unionTypeClass)) {
                  i = H.TypeBase.cloneAsSpecialForm(i, H.ClassType.cloneAsInstance(Ae.unionTypeClass));
                }
                if (Zr(t) && s) {
                  i = H.TypeBase.cloneWithTypeForm(i, Z.convertToInstance(i));
                }
                return i;
              }(t, e, a);
            }
            if (H.ClassType.isBuiltIn(t, 'InitVar')) {
              const t = Qt(e, a);
              if (a & 256) {
                if (!(a & 32768)) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.initVarNotAllowed(), e.d.leftExpr);
                }
              }
              if (t.length === 1) {
                return t[0].type;
              } else {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsMismatchOne().format({
                  received: t.length
                }), e.d.leftExpr);
                return H.UnknownType.create();
              }
            }
            if (H.ClassType.isEnumClass(t)) {
              return H.ClassType.cloneAsInstance(t);
            }
            const r = H.isInstantiableClass(t) && H.ClassType.isBuiltIn(t, 'Annotated');
            const o = H.isInstantiableClass(t) && H.ClassType.hasCustomClassGetItem(t);
            const l = ((s = t.shared.typeParams) === null || s === undefined ? undefined : s.length) > 0 || H.ClassType.isSpecialBuiltIn(t) || H.ClassType.isBuiltIn(t, 'type') || H.ClassType.isPartiallyEvaluated(t);
            const m = H.isInstantiableClass(t) && H.ClassType.isBuiltIn(t, 'Final');
            const y = H.isInstantiableClass(t) && H.ClassType.isBuiltIn(t, 'ClassVar');
            const h = v.getFileInfo(e).diagnosticRuleSet.enableExperimentalFeatures && H.ClassType.isBuiltIn(t, 'TypedDict');
            let f = Qt(e, a, {
              isAnnotatedClass: r,
              hasCustomClassGetItem: o || !l,
              isFinalAnnotation: m,
              isClassVarAnnotation: y,
              supportsTypedDictTypeArg: h
            });
            if (!r) {
              f = qt(f, t.shared.typeParams, e);
            }
            if (o) {
              return t;
            }
            if (t.priv.typeArgs) {
              kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.classAlreadySpecialized().format({
                type: Yr(Z.convertToInstance(t), {
                  expandTypeAlias: true
                })
              }), e.d.leftExpr);
              return t;
            }
            const T = Ga(t, f, a, e);
            if (T.isRequired) {
              p = true;
            } else {
              if (T.isNotRequired) {
                c = true;
              }
            }
            if (T.isReadOnly) {
              u = true;
            }
            return T.type;
          }
          if (Z.isNoneInstance(t)) {
            if (!l) {
              kt(d.DiagnosticRule.reportOptionalSubscript, g.LocMessage.noneNotSubscriptable(), e.d.leftExpr);
            }
            return H.UnknownType.create();
          }
          if (H.isClassInstance(t)) {
            const a = Jt(e, t, i, n);
            if (a.isIncomplete) {
              l = true;
            }
            return a.type;
          }
          if (H.isNever(t)) {
            return H.NeverType.createNever();
          } else {
            if (!H.isUnbound(t) && !l) {
              kt(d.DiagnosticRule.reportIndexIssue, g.LocMessage.typeNotSubscriptable().format({
                type: Yr(t)
              }), e.d.leftExpr);
            }
            return H.UnknownType.create();
          }
        });
        if (!t.isIncomplete) {
          e.d.items.forEach(e => {
            if (!De(e.d.valueExpr)) {
              qe(e.d.valueExpr, a & 4);
            }
          });
        }
        return {
          type: m,
          isIncomplete: l,
          isReadOnly: u,
          isRequired: p,
          isNotRequired: c
        };
      }
      function Ht(e) {
        var t;
        const n = (t = e.props) === null || t === undefined ? undefined : t.typeAliasInfo;
        if (!n || !n.shared.typeParams) {
          return;
        }
        if (n.shared.computedVariance) {
          return n.shared.computedVariance;
        }
        const a = n.shared.typeParams;
        const r = a.map(() => 1);
        n.shared.computedVariance = r;
        Zt(e, a, r, 3);
        return r;
      }
      function Zt(e, t, n, a, r = [], s = 0) {
        if (s > H.maxTypeRecursionCount) {
          return;
        }
        const i = Z.transformPossibleRecursiveTypeAlias(e);
        if (i !== e) {
          if (r.filter(t => H.isTypeSame(t, e)).length > 1) {
            return;
          }
        }
        function o(e, a) {
          Z.doForEachSubtype(e, i => {
            const o = t.findIndex(e => H.isTypeSame(e, i));
            if (o >= 0) {
              n[o] = Z.combineVariances(n[o], a);
            } else {
              r.push(e);
              Zt(i, t, n, a, r, s);
              r.pop();
            }
          });
        }
        s++;
        Z.doForEachSubtype(i, e => {
          if (e.category === 4) {
            e.shared.parameters.forEach((t, n) => {
              o(H.FunctionType.getParamType(e, n), Z.invertVariance(a));
            });
            const t = H.FunctionType.getEffectiveReturnType(e);
            if (t) {
              o(t, a);
            }
          } else {
            if (e.category === 6 && e.priv.typeArgs) {
              ya(e);
              e.priv.typeArgs.forEach((t, n) => {
                var r;
                if (Z.isTupleClass(e)) {
                  o(t, a);
                } else {
                  if (n < e.shared.typeParams.length) {
                    const s = e.shared.typeParams[n];
                    if (H.isUnpackedClass(t) && t.priv.tupleTypeArgs) {
                      t.priv.tupleTypeArgs.forEach(e => {
                        o(e.type, 2);
                      });
                    } else {
                      const e = (r = s.priv.computedVariance) !== null && r !== undefined ? r : s.shared.declaredVariance;
                      o(t, a === 4 ? Z.invertVariance(e) : e);
                    }
                  }
                }
              });
            }
          }
        });
      }
      function Yt(e) {
        if (e.method === 'get') {
          return '__getitem__';
        } else {
          if (e.method === 'set') {
            return '__setitem__';
          } else {
            l.assert(e.method === 'del');
            return '__delitem__';
          }
        }
      }
      function Jt(e, t, n, a) {
        var r;
        var s;
        var i;
        var o;
        var l;
        if (H.isClassInstance(t) && H.ClassType.isTypedDictClass(t)) {
          const n = W.getTypeOfIndexedTypedDict(es, e, t, a);
          if (n) {
            return n;
          }
        }
        const p = Yt(a);
        const c = tt(t, p, n);
        if (!c) {
          kt(d.DiagnosticRule.reportIndexIssue, g.LocMessage.methodNotDefinedOnType().format({
            name: p,
            type: Yr(t)
          }), e.d.leftExpr);
          return {
            type: H.UnknownType.create()
          };
        }
        if (e.d.items.length === 1 && !e.d.trailingComma && !e.d.items[0].d.name && e.d.items[0].d.argCategory === 0 && H.isClassInstance(t)) {
          const n = e.d.items[0].d.valueExpr;
          const a = qe(n).type;
          if (H.isClassInstance(a) && H.ClassType.isBuiltIn(a, 'int') && Z.isLiteralType(a) && typeof a.priv.literalValue == 'number') {
            const e = a.priv.literalValue;
            const n = Z.getSpecializedTupleType(t);
            if (n && n.priv.tupleTypeArgs && Z.isTupleIndexUnambiguous(n, e)) {
              if (e >= 0 && e < n.priv.tupleTypeArgs.length) {
                return {
                  type: n.priv.tupleTypeArgs[e].type
                };
              }
              if (e < 0 && n.priv.tupleTypeArgs.length + e >= 0) {
                return {
                  type: n.priv.tupleTypeArgs[n.priv.tupleTypeArgs.length + e].type
                };
              }
            }
          } else {
            if (H.isClassInstance(a) && H.ClassType.isBuiltIn(a, 'slice')) {
              const e = Z.getSpecializedTupleType(t);
              if (e && n.nodeType === 46) {
                const t = q.getSlicedTupleType(es, e, n);
                if (t) {
                  return {
                    type: t
                  };
                }
              }
            }
          }
        }
        const u = e.d.items.filter(e => e.d.argCategory === 0 && !e.d.name);
        const m = e.d.items.filter(e => e.d.argCategory === 1);
        const y = e.d.items.filter(e => e.d.argCategory === 0 && !!e.d.name);
        const h = e.d.items.filter(e => e.d.argCategory === 2);
        let f;
        let T = false;
        if (u.length !== 1 || m.length !== 0 || e.d.trailingComma) {
          if (u.length === 0 && m.length === 0) {
            f = q.makeTupleObject(es, []);
          } else {
            const e = [];
            u.forEach(t => {
              const n = qe(t.d.valueExpr);
              e.push({
                type: n.type,
                isUnbounded: false
              });
              if (n.isIncomplete) {
                T = true;
              }
            });
            m.forEach(t => {
              var n;
              var a;
              const r = qe(t.d.valueExpr);
              if (r.isIncomplete) {
                T = true;
              }
              const s = (a = (n = st(r, false, t.d.valueExpr)) === null || n === undefined ? undefined : n.type) !== null && a !== undefined ? a : H.UnknownType.create();
              e.push({
                type: s,
                isUnbounded: true
              });
            });
            f = q.makeTupleObject(es, e);
          }
        } else {
          const e = qe(u[0].d.valueExpr);
          f = e.type;
          if (e.isIncomplete) {
            T = true;
          }
        }
        const v = [{
          argCategory: 0,
          typeResult: {
            type: f,
            isIncomplete: T
          }
        }];
        if (a.method === 'set') {
          let e = (s = (r = a.setType) === null || r === undefined ? undefined : r.type) !== null && s !== undefined ? s : H.AnyType.create();
          if (H.isTypeVar(e) && H.TypeVarType.hasConstraints(e)) {
            e = Pt(e, undefined, H.isClassInstance(t) ? (i = t.props) === null || i === undefined ? undefined : i.condition : undefined);
          }
          v.push({
            argCategory: 0,
            typeResult: {
              type: e,
              isIncomplete: !!((o = a.setType) === null || o === undefined ? undefined : o.isIncomplete)
            }
          });
        }
        y.forEach(e => {
          v.push({
            argCategory: 0,
            valueExpression: e.d.valueExpr,
            node: e,
            name: e.d.name
          });
        });
        h.forEach(e => {
          v.push({
            argCategory: 2,
            valueExpression: e.d.valueExpr,
            node: e
          });
        });
        const b = pn(e, v, {
          type: c
        }, undefined, true, undefined);
        return {
          type: (l = b.returnType) !== null && l !== undefined ? l : H.UnknownType.create(),
          isIncomplete: !!b.isTypeIncomplete
        };
      }
      function Qt(e, t, n) {
        const a = [];
        let r = t | 33554432;
        r &= -1073741825;
        const s = () => {
          const t = M.getEnclosingClass(e, true);
          if (t) {
            const e = ca(t);
            if (e && H.ClassType.isDataClass(e.classType)) {
              return true;
            }
          }
          return false;
        };
        if (n == null ? undefined : n.isFinalAnnotation) {
          r |= 16;
          if (!s()) {
            r |= 131072;
          }
        } else {
          if (n == null ? undefined : n.isClassVarAnnotation) {
            r |= 131072;
            if (!s()) {
              r |= 16;
            }
          } else {
            r &= -1065059;
            if (!(n == null ? undefined : n.isAnnotatedClass)) {
              r |= 131088;
            }
            r |= 138412032;
          }
        }
        const i = (t, a) => {
          let s;
          if (n == null ? undefined : n.hasCustomClassGetItem) {
            r = 131170;
            s = {
              ...qe(t, r),
              node: t
            };
          } else {
            if ((n == null ? undefined : n.isAnnotatedClass) && a > 0) {
              r = 131170;
              if (T.isAnnotationEvaluationPostponed(v.getFileInfo(e))) {
                r |= 4;
              }
              s = {
                ...qe(t, r),
                node: t
              };
            } else {
              s = function (e, t, n) {
                let a;
                let r = t | 137;
                const s = v.getFileInfo(e);
                if (s.isStubFile) {
                  r |= 4;
                }
                if (e.nodeType === 34) {
                  a = {
                    type: H.UnknownType.create(),
                    typeList: e.d.items.map(e => ({
                      ...qe(e, r),
                      node: e
                    })),
                    node: e
                  };
                  Ee(e, {
                    type: H.UnknownType.create()
                  });
                } else {
                  if (e.nodeType === 18 && n) {
                    const t = (Ae == null ? undefined : Ae.typedDictClass) && H.isInstantiableClass(Ae.typedDictClass) ? W.createTypedDictTypeInlined(es, e, Ae.typedDictClass) : undefined;
                    a = {
                      type: (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass) ? Ae.strClass : H.UnknownType.create(),
                      inlinedTypeDict: t,
                      node: e
                    };
                  } else {
                    a = {
                      ...qe(e, r),
                      node: e
                    };
                    if (e.nodeType === 18) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.dictInAnnotation(), e);
                    }
                    if (t & 131072 && H.isClass(a.type) && H.ClassType.isBuiltIn(a.type, 'ClassVar')) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.classVarNotAllowed(), e);
                    }
                  }
                }
                return a;
              }(t, r, !!(n == null ? undefined : n.supportsTypedDictTypeArg) && a === 0);
            }
          }
          return s;
        };
        if (e.d.items.length !== 1 || e.d.trailingComma || e.d.items[0].d.name || e.d.items[0].d.valueExpr.nodeType !== 52) {
          e.d.items.forEach((e, r) => {
            const s = i(e.d.valueExpr, r);
            if (e.d.argCategory !== 0 && e.d.argCategory === 1 && (!(n == null ? undefined : n.isAnnotatedClass) || r === 0)) {
              const n = Xt(s.type);
              if (n) {
                s.type = n;
              } else {
                if (t & 256) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackNotAllowed(), e.d.valueExpr);
                  s.typeErrors = true;
                } else {
                  s.type = H.UnknownType.create();
                }
              }
            }
            if (e.d.name) {
              if (t & 256) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.keywordArgInTypeArgument(), e.d.valueExpr);
                s.typeErrors = true;
              } else {
                s.type = H.UnknownType.create();
              }
            }
            if (e.d.valueExpr.nodeType !== 0 || e.d.valueExpr.d.category !== 3) {
              a.push(s);
            }
          });
          return a;
        } else {
          e.d.items[0].d.valueExpr.d.items.forEach((e, t) => {
            a.push(i(e, t));
          });
          Ee(e.d.items[0].d.valueExpr, {
            type: H.UnknownType.create()
          });
          return a;
        }
      }
      function Xt(e) {
        if (H.isTypeVarTuple(e)) {
          if (e.priv.isUnpacked) {
            return undefined;
          } else {
            return H.TypeVarType.cloneForUnpacked(e);
          }
        }
        if (!H.isParamSpec(e)) {
          if (H.isTypeVar(e)) {
            const t = e.shared.boundType;
            if (t && H.isClassInstance(t) && Z.isTupleClass(t)) {
              return H.TypeVarType.cloneForUnpacked(e);
            } else {
              return undefined;
            }
          }
          if (H.isInstantiableClass(e) && !e.priv.includeSubclasses && Z.isTupleClass(e)) {
            return H.ClassType.cloneForUnpacked(e);
          } else {
            return undefined;
          }
        }
      }
      function en(e) {
        return {
          argCategory: e.d.argCategory,
          name: e.d.name,
          valueExpression: e.d.valueExpr
        };
      }
      function tn(e, t) {
        let n;
        let a;
        let r;
        let s;
        let i;
        e.d.args.forEach((e, t) => {
          if (t === 0) {
            if (e.d.argCategory === 0 && !e.d.name) {
              n = e.d.valueExpr;
            }
          } else {
            if (e.d.argCategory === 0 && e.d.name) {
              if (e.d.name.d.value === 'expected_text') {
                s = e.d.valueExpr;
                const t = qe(e.d.valueExpr).type;
                if (H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'str') && typeof t.priv.literalValue == 'string') {
                  i = t.priv.literalValue;
                } else {
                  kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.revealTypeExpectedTextArg(), e.d.valueExpr);
                }
              } else {
                if (e.d.name.d.value === 'expected_type') {
                  a = e.d.valueExpr;
                  r = Z.convertToInstance($a(en(e), {
                    typeExpression: true
                  }).type);
                }
              }
            } else {
              n = undefined;
            }
          }
        });
        if (!n) {
          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.revealTypeArgs(), e);
          return {
            type: H.UnknownType.create()
          };
        }
        const o = qe(n, undefined, t);
        const l = o.type;
        const p = M.printExpression(n);
        const c = Yr(l, {
          expandTypeAlias: true
        });
        if (!o.isIncomplete) {
          if (i !== undefined && i !== c) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.revealTypeExpectedTextMismatch().format({
              expected: i,
              received: c
            }), s ?? n);
          }
          if (r && !H.isTypeSame(r, l, {
            ignorePseudoGeneric: true
          })) {
            const e = Yr(r);
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.revealTypeExpectedTypeMismatch().format({
              expected: e,
              received: c
            }), a ?? n);
          }
          bt(g.LocAddendum.typeOfSymbol().format({
            name: p,
            type: c
          }), e.d.args[0]);
        }
        return {
          type: l,
          isIncomplete: o.isIncomplete
        };
      }
      function nn(e) {
        var t;
        const n = M.getParentNodeOfType(e, 1);
        if (n == null ? undefined : n.parent) {
          return n.parent;
        } else {
          if (e.nodeType === 38 && ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 10 && e.parent.d.name === e) {
            return e.parent;
          } else {
            return e;
          }
        }
      }
      function an(e, t, n, a, r, s) {
        var i;
        var o;
        const l = [];
        const p = [];
        let d = false;
        let c = [];
        let u = false;
        const m = nn(e);
        for (let r = 0; r < t.length; r++) {
          let y;
          const g = t[r];
          const h = g.some(e => e !== undefined);
          let f = [];
          let T = false;
          u = false;
          for (let t = 0; t < n.length; t++) {
            const r = n[t].overload;
            let v = n[t];
            if (h) {
              v = {
                ...n[t]
              };
              v.argParams = v.argParams.map((e, t) => {
                if (!g[t]) {
                  return e;
                }
                const n = {
                  ...e
                };
                n.argType = g[t];
                return n;
              });
            }
            const b = (i = a == null ? undefined : a.clone()) !== null && i !== undefined ? i : new k.ConstraintTracker();
            const _ = nr(m, () => mn(e, v, b, true, s));
            if (_.isTypeIncomplete) {
              d = true;
            }
            if (!_.argumentErrors && _.returnType) {
              c.push(r);
              y = r;
              const e = {
                overload: y,
                matchResults: v,
                constraints: b,
                returnType: _.returnType,
                argResults: (o = _.argResults) !== null && o !== undefined ? o : []
              };
              p.push(e);
              if (!_.anyOrUnknownArg) {
                l.push(_.returnType);
                u = true;
                break;
              }
              f.push(e);
              if (Z.isIncompleteUnknown(_.anyOrUnknownArg)) {
                T = true;
              }
            }
          }
          if (!u && f.length > 0) {
            f = rn(f);
            if (f.length === 1) {
              c = [f[0].overload];
              l.push(f[0].returnType);
            } else {
              let e = [];
              let t = false;
              f.forEach(n => {
                let a = false;
                for (let r = 0; r < e.length; r++) {
                  if (Ir(e[r], n.returnType)) {
                    const n = Z.containsAnyOrUnknown(e[r], false);
                    if (n) {
                      if (H.isAny(n)) {
                        t = true;
                      }
                    } else {
                      a = true;
                    }
                    break;
                  }
                  if (Ir(n.returnType, e[r])) {
                    const a = Z.containsAnyOrUnknown(n.returnType, false);
                    if (a) {
                      if (H.isAny(a)) {
                        t = true;
                      }
                    } else {
                      e[r] = H.NeverType.createNever();
                    }
                    break;
                  }
                }
                if (!a) {
                  e.push(n.returnType);
                }
              });
              e = e.filter(e => !H.isNever(e));
              const n = H.combineTypes(e);
              let a = n;
              if (e.length > 1) {
                a = t ? H.AnyType.create() : H.UnknownType.createPossibleType(n, T);
              }
              l.push(a);
            }
          }
          if (!y) {
            return {
              argumentErrors: true,
              isTypeIncomplete: d,
              overloadsUsedForCall: c
            };
          }
        }
        if (a && u) {
          a.copyFromClone(p[p.length - 1].constraints);
        }
        const y = a ?? p[0].constraints;
        const g = mn(e, p[0].matchResults, y, r, s);
        if (g.isTypeIncomplete) {
          d = true;
        }
        return {
          argumentErrors: g.argumentErrors,
          anyOrUnknownArg: g.anyOrUnknownArg,
          returnType: H.combineTypes(l),
          isTypeIncomplete: d,
          specializedInitSelfType: g.specializedInitSelfType,
          overloadsUsedForCall: c
        };
      }
      function rn(e) {
        if (e.length < 2) {
          return e;
        }
        if (e[0].matchResults.relevance !== e[e.length - 1].matchResults.relevance && (e = e.filter(t => t.matchResults.relevance === e[0].matchResults.relevance)).length < 2) {
          return e;
        }
        if (Z.areTypesSame(e.map(e => e.returnType), {
          treatAnySameAsUnknown: true
        })) {
          return [e[0]];
        }
        const t = e[0].argResults;
        if (!t) {
          return e;
        }
        let n = false;
        for (let a = 0; a < t.length; a++) {
          if (H.isAnyOrUnknown(t[a].argType)) {
            const t = e.map(e => a < e.matchResults.argParams.length ? e.matchResults.argParams[a].paramType : H.UnknownType.create());
            if (!Z.areTypesSame(t, {
              treatAnySameAsUnknown: true
            })) {
              n = true;
            }
          }
        }
        if (n || e.some(e => e.argResults.length !== t.length)) {
          return e;
        } else {
          return [e[0]];
        }
      }
      function sn(e) {
        return e.sort((e, t) => e.relevance !== t.relevance ? t.relevance - e.relevance : e.overloadIndex - t.overloadIndex);
      }
      function on(e, t, n, a, r, s) {
        let i;
        let o = [];
        let l = !!n.isIncomplete;
        const c = n.type;
        nr(nn(e), () => {
          let a = 0;
          H.OverloadedType.getOverloads(c).forEach(r => {
            const s = un(e, t, {
              type: r,
              isIncomplete: n.isIncomplete
            }, a);
            if (!s.argumentErrors) {
              o.push(s);
            }
            a++;
          });
        });
        o = sn(o);
        if (o.length === 0) {
          if (!It(e)) {
            const n = H.OverloadedType.getOverloads(c);
            const a = n.length > 0 && n[0].shared.name ? n[0].shared.name : '<anonymous function>';
            const r = new p.DiagnosticAddendum();
            const s = t.map(e => {
              const t = Yr(Ka(e, undefined).type);
              if (e.argCategory === 1) {
                return `*${t}`;
              } else {
                if (e.argCategory === 2) {
                  return `**${t}`;
                } else {
                  return t;
                }
              }
            });
            r.addMessage(g.LocAddendum.argumentTypes().format({
              types: s.join(', ')
            }));
            kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.noOverload().format({
              name: a
            }) + r.getString(), e);
          }
          return {
            argumentErrors: true,
            isTypeIncomplete: l,
            overloadsUsedForCall: []
          };
        }
        function u(t, n) {
          const r = o.reduce((e, t) => t.argumentMatchScore === e.argumentMatchScore ? t.overloadIndex > e.overloadIndex ? t : e : t.argumentMatchScore < e.argumentMatchScore ? t : e);
          if (n) {
            const t = r.overload.shared.name || '<anonymous function>';
            const n = kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.noOverload().format({
              name: t
            }), e);
            const a = r.overload.shared.declaration;
            if (n && a) {
              n.addRelatedInfo(g.LocAddendum.overloadIndex().format({
                index: r.overloadIndex + 1
              }), a.uri, a.range);
            }
          }
          const i = a ?? new k.ConstraintTracker();
          return mn(e, r, i, t, s);
        }
        if (o.length === 1) {
          return u(false, false);
        }
        let m = [t.map(e => {})];
        while (true) {
          const n = an(e, m, o, a, r, s);
          if (n.isTypeIncomplete) {
            l = true;
          }
          if (!n.argumentErrors) {
            return n;
          }
          if (!i) {
            nr(nn(e), () => {
              i = t.map(e => {
                if (e.typeResult) {
                  return e.typeResult.type;
                }
                if (e.valueExpression) {
                  const t = e.valueExpression;
                  return nr(t, () => qe(t).type);
                }
                return H.AnyType.create();
              });
            });
          }
          m = ln(i, m);
          if (!m || m.length > ie) {
            break;
          }
        }
        if (!It(e) && !l) {
          const e = u(true, true);
          e.returnType = H.UnknownType.create();
          return {
            ...e,
            argumentErrors: true
          };
        }
        return {
          argumentErrors: true,
          isTypeIncomplete: l,
          overloadsUsedForCall: []
        };
      }
      function ln(e, t) {
        let n;
        let a = e.length - 1;
        while (a >= 0 && !t[0][a]) {
          a--;
        }
        a++;
        if (a >= e.length) {
          return;
        }
        while (a < e.length) {
          const t = e[a];
          if (H.isUnion(t)) {
            n = Pt(t);
            break;
          }
          if (H.isTypeVar(t) && H.TypeVarType.hasConstraints(t)) {
            n = Pt(t);
            break;
          }
          a++;
        }
        if (!n) {
          return;
        }
        const r = [];
        t.forEach(e => {
          Z.doForEachSubtype(n, t => {
            const n = [...e];
            n[a] = t;
            r.push(n);
          });
        });
        return r;
      }
      function pn(e, t, n, a, r, s, i = 0) {
        var l;
        let c;
        let u = false;
        let m = false;
        const y = [];
        if (i > H.maxTypeRecursionCount) {
          return {
            returnType: H.UnknownType.create(),
            argumentErrors: true,
            overloadsUsedForCall: y
          };
        }
        i++;
        if ((l = n.type.props) === null || l === undefined ? undefined : l.specialForm) {
          const t = e.nodeType === 9 ? e.d.leftExpr : e;
          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.objectNotCallable().format({
            type: Yr(n.type.props.specialForm, {
              expandTypeAlias: true
            })
          }), t);
          return {
            returnType: H.UnknownType.create(),
            argumentErrors: true,
            overloadsUsedForCall: y
          };
        }
        let h = Dt(n.type, {
          sortSubtypes: true
        }, (l, h, f) => nr(f ? undefined : nn(e), () => {
          const f = function (e, t, n, a, r, s, i, o, l) {
            switch (n.category) {
              case 3:
              case 1:
              case 2:
                if (!r) {
                  t.forEach(e => {
                    if (e.valueExpression && !ar(e.valueExpression)) {
                      Ka(e, undefined);
                    }
                  });
                }
                return {
                  returnType: n
                };
              case 4:
                return function (e, t, n, a, r, s, i) {
                  var o;
                  if (H.TypeBase.isInstantiable(n)) {
                    kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.callableNotInstantiable().format({
                      type: Yr(n)
                    }), e);
                    return {
                      returnType: undefined,
                      argumentErrors: true
                    };
                  }
                  if (H.FunctionType.isBuiltIn(n, 'namedtuple')) {
                    kt(d.DiagnosticRule.reportUntypedNamedTuple, g.LocMessage.namedTupleNoTypes(), e);
                    const a = {
                      returnType: N.createNamedTupleType(es, e, t, false)
                    };
                    fn(e, t, {
                      type: n
                    }, r, s, i);
                    return a;
                  }
                  if (H.FunctionType.isBuiltIn(n, 'NewType')) {
                    return {
                      returnType: An(e, t)
                    };
                  }
                  const l = fn(e, t, {
                    type: n,
                    isIncomplete: a
                  }, r, s, i);
                  let p = !!l.isTypeIncomplete;
                  let c = l.returnType;
                  let u = !!l.argumentErrors;
                  if (!u) {
                    const a = D.applyFunctionTransform(es, e, t, n, {
                      argumentErrors: !!l.argumentErrors,
                      returnType: (o = l.returnType) !== null && o !== undefined ? o : H.UnknownType.create(p),
                      isTypeIncomplete: p
                    });
                    c = a.returnType;
                    if (a.isTypeIncomplete) {
                      p = true;
                    }
                    if (a.argumentErrors) {
                      u = true;
                    }
                  }
                  if (H.FunctionType.isBuiltIn(n, '__import__')) {
                    c = H.AnyType.create();
                  }
                  return {
                    returnType: c,
                    isTypeIncomplete: p,
                    argumentErrors: u,
                    overloadsUsedForCall: l.overloadsUsedForCall,
                    specializedInitSelfType: l.specializedInitSelfType
                  };
                }(e, t, n, r, s, i, o);
              case 5:
                return function (e, t, n, a, r, s, i) {
                  var o;
                  var l;
                  const p = H.OverloadedType.getOverloads(n);
                  if (p.length > 0 && H.FunctionType.isBuiltIn(p[0], ['typing.cast', 'typing_extensions.cast']) && t.length === 2) {
                    return {
                      returnType: cn(t, e)
                    };
                  }
                  const d = on(e, t, {
                    type: n,
                    isIncomplete: a
                  }, r, s, i);
                  let c = (o = d.returnType) !== null && o !== undefined ? o : H.UnknownType.create();
                  let u = !!d.isTypeIncomplete;
                  let m = !!d.argumentErrors;
                  if (!m) {
                    const a = D.applyFunctionTransform(es, e, t, n, {
                      argumentErrors: !!d.argumentErrors,
                      returnType: (l = d.returnType) !== null && l !== undefined ? l : H.UnknownType.create(u),
                      isTypeIncomplete: u
                    });
                    c = a.returnType;
                    if (a.isTypeIncomplete) {
                      u = true;
                    }
                    if (a.argumentErrors) {
                      m = true;
                    }
                  }
                  return {
                    returnType: c,
                    isTypeIncomplete: u,
                    argumentErrors: m,
                    overloadsUsedForCall: d.overloadsUsedForCall,
                    specializedInitSelfType: d.specializedInitSelfType
                  };
                }(e, t, n, r, s, i, o);
              case 6:
                if (Z.isNoneInstance(n)) {
                  kt(d.DiagnosticRule.reportOptionalCall, g.LocMessage.noneNotCallable(), e);
                  return {
                    argumentErrors: true
                  };
                } else {
                  if (H.TypeBase.isInstantiable(n)) {
                    return function (e, t, n, a, r, s) {
                      var i;
                      var o;
                      if (n.priv.literalValue !== undefined) {
                        kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.literalNotCallable(), e);
                        return {
                          returnType: H.UnknownType.create(),
                          argumentErrors: true
                        };
                      }
                      if (H.ClassType.isBuiltIn(n)) {
                        const a = (i = n.priv.aliasName) !== null && i !== undefined ? i : n.shared.name;
                        if (Z.isInstantiableMetaclass(n)) {
                          if (n.priv.typeArgs && n.priv.isTypeArgExplicit) {
                            kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.objectNotCallable().format({
                              type: Yr(n)
                            }), e);
                            return {
                              returnType: H.UnknownType.create(),
                              argumentErrors: true
                            };
                          }
                          w.validateConstructorArgs(es, e, t, n, r, s);
                          if (n.shared.name === 'type' && t.length === 1) {
                            const e = Ka(t[0], undefined);
                            const a = e.type;
                            return {
                              returnType: Z.mapSubtypes(a, e => H.isNever(e) ? e : H.isClass(e) ? Z.convertToInstantiable($e(e)) : H.TypeBase.isInstance(e) && (H.isFunction(e) || H.isTypeVar(e)) ? Z.convertToInstantiable(e) : H.ClassType.specialize(H.ClassType.cloneAsInstance(n), [H.UnknownType.create()])),
                              isTypeIncomplete: e.isIncomplete
                            };
                          }
                          if (t.length >= 2) {
                            return {
                              returnType: xn(e, t, n) || H.AnyType.create()
                            };
                          } else {
                            return {
                              returnType: H.AnyType.create()
                            };
                          }
                        }
                        if (a === 'TypeVar') {
                          return {
                            returnType: bn(e, n, t)
                          };
                        }
                        if (a === 'TypeVarTuple') {
                          return {
                            returnType: Cn(e, n, t)
                          };
                        }
                        if (a === 'ParamSpec') {
                          return {
                            returnType: kn(e, n, t)
                          };
                        }
                        if (a === 'TypeAliasType') {
                          const n = function (e, t) {
                            if (e.nodeType !== 9 || !e.parent || t.length < 2) {
                              return;
                            }
                            if (e.parent.nodeType !== 3 || e.parent.d.rightExpr !== e || e.parent.d.leftExpr.nodeType !== 38) {
                              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeMustBeAssigned(), e);
                              return;
                            }
                            const n = e.parent.d.leftExpr;
                            const a = t[0];
                            if (!a.valueExpression || a.valueExpression.nodeType !== 48) {
                              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeNameArg(), a.valueExpression || e);
                              return;
                            }
                            if (a.valueExpression.d.strings.map(e => e.d.value).join('') !== n.d.value) {
                              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeNameMismatch(), a.valueExpression);
                            }
                            let r;
                            let s;
                            let i;
                            for (let e = 1; e < t.length; e++) {
                              const n = t[e].name;
                              const a = n ? n.d.value : undefined;
                              if (a) {
                                if (a !== 'type_params' || s) {
                                  if (a !== 'value' || r) {
                                    return;
                                  }
                                  r = t[e].valueExpression;
                                } else {
                                  s = t[e].valueExpression;
                                }
                              } else {
                                if (e !== 1) {
                                  return;
                                }
                                r = t[e].valueExpression;
                              }
                            }
                            if (!r) {
                              return;
                            }
                            if (s) {
                              if (s.nodeType !== 52) {
                                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeParamInvalid(), s);
                                return;
                              }
                              i = [];
                              let e = true;
                              s.d.items.map(t => {
                                let a = qe(t, 4224).type;
                                if (H.isTypeVar(a)) {
                                  if (a.priv.scopeId || H.isTypeVarTuple(a) && a.priv.isUnpacked) {
                                    e = false;
                                  } else {
                                    a = H.TypeVarType.cloneForScopeId(a, M.getScopeIdForNode(n), n.d.value, 2);
                                  }
                                  i.push(a);
                                } else {
                                  e = false;
                                }
                              });
                              if (!e) {
                                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeParamInvalid(), s);
                                return;
                              }
                            }
                            return la(n, n, r, true, undefined, () => i);
                          }(e, t);
                          if (n) {
                            return {
                              returnType: n
                            };
                          }
                        }
                        if (a === 'NamedTuple') {
                          const a = {
                            returnType: N.createNamedTupleType(es, e, t, true)
                          };
                          const s = w.getBoundInitMethod(es, e, H.ClassType.cloneAsInstance(n), undefined, 0);
                          if (s && H.isOverloaded(s.type)) {
                            on(e, t, {
                              type: s.type
                            }, undefined, r, undefined);
                          }
                          return a;
                        }
                        if (a === 'NewType') {
                          return {
                            returnType: An(e, t)
                          };
                        }
                        if (H.ClassType.isSpecialFormClass(n)) {
                          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.typeNotIntantiable().format({
                            type: a
                          }), e);
                          return {
                            returnType: H.UnknownType.create(),
                            argumentErrors: true
                          };
                        }
                        if (a === 'TypedDict') {
                          return {
                            returnType: W.createTypedDictType(es, e, n, t)
                          };
                        }
                        if (a === 'auto' && t.length === 0) {
                          return {
                            returnType: P.getEnumAutoValueType(es, e)
                          };
                        }
                      }
                      if (H.isClass(n) && n.shared.effectiveMetaclass && H.isClass(n.shared.effectiveMetaclass) && P.isEnumMetaclass(n.shared.effectiveMetaclass) && !P.isEnumClassWithMembers(es, n)) {
                        return {
                          returnType: (o = P.createEnumType(es, e, n, t)) !== null && o !== undefined ? o : Z.convertToInstance(a)
                        };
                      }
                      if (H.ClassType.supportsAbstractMethods(n)) {
                        const t = zr(n);
                        if (t.length > 0 && !n.priv.includeSubclasses && !H.isTypeVar(a)) {
                          const a = new p.DiagnosticAddendum();
                          const r = 2;
                          t.forEach((e, n) => {
                            if (n === r) {
                              a.addMessage(g.LocAddendum.memberIsAbstractMore().format({
                                count: t.length - r
                              }));
                            } else {
                              if (n < r && H.isInstantiableClass(e.classType)) {
                                const t = e.classType.shared.name;
                                a.addMessage(g.LocAddendum.memberIsAbstract().format({
                                  type: t,
                                  name: e.symbolName
                                }));
                              }
                            }
                          });
                          kt(d.DiagnosticRule.reportAbstractUsage, g.LocMessage.instantiateAbstract().format({
                            type: n.shared.name
                          }) + a.getString(), e);
                        }
                      }
                      if (H.ClassType.isProtocolClass(n) && !n.priv.includeSubclasses) {
                        kt(d.DiagnosticRule.reportAbstractUsage, g.LocMessage.instantiateProtocol().format({
                          type: n.shared.name
                        }), e);
                      }
                      const l = w.validateConstructorArgs(es, e, t, n, r, s);
                      const c = l.overloadsUsedForCall;
                      const u = l.argumentErrors;
                      const m = l.isTypeIncomplete;
                      let y = l.returnType;
                      if (H.isTypeVar(a)) {
                        y = Z.convertToInstance(a);
                      }
                      if (e.nodeType === 9 && y && H.isClassInstance(y) && H.ClassType.isBuiltIn(y, 'deprecated')) {
                        y = H.ClassType.cloneForDeprecatedInstance(y, x.getDeprecatedMessageFromCall(e));
                      }
                      if (y && H.isClassInstance(y) && y.shared.mro.some(e => H.isInstantiableClass(e) && H.ClassType.isBuiltIn(e, 'type'))) {
                        let a = `__class_${y.shared.name}`;
                        if (t.length === 3) {
                          const e = Ka(t[0], undefined).type;
                          if (H.isClassInstance(e) && H.ClassType.isBuiltIn(e, 'str') && typeof e.priv.literalValue == 'string') {
                            a = e.priv.literalValue;
                          }
                        }
                        const r = H.ClassType.createInstantiable(a, '', '', v.getFileInfo(e).fileUri, 0, M.getTypeSourceId(e), H.ClassType.cloneAsInstantiable(y), H.ClassType.cloneAsInstantiable(y));
                        r.shared.baseClasses.push(Za(e, 'object'));
                        r.shared.effectiveMetaclass = n;
                        r.shared.declaration = y.shared.declaration;
                        Z.computeMroLinearization(r);
                        y = r;
                      }
                      return {
                        returnType: y,
                        overloadsUsedForCall: c,
                        argumentErrors: u,
                        isTypeIncomplete: m
                      };
                    }(e, t, n, a, i, o);
                  } else {
                    return function (e, t, n, a, r, s, i, o) {
                      var l;
                      const c = new p.DiagnosticAddendum();
                      const u = et(e, n, '__call__', undefined, c, 528, undefined, o);
                      const m = u == null ? undefined : u.type;
                      if (!m || u.typeErrors) {
                        kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.objectNotCallable().format({
                          type: Yr(n)
                        }) + c.getString(), e);
                        return {
                          returnType: H.UnknownType.create(),
                          argumentErrors: true
                        };
                      }
                      const y = pn(e, t, {
                        type: m
                      }, r, s, i, o);
                      let h = (l = y.returnType) !== null && l !== undefined ? l : H.UnknownType.create();
                      if (H.isTypeVar(a) && H.TypeBase.isInstantiable(a) && H.isClass(n) && H.ClassType.isBuiltIn(n, 'type')) {
                        h = Z.convertToInstance(a);
                      }
                      return {
                        returnType: h,
                        argumentErrors: y.argumentErrors,
                        overloadsUsedForCall: y.overloadsUsedForCall
                      };
                    }(e, t, n, a, s, i, o, l);
                  }
                }
              case 9:
                return pn(e, t, {
                  type: Z.transformPossibleRecursiveTypeAlias(n),
                  isIncomplete: r
                }, s, i, o, l);
              case 7:
                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.moduleNotCallable(), e);
                return {
                  argumentErrors: true
                };
            }
            return {
              argumentErrors: true
            };
          }(e, t, l, h, !!n.isIncomplete, a, r, s, i);
          if (f.argumentErrors) {
            u = true;
          }
          if (f.isTypeIncomplete) {
            m = true;
          }
          if (f.overloadsUsedForCall) {
            o.appendArray(y, f.overloadsUsedForCall);
          }
          c = f.specializedInitSelfType;
          return f.returnType;
        }, {
          allowDiagnostics: true
        }));
        if (u && H.isNever(h) && !h.priv.isNoReturn) {
          h = H.UnknownType.create();
        }
        return {
          argumentErrors: u,
          returnType: h,
          isTypeIncomplete: m,
          specializedInitSelfType: c,
          overloadsUsedForCall: y
        };
      }
      function dn(e, t) {
        const n = H.ClassType.isProtocolClass(e);
        const a = H.ClassType.getSymbolTable(e).get(t);
        if (!a) {
          return;
        }
        if (!a.isClassMember() && !a.isNamedTupleMemberMember()) {
          return;
        }
        const r = j.getLastTypedDeclarationForSymbol(a);
        if (!r) {
          return;
        }
        if (n && r.type === 1) {
          if (!a.getDeclarations().some(e => e.type === 1 && !!e.inferredTypeSource)) {
            return {
              symbol: a,
              symbolName: t,
              classType: e,
              hasImplementation: false
            };
          }
        }
        if (r.type !== 5) {
          return;
        }
        let s = false;
        const i = x.getFunctionInfoFromDecorators(es, r.node, true);
        if (i.flags & 8) {
          s = true;
        }
        const o = v.getFileInfo(r.node).isStubFile;
        const l = a.getDeclarations()[0];
        let p;
        if (l !== r && l.type === 5 && (p = x.getFunctionInfoFromDecorators(es, l.node, true), p.flags & 8 && (s = true), n && i.flags & 256)) {
          if (n && !s && o) {
            return;
          }
          return {
            symbol: a,
            symbolName: t,
            classType: e,
            hasImplementation: false
          };
        }
        if (!n && !s) {
          return;
        }
        const d = !M.isSuiteEmpty(r.node.d.suite) && !xa(r);
        if (!n || s || !d && !o) {
          return {
            symbol: a,
            symbolName: t,
            classType: e,
            hasImplementation: d
          };
        } else {
          return undefined;
        }
      }
      function cn(e, t) {
        var n;
        let a = $a(e[0], {
          typeExpression: true
        }).type;
        const r = M.getTypeVarScopesForNode(t);
        a = Z.makeTypeVarsBound(a, r);
        let s = Ka(e[1], undefined).type;
        if ((n = s.props) === null || n === undefined ? undefined : n.specialForm) {
          s = s.props.specialForm;
        }
        if (H.TypeBase.isInstantiable(a) && !H.isUnknown(a) && H.isTypeSame(Z.convertToInstance(a), s, {
          ignorePseudoGeneric: true
        })) {
          kt(d.DiagnosticRule.reportUnnecessaryCast, g.LocMessage.unnecessaryCast().format({
            type: Yr(s)
          }), t);
        }
        return Z.convertToInstance(a);
      }
      function un(e, t, n, a) {
        var r;
        var s;
        var i;
        var o;
        var c;
        var u;
        var m;
        var y;
        var h;
        var f;
        var T;
        const v = n.type;
        const b = E.getParamListDetails(v);
        const _ = H.FunctionType.getParamSpecFromArgsKwargs(v);
        let C = 0;
        let I = false;
        let w = false;
        let S = !!n.isIncomplete;
        let A = false;
        t = function (e) {
          var t;
          const n = [];
          for (const a of e) {
            if (a.argCategory === 1) {
              const e = Ka(a, undefined).type;
              const r = Z.combineSameSizedTuples(Pt(e), Ae == null ? undefined : Ae.tupleClass);
              if (H.isClassInstance(r) && Z.isTupleClass(r)) {
                const e = (t = r.priv.tupleTypeArgs) !== null && t !== undefined ? t : [];
                if (e.length !== 1 || !e[0].isUnbounded) {
                  for (const t of e) {
                    if (t.isUnbounded) {
                      n.push({
                        ...a,
                        argCategory: 1,
                        valueExpression: undefined,
                        typeResult: {
                          type: q.makeTupleObject(es, [t])
                        }
                      });
                    } else {
                      n.push({
                        ...a,
                        argCategory: 0,
                        valueExpression: undefined,
                        typeResult: {
                          type: t.type
                        }
                      });
                    }
                  }
                  continue;
                }
              }
            }
            n.push(a);
          }
          return n;
        }(t);
        const x = new Map();
        b.params.forEach(e => {
          var t;
          var n;
          l.assert(e !== undefined, 'paramInfo is undefined for param name map');
          const a = e.param;
          if (a.name && a.category === 0 && e.kind !== E.ParamKind.Positional) {
            let r = (n = (t = x.get(a.name)) === null || t === undefined ? undefined : t.argsNeeded) !== null && n !== undefined ? n : 0;
            if (a.category === 0 && !e.defaultType) {
              r += 1;
            }
            x.set(a.name, {
              argsNeeded: r,
              argsReceived: 0
            });
          }
        });
        let P = b.positionOnlyParamCount;
        let D = (r = b.firstKeywordOnlyIndex) !== null && r !== undefined ? r : b.params.length;
        const N = b.argsIndex;
        const F = b.kwargsIndex;
        let M;
        let O;
        let z = false;
        let U = t.findIndex(e => e.argCategory === 2 || e.name !== undefined);
        if (U < 0) {
          U = t.length;
        }
        if (N !== undefined && F !== undefined) {
          l.assert(b.params[N], 'varArgListParamIndex params entry is undefined');
          const e = b.params[N].type;
          l.assert(b.params[F], 'varArgDictParamIndex params entry is undefined');
          const t = b.params[F].type;
          if (H.isParamSpec(e) && e.priv.paramSpecAccess === 'args' && H.isParamSpec(t) && t.priv.paramSpecAccess === 'kwargs' && e.shared.name === t.shared.name) {
            z = true;
            const t = e.priv.scopeId;
            if (Z.getTypeVarScopeIds(v).some(e => e === t)) {
              M = [];
              O = H.TypeVarType.cloneForParamSpecAccess(e, undefined);
            } else {
              P = N;
              U = Math.min(N, U);
              D = N;
            }
          }
        } else {
          if (_ && Z.getTypeVarScopeIds(v).some(e => e === _.priv.scopeId)) {
            z = true;
            M = [];
            O = _;
          }
        }
        if (t.some(e => e.argCategory === 1)) {
          t.forEach(e => {
            if (e.name) {
              const t = b.params.findIndex(t => {
                l.assert(t, 'paramInfo entry is undefined fork kwargs check');
                return t.param.name === e.name.d.value && t.param.category === 0;
              });
              if (t >= 0 && t >= P && (D < 0 || t < D)) {
                D = t;
              }
            }
          });
        }
        if (D < 0) {
          D = b.params.length;
        }
        let V;
        let R = [];
        function L(e, t) {
          if (e.active) {
            V = t;
          }
        }
        const B = t.find(e => e.argCategory === 1) !== undefined;
        let j = 0;
        while (C < U) {
          if (C < P && t[C].name) {
            const e = t[C].name;
            if (e) {
              kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.argPositional(), e);
              w = true;
            }
          }
          const n = U - C;
          const a = D - j - 1;
          if (j >= D) {
            if (M) {
              while (C < U) {
                M.push(t[C]);
                C++;
              }
            } else {
              let n = false;
              if (B && t[C].argCategory === 1) {
                const e = Ka(t[C], undefined).type;
                if (H.isClassInstance(e) && Z.isTupleClass(e) && !Z.isUnboundedTupleClass(e) && e.priv.tupleTypeArgs !== undefined && e.priv.tupleTypeArgs.length > 0) {
                  n = true;
                } else {
                  I = true;
                }
              } else {
                n = true;
              }
              if (n) {
                if (!It(e) && !S) {
                  kt(d.DiagnosticRule.reportCallIssue, D === 1 ? g.LocMessage.argPositionalExpectedOne() : g.LocMessage.argPositionalExpectedCount().format({
                    expected: D
                  }), (s = t[C].valueExpression) !== null && s !== undefined ? s : e);
                }
                w = true;
              }
            }
            break;
          }
          if (j >= b.params.length) {
            break;
          }
          l.assert(b.params[j], 'paramIndex params entry is undefined');
          const r = b.params[j];
          const p = r.type;
          const u = r.param.name;
          const m = r.param.category === 1 && H.isUnpacked(p);
          if (t[C].argCategory === 1) {
            let s = false;
            const l = Ka(t[C], undefined);
            let y;
            let h = false;
            if (j < D && H.isParamSpec(l.type) && l.type.priv.paramSpecAccess === 'args' && r.param.category !== 1) {
              if (!It(e) && !S) {
                kt(d.DiagnosticRule.reportCallIssue, D === 1 ? g.LocMessage.argPositionalExpectedOne() : g.LocMessage.argPositionalExpectedCount().format({
                  expected: D
                }), (i = t[C].valueExpression) !== null && i !== undefined ? i : e);
              }
              w = true;
            }
            const f = l.type;
            if (m && H.isUnpackedTypeVarTuple(f)) {
              y = f;
              s = true;
              h = true;
              A = true;
            } else {
              if (H.isClassInstance(f) && Z.isTupleClass(f) && f.priv.tupleTypeArgs && f.priv.tupleTypeArgs.length === 1 && H.isUnpackedTypeVarTuple(f.priv.tupleTypeArgs[0].type)) {
                y = f.priv.tupleTypeArgs[0].type;
                s = true;
                h = true;
                A = true;
              } else {
                if (m && H.isClassInstance(f) && Z.isTupleClass(f)) {
                  s = true;
                  h = true;
                  if (n < a) {
                    A = true;
                  }
                  y = H.ClassType.cloneForUnpacked(f);
                } else {
                  if (H.isParamSpec(f) && f.priv.paramSpecAccess === 'args') {
                    y = undefined;
                  } else {
                    y = (o = st({
                      type: f,
                      isIncomplete: l.isIncomplete
                    }, false, e, false)) === null || o === undefined ? undefined : o.type;
                    if (r.param.category !== 1) {
                      I = true;
                    }
                  }
                }
              }
            }
            const T = y ? {
              argCategory: 0,
              typeResult: {
                type: y,
                isIncomplete: l.isIncomplete
              }
            } : {
              ...t[C]
            };
            if (l.isIncomplete) {
              S = true;
            }
            if (m && !s) {
              if (!It(e) && !S) {
                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.unpackedArgWithVariadicParam(), t[C].valueExpression || e);
              }
              w = true;
            } else {
              if (M && r.param.category !== 0) {
                M.push(t[C]);
              }
              if (T) {
                R.push({
                  paramCategory: r.param.category,
                  paramType: p,
                  requiresTypeVarMatching: Z.requiresSpecialization(p),
                  argument: T,
                  errorNode: (c = t[C].valueExpression) !== null && c !== undefined ? c : e,
                  paramName: u,
                  isParamNameSynthesized: H.FunctionParam.isNameSynthesized(r.param),
                  mapsToVarArgList: m && n > a
                });
              }
            }
            L(t[C], b.params[j].param);
            if (u && b.params[j].param.category === 0 && x.has(u)) {
              x.get(u).argsReceived++;
            }
            if (h || b.params[j].param.category === 1) {
              C++;
            }
            if (A || b.params[j].param.category !== 1) {
              j++;
            }
          } else {
            if (b.params[j].param.category === 1) {
              L(t[C], b.params[j].param);
              if (M) {
                M.push(t[C]);
                C++;
              } else {
                let r = b.params[j].param.category;
                let s = p;
                const i = b.params[j].param.name;
                if (H.isUnpackedClass(p) && p.priv.tupleTypeArgs && p.priv.tupleTypeArgs.length > 0) {
                  s = p.priv.tupleTypeArgs[0].type;
                }
                r = H.isUnpacked(s) ? 1 : 0;
                if (n <= a) {
                  if (n < a) {
                    if (!It(e) && !S) {
                      kt(d.DiagnosticRule.reportCallIssue, n === 1 ? g.LocMessage.argMorePositionalExpectedOne() : g.LocMessage.argMorePositionalExpectedCount().format({
                        expected: n
                      }), t[C].valueExpression || e);
                    }
                    w = true;
                  }
                  j++;
                } else {
                  R.push({
                    paramCategory: r,
                    paramType: s,
                    requiresTypeVarMatching: Z.requiresSpecialization(p),
                    argument: t[C],
                    errorNode: t[C].valueExpression || e,
                    paramName: i,
                    isParamNameSynthesized: H.FunctionParam.isNameSynthesized(b.params[j].param),
                    mapsToVarArgList: true
                  });
                  C++;
                }
              }
            } else {
              const n = b.params[j];
              const a = n.param.name;
              R.push({
                paramCategory: n.param.category,
                paramType: p,
                requiresTypeVarMatching: Z.requiresSpecialization(p),
                argument: t[C],
                errorNode: t[C].valueExpression || e,
                paramName: a,
                isParamNameSynthesized: H.FunctionParam.isNameSynthesized(n.param)
              });
              L(t[C], n.param);
              if (a && x.has(a) && n.kind !== E.ParamKind.Positional) {
                x.get(a).argsReceived++;
              }
              C++;
              j++;
            }
          }
        }
        let G = false;
        if (P >= 0 && j < P && j < b.params.length && b.params[j].param.category === 1 && !H.isParamSpec(b.params[j].type)) {
          j++;
          G = true;
        }
        if (P >= 0 && j < P && (!B || z)) {
          const n = b.params.findIndex(e => !!e.defaultType);
          let a = (n >= 0 && n < P ? n : P) - U;
          if (G) {
            a--;
          }
          const r = b.params.findIndex(e => e.param.category === 1 && !H.isParamSpec(e.type));
          if (r >= j && r < P) {
            a--;
          }
          if (a > 0) {
            if (!It(e) && !S) {
              kt(d.DiagnosticRule.reportCallIssue, a === 1 ? g.LocMessage.argMorePositionalExpectedOne() : g.LocMessage.argMorePositionalExpectedCount().format({
                expected: a
              }), t.length > U && t[U].valueExpression || e);
            }
            w = true;
          }
        }
        if (!w) {
          let n;
          let a;
          while (C < t.length) {
            if (t[C].argCategory === 2) {
              const r = Ka(t[C], Z.makeInferenceContext(b.unpackedKwargsTypedDictType));
              const s = r.type;
              if (r.isIncomplete) {
                S = true;
              }
              if (H.isAnyOrUnknown(s)) {
                a = s;
              } else {
                if (H.isClassInstance(s) && H.ClassType.isTypedDictClass(s)) {
                  const n = W.getTypedDictMembersForClass(es, s);
                  const a = new p.DiagnosticAddendum();
                  n.knownItems.forEach((n, r) => {
                    var s;
                    var i;
                    const o = x.get(r);
                    if (o) {
                      if (o.argsReceived > 0) {
                        a.addMessage(g.LocMessage.paramAlreadyAssigned().format({
                          name: r
                        }));
                      } else {
                        o.argsReceived++;
                        const a = b.params.findIndex(e => e.param.name === r);
                        l.assert(a >= 0);
                        const i = b.params[a].type;
                        R.push({
                          paramCategory: 0,
                          paramType: i,
                          requiresTypeVarMatching: Z.requiresSpecialization(i),
                          argument: {
                            argCategory: 0,
                            typeResult: {
                              type: n.valueType
                            }
                          },
                          errorNode: (s = t[C].valueExpression) !== null && s !== undefined ? s : e,
                          paramName: r
                        });
                      }
                    } else {
                      if (b.kwargsIndex !== undefined) {
                        const a = b.params[b.kwargsIndex].type;
                        R.push({
                          paramCategory: 2,
                          paramType: a,
                          requiresTypeVarMatching: Z.requiresSpecialization(a),
                          argument: {
                            argCategory: 0,
                            typeResult: {
                              type: n.valueType
                            }
                          },
                          errorNode: (i = t[C].valueExpression) !== null && i !== undefined ? i : e,
                          paramName: r
                        });
                        x.set(r, {
                          argsNeeded: 1,
                          argsReceived: 1
                        });
                      } else {
                        if (!b.hasUnpackedTypedDict) {
                          a.addMessage(g.LocMessage.paramNameMissing().format({
                            name: r
                          }));
                        }
                      }
                    }
                  });
                  const r = (m = (u = n.extraItems) === null || u === undefined ? undefined : u.valueType) !== null && m !== undefined ? m : lt();
                  if (!H.isNever(r) && b.kwargsIndex !== undefined) {
                    const n = b.params[b.kwargsIndex];
                    R.push({
                      paramCategory: 2,
                      paramType: n.declaredType,
                      requiresTypeVarMatching: Z.requiresSpecialization(n.declaredType),
                      argument: {
                        argCategory: 2,
                        typeResult: {
                          type: r
                        }
                      },
                      errorNode: (y = t[C].valueExpression) !== null && y !== undefined ? y : e,
                      paramName: n.param.name
                    });
                  }
                  if (!a.isEmpty()) {
                    if (!It(e) && !S) {
                      kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.unpackedTypedDictArgument() + a.getString(), t[C].valueExpression || e);
                    }
                    w = true;
                  }
                } else {
                  if (_ && E.isParamSpecKwargs(_, s)) {
                    a = H.AnyType.create();
                    if (!M) {
                      R.push({
                        paramCategory: 2,
                        paramType: _,
                        requiresTypeVarMatching: false,
                        argument: t[C],
                        argType: H.isParamSpec(s) ? undefined : H.AnyType.create(),
                        errorNode: t[C].valueExpression || e
                      });
                    }
                  } else {
                    const r = Ya(e, 'str');
                    if ((Ae == null ? undefined : Ae.supportsKeysAndGetItemClass) && H.isInstantiableClass(Ae.supportsKeysAndGetItemClass) && r && H.isClassInstance(r)) {
                      const i = new k.ConstraintTracker();
                      let o = false;
                      if (H.isTypeVar(s)) {
                        o = true;
                      } else {
                        if (Ir(H.ClassType.cloneAsInstance(Ae.supportsKeysAndGetItemClass), s, undefined, i)) {
                          const e = Xe(Ae.supportsKeysAndGetItemClass, i).priv.typeArgs;
                          if (e && e.length >= 2) {
                            if (Ir(r, e[0])) {
                              o = true;
                            }
                            n = [];
                            Z.doForEachSubtype(e[0], e => {
                              if (H.isClassInstance(e) && typeof e.priv.literalValue == 'string') {
                                if (n != null) {
                                  n.push(e.priv.literalValue);
                                }
                              } else {
                                n = undefined;
                              }
                            });
                            a = e[1];
                          } else {
                            o = true;
                            a = H.UnknownType.create();
                          }
                        }
                      }
                      if (b.kwargsIndex !== undefined && a) {
                        const n = b.params[b.kwargsIndex].type;
                        R.push({
                          paramCategory: 0,
                          paramType: n,
                          requiresTypeVarMatching: Z.requiresSpecialization(n),
                          argType: a,
                          argument: t[C],
                          errorNode: t[C].valueExpression || e,
                          paramName: b.params[b.kwargsIndex].param.name
                        });
                      }
                      if (!o) {
                        if (!It(e) && !S) {
                          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.unpackedDictArgumentNotMapping(), t[C].valueExpression || e);
                        }
                        w = true;
                      }
                    }
                  }
                }
              }
              if (M) {
                M.push(t[C]);
              }
            } else {
              const n = t[C].name;
              if (n) {
                const a = n.d.value;
                const r = x.get(a);
                if (r) {
                  if (r.argsReceived > 0) {
                    if (!It(e) && !S) {
                      kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramAlreadyAssigned().format({
                        name: a
                      }), n);
                    }
                    w = true;
                  } else {
                    r.argsReceived++;
                    const n = b.params.findIndex(e => e.param.name === a && e.kind !== E.ParamKind.Positional);
                    l.assert(n >= 0);
                    const s = b.params[n].type;
                    R.push({
                      paramCategory: 0,
                      paramType: s,
                      requiresTypeVarMatching: Z.requiresSpecialization(s),
                      argument: t[C],
                      errorNode: (h = t[C].valueExpression) !== null && h !== undefined ? h : e,
                      paramName: a
                    });
                    L(t[C], b.params[n].param);
                  }
                } else {
                  if (M) {
                    M.push(t[C]);
                  } else {
                    if (b.kwargsIndex !== undefined) {
                      const r = b.params[b.kwargsIndex].type;
                      if (H.isParamSpec(r)) {
                        if (!It(e) && !S) {
                          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramNameMissing().format({
                            name: n.d.value
                          }), n);
                        }
                        w = true;
                      } else {
                        R.push({
                          paramCategory: 2,
                          paramType: r,
                          requiresTypeVarMatching: Z.requiresSpecialization(r),
                          argument: t[C],
                          errorNode: (f = t[C].valueExpression) !== null && f !== undefined ? f : e,
                          paramName: a
                        });
                        x.set(a, {
                          argsNeeded: 1,
                          argsReceived: 1
                        });
                        l.assert(b.params[b.kwargsIndex], 'paramDetails.kwargsIndex params entry is undefined');
                      }
                      L(t[C], b.params[b.kwargsIndex].param);
                    } else {
                      if (!It(e) && !S) {
                        kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramNameMissing().format({
                          name: n.d.value
                        }), n);
                      }
                      w = true;
                    }
                  }
                }
              } else {
                if (t[C].argCategory === 0) {
                  if (M) {
                    M.push(t[C]);
                  } else {
                    if (!It(e) && !S) {
                      kt(d.DiagnosticRule.reportCallIssue, D === 1 ? g.LocMessage.argPositionalExpectedOne() : g.LocMessage.argPositionalExpectedCount().format({
                        expected: D
                      }), t[C].valueExpression || e);
                    }
                    w = true;
                  }
                } else {
                  if (t[C].argCategory === 1 && _) {
                    const n = Ka(t[C], undefined);
                    const a = n.type;
                    if (n.isIncomplete) {
                      S = true;
                    }
                    if (E.isParamSpecArgs(_, a)) {
                      R.push({
                        paramCategory: 1,
                        paramType: _,
                        requiresTypeVarMatching: false,
                        argument: t[C],
                        argType: H.isParamSpec(a) ? undefined : H.AnyType.create(),
                        errorNode: (T = t[C].valueExpression) !== null && T !== undefined ? T : e
                      });
                    }
                  }
                }
              }
            }
            C++;
          }
          if (!!a && (!B || b.argsIndex !== undefined)) {
            b.params.forEach((r, s) => {
              var i;
              var o;
              const l = r.param;
              if (s >= b.firstPositionOrKeywordIndex && l.category === 0 && l.name && x.has(l.name) && x.get(l.name).argsReceived === 0) {
                const r = b.params[s].type;
                if (!n || !!n.includes(l.name)) {
                  R.push({
                    paramCategory: 0,
                    paramType: r,
                    requiresTypeVarMatching: Z.requiresSpecialization(r),
                    argument: {
                      argCategory: 0,
                      typeResult: {
                        type: a
                      }
                    },
                    errorNode: (o = (i = t.find(e => e.argCategory === 2)) === null || i === undefined ? undefined : i.valueExpression) !== null && o !== undefined ? o : e,
                    paramName: l.name,
                    isParamNameSynthesized: H.FunctionParam.isNameSynthesized(l)
                  });
                  x.get(l.name).argsReceived = 1;
                }
              }
            });
          }
          if (!a && !H.FunctionType.isDefaultParamCheckDisabled(v)) {
            const t = Array.from(x.keys()).filter(e => {
              const t = x.get(e);
              return !t || t.argsReceived < t.argsNeeded;
            });
            if (t.length > 0) {
              if (!It(e)) {
                const n = t.map(e => `"${e}"`).join(', ');
                if (!It(e) && !S) {
                  kt(d.DiagnosticRule.reportCallIssue, t.length === 1 ? g.LocMessage.argMissingForParam().format({
                    name: n
                  }) : g.LocMessage.argMissingForParams().format({
                    names: n
                  }), e);
                }
              }
              w = true;
            }
            b.params.forEach(t => {
              const n = t.param;
              if (n.category === 0 && n.name) {
                const a = x.get(n.name);
                if (a && a.argsNeeded === 0 && a.argsReceived === 0) {
                  const a = t.defaultType;
                  if (a && !Z.isEllipsisType(a) && Z.requiresSpecialization(t.declaredType)) {
                    R.push({
                      paramCategory: n.category,
                      paramType: t.type,
                      requiresTypeVarMatching: true,
                      argument: {
                        argCategory: 0,
                        typeResult: {
                          type: a
                        }
                      },
                      isDefaultArg: true,
                      errorNode: e,
                      paramName: n.name,
                      isParamNameSynthesized: H.FunctionParam.isNameSynthesized(n)
                    });
                  }
                }
              }
            });
          }
        }
        if ((!w || !ar(undefined)) && (l.assert(b.argsIndex === undefined || b.argsIndex < b.params.length, 'paramDetails.argsIndex params entry is invalid'), b.argsIndex !== undefined && b.argsIndex >= 0 && H.FunctionParam.isTypeDeclared(b.params[b.argsIndex].param) && !A)) {
          const t = b.params[b.argsIndex].type;
          const n = R.filter(e => e.mapsToVarArgList);
          if (H.isUnpacked(t) && (!H.isTypeVarTuple(t) || !t.priv.isInUnion)) {
            const a = n.map(t => {
              var n;
              const a = Ka(t.argument, undefined).type;
              if ((H.isUnpackedTypeVarTuple(a) || H.isClassInstance(a) && Z.isTupleClass(a) && a.priv.tupleTypeArgs && a.priv.tupleTypeArgs.length === 1 && H.isUnpackedTypeVarTuple(a.priv.tupleTypeArgs[0].type)) && t.argument.argCategory !== 1 && !t.mapsToVarArgList) {
                if (!It(e) && !S) {
                  kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.typeVarTupleMustBeUnpacked(), (n = t.argument.valueExpression) !== null && n !== undefined ? n : e);
                }
                w = true;
              }
              return {
                type: a,
                isUnbounded: t.argument.argCategory === 1
              };
            });
            let r;
            if (a.length === 1 && !a[0].isUnbounded) {
              const e = a[0].type;
              if (H.isUnpacked(e)) {
                r = Z.makePacked(e);
              }
            }
            if (!r) {
              r = q.makeTupleObject(es, a, false);
            }
            const s = {
              paramCategory: 0,
              paramType: Z.makePacked(t),
              requiresTypeVarMatching: true,
              argument: {
                argCategory: 0,
                typeResult: {
                  type: r
                }
              },
              errorNode: e,
              paramName: b.params[b.argsIndex].param.name,
              isParamNameSynthesized: H.FunctionParam.isNameSynthesized(b.params[b.argsIndex].param),
              mapsToVarArgList: true
            };
            R = [...R.filter(e => !e.mapsToVarArgList), s];
          }
        }
        let K = 0;
        if (I) {
          K--;
        }
        if (H.FunctionType.isBuiltIn(v, ['isinstance', 'issubclass']) && R.length === 2) {
          R[1].isinstanceParam = true;
        }
        return {
          overload: v,
          overloadIndex: a,
          argumentErrors: w,
          isTypeIncomplete: S,
          argParams: R,
          paramSpecTarget: O,
          paramSpecArgList: M,
          activeParam: V,
          relevance: K,
          argumentMatchScore: 0
        };
      }
      function mn(e, t, n, a = false, r) {
        var s;
        const i = t.overload;
        let o = r == null ? undefined : r.expectedType;
        const l = (s = r == null ? undefined : r.returnTypeOverride) !== null && s !== undefined ? s : hr(i);
        if (!l || !Z.requiresSpecialization(l)) {
          o = undefined;
        }
        const p = a => {
          const s = n.clone();
          const i = yn(e, t, s, true, a, l);
          if (!i.argumentErrors && i.returnType) {
            if (Ir(a, (r == null ? undefined : r.returnTypeOverride) ? Xe(r.returnTypeOverride, s) : i.returnType, undefined, undefined, 0)) {
              const e = Z.containsAnyOrUnknown(i.returnType, true);
              if (e) {
                if (H.isAny(e)) {
                  return 2;
                } else {
                  return 1;
                }
              } else {
                return 3;
              }
            }
          }
          return 0;
        };
        if (o) {
          o = nr(nn(e), () => {
            let e;
            let t = -1;
            if (H.isUnion(o)) {
              Z.doForEachSubtype(o, n => {
                if (t < 3) {
                  const a = p(n);
                  if (a > 0 && a > t) {
                    e = n;
                    t = a;
                  }
                }
              }, true);
            }
            if (t < 3) {
              const n = p(o);
              if (n > 0 && n > t) {
                e = o;
              }
            }
            return e;
          });
        }
        if (!o || H.isAnyOrUnknown(o) || H.isNever(o)) {
          return gn(e, t, n, a);
        } else {
          return yn(e, t, n, a, o, l);
        }
      }
      function yn(e, t, n, a = false, r, s) {
        const i = M.getTypeVarScopesForNode(e);
        let o = 2048;
        if (Z.containsLiteralType(r, true)) {
          o |= 256;
        }
        if (H.isClassInstance(s) && H.isClassInstance(r) && !H.isTypeSame(s, r)) {
          const t = new k.ConstraintTracker();
          if (I.addConstraintsForExpectedType(es, s, r, t, i, e.start)) {
            r = Xe(Z.selfSpecializeClass(s, {
              overrideTypeArgs: true
            }), t, {
              replaceUnsolved: {
                scopeIds: Z.getTypeVarScopeIds(s),
                useUnknown: true,
                tupleClassType: ot()
              }
            });
            o |= 4096;
          }
        }
        Ir(s, r = Z.transformExpectedType(r, i, e.start), undefined, n, o);
        return gn(e, t, n, a);
      }
      function gn(e, t, n, a) {
        const r = t.overload;
        let s;
        let i;
        let l = t.isTypeIncomplete;
        let p = false;
        let c = 0;
        const u = nn(e);
        const m = Z.getTypeCondition(r);
        const y = H.FunctionType.getParamSpecFromArgsKwargs(r);
        if (r.priv.boundToType && !r.priv.boundToType.priv.includeSubclasses && r.shared.methodClass) {
          const t = dn(r.shared.methodClass, r.shared.name);
          if (t && !t.hasImplementation) {
            kt(d.DiagnosticRule.reportAbstractUsage, g.LocMessage.abstractMethodInvocation().format({
              method: r.shared.name
            }), e.nodeType === 9 ? e.d.leftExpr : e);
          }
        }
        if (r.shared.name === '__init__' && r.priv.strippedFirstParamType && r.priv.boundToType && H.isClassInstance(r.priv.strippedFirstParamType) && H.isClassInstance(r.priv.boundToType) && H.ClassType.isSameGenericClass(r.priv.strippedFirstParamType, r.priv.boundToType) && r.priv.strippedFirstParamType.priv.typeArgs) {
          const e = r.priv.strippedFirstParamType.shared.typeParams;
          s = r.priv.strippedFirstParamType;
          r.priv.strippedFirstParamType.priv.typeArgs.forEach((t, a) => {
            if (a < e.length) {
              const r = e[a];
              if (!H.isTypeSame(r, t, {
                ignorePseudoGeneric: true
              })) {
                n.setBounds(e[a], t);
              }
            }
          });
        }
        if (H.FunctionType.isBuiltIn(r, ['typing.cast', 'typing_extensions.cast', 'builtins.isinstance', 'builtins.issubclass'])) {
          a = true;
        }
        const h = t.argParams.filter(e => e.requiresTypeVarMatching).length;
        if (h > 0) {
          let e = Math.min(h, 2);
          for (let s = 0; s < e; s++) {
            nr(u, () => {
              t.argParams.forEach(i => {
                if (!i.requiresTypeVarMatching) {
                  return;
                }
                const o = vn(i, n, {
                  type: r,
                  isIncomplete: t.isTypeIncomplete
                }, {
                  skipUnknownArgCheck: a,
                  isArgFirstPass: e > 1 && s === 0,
                  conditionFilter: m,
                  skipReportError: true
                });
                if (o.isTypeIncomplete) {
                  l = true;
                }
                if (s === 0 && e < 2 && o.skippedBareTypeVarExpectedType) {
                  e++;
                }
              });
            });
          }
        }
        let f = false;
        let T = false;
        let v = [];
        const b = [];
        t.argParams.forEach((e, s) => {
          var o;
          const u = vn(e, n, {
            type: r,
            isIncomplete: t.isTypeIncomplete
          }, {
            skipUnknownArgCheck: a,
            conditionFilter: m
          });
          b.push(u);
          if (!u.isCompatible) {
            p = true;
            c += t.argParams.length - s + 1;
          }
          if (u.isTypeIncomplete) {
            l = true;
          }
          if (u.condition) {
            v = (o = H.TypeCondition.combine(v, u.condition)) !== null && o !== undefined ? o : [];
          }
          if (H.isAnyOrUnknown(u.argType)) {
            i = i ? Z.preserveUnknown(u.argType, i) : u.argType;
          }
          if (y) {
            if (e.argument.argCategory === 1 && E.isParamSpecArgs(y, u.argType)) {
              if (f) {
                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecArgsKwargsDuplicate().format({
                  type: Yr(y)
                }), e.errorNode);
              }
              f = true;
            }
            if (e.argument.argCategory === 2 && E.isParamSpecKwargs(y, u.argType)) {
              if (T) {
                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecArgsKwargsDuplicate().format({
                  type: Yr(y)
                }), e.errorNode);
              }
              T = true;
            }
          }
        });
        let _ = [];
        if (t.paramSpecArgList && t.paramSpecTarget) {
          const a = function (e, t, n, a) {
            const r = a.getConstraintSets();
            if (r.length === 1) {
              return Tn(e, t, n, r[0]);
            }
            const s = [];
            const i = [];
            const l = nn(e);
            r.forEach(a => {
              nr(l, () => {
                const r = Tn(e, t, n, a);
                if (!r.argumentErrors) {
                  s.push(a);
                }
                o.appendArray(i, r.constraintTrackers);
              });
            });
            if (s.length > 0) {
              a.addConstraintSets(s);
            }
            const p = Tn(e, t, n, s.length > 0 ? s[0] : r[0]);
            return {
              argumentErrors: p.argumentErrors,
              constraintTrackers: i
            };
          }(e, t.paramSpecArgList, t.paramSpecTarget, n);
          if (a.argumentErrors) {
            p = true;
            c += 1;
          }
          _ = a.constraintTrackers;
        } else {
          if (y) {
            if (!f || !T) {
              if (!l) {
                kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecArgsMissing().format({
                  type: Yr(y)
                }), e);
              }
              p = true;
              c += 1;
            }
          }
        }
        let k = hr(r, {
          callSiteInfo: {
            args: t.argParams,
            errorNode: e
          }
        });
        if (v.length > 0) {
          k = H.TypeBase.cloneForCondition(k, v);
        }
        let w = true;
        if (H.isFunction(k) || H.isOverloaded(k)) {
          w = false;
        }
        let S = Xe(k, n, {
          replaceUnsolved: {
            scopeIds: Z.getTypeVarScopeIds(r),
            unsolvedExemptTypeVars: hn(r, k),
            tupleClassType: ot(),
            eliminateUnsolvedInUnions: w
          }
        });
        S = Z.addConditionToType(S, m, {
          skipBoundTypeVars: true
        });
        if (_.length > 0) {
          _.forEach(e => {
            if (e) {
              S = Xe(S, e);
              I.applySourceSolutionToConstraints(n, I.solveConstraints(es, e));
            }
          });
        }
        if (H.isUnpackedClass(S)) {
          S = H.ClassType.cloneForPacked(S);
        }
        const A = M.getTypeVarScopesForNode(e);
        S = function (e, t, n) {
          if (!H.isFunction(t)) {
            return t;
          }
          const a = Z.getTypeVarArgsRecursive(t).filter(e => !n.some(t => e.priv.scopeId === t));
          if (a.length === 0) {
            return t;
          }
          gr(t);
          const r = M.getScopeIdForNode(e);
          const s = new C.ConstraintSolution();
          const i = a.map(e => {
            const t = H.TypeVarType.cloneForScopeId(e, r, e.priv.scopeName, 1);
            s.setType(e, t);
            return t;
          });
          return Z.applySolvedTypeVars(H.FunctionType.cloneWithNewTypeVarScopeId(t, r, undefined, i), s);
        }(e, S, A);
        if (s) {
          s = Xe(s, n);
        }
        t.argumentMatchScore = c;
        return {
          argumentErrors: p,
          argResults: b,
          anyOrUnknownArg: i,
          returnType: S,
          isTypeIncomplete: l,
          activeParam: t.activeParam,
          specializedInitSelfType: s,
          overloadsUsedForCall: p ? [] : [r]
        };
      }
      function hn(e, t) {
        if (H.isFunction(t) && !t.shared.name) {
          if (t.shared.typeVarScopeId && e.shared.typeVarScopeId) {
            let n = Z.getTypeVarArgsRecursive(t);
            e.shared.parameters.forEach((t, a) => {
              if (H.FunctionParam.isTypeDeclared(t)) {
                const t = Z.getTypeVarArgsRecursive(H.FunctionType.getParamType(e, a));
                n = n.filter(e => !t.some(t => H.isTypeSame(e, t)));
              }
            });
            return n;
          }
        }
        return [];
      }
      function fn(e, t, n, a, r = false, s) {
        const i = un(e, t, n, 0);
        if (i.argumentErrors) {
          t.forEach(e => {
            if (e.valueExpression && !ar(e.valueExpression)) {
              qe(e.valueExpression);
            }
          });
          return {
            argumentErrors: true,
            activeParam: i.activeParam,
            overloadsUsedForCall: []
          };
        } else {
          return mn(e, i, a ?? new k.ConstraintTracker(), r, Z.makeInferenceContext(s == null ? undefined : s.expectedType, s == null ? undefined : s.isTypeIncomplete, s == null ? undefined : s.returnTypeOverride));
        }
      }
      function Tn(e, t, n, a) {
        var r;
        let s = I.solveConstraintSet(es, a).getType(n);
        s = Z.convertTypeToParamSpecValue(s ?? n);
        const i = un(e, t, {
          type: s
        }, 0);
        const o = i.overload;
        const l = new k.ConstraintTracker();
        if (i.argumentErrors) {
          t.forEach(e => {
            if (e.valueExpression && !ar(e.valueExpression)) {
              qe(e.valueExpression);
            }
          });
          return {
            argumentErrors: true,
            constraintTrackers: [l]
          };
        }
        const p = H.FunctionType.getParamSpecFromArgsKwargs(o);
        const c = H.FunctionType.cloneRemoveParamSpecArgsKwargs(o);
        if (p && c.shared.parameters.length === 0 && H.isTypeSame(p, n)) {
          let a;
          let s = 0;
          let i = 0;
          let o = false;
          for (const e of t) {
            const t = (r = Ka(e, undefined)) === null || r === undefined ? undefined : r.type;
            if (e.argCategory === 1) {
              if (E.isParamSpecArgs(n, t)) {
                s++;
              }
            } else {
              if (e.argCategory === 2) {
                if (E.isParamSpecKwargs(n, t)) {
                  i++;
                }
              } else {
                a = a ?? e.valueExpression;
                o = true;
              }
            }
          }
          if (s !== 1 || i !== 1) {
            o = true;
          }
          if (o) {
            kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecArgsMissing().format({
              type: Yr(p)
            }), a ?? e);
          }
          return {
            argumentErrors: o,
            constraintTrackers: [l]
          };
        }
        return {
          argumentErrors: !!gn(e, i, l, undefined).argumentErrors,
          constraintTrackers: [l]
        };
      }
      function vn(e, t, n, a) {
        var r;
        var s;
        let i;
        let o;
        let l = !!(n == null ? undefined : n.isIncomplete);
        let c = true;
        const u = n == null ? undefined : n.type.shared.name;
        let m = false;
        if (e.argument.valueExpression) {
          let T;
          let b = true;
          Z.doForEachSubtype(e.paramType, e => {
            if (!H.isTypeVar(e) || e.priv.scopeId !== (n == null ? undefined : n.type.shared.typeVarScopeId)) {
              b = false;
            }
          });
          if (a.isArgFirstPass && b) {
            m = true;
          } else {
            T = e.paramType;
            if (!H.isFunction(e.paramType) || !H.FunctionType.getParamSpecFromArgsKwargs(e.paramType) || !(t.getConstraintSets().length > 1)) {
              T = Xe(T, t, undefined, {
                useLowerBoundOnly: !!a.isArgFirstPass
              });
            }
          }
          if (T && H.isUnknown(T)) {
            T = undefined;
          }
          if (e.argType) {
            i = e.argType;
          } else {
            const _ = e.isinstanceParam ? 536871546 : 18;
            const C = qe(e.argument.valueExpression, _, Z.makeInferenceContext(T, !!(n == null ? undefined : n.isIncomplete)));
            i = C.type;
            if (C.isIncomplete) {
              l = true;
            }
            if (C.typeErrors) {
              c = false;
            } else {
              if (T && Z.requiresSpecialization(T)) {
                const I = t.clone();
                if (Ir(T, i, undefined, I, (a == null ? undefined : a.isArgFirstPass) ? 8 : 0)) {
                  t.copyFromClone(I);
                } else {
                  c = false;
                }
              }
            }
            o = C.expectedTypeDiagAddendum;
          }
          if (e.argument && e.argument.name && !ar(e.errorNode)) {
            Fe(e.argument.name, {
              type: T ?? i,
              isIncomplete: l
            }, 0);
          }
        } else {
          if (e.argType) {
            i = e.argType;
          } else {
            const k = Ka(e.argument, undefined);
            i = k.type;
            if (k.isIncomplete) {
              l = true;
            }
          }
          if (e.isDefaultArg) {
            i = Xe(i, t);
          }
        }
        if (e.paramCategory === 2 && H.isTypeVar(e.paramType)) {
          i = $e(i);
        }
        if (a.conditionFilter) {
          i = Dt(i, {
            conditionFilter: a.conditionFilter
          }, e => e);
        }
        const y = (r = i.props) === null || r === undefined ? undefined : r.condition;
        let h = (a == null ? undefined : a.skipReportError) ? undefined : new p.DiagnosticAddendum();
        if (H.isParamSpec(e.paramType)) {
          if (e.paramType.priv.paramSpecAccess !== undefined) {
            return {
              isCompatible: c,
              argType: i,
              isTypeIncomplete: l,
              condition: y
            };
          }
          if (H.isParamSpec(i) && i.priv.paramSpecAccess !== undefined) {
            return {
              isCompatible: c,
              argType: i,
              isTypeIncomplete: l,
              condition: y
            };
          }
        }
        let f = 0;
        if (e.isinstanceParam) {
          f |= 16384;
        }
        if (a == null ? undefined : a.isArgFirstPass) {
          f |= 8;
        }
        if (!Ir(e.paramType, i, h == null ? undefined : h.createAddendum(), t, f)) {
          if (!(a == null ? undefined : a.skipReportError)) {
            if (v.getFileInfo(e.errorNode).diagnosticRuleSet.reportArgumentType !== 'none' && !It(e.errorNode) && !l) {
              const w = Yr(i);
              const S = Yr(e.paramType);
              let A;
              A = e.paramName && !e.isParamNameSynthesized ? u ? g.LocMessage.argAssignmentParamFunction().format({
                argType: w,
                paramType: S,
                functionName: u,
                paramName: e.paramName
              }) : g.LocMessage.argAssignmentParam().format({
                argType: w,
                paramType: S,
                paramName: e.paramName
              }) : u ? g.LocMessage.argAssignmentFunction().format({
                argType: w,
                paramType: S,
                functionName: u
              }) : g.LocMessage.argAssignment().format({
                argType: w,
                paramType: S
              });
              if (o) {
                h = o;
              }
              kt(d.DiagnosticRule.reportArgumentType, A + (h == null ? undefined : h.getString()), e.errorNode, (s = h == null ? undefined : h.getEffectiveTextRange()) !== null && s !== undefined ? s : e.errorNode);
            }
          }
          return {
            isCompatible: false,
            argType: i,
            isTypeIncomplete: l,
            skippedBareTypeVarExpectedType: m,
            condition: y
          };
        }
        if (!a.skipUnknownArgCheck) {
          const x = Pt(H.removeUnbound(i));
          function P() {
            const t = new p.DiagnosticAddendum();
            if (e.paramName) {
              t.addMessage((u ? g.LocAddendum.argParamFunction().format({
                paramName: e.paramName,
                functionName: u
              }) : g.LocAddendum.argParam().format({
                paramName: e.paramName
              })) + t.getString());
            }
            return t;
          }
          if (v.getFileInfo(e.errorNode).diagnosticRuleSet.reportUnknownArgumentType !== 'none' && !H.isAny(e.paramType) && !l) {
            if (H.isUnknown(x)) {
              const D = P();
              kt(d.DiagnosticRule.reportUnknownArgumentType, g.LocMessage.argTypeUnknown() + D.getString(), e.errorNode);
            } else {
              if (Z.isPartlyUnknown(x) && !Z.isPartlyUnknown(e.paramType)) {
                const N = P();
                N.addMessage(g.LocAddendum.argumentType().format({
                  type: Yr(x, {
                    expandTypeAlias: true
                  })
                }));
                kt(d.DiagnosticRule.reportUnknownArgumentType, g.LocMessage.argTypePartiallyUnknown() + N.getString(), e.errorNode);
              }
            }
          }
        }
        return {
          isCompatible: c,
          argType: i,
          isTypeIncomplete: l,
          skippedBareTypeVarExpectedType: m,
          condition: y
        };
      }
      function bn(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        var o;
        var l;
        var p;
        let c;
        let m;
        let y = '';
        if (n.length === 0) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarFirstArg(), e);
          return;
        }
        const h = n[0];
        if (h.valueExpression && h.valueExpression.nodeType === 48) {
          y = h.valueExpression.d.strings.map(e => e.d.value).join('');
        } else {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarFirstArg(), h.valueExpression || e);
        }
        const f = H.TypeBase.cloneAsSpecialForm(H.TypeVarType.createInstantiable(y), H.ClassType.cloneAsInstance(t));
        const T = new Map();
        for (let y = 1; y < n.length; y++) {
          const h = n[y].name;
          const b = h ? h.d.value : undefined;
          if (b) {
            if (T.get(b)) {
              kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.duplicateParam().format({
                name: b
              }), n[y].valueExpression || e);
            }
            if (b === 'bound') {
              if (H.TypeVarType.hasConstraints(f)) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarBoundAndConstrained(), n[y].valueExpression || e);
              } else {
                const t = (r = (a = n[y].typeResult) === null || a === undefined ? undefined : a.type) !== null && r !== undefined ? r : Ha(n[y].valueExpression, {
                  noNonTypeSpecialForms: true,
                  typeExpression: true,
                  parsesStringLiteral: true
                }).type;
                if (Z.requiresSpecialization(t, {
                  ignorePseudoGeneric: true,
                  ignoreImplicitTypeArgs: true
                })) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarBoundGeneric(), n[y].valueExpression || e);
                }
                f.shared.boundType = Z.convertToInstance(t);
              }
            } else {
              if (b === 'covariant') {
                if (n[y].valueExpression && Sn(n[y].valueExpression)) {
                  if (f.shared.declaredVariance === 4 || f.shared.declaredVariance === 0) {
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarVariance(), n[y].valueExpression);
                  } else {
                    f.shared.declaredVariance = 3;
                  }
                }
              } else {
                if (b === 'contravariant') {
                  if (n[y].valueExpression && Sn(n[y].valueExpression)) {
                    if (f.shared.declaredVariance === 3 || f.shared.declaredVariance === 0) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarVariance(), n[y].valueExpression);
                    } else {
                      f.shared.declaredVariance = 4;
                    }
                  }
                } else {
                  if (b === 'infer_variance') {
                    if (n[y].valueExpression && Sn(n[y].valueExpression)) {
                      if (f.shared.declaredVariance === 3 || f.shared.declaredVariance === 4) {
                        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarVariance(), n[y].valueExpression);
                      } else {
                        f.shared.declaredVariance = 0;
                      }
                    }
                  } else {
                    if (b === 'default') {
                      m = n[y].valueExpression;
                      const a = (i = (s = n[y].typeResult) === null || s === undefined ? undefined : s.type) !== null && i !== undefined ? i : Ha(m, {
                        allowTypeVarsWithoutScopeId: true,
                        typeExpression: true
                      }).type;
                      f.shared.defaultType = Z.convertToInstance(a);
                      f.shared.isDefaultExplicit = true;
                      const r = v.getFileInfo(e);
                      if (!r.isStubFile && u.PythonVersion.isLessThan(r.executionEnvironment.pythonVersion, u.pythonVersion3_13) && t.shared.moduleName !== 'typing_extensions') {
                        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultIllegal(), m);
                      }
                    } else {
                      kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.typeVarUnknownParam().format({
                        name: b
                      }), ((o = n[y].node) === null || o === undefined ? undefined : o.d.name) || n[y].valueExpression || e);
                    }
                  }
                }
              }
            }
            T.set(b, b);
          } else {
            if (H.TypeVarType.hasBound(f)) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarBoundAndConstrained(), n[y].valueExpression || e);
            } else {
              const t = (p = (l = n[y].typeResult) === null || l === undefined ? undefined : l.type) !== null && p !== undefined ? p : Ha(n[y].valueExpression, {
                typeExpression: true
              }).type;
              if (Z.requiresSpecialization(t, {
                ignorePseudoGeneric: true
              })) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarConstraintGeneric(), n[y].valueExpression || e);
              }
              H.TypeVarType.addConstraint(f, Z.convertToInstance(t));
              if (c === undefined) {
                c = n[y];
              }
            }
          }
        }
        if (f.shared.constraints.length === 1 && c) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarSingleConstraint(), c.valueExpression || e);
        }
        if (f.shared.isDefaultExplicit && m) {
          _n(f, m);
        }
        return f;
      }
      function _n(e, t) {
        l.assert(e.shared.isDefaultExplicit);
        const n = new k.ConstraintTracker();
        const a = Pt(Xe(e.shared.defaultType, n, {
          replaceUnsolved: {
            scopeIds: Z.getTypeVarScopeIds(e),
            tupleClassType: ot()
          }
        }));
        if (e.shared.boundType) {
          if (!Ir(e.shared.boundType, a)) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultBoundMismatch(), t);
          }
        } else {
          if (H.TypeVarType.hasConstraints(e)) {
            let n = true;
            if (H.isTypeVar(e.shared.defaultType) && H.TypeVarType.hasConstraints(e.shared.defaultType)) {
              for (const t of e.shared.defaultType.shared.constraints) {
                if (!e.shared.constraints.some(e => H.isTypeSame(e, t))) {
                  n = false;
                }
              }
            } else {
              if (!e.shared.constraints.some(e => H.isTypeSame(e, a, {
                ignoreConditions: true
              }))) {
                n = false;
              }
            }
            if (!n) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultConstraintMismatch(), t);
            }
          }
        }
      }
      function Cn(e, t, n) {
        var a;
        var r;
        let s = '';
        if (n.length === 0) {
          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.typeVarFirstArg(), e);
          return;
        }
        const i = n[0];
        if (i.valueExpression && i.valueExpression.nodeType === 48) {
          s = i.valueExpression.d.strings.map(e => e.d.value).join('');
        } else {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarFirstArg(), i.valueExpression || e);
        }
        const o = H.TypeBase.cloneAsSpecialForm(H.TypeVarType.createInstantiable(s, H.TypeVarKind.TypeVarTuple), H.ClassType.cloneAsInstance(t));
        o.shared.defaultType = q.makeTupleObject(es, [{
          type: H.UnknownType.create(),
          isUnbounded: true
        }]);
        for (let s = 1; s < n.length; s++) {
          const i = n[s].name;
          const l = i ? i.d.value : undefined;
          if (l) {
            if (l === 'default') {
              const a = n[s].valueExpression;
              if (a) {
                const e = In(a, false);
                if (e) {
                  o.shared.defaultType = e;
                  o.shared.isDefaultExplicit = true;
                }
              }
              const r = v.getFileInfo(e);
              if (!r.isStubFile && u.PythonVersion.isLessThan(r.executionEnvironment.pythonVersion, u.pythonVersion3_13) && t.shared.moduleName !== 'typing_extensions') {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultIllegal(), a);
              }
            } else {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarTupleUnknownParam().format({
                name: ((a = n[s].name) === null || a === undefined ? undefined : a.d.value) || '?'
              }), ((r = n[s].node) === null || r === undefined ? undefined : r.d.name) || n[s].valueExpression || e);
            }
          } else {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarTupleConstraints(), n[s].valueExpression || e);
          }
        }
        return o;
      }
      function In(e, t) {
        const n = Ha(e, {
          allowUnpackedTuple: true,
          allowTypeVarsWithoutScopeId: true,
          forwardRefs: t,
          typeExpression: true
        }).type;
        const a = H.isClass(n) && Z.isTupleClass(n) && n.priv.isUnpacked;
        const r = H.isUnpackedTypeVarTuple(n);
        if (a || r) {
          return Z.convertToInstance(n);
        }
        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarTupleDefaultNotUnpacked(), e);
      }
      function kn(e, t, n) {
        if (n.length === 0) {
          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecFirstArg(), e);
          return;
        }
        const a = n[0];
        let r = '';
        if (a.valueExpression && a.valueExpression.nodeType === 48) {
          r = a.valueExpression.d.strings.map(e => e.d.value).join('');
        } else {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecFirstArg(), a.valueExpression || e);
        }
        const s = H.TypeBase.cloneAsSpecialForm(H.TypeVarType.createInstantiable(r, H.TypeVarKind.ParamSpec), H.ClassType.cloneAsInstance(t));
        s.shared.defaultType = H.ParamSpecType.getUnknown();
        for (let a = 1; a < n.length; a++) {
          const r = n[a].name;
          const i = r ? r.d.value : undefined;
          if (!i) {
            kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.paramSpecUnknownArg(), n[a].valueExpression || e);
            break;
          }
          if (i === 'default') {
            const r = n[a].valueExpression;
            if (r) {
              const e = wn(r, false);
              if (e) {
                s.shared.defaultType = e;
                s.shared.isDefaultExplicit = true;
              }
            }
            const i = v.getFileInfo(e);
            if (!i.isStubFile && u.PythonVersion.isLessThan(i.executionEnvironment.pythonVersion, u.pythonVersion3_13) && t.shared.moduleName !== 'typing_extensions') {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultIllegal(), r);
            }
          } else {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecUnknownParam().format({
              name: i
            }), r || n[a].valueExpression || e);
          }
        }
        return s;
      }
      function wn(e, t) {
        const n = H.FunctionType.createSynthesizedInstance('', 65536);
        if (e.nodeType === 21) {
          H.FunctionType.addDefaultParams(n);
          n.shared.flags |= 32768;
          return n;
        }
        if (e.nodeType === 34) {
          e.d.items.forEach((e, a) => {
            const r = Ha(e, {
              allowTypeVarsWithoutScopeId: true,
              forwardRefs: t,
              typeExpression: true
            });
            H.FunctionType.addParam(n, H.FunctionParam.create(0, Z.convertToInstance(r.type), H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${a}`));
          });
          if (e.d.items.length > 0) {
            H.FunctionType.addPositionOnlyParamSeparator(n);
          }
          Fe(e, {
            type: H.AnyType.create()
          }, undefined);
          return n;
        }
        {
          const t = Ha(e, {
            allowParamSpec: true,
            allowTypeVarsWithoutScopeId: true,
            allowEllipsis: true,
            typeExpression: true
          });
          if (t.typeErrors) {
            return;
          }
          if (H.isParamSpec(t.type)) {
            H.FunctionType.addParamSpecVariadics(n, t.type);
            return n;
          }
          if (H.isClassInstance(t.type) && H.ClassType.isBuiltIn(t.type, ['EllipsisType', 'ellipsis'])) {
            H.FunctionType.addDefaultParams(n);
            return n;
          }
        }
        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramSpecDefaultNotTuple(), e);
      }
      function Sn(e) {
        if (e.nodeType === 14) {
          if (e.d.constType === 15) {
            return false;
          }
          if (e.d.constType === 33) {
            return true;
          }
        }
        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.expectedBoolLiteral(), e);
        return false;
      }
      function An(e, t) {
        var n;
        var a;
        var r;
        var s;
        var i;
        const o = v.getFileInfo(e);
        let l = '';
        if (t.length !== 2) {
          kt(d.DiagnosticRule.reportCallIssue, g.LocMessage.newTypeParamCount(), e);
          return;
        }
        const p = t[0];
        if (p.argCategory === 0 && p.valueExpression && p.valueExpression.nodeType === 48) {
          l = p.valueExpression.d.strings.map(e => e.d.value).join('');
        }
        if (!l) {
          kt(d.DiagnosticRule.reportArgumentType, g.LocMessage.newTypeBadName(), (n = t[0].node) !== null && n !== undefined ? n : e);
          return;
        }
        if (((a = e.parent) === null || a === undefined ? undefined : a.nodeType) === 3 && e.parent.d.leftExpr.nodeType === 38 && e.parent.d.leftExpr.d.value !== l) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeNameMismatch(), e.parent.d.leftExpr);
          return;
        }
        let c = $a(t[1]).type;
        let u = false;
        if (H.isAnyOrUnknown(c)) {
          c = (r = Ae == null ? undefined : Ae.objectClass) !== null && r !== undefined ? r : H.UnknownType.create();
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeAnyOrUnknown(), (s = t[1].node) !== null && s !== undefined ? s : e);
          u = true;
        }
        if (((i = c.props) === null || i === undefined ? undefined : i.specialForm) && H.isClassInstance(c.props.specialForm) && H.ClassType.isBuiltIn(c.props.specialForm, 'Annotated')) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeNotAClass(), t[1].node || e);
          return;
        }
        if (!H.isInstantiableClass(c)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeNotAClass(), t[1].node || e);
          return;
        }
        if (H.ClassType.isProtocolClass(c) || H.ClassType.isTypedDictClass(c)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeProtocolClass(), t[1].node || e);
        } else {
          if (c.priv.literalValue !== undefined) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.newTypeLiteral(), t[1].node || e);
          }
        }
        const m = H.ClassType.createInstantiable(l, M.getClassFullName(e, o.moduleName, l), o.moduleName, o.fileUri, 6291712, M.getTypeSourceId(e), undefined, c.shared.effectiveMetaclass);
        m.shared.baseClasses.push(u ? H.AnyType.create() : c);
        Z.computeMroLinearization(m);
        if (!u) {
          const e = H.FunctionType.createSynthesizedInstance('__init__');
          H.FunctionType.addParam(e, H.FunctionParam.create(0, H.ClassType.cloneAsInstance(m), H.FunctionParamFlags.TypeDeclared, 'self'));
          H.FunctionType.addParam(e, H.FunctionParam.create(0, H.ClassType.cloneAsInstance(c), H.FunctionParamFlags.TypeDeclared, '_x'));
          e.shared.declaredReturnType = pt();
          H.ClassType.getSymbolTable(m).set('__init__', L.Symbol.createWithType(4, e));
          const t = H.FunctionType.createSynthesizedInstance('__new__', 1);
          H.FunctionType.addParam(t, H.FunctionParam.create(0, m, H.FunctionParamFlags.TypeDeclared, 'cls'));
          H.FunctionType.addDefaultParams(t);
          t.shared.declaredReturnType = H.ClassType.cloneAsInstance(m);
          t.priv.constructorTypeVarScopeId = Z.getTypeVarScopeId(m);
          H.ClassType.getSymbolTable(m).set('__new__', L.Symbol.createWithType(4, t));
        }
        return m;
      }
      function xn(e, t, n) {
        const a = v.getFileInfo(e);
        const r = Ka(t[0], undefined).type;
        if (!H.isClassInstance(r) || !H.ClassType.isBuiltIn(r, 'str')) {
          return;
        }
        const s = r.priv.literalValue || '_';
        const i = Ka(t[1], undefined).type;
        if (!H.isClassInstance(i) || !Z.isTupleClass(i) || i.priv.tupleTypeArgs === undefined) {
          return;
        }
        const o = H.ClassType.createInstantiable(s, M.getClassFullName(e, a.moduleName, s), a.moduleName, a.fileUri, 4194304, M.getTypeSourceId(e), n, i.shared.effectiveMetaclass);
        i.priv.tupleTypeArgs.forEach(e => {
          const t = Pt(e.type);
          if (Z.isEffectivelyInstantiable(t)) {
            o.shared.baseClasses.push(t);
          } else {
            o.shared.baseClasses.push(H.UnknownType.create());
          }
        });
        if (!Z.computeMroLinearization(o)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.methodOrdering(), e);
        }
        return o;
      }
      function Pn(e, t, n, a, r, s) {
        let i;
        let o = true;
        let p = false;
        const d = [];
        const c = e => {
          let c;
          const u = Pt(e);
          if (H.isClass(u)) {
            c = tt(u, t, e, s);
          }
          if (c) {
            const e = n.map(e => ({
              argCategory: 0,
              typeResult: e
            }));
            let s;
            s = nr(a, () => {
              l.assert(c !== undefined);
              return pn(a, e, {
                type: c
              }, undefined, true, r);
            });
            if (s.argumentErrors && r) {
              s = nr(a, () => {
                l.assert(c !== undefined);
                return pn(a, e, {
                  type: c
                }, undefined, true, undefined);
              });
            }
            if (s.argumentErrors) {
              o = false;
            } else {
              if (s.overloadsUsedForCall) {
                s.overloadsUsedForCall.forEach(e => {
                  d.push(e);
                  if (e.shared.deprecatedMessage && H.isClass(u)) {
                    i = {
                      deprecatedMessage: e.shared.deprecatedMessage,
                      className: u.shared.name,
                      methodName: t
                    };
                  }
                });
              }
            }
            if (s.isTypeIncomplete) {
              p = true;
            }
            return s.returnType;
          }
          o = false;
        };
        const u = Z.mapSubtypes(e, e => H.isAnyOrUnknown(e) ? e : H.isClassInstance(e) || H.isInstantiableClass(e) || H.isTypeVar(e) ? c(e) : Z.isNoneInstance(e) && (Ae == null ? undefined : Ae.objectClass) && H.isInstantiableClass(Ae.objectClass) ? c(H.ClassType.cloneAsInstance(Ae.objectClass)) : Z.isNoneTypeClass(e) && (Ae == null ? undefined : Ae.typeClass) && H.isInstantiableClass(Ae.typeClass) ? c(H.ClassType.cloneAsInstance(Ae.typeClass)) : void (o = false));
        if (o) {
          return {
            type: u,
            isIncomplete: p,
            magicMethodDeprecationInfo: i,
            overloadsUsedForCall: d
          };
        }
      }
      function Dn(e, t, n, a) {
        n.expectedType = Z.transformPossibleRecursiveTypeAlias(n.expectedType);
        let r = Pt(n.expectedType);
        if (!H.isClassInstance(r)) {
          return;
        }
        const s = [];
        const i = [];
        let o;
        let l;
        let p = false;
        let d = false;
        if (H.ClassType.isTypedDictClass(r)) {
          r = H.TypeBase.cloneForCondition(r, undefined);
          const n = Nn(e, t, s, i, true, true, undefined, undefined, W.getTypedDictMembersForClass(es, r), a);
          if (n.isIncomplete) {
            p = true;
          }
          if (n.typeErrors) {
            d = true;
          }
          const o = W.assignToTypedDict(es, r, s, i, (a == null ? undefined : a.isEmpty()) ? a : undefined);
          if (o) {
            return {
              type: o,
              isIncomplete: p
            };
          } else {
            return undefined;
          }
        }
        if (H.isAnyOrUnknown(n.expectedType)) {
          o = n.expectedType;
          l = n.expectedType;
        } else {
          const t = Ya(e, 'dict');
          if (!H.isClassInstance(t)) {
            return;
          }
          const a = new k.ConstraintTracker();
          if (!I.addConstraintsForExpectedType(es, t, n.expectedType, a, M.getTypeVarScopesForNode(e), e.start)) {
            return;
          }
          const r = Xe(H.ClassType.cloneAsInstantiable(t), a);
          if (!r.priv.typeArgs || r.priv.typeArgs.length !== 2) {
            return;
          }
          o = r.priv.typeArgs[0];
          l = r.priv.typeArgs[1];
        }
        let c = false;
        if (H.isClassInstance(n.expectedType) && n.expectedType.shared.typeParams.length >= 2) {
          const e = n.expectedType.shared.typeParams[1];
          if (H.TypeVarType.getVariance(e) === 2) {
            c = true;
          }
        }
        const u = Nn(e, t, s, i, true, c, o, l, undefined, a);
        if (u.isIncomplete) {
          p = true;
        }
        if (u.typeErrors) {
          d = true;
        }
        const m = On(Z.makeInferenceContext(o), s.map(e => e.type), false);
        const y = On(Z.makeInferenceContext(l), i.map(e => e.type), !c);
        if (!m || !y) {
          return;
        }
        return {
          type: Ya(e, 'dict', [m, y]),
          isIncomplete: p,
          typeErrors: d
        };
      }
      function Nn(e, t, n, a, r, s, i, o, l, p) {
        let c = false;
        let u = false;
        const m = t & -393;
        e.d.items.forEach((y, h) => {
          var f;
          var T;
          var v;
          var b;
          var _;
          var C;
          let I = true;
          if (y.nodeType === 20) {
            const d = qe(y.d.keyExpr, m | 268435456, Z.makeInferenceContext(i ?? (r ? H.NeverType.createNever() : undefined)));
            if (d.isIncomplete) {
              c = true;
            }
            if (d.typeErrors) {
              u = true;
            }
            const g = d.type;
            let b;
            let _;
            if (!d.isIncomplete && !d.typeErrors) {
              Mn(y.d.keyExpr, g, true);
            }
            if (p && d.expectedTypeDiagAddendum) {
              p.addAddendum(d.expectedTypeDiagAddendum);
            }
            if (l && H.isClassInstance(g) && H.ClassType.isBuiltIn(g, 'str') && Z.isLiteralType(g) && (l.knownItems.has(g.priv.literalValue) || l.extraItems)) {
              let n = (T = (f = l.knownItems.get(g.priv.literalValue)) === null || f === undefined ? undefined : f.valueType) !== null && T !== undefined ? T : (v = l.extraItems) === null || v === undefined ? undefined : v.valueType;
              if (n) {
                const t = M.getTypeVarScopesForNode(e);
                n = Z.transformExpectedType(n, t, e.start);
              }
              _ = Z.makeInferenceContext(n);
              b = qe(y.d.valueExpr, t | 268435456, _);
            } else {
              let n = o ?? (r ? H.NeverType.createNever() : undefined);
              if (n) {
                const t = M.getTypeVarScopesForNode(e);
                n = Z.transformExpectedType(n, t, e.start);
              }
              _ = Z.makeInferenceContext(n);
              b = qe(y.d.valueExpr, t | 268435456, _);
            }
            if (_ && !b.typeErrors) {
              const e = On(_, [b.type], !s);
              if (e) {
                b = {
                  ...b,
                  type: e
                };
              }
            }
            if (p && b.expectedTypeDiagAddendum) {
              p.addAddendum(b.expectedTypeDiagAddendum);
            }
            const C = b.type;
            if (b.isIncomplete) {
              c = true;
            }
            if (b.typeErrors) {
              u = true;
            }
            if (r || h < ae) {
              if (H.isClass(g) && Z.isLiteralType(g)) {
                const e = n.findIndex(e => H.isTypeSame(g, e.type));
                if (e >= 0) {
                  n.splice(e, 1);
                  a.splice(e, 1);
                }
              }
              n.push({
                node: y.d.keyExpr,
                type: g
              });
              a.push({
                node: y.d.valueExpr,
                type: C
              });
            }
            I = false;
          } else {
            if (y.nodeType === 19) {
              let e;
              if (i && o && (Ae == null ? undefined : Ae.supportsKeysAndGetItemClass) && H.isInstantiableClass(Ae.supportsKeysAndGetItemClass)) {
                e = H.ClassType.cloneAsInstance(H.ClassType.specialize(Ae.supportsKeysAndGetItemClass, [i, o]));
              }
              const p = Z.makeInferenceContext(e);
              let m = qe(y.d.expr, t | 268435456, p);
              if (p && !m.typeErrors) {
                const e = On(p, [m.type], !s);
                if (e) {
                  m = {
                    ...m,
                    type: e
                  };
                }
              }
              if (m.isIncomplete) {
                c = true;
              }
              if (m.typeErrors) {
                u = true;
              }
              const f = m.type;
              if (H.isAnyOrUnknown(f)) {
                I = false;
              } else {
                if (H.isClassInstance(f) && H.ClassType.isTypedDictClass(f)) {
                  if ((Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass)) {
                    const e = H.ClassType.cloneAsInstance(Ae.strClass);
                    const t = W.getTypedDictMembersForClass(es, f, true);
                    t.knownItems.forEach((t, r) => {
                      if (t.isRequired || t.isProvided) {
                        n.push({
                          node: y,
                          type: H.ClassType.cloneWithLiteral(e, r)
                        });
                        a.push({
                          node: y,
                          type: t.valueType
                        });
                      }
                    });
                    if (!l) {
                      n.push({
                        node: y,
                        type: H.ClassType.cloneAsInstance(e)
                      });
                      a.push({
                        node: y,
                        type: (_ = (b = t.extraItems) === null || b === undefined ? undefined : b.valueType) !== null && _ !== undefined ? _ : lt()
                      });
                    }
                    I = false;
                  }
                } else {
                  if ((Ae == null ? undefined : Ae.supportsKeysAndGetItemClass) && H.isInstantiableClass(Ae.supportsKeysAndGetItemClass)) {
                    const e = new k.ConstraintTracker();
                    const t = Z.selfSpecializeClass(Ae.supportsKeysAndGetItemClass);
                    if (Ir(H.ClassType.cloneAsInstance(t), f, undefined, e, 256)) {
                      const s = Xe(t, e).priv.typeArgs;
                      if (s && s.length >= 2) {
                        if (r || h < ae) {
                          n.push({
                            node: y,
                            type: s[0]
                          });
                          a.push({
                            node: y,
                            type: s[1]
                          });
                        }
                        I = false;
                      }
                    } else {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.dictUnpackIsNotMapping(), y);
                    }
                  }
                }
              }
            } else {
              if (y.nodeType === 11) {
                const e = Rn(y, t | 268435456, o, i);
                const s = e.type;
                if (e.isIncomplete) {
                  c = true;
                }
                if (e.typeErrors) {
                  u = true;
                }
                if (H.isClassInstance(s) && Z.isTupleClass(s)) {
                  const e = (C = s.priv.tupleTypeArgs) === null || C === undefined ? undefined : C.map(e => e.type);
                  if (e && e.length === 2) {
                    if (r || h < ae) {
                      n.push({
                        node: y,
                        type: e[0]
                      });
                      a.push({
                        node: y,
                        type: e[1]
                      });
                    }
                    I = false;
                  }
                }
              }
            }
          }
          if (I && (r || h < ae)) {
            n.push({
              node: y,
              type: H.UnknownType.create()
            });
            a.push({
              node: y,
              type: H.UnknownType.create()
            });
          }
        });
        return {
          type: H.AnyType.create(),
          isIncomplete: c,
          typeErrors: u
        };
      }
      function Fn(e, t, n) {
        const a = e.nodeType === 34 ? 'list' : 'set';
        n.expectedType = Z.transformPossibleRecursiveTypeAlias(n.expectedType);
        let r = false;
        let s = false;
        const i = e.nodeType === 45;
        const o = En(e, Za(e, a), n);
        if (!o) {
          return;
        }
        const l = [];
        const d = new p.DiagnosticAddendum();
        e.d.items.forEach(e => {
          let n;
          n = e.nodeType === 11 ? Rn(e, t | 268435456, o) : qe(e, t | 268435456, Z.makeInferenceContext(o));
          l.push(n.type);
          if (n.isIncomplete) {
            r = true;
          }
          if (n.typeErrors) {
            s = true;
          }
          if (n.expectedTypeDiagAddendum) {
            d.addAddendum(n.expectedTypeDiagAddendum);
          }
          if (!!i && !n.isIncomplete && !n.typeErrors) {
            Mn(e, n.type, false);
          }
        });
        let c = false;
        if (H.isClassInstance(n.expectedType)) {
          ya(n.expectedType);
          if (n.expectedType.shared.typeParams.some(e => H.TypeVarType.getVariance(e) === 2)) {
            c = true;
          }
        }
        const u = On(Z.makeInferenceContext(o), l, !c);
        if (!u) {
          return {
            type: H.UnknownType.create(),
            isIncomplete: r,
            typeErrors: true,
            expectedTypeDiagAddendum: d
          };
        }
        return {
          type: Ya(e, a, [u]),
          isIncomplete: r,
          typeErrors: s,
          expectedTypeDiagAddendum: d
        };
      }
      function En(e, t, n) {
        if (!n) {
          return;
        }
        if (!t || !H.isInstantiableClass(t)) {
          return;
        }
        if (H.isAnyOrUnknown(n.expectedType)) {
          return n.expectedType;
        }
        if (!H.isClassInstance(n.expectedType)) {
          return;
        }
        const a = new k.ConstraintTracker();
        if (!I.addConstraintsForExpectedType(es, H.ClassType.cloneAsInstance(t), n.expectedType, a, M.getTypeVarScopesForNode(e), e.start)) {
          return;
        }
        const r = Xe(t, a);
        if (r.priv.typeArgs) {
          return r.priv.typeArgs[0];
        } else {
          return undefined;
        }
      }
      function Mn(e, t, n) {
        if (!function (e) {
          let t = true;
          Z.doForEachSubtype(Pt(e), e => {
            if (H.isClassInstance(e)) {
              let n = true;
              if (e.shared.isInstanceHashable !== undefined) {
                n = e.shared.isInstanceHashable;
              } else {
                const t = Z.lookUpObjectMember(e, '__hash__', 4);
                if (t && t.isTypeDeclared) {
                  const e = t.symbol.getTypedDeclarations();
                  const a = t.symbol.getSynthesizedType();
                  if (a) {
                    n = !Z.isNoneInstance(a.type);
                  } else {
                    if (e.every(e => e.type === 1)) {
                      n = false;
                    }
                  }
                }
                e.shared.isInstanceHashable = n;
              }
              if (!n) {
                t = false;
              }
            }
          });
          return t;
        }(t)) {
          const a = new p.DiagnosticAddendum();
          a.addMessage(g.LocAddendum.unhashableType().format({
            type: Yr(t)
          }));
          const r = n ? g.LocMessage.unhashableDictKey() : g.LocMessage.unhashableSetEntry();
          kt(d.DiagnosticRule.reportUnhashable, r + a.getString(), e);
        }
      }
      function On(e, t, n) {
        if (H.isAny(e.expectedType)) {
          return e.expectedType;
        }
        const a = new k.ConstraintTracker();
        const r = e.expectedType;
        let s = true;
        t.forEach(e => {
          if (s && !Ir(r, e, undefined, a)) {
            s = false;
          }
        });
        if (s) {
          if (n && t.length > 0) {
            const n = H.combineTypes(t);
            if (Z.containsLiteralType(e.expectedType)) {
              return n;
            } else {
              return $e(n);
            }
          }
          return Z.mapSubtypes(Xe(e.expectedType, a, {
            replaceUnsolved: {
              scopeIds: [],
              tupleClassType: ot()
            }
          }), e => {
            if (t.length !== 1) {
              return e;
            }
            const n = t[0];
            if (H.isTypeSame(e, n, {
              ignoreTypedDictNarrowEntries: true
            }) && H.isClass(e) && H.isClass(n) && H.ClassType.isTypedDictClass(n)) {
              return H.ClassType.cloneForNarrowedTypedDictEntries(e, n.priv.typedDictNarrowedEntries);
            } else {
              return e;
            }
          });
        }
      }
      function zn(e, t, n, a) {
        let r;
        let s;
        let o = !!(n == null ? undefined : n.isTypeIncomplete);
        let l = true;
        if (t) {
          const n = M.getTypeVarScopesForNode(e);
          t = Z.transformExpectedType(t, n, e.start);
          s = E.getParamListDetails(t);
          r = hr(t);
        }
        let p = H.FunctionType.createInstance('', '', '', 131072);
        p.shared.typeVarScopeId = M.getScopeIdForNode(e);
        return i.invalidateTypeCacheIfCanceled(() => {
          Fe(e, {
            type: p,
            isIncomplete: true
          }, 0);
          let i = false;
          e.d.params.forEach((t, a) => {
            let r;
            if (s && !i) {
              if (a < s.params.length) {
                const e = s.params[a];
                if (e.param.category === t.d.category && !t.d.name == !e.param.name) {
                  r = e.type;
                } else {
                  i = true;
                }
              } else {
                if (t.d.defaultValue) {
                  r = qe(t.d.defaultValue, undefined, n).type;
                }
              }
            } else {
              if (t.d.defaultValue) {
                r = ka(t.d.defaultValue);
              }
            }
            if (t.d.name) {
              Fe(t.d.name, {
                type: wa(e, t.d.category, r ?? H.UnknownType.create())
              }, 0);
            }
            if (t.d.defaultValue) {
              qe(t.d.defaultValue, 1);
            }
            if (a >= 0) {
              let e = false;
              if (t.d.category === 0 && t.d.name) {
                if (B.isPrivateName(t.d.name.d.value)) {
                  e = true;
                }
              } else {
                l = false;
              }
              if (l && !e && p.shared.parameters.length > 0) {
                H.FunctionType.addPositionOnlyParamSeparator(p);
              }
              if (!e) {
                l = false;
              }
            }
            const o = H.FunctionParam.create(t.d.category, r ?? H.UnknownType.create(), H.FunctionParamFlags.TypeDeclared, t.d.name ? t.d.name.d.value : undefined, t.d.defaultValue ? H.AnyType.create(true) : undefined, t.d.defaultValue);
            H.FunctionType.addParam(p, o);
          });
          if (l && p.shared.parameters.length > 0) {
            H.FunctionType.addPositionOnlyParamSeparator(p);
          }
          let d = false;
          nr(a || ar(e) || (n == null ? undefined : n.isTypeIncomplete) ? e.d.expr : undefined, () => {
            const t = qe(e.d.expr, undefined, Z.makeInferenceContext(r));
            p.priv.inferredReturnType = t.type;
            if (t.isIncomplete) {
              o = true;
            }
            if (t.typeErrors) {
              d = true;
            } else {
              if (r && Z.requiresSpecialization(r)) {
                const e = new k.ConstraintTracker();
                if (Ir(r, t.type, undefined, e)) {
                  p = Xe(p, e, {
                    replaceUnsolved: {
                      scopeIds: [],
                      tupleClassType: ot()
                    }
                  });
                }
              }
            }
          }, {
            dependentType: n == null ? undefined : n.expectedType,
            allowDiagnostics: !a && !It(e) && !(n == null ? undefined : n.isTypeIncomplete)
          });
          p.shared.flags &= -131073;
          if (t && !Ir(t, p)) {
            d = true;
          }
          return {
            type: p,
            isIncomplete: o,
            typeErrors: d
          };
        });
      }
      function Un(e, t, n, a, r, s) {
        if (e === 'none') {
          return;
        }
        const i = n.d.value;
        const o = H.removeUnbound(a);
        if (H.isUnknown(o)) {
          kt(t, g.LocMessage.typeUnknown().format({
            name: i
          }), r);
        } else {
          if (Z.isPartlyUnknown(o) && (!s || !H.isClassInstance(a) || !a.priv.isEmptyContainer)) {
            const e = new p.DiagnosticAddendum();
            e.addMessage(g.LocAddendum.typeOfSymbol().format({
              name: i,
              type: Yr(o, {
                expandTypeAlias: true
              })
            }));
            kt(t, g.LocMessage.typePartiallyUnknown().format({
              name: i
            }) + e.getString(), r);
          }
        }
      }
      function Vn(e) {
        var t;
        let n = false;
        if (e.nodeType === 12) {
          const a = qe(e.d.iterableExpr);
          if (a.isIncomplete) {
            n = true;
          }
          const r = (t = st({
            type: $e(a.type),
            isIncomplete: a.isIncomplete
          }, !!e.d.isAsync, e.d.iterableExpr)) !== null && t !== undefined ? t : {
            type: H.UnknownType.create(),
            isIncomplete: a.isIncomplete
          };
          Nt(e.d.targetExpr, r, e.d.iterableExpr);
        } else {
          l.assert(e.nodeType === 13);
          qe(e.d.testExpr);
        }
        return n;
      }
      function Rn(e, t, n, a) {
        let r = false;
        let s = false;
        for (const t of e.d.forIfNodes) {
          if (Vn(t)) {
            r = true;
          }
        }
        let i = H.UnknownType.create();
        if (e.d.expr.nodeType === 20) {
          const o = qe(e.d.expr.d.keyExpr, t, Z.makeInferenceContext(a));
          if (o.isIncomplete) {
            r = true;
          }
          if (o.typeErrors) {
            s = true;
          }
          let l = o.type;
          if (!a || !Z.containsLiteralType(a)) {
            l = $e(l);
          }
          const p = qe(e.d.expr.d.valueExpr, t, Z.makeInferenceContext(n));
          if (p.isIncomplete) {
            r = true;
          }
          if (p.typeErrors) {
            s = true;
          }
          let d = p.type;
          if (!n || !Z.containsLiteralType(n)) {
            d = $e(d);
          }
          i = q.makeTupleObject(es, [{
            type: l,
            isUnbounded: false
          }, {
            type: d,
            isUnbounded: false
          }]);
        } else {
          if (e.d.expr.nodeType === 19) {
            qe(e.d.expr.d.expr, t, Z.makeInferenceContext(n));
          } else {
            if (h.isExpressionNode(e)) {
              const a = qe(e.d.expr, t, Z.makeInferenceContext(n));
              if (a.isIncomplete) {
                r = true;
              }
              if (a.typeErrors) {
                s = true;
              }
              i = a.type;
            }
          }
        }
        return {
          type: i,
          isIncomplete: r,
          typeErrors: s
        };
      }
      function Ln(e, t) {
        if (e.typeList) {
          if (!(t == null ? undefined : t.allowTypeArgList)) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgListNotAllowed(), e.node);
            return false;
          }
          e.typeList.forEach(e => {
            Ln(e);
          });
        }
        if (Z.isEllipsisType(e.type) && !(t == null ? undefined : t.allowTypeArgList)) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisContext(), e.node);
          return false;
        }
        if (H.isModule(e.type)) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.moduleAsType(), e.node);
          return false;
        }
        if (H.isParamSpec(e.type) && !(t == null ? undefined : t.allowParamSpec)) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.paramSpecContext(), e.node);
          return false;
        }
        if (H.isTypeVarTuple(e.type) && !e.type.priv.isInUnion) {
          if (!(t == null ? undefined : t.allowTypeVarTuple)) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeVarTupleContext(), e.node);
            return false;
          }
          Gt(e.type, e.node);
        }
        if (!(t == null ? undefined : t.allowEmptyTuple) && e.isEmptyTupleShorthand) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.zeroLengthTupleNotAllowed(), e.node);
          return false;
        } else {
          return !H.isUnpackedClass(e.type) || !!(t == null ? undefined : t.allowUnpackedTuples) || (kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackedArgInTypeArgument(), e.node), false);
        }
      }
      function Bn(e, t, n) {
        let a;
        let r = H.FunctionType.createInstantiable(0);
        let s = true;
        H.TypeBase.setSpecialForm(r, H.ClassType.cloneAsInstance(e));
        r.shared.declaredReturnType = H.UnknownType.create();
        r.shared.typeVarScopeId = M.getScopeIdForNode(n);
        if (t && t.length > 0) {
          r.priv.isCallableWithTypeArgs = true;
          if (t[0].typeList) {
            const e = t[0].typeList;
            let n = false;
            let a = false;
            const i = e => {
              if (n) {
                if (!a) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.variadicTypeArgsTooMany(), e.node);
                  a = true;
                  s = false;
                }
              }
              n = true;
            };
            e.forEach((e, t) => {
              var n;
              let a = e.type;
              let s = 0;
              const o = `__p${t.toString()}`;
              if (H.isTypeVarTuple(a)) {
                Gt(a, e.node);
                s = 1;
                i(e);
              } else {
                if (Ln(e, {
                  allowUnpackedTuples: true
                })) {
                  if (H.isUnpackedClass(a)) {
                    s = 1;
                    if ((n = a.priv.tupleTypeArgs) === null || n === undefined ? undefined : n.some(e => H.isTypeVarTuple(e.type) || e.isUnbounded)) {
                      i(e);
                    }
                  }
                } else {
                  a = H.UnknownType.create();
                }
              }
              H.FunctionType.addParam(r, H.FunctionParam.create(s, Z.convertToInstance(a), H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, o));
            });
            if (e.length > 0) {
              H.FunctionType.addPositionOnlyParamSeparator(r);
            }
          } else {
            if (Z.isEllipsisType(t[0].type)) {
              H.FunctionType.addDefaultParams(r);
              r.shared.flags |= 32768;
            } else {
              if (H.isParamSpec(t[0].type)) {
                a = t[0].type;
              } else {
                if (H.isInstantiableClass(t[0].type) && H.ClassType.isBuiltIn(t[0].type, 'Concatenate')) {
                  const e = t[0].type.priv.typeArgs;
                  if (e && e.length > 0) {
                    e.forEach((t, n) => {
                      if (n === e.length - 1) {
                        H.FunctionType.addPositionOnlyParamSeparator(r);
                        if (H.isParamSpec(t)) {
                          a = t;
                        } else {
                          if (Z.isEllipsisType(t)) {
                            H.FunctionType.addDefaultParams(r);
                            r.shared.flags |= 32768;
                          }
                        }
                      } else {
                        H.FunctionType.addParam(r, H.FunctionParam.create(0, t, H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${n}`));
                      }
                    });
                  }
                } else {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.callableFirstArg(), t[0].node);
                  s = false;
                }
              }
            }
          }
          if (t.length > 1) {
            let e = t[1].type;
            if (!Ln(t[1])) {
              e = H.UnknownType.create();
            }
            r.shared.declaredReturnType = Z.convertToInstance(e);
          } else {
            kt(d.DiagnosticRule.reportMissingTypeArgument, g.LocMessage.callableSecondArg(), n);
            r.shared.declaredReturnType = H.UnknownType.create();
            s = false;
          }
          if (t.length > 2) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.callableExtraArgs(), t[2].node);
            s = false;
          }
        } else {
          H.FunctionType.addDefaultParams(r, true);
          r.shared.flags |= 32768;
          if (t && t.length === 0) {
            s = false;
          }
        }
        if (a) {
          H.FunctionType.addParamSpecVariadics(r, Z.convertToInstance(a));
        }
        if (Zr(n) && s) {
          r = H.TypeBase.cloneWithTypeForm(r, Z.convertToInstance(r));
        }
        return r;
      }
      function jn(e, t, n, a) {
        var r;
        var s;
        var i;
        if (!n) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.optionalExtraArgs(), t);
            return H.UnknownType.create();
          } else {
            return e;
          }
        }
        if (n.length !== 1) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.optionalExtraArgs(), t);
          return H.UnknownType.create();
        }
        let o = n[0].type;
        if (!Ln(n[0])) {
          o = H.UnknownType.create();
        }
        let l = H.combineTypes([o, (r = Ae == null ? undefined : Ae.noneTypeClass) !== null && r !== undefined ? r : H.UnknownType.create()]);
        if ((Ae == null ? undefined : Ae.unionTypeClass) && H.isInstantiableClass(Ae.unionTypeClass)) {
          l = H.TypeBase.cloneAsSpecialForm(l, H.ClassType.cloneAsInstance(Ae.unionTypeClass));
        }
        if ((s = o.props) === null || s === undefined ? undefined : s.typeForm) {
          const e = H.combineTypes([o.props.typeForm, Z.convertToInstance((i = Ae == null ? undefined : Ae.noneTypeClass) !== null && i !== undefined ? i : H.UnknownType.create())]);
          l = H.TypeBase.cloneWithTypeForm(l, e);
        }
        return l;
      }
      function qn(e, t, n) {
        const a = Ya(e, t);
        if (H.isClassInstance(a)) {
          return H.ClassType.cloneWithLiteral(H.ClassType.cloneRemoveTypePromotions(a), n);
        } else {
          return H.UnknownType.create();
        }
      }
      function Gn(e, t, n, a) {
        const r = Za(e, n);
        if (H.isInstantiableClass(r)) {
          const e = H.ClassType.cloneWithLiteral(r, a);
          H.TypeBase.setSpecialForm(e, t);
          return e;
        }
        return H.UnknownType.create();
      }
      function Wn(e, t, n, a) {
        var r;
        if (a & 131072) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.classVarNotAllowed(), t);
          return H.AnyType.create();
        }
        if (!n) {
          return e;
        }
        if (n.length === 0) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.classVarFirstArgMissing(), t);
          return H.UnknownType.create();
        }
        if (n.length > 1) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.classVarTooManyArgs(), n[1].node);
          return H.UnknownType.create();
        }
        const s = n[0].type;
        if (Z.requiresSpecialization(s, {
          ignorePseudoGeneric: true,
          ignoreSelf: true
        })) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.classVarWithTypeVar(), (r = n[0].node) !== null && r !== undefined ? r : t);
        }
        return s;
      }
      function Kn(e, t, n) {
        if (!n || n.length === 0) {
          return H.ClassType.specialize(e, [H.UnknownType.create()]);
        }
        if (n.length > 1) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsTooMany().format({
            name: e.priv.aliasName || e.shared.name,
            expected: 1,
            received: n.length
          }), n[1].node);
          return H.UnknownType.create();
        }
        const a = n.map(e => Z.convertToInstance(Ln(e) ? e.type : H.UnknownType.create()));
        let r = H.ClassType.specialize(e, a);
        if (Zr(t)) {
          r = H.TypeBase.cloneWithTypeForm(r, Z.convertToInstance(r));
        }
        return r;
      }
      function $n(e, t, n, a) {
        if (!n) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeGuardArgCount(), t);
          }
          return e;
        }
        if (n.length !== 1) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeGuardArgCount(), t);
          return H.UnknownType.create();
        }
        const r = n.map(e => Z.convertToInstance(Ln(e) ? e.type : H.UnknownType.create()));
        let s = H.ClassType.specialize(e, r);
        if (Zr(t)) {
          s = H.TypeBase.cloneWithTypeForm(s, Z.convertToInstance(s));
        }
        return s;
      }
      function Hn(e, t, n, a) {
        var r;
        if (n) {
          kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsExpectingNone().format({
            name: e.shared.name
          }), (r = n[0].node) !== null && r !== undefined ? r : t);
        }
        let s = M.getEnclosingClass(t);
        if (s && !M.isNodeContainedWithin(t, s.d.suite)) {
          s = undefined;
        }
        const i = s ? ca(s) : undefined;
        if (!i) {
          if (a & 384) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.selfTypeContext(), t);
          }
          return H.UnknownType.create();
        }
        if (Z.isInstantiableMetaclass(i.classType)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.selfTypeMetaclass(), t);
          return H.UnknownType.create();
        }
        const o = M.getEnclosingFunction(t);
        if (o) {
          const e = x.getFunctionInfoFromDecorators(es, o, true);
          if (!M.getEnclosingFunction(o)) {
            if (e.flags & 4) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.selfTypeContext(), t);
              return H.UnknownType.create();
            }
            if (o.d.params.length > 0) {
              const e = M.getTypeAnnotationForParam(o, 0);
              if (e && !M.isNodeContainedWithin(t, e)) {
                const n = Ze(e, {
                  typeVarGetsCurScope: true
                });
                if (!H.isTypeVar(n) || !H.TypeVarType.isSelf(n)) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.selfTypeWithTypedSelfOrCls(), t);
                }
              }
            }
          }
        }
        let l = Z.synthesizeTypeVarForSelfCls(i.classType, true);
        if (s) {
          const e = M.getEnclosingClassOrFunctionSuite(t);
          if (e && M.isNodeContainedWithin(e, s) && s.d.suite !== e) {
            l = H.TypeVarType.cloneAsBound(l);
          }
        }
        return l;
      }
      function Zn(e, t, n, a) {
        if (!n && !(a & 256)) {
          return {
            type: e
          };
        }
        if (!n || n.length !== 1) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, e.shared.name === 'ReadOnly' ? g.LocMessage.readOnlyArgCount() : e.shared.name === 'Required' ? g.LocMessage.requiredArgCount() : g.LocMessage.notRequiredArgCount(), t);
          }
          return {
            type: e
          };
        }
        const r = n[0].type;
        const s = M.getEnclosingClass(t, true);
        const i = s ? ca(s) : undefined;
        let o = false;
        if (i && H.isInstantiableClass(i.classType) && H.ClassType.isTypedDictClass(i.classType) && M.isNodeContainedWithinNodeType(t, 54)) {
          o = true;
        }
        let l = n[0].isReadOnly;
        let p = n[0].isRequired;
        let c = n[0].isNotRequired;
        if (e.shared.name === 'ReadOnly') {
          if (a & 2097152) {
            o = true;
          }
          if (n[0].isReadOnly) {
            o = false;
          }
          l = true;
        } else {
          if (a & 1048576) {
            o = true;
          }
          if (n[0].isRequired || n[0].isNotRequired) {
            o = false;
          }
          p = e.shared.name === 'Required';
          c = e.shared.name === 'NotRequired';
        }
        if (o) {
          return {
            type: r,
            isReadOnly: l,
            isRequired: p,
            isNotRequired: c
          };
        } else {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, e.shared.name === 'ReadOnly' ? g.LocMessage.readOnlyNotInTypedDict() : e.shared.name === 'Required' ? g.LocMessage.requiredNotInTypedDict() : g.LocMessage.notRequiredNotInTypedDict(), t);
          }
          return {
            type: e
          };
        }
      }
      function Yn(e, t, n, a) {
        if (!n || n.length !== 1) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackArgCount(), t);
          }
          return e;
        }
        const r = n[0].type;
        if (a & 4194304) {
          const n = Xt(r);
          return n || (a & 256 ? (kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.unpackExpectedTypeVarTuple(), t), H.UnknownType.create()) : e);
        }
        if (a & 8388608) {
          if (H.isInstantiableClass(r) && H.ClassType.isTypedDictClass(r)) {
            return H.ClassType.cloneForUnpacked(r);
          } else {
            if (a & 256) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.unpackExpectedTypedDict(), t);
              return H.UnknownType.create();
            } else {
              return e;
            }
          }
        } else {
          if (a & 256) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.unpackNotAllowed(), t);
            return H.UnknownType.create();
          } else {
            return e;
          }
        }
      }
      function Jn(e, t, n, a) {
        if (a & 16) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.finalContext(), t);
          }
          return e;
        } else {
          if (a & 256 && n && n.length !== 0) {
            if (n.length > 1) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.finalTooManyArgs(), t);
            }
            return H.TypeBase.cloneAsSpecialForm(n[0].type, e);
          } else {
            return e;
          }
        }
      }
      function Qn(e, t, n, a) {
        if (a & 134217728) {
          if (n && n.length !== 0) {
            n.forEach((e, t) => {
              if (t === n.length - 1) {
                if (!H.isParamSpec(e.type) && !Z.isEllipsisType(e.type)) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.concatenateParamSpecMissing(), e.node);
                }
              } else {
                if (H.isParamSpec(e.type)) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.paramSpecContext(), e.node);
                } else {
                  if (H.isUnpackedTypeVarTuple(e.type)) {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeVarTupleContext(), e.node);
                  } else {
                    if (H.isUnpackedClass(e.type)) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackedArgInTypeArgument(), e.node);
                    }
                  }
                }
              }
            });
          } else {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.concatenateTypeArgsMissing(), t);
          }
          return ea(e, n, undefined, true);
        } else {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.concatenateContext(), t);
          }
          return e;
        }
      }
      function Xn(e, t, n, a) {
        var r;
        let s;
        if (a & 33554688) {
          if (n && n.length > 0) {
            s = n[0].type;
            if (n.length < 2) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.annotatedTypeArgMissing(), t);
            } else {
              s = function (e, t, n) {
                for (const e of n);
                return t;
              }(0, n[0].type, n.slice(1));
            }
          }
          return s && n && n.length !== 0 ? (n[0].typeList && kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgListNotAllowed(), n[0].node), {
            type: H.TypeBase.cloneAsSpecialForm(s, H.ClassType.cloneAsInstance(e)),
            isReadOnly: n[0].isReadOnly,
            isRequired: n[0].isRequired,
            isNotRequired: n[0].isNotRequired
          }) : {
            type: H.AnyType.create()
          };
        } else {
          s = H.ClassType.cloneAsInstance(e);
          if (n && n.length >= 1 && ((r = n[0].type.props) === null || r === undefined ? undefined : r.typeForm)) {
            s = H.TypeBase.cloneWithTypeForm(s, n[0].type.props.typeForm);
          }
          return {
            type: s
          };
        }
      }
      function ea(e, t, n, a = false, r = true) {
        const s = H.ClassType.isTupleClass(e);
        if (t) {
          if (s && t.length === 1 && t[0].isEmptyTupleShorthand) {
            t = [];
          } else {
            let e = false;
            const r = t => {
              if (e) {
                if (!i) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.variadicTypeArgsTooMany(), t.node);
                  i = true;
                }
              }
              e = true;
            };
            let i = false;
            t.forEach((e, i) => {
              var o;
              l.assert(t !== undefined);
              if (Z.isEllipsisType(e.type)) {
                if (s) {
                  if (t.length !== 2 || i !== 1) {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisSecondArg(), e.node);
                  } else {
                    if (H.isTypeVarTuple(t[0].type) && !t[0].type.priv.isInUnion) {
                      kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeVarTupleContext(), t[0].node);
                    } else {
                      if (H.isUnpackedClass(t[0].type)) {
                        kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisAfterUnpacked(), e.node);
                      }
                    }
                  }
                } else {
                  if (!a) {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisContext(), e.node);
                  }
                }
              } else {
                if (!H.isParamSpec(e.type) || !a) {
                  if (n === undefined && H.isTypeVarTuple(e.type)) {
                    if (!e.type.priv.isInUnion) {
                      r(e);
                    }
                    Gt(e.type, e.node);
                  } else {
                    if (n === undefined && H.isUnpackedClass(e.type)) {
                      if ((o = e.type.priv.tupleTypeArgs) === null || o === undefined ? undefined : o.some(e => H.isTypeVarTuple(e.type) || e.isUnbounded)) {
                        r(e);
                      }
                      Ln(e, {
                        allowUnpackedTuples: true
                      });
                    } else {
                      Ln(e);
                    }
                  }
                }
              }
            });
          }
        }
        let i;
        let p = t ? t.map(e => Z.convertToInstance(e.type)) : [];
        if (n !== undefined) {
          if (t && p.length > n) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsTooMany().format({
              name: e.priv.aliasName || e.shared.name,
              expected: n,
              received: p.length
            }), t[n].node);
            p = p.slice(0, n);
          } else {
            if (p.length < n) {
              while (p.length < n) {
                p.push(H.UnknownType.create());
              }
            }
          }
        }
        if (s) {
          const n = [];
          if (t) {
            t.forEach((e, t) => {
              if (t === 1 && Z.isEllipsisType(p[t])) {
                if (n.length === 1 && !n[0].isUnbounded) {
                  n[0] = {
                    type: n[0].type,
                    isUnbounded: true
                  };
                }
              } else {
                if (H.isUnpackedClass(e.type) && e.type.priv.tupleTypeArgs) {
                  o.appendArray(n, e.type.priv.tupleTypeArgs);
                } else {
                  n.push({
                    type: p[t],
                    isUnbounded: false
                  });
                }
              }
            });
          } else {
            n.push({
              type: H.UnknownType.create(),
              isUnbounded: true
            });
          }
          i = Z.specializeTupleClass(e, n, t !== undefined);
        } else {
          i = H.ClassType.specialize(e, p, t !== undefined);
        }
        if (r) {
          i = H.TypeBase.cloneAsSpecialForm(i, e);
        }
        return i;
      }
      function ta(e, t, n, a) {
        var r;
        const s = v.getFileInfo(t);
        const i = [];
        let o = false;
        let l = true;
        if (!n) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unionTypeArgCount(), t);
            return H.NeverType.createNever();
          } else {
            return e;
          }
        }
        for (const e of n) {
          let n = e.type;
          if (!Ln(e, {
            allowTypeVarTuple: s.diagnosticRuleSet.enableExperimentalFeatures
          })) {
            n = H.UnknownType.create();
          }
          if (H.isTypeVar(n) && H.isUnpackedTypeVarTuple(n)) {
            if (s.diagnosticRuleSet.enableExperimentalFeatures) {
              n = H.TypeVarType.cloneForUnpacked(n, true);
              o = true;
            } else {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.unionUnpackedTypeVarTuple(), t);
              n = H.UnknownType.create();
              l = false;
            }
          }
          i.push(n);
        }
        if (i.length === 1 && !o && !Z.isNoneInstance(i[0])) {
          if (a & 256) {
            kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.unionTypeArgCount(), t);
          }
          l = false;
        }
        let p = H.combineTypes(i, {
          skipElideRedundantLiterals: true
        });
        if ((Ae == null ? undefined : Ae.unionTypeClass) && H.isInstantiableClass(Ae.unionTypeClass)) {
          p = H.TypeBase.cloneAsSpecialForm(p, H.ClassType.cloneAsInstance(Ae.unionTypeClass));
        }
        if (!l || i.some(e => {
          var t;
          return !((t = e.props) === null || t === undefined ? undefined : t.typeForm);
        })) {
          if ((r = p.props) === null || r === undefined ? undefined : r.typeForm) {
            p = H.TypeBase.cloneWithTypeForm(p, undefined);
          }
        } else {
          if (Zr(t)) {
            const e = H.combineTypes(i.map(e => e.props.typeForm));
            p = H.TypeBase.cloneWithTypeForm(p, e);
          }
        }
        return p;
      }
      function na(e, t, n, a) {
        if (!n) {
          if (a & 262400) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.genericTypeArgMissing(), t);
          }
          return e;
        }
        const r = [];
        if (n) {
          if (n.length === 0) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.genericTypeArgMissing(), t);
          }
          n.forEach(e => {
            if (H.isTypeVar(e.type)) {
              if (r.some(t => H.isTypeSame(t, e.type))) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.genericTypeArgUnique(), e.node);
              }
              r.push(e.type);
            } else {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.genericTypeArgTypeVar(), e.node);
            }
          });
        }
        return ea(e, n, undefined, true);
      }
      function aa(e, t, n, a, r) {
        var s;
        if (Z.isTypeAliasPlaceholder(e)) {
          return e;
        }
        const i = n.shared.recursiveAlias;
        l.assert(i !== undefined);
        let o = i.typeParams;
        if (!o) {
          o = [];
          Z.addTypeVarsToListIfUnique(o, Z.getTypeVarArgsRecursive(e));
          o = o.filter(e => !e.shared.isSynthesized);
        }
        o = o.map(e => H.TypeBase.isInstance(e) ? e : Z.convertToInstance(e));
        const p = o.findIndex(e => H.isTypeVarTuple(e));
        if (p >= 0) {
          const e = o.findIndex((e, t) => t > p && !H.isParamSpec(e) && e.shared.isDefaultExplicit);
          if (e >= 0) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarWithDefaultFollowsVariadic().format({
              typeVarName: o[e].shared.name,
              variadicName: o[p].shared.name
            }), r ? r[e].d.name : t);
          }
        }
        o.forEach((e, n) => {
          var a;
          l.assert(o !== undefined);
          let s = t;
          if (r && n < r.length) {
            s = (a = r[n].d.defaultExpr) !== null && a !== undefined ? a : r[n].d.name;
          }
          ma(s, e, o.slice(0, n), i.typeVarScopeId);
        });
        const c = o.filter(e => H.isTypeVarTuple(e));
        if (c.length > 1) {
          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.variadicTypeParamTooManyAlias().format({
            names: c.map(e => `"${e.shared.name}"`).join(', ')
          }), t);
        }
        if (!i.isPep695Syntax && !a) {
          const e = o.filter(e => e.priv.scopeId !== i.typeVarScopeId && e.priv.scopeType === 0);
          if (e.length > 0) {
            kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.genericTypeAliasBoundTypeVar().format({
              names: e.map(e => `${e.shared.name}`).join(', ')
            }), t);
          }
        }
        if (!H.TypeBase.isInstantiable(e)) {
          return e;
        }
        i.typeParams = o.length > 0 ? o : undefined;
        let u = H.TypeBase.cloneForTypeAlias(e, {
          shared: i,
          typeArgs: undefined
        });
        if (i.isPep695Syntax || a) {
          const e = ct(t, 'TypeAliasType');
          if (e && H.isInstantiableClass(e)) {
            u = H.TypeBase.cloneAsSpecialForm(u, H.ClassType.cloneAsInstance(e));
          }
        }
        if ((s = u.props) === null || s === undefined ? undefined : s.typeForm) {
          u = H.TypeBase.cloneWithTypeForm(u, undefined);
        }
        return u;
      }
      function ra(e, t, n) {
        var a;
        const r = v.getFileInfo(e);
        let s = H.ClassType.createInstantiable(t, M.getClassFullName(e, r.moduleName, t), r.moduleName, r.fileUri, 3, 0, undefined, undefined);
        if (n.isSpecialForm) {
          s.shared.flags |= 8388608;
        }
        if (n.isIllegalInIsinstance) {
          s.shared.flags |= 16777216;
        }
        if (n.typeParamVariance !== undefined) {
          let a = H.TypeVarType.createInstance('T');
          a = H.TypeVarType.cloneForScopeId(a, M.getScopeIdForNode(e), t, 0);
          a.shared.declaredVariance = n.typeParamVariance;
          s.shared.typeParams.push(a);
        }
        const i = (a = v.getDeclaration(e)) !== null && a !== undefined ? a : e.parent ? v.getDeclaration(e.parent) : undefined;
        s.shared.declaration = i;
        if (r.isTypingExtensionsStubFile) {
          s.shared.flags |= 4096;
        }
        const o = n.implicitBaseClass || n.alias || 'object';
        let l;
        if (n.module === 'builtins') {
          l = Za(e, o);
        } else {
          if (n.module === 'collections') {
            l = mt(e, o, ['collections']);
          } else {
            if (n.module === 'self') {
              const t = Ja(e, o, false);
              if (t) {
                l = cr(t.symbol);
                if (H.isInstantiableClass(l) && H.ClassType.isBuiltIn(l, '_TypedDict')) {
                  l = H.ClassType.cloneWithNewFlags(l, l.shared.flags & -1048641);
                }
              }
            }
          }
        }
        if (l && H.isInstantiableClass(l)) {
          if (n.alias) {
            s = H.ClassType.cloneForTypingAlias(l, t);
          } else {
            s.shared.baseClasses.push(l);
            s.shared.effectiveMetaclass = l.shared.effectiveMetaclass;
            Z.computeMroLinearization(s);
          }
        } else {
          s.shared.baseClasses.push(H.UnknownType.create());
          s.shared.effectiveMetaclass = H.UnknownType.create();
          Z.computeMroLinearization(s);
        }
        return s;
      }
      function sa(e) {
        var t;
        var n;
        const a = v.getFileInfo(e);
        if (De(e)) {
          return;
        }
        let r = 0;
        if (a.isStubFile) {
          r |= 1;
        }
        if (e.d.rightExpr.nodeType === 38 || e.d.rightExpr.nodeType === 35) {
          r |= 2;
        }
        let s;
        let i = Ne(e.d.rightExpr, undefined);
        let o = false;
        if (!i) {
          if (a.isTypingStubFile || a.isTypingExtensionsStubFile) {
            i = function (e) {
              if (e.d.leftExpr.nodeType !== 38) {
                return;
              }
              const t = e.d.leftExpr.d.value;
              if (t === 'Any') {
                return H.AnyType.createSpecialForm();
              }
              const n = new Map([['overload', {
                alias: '',
                module: 'builtins'
              }], ['TypeVar', {
                alias: '',
                module: 'builtins'
              }], ['_promote', {
                alias: '',
                module: 'builtins'
              }], ['no_type_check', {
                alias: '',
                module: 'builtins'
              }], ['NoReturn', {
                alias: '',
                module: 'builtins'
              }], ['Never', {
                alias: '',
                module: 'builtins'
              }], ['Counter', {
                alias: 'Counter',
                module: 'collections'
              }], ['List', {
                alias: 'list',
                module: 'builtins'
              }], ['Dict', {
                alias: 'dict',
                module: 'builtins'
              }], ['DefaultDict', {
                alias: 'defaultdict',
                module: 'collections'
              }], ['Set', {
                alias: 'set',
                module: 'builtins'
              }], ['FrozenSet', {
                alias: 'frozenset',
                module: 'builtins'
              }], ['Deque', {
                alias: 'deque',
                module: 'collections'
              }], ['ChainMap', {
                alias: 'ChainMap',
                module: 'collections'
              }], ['OrderedDict', {
                alias: 'OrderedDict',
                module: 'collections'
              }]]).get(t);
              if (n) {
                qe(e.d.rightExpr);
                return ra(e, t, n);
              } else {
                return undefined;
              }
            }(e);
            if (i) {
              Fe(e.d.rightExpr, {
                type: i
              }, 0);
            }
          }
        }
        if (!i) {
          let p;
          let c;
          let u = false;
          if (function (e) {
            if (e.nodeType === 54 && e.d.valueExpr.nodeType === 38) {
              const t = Ja(e, e.d.valueExpr.d.value, false);
              if (t) {
                return t.symbol.getDeclarations().find(e => Br(e)) !== undefined;
              }
            }
            return false;
          }(e.d.leftExpr)) {
            r = 131560;
            p = e.d.leftExpr.d.valueExpr;
            if (!qr(e.d.rightExpr, true)) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeAliasIllegalExpressionForm(), e.d.rightExpr);
            }
          } else {
            if (e.d.leftExpr.nodeType === 38) {
              const t = Ja(e.d.leftExpr, e.d.leftExpr.d.value, false);
              if (t) {
                const n = t.symbol.getDeclarations();
                if (n.length === 1) {
                  if (jr(n[0])) {
                    p = e.d.leftExpr;
                    u = true;
                    r |= 33554432;
                  } else {
                    if (Kr(n[0])) {
                      p = e.d.leftExpr;
                    }
                  }
                }
              }
            }
          }
          if (p) {
            c = ia(p, false);
            Fe(e, {
              type: c
            }, undefined);
            Fe(e.d.leftExpr, {
              type: c
            }, undefined);
            if (e.d.leftExpr.nodeType === 54) {
              Fe(e.d.leftExpr.d.valueExpr, {
                type: c
              }, undefined);
            }
          }
          let m = at(e.d.leftExpr, {
            method: 'set'
          });
          if (m) {
            const t = M.getTypeVarScopesForNode(e);
            m = Z.makeTypeVarsBound(m, t);
          }
          const y = qe(e.d.rightExpr, r, Z.makeInferenceContext(m));
          i = y.type;
          s = y.expectedTypeDiagAddendum;
          if (y.isIncomplete) {
            o = true;
          }
          if (u && !Gr(i)) {
            p = undefined;
          }
          if (p) {
            l.assert(c !== undefined);
            i = aa(i, p, c, false);
            if (Z.isTypeAliasRecursive(c, i)) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasIsRecursiveDirect().format({
                name: p.d.value
              }), e.d.rightExpr);
              i = H.UnknownType.create();
            }
            c.shared.boundType = i;
            c.shared.recursiveAlias.typeParams = (n = (t = i.props) === null || t === undefined ? undefined : t.typeAliasInfo) === null || n === undefined ? undefined : n.shared.typeParams;
          } else {
            const t = R.evaluateStaticBoolExpression(e.d.rightExpr, a.executionEnvironment, a.definedConstants);
            if (t !== undefined) {
              const n = Ya(e, 'bool');
              if (H.isClassInstance(n)) {
                i = H.ClassType.cloneWithLiteral(n, t);
              }
            }
          }
        }
        Nt(e.d.leftExpr, {
          type: i,
          isIncomplete: o
        }, e.d.rightExpr, true, true, s);
        Fe(e, {
          type: i,
          isIncomplete: o
        }, 0);
      }
      function ia(e, t) {
        const n = H.TypeVarType.createInstantiable(`__type_alias_${e.d.value}`);
        n.shared.isSynthesized = true;
        const a = M.getScopeIdForNode(e);
        const r = v.getFileInfo(e);
        n.shared.recursiveAlias = {
          name: e.d.value,
          fullName: M.getClassFullName(e, r.moduleName, e.d.value),
          moduleName: r.moduleName,
          fileUri: r.fileUri,
          typeVarScopeId: a,
          isPep695Syntax: t,
          typeParams: undefined,
          computedVariance: undefined
        };
        n.priv.scopeId = a;
        return n;
      }
      function oa(e) {
        var t;
        return la(e, e.d.name, e.d.expr, true, (t = e.d.typeParams) === null || t === undefined ? undefined : t.d.params, () => {
          if (e.d.typeParams) {
            return ga(e.d.typeParams);
          }
        });
      }
      function la(e, t, n, a, r, s) {
        const i = Ne(t, 0);
        if (i) {
          return i;
        }
        const o = ia(t, a);
        Fe(t, {
          type: o
        }, undefined);
        const l = V.getScopeForNode(e);
        const p = l == null ? undefined : l.lookUpSymbolRecursive(t.d.value);
        const c = v.getDeclaration(e);
        if (c && p) {
          Ve(p.symbol, c, o);
        }
        const u = s();
        if (o.shared.recursiveAlias) {
          o.shared.recursiveAlias.typeParams = u ?? [];
        }
        const m = Ha(n, {
          forwardRefs: true,
          typeExpression: true
        });
        let y = false;
        let h = m.type;
        if (m.isIncomplete) {
          y = true;
        }
        h = aa(h, t, o, true, r);
        if (Z.isTypeAliasRecursive(o, h)) {
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasIsRecursiveDirect().format({
            name: t.d.value
          }), n);
          h = H.UnknownType.create();
        }
        o.shared.boundType = h;
        Fe(t, {
          type: h,
          isIncomplete: y
        }, 0);
        return h;
      }
      function pa(e) {
        if (De(e)) {
          return;
        }
        Fe(e, F.getTypeOfAugmentedAssignment(es, e, undefined), 0);
      }
      function da(e) {
        return `__type_of_${e}`;
      }
      function ca(e) {
        je(e);
        const t = Ne(e.d.name, 0);
        if (t) {
          if (!H.isInstantiableClass(t)) {
            return;
          }
          return {
            classType: t,
            decoratedType: Ne(e, 0) || H.UnknownType.create()
          };
        }
        const n = V.getScopeForNode(e);
        const a = v.getFileInfo(e);
        let r = 0;
        if ((n == null ? undefined : n.type) === 5 || a.isTypingStubFile || a.isTypingExtensionsStubFile || a.isBuiltInStubFile || a.isTypeshedStubFile) {
          r |= 1;
          if (a.isTypingExtensionsStubFile) {
            r |= 4096;
          }
          if (e.d.name.d.value === 'property') {
            r |= 128;
          }
          if (e.d.name.d.value === 'tuple') {
            r |= 32768;
          }
        }
        if (a.isStubFile) {
          r |= 262144;
        }
        const s = H.ClassType.createInstantiable(e.d.name.d.value, M.getClassFullName(e, a.moduleName, e.d.name.d.value), a.moduleName, a.fileUri, r, 0, undefined, undefined, M.getDocString(e.d.suite.d.statements));
        s.shared.typeVarScopeId = M.getScopeIdForNode(e);
        if (J.has(s.shared.fullName)) {
          s.priv.includePromotions = true;
        }
        const c = n == null ? undefined : n.lookUpSymbol(e.d.name.d.value);
        let y;
        const h = v.getDeclaration(e);
        if (h) {
          y = h;
        }
        if (y && c) {
          Ve(c, y, s);
        }
        s.shared.flags |= 8192;
        s.shared.declaration = y;
        return i.invalidateTypeCacheIfCanceled(() => {
          Fe(e, {
            type: s
          }, undefined);
          Fe(e.d.name, {
            type: s
          }, undefined);
          let n;
          let r;
          let i = [];
          if (e.d.typeParams) {
            i = ga(e.d.typeParams).map(e => H.TypeVarType.cloneAsInstance(e));
          }
          let c = false;
          const y = [];
          let h;
          let f = 289920;
          if (a.isStubFile) {
            f |= 4;
          }
          e.d.arguments.forEach(t => {
            var o;
            var p;
            var m;
            if (t.d.argCategory !== 2) {
              if (t.d.name) {
                if (H.ClassType.isTypedDictClass(s)) {
                  if (t.d.name.d.value === 'total' || t.d.name.d.value === 'closed') {
                    const n = R.evaluateStaticBoolExpression(t.d.valueExpr, a.executionEnvironment, a.definedConstants);
                    if (n === undefined) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictBoolParam().format({
                        name: t.d.name.d.value
                      }), t.d.valueExpr);
                    } else {
                      if (t.d.name.d.value !== 'total' || n) {
                        if (t.d.name.d.value === 'closed' && n && v.getFileInfo(e).diagnosticRuleSet.enableExperimentalFeatures) {
                          s.shared.flags |= 24;
                          if (s.shared.typedDictExtraItemsExpr) {
                            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictExtraItemsClosed(), s.shared.typedDictExtraItemsExpr);
                          }
                        }
                      } else {
                        s.shared.flags |= 32;
                      }
                    }
                  } else {
                    if (t.d.name.d.value === 'extra_items') {
                      if (v.getFileInfo(e).diagnosticRuleSet.enableExperimentalFeatures) {
                        s.shared.typedDictExtraItemsExpr = t.d.valueExpr;
                        s.shared.flags |= 16;
                        if (H.ClassType.isTypedDictMarkedClosed(s)) {
                          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictExtraItemsClosed(), s.shared.typedDictExtraItemsExpr);
                        }
                      }
                    } else {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictInitsubclassParameter().format({
                        name: t.d.name.d.value
                      }), t);
                    }
                  }
                } else {
                  if (t.d.name.d.value === 'metaclass') {
                    if (h) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.metaclassDuplicate(), t);
                    } else {
                      h = t.d.valueExpr;
                    }
                  } else {
                    y.push({
                      argCategory: 0,
                      node: t,
                      name: t.d.name,
                      valueExpression: t.d.valueExpr
                    });
                  }
                }
              } else {
                let y;
                if (t.d.argCategory === 1) {
                  qe(t.d.valueExpr);
                  y = H.UnknownType.create();
                } else {
                  y = qe(t.d.valueExpr, f).type;
                  if (H.isTypeVar(y) && ((o = y.props) === null || o === undefined ? undefined : o.specialForm) && H.TypeBase.isInstance(y.props.specialForm)) {
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.baseClassInvalid(), t);
                    y = H.UnknownType.create();
                  }
                  y = Pt(y);
                }
                if (H.isUnion(y)) {
                  y = H.removeUnbound(y);
                }
                if (H.isAny(y) && ((p = y.props) === null || p === undefined ? undefined : p.specialForm)) {
                  y = H.AnyType.create();
                }
                y = Z.stripTypeFormRecursive(y);
                if (!H.isAnyOrUnknown(y) && !H.isUnbound(y)) {
                  if (H.isClass(y) && H.TypeBase.getInstantiableDepth(y) > 0 && y.shared.effectiveMetaclass && H.isClass(y.shared.effectiveMetaclass)) {
                    y = y.shared.effectiveMetaclass;
                  }
                  if (Z.isMetaclassInstance(y)) {
                    l.assert(H.isClassInstance(y));
                    y = y.priv.typeArgs && y.priv.typeArgs.length > 0 ? y.priv.typeArgs[0] : H.UnknownType.create();
                  } else {
                    if (H.isInstantiableClass(y)) {
                      if (H.ClassType.isPartiallyEvaluated(y) || y.shared.mro.some(e => H.isClass(e) && H.ClassType.isPartiallyEvaluated(e))) {
                        fa(e, y);
                      }
                      if (H.ClassType.isBuiltIn(y, 'Protocol')) {
                        if (!a.isStubFile && !H.ClassType.isTypingExtensionClass(y) && !!u.PythonVersion.isLessThan(a.executionEnvironment.pythonVersion, u.pythonVersion3_7)) {
                          kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.protocolIllegal(), t.d.valueExpr);
                        }
                        s.shared.flags |= 512;
                      }
                      if (H.ClassType.isBuiltIn(y, 'property')) {
                        s.shared.flags |= 128;
                      }
                      if (u.PythonVersion.isGreaterOrEqualTo(a.executionEnvironment.pythonVersion, u.pythonVersion3_6) && H.ClassType.isBuiltIn(y, 'NamedTuple')) {
                        c = true;
                      }
                      if (H.ClassType.isBuiltIn(y, 'TypedDict') || H.ClassType.isTypedDictClass(y)) {
                        s.shared.flags |= 4;
                        if (H.ClassType.isTypedDictEffectivelyClosed(y)) {
                          s.shared.flags |= 16;
                        }
                      }
                      if (Z.derivesFromClassRecursive(y, s, true)) {
                        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.baseClassCircular(), t);
                        y = H.UnknownType.create();
                      }
                      if (((m = y.props) === null || m === undefined ? undefined : m.specialForm) && H.ClassType.isBuiltIn(y.props.specialForm, 'TypeAliasType')) {
                        kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeAliasTypeBaseClass(), t);
                        y = H.UnknownType.create();
                      }
                    } else {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.baseClassInvalid(), t);
                      y = H.UnknownType.create();
                    }
                  }
                }
                if (H.isUnknown(y)) {
                  kt(d.DiagnosticRule.reportUntypedBaseClass, g.LocMessage.baseClassUnknown(), t);
                }
                if (s.shared.baseClasses.some(e => H.isInstantiableClass(e) && H.isInstantiableClass(y) && H.ClassType.isSameGenericClass(y, e))) {
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.duplicateBaseClass(), t.d.name || t);
                }
                s.shared.baseClasses.push(y);
                if (H.isInstantiableClass(y) && (H.ClassType.isEnumClass(y) && (s.shared.flags |= 65536), (H.ClassType.supportsAbstractMethods(y) || H.ClassType.isProtocolClass(y) && !H.ClassType.isBuiltIn(y)) && (s.shared.flags |= 64), H.ClassType.isPropertyClass(y) && (s.shared.flags |= 128), H.ClassType.isFinal(y))) {
                  const e = $r(y);
                  kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.baseClassFinal().format({
                    type: e
                  }), t.d.valueExpr);
                }
                Z.addTypeVarsToListIfUnique(i, Z.getTypeVarArgsRecursive(y));
                if (H.isInstantiableClass(y)) {
                  if (H.ClassType.isBuiltIn(y, 'Generic')) {
                    if (e.d.typeParams) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.genericBaseClassNotAllowed(), t.d.valueExpr);
                    } else {
                      if (!n) {
                        if (r) {
                          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.duplicateGenericAndProtocolBase(), t.d.valueExpr);
                        }
                        n = ua(y);
                      }
                    }
                  } else {
                    if (H.ClassType.isBuiltIn(y, 'Protocol') && y.priv.typeArgs && y.priv.typeArgs.length > 0) {
                      if (!r) {
                        if (n) {
                          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.duplicateGenericAndProtocolBase(), t.d.valueExpr);
                        }
                        r = ua(y);
                        if (e.d.typeParams && r.length > 0) {
                          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.protocolBaseClassWithTypeArgs(), t.d.valueExpr);
                          r = [];
                        }
                      }
                    }
                  }
                }
              }
            } else {
              qe(t.d.valueExpr);
            }
          });
          if (s.shared.baseClasses.length > 1) {
            let t = false;
            let n = false;
            s.shared.baseClasses.forEach(e => {
              if (H.isInstantiableClass(e)) {
                if (H.ClassType.isBuiltIn(e, 'NamedTuple')) {
                  t = true;
                } else {
                  if (!H.ClassType.isBuiltIn(e, 'Generic')) {
                    n = true;
                  }
                }
              }
            });
            if (t && n) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.namedTupleMultipleInheritance(), e.d.name);
            }
          }
          if (!H.ClassType.isBuiltIn(s, 'object') && s.shared.baseClasses.filter(e => H.isClass(e)).length === 0) {
            s.shared.baseClasses.push(Za(e, 'object'));
          }
          n = n ?? r;
          if (n && !e.d.typeParams) {
            (function (e, t, n) {
              const a = t.filter(e => !n.some(t => t.shared.name === e.shared.name));
              if (a.length > 0) {
                const t = new p.DiagnosticAddendum();
                t.addMessage(g.LocAddendum.typeVarsMissing().format({
                  names: a.map(e => `"${e.shared.name}"`).join(', ')
                }));
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarsNotInGenericOrProtocol() + t.getString(), e);
              }
            })(e.d.name, i, n);
          }
          s.shared.typeParams = n ?? i;
          if (s.shared.typeParams.some(e => e.shared.declaredVariance === 0 && e.priv.computedVariance === undefined)) {
            s.shared.requiresVarianceInference = true;
          }
          const T = i.filter(e => H.isTypeVarTuple(e));
          if (T.length > 1) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.variadicTypeParamTooManyClass().format({
              names: T.map(e => `"${e.shared.name}"`).join(', ')
            }), e.d.name, m.TextRange.combine(e.d.arguments) || e.d.name);
          } else {
            if (T.length > 0) {
              const t = s.shared.typeParams.findIndex(e => H.isTypeVarTuple(e));
              const n = s.shared.typeParams.findIndex((e, n) => n > t && !H.isParamSpec(e) && e.shared.isDefaultExplicit);
              if (n >= 0) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarWithDefaultFollowsVariadic().format({
                  typeVarName: i[n].shared.name,
                  variadicName: i[t].shared.name
                }), e.d.typeParams ? e.d.typeParams.d.params[n].d.name : e.d.name);
              }
            }
          }
          s.shared.typeParams.forEach((t, n) => {
            var a;
            let r = e.d.name;
            if (e.d.typeParams && n < e.d.typeParams.d.params.length) {
              const t = e.d.typeParams.d.params[n];
              r = (a = t.d.defaultExpr) !== null && a !== undefined ? a : t.d.name;
            }
            ma(r, t, s.shared.typeParams.slice(0, n), s.shared.typeVarScopeId);
          });
          if (!Z.computeMroLinearization(s)) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.methodOrdering(), e.d.name);
          }
          const b = V.getScopeForNode(e.d.suite);
          s.shared.fields = (b == null ? undefined : b.symbolTable) ? new Map(b.symbolTable) : new Map();
          if (s.shared.fields.has('__eq__') && !s.shared.fields.has('__hash__')) {
            s.shared.fields.set('__hash__', L.Symbol.createWithType(4292, pt()));
          }
          const _ = b == null ? undefined : b.getSlotsNames();
          if (_) {
            s.shared.localSlotsNames = _;
          }
          if (!a.isStubFile && s.shared.typeParams.length === 0) {
            const t = s.shared.fields.get('__init__');
            if (t) {
              const n = t.getTypedDeclarations();
              if (n.length === 1 && n[0].type === 5) {
                const t = n[0].node;
                const a = t.d.params;
                if (a.length > 1 && !a.some((e, n) => !!M.getTypeAnnotationForParam(t, n))) {
                  const n = a.filter((e, t) => t > 0 && e.d.name && e.d.category === 0 && !e.d.defaultValue);
                  if (n.length > 0) {
                    s.shared.flags |= 1024;
                    s.shared.typeParams = n.map(n => {
                      const a = H.TypeVarType.createInstance(da(n.d.name.d.value));
                      a.shared.isSynthesized = true;
                      a.priv.scopeId = M.getScopeIdForNode(t);
                      a.shared.boundType = H.UnknownType.create();
                      return H.TypeVarType.cloneForScopeId(a, M.getScopeIdForNode(e), e.d.name.d.value, 0);
                    });
                  }
                }
              }
            }
          }
          if (s.shared.typeParams.length === 0 && !H.ClassType.isBuiltIn(s, 'type')) {
            if (s.shared.baseClasses.some(e => H.isInstantiableClass(e) && H.ClassType.hasCustomClassGetItem(e)) || s.shared.fields.has('__class_getitem__')) {
              s.shared.flags |= 16384;
            }
          }
          if (h) {
            let e = qe(h, f).type;
            if (H.isInstantiableClass(e) || H.isUnknown(e)) {
              if (Z.requiresSpecialization(e, {
                ignorePseudoGeneric: true
              })) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.metaclassIsGeneric(), h);
              }
              if (H.TypeBase.getInstantiableDepth(e) > 0 && H.isClass(e) && e.shared.effectiveMetaclass && H.isClass(e.shared.effectiveMetaclass)) {
                e = e.shared.effectiveMetaclass;
              }
              s.shared.declaredMetaclass = e;
              if (H.isInstantiableClass(e)) {
                if (P.isEnumMetaclass(e)) {
                  s.shared.flags |= 65536;
                }
                if (Z.derivesFromStdlibClass(e, 'ABCMeta')) {
                  s.shared.flags |= 64;
                }
              }
            }
          }
          const C = ha(s, e.d.name);
          s.shared.flags &= -8193;
          let I;
          let k = s;
          let w = false;
          for (let n = e.d.decorators.length - 1; n >= 0; n--) {
            const a = e.d.decorators[n];
            const r = er(e.parent ?? e, () => x.applyClassDecorator(es, k, s, a));
            const i = Z.containsAnyOrUnknown(r, false);
            if (i && H.isUnknown(i)) {
              if (!w) {
                kt(d.DiagnosticRule.reportUntypedClassDecorator, g.LocMessage.classDecoratorTypeUnknown(), e.d.decorators[n].d.expr);
                w = true;
              }
            } else {
              k = r;
            }
          }
          if (H.isInstantiableClass(C) && C.shared.classDataClassTransform) {
            I = C.shared.classDataClassTransform;
          } else {
            const e = s.shared.mro.find(e => H.isClass(e) && e.shared.classDataClassTransform !== undefined && !H.ClassType.isSameGenericClass(e, s));
            if (e) {
              I = e.shared.classDataClassTransform;
            }
          }
          var A;
          if (I) {
            S.applyDataClassClassBehaviorOverrides(es, e.d.name, s, y, I);
          }
          A = s;
          _e.forEach(e => {
            if (H.ClassType.isSameGenericClass(e.dependsUpon, A)) {
              e.classesToComplete.forEach(e => {
                const t = Ne(e.d.name, 0);
                if (t) {
                  (function (e, t) {
                    if (!Z.computeMroLinearization(e)) {
                      kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.methodOrdering(), t);
                    }
                    ha(e, t);
                  })(t, e.d.name);
                }
              });
            }
          });
          _e = _e.filter(e => !H.ClassType.isSameGenericClass(e.dependsUpon, A));
          fa(e, undefined);
          if (H.ClassType.isTypedDictClass(s)) {
            let t = false;
            const n = new p.DiagnosticAddendum();
            s.shared.baseClasses.forEach(e => {
              if (!!H.isClass(e) && !H.ClassType.isTypedDictClass(e) && !H.ClassType.isBuiltIn(e, ['_TypedDict', 'Generic'])) {
                t = true;
                n.addMessage(g.LocAddendum.typedDictBaseClass().format({
                  type: e.shared.name
                }));
              }
            });
            if (t) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typedDictBaseClass() + n.getString(), e.d.name);
            }
            W.synthesizeTypedDictClassMethods(es, e, s);
          }
          if (H.ClassType.isDataClass(s) || c) {
            const t = H.ClassType.isDataClassSkipGenerateInit(s);
            let n = t;
            if (!t) {
              const e = s.shared.fields.get('__init__');
              if (e && e.isClassMember()) {
                n = true;
              }
            }
            let a = false;
            const r = s.shared.fields.get('__hash__');
            if (r && r.isClassMember() && !r.getSynthesizedType()) {
              a = true;
            }
            const i = () => S.synthesizeDataClassMethods(es, e, s, c, t, n, a);
            if (c) {
              i();
            } else {
              s.shared.synthesizeMethodsDeferred = () => {
                delete s.shared.synthesizeMethodsDeferred;
                i();
              };
            }
          }
          s.shared.calculateInheritedSlotsNamesDeferred = () => {
            delete s.shared.calculateInheritedSlotsNamesDeferred;
            if (s.shared.localSlotsNames) {
              let e = true;
              const t = Array.from(s.shared.localSlotsNames);
              s.shared.baseClasses.forEach(n => {
                if (H.isInstantiableClass(n)) {
                  if (!H.ClassType.isBuiltIn(n, 'object') && !H.ClassType.isBuiltIn(n, 'type') && !H.ClassType.isBuiltIn(n, 'Generic')) {
                    const a = H.ClassType.getInheritedSlotsNames(n);
                    if (a) {
                      o.appendArray(t, a);
                    } else {
                      e = false;
                    }
                  }
                } else {
                  e = false;
                }
              });
              if (e) {
                s.shared.inheritedSlotsNamesCached = t;
              }
            }
          };
          Fe(e.d.name, {
            type: s
          }, 0);
          Fe(e, {
            type: k
          }, 0);
          return {
            classType: s,
            decoratedType: k
          };
        });
      }
      function ua(e) {
        var t;
        const n = [];
        ((t = e.priv.typeArgs) !== null && t !== undefined ? t : []).forEach((e, t) => {
          if (H.isTypeVar(e)) {
            n.push(e);
            return;
          }
          const a = H.TypeVarType.createInstance(`__P${t}`);
          a.shared.isSynthesized = true;
          n.push(a);
        });
        return n;
      }
      function ma(e, t, n, a) {
        if (!t.shared.isDefaultExplicit && !t.shared.isSynthesized && !H.TypeVarType.isSelf(t)) {
          const r = n.find(e => e.shared.isDefaultExplicit && e.priv.scopeId === a);
          if (r) {
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarWithoutDefault().format({
              name: t.shared.name,
              other: r.shared.name
            }), e);
          }
          return;
        }
        const r = new Set();
        Z.validateTypeVarDefault(t, n, r);
        if (r.size > 0) {
          const n = new p.DiagnosticAddendum();
          r.forEach(e => {
            n.addMessage(g.LocAddendum.typeVarDefaultOutOfScope().format({
              name: e
            }));
          });
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarDefaultInvalidTypeVar().format({
            name: t.shared.name
          }) + n.getString(), e);
        }
      }
      function ya(e) {
        if (!e.shared.requiresVarianceInference) {
          return;
        }
        e.shared.requiresVarianceInference = false;
        e.shared.typeParams.forEach(e => {
          if (e.shared.declaredVariance === 0) {
            e.priv.computedVariance = 1;
          }
        });
        const t = H.ClassType.createInstantiable('__varianceDummy', '', '', y.Uri.empty(), 0, 0, undefined, undefined);
        e.shared.typeParams.forEach((n, a) => {
          if (H.isTypeVarTuple(n) || H.isParamSpec(n)) {
            return;
          }
          if (n.shared.declaredVariance !== 0) {
            return;
          }
          const r = e.shared.typeParams.map((e, n) => H.isTypeVarTuple(e) ? e : n === a ? lt() : t);
          const s = e.shared.typeParams.map((e, n) => n === a || H.isTypeVarTuple(e) ? e : t);
          const i = H.ClassType.specialize(e, r);
          const o = H.ClassType.specialize(e, s);
          let l;
          if (_r(i, o, 3, false)) {
            l = 3;
          } else {
            l = _r(o, i, 4, false) ? 4 : 2;
          }
          e.shared.typeParams[a].priv.computedVariance = l;
        });
      }
      function ga(e) {
        const t = [];
        const n = v.getScope(e);
        e.d.params.forEach(e => {
          var a;
          const r = n == null ? undefined : n.symbolTable.get(e.d.name.d.value);
          if (!r) {
            return;
          }
          const s = (a = yr(r, e.d.name)) === null || a === undefined ? undefined : a.type;
          if (s && H.isTypeVar(s)) {
            Fe(e.d.name, {
              type: s
            }, 0);
            t.push(s);
          }
        });
        return t;
      }
      function ha(e, t) {
        var n;
        let a = e.shared.declaredMetaclass;
        let r = false;
        if (!a || H.isInstantiableClass(a)) {
          for (const s of e.shared.baseClasses) {
            if (!H.isInstantiableClass(s)) {
              a = H.UnknownType.create();
              break;
            }
            {
              const e = (n = s.shared.effectiveMetaclass) !== null && n !== undefined ? n : Ae == null ? undefined : Ae.typeClass;
              if (!e || !H.isInstantiableClass(e)) {
                a = e ? H.UnknownType.create() : undefined;
                break;
              }
              if (a) {
                if (Z.derivesFromClassRecursive(e, a, false)) {
                  a = e;
                } else {
                  if (!Z.derivesFromClassRecursive(a, e, false) && !r) {
                    const n = new p.DiagnosticAddendum();
                    n.addMessage(g.LocAddendum.metaclassConflict().format({
                      metaclass1: Yr(Z.convertToInstance(a)),
                      metaclass2: Yr(Z.convertToInstance(e))
                    }));
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.metaclassConflict() + n.getString(), t);
                    r = true;
                  }
                }
              } else {
                a = e;
              }
            }
          }
        }
        if (!a) {
          const e = Za(t, 'type');
          a = e && H.isInstantiableClass(e) ? e : H.UnknownType.create();
        }
        e.shared.effectiveMetaclass = a;
        return a;
      }
      function fa(e, t) {
        if (t) {
          const n = _e.find(e => H.ClassType.isSameGenericClass(e.dependsUpon, t));
          if (n) {
            n.classesToComplete.push(e);
          } else {
            _e.push({
              dependsUpon: t,
              classesToComplete: [e]
            });
          }
        } else {
          _e.forEach(t => {
            t.classesToComplete.push(e);
          });
        }
      }
      function Ta(e, t) {
        const n = [];
        let a;
        e.d.arguments.forEach(e => {
          if (e.d.name && e.d.name.d.value !== 'metaclass') {
            n.push({
              argCategory: 0,
              node: e,
              name: e.d.name,
              valueExpression: e.d.valueExpr
            });
          }
        });
        if (t.shared.effectiveMetaclass && H.isClass(t.shared.effectiveMetaclass)) {
          if (!H.ClassType.isBuiltIn(t.shared.effectiveMetaclass, ['ABCMeta', 'type']) || !!H.ClassType.isTypedDictClass(t)) {
            a = Z.lookUpClassMember(t.shared.effectiveMetaclass, '__new__', 8);
          }
        }
        if (a) {
          const t = Tr(a);
          if (H.isFunction(t)) {
            const a = E.getParamListDetails(t);
            if (a.firstKeywordOnlyIndex !== undefined) {
              const r = new Map();
              for (let e = a.firstKeywordOnlyIndex; e < a.params.length; e++) {
                const t = a.params[e];
                if (t.param.category === 0 && t.param.name && t.kind !== E.ParamKind.Positional) {
                  r.set(t.param.name, e);
                }
              }
              n.forEach(n => {
                var s;
                var i;
                var o;
                if (n.argCategory === 0 && n.name) {
                  const l = (s = r.get(n.name.d.value)) !== null && s !== undefined ? s : a.kwargsIndex;
                  if (l !== undefined) {
                    const s = a.params[l];
                    vn({
                      paramCategory: s.param.category,
                      paramType: s.type,
                      requiresTypeVarMatching: false,
                      argument: n,
                      errorNode: (i = n.valueExpression) !== null && i !== undefined ? i : e.d.name
                    }, new k.ConstraintTracker(), {
                      type: t
                    }, {
                      skipUnknownArgCheck: true
                    });
                    r.delete(n.name.d.value);
                  } else {
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.paramNameMissing().format({
                      name: n.name.d.value
                    }), (o = n.name) !== null && o !== undefined ? o : e.d.name);
                  }
                }
              });
              const s = [];
              r.forEach((e, t) => {
                if (!a.params[e].defaultType) {
                  s.push(t);
                }
              });
              if (s.length > 0) {
                const t = s.map(e => `"${e}"`).join(', ');
                kt(d.DiagnosticRule.reportGeneralTypeIssues, s.length === 1 ? g.LocMessage.argMissingForParam().format({
                  name: t
                }) : g.LocMessage.argMissingForParams().format({
                  names: t
                }), e.d.name);
              }
            }
          }
        } else {
          const a = et(e.d.name, t, '__init_subclass__', undefined, undefined, 545);
          if (a) {
            const t = a.type;
            if (t && a.classType) {
              if (pn(e.d.name, n, {
                type: t
              }, undefined, false, Z.makeInferenceContext(pt())).argumentErrors) {
                const n = kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.initSubclassCallFailed(), e.d.name);
                const r = H.isOverloaded(t) ? H.OverloadedType.getOverloads(t)[0] : t;
                const s = H.isFunction(r) ? r.shared.declaration : undefined;
                if (n && s) {
                  n.addRelatedInfo(g.LocAddendum.initSubclassLocation().format({
                    name: Yr(Z.convertToInstance(a.classType))
                  }), s.uri, s.range);
                }
              }
            }
          }
        }
        n.forEach(e => {
          if (e.valueExpression) {
            qe(e.valueExpression);
          }
        });
      }
      function va(e) {
        var t;
        je(e);
        let n = Ne(e.d.name, 0);
        if (n) {
          if (!H.isFunction(n)) {
            return;
          }
          if (H.FunctionType.isPartiallyEvaluated(n)) {
            return {
              functionType: n,
              decoratedType: n
            };
          }
        } else {
          n = ba(e);
        }
        let a = Ne(e, 0);
        if (a) {
          return {
            functionType: n,
            decoratedType: a
          };
        }
        Fe(e, {
          type: n
        }, undefined);
        n.shared.flags |= 131072;
        const r = e.d.isAsync ? function (e, t) {
          l.assert(H.FunctionType.isAsync(t));
          const n = H.FunctionType.cloneWithNewFlags(t, t.shared.flags & -131585);
          if (t.shared.declaredReturnType) {
            n.shared.declaredReturnType = Sa(e, t.shared.declaredReturnType, H.FunctionType.isGenerator(t));
          } else {
            n.priv.inferredReturnType = Sa(e, Xr(t), H.FunctionType.isGenerator(t));
          }
          return n;
        }(e, n) : n;
        n.shared.flags &= -131073;
        a = r;
        let s = false;
        for (let r = e.d.decorators.length - 1; r >= 0; r--) {
          const i = e.d.decorators[r];
          const o = er((t = e.parent) !== null && t !== undefined ? t : e, () => {
            l.assert(a !== undefined);
            return x.applyFunctionDecorator(es, a, n, i, e);
          });
          const p = Z.containsAnyOrUnknown(o, false);
          if (p && H.isUnknown(p)) {
            if (!s) {
              kt(d.DiagnosticRule.reportUntypedFunctionDecorator, g.LocMessage.functionDecoratorTypeUnknown(), e.d.decorators[r].d.expr);
              s = true;
            }
          } else {
            a = o;
          }
        }
        if (H.isFunction(a)) {
          a.shared.deprecatedMessage = n.shared.deprecatedMessage;
          if (H.FunctionType.isOverloaded(a)) {
            e.d.params.forEach(e => {
              _a(e);
            });
          }
        }
        a = x.addOverloadsToFunctionType(es, e, a);
        Fe(e, {
          type: a
        }, 0);
        return {
          functionType: n,
          decoratedType: a
        };
      }
      function ba(e) {
        var t;
        const n = v.getFileInfo(e);
        const a = Ne(e.d.name, 0);
        if (a && H.isFunction(a)) {
          return a;
        }
        let r;
        const s = v.getDeclaration(e);
        if (s) {
          r = s;
        }
        const o = M.getEnclosingClass(e, true);
        let l;
        if (o) {
          l = (t = ca(o)) === null || t === undefined ? undefined : t.classType;
        }
        const c = x.getFunctionInfoFromDecorators(es, e, !!o);
        let u = c.flags;
        if (r == null ? undefined : r.isGenerator) {
          u |= 16;
        }
        if (n.isStubFile) {
          u |= 2048;
        } else {
          if (n.isInPyTypedPackage) {
            u |= 4096;
          }
        }
        if (e.d.isAsync) {
          u |= 512;
        }
        const m = H.FunctionType.createInstance(e.d.name.d.value, function (e, t, n) {
          const a = [n];
          let r = e;
          while (r) {
            r = M.getEnclosingClassOrFunction(r);
            if (r) {
              a.push(r.d.name.d.value);
            }
          }
          a.push(t);
          return a.reverse().join('.');
        }(e, n.moduleName, e.d.name.d.value), n.moduleName, u | 131072, M.getDocString(e.d.suite.d.statements));
        m.shared.typeVarScopeId = M.getScopeIdForNode(e);
        m.shared.deprecatedMessage = c.deprecationMessage;
        m.shared.methodClass = l;
        if (e.d.name.d.value === '__init__' || e.d.name.d.value === '__new__') {
          if (o) {
            m.priv.constructorTypeVarScopeId = M.getScopeIdForNode(o);
          }
        }
        if (n.isBuiltInStubFile || n.isTypingStubFile || n.isTypingExtensionsStubFile) {
          m.shared.flags |= 1048576;
        }
        m.shared.declaration = r;
        const y = V.getScopeForNode(e);
        const h = y == null ? undefined : y.lookUpSymbolRecursive(e.d.name.d.value);
        if (r && h) {
          Ve(h.symbol, r, m);
        }
        return i.invalidateTypeCacheIfCanceled(() => {
          var a;
          Fe(e.d.name, {
            type: m
          }, undefined);
          const r = l && H.ClassType.isPseudoGenericClass(l) && e.d.name.d.value === '__init__';
          const s = [];
          let i = 0;
          if (!!l && !(m.shared.flags & 4)) {
            i = 1;
          }
          if (e.d.funcAnnotationComment && !e.d.funcAnnotationComment.d.isEllipsis) {
            const t = e.d.params.length - i;
            const n = e.d.funcAnnotationComment.d.paramAnnotations.length;
            if (i > 0 && n === e.d.params.length) {
              i = 0;
            } else {
              if (n !== t) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.annotatedParamCountMismatch().format({
                  expected: t,
                  received: n
                }), e.d.funcAnnotationComment);
              }
            }
          }
          const o = [];
          if (e.d.typeParams) {
            m.shared.typeParams = ga(e.d.typeParams).map(e => Z.convertToInstance(e));
          } else {
            m.shared.typeParams = o;
          }
          let u = true;
          const y = l && (H.FunctionType.isClassMethod(m) || H.FunctionType.isInstanceMethod(m) || H.FunctionType.isConstructorMethod(m));
          const h = y ? 1 : 0;
          e.d.params.forEach((t, a) => {
            let f;
            let T;
            let v;
            let b;
            if (t.d.name && (a === 0 && y || H.FunctionType.isAbstractMethod(m) || l && H.ClassType.isProtocolClass(l))) {
              _a(t);
            }
            if (t.d.annotation) {
              v = t.d.annotation;
            } else {
              if (t.d.annotationComment) {
                v = t.d.annotationComment;
              } else {
                if (e.d.funcAnnotationComment && !e.d.funcAnnotationComment.d.isEllipsis) {
                  const t = a - i;
                  if (t >= 0 && t < e.d.funcAnnotationComment.d.paramAnnotations.length) {
                    v = e.d.funcAnnotationComment.d.paramAnnotations[t];
                  }
                }
              }
            }
            if (v) {
              T = c.flags & 524288 ? H.UnknownType.create() : He(v, t.d.category);
              if (T) {
                Z.addTypeVarsToListIfUnique(o, Z.getTypeVarArgsRecursive(T), m.shared.typeVarScopeId);
              }
              if (H.isTypeVarTuple(T) && !T.priv.isUnpacked) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.unpackedTypeVarTupleExpected().format({
                  name1: T.shared.name,
                  name2: T.shared.name
                }), v);
                T = H.UnknownType.create();
              }
            }
            if (!T && r && a > 0 && t.d.category === 0 && t.d.name && !t.d.defaultValue) {
              const e = da(t.d.name.d.value);
              T = l.shared.typeParams.find(t => t.shared.name === e);
            }
            if (T) {
              const e = Ca(t, T);
              if (e !== T) {
                T = e;
              }
            }
            if (t.d.defaultValue) {
              let a = n.isStubFile || M.isSuiteEmpty(e.d.suite);
              if (l && H.ClassType.isProtocolClass(l)) {
                a = true;
              }
              if (H.FunctionType.isOverloaded(m) || H.FunctionType.isAbstractMethod(m)) {
                a = true;
              }
              b = qe(t.d.defaultValue, a ? 1 : 0, Z.makeInferenceContext(T)).type;
            }
            if (T) {
              if (t.d.defaultValue && b) {
                const e = new p.DiagnosticAddendum();
                if (!Ir(T, b, e)) {
                  kt(d.DiagnosticRule.reportArgumentType, g.LocMessage.paramAssignmentMismatch().format({
                    sourceType: Yr(b),
                    paramType: Yr(T)
                  }) + e.getString(), t.d.defaultValue);
                }
              }
              f = T;
            }
            if (a >= h) {
              let n = false;
              if (t.d.category === 0 && t.d.name) {
                if (B.isPrivateName(t.d.name.d.value) && !e.d.params.some(e => e.d.category === 0 && !e.d.name)) {
                  n = true;
                  if (!u && m.shared.parameters.every(e => e.category === 0)) {
                    kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.positionOnlyAfterNon(), t.d.name);
                  }
                }
              } else {
                u = false;
              }
              if (u && !n && m.shared.parameters.length > h) {
                H.FunctionType.addPositionOnlyParamSeparator(m);
              }
              if (!n) {
                u = false;
              }
            }
            let _ = false;
            if (!v) {
              _ = true;
              const t = Ia(e, m.shared.flags, a, l);
              if (t) {
                f = t;
              }
            }
            f = f ?? H.UnknownType.create();
            const C = H.FunctionParam.create(t.d.category, f, (_ ? H.FunctionParamFlags.TypeInferred : H.FunctionParamFlags.None) | (v ? H.FunctionParamFlags.TypeDeclared : H.FunctionParamFlags.None), t.d.name ? t.d.name.d.value : undefined, b, t.d.defaultValue);
            H.FunctionType.addParam(m, C);
            if (H.FunctionParam.isTypeDeclared(C)) {
              Z.addTypeVarsToListIfUnique(o, Z.getTypeVarArgsRecursive(f), m.shared.typeVarScopeId);
            }
            if (t.d.name) {
              const n = wa(e, t.d.category, f);
              s.push(n);
            } else {
              s.push(f);
            }
          });
          if (u && m.shared.parameters.length > h) {
            H.FunctionType.addPositionOnlyParamSeparator(m);
          }
          const f = M.getTypeVarScopesForNode(e);
          s.forEach((t, n) => {
            const a = e.d.params[n].d.name;
            if (a) {
              if (H.isUnknown(t)) {
                m.shared.flags |= 16384;
              }
              Fe(a, {
                type: t = Z.makeTypeVarsBound(t, f)
              }, 0);
            }
          });
          if (s.length >= 2) {
            const e = s[s.length - 2];
            const t = s[s.length - 1];
            if (H.isParamSpec(e) && e.priv.paramSpecAccess === 'args' && H.isParamSpec(t) && t.priv.paramSpecAccess === 'kwargs') {
              m.shared.flags |= 32768;
            }
          }
          if (m.shared.parameters.filter((e, t) => e.category !== 0 && e.name && H.isAnyOrUnknown(H.FunctionType.getParamType(m, t))).length >= 2) {
            m.shared.flags |= 32768;
          }
          const T = e.d.returnAnnotation ?? ((a = e.d.funcAnnotationComment) === null || a === undefined ? undefined : a.d.returnAnnotation);
          if (T) {
            m.shared.declaredReturnType = H.UnknownType.create();
            const e = Ze(T, {
              typeVarGetsCurScope: true
            });
            m.shared.declaredReturnType = e;
          } else {
            if (n.isStubFile) {
              if (e.d.name.d.value === '__init__') {
                m.shared.declaredReturnType = pt();
              } else {
                m.shared.declaredReturnType = H.UnknownType.create();
              }
            }
          }
          if (m.shared.declaredReturnType && T) {
            Z.addTypeVarsToListIfUnique(o, Z.getTypeVarArgsRecursive(m.shared.declaredReturnType), m.shared.typeVarScopeId);
          }
          if ((n.isStubFile || M.isSuiteEmpty(e.d.suite)) && m.shared.declaredReturnType && H.isClassInstance(m.shared.declaredReturnType) && H.ClassType.isBuiltIn(m.shared.declaredReturnType, ['Generator', 'AsyncGenerator', 'AwaitableGenerator'])) {
            m.shared.flags |= 16;
          }
          m.shared.typeParams.forEach((t, n) => {
            var a;
            let r = e.d.name;
            if (e.d.typeParams && n < e.d.typeParams.d.params.length) {
              const t = e.d.typeParams.d.params[n];
              r = (a = t.d.defaultExpr) !== null && a !== undefined ? a : t.d.name;
            }
            ma(r, t, m.shared.typeParams.slice(0, n), m.shared.typeVarScopeId);
          });
          m.shared.flags &= -131073;
          Fe(e.d.name, {
            type: m
          }, 0);
          return m;
        });
      }
      function _a(e) {
        if (e.d.name) {
          const t = Ja(e.d.name, e.d.name.d.value, false);
          if (t) {
            Et(v.getFileInfo(e), t.symbol, e.d.name);
          }
        }
      }
      function Ca(e, t) {
        var n;
        if (((n = e.d.defaultValue) === null || n === undefined ? undefined : n.nodeType) !== 14 || e.d.defaultValue.d.constType !== 26 || Z.isOptionalType(t) || v.getFileInfo(e).diagnosticRuleSet.strictParameterNoneValue) {
          return t;
        } else {
          return H.combineTypes([t, pt()]);
        }
      }
      function Ia(e, t, n, a) {
        var r;
        if (a) {
          if (n === 0 && !(t & 4)) {
            const e = !!(t & 3);
            return Z.synthesizeTypeVarForSelfCls(a, e);
          }
          const s = e.d.name.d.value;
          const i = Z.lookUpClassMember(a, s, 1);
          if (i) {
            const t = i.symbol.getDeclarations();
            if (t.length === 1 && t[0].type === 5) {
              const a = t[0].node;
              if (a.d.params.length === e.d.params.length && a.d.params.every((t, n) => {
                var a;
                var r;
                const s = e.d.params[n];
                return ((a = s.d.name) === null || a === undefined ? undefined : a.d.value) === ((r = t.d.name) === null || r === undefined ? undefined : r.d.value) && s.d.category === t.d.category;
              })) {
                const t = a.d.params[n];
                const s = (r = t.d.annotation) !== null && r !== undefined ? r : t.d.annotationComment;
                if (s) {
                  let t = He(s, e.d.params[n].d.category);
                  if (Z.requiresSpecialization(t) && H.isClass(i.classType)) {
                    const e = Z.getTypeVarScopeIds(i.classType);
                    const n = Z.buildSolutionFromSpecializedClass(i.classType);
                    e.push(M.getScopeIdForNode(a));
                    t = Z.applySolvedTypeVars(t, n, {
                      replaceUnsolved: {
                        scopeIds: e,
                        tupleClassType: ot()
                      }
                    });
                  }
                  const r = v.getFileInfo(e);
                  if (r.isInPyTypedPackage && !r.isStubFile) {
                    t = H.TypeBase.cloneForAmbiguousType(t);
                  }
                  return t;
                }
              }
            }
          }
        }
        const s = e.d.params[n].d.defaultValue;
        if (s) {
          return ka(s);
        }
      }
      function ka(e) {
        const t = qe(e, 1).type;
        let n;
        if (Z.isNoneInstance(t) || H.isClassInstance(t) && B.isPrivateOrProtectedName(t.shared.name)) {
          n = H.combineTypes([t, H.UnknownType.create()]);
        } else {
          let e = false;
          if (H.isFunction(t) || H.isOverloaded(t) || H.isClassInstance(t) && H.ClassType.isBuiltIn(t, ['tuple', 'list', 'set', 'dict'])) {
            e = true;
          }
          if (!e) {
            n = Ut(t, 0, true);
            n = Z.stripTypeForm(n);
            n = $e(n);
          }
        }
        if (n) {
          const t = v.getFileInfo(e);
          if (t.isInPyTypedPackage && !t.isStubFile) {
            n = H.TypeBase.cloneForAmbiguousType(n);
          }
        }
        return n;
      }
      function wa(e, t, n) {
        switch (t) {
          case 0:
            return n;
          case 1:
            if (H.isParamSpec(n) && n.priv.paramSpecAccess) {
              return n;
            } else {
              if (H.isUnpackedClass(n)) {
                return H.ClassType.cloneForPacked(n);
              } else {
                return q.makeTupleObject(es, [{
                  type: n,
                  isUnbounded: !H.isTypeVarTuple(n)
                }]);
              }
            }
          case 2:
            {
              if (H.isParamSpec(n) && n.priv.paramSpecAccess) {
                return n;
              }
              if (H.isClassInstance(n) && H.ClassType.isTypedDictClass(n) && n.priv.isUnpacked) {
                return H.ClassType.cloneForPacked(n);
              }
              const t = Za(e, 'dict');
              const a = Ya(e, 'str');
              if (H.isInstantiableClass(t) && H.isClassInstance(a)) {
                return H.ClassType.cloneAsInstance(H.ClassType.specialize(t, [a, n]));
              } else {
                return H.UnknownType.create();
              }
            }
        }
      }
      function Sa(e, t, n, a = true) {
        let r;
        if (H.isClassInstance(t) && H.ClassType.isBuiltIn(t)) {
          if (t.shared.name === 'Generator') {
            const n = ct(e, 'AsyncGenerator');
            if (n && H.isInstantiableClass(n)) {
              const e = [];
              const a = t.priv.typeArgs;
              if (a && a.length > 0) {
                e.push(a[0]);
              }
              if (a && a.length > 1) {
                e.push(a[1]);
              }
              r = H.ClassType.cloneAsInstance(H.ClassType.specialize(n, e));
            }
          } else {
            if (['AsyncGenerator', 'AsyncIterator', 'AsyncIterable'].some(e => e === t.shared.name)) {
              r = t;
            }
          }
        }
        if (!r || !n) {
          const n = ct(e, a ? 'Coroutine' : 'Awaitable');
          r = n && H.isInstantiableClass(n) ? H.ClassType.cloneAsInstance(H.ClassType.specialize(n, a ? [H.AnyType.create(), H.AnyType.create(), t] : [t])) : H.UnknownType.create();
        }
        return r;
      }
      function Aa(e, t) {
        var n;
        if (e.d.returnAnnotation || ((n = e.d.funcAnnotationComment) === null || n === undefined ? undefined : n.d.returnAnnotation)) {
          return;
        }
        let a = Ne(e.d.suite, 0);
        let r = false;
        if (a) {
          return {
            type: a,
            isIncomplete: r
          };
        }
        if (he.has(e.id) || he.size >= oe) {
          a = H.UnknownType.create();
          r = true;
        } else {
          he.add(e.id);
          try {
            let n;
            const s = v.getDeclaration(e);
            if (s) {
              n = s;
            }
            const i = !ht(e);
            const o = ht(e.d.suite);
            if (v.getFileInfo(e).isStubFile) {
              a = H.UnknownType.create();
            } else {
              if (i) {
                a = t || xa(n) ? H.UnknownType.create() : H.NeverType.createNoReturn();
              } else {
                const e = [];
                if (n == null ? undefined : n.returnStatements) {
                  n.returnStatements.forEach(t => {
                    var n;
                    if (gt(t)) {
                      if (t.d.expr) {
                        const a = qe(t.d.expr);
                        if (a.isIncomplete) {
                          r = true;
                        }
                        let s = a.type;
                        if ((n = s.props) === null || n === undefined ? undefined : n.specialForm) {
                          s = s.props.specialForm;
                        }
                        s = Z.mapSubtypes(s, e => H.isClassInstance(e) && e.priv.isEmptyContainer ? H.ClassType.specialize(e, e.priv.typeArgs, !!e.priv.isTypeArgExplicit, e.priv.includeSubclasses, e.priv.tupleTypeArgs, false) : e);
                        s = Z.stripTypeForm(s);
                        e.push(s);
                      } else {
                        e.push(pt());
                      }
                    }
                  });
                }
                if (!i && o) {
                  e.push(pt());
                }
                a = H.combineTypes(e);
                a = H.removeUnbound(a);
              }
              if (n == null ? undefined : n.isGenerator) {
                const t = [];
                let r = false;
                let s = false;
                if (n.yieldStatements) {
                  n.yieldStatements.forEach(e => {
                    var n;
                    var a;
                    if (gt(e)) {
                      if (e.nodeType === 61) {
                        s = true;
                        const a = qe(e.d.expr);
                        if (H.isClassInstance(a.type) && H.ClassType.isBuiltIn(a.type, 'Coroutine')) {
                          const e = a.type.priv.typeArgs && a.type.priv.typeArgs.length > 0 ? a.type.priv.typeArgs[0] : H.UnknownType.create();
                          t.push(e);
                          r = true;
                        } else {
                          const r = (n = st(a, false, e)) === null || n === undefined ? undefined : n.type;
                          t.push(r ?? H.UnknownType.create());
                        }
                      } else {
                        if (((a = e == null ? undefined : e.parent) === null || a === undefined ? undefined : a.nodeType) !== 47) {
                          s = true;
                        }
                        if (e.d.expr) {
                          const n = qe(e.d.expr).type;
                          t.push(n ?? H.UnknownType.create());
                        } else {
                          t.push(pt());
                        }
                      }
                    }
                  });
                }
                const i = H.combineTypes(t);
                const o = ct(e, r ? 'AwaitableGenerator' : 'Generator');
                if (o && H.isInstantiableClass(o)) {
                  const e = [];
                  const t = s ? H.UnknownType.create() : H.AnyType.create();
                  e.push(i, t, a);
                  if (r) {
                    e.push(H.AnyType.create());
                  }
                  a = H.ClassType.cloneAsInstance(H.ClassType.specialize(o, e));
                } else {
                  a = H.UnknownType.create();
                }
              }
            }
            Fe(e.d.suite, {
              type: a,
              isIncomplete: r
            }, 0);
          } catch (t) {
            if ((t == null ? undefined : t.message) === 'Maximum call stack size exceeded') {
              const t = v.getFileInfo(e);
              console.error(`Overflowed stack when inferring return type for function: ${e.d.name.d.value} in file ${t.fileUri.toUserVisibleString()}`);
              return;
            }
            throw t;
          } finally {
            he.delete(e.id);
          }
        }
        if (a) {
          return {
            type: a,
            isIncomplete: r
          };
        } else {
          return undefined;
        }
      }
      function xa(e) {
        if (!e || !e.isMethod || e.returnStatements || e.yieldStatements || !e.raiseStatements) {
          return false;
        }
        if (e.node.d.suite.d.statements.some(e => e.nodeType !== 47)) {
          return false;
        }
        for (const t of e.raiseStatements) {
          if (!t.d.expr || t.d.fromExpr) {
            return false;
          }
          const e = qe(t.d.expr).type;
          const n = H.isInstantiableClass(e) || H.isClassInstance(e) ? e : undefined;
          if (!n || !Z.derivesFromStdlibClass(n, 'NotImplementedError')) {
            return false;
          }
        }
        return true;
      }
      function Pa(e) {
        var t;
        var n;
        if (De(e)) {
          return;
        }
        const a = qe(e.d.iterableExpr);
        const r = (n = (t = st(a, !!e.d.isAsync, e.d.iterableExpr)) === null || t === undefined ? undefined : t.type) !== null && n !== undefined ? n : H.UnknownType.create();
        Nt(e.d.targetExpr, {
          type: r,
          isIncomplete: a.isIncomplete
        }, e.d.targetExpr);
        Fe(e, {
          type: r,
          isIncomplete: !!a.isIncomplete
        }, 0);
      }
      function Da(e) {
        l.assert(e.d.typeExpr !== undefined);
        if (De(e)) {
          return;
        }
        const t = qe(e.d.typeExpr);
        const n = t.type;
        let a = false;
        function r(e, n) {
          var r;
          var s;
          e = Pt(e);
          if (H.isAnyOrUnknown(e)) {
            return e;
          }
          if (H.isInstantiableClass(e)) {
            if (H.ClassType.isBuiltIn(e, 'BaseException')) {
              a = true;
            }
            return H.ClassType.cloneAsInstance(e);
          }
          if (H.isClassInstance(e)) {
            const a = (s = (r = st({
              type: e,
              isIncomplete: t.isIncomplete
            }, false, n)) === null || r === undefined ? undefined : r.type) !== null && s !== undefined ? s : H.UnknownType.create();
            return Z.mapSubtypes(a, e => H.isAnyOrUnknown(e) ? e : H.UnknownType.create());
          }
          return H.UnknownType.create();
        }
        let s = Z.mapSubtypes(n, t => {
          const n = Z.getSpecializedTupleType(t);
          if (n && n.priv.tupleTypeArgs) {
            const t = n.priv.tupleTypeArgs.map(t => r(t.type, e.d.typeExpr));
            return H.combineTypes(t);
          }
          return r(t, e.d.typeExpr);
        });
        if (e.d.isExceptGroup) {
          s = Ya(e, a ? 'BaseExceptionGroup' : 'ExceptionGroup', [s]);
        }
        if (e.d.name) {
          Nt(e.d.name, {
            type: s
          }, e.d.name);
        }
        Fe(e, {
          type: s
        }, 0);
      }
      function Na(e) {
        if (De(e)) {
          return;
        }
        const t = qe(e.d.expr);
        let n = t.type;
        const a = e.parent && e.parent.nodeType === 58 && !!e.parent.d.isAsync;
        if (Z.isOptionalType(n)) {
          kt(d.DiagnosticRule.reportOptionalContextManager, g.LocMessage.noneNotUsableWith(), e.d.expr);
          n = Z.removeNoneFromUnion(n);
        }
        const r = a ? '__aenter__' : '__enter__';
        const s = Z.mapSubtypes(n, t => {
          t = Pt(t);
          if (H.isAnyOrUnknown(t)) {
            return t;
          }
          const i = new p.DiagnosticAddendum();
          if (H.isClass(t)) {
            let o = Pn(t, r, [], e.d.expr, undefined, i.createAddendum())?.type;
            if (o) {
              if (a) {
                o = rt(o, e.d.expr);
              }
              return o;
            }
            if (!a) {
              if (Pn(t, '__aenter__', [], e.d.expr, undefined)?.type) {
                i.addMessage(g.LocAddendum.asyncHelp());
              }
            }
          }
          kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeNotUsableWith().format({
            type: Yr(t),
            method: r
          }) + i.getString(), e.d.expr);
          return H.UnknownType.create();
        });
        const i = a ? '__aexit__' : '__exit__';
        Z.doForEachSubtype(n, t => {
          t = Pt(t);
          if (!H.isAnyOrUnknown(t)) {
            if (H.isClass(t)) {
              const a = {
                type: H.AnyType.create()
              };
              if (Pn(t, i, [a, a, a], e.d.expr, undefined)?.type) {
                return;
              }
            }
            kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeNotUsableWith().format({
              type: Yr(t),
              method: i
            }), e.d.expr);
          }
        });
        if (e.d.target) {
          Nt(e.d.target, {
            type: s,
            isIncomplete: t.isIncomplete
          }, e.d.target);
        }
        Fe(e, {
          type: s,
          isIncomplete: !!t.isIncomplete
        }, 0);
      }
      function Fa(e) {
        var t;
        if (De(e)) {
          return;
        }
        let n;
        n = e.d.alias ? e.d.alias : e.d.module.d.nameParts[0];
        if (!n) {
          return;
        }
        let a = (t = Ua(e, n.d.value)) !== null && t !== undefined ? t : H.UnknownType.create();
        const r = Ne(e, 0);
        if (r && H.isModule(r) && a && H.isTypeSame(a, r)) {
          a = r;
        }
        St(n, {
          type: a
        }, false);
        Fe(e, {
          type: a
        }, 0);
      }
      function Ea(t) {
        var n;
        if (De(t)) {
          return;
        }
        const a = t.d.alias || t.d.name;
        const r = v.getFileInfo(t);
        if (((n = t.d.alias) === null || n === undefined ? undefined : n.d.value) === t.d.name.d.value) {
          const e = Ja(t, t.d.name.d.value, true);
          if (e) {
            Et(r, e.symbol, t);
          }
        }
        if (M.getEnclosingClass(t, true)) {
          const e = Ja(t, a.d.value, true);
          if (e) {
            Et(r, e.symbol, t);
          }
        }
        let s = Ua(t, a.d.value);
        if (!s) {
          const n = t.parent;
          l.assert(n && n.nodeType === 25);
          l.assert(!n.d.isWildcardImport);
          const a = v.getImportInfo(n.d.module);
          if (a && a.isImportFound && !a.isNativeLib) {
            const n = a.resolvedUris[a.resolvedUris.length - 1];
            const i = e(n);
            let o = false;
            if (i) {
              o = true;
              if (u.PythonVersion.isGreaterOrEqualTo(r.executionEnvironment.pythonVersion, u.pythonVersion3_7) || r.isStubFile) {
                const e = i.symbolTable.get('__getattr__');
                if (e) {
                  const t = cr(e);
                  if (H.isFunction(t)) {
                    s = hr(t);
                    o = false;
                  }
                }
              }
            } else {
              if (n.isEmpty()) {
                o = true;
              }
            }
            if (o) {
              kt(d.DiagnosticRule.reportAttributeAccessIssue, g.LocMessage.importSymbolUnknown().format({
                name: t.d.name.d.value
              }), t.d.name);
            }
          }
          if (!s) {
            s = H.UnknownType.create();
          }
        }
        St(a, {
          type: s
        }, false);
        Fe(t, {
          type: s
        }, 0);
      }
      function Ma(e) {
        if (De(e)) {
          return;
        }
        if (!e.parent || e.parent.nodeType !== 63) {
          l.fail('Expected parent of case statement to be match statement');
          return;
        }
        const t = v.getFileInfo(e);
        const n = qe(e.parent.d.expr);
        let a = n.type;
        for (const r of e.parent.d.cases) {
          if (r === e) {
            if (t.diagnosticRuleSet.reportUnnecessaryComparison !== 'none') {
              if (!n.isIncomplete) {
                O.checkForUnusedPattern(es, e.d.pattern, a);
              }
            }
            break;
          }
          if (!r.d.guardExpr) {
            a = O.narrowTypeBasedOnPattern(es, a, r.d.pattern, false);
          }
        }
        Fe(e, {
          type: O.assignTypeToPatternTargets(es, a, !!n.isIncomplete, e.d.pattern),
          isIncomplete: !!n.isIncomplete
        }, 0);
      }
      function Oa(e) {
        if (!De(e)) {
          if (e.d.isWildcardImport) {
            Fe(e, {
              type: H.AnyType.create()
            }, 0);
            const t = v.getFlowNode(e);
            if (t && t.flags & _.FlowFlags.WildcardImport) {
              t.names.forEach(t => {
                var n;
                var a;
                const r = Ua(e, t);
                if (!r) {
                  return;
                }
                const s = Ja(e, t, false);
                if (!s) {
                  return;
                }
                const i = (n = yr(s.symbol)) === null || n === undefined ? undefined : n.type;
                if (!i) {
                  return;
                }
                const o = new p.DiagnosticAddendum();
                if (!Ir(i, r, o)) {
                  kt(d.DiagnosticRule.reportAssignmentType, g.LocMessage.typeAssignmentMismatchWildcard().format({
                    ...Hr(r, i),
                    name: t
                  }) + o.getString(), e, (a = e.d.wildcardToken) !== null && a !== undefined ? a : e);
                }
              });
            }
          } else {
            const t = e.d.module.d.nameParts[0];
            let n = Ua(e, t.d.value);
            if (!n) {
              return;
            }
            const a = Ne(e, 0);
            if (a && H.isModule(a) && n && H.isTypeSame(n, a)) {
              n = a;
            }
            St(t, {
              type: n
            }, false);
            Fe(e, {
              type: n
            }, 0);
          }
        }
      }
      function za(e) {
        var t;
        if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 3) {
          sa(e.parent);
        } else {
          const t = Ze(e.d.annotation, {
            varTypeAnnotation: true,
            allowFinal: M.isFinalAllowedForAssignmentTarget(e.d.valueExpr),
            allowClassVar: M.isClassVarAllowedForAssignmentTarget(e.d.valueExpr)
          });
          Fe(e.d.valueExpr, {
            type: t
          }, 0);
        }
      }
      function Ua(e, t) {
        const a = Ja(e, t, true);
        if (!a) {
          return;
        }
        const r = a.symbol.getDeclarations().filter(t => M.isNodeContainedWithin(e, t.node) && t.type === 8);
        let s = r.length > 0 ? r[r.length - 1] : undefined;
        if (!s) {
          s = a.symbol.getDeclarations().find(e => e.type === 8);
        }
        if (!s) {
          return;
        }
        l.assert(s.type === 8);
        const i = dr(s, true, {
          allowExternallyHiddenAccess: v.getFileInfo(e).isStubFile
        });
        if (i) {
          if (!i.declaration) {
            if (n.evaluateUnknownImportsAsAny) {
              return H.AnyType.create();
            } else {
              return H.UnknownType.create();
            }
          }
          if (e.nodeType === 26 && (i.isPrivate && kt(d.DiagnosticRule.reportPrivateUsage, g.LocMessage.privateUsedOutsideOfModule().format({
            name: e.d.name.d.value
          }), e.d.name), i.privatePyTypedImporter)) {
            const t = new p.DiagnosticAddendum();
            if (i.privatePyTypedImported) {
              t.addMessage(g.LocAddendum.privateImportFromPyTypedSource().format({
                module: i.privatePyTypedImported
              }));
            }
            kt(d.DiagnosticRule.reportPrivateImportUsage, g.LocMessage.privateImportFromPyTypedModule().format({
              name: e.d.name.d.value,
              module: i.privatePyTypedImporter
            }) + t.getString(), e.d.name);
          }
          return lr(a.symbol, s);
        }
      }
      function Va(e) {
        var t;
        var n;
        var a;
        var r;
        var s;
        var i;
        if (e.nodeType === 38 && e.parent) {
          if (e.parent.nodeType === 31 && e.parent.d.name === e) {
            va(e.parent);
            return;
          }
          if (e.parent.nodeType === 10 && e.parent.d.name === e) {
            ca(e.parent);
            return;
          }
          if (e.parent.nodeType === 26) {
            Ea(e.parent);
            return;
          }
          if (e.parent.nodeType === 24) {
            Fa(e.parent);
            return;
          }
          if (e.parent.nodeType === 77 && e.parent.d.name === e) {
            oa(e.parent);
            return;
          }
          if (e.parent.nodeType === 32 || e.parent.nodeType === 39) {
            qe(e, 4);
            return;
          }
          if (e.parent.nodeType === 37) {
            return;
          }
        }
        const o = M.getParentAnnotationNode(e);
        if (o) {
          const e = o.parent;
          l.assert(e !== undefined);
          if (e.nodeType === 3) {
            if (o === e.d.annotationComment) {
              Ze(o, {
                varTypeAnnotation: true,
                allowFinal: M.isFinalAllowedForAssignmentTarget(e.d.leftExpr),
                allowClassVar: M.isClassVarAllowedForAssignmentTarget(e.d.leftExpr)
              });
            } else {
              sa(e);
            }
            return;
          } else {
            if (e.nodeType === 54) {
              za(e);
              return;
            } else {
              if (e.nodeType === 31 && o === e.d.returnAnnotation) {
                Ze(o, {
                  typeVarGetsCurScope: true
                });
                return;
              } else {
                Ze(o, {
                  varTypeAnnotation: ((t = o.parent) === null || t === undefined ? undefined : t.nodeType) === 54,
                  allowUnpackedTuple: e.nodeType === 41 && e.d.category === 1,
                  allowUnpackedTypedDict: e.nodeType === 41 && e.d.category === 2
                });
                return;
              }
            }
          }
        }
        const p = M.getParentNodeOfType(e, 64);
        if (p && M.isNodeContainedWithin(e, p.d.pattern)) {
          Ma(p);
          return;
        }
        let d = e;
        let c = 0;
        while (true) {
          const t = M.getParentNodeOfType(d, 1);
          if (t && t !== d) {
            l.assert(t.parent !== undefined);
            if (t.parent.nodeType === 9 || t.parent.nodeType === 27) {
              d = t.parent;
              continue;
            }
            if (t.parent.nodeType === 10) {
              ca(t.parent);
              return;
            }
          }
          let n = d.parent;
          if (!n) {
            break;
          }
          if (n.nodeType === 4 && d === n.d.name) {
            d = n;
            continue;
          }
          const a = M.getParentNodeOfType(n, 48);
          if (a) {
            d = a;
          } else {
            if (n.nodeType === 9 || n.nodeType === 35) {
              if (d === n.d.leftExpr) {
                if (d.nodeType === 9 && d.d.leftExpr.nodeType === 38 && d.d.leftExpr.d.value === 'super') {
                  d = n;
                  continue;
                }
                if (n.nodeType === 9 && d.nodeType === 33) {
                  d = n;
                  continue;
                }
                c = 2;
                break;
              }
            } else {
              if (n.nodeType === 27 && d === n.d.leftExpr) {
                c = 2;
              }
            }
            if (!h.isExpressionNode(n)) {
              if (n.nodeType === 20 || n.nodeType === 19 || n.nodeType === 12 || n.nodeType === 13) {
                l.assert(n.parent !== undefined && h.isExpressionNode(n.parent));
                n = n.parent;
              } else {
                if (n.nodeType !== 41) {
                  if (n.nodeType === 75) {
                    if (e === n.d.boundExpr || e === n.d.defaultExpr) {
                      or(n);
                      return;
                    }
                    break;
                  }
                  break;
                }
                l.assert(n.parent !== undefined);
                if (n.parent.nodeType !== 33) {
                  break;
                }
                n = n.parent;
              }
            }
            d = n;
          }
        }
        const u = d.parent;
        l.assert(u !== undefined);
        switch (u.nodeType) {
          case 17:
            Ft(d);
            return;
          case 75:
            if (d === u.d.name && ((n = u.parent) === null || n === undefined ? undefined : n.nodeType) === 76 && ((a = u.parent.parent) === null || a === undefined ? undefined : a.nodeType) === 77) {
              oa(u.parent.parent);
              return;
            }
            break;
          case 77:
            oa(u);
            return;
          case 16:
            if (((r = u.parent) === null || r === undefined ? undefined : r.nodeType) === 10) {
              ca(u.parent);
            } else {
              if (((s = u.parent) === null || s === undefined ? undefined : s.nodeType) === 31) {
                va(u.parent);
              }
            }
            return;
          case 41:
            if (d !== u.d.defaultValue) {
              Ra(u);
              return;
            }
            break;
          case 1:
            if (d === u.d.name) {
              return;
            }
            if (((i = u.parent) === null || i === undefined ? undefined : i.nodeType) === 10) {
              ca(u.parent);
              return;
            }
            break;
          case 44:
            if (u.d.expr) {
              const t = M.getEnclosingFunction(e);
              let n = t ? fr(t) : undefined;
              if (n) {
                const t = M.getTypeVarScopesForNode(e);
                n = Z.makeTypeVarsBound(n, t);
              }
              qe(u.d.expr, 0, Z.makeInferenceContext(n));
              return;
            }
            break;
          case 54:
            za(u);
            return;
          case 3:
            sa(u);
            return;
        }
        if (d.nodeType !== 54) {
          qe(d, c);
        } else {
          za(d);
        }
      }
      function Ra(e) {
        var t;
        if (!e.d.name) {
          return;
        }
        const n = e.parent;
        if (n.nodeType === 33) {
          Va(n);
          return;
        }
        l.assert(n.nodeType === 31);
        const a = n;
        const r = a.d.params.findIndex(t => t === e);
        const s = M.getTypeAnnotationForParam(a, r);
        if (s) {
          const t = a.d.params[r];
          let n = He(s, a.d.params[r].d.category);
          const i = M.getTypeVarScopesForNode(t);
          n = Z.makeTypeVarsBound(n, i);
          const o = wa(e, e.d.category, Ca(t, n));
          Fe(e.d.name, {
            type: o
          }, 0);
          return;
        }
        const i = M.getEnclosingClass(a, true);
        const o = i ? ca(i) : undefined;
        if (o && H.ClassType.isPseudoGenericClass(o == null ? undefined : o.classType) && a.d.name.d.value === '__init__') {
          const t = da(e.d.name.d.value);
          const n = o.classType.shared.typeParams.find(e => e.shared.name === t);
          if (n) {
            Fe(e.d.name, {
              type: H.TypeVarType.cloneAsBound(n)
            }, 0);
            return;
          }
        }
        let p = (t = Ia(a, x.getFunctionInfoFromDecorators(es, a, true).flags, r, o == null ? undefined : o.classType)) !== null && t !== undefined ? t : H.UnknownType.create();
        const d = M.getTypeVarScopesForNode(e);
        p = Z.makeTypeVarsBound(p, d);
        Fe(e.d.name, {
          type: wa(e, e.d.category, p)
        }, 0);
      }
      function La(e) {
        je(e);
        let t = e;
        while (t) {
          switch (t.nodeType) {
            case 3:
              if (!t.parent || t.parent.nodeType !== 3 && t.parent.nodeType !== 4 && t.parent.nodeType !== 5 || t.parent.d.rightExpr !== t) {
                sa(t);
                return;
              }
              break;
            case 77:
              oa(t);
              return;
            case 4:
            case 33:
              Va(t);
              return;
            case 5:
              pa(t);
              return;
            case 10:
              ca(t);
              return;
            case 41:
              Ra(t);
              return;
            case 31:
              va(t);
              return;
            case 29:
              Pa(t);
              return;
            case 28:
              Da(t);
              return;
            case 59:
              Na(t);
              return;
            case 12:
              {
                const e = t.parent;
                l.assert(e.nodeType === 11);
                if (t === e.d.expr) {
                  Va(e);
                } else {
                  for (const n of e.d.forIfNodes) {
                    Vn(n);
                    if (n === t) {
                      break;
                    }
                  }
                }
                return;
              }
            case 24:
              Fa(t);
              return;
            case 26:
              Ea(t);
              return;
            case 25:
              Oa(t);
              return;
            case 64:
              Ma(t);
              return;
          }
          t = t.parent;
        }
        l.fail('Unexpected statement');
      }
      function Ba(e, t) {
        let n = Pe(e);
        if (n && !n.typeResult.isIncomplete) {
          const e = n.typeResult;
          if (H.isFunction(e.type) && H.FunctionType.isPartiallyEvaluated(e.type) || H.isClass(e.type) && H.ClassType.isPartiallyEvaluated(e.type)) {
            return {
              ...e,
              isIncomplete: true
            };
          } else {
            return e;
          }
        }
        t();
        n = Pe(e);
        if (n) {
          return n.typeResult;
        }
      }
      function ja(e, t) {
        let n = fe.get(e);
        if (n) {
          const e = n.find(e => t && e.typeAtStart ? !t.isIncomplete == !e.typeAtStart.isIncomplete && H.isTypeSame(t.type, e.typeAtStart.type) : !t && !e.typeAtStart);
          if (e) {
            return e.codeFlowAnalyzer;
          }
        }
        const a = ts.createCodeFlowAnalyzer();
        if (n) {
          n.push({
            typeAtStart: t,
            codeFlowAnalyzer: a
          });
        } else {
          n = [{
            typeAtStart: t,
            codeFlowAnalyzer: a
          }];
          fe.set(e, n);
        }
        return a;
      }
      function qa(e, t, n) {
        var a;
        const r = _.createKeyForReference(e);
        const s = M.getExecutionScopeNode((a = t == null ? undefined : t.parent) !== null && a !== undefined ? a : e);
        const i = v.getCodeFlowExpressions(s);
        if (!i || !i.has(r) && !i.has(_.wildcardImportReferenceKey)) {
          return b.FlowNodeTypeResult.create(undefined, false);
        }
        if (yt(e)) {
          return b.FlowNodeTypeResult.create(undefined, true);
        }
        let o;
        o = Me(s) ? function () {
          const e = ke.length;
          l.assert(e > 0);
          return ke[e - 1].codeFlowAnalyzer;
        }() : ja(s.id, n == null ? undefined : n.typeAtStart);
        const p = v.getFlowNode(t ?? e);
        if (p === undefined) {
          return b.FlowNodeTypeResult.create(undefined, false);
        } else {
          return o.getTypeFromCodeFlow(p, e, n);
        }
      }
      function Ga(e, t, n, a) {
        let r = true;
        if (H.ClassType.isSpecialBuiltIn(e)) {
          const s = e.priv.aliasName || e.shared.name;
          switch (s) {
            case 'Callable':
              return {
                type: Bn(e, t, a)
              };
            case 'Never':
            case 'NoReturn':
              {
                if (t && t.length > 0) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgsExpectingNone().format({
                    name: s
                  }), t[0].node);
                }
                let n = s === 'Never' ? H.NeverType.createNever() : H.NeverType.createNoReturn();
                n = H.TypeBase.cloneAsSpecialForm(n, e);
                if (Zr(a)) {
                  n = H.TypeBase.cloneWithTypeForm(n, Z.convertToInstance(n));
                }
                return {
                  type: n
                };
              }
            case 'Optional':
              return {
                type: jn(e, a, t, n)
              };
            case 'Type':
              {
                let n = ea(e, t, 1, undefined, false);
                if (H.isInstantiableClass(n)) {
                  n = Z.explodeGenericClass(n);
                }
                if (Zr(a)) {
                  n = H.TypeBase.cloneWithTypeForm(n, Z.convertToInstance(n));
                }
                return {
                  type: n
                };
              }
            case 'ClassVar':
              return {
                type: Wn(e, a, t, n)
              };
            case 'Protocol':
              if (n & 67109120) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.protocolNotAllowed(), a);
              }
              if (t != null) {
                t.forEach(e => {
                  if (!!e.typeList || !H.isTypeVar(e.type)) {
                    kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.protocolTypeArgMustBeTypeParam(), e.node);
                  }
                });
              }
              return {
                type: ea(e, t, undefined, true)
              };
            case 'TypedDict':
              if (n & 67109120) {
                if (!v.getFileInfo(a).diagnosticRuleSet.enableExperimentalFeatures || !t) {
                  kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typedDictNotAllowed(), a);
                }
              }
              r = false;
              break;
            case 'Literal':
              if (n & 67109120) {
                kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.literalNotAllowed(), a);
              }
              r = false;
              break;
            case 'Tuple':
              return {
                type: ea(e, t, undefined, false, false)
              };
            case 'Union':
              return {
                type: ta(e, a, t, n)
              };
            case 'Generic':
              return {
                type: na(e, a, t, n)
              };
            case 'Final':
              return {
                type: Jn(e, a, t, n)
              };
            case 'Annotated':
              return Xn(e, a, t, n);
            case 'Concatenate':
              return {
                type: Qn(e, a, t, n)
              };
            case 'TypeGuard':
            case 'TypeIs':
              return {
                type: $n(e, a, t, n)
              };
            case 'Unpack':
              return {
                type: Yn(e, a, t, n)
              };
            case 'Required':
            case 'NotRequired':
            case 'ReadOnly':
              return Zn(e, a, t, n);
            case 'Self':
              return {
                type: Hn(e, a, t, n)
              };
            case 'LiteralString':
              return {
                type: ea(e, t, 0)
              };
            case 'TypeForm':
              return {
                type: Kn(e, a, t)
              };
          }
        }
        const s = v.getFileInfo(a);
        if (s.isStubFile || u.PythonVersion.isGreaterOrEqualTo(s.executionEnvironment.pythonVersion, u.pythonVersion3_9) || T.isAnnotationEvaluationPostponed(v.getFileInfo(a)) || n & 4) {
          if (H.ClassType.isBuiltIn(e, 'type') && t) {
            if (t.length >= 1 && (H.isFunction(t[0].type) || H.isOverloaded(t[0].type))) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeAnnotationWithCallable(), t[0].node);
              return {
                type: H.UnknownType.create()
              };
            }
            if ((Ae == null ? undefined : Ae.typeClass) && H.isInstantiableClass(Ae.typeClass)) {
              let e = ea(Ae.typeClass, t, 1, undefined, false);
              if (H.isInstantiableClass(e)) {
                e = Z.explodeGenericClass(e);
              }
              if (Zr(a)) {
                e = H.TypeBase.cloneWithTypeForm(e, Z.convertToInstance(e));
              }
              return {
                type: e
              };
            }
          }
          if (Z.isTupleClass(e)) {
            let n = ea(e, t, undefined, undefined, false);
            if (Zr(a)) {
              n = H.TypeBase.cloneWithTypeForm(n, Z.convertToInstance(n));
            }
            return {
              type: n
            };
          }
        }
        let i = t ? t.length : 0;
        const o = H.ClassType.isPseudoGenericClass(e) ? [] : H.ClassType.getTypeParams(e);
        if (o.length === 0 && i === 0) {
          return {
            type: e
          };
        }
        const c = o.findIndex(e => H.isTypeVarTuple(e));
        if (t) {
          let n = o.length;
          const s = o.findIndex(e => !!e.shared.isDefaultExplicit);
          if (s >= 0) {
            n = s;
          }
          if (t.length > 0 && t[0].inlinedTypeDict) {
            if (t.length > 1) {
              kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsTooMany().format({
                name: e.priv.aliasName || e.shared.name,
                expected: 1,
                received: i
              }), t[1].node);
            }
            return {
              type: t[0].inlinedTypeDict
            };
          }
          if (i > o.length) {
            if (!H.ClassType.isPartiallyEvaluated(e) && !H.ClassType.isTupleClass(e)) {
              if (o.length === 0) {
                r = false;
                kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsExpectingNone().format({
                  name: e.priv.aliasName || e.shared.name
                }), t[o.length].node);
              } else {
                if (o.length !== 1 || !H.isParamSpec(o[0])) {
                  r = false;
                  kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsTooMany().format({
                    name: e.priv.aliasName || e.shared.name,
                    expected: o.length,
                    received: i
                  }), t[o.length].node);
                }
              }
              i = o.length;
            }
          } else {
            if (i < n) {
              r = false;
              kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeArgsTooFew().format({
                name: e.priv.aliasName || e.shared.name,
                expected: n,
                received: i
              }), t.length > 0 ? t[0].node.parent : a);
            }
          }
          t.forEach((e, t) => {
            var n;
            if (!((n = e.type.props) === null || n === undefined ? undefined : n.typeForm)) {
              r = false;
            }
            if (t === c) {
              if (H.isClassInstance(e.type) && Z.isTupleClass(e.type)) {
                return;
              }
              if (H.isTypeVarTuple(e.type)) {
                if (!Gt(e.type, e.node)) {
                  r = false;
                }
                return;
              }
            }
            const a = t < o.length ? o[t] : undefined;
            if (!Ln(e, {
              allowParamSpec: true,
              allowTypeArgList: a && H.isParamSpec(a)
            })) {
              r = false;
            }
          });
        }
        let m = [];
        const y = H.ClassType.getTypeParams(e);
        if (!(t = Wa(y, t, a))) {
          r = false;
        }
        const h = new k.ConstraintTracker();
        y.forEach((n, a) => {
          if (t && a < t.length) {
            if (H.isParamSpec(n)) {
              const e = t[a];
              const r = H.FunctionType.createSynthesizedInstance('', 65536);
              if (Z.isEllipsisType(e.type)) {
                H.FunctionType.addDefaultParams(r);
                r.shared.flags |= 32768;
                m.push(r);
                h.setBounds(n, r);
                return;
              }
              if (e.typeList) {
                e.typeList.forEach((e, t) => {
                  H.FunctionType.addParam(r, H.FunctionParam.create(0, Z.convertToInstance(e.type), H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${t}`));
                });
                if (e.typeList.length > 0) {
                  H.FunctionType.addPositionOnlyParamSeparator(r);
                }
                m.push(r);
                h.setBounds(n, r);
                return;
              }
              if (H.isInstantiableClass(e.type) && H.ClassType.isBuiltIn(e.type, 'Concatenate')) {
                const t = e.type.priv.typeArgs;
                if (t && t.length > 0) {
                  t.forEach((e, n) => {
                    if (n === t.length - 1) {
                      if (H.isParamSpec(e)) {
                        H.FunctionType.addParamSpecVariadics(r, e);
                      } else {
                        if (Z.isEllipsisType(e)) {
                          H.FunctionType.addDefaultParams(r);
                          r.shared.flags |= 32768;
                        }
                      }
                    } else {
                      H.FunctionType.addParam(r, H.FunctionParam.create(0, e, H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, `__p${n}`));
                    }
                  });
                }
                m.push(r);
                return;
              }
            }
            const e = Z.convertToInstance(t[a].type);
            m.push(e);
            h.setBounds(n, e);
            return;
          }
          const r = Xe(n, h, {
            replaceUnsolved: {
              scopeIds: Z.getTypeVarScopeIds(e),
              tupleClassType: ot()
            }
          });
          m.push(r);
          h.setBounds(n, r);
        });
        m = m.map((a, s) => {
          if (s < i) {
            const i = new p.DiagnosticAddendum();
            let c = function (e, t, n) {
              if (H.isAnyOrUnknown(t)) {
                return t;
              }
              let a = Z.transformPossibleRecursiveTypeAlias(t);
              if (H.isTypeVar(t)) {
                if (H.isTypeSame(t, e)) {
                  return t;
                }
                a = Pt(t);
              }
              if (H.isClass(a) && H.ClassType.isPartiallyEvaluated(a)) {
                return t;
              }
              if (e.shared.boundType && !Z.isTypeAliasPlaceholder(a) && !Ir(e.shared.boundType, a, n.createAddendum(), undefined)) {
                if (!e.shared.isSynthesized) {
                  n.addMessage(g.LocAddendum.typeBound().format({
                    sourceType: Yr(a),
                    destType: Yr(e.shared.boundType),
                    name: H.TypeVarType.getReadableName(e)
                  }));
                }
                return;
              }
              if (H.isParamSpec(e)) {
                if (H.isParamSpec(t) || H.isFunction(t) && H.FunctionType.isParamSpecValue(t) || H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'Concatenate')) {
                  return t;
                } else {
                  n.addMessage(g.LocAddendum.typeParamSpec().format({
                    type: Yr(t),
                    name: H.TypeVarType.getReadableName(e)
                  }));
                  return;
                }
              }
              if (H.isParamSpec(t)) {
                n.addMessage(g.LocMessage.paramSpecContext());
                return;
              }
              const r = e.shared.constraints;
              if (r.length === 0) {
                return t;
              }
              if (Z.isTypeAliasPlaceholder(t)) {
                return t;
              }
              if (H.isTypeVar(t) && H.TypeVarType.hasConstraints(t)) {
                if (t.shared.constraints.every(e => r.some(t => Ir(t, e)))) {
                  return t;
                }
              } else {
                let e;
                for (const t of r) {
                  if (Ir(t, a)) {
                    if ((!H.isNever(a) || !!H.isNever(t)) && (!e || !!Ir(e, t))) {
                      e = t;
                    }
                  }
                }
                if (e) {
                  return e;
                }
              }
              n.addMessage(g.LocAddendum.typeConstrainedTypeVar().format({
                type: Yr(t),
                name: H.TypeVarType.getReadableName(e)
              }));
              return;
            }(o[s], a, i);
            if (c && n & 16384) {
              const t = o[s].shared.declaredVariance;
              if (!Z.isVarianceOfTypeArgCompatible(c, t)) {
                i.addMessage(g.LocAddendum.varianceMismatchForClass().format({
                  typeVarName: Yr(c),
                  className: e.shared.name
                }));
                c = undefined;
              }
            }
            if (c) {
              a = c;
            } else {
              if (!H.isClassInstance(a) || !H.ClassType.isPartiallyEvaluated(a)) {
                l.assert(t !== undefined);
                r = false;
                kt(d.DiagnosticRule.reportInvalidTypeArguments, g.LocMessage.typeVarAssignmentMismatch().format({
                  type: Yr(a),
                  name: H.TypeVarType.getReadableName(o[s])
                }) + i.getString(), t[s].node);
              }
            }
          }
          return a;
        });
        if (t && e.shared.typeParams.length === 0 && H.ClassType.isPartiallyEvaluated(e)) {
          m = t.map(e => Z.convertToInstance(e.type));
        }
        let f = H.ClassType.specialize(e, m, t !== undefined);
        if (Zr(a)) {
          f = H.TypeBase.cloneWithTypeForm(f, r ? Z.convertToInstance(f) : undefined);
        }
        return {
          type: f
        };
      }
      function Wa(e, t, n) {
        if (e.length !== 1 || !H.isParamSpec(e[0]) || !t) {
          return t;
        }
        if (t.length > 1) {
          for (const e of t) {
            if (H.isParamSpec(e.type)) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.paramSpecContext(), e.node);
              return;
            }
            if (Z.isEllipsisType(e.type)) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.ellipsisContext(), e.node);
              return;
            }
            if (H.isInstantiableClass(e.type) && H.ClassType.isBuiltIn(e.type, 'Concatenate')) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.concatenateContext(), e.node);
              return;
            }
            if (e.typeList) {
              kt(d.DiagnosticRule.reportInvalidTypeForm, g.LocMessage.typeArgListNotAllowed(), e.node);
              return;
            }
          }
        }
        if (t.length === 1) {
          if (t[0].typeList) {
            return t;
          }
          const e = t[0].type;
          if (H.isParamSpec(e) || Z.isEllipsisType(e)) {
            return t;
          }
          if (H.isInstantiableClass(e) && H.ClassType.isBuiltIn(e, 'Concatenate')) {
            return t;
          }
        }
        return [{
          type: H.UnknownType.create(),
          node: t.length > 0 ? t[0].node : n,
          typeList: t
        }];
      }
      function Ka(e, t) {
        var n;
        var a;
        if (e.typeResult) {
          const t = e.typeResult.type;
          return {
            type: (a = (n = t == null ? undefined : t.props) === null || n === undefined ? undefined : n.specialForm) !== null && a !== undefined ? a : t,
            isIncomplete: e.typeResult.isIncomplete
          };
        }
        if (e.valueExpression) {
          return qe(e.valueExpression, undefined, t);
        } else {
          return {
            type: H.UnknownType.create()
          };
        }
      }
      function $a(e, t) {
        if (e.typeResult) {
          return {
            type: e.typeResult.type,
            isIncomplete: e.typeResult.isIncomplete
          };
        } else {
          l.assert(e.valueExpression !== undefined);
          return Ha(e.valueExpression, t);
        }
      }
      function Ha(e, t) {
        let n = 136;
        if (t == null ? undefined : t.allowTypeVarsWithoutScopeId) {
          n |= 4096;
        }
        if (t == null ? undefined : t.typeVarGetsCurScope) {
          n |= 8192;
        }
        if (t == null ? undefined : t.enforceClassTypeVarScope) {
          n |= -2147483648;
        }
        const a = v.getFileInfo(e);
        if (T.isAnnotationEvaluationPostponed(a) || (t == null ? undefined : t.forwardRefs)) {
          n |= 4;
        } else {
          if (t == null ? undefined : t.parsesStringLiteral) {
            n |= 16777216;
          }
        }
        if (!(t == null ? undefined : t.allowFinal)) {
          n |= 16;
        }
        if (t == null ? undefined : t.allowRequired) {
          n |= 1048832;
        }
        if (t == null ? undefined : t.allowReadOnly) {
          n |= 2097408;
        }
        if (t == null ? undefined : t.allowUnpackedTuple) {
          n |= 4194304;
        } else {
          n |= 64;
        }
        if (t == null ? undefined : t.allowUnpackedTypedDict) {
          n |= 8388608;
        }
        if (!(t == null ? undefined : t.allowParamSpec)) {
          n |= 32;
        }
        if (t == null ? undefined : t.typeExpression) {
          n |= 256;
        }
        if (t == null ? undefined : t.convertEllipsisToAny) {
          n |= 1;
        }
        if (t == null ? undefined : t.allowEllipsis) {
          n |= 65536;
        }
        if (t == null ? undefined : t.noNonTypeSpecialForms) {
          n |= 67108864;
        }
        if (!(t == null ? undefined : t.allowClassVar)) {
          n |= 131072;
        }
        if (t == null ? undefined : t.varTypeAnnotation) {
          n |= 32768;
        }
        if (t == null ? undefined : t.notParsed) {
          n |= 524288;
        }
        if (t == null ? undefined : t.typeFormArg) {
          n |= 1073741824;
        }
        return qe(e, n);
      }
      function Za(e, t) {
        const n = V.getScopeForNode(e);
        if (n) {
          const e = V.getBuiltInScope(n).lookUpSymbol(t);
          if (e) {
            return cr(e);
          }
        }
        return H.UnknownType.create();
      }
      function Ya(e, t, n) {
        const a = Za(e, t);
        if (H.isInstantiableClass(a)) {
          let e = a;
          if (n) {
            e = H.ClassType.specialize(e, n);
          }
          return H.ClassType.cloneAsInstance(e);
        }
        return a;
      }
      function Ja(e, t, n, a = false) {
        var r;
        const s = M.getEvaluationScopeNode(e);
        const i = v.getScope(s.node);
        let o = i == null ? undefined : i.lookUpSymbolRecursive(t, {
          useProxyScope: !!s.useProxyScope
        });
        const l = (r = i == null ? undefined : i.type) !== null && r !== undefined ? r : 4;
        let p = l !== 2 && l !== 1;
        if ((o == null ? undefined : o.scope.type) === 0) {
          p = false;
        }
        if (o && n && p) {
          if (!o.symbol.getDeclarations().find(n => {
            if (n.type !== 8 && n.type !== 0) {
              let a = M.getExecutionScopeNode(e);
              const r = n.type === 6 || n.type === 5 || n.type === 4 ? n.node.d.name : n.node;
              const s = M.getExecutionScopeNode(r);
              const i = v.getScope(a);
              if (i == null ? undefined : i.proxy) {
                const e = v.getScope(a);
                if (!(e == null ? undefined : e.symbolTable.has(t)) && a.parent) {
                  a = M.getExecutionScopeNode(a.parent);
                }
              }
              if (a === s && !vt(r, e)) {
                const t = v.getFlowNode(e);
                return !t || ts.getFlowNodeReachability(t, undefined, true) !== K.Reachability.Reachable;
              }
            }
            return true;
          })) {
            if (o.scope.type !== 2) {
              let e = o.scope.parent;
              const n = o.isOutsideCallerModule || o.scope.type === 4;
              let a = o.isBeyondExecutionScope || o.scope.isIndependentlyExecutable();
              if (o.scope.type === 3) {
                const t = o.scope.getGlobalScope();
                e = t.scope;
                if (t.isBeyondExecutionScope) {
                  a = true;
                }
              }
              o = e ? e.lookUpSymbolRecursive(t, {
                isOutsideCallerModule: n,
                isBeyondExecutionScope: a
              }) : undefined;
            } else {
              o = undefined;
            }
          }
        }
        if (o && a) {
          let e = o;
          while (e.scope.type !== 4 && e.scope.type !== 5 && e.scope.type !== 0 && e.scope.parent && (e = e.scope.parent.lookUpSymbolRecursive(t, {
            isOutsideCallerModule: e.isOutsideCallerModule,
            isBeyondExecutionScope: e.isBeyondExecutionScope || e.scope.isIndependentlyExecutable()
          }), e));
          if ((e == null ? undefined : e.scope.type) === 4 || (e == null ? undefined : e.scope.type) === 5) {
            o = e;
          }
        }
        return o;
      }
      function Qa(e, t, n) {
        me.push({
          node: e,
          suppressedDiags: n ? [] : undefined
        });
        try {
          const e = t();
          const a = me.pop();
          if (n && (a == null ? undefined : a.suppressedDiags)) {
            n(a.suppressedDiags);
          }
          return e;
        } catch (e) {
          me.pop();
          throw e;
        }
      }
      function Xa(e) {
        for (let t = Se.length - 1; t >= 0; t--) {
          const n = Se[t].rootNode;
          if (M.isNodeContainedWithin(e, n)) {
            return Se[t].tracker;
          }
        }
      }
      function er(e, t) {
        const n = Xa(e);
        try {
          if (!n) {
            Se.push({
              tracker: new Z.UniqueSignatureTracker(),
              rootNode: e
            });
          }
          const a = t();
          if (!n) {
            Se.pop();
          }
          return a;
        } catch (e) {
          if (!n) {
            Se.pop();
          }
          throw e;
        }
      }
      function tr(e, t) {
        const n = Xa(t);
        if (n && (H.isFunction(e) || H.isOverloaded(e))) {
          return Z.ensureSignaturesAreUnique(e, n, t.start);
        } else {
          return e;
        }
      }
      function nr(e, t, n) {
        if (!e) {
          return t();
        }
        ue.enterSpeculativeContext(e, n);
        try {
          const e = t();
          ue.leaveSpeculativeContext();
          return e;
        } catch (e) {
          ue.leaveSpeculativeContext();
          throw e;
        }
      }
      function ar(e) {
        return ue.isSpeculative(e);
      }
      function rr(e, t) {
        if (H.isFunction(e) && e.shared.declaration) {
          const n = e.shared.declaration;
          if (n.type === 5) {
            const a = n.node;
            const r = v.getScope(a);
            if (r) {
              const n = r.lookUpSymbol(t);
              if (n) {
                return n.getDeclarations().find(e => e.type === 2);
              }
              const a = E.getParamListDetails(e);
              if (a.unpackedKwargsTypedDictType) {
                const e = Z.lookUpClassMember(a.unpackedKwargsTypedDictType, t);
                if (e) {
                  return e.symbol.getDeclarations().find(e => e.type === 1);
                }
              }
            }
          }
        }
      }
      function sr(e) {
        if (e.parent && e.parent.nodeType === 26 && e.parent.d.alias && e === e.parent.d.name) {
          return e.parent.d.alias;
        }
      }
      function ir(e) {
        var t;
        var n;
        var a;
        switch (e.type) {
          case 0:
            {
              if (e.intrinsicType === 'Any') {
                return {
                  type: H.AnyType.create()
                };
              }
              if (e.intrinsicType === 'type[self]') {
                const t = ca(M.getEnclosingClass(e.node));
                return {
                  type: t ? Z.synthesizeTypeVarForSelfCls(t.classType, true) : H.UnknownType.create()
                };
              }
              const t = Ya(e.node, 'str');
              const n = Ya(e.node, 'int');
              if (H.isClassInstance(n) && H.isClassInstance(t)) {
                if (e.intrinsicType === 'str') {
                  return {
                    type: t
                  };
                }
                if (e.intrinsicType === 'str | None') {
                  return {
                    type: H.combineTypes([t, pt()])
                  };
                }
                if (e.intrinsicType === 'int') {
                  return {
                    type: n
                  };
                }
                if (e.intrinsicType === 'Iterable[str]') {
                  const n = Za(e.node, 'Iterable');
                  if (H.isInstantiableClass(n)) {
                    return {
                      type: H.ClassType.cloneAsInstance(H.ClassType.specialize(n, [t]))
                    };
                  }
                }
                if (e.intrinsicType === 'Dict[str, Any]') {
                  const n = Za(e.node, 'dict');
                  if (H.isInstantiableClass(n)) {
                    return {
                      type: H.ClassType.cloneAsInstance(H.ClassType.specialize(n, [t, H.AnyType.create()]))
                    };
                  }
                }
              }
              return {
                type: H.UnknownType.create()
              };
            }
          case 6:
            {
              const t = ca(e.node);
              return {
                type: t == null ? undefined : t.decoratedType
              };
            }
          case 7:
            return {
              type: Ze(e.node.d.annotation)
            };
          case 5:
            {
              const t = va(e.node);
              return {
                type: t == null ? undefined : t.decoratedType
              };
            }
          case 4:
            return {
              type: oa(e.node)
            };
          case 2:
            {
              let a = (t = e.node.d.annotation) !== null && t !== undefined ? t : e.node.d.annotationComment;
              if (!a && ((n = e.node.parent) === null || n === undefined ? undefined : n.nodeType) === 31) {
                const t = e.node.parent;
                if (t.d.funcAnnotationComment && !t.d.funcAnnotationComment.d.isEllipsis) {
                  const n = t.d.params.findIndex(t => t === e.node);
                  a = M.getTypeAnnotationForParam(t, n);
                }
              }
              if (a) {
                let t = He(a, e.node.d.category);
                const n = M.getTypeVarScopesForNode(e.node);
                t = Z.makeTypeVarsBound(t, n);
                return {
                  type: wa(e.node, e.node.d.category, Ca(e.node, t))
                };
              }
              return {
                type: undefined
              };
            }
          case 3:
            return {
              type: or(e.node)
            };
          case 1:
            {
              const t = e.typeAnnotationNode;
              if (t) {
                let n;
                if (e.isRuntimeTypeExpression) {
                  n = Z.convertToInstance(Ha(t, {
                    allowFinal: true,
                    allowRequired: true,
                    allowReadOnly: true
                  }).type);
                } else {
                  const r = e.isDefinedByMemberAccess && ((a = e.node.parent) === null || a === undefined ? undefined : a.nodeType) === 35 ? e.node.parent : e.node;
                  const s = M.isClassVarAllowedForAssignmentTarget(r);
                  const i = M.isFinalAllowedForAssignmentTarget(r);
                  const o = M.isRequiredAllowedForAssignmentTarget(r) || !!e.isInInlinedTypedDict;
                  n = Ze(t, {
                    varTypeAnnotation: true,
                    allowClassVar: s,
                    allowFinal: i,
                    allowRequired: o,
                    allowReadOnly: o,
                    enforceClassTypeVarScope: e.isDefinedByMemberAccess
                  });
                }
                if (n) {
                  if (e.isDefinedByMemberAccess) {
                    const t = M.getEnclosingClass(e.node);
                    if (t) {
                      n = Z.makeTypeVarsFree(n, [M.getScopeIdForNode(t)]);
                    }
                  }
                  if (H.isClassInstance(n) && H.ClassType.isBuiltIn(n, 'TypeAlias')) {
                    return {
                      type: undefined,
                      isTypeAlias: true
                    };
                  } else {
                    return {
                      type: n
                    };
                  }
                }
              }
              return {
                type: undefined
              };
            }
          case 8:
            return {
              type: undefined
            };
        }
      }
      function or(e) {
        const t = Ne(e.d.name, 0);
        if (t && H.isTypeVar(t)) {
          return t;
        }
        let n = 'TypeVar';
        let a = H.TypeVarKind.TypeVar;
        if (e.d.typeParamKind === h.TypeParamKind.TypeVarTuple) {
          n = 'TypeVarTuple';
          a = H.TypeVarKind.TypeVarTuple;
        } else {
          if (e.d.typeParamKind === h.TypeParamKind.ParamSpec) {
            n = 'ParamSpec';
            a = H.TypeVarKind.ParamSpec;
          }
        }
        const r = ct(e, n);
        const s = r && H.isInstantiableClass(r) ? r : undefined;
        let i = H.TypeVarType.createInstantiable(e.d.name.d.value, a);
        if (s) {
          i = H.TypeBase.cloneAsSpecialForm(i, H.ClassType.cloneAsInstance(s));
        }
        i.shared.isTypeParamSyntax = true;
        Fe(e, {
          type: i
        }, undefined);
        Fe(e.d.name, {
          type: i
        }, undefined);
        if (e.d.boundExpr) {
          if (e.d.boundExpr.nodeType === 52) {
            const t = e.d.boundExpr.d.items.map(e => {
              const t = Ha(e, {
                noNonTypeSpecialForms: true,
                forwardRefs: true,
                typeExpression: true
              }).type;
              if (Z.requiresSpecialization(t, {
                ignorePseudoGeneric: true,
                ignoreImplicitTypeArgs: true
              })) {
                kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarBoundGeneric(), e);
              }
              return Z.convertToInstance(t);
            });
            if (t.length < 2) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarSingleConstraint(), e.d.boundExpr);
            } else {
              if (e.d.typeParamKind === h.TypeParamKind.TypeVar) {
                i.shared.constraints = t;
              }
            }
          } else {
            const t = Ha(e.d.boundExpr, {
              noNonTypeSpecialForms: true,
              forwardRefs: true,
              typeExpression: true
            }).type;
            if (Z.requiresSpecialization(t, {
              ignorePseudoGeneric: true
            })) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.typeVarConstraintGeneric(), e.d.boundExpr);
            }
            if (e.d.typeParamKind === h.TypeParamKind.TypeVar) {
              i.shared.boundType = Z.convertToInstance(t);
            }
          }
        }
        if (e.d.typeParamKind === h.TypeParamKind.ParamSpec) {
          const t = e.d.defaultExpr ? wn(e.d.defaultExpr, true) : undefined;
          if (t) {
            i.shared.defaultType = t;
            i.shared.isDefaultExplicit = true;
          } else {
            i.shared.defaultType = H.ParamSpecType.getUnknown();
          }
        } else {
          if (e.d.typeParamKind === h.TypeParamKind.TypeVarTuple) {
            const t = e.d.defaultExpr ? In(e.d.defaultExpr, true) : undefined;
            if (t) {
              i.shared.defaultType = t;
              i.shared.isDefaultExplicit = true;
            } else {
              i.shared.defaultType = q.makeTupleObject(es, [{
                type: H.UnknownType.create(),
                isUnbounded: true
              }]);
            }
          } else {
            const t = e.d.defaultExpr ? Z.convertToInstance(Ha(e.d.defaultExpr, {
              forwardRefs: true,
              typeExpression: true
            }).type) : undefined;
            if (t) {
              i.shared.defaultType = t;
              i.shared.isDefaultExplicit = true;
            } else {
              i.shared.defaultType = H.UnknownType.create();
            }
          }
        }
        if (i.shared.isDefaultExplicit && e.d.defaultExpr) {
          _n(i, e.d.defaultExpr);
        }
        const o = M.getTypeVarScopeNode(e);
        if (o) {
          let e;
          if (o.nodeType === 10) {
            e = 0;
            i.shared.declaredVariance = H.isParamSpec(i) || H.isTypeVarTuple(i) ? 2 : 0;
          } else {
            if (o.nodeType === 31) {
              e = 1;
            } else {
              l.assert(o.nodeType === 77);
              e = 2;
              i.shared.declaredVariance = H.isParamSpec(i) || H.isTypeVarTuple(i) ? 2 : 0;
            }
          }
          i = H.TypeVarType.cloneForScopeId(i, M.getScopeIdForNode(o.nodeType === 77 ? o.d.name : o), o.d.name.d.value, e);
        }
        Fe(e, {
          type: i
        }, undefined);
        Fe(e.d.name, {
          type: i
        }, undefined);
        return i;
      }
      function lr(t, a) {
        var r;
        var s;
        var i;
        const o = pr(a, true, {
          allowExternallyHiddenAccess: v.getFileInfo(a.node).isStubFile
        });
        if (!o) {
          if (n.evaluateUnknownImportsAsAny) {
            return H.AnyType.create();
          } else {
            return H.UnknownType.create();
          }
        }
        function p(e, t, a) {
          if (!t.uri.isEmpty() && t.loadSymbolsFromPath) {
            const r = a(t.uri);
            if (r) {
              e.priv.fields = r.symbolTable;
              e.priv.docString = r.docString;
            } else {
              e.priv.notPresentFieldType = n.evaluateUnknownImportsAsAny ? H.AnyType.create() : H.UnknownType.create();
            }
          }
          if (t.implicitImports) {
            t.implicitImports.forEach((t, n) => {
              let r;
              if (t.isUnresolved) {
                r = H.UnknownType.create();
              } else {
                const s = e.priv.moduleName ? e.priv.moduleName + '.' + n : '';
                r = p(H.ModuleType.create(s, t.uri), t, a);
              }
              const s = L.Symbol.createWithType(0, r);
              e.priv.loaderFields.set(n, s);
            });
          }
          return e;
        }
        if (o.type === 8) {
          const t = H.ModuleType.create(o.moduleName, o.uri);
          if (o.symbolName && o.submoduleFallback) {
            return p(t, o.submoduleFallback, e);
          } else {
            return p(t, o, e);
          }
        }
        const d = ir(o);
        if (d.type) {
          return d.type;
        }
        const c = v.getFileInfo(o.node);
        let u = !c.isInPyTypedPackage || c.isStubFile;
        if (!u && o.type === 1) {
          const e = M.getEnclosingClass(o.node, true);
          if (e) {
            const t = ca(e);
            if (t && H.ClassType.isEnumClass(t.classType)) {
              u = true;
            }
          }
          if (Lr(o) || o.isConstant) {
            u = true;
          }
          if (((r = o.inferredTypeSource) === null || r === undefined ? undefined : r.nodeType) === 9) {
            const e = qe(o.inferredTypeSource.d.leftExpr, 2).type;
            const t = ['TypeVar', 'ParamSpec', 'TypeVarTuple', 'TypedDict', 'NamedTuple', 'NewType', 'TypeAliasType'];
            if (H.isInstantiableClass(e) && H.ClassType.isBuiltIn(e, t) || H.isFunction(e) && t.some(t => H.FunctionType.isBuiltIn(e, t))) {
              u = true;
            }
          }
        }
        if (o.type === 2) {
          l.assert(o.node.d.name !== undefined);
          if ((s = Ba(o.node.d.name, () => {
            Ra(o.node);
          })) === null || s === undefined) {
            return undefined;
          } else {
            return s.type;
          }
        }
        if (o.type === 1 && o.inferredTypeSource) {
          const e = Br(o) || Wr(o);
          const n = e && o.inferredTypeSource.parent ? o.inferredTypeSource.parent : o.inferredTypeSource;
          let r = (i = Ba(o.node, () => {
            La(n);
          })) === null || i === undefined ? undefined : i.type;
          if (r && e && o.typeAliasName && Gr(r)) {
            const e = ia(o.typeAliasName, false);
            r = aa(r, o.node, e, false);
            u = true;
          }
          if (r && c.isInPyTypedPackage && !c.isStubFile) {
            if (!u) {
              if (function (e, t, n) {
                var a;
                const r = e.getDeclarations().filter(e => e.type !== 1 || !e.isInferenceAllowedInPyTyped);
                if (r.length > 1) {
                  return false;
                }
                if (t.type !== 1) {
                  return false;
                }
                if (r.length === 0) {
                  return true;
                }
                if (H.isTypeVar(n)) {
                  return true;
                }
                let s;
                const i = t.node.parent;
                if (i) {
                  if (i.nodeType === 3) {
                    s = i;
                  } else {
                    if (i.nodeType === 35 && ((a = i.parent) === null || a === undefined ? undefined : a.nodeType) === 3) {
                      s = i.parent;
                    }
                  }
                }
                if (!s) {
                  return false;
                }
                const o = qe(s.d.rightExpr).type;
                if (H.isClassInstance(o) && Z.isLiteralType(o)) {
                  return true;
                }
                if (s.d.rightExpr.nodeType === 38 && !H.TypeBase.isAmbiguous(o)) {
                  return true;
                }
                return false;
              }(t, a, r)) {
                u = true;
              }
            }
            if (!u) {
              r = H.TypeBase.cloneForAmbiguousType(r);
            }
          }
          return r;
        }
      }
      function pr(t, n, a) {
        var r;
        var s;
        var i;
        if ((i = A.resolveAliasDeclaration(e, t, {
          resolveLocalNames: n,
          allowExternallyHiddenAccess: (r = a == null ? undefined : a.allowExternallyHiddenAccess) !== null && r !== undefined && r,
          skipFileNeededCheck: (s = a == null ? undefined : a.skipFileNeededCheck) !== null && s !== undefined && s
        })) === null || i === undefined) {
          return undefined;
        } else {
          return i.declaration;
        }
      }
      function dr(t, n, a) {
        var r;
        var s;
        return A.resolveAliasDeclaration(e, t, {
          resolveLocalNames: n,
          allowExternallyHiddenAccess: (r = a == null ? undefined : a.allowExternallyHiddenAccess) !== null && r !== undefined && r,
          skipFileNeededCheck: (s = a == null ? undefined : a.skipFileNeededCheck) !== null && s !== undefined && s
        });
      }
      function cr(e) {
        return ur(e).type;
      }
      function ur(e, t, n = false) {
        let a;
        if (e.hasTypedDeclarations()) {
          a = yr(e, t);
          const n = a == null ? undefined : a.type;
          let r = false;
          if (n && (H.isFunction(n) && H.FunctionType.isPartiallyEvaluated(n) || H.isClass(n) && H.ClassType.isPartiallyEvaluated(n))) {
            r = true;
          }
          if (n || !a.isTypeAlias) {
            const t = e.getTypedDeclarations();
            return {
              type: n ?? H.UnknownType.create(),
              isIncomplete: r,
              includesVariableDecl: mr(t),
              includesIllegalTypeAliasDecl: !t.every(e => jr(e)),
              includesSpeculativeResult: false,
              isRecursiveDefinition: !n && !ue.isSpeculative(undefined)
            };
          }
        }
        return function (e, t, n = false) {
          let a = ve.get(e.id);
          const r = t ? t.id : undefined;
          const s = `${r === undefined ? '.' : r.toString()}${n ? '*' : ''}`;
          const i = a == null ? undefined : a.get(s);
          if (i && !i.isIncomplete) {
            return i;
          }
          const o = e.getDeclarations();
          let l;
          if (o.length > re) {
            const e = {
              type: H.UnknownType.create(),
              isIncomplete: false,
              includesVariableDecl: false,
              includesIllegalTypeAliasDecl: !o.every(e => jr(e)),
              includesSpeculativeResult: false,
              isRecursiveDefinition: false
            };
            y(e);
            return e;
          }
          if (n) {
            o.forEach((e, t) => {
              if (!e.isInExceptSuite) {
                l = t;
              }
            });
          } else {
            if (o.length > 1 && o.every(e => e.type === 8)) {
              const e = o.filter(e => e.type === 8 && !e.isInExceptSuite);
              if (e.length === 1) {
                l = o.findIndex(t => t === e[0]);
              }
            }
          }
          const p = [];
          let d = false;
          let c = false;
          let u = false;
          o.forEach((n, a) => {
            var r;
            var s;
            var i;
            const o = (r = pr(n, true, {
              allowExternallyHiddenAccess: v.getFileInfo(n.node).isStubFile
            })) !== null && r !== undefined ? r : n;
            if (!jr(o) && !Br(o)) {
              c = true;
            }
            if (mr([o])) {
              d = true;
            }
            if (l !== undefined && l !== a) {
              return;
            }
            if (u) {
              return;
            }
            if (j.isEffectivelyClassVar(e, false) && n.type === 1 && n.isDefinedByMemberAccess) {
              return;
            }
            if (t !== undefined && n.type !== 8) {
              if (M.getExecutionScopeNode(t) === M.getExecutionScopeNode(n.node)) {
                return;
              }
            }
            const m = Br(o);
            const y = m || Wr(o);
            if (m) {
              u = true;
            }
            if (y && o.type === 1 && ((i = (s = o.inferredTypeSource) === null || s === undefined ? undefined : s.parent) === null || i === undefined ? undefined : i.nodeType) === 3) {
              sa(o.inferredTypeSource.parent);
            }
            p.push(o);
          });
          const m = function (e, t, n) {
            var a;
            var r;
            const s = [];
            let i = false;
            let o = false;
            let l = false;
            t.forEach(t => {
              if (ze(e, t)) {
                try {
                  let n = lr(e, t);
                  if (!Ue(e)) {
                    i = true;
                  }
                  if (n) {
                    if (t.type === 1) {
                      let e = false;
                      if (t.type === 1 && (t.isConstant || Lr(t))) {
                        e = true;
                      }
                      if (H.isClassInstance(n) && H.ClassType.isEnumClass(n) && P.isDeclInEnumClass(es, t)) {
                        e = true;
                      }
                      if (!!H.TypeBase.isInstance(n) && !e && !Br(t)) {
                        n = Z.stripTypeForm($e(n));
                      }
                    }
                    s.push(n);
                    if (ar(t.node)) {
                      l = true;
                    }
                  } else {
                    i = true;
                  }
                } catch (t) {
                  Ue(e);
                  throw t;
                }
              } else {
                if (t.type === 6) {
                  const e = ca(t.node);
                  if (e == null ? undefined : e.decoratedType) {
                    s.push(e.decoratedType);
                  }
                }
                i = true;
                o = true;
              }
            });
            const p = ve.get(e.id);
            const d = ((r = (a = p == null ? undefined : p.get(n)) === null || a === undefined ? undefined : a.evaluationAttempts) !== null && r !== undefined ? r : 0) + 1;
            let c;
            if (s.length > 0) {
              i = o && d < se;
              c = H.combineTypes(s);
            } else {
              c = H.UnboundType.create();
            }
            return {
              type: c,
              isIncomplete: i,
              includesSpeculativeResult: l,
              evaluationAttempts: d
            };
          }(e, p, s);
          m.includesVariableDecl = d;
          m.includesIllegalTypeAliasDecl = c;
          if (!m.includesSpeculativeResult) {
            y(m);
          }
          return m;
          function y(t) {
            if (!a) {
              a = new Map();
              ve.set(e.id, a);
            }
            a.set(s, t);
          }
        }(e, t, n);
      }
      function mr(e) {
        return e.some(e => {
          if (e.type === 1) {
            const t = v.getFileInfo(e.node);
            if (!t.isTypingStubFile && !t.isTypingExtensionsStubFile) {
              return true;
            }
          }
          return e.type === 2;
        });
      }
      function yr(e, t) {
        var n;
        const a = (n = e.getSynthesizedType()) === null || n === undefined ? undefined : n.type;
        if (a) {
          return {
            type: a
          };
        }
        let r = e.getTypedDeclarations();
        if (r.length === 0) {
          if (e.getDeclarations().length > re) {
            return {
              type: H.UnknownType.create()
            };
          } else {
            return {
              type: undefined
            };
          }
        }
        if (t && r.length > 1) {
          if (r.length > pe) {
            r = [r[r.length - 1]];
          } else {
            const e = r.filter(e => {
              if (e.type !== 8) {
                if (M.getExecutionScopeNode(t) === M.getExecutionScopeNode(e.node) && !vt(e.node, t, false)) {
                  return false;
                }
              }
              return true;
            });
            if (e.length === 0) {
              return {
                type: H.UnboundType.create()
              };
            }
            r = e;
          }
        }
        let s = r.length - 1;
        while (s >= 0) {
          const t = r[s];
          const n = Re(e, t);
          if (n) {
            return {
              type: n
            };
          }
          if (Oe(e, t) < 0 && ze(e, t)) {
            try {
              const n = ir(t);
              if (Ue(e) || t.type === 6) {
                return n;
              }
            } catch (t) {
              Ue(e);
              throw t;
            }
          }
          s--;
        }
        return {
          type: undefined
        };
      }
      function gr(e) {
        if (H.isFunction(e)) {
          hr(e);
        } else {
          if (H.isOverloaded(e)) {
            H.OverloadedType.getOverloads(e).forEach(e => {
              hr(e);
            });
            const t = H.OverloadedType.getImplementation(e);
            if (t && H.isFunction(t)) {
              hr(t);
            }
          }
        }
      }
      function hr(e, t) {
        const n = H.FunctionType.getEffectiveReturnType(e, false);
        if (n && !H.isUnknown(n)) {
          return n;
        } else {
          if (t == null ? undefined : t.skipInferReturnType) {
            return H.UnknownType.create();
          } else {
            return Xr(e, t == null ? undefined : t.callSiteInfo);
          }
        }
      }
      function fr(e) {
        const t = va(e);
        const n = t == null ? undefined : t.functionType.shared.declaredReturnType;
        if (n) {
          if (H.FunctionType.isGenerator(t.functionType)) {
            return Z.getDeclaredGeneratorReturnType(t.functionType);
          } else {
            return n;
          }
        }
      }
      function Tr(e) {
        if (H.isInstantiableClass(e.classType)) {
          return Z.partiallySpecializeType(cr(e.symbol), e.classType, dt(), undefined);
        } else {
          return H.UnknownType.create();
        }
      }
      function vr(e, t, n, a) {
        if (H.isAnyOrUnknown(t.classType)) {
          return {
            type: t.classType,
            isIncomplete: false
          };
        }
        if (!H.isInstantiableClass(t.classType)) {
          return;
        }
        const r = ur(t.symbol);
        if (r) {
          if (a & 2048 && e) {
            r.type = zt(e, r.type, !!r.includesVariableDecl);
          }
          gr(r.type);
          if (e && n && H.isClass(n) && t.isInstanceMember && H.isClass(t.unspecializedClassType) && a & 1024 && Z.requiresSpecialization(r.type, {
            ignoreSelf: true,
            ignoreImplicitTypeArgs: true
          })) {
            const a = Z.partiallySpecializeType(r.type, t.unspecializedClassType, dt(), Z.selfSpecializeClass(n, {
              overrideTypeArgs: true
            }));
            if (H.findSubtype(a, e => !H.isFunction(e) && !H.isOverloaded(e) && Z.requiresSpecialization(e, {
              ignoreSelf: true,
              ignoreImplicitTypeArgs: true
            }))) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.genericInstanceVariableAccess(), e);
            }
          }
          return {
            type: Z.partiallySpecializeType(r.type, t.classType, dt(), n),
            isIncomplete: !!r.isIncomplete
          };
        }
      }
      function br(e, t, n, a, r, s, i) {
        if (H.ClassType.isHierarchyPartiallyEvaluated(e) || H.ClassType.isHierarchyPartiallyEvaluated(t)) {
          return true;
        }
        if (H.ClassType.isTypedDictClass(t)) {
          if (H.ClassType.isTypedDictClass(e) && !H.ClassType.isSameGenericClass(e, t)) {
            return !!W.assignTypedDictToTypedDict(es, e, t, n, a, r, s) && (H.ClassType.isFinal(e) !== H.ClassType.isFinal(t) ? (n == null || n.addMessage(g.LocAddendum.typedDictFinalMismatch().format({
              sourceType: Yr(Z.convertToInstance(t)),
              destType: Yr(Z.convertToInstance(e))
            })), false) : !(r & 1) || W.assignTypedDictToTypedDict(es, t, e, undefined, undefined, r, s));
          }
          if (H.ClassType.isBuiltIn(e, 'Mapping')) {
            const e = W.getTypedDictMappingEquivalent(es, t);
            if (e && (Ae == null ? undefined : Ae.mappingClass) && H.isInstantiableClass(Ae.mappingClass) && (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass)) {
              t = H.ClassType.specialize(Ae.mappingClass, [H.ClassType.cloneAsInstance(Ae.strClass), e]);
            }
          } else {
            if (H.ClassType.isBuiltIn(e, ['dict', 'MutableMapping'])) {
              const e = W.getTypedDictDictEquivalent(es, t, s);
              if (e && (Ae == null ? undefined : Ae.dictClass) && H.isInstantiableClass(Ae.dictClass) && Ae.strClass && H.isInstantiableClass(Ae.strClass)) {
                t = H.ClassType.specialize(Ae.dictClass, [H.ClassType.cloneAsInstance(Ae.strClass), e]);
              }
            }
          }
        }
        if (e.priv.includePromotions) {
          const n = J.get(e.shared.fullName);
          if (n && n.some(e => t.shared.mro.some(t => H.isClass(t) && e === t.shared.fullName)) && !(r & 1)) {
            return true;
          }
        }
        const o = [];
        const p = H.ClassType.isDerivedFrom(t, e, o);
        if (H.ClassType.isProtocolClass(e) && !p) {
          return !!U.assignClassToProtocol(es, e, H.ClassType.cloneAsInstance(t), n == null ? undefined : n.createAddendum(), a, r, s) || (n == null || n.addMessage(g.LocAddendum.protocolIncompatible().format({
            sourceType: Yr(Z.convertToInstance(t)),
            destType: Yr(Z.convertToInstance(e))
          })), false);
        }
        if ((!(r & 1) || H.ClassType.isSameGenericClass(t, e)) && p && (l.assert(o.length > 0), function (e, t, n, a, r, s, i) {
          let o;
          let l = t;
          ya(e);
          if (s & 1) {
            if (Z.isLiteralLikeType(t) !== Z.isLiteralLikeType(e)) {
              return false;
            }
          }
          for (let t = n.length - 1; t >= 0; t--) {
            const a = n[t];
            if (H.isUnknown(a)) {
              return !Z.isNoneTypeClass(e);
            }
            if (t < n.length - 1) {
              let e = l;
              if (H.ClassType.isBuiltIn(l, 'NamedTuple') && H.ClassType.isBuiltIn(a, 'tuple') && o) {
                e = o;
              }
              l = Z.specializeForBaseClass(e, a);
            }
            if (H.ClassType.getTypeParams(a).length !== 0) {
              if (!a.priv.typeArgs) {
                return true;
              }
              o = l;
            }
          }
          if (e.priv.tupleTypeArgs && l.priv.tupleTypeArgs) {
            return q.assignTupleTypeArgs(es, e, l, a, r, s, i);
          }
          if (e.priv.typeArgs) {
            return Cr(e, l, s & 1 ? undefined : a, r, s, i);
          }
          if (r && l.priv.typeArgs) {
            const t = l.priv.typeArgs;
            for (let n = 0; n < e.shared.typeParams.length; n++) {
              let a;
              const s = e.shared.typeParams[n];
              const i = H.TypeVarType.getVariance(s);
              a = l.priv.tupleTypeArgs ? Z.convertToInstance(q.makeTupleObject(es, l.priv.tupleTypeArgs, true)) : n < t.length ? t[n] : H.UnknownType.create();
              r.setBounds(s, i !== 4 ? a : undefined, i !== 3 ? a : undefined, true);
            }
          }
          return true;
        }(e, t, o, n == null ? undefined : n.createAddendum(), a, r, s))) {
          return true;
        }
        if (H.ClassType.isBuiltIn(e, 'object') && !(r & 1)) {
          return true;
        }
        if (n) {
          const a = i ? H.ClassType.cloneAsInstance(e) : e;
          const r = i ? H.ClassType.cloneAsInstance(t) : t;
          let s = Yr(a);
          let o = Yr(r);
          if (s === o && e.shared.fullName && t.shared.fullName) {
            s = e.shared.fullName;
            o = t.shared.fullName;
          }
          if (n != null) {
            n.addMessage(g.LocAddendum.typeIncompatible().format({
              sourceType: o,
              destType: s
            }));
          }
          if (H.ClassType.isBuiltIn(e, 'bytes')) {
            const a = J.get(e.shared.fullName);
            if (a && a.some(e => e === t.shared.fullName)) {
              if (n != null) {
                n.addMessage(g.LocAddendum.bytesTypePromotions());
              }
            }
          }
        }
        return false;
      }
      function _r(e, t, n, a = true, r = 0) {
        l.assert(H.ClassType.isSameGenericClass(e, t));
        l.assert(e.shared.typeParams.length > 0);
        t = Z.makeTypeVarsBound(t, Z.getTypeVarScopeIds(t));
        e = Z.makeTypeVarsBound(e, Z.getTypeVarScopeIds(e));
        let s = true;
        try {
          ye.push({
            class: e,
            assumedVariance: n
          });
          H.ClassType.getSymbolTable(e).forEach((n, a) => {
            if (!s || n.isIgnoredForProtocolMatch()) {
              return;
            }
            if (a === '__new__' || a === '__init__') {
              return;
            }
            const i = Z.lookUpClassMember(t, a);
            l.assert(i !== undefined);
            let o = cr(n);
            const p = Tr(i);
            o = Z.partiallySpecializeType(o, e, dt());
            if (H.isClassInstance(o) && H.ClassType.isPropertyClass(o) && H.isClassInstance(p) && H.ClassType.isPropertyClass(p)) {
              if (!z.assignProperty(es, H.ClassType.cloneAsInstantiable(o), H.ClassType.cloneAsInstantiable(p), e, t, undefined, undefined, undefined, r)) {
                s = false;
              }
            } else {
              const t = n.getDeclarations()[0];
              let i = 0;
              if ((t == null ? undefined : t.type) === 1 && !Lr(t) && !Z.isMemberReadOnly(e, a) && !B.isPrivateOrProtectedName(a)) {
                i |= 1;
              }
              if (!Ir(o, p, undefined, undefined, i | 32768, r)) {
                s = false;
              }
            }
          });
          if (s) {
            e.shared.baseClasses.forEach(i => {
              if (!s || !H.isInstantiableClass(i) || H.ClassType.isBuiltIn(i, ['object', 'Protocol', 'Generic']) || i.shared.typeParams.length === 0) {
                return;
              }
              const o = Z.specializeForBaseClass(e, i);
              const l = Z.specializeForBaseClass(t, i);
              if (!a) {
                o.shared.typeParams.forEach((e, t) => {
                  if (H.isParamSpec(e) || H.isTypeVarTuple(e) || e.shared.isSynthesized) {
                    return;
                  }
                  if (!l.priv.typeArgs || t >= l.priv.typeArgs.length || !o.priv.typeArgs || t >= o.priv.typeArgs.length) {
                    return;
                  }
                  const n = e.shared.declaredVariance;
                  if (!!H.isTypeVar(l.priv.typeArgs[t]) && (n === 2 || n === 4) || !!H.isTypeVar(o.priv.typeArgs[t]) && (n === 2 || n === 3)) {
                    s = false;
                  }
                });
              }
              if (s) {
                if (!H.ClassType.isTupleClass(o) && !_r(o, l, n, a, r)) {
                  s = false;
                }
              }
            });
            return s;
          } else {
            return false;
          }
        } finally {
          ye.pop();
        }
      }
      function Cr(e, t, n, a, r, s) {
        var i;
        var o;
        var d;
        l.assert(H.ClassType.isSameGenericClass(e, t));
        ya(e);
        const c = H.ClassType.getTypeParams(e);
        let u;
        let m;
        const y = ye.find(t => H.ClassType.isSameGenericClass(t.class, e));
        const h = y == null ? undefined : y.assumedVariance;
        if (!e.priv.typeArgs || !t.priv.typeArgs) {
          return true;
        }
        if (H.ClassType.isTupleClass(e)) {
          u = (o = (i = e.priv.tupleTypeArgs) === null || i === undefined ? undefined : i.map(e => e.type)) !== null && o !== undefined ? o : [];
          m = (d = t.priv.tupleTypeArgs) === null || d === undefined ? undefined : d.map(e => e.type);
        } else {
          u = e.priv.typeArgs;
          m = t.priv.typeArgs;
        }
        let f = true;
        if (m != null) {
          m.forEach((i, o) => {
            const l = o >= u.length ? u.length - 1 : o;
            const d = l >= 0 ? u[l] : H.UnknownType.create();
            const m = l < c.length ? c[l] : undefined;
            const y = new p.DiagnosticAddendum();
            const T = h ?? (m ? H.TypeVarType.getVariance(m) : 3);
            let v;
            let b;
            let _ = true;
            if (T === 3) {
              v = r | 256;
              b = g.LocAddendum.typeVarIsCovariant;
            } else {
              if (T === 4) {
                v = r | 258;
                b = g.LocAddendum.typeVarIsContravariant;
              } else {
                v = r | 257;
                b = g.LocAddendum.typeVarIsInvariant;
                _ = false;
              }
            }
            if (H.ClassType.isBuiltIn(e, 'TypeForm')) {
              v |= 256;
            }
            if (!Ir(T === 4 ? i : d, T === 4 ? d : i, y, a, v, s) && !H.ClassType.isPseudoGenericClass(e)) {
              if (n) {
                if (m) {
                  const a = n.createAddendum();
                  a.addMessage(b().format({
                    name: H.TypeVarType.getReadableName(m),
                    ...Hr(i, d)
                  }));
                  if (_) {
                    a.addAddendum(y);
                  }
                  if (f && H.ClassType.isSameGenericClass(e, t)) {
                    if (H.ClassType.isBuiltIn(e, 'dict') && o === 1) {
                      a.addMessage(g.LocAddendum.invariantSuggestionDict());
                    } else {
                      if (H.ClassType.isBuiltIn(e, 'list')) {
                        a.addMessage(g.LocAddendum.invariantSuggestionList());
                      } else {
                        if (H.ClassType.isBuiltIn(e, 'set')) {
                          a.addMessage(g.LocAddendum.invariantSuggestionSet());
                        }
                      }
                    }
                  }
                } else {
                  n.addAddendum(y);
                }
              }
              f = false;
            }
          });
        }
        return f;
      }
      function Ir(e, t, n, a, r = 0, s = 0) {
        var i;
        var p;
        var d;
        var c;
        var u;
        var m;
        var y;
        var h;
        var f;
        var T;
        var v;
        var b;
        if (e === t && !Z.requiresSpecialization(e)) {
          return true;
        }
        const _ = (i = t.props) === null || i === undefined ? undefined : i.specialForm;
        if (_) {
          let e = false;
          if (r & 16384 && H.ClassType.isBuiltIn(_, ['Callable', 'UnionType', 'Generic'])) {
            e = true;
          }
          if (!e) {
            t = ((p = t.props) === null || p === undefined ? undefined : p.typeForm) && !((d = _.props) === null || d === undefined ? undefined : d.typeForm) ? H.TypeBase.cloneWithTypeForm(_, t.props.typeForm) : _;
          }
        }
        if (s > H.maxTypeRecursionCount) {
          return true;
        }
        s++;
        if (H.isTypeVar(e) && e.shared.recursiveAlias && H.isTypeVar(t) && t.shared.recursiveAlias) {
          const i = (c = e.props) === null || c === undefined ? undefined : c.typeAliasInfo;
          const o = (u = t.props) === null || u === undefined ? undefined : u.typeAliasInfo;
          if ((i == null ? undefined : i.typeArgs) && (o == null ? undefined : o.typeArgs) && e.shared.recursiveAlias.typeVarScopeId === t.shared.recursiveAlias.typeVarScopeId) {
            return function (e, t, n, a, r = 0, s = 0) {
              l.assert(e.typeArgs !== undefined);
              l.assert(t.typeArgs !== undefined);
              let i = true;
              const o = t.typeArgs;
              const p = e.shared.computedVariance;
              e.typeArgs.forEach((e, t) => {
                const l = t < o.length ? o[t] : H.UnknownType.create();
                let d = r;
                const c = p && t < p.length ? p[t] : 3;
                if (c === 2) {
                  d |= 1;
                } else {
                  if (c === 4) {
                    d ^= 2;
                  }
                }
                if (!Ir(e, l, n, a, d, s)) {
                  i = false;
                }
              });
              return i;
            }(i, o, n, a, r, s);
          }
          if (r & 4) {
            return true;
          }
          r |= 4;
        }
        if (H.TypeBase.isInstantiable(e) && H.TypeBase.isInstantiable(t) && (H.TypeBase.getInstantiableDepth(e) > 0 || H.TypeBase.getInstantiableDepth(t) > 0)) {
          return Ir(Z.convertToInstance(e), Z.convertToInstance(t), n, a, r, s);
        }
        const C = Z.transformPossibleRecursiveTypeAlias(e);
        const S = Z.transformPossibleRecursiveTypeAlias(t);
        if ((C !== e && H.isUnion(C) || S !== t && H.isUnion(S)) && s > le) {
          return !H.isClassInstance(t) || !H.ClassType.isBuiltIn(t, 'str') || !H.isUnion(C) || C.priv.subtypes.some(e => H.isClassInstance(e) && H.ClassType.isBuiltIn(e, ['object', 'str']));
        }
        e = C;
        t = S;
        if (H.isUnbound(e) || H.isUnbound(t)) {
          return true;
        }
        if (H.isTypeVar(e)) {
          if (Z.isTypeVarSame(e, t)) {
            return true;
          }
          if (function (e, t, n) {
            return !H.findSubtype(t, t => {
              if (H.isTypeSame(e, t, {
                ignorePseudoGeneric: true
              }, n)) {
                return false;
              }
              if (Z.isIncompleteUnknown(t)) {
                return false;
              }
              const r = H.TypeVarType.getNameWithScope(e);
              const s = (Z.getTypeCondition(t) ?? []).filter(e => e.typeVar.priv.nameWithScope === r);
              return s.length === 0 || !s.some(a => a.typeVar.priv.nameWithScope === H.TypeVarType.getNameWithScope(e) && (e.shared.boundType ? (l.assert(a.constraintIndex === 0, 'Expected constraint for bound TypeVar to have index of 0'), Ir(e.shared.boundType, t, undefined, undefined, 0, n)) : !H.TypeVarType.hasConstraints(e) || (l.assert(a.constraintIndex < e.shared.constraints.length, 'Constraint for constrained TypeVar is out of bounds'), Ir(e.shared.constraints[a.constraintIndex], t, undefined, undefined, 0, n))));
            });
          }(e, t, s)) {
            return true;
          }
          const i = e;
          if (H.TypeBase.isInstantiable(e) === H.TypeBase.isInstantiable(t) && ((m = t.props) === null || m === undefined ? undefined : m.condition) && t.props.condition.some(e => !H.TypeVarType.hasConstraints(e.typeVar) && e.typeVar.priv.nameWithScope === i.priv.nameWithScope)) {
            return true;
          }
          if (H.isUnion(t)) {
            const n = H.removeFromUnion(t, e => H.isAnyOrUnknown(e));
            if (H.isTypeSame(e, n)) {
              return true;
            }
          }
          if (H.isTypeVar(t) && H.TypeVarType.isSelf(t) && H.TypeVarType.hasBound(t) && H.TypeVarType.isSelf(e) && H.TypeVarType.hasBound(e) && H.TypeVarType.isBound(e) === H.TypeVarType.isBound(t) && H.TypeBase.isInstance(t) === H.TypeBase.isInstance(e)) {
            if (!(r & 2) && !!a) {
              I.assignTypeVar(es, e, t, n, a, r, s);
            }
            return true;
          }
          if (H.isTypeVarTuple(e) && H.isClassInstance(t) && Z.isTupleClass(t) && t.priv.tupleTypeArgs && t.priv.tupleTypeArgs.length === 1 && H.isTypeSame(e, t.priv.tupleTypeArgs[0].type, {}, s)) {
            return true;
          }
          if (!(r & 2) || !H.isTypeVar(t)) {
            return !!I.assignTypeVar(es, e, t, n, a, r, s) && (!H.isAnyOrUnknown(t) || !(r & 16));
          }
        }
        if (H.isTypeVar(t)) {
          if (r & 2) {
            if (H.TypeVarType.isBound(t)) {
              return Ir(Pt(e), Pt(t), n, undefined, r, s);
            }
            if (I.assignTypeVar(es, t, e, n, a, r, s)) {
              return true;
            }
            let i = false;
            if (H.isUnion(e)) {
              Z.doForEachSubtype(e, e => {
                if (I.assignTypeVar(es, t, e, n, a, r, s)) {
                  i = true;
                }
              });
            }
            return i;
          }
          if (r & 1) {
            if (H.isAnyOrUnknown(e)) {
              return true;
            }
            if (H.isParamSpec(t) && H.isFunction(e) && H.FunctionType.isGradualCallableForm(e) && e.shared.parameters.length <= 2) {
              return true;
            }
            if (H.isUnpackedTypeVarTuple(t) && H.isClassInstance(e) && H.isUnpackedClass(e) && e.priv.tupleTypeArgs && e.priv.tupleTypeArgs.length === 1 && e.priv.tupleTypeArgs[0].isUnbounded && H.isAnyOrUnknown(e.priv.tupleTypeArgs[0].type)) {
              return true;
            }
            if (!H.isUnion(e)) {
              if (n != null) {
                n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e)));
              }
              return false;
            }
          }
        }
        if (H.isAnyOrUnknown(e)) {
          return true;
        }
        if (H.isAnyOrUnknown(t) && !((y = t.props) === null || y === undefined ? undefined : y.specialForm)) {
          if (a) {
            const n = Z.isEllipsisType(t) ? H.AnyType.create() : t;
            Sr(e, n, a);
          }
          if (!(r & 16)) {
            return true;
          }
        }
        if (H.isNever(t)) {
          if (r & 1) {
            return !!H.isNever(e) || (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false);
          } else {
            if (a) {
              Sr(e, H.UnknownType.create(), a);
            }
            return true;
          }
        }
        if (H.isUnion(e)) {
          if (H.isUnion(t)) {
            return kr(e, t, n, a, r, s);
          }
          const i = a == null ? undefined : a.clone();
          if (Pr(e, t, undefined, i, r, s)) {
            if (a && i) {
              a.copyFromClone(i);
            }
            return true;
          }
        }
        const A = Pt(t);
        if (H.isUnion(A)) {
          return kr(e, A, n, a, r, s);
        }
        if (H.isUnion(e)) {
          return Pr(e, t, n, a, r, s);
        }
        if (H.isClassInstance(A) && H.ClassType.isBuiltIn(A, 'type')) {
          const i = A.priv.typeArgs;
          let o;
          o = i && i.length >= 1 ? i[0] : H.UnknownType.create();
          if (H.isAnyOrUnknown(o)) {
            if (Z.isEffectivelyInstantiable(e)) {
              return true;
            }
          } else {
            if (H.isClassInstance(o) || H.isTypeVar(o)) {
              return !!Ir(e, Z.convertToInstantiable(o), n == null ? undefined : n.createAddendum(), a, r, s) || (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false);
            }
          }
        }
        if (H.isInstantiableClass(e)) {
          if (H.isInstantiableClass(A)) {
            if (H.ClassType.isProtocolClass(e) && !(r & 65536) && H.ClassType.isProtocolClass(A) && H.isInstantiableClass(t) && !t.priv.includeSubclasses) {
              if (n != null) {
                n.addMessage(g.LocAddendum.protocolSourceIsNotConcrete().format({
                  sourceType: Yr(Z.convertToInstance(t)),
                  destType: Yr(e)
                }));
              }
              return false;
            }
            if (H.ClassType.isBuiltIn(e, 'type') && ((f = (h = t.props) === null || h === undefined ? undefined : h.instantiableDepth) !== null && f !== undefined ? f : 0) > 0) {
              return true;
            }
            if (wr(A, r)) {
              const t = (v = (T = e.props) === null || T === undefined ? undefined : T.specialForm) !== null && v !== undefined ? v : e;
              if (wr(t, r)) {
                return Ir(t, A, n, a, r, s);
              }
            } else {
              if (br(e, A, n, a, r, s, false)) {
                return true;
              }
            }
            if (n != null) {
              n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e)));
            }
            return false;
          }
          if (H.isClassInstance(A) && Z.isMetaclassInstance(A)) {
            const i = e.shared.effectiveMetaclass;
            if (i && H.isInstantiableClass(i)) {
              return !!br(i, H.ClassType.cloneAsInstantiable(A), n, a, r, s, false) || (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false);
            }
          }
        }
        if (H.isClassInstance(e)) {
          if (H.ClassType.isBuiltIn(e, 'type')) {
            if (H.isInstantiableClass(t) && wr(t, r) && H.TypeBase.getInstantiableDepth(t) === 0) {
              return false;
            }
            if (H.isAnyOrUnknown(t) && r & 16) {
              return false;
            }
            const i = e.priv.typeArgs;
            if (i && i.length >= 1 && H.TypeBase.isInstance(i[0]) && H.TypeBase.isInstantiable(t)) {
              return Ir(i[0], Z.convertToInstance(t), n, a, r, s);
            }
            if (H.TypeBase.isInstantiable(t)) {
              return !H.isClass(t) || t.priv.literalValue === undefined;
            }
          }
          let i = Pt(t);
          if (H.isClass(i) && H.TypeBase.isInstance(i)) {
            if (!e.priv.isUnpacked && i.priv.isUnpacked && i.priv.tupleTypeArgs) {
              return Ir(e, Z.combineTupleTypeArgs(i.priv.tupleTypeArgs), n, a, r, s);
            }
            if (H.ClassType.isEnumClass(i) && i.priv.literalValue instanceof H.EnumLiteral && i.shared.mro.some(e => H.isClass(e) && H.ClassType.isBuiltIn(e, ['int', 'str', 'bytes'])) && H.isClassInstance(i.priv.literalValue.itemType) && Z.isLiteralType(i.priv.literalValue.itemType) && Ir(e, i.priv.literalValue.itemType)) {
              return true;
            }
            if (e.priv.literalValue !== undefined && H.ClassType.isSameGenericClass(e, i)) {
              if (i.priv.literalValue === undefined || !H.ClassType.isLiteralValueSame(i, e)) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.literalAssignmentMismatch().format({
                    sourceType: Yr(t),
                    destType: Yr(e)
                  }));
                }
                return false;
              }
            }
            if (H.ClassType.isBuiltIn(e, 'LiteralString')) {
              if (H.ClassType.isBuiltIn(i, 'str') && i.priv.literalValue !== undefined) {
                return !(r & 1);
              }
              if (H.ClassType.isBuiltIn(i, 'LiteralString')) {
                return true;
              }
            } else {
              if (H.ClassType.isBuiltIn(i, 'LiteralString') && (Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass) && !(r & 1)) {
                i = H.ClassType.cloneAsInstance(Ae.strClass);
              }
            }
            return !!br(H.ClassType.cloneAsInstantiable(e), H.ClassType.cloneAsInstantiable(i), n, a, r, s, true);
          }
          if (H.isFunction(i) || H.isOverloaded(i)) {
            const t = Dr(e, s);
            if (t) {
              return Ir(t, i, n, a, r, s);
            }
            if (Ae == null ? undefined : Ae.functionClass) {
              return Ir(e, Z.convertToInstance(Ae.functionClass), n, a, r, s);
            }
          } else {
            if (H.isModule(i)) {
              if (H.ClassType.isBuiltIn(e, 'ModuleType')) {
                return true;
              }
              if (H.ClassType.isProtocolClass(e)) {
                return U.assignModuleToProtocol(es, H.ClassType.cloneAsInstantiable(e), i, n, a, r, s);
              }
            } else {
              if (H.isInstantiableClass(i)) {
                const t = Dr(e, s);
                if (t) {
                  return Ir(t, i, n, a, r, s);
                }
                if (H.ClassType.isProtocolClass(e)) {
                  return U.assignClassToProtocol(es, H.ClassType.cloneAsInstantiable(e), i, n, a, r, s);
                }
                const o = i.shared.effectiveMetaclass;
                if (o) {
                  if (H.isAnyOrUnknown(o)) {
                    return true;
                  }
                  if (br(H.ClassType.cloneAsInstantiable(e), o, undefined, a, r, s, true)) {
                    return true;
                  }
                }
              } else {
                if (H.isAnyOrUnknown(i) && !((b = i.props) === null || b === undefined ? undefined : b.specialForm)) {
                  return !(r & 16);
                }
                if (H.isUnion(i)) {
                  return Ir(e, i, n, a, r, s);
                }
              }
            }
          }
        }
        if (H.isFunction(e)) {
          let i = Pt(t);
          if (H.isClassInstance(i)) {
            const e = tt(i, '__call__', undefined, undefined, s);
            if (e) {
              i = e;
            }
          }
          if (H.isInstantiableClass(i) && i.priv.literalValue === undefined) {
            const o = w.createFunctionFromConstructor(es, i, H.isTypeVar(t) ? Z.convertToInstance(t) : undefined, s);
            if (o && (i = o, H.isUnion(i))) {
              return Ir(e, i, n, a, r, s);
            }
          }
          if (H.isAnyOrUnknown(i)) {
            return !(r & 16);
          }
          if (H.isOverloaded(i)) {
            if (r & 8) {
              return true;
            }
            const t = H.OverloadedType.getOverloads(i);
            const l = [];
            const p = [];
            t.forEach(t => {
              var n;
              const i = (n = Z.getTypeVarScopeId(t)) !== null && n !== undefined ? n : '';
              const d = a == null ? undefined : a.cloneWithSignature(i);
              if (Ir(e, t, undefined, d, r, s)) {
                l.push(t);
                if (d) {
                  o.appendArray(p, d.getConstraintSets());
                }
              }
            });
            if (l.length === 0) {
              if (n != null) {
                n.addMessage(g.LocAddendum.noOverloadAssignable().format({
                  type: Yr(e)
                }));
              }
              return false;
            } else {
              if (l.length === 1 || !(r & 8)) {
                if (a) {
                  a.addConstraintSets(p);
                }
              }
              return true;
            }
          }
          if (H.isFunction(i) && function (e, t, n, a, r, s) {
            var i;
            var p;
            var d;
            var c;
            var u;
            var m;
            var y;
            var h;
            let f = true;
            const T = !(r & 64);
            const v = !!(r & 2);
            r &= -65;
            const b = H.FunctionType.getParamSpecFromArgsKwargs(e);
            if (b) {
              e = H.FunctionType.cloneRemoveParamSpecArgsKwargs(e);
            }
            const _ = H.FunctionType.getParamSpecFromArgsKwargs(t);
            if (_) {
              t = H.FunctionType.cloneRemoveParamSpecArgsKwargs(t);
            }
            const C = E.getParamListDetails(e);
            const I = E.getParamListDetails(t);
            (function (e, t) {
              var n;
              if (t.argsIndex === undefined) {
                return;
              }
              if (!H.isUnpacked(t.params[t.argsIndex].type)) {
                return;
              }
              if (e.params.length < t.argsIndex) {
                return;
              }
              let a = e.params.findIndex((e, n) => {
                l.assert(t.argsIndex !== undefined);
                return n >= t.argsIndex && e.kind === E.ParamKind.Keyword;
              });
              if (a < 0) {
                a = e.params.length;
              }
              if (e.argsIndex !== undefined && t.argsIndex > e.argsIndex) {
                return;
              }
              const r = (n = t.firstKeywordOnlyIndex) !== null && n !== undefined ? n : t.params.length;
              const s = r - t.argsIndex - 1;
              const i = e.params.slice(t.argsIndex, a - s);
              const p = [];
              i.forEach(e => {
                if (e.param.category === 1) {
                  if (H.isUnpackedTypeVarTuple(e.type)) {
                    p.push({
                      type: e.type,
                      isUnbounded: false
                    });
                  } else {
                    if (H.isUnpackedClass(e.type) && e.type.priv.tupleTypeArgs) {
                      o.appendArray(p, e.type.priv.tupleTypeArgs);
                    } else {
                      p.push({
                        type: e.type,
                        isUnbounded: true
                      });
                    }
                  }
                } else {
                  p.push({
                    type: e.type,
                    isUnbounded: false,
                    isOptional: !!e.defaultType
                  });
                }
              });
              if (p.length !== 1 || !H.isTypeVarTuple(p[0].type)) {
                const n = q.makeTupleObject(es, p, true);
                e.params = [...e.params.slice(0, t.argsIndex), {
                  param: H.FunctionParam.create(1, n, H.FunctionParamFlags.NameSynthesized | H.FunctionParamFlags.TypeDeclared, '_arg_combined'),
                  type: n,
                  declaredType: n,
                  index: -1,
                  kind: E.ParamKind.Positional
                }, ...e.params.slice(t.argsIndex + i.length, e.params.length)];
                const a = e.params.findIndex(e => e.param.category === 1);
                e.argsIndex = a >= 0 ? a : undefined;
                const r = e.params.findIndex(e => e.param.category === 2);
                e.kwargsIndex = r >= 0 ? r : undefined;
                const s = e.params.findIndex(e => e.kind === E.ParamKind.Keyword);
                e.firstKeywordOnlyIndex = s >= 0 ? s : undefined;
                e.positionOnlyParamCount = Math.max(0, e.params.findIndex(e => e.kind !== E.ParamKind.Positional || e.param.category !== 0 || !!e.defaultType));
              }
            })(v ? C : I, v ? I : C);
            const k = v ? !!_ : !!b;
            const w = (i = C.firstKeywordOnlyIndex) !== null && i !== undefined ? i : C.params.length;
            const S = (p = I.firstKeywordOnlyIndex) !== null && p !== undefined ? p : I.params.length;
            const A = Math.min(w, S);
            for (let i = 0; i < A; i++) {
              if (i === 0 && e.shared.methodClass && r & 32768 && (H.FunctionType.isInstanceMethod(e) || H.FunctionType.isClassMethod(e))) {
                continue;
              }
              if (i === C.argsIndex) {
                continue;
              }
              const o = C.params[i];
              const l = I.params[i];
              const p = l.type;
              const m = o.type;
              const y = (d = o.param.name) !== null && d !== undefined ? d : '';
              const h = (c = l.param.name) !== null && c !== undefined ? c : '';
              if (y) {
                if (o.kind !== E.ParamKind.Positional && o.kind !== E.ParamKind.ExpandedArgs && o.param.category !== 1 && l.param.category !== 1) {
                  if (l.kind === E.ParamKind.Positional || l.kind === E.ParamKind.ExpandedArgs) {
                    if (n != null) {
                      n.createAddendum().addMessage(g.LocAddendum.functionParamPositionOnly().format({
                        name: y
                      }));
                    }
                    f = false;
                  } else {
                    if (y !== h) {
                      if (n != null) {
                        n.createAddendum().addMessage(g.LocAddendum.functionParamName().format({
                          srcName: h,
                          destName: y
                        }));
                      }
                      f = false;
                    }
                  }
                }
              }
              if (!o.defaultType || !(l.defaultType || i === I.argsIndex || (n == null || n.createAddendum().addMessage(g.LocAddendum.functionParamDefaultMissing().format({
                name: h
              })), f = false), r & 32 && l.defaultType)) {
                if (i !== 0 || t.shared.name !== '__init__' || !H.FunctionType.isInstanceMethod(t) || e.shared.name !== '__init__' || !H.FunctionType.isInstanceMethod(e) || !H.FunctionType.isOverloaded(e) || !H.FunctionParam.isTypeDeclared(o.param)) {
                  if (H.isUnpacked(p)) {
                    f = false;
                  } else {
                    if (Nr(m, p, i, n == null ? undefined : n.createAddendum(), a, r, s)) {
                      if (o.kind !== E.ParamKind.Positional && o.kind !== E.ParamKind.ExpandedArgs && l.kind === E.ParamKind.Positional && I.kwargsIndex === undefined && !I.params.some(e => e.kind === E.ParamKind.Keyword && e.param.category === 0 && e.param.name === o.param.name)) {
                        if (n != null) {
                          n.addMessage(g.LocAddendum.namedParamMissingInSource().format({
                            name: (u = o.param.name) !== null && u !== undefined ? u : ''
                          }));
                        }
                        f = false;
                      }
                    } else {
                      if (!(r & 512) || !H.isTypeVar(p) || !p.shared.isSynthesized) {
                        f = false;
                      }
                    }
                  }
                }
              }
            }
            if (!H.FunctionType.isGradualCallableForm(e) && C.firstPositionOrKeywordIndex < I.positionOnlyParamCount && !k) {
              if (n != null) {
                n.createAddendum().addMessage(g.LocAddendum.argsPositionOnly().format({
                  expected: I.positionOnlyParamCount,
                  received: C.firstPositionOrKeywordIndex
                }));
              }
              f = false;
            }
            if (w < S && !k) {
              for (let e = w; e < S; e++) {
                if (C.argsIndex !== undefined) {
                  if (!Nr(C.params[C.argsIndex].type, I.params[e].type, e, n == null ? undefined : n.createAddendum(), a, r, s)) {
                    f = false;
                  }
                  continue;
                }
                const t = I.params[e];
                if (t.defaultType) {
                  const t = I.params[e];
                  const i = (m = t.defaultType) !== null && m !== undefined ? m : t.defaultType;
                  if (i && !Ir(t.type, i, n == null ? undefined : n.createAddendum(), a, r, s)) {
                    if (!(r & 32)) {
                      f = false;
                    }
                  }
                  continue;
                }
                if (t.kind === E.ParamKind.Standard) {
                  continue;
                }
                if (t.param.category === 1) {
                  continue;
                }
                const i = I.params.filter(e => !!e.param.name && !e.defaultType && e.param.category === 0).length;
                if (n != null) {
                  n.createAddendum().addMessage(g.LocAddendum.functionTooFewParams().format({
                    expected: i,
                    received: w
                  }));
                }
                f = false;
                break;
              }
            } else {
              if (S < w) {
                if (I.argsIndex !== undefined) {
                  const e = I.params[I.argsIndex].type;
                  for (let t = S; t < w; t++) {
                    if (t === I.argsIndex) {
                      continue;
                    }
                    const i = C.params[t].type;
                    if (H.isTypeVarTuple(i) && !H.isTypeVarTuple(e)) {
                      if (n != null) {
                        n.addMessage(g.LocAddendum.typeVarTupleRequiresKnownLength());
                      }
                      f = false;
                    } else {
                      if (!Nr(i, e, t, n == null ? undefined : n.createAddendum(), a, r, s)) {
                        f = false;
                      }
                      const o = C.params[t].kind;
                      if (o !== E.ParamKind.Positional && o !== E.ParamKind.ExpandedArgs && I.kwargsIndex === undefined) {
                        if (n != null) {
                          n.addMessage(g.LocAddendum.namedParamMissingInSource().format({
                            name: (y = C.params[t].param.name) !== null && y !== undefined ? y : ''
                          }));
                        }
                        f = false;
                      }
                    }
                  }
                } else {
                  if (!I.paramSpec) {
                    let e = w;
                    if (C.argsIndex !== undefined && C.argsIndex < w) {
                      e--;
                    }
                    if (r & 32) {
                      while (e > 0 && C.params[e - 1].defaultType) {
                        e--;
                      }
                    }
                    if (S < e) {
                      if (n != null) {
                        n.addMessage(g.LocAddendum.functionTooManyParams().format({
                          expected: S,
                          received: w
                        }));
                      }
                      f = false;
                    }
                  }
                }
              }
            }
            if (I.argsIndex !== undefined && C.argsIndex !== undefined && !H.FunctionType.isGradualCallableForm(e)) {
              let e = C.params[C.argsIndex].type;
              let t = I.params[I.argsIndex].type;
              if (!H.isUnpacked(e)) {
                e = q.makeTupleObject(es, [{
                  type: e,
                  isUnbounded: true
                }], true);
              }
              if (!H.isUnpacked(t)) {
                t = q.makeTupleObject(es, [{
                  type: t,
                  isUnbounded: true
                }], true);
              }
              if (!Nr(e, t, C.params[C.argsIndex].index, n == null ? undefined : n.createAddendum(), a, r, s)) {
                f = false;
              }
            }
            if (!H.FunctionType.isGradualCallableForm(e) && I.argsIndex === undefined && _ === undefined && C.argsIndex !== undefined && !C.hasUnpackedTypeVarTuple) {
              if (n != null) {
                n.createAddendum().addMessage(g.LocAddendum.argsParamMissing().format({
                  paramName: (h = C.params[C.argsIndex].param.name) !== null && h !== undefined ? h : ''
                }));
              }
              f = false;
            }
            if (!k) {
              const t = new Map();
              if (C.firstKeywordOnlyIndex !== undefined) {
                C.params.forEach((e, n) => {
                  if (n >= C.firstKeywordOnlyIndex && e.param.name && e.param.category === 0 && e.kind !== E.ParamKind.Positional && e.kind !== E.ParamKind.ExpandedArgs) {
                    t.set(e.param.name, e);
                  }
                });
              }
              let i = I.firstKeywordOnlyIndex !== undefined ? I.firstKeywordOnlyIndex : I.params.length;
              if (w < S && C.argsIndex === undefined) {
                i = w;
              }
              if (i >= 0) {
                I.params.forEach((e, o) => {
                  var l;
                  if (o >= i && e.param.name && e.param.category === 0 && e.kind !== E.ParamKind.Positional) {
                    const i = t.get(e.param.name);
                    const o = n == null ? undefined : n.createAddendum();
                    const p = e.type;
                    if (i) {
                      const l = i.type;
                      const d = a ? Xe(l, a) : l;
                      if (!Nr(i.type, p, undefined, o == null ? undefined : o.createAddendum(), a, r, s)) {
                        if (o) {
                          o.addMessage(g.LocAddendum.namedParamTypeMismatch().format({
                            name: e.param.name,
                            sourceType: Yr(d),
                            destType: Yr(p)
                          }));
                        }
                        f = false;
                      }
                      if (i.defaultType && !e.defaultType) {
                        if (n != null) {
                          n.createAddendum().addMessage(g.LocAddendum.functionParamDefaultMissing().format({
                            name: e.param.name
                          }));
                        }
                        f = false;
                      }
                      t.delete(e.param.name);
                    } else {
                      if (C.kwargsIndex !== undefined || e.defaultType) {
                        if (C.kwargsIndex !== undefined) {
                          if (!Nr(C.params[C.kwargsIndex].type, p, C.params[C.kwargsIndex].index, n == null ? undefined : n.createAddendum(), a, r, s)) {
                            f = false;
                          }
                        } else {
                          if (e.defaultType) {
                            const t = (l = e.defaultType) !== null && l !== undefined ? l : e.defaultType;
                            if (t && !Ir(e.type, t, n == null ? undefined : n.createAddendum(), a, r, s)) {
                              if (!(r & 32)) {
                                f = false;
                              }
                            }
                          }
                        }
                      } else {
                        if (o) {
                          o.addMessage(g.LocAddendum.namedParamMissingInDest().format({
                            name: e.param.name
                          }));
                        }
                        f = false;
                      }
                    }
                  }
                });
              }
              t.forEach((e, i) => {
                if (I.kwargsIndex !== undefined && e.param.name) {
                  if (!Nr(e.type, I.params[I.kwargsIndex].type, e.index, n == null ? undefined : n.createAddendum(), a, r, s)) {
                    f = false;
                  }
                  t.delete(i);
                } else {
                  if (n != null) {
                    n.createAddendum().addMessage(g.LocAddendum.namedParamMissingInSource().format({
                      name: i
                    }));
                  }
                  f = false;
                }
              });
              if (I.kwargsIndex !== undefined && C.kwargsIndex !== undefined) {
                if (!Nr(C.params[C.kwargsIndex].type, I.params[I.kwargsIndex].type, C.params[C.kwargsIndex].index, n == null ? undefined : n.createAddendum(), a, r, s)) {
                  f = false;
                }
              }
              if (!H.FunctionType.isGradualCallableForm(e) && I.kwargsIndex === undefined && _ === undefined && C.kwargsIndex !== undefined) {
                if (n != null) {
                  n.createAddendum().addMessage(g.LocAddendum.kwargsParamMissing().format({
                    paramName: C.params[C.kwargsIndex].param.name
                  }));
                }
                f = false;
              }
            }
            if (k && (_ == null ? undefined : _.priv.nameWithScope) === (b == null ? undefined : b.priv.nameWithScope) && I.params.length !== C.params.length) {
              f = false;
            }
            if (k) {
              const n = v ? e : t;
              const s = v ? t : e;
              const i = v ? b : _;
              const o = v ? _ : b;
              if (o) {
                const e = s.shared.parameters.filter((e, t) => {
                  if (!e.name) {
                    return false;
                  }
                  const n = H.FunctionType.getParamType(s, t);
                  return e.category !== 0 || !H.isParamSpec(n);
                }).length;
                let t = 0;
                const l = [];
                n.shared.parameters.forEach((a, r) => {
                  if (t < e) {
                    if (a.name) {
                      t++;
                    }
                  } else {
                    if (!H.isPositionOnlySeparator(a) || l.length !== 0) {
                      l.push(H.FunctionParam.create(a.category, H.FunctionType.getParamType(n, r), a.flags, a.name, H.FunctionType.getParamDefaultType(n, r), a.defaultExpr));
                    }
                  }
                });
                if (l.length > 0 || !i || !H.isTypeSame(i, o, {
                  ignoreTypeFlags: true
                })) {
                  const e = H.FunctionType.createInstance('', '', '', n.shared.flags | 64, n.shared.docString);
                  e.shared.deprecatedMessage = n.shared.deprecatedMessage;
                  e.shared.typeVarScopeId = n.shared.typeVarScopeId;
                  e.priv.constructorTypeVarScopeId = n.priv.constructorTypeVarScopeId;
                  e.shared.methodClass = n.shared.methodClass;
                  l.forEach(t => {
                    H.FunctionType.addParam(e, t);
                  });
                  if (i) {
                    H.FunctionType.addParamSpecVariadics(e, Z.convertToInstance(i));
                  }
                  if (!Ir(o, e, undefined, a, r)) {
                    if (l.length > 0 || !i || !Ir(Z.convertToInstance(o), Z.convertToInstance(i), undefined, a, r)) {
                      f = false;
                    }
                  }
                }
              }
            }
            if (T) {
              const i = hr(e);
              if (!H.isAnyOrUnknown(i)) {
                const e = Xe(hr(t), a);
                const o = n == null ? undefined : n.createAddendum();
                let l = false;
                let p = r;
                if (t.shared.declaredReturnType && Z.containsLiteralType(t.shared.declaredReturnType, true)) {
                  p |= 256;
                }
                if (Ir(i, e, o == null ? undefined : o.createAddendum(), a, p, s) || H.isClassInstance(e) && H.ClassType.isBuiltIn(e, ['TypeGuard', 'TypeIs']) && (Ae == null ? undefined : Ae.boolClass) && H.isInstantiableClass(Ae.boolClass) && Ir(i, H.ClassType.cloneAsInstance(Ae.boolClass), o == null ? undefined : o.createAddendum(), a, r, s)) {
                  l = true;
                }
                if (!l) {
                  if (o) {
                    o.addMessage(g.LocAddendum.functionReturnTypeMismatch().format({
                      sourceType: Yr(e),
                      destType: Yr(i)
                    }));
                  }
                  f = false;
                }
              }
            }
            return f;
          }(e, i, n == null ? undefined : n.createAddendum(), a ?? new k.ConstraintTracker(), r, s)) {
            return true;
          }
        }
        if (H.isOverloaded(e)) {
          const i = n == null ? undefined : n.createAddendum();
          const o = H.OverloadedType.getOverloads(e);
          if (H.isOverloaded(t)) {
            const e = H.OverloadedType.getOverloads(t);
            if (o.length === e.length && o.every((t, n) => Ir(t, e[n], undefined, a, r, s))) {
              return true;
            }
          }
          if (!o.every(e => Ir(e, t, i == null ? undefined : i.createAddendum(), a, r, s))) {
            const t = H.OverloadedType.getOverloads(e);
            if (i && t.length > 0) {
              i.addMessage(g.LocAddendum.overloadNotAssignable().format({
                name: t[0].shared.name
              }));
            }
            return false;
          }
          return true;
        }
        return !!H.isClass(e) && !!H.ClassType.isBuiltIn(e, 'object') && (!!H.isInstantiableClass(e) && !!H.TypeBase.isInstantiable(t) || !!H.isClassInstance(e)) && !(r & 1) || (Z.isNoneInstance(t) && H.isClassInstance(e) && H.ClassType.isProtocolClass(e) && (Ae == null ? undefined : Ae.noneTypeClass) && H.isInstantiableClass(Ae.noneTypeClass) ? U.assignClassToProtocol(es, H.ClassType.cloneAsInstantiable(e), H.ClassType.cloneAsInstance(Ae.noneTypeClass), n, a, r, s) : Z.isNoneInstance(e) ? (n == null || n.addMessage(g.LocAddendum.assignToNone()), false) : (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false));
      }
      function kr(e, t, n, a, r, s) {
        if (H.isTypeSame(t, e, {}, s)) {
          return true;
        }
        let i = Z.sortTypes(t.priv.subtypes);
        let o = false;
        if (H.isUnion(e)) {
          const l = e.priv.subtypes.filter(e => !H.isAnyOrUnknown(e));
          if (l.length === 1 && H.isTypeVar(l[0])) {
            Ir(l[0], t, undefined, a, r, s);
            return true;
          }
          const p = [];
          let d = i;
          let c = true;
          Z.sortTypes(e.priv.subtypes).forEach(e => {
            if (Z.requiresSpecialization(e)) {
              p.push(e);
            } else {
              const t = d.findIndex(t => H.isTypeSame(t, e, {}, s));
              if (t >= 0) {
                d.splice(t, 1);
                o = true;
              } else {
                p.push(e);
              }
            }
          });
          d.forEach(e => {
            const t = p.findIndex(t => {
              if (H.isTypeSame(t, e)) {
                return true;
              }
              if (H.isClass(e) && H.isClass(t) && H.TypeBase.isInstance(e) === H.TypeBase.isInstance(t)) {
                if (H.ClassType.isSameGenericClass(e, t)) {
                  return true;
                }
                if (H.ClassType.isTypedDictClass(e) && H.ClassType.isTypedDictClass(t) && Ir(e, t, undefined, undefined, r, s)) {
                  return true;
                }
              }
              return (!!H.isFunction(e) || !!H.isOverloaded(e)) && (!!H.isFunction(t) || !!H.isOverloaded(t));
            });
            if (t >= 0) {
              if (Ir(p[t], e, undefined, a, r, s)) {
                o = true;
              } else {
                c = false;
              }
              p.splice(t, 1);
              d = d.filter(t => t !== e);
            }
          });
          if (c && (p.length !== 0 || d.length !== 0)) {
            if (r & 1 && d.length === 0) {
              return p.every(t => Ar(t, e, true, s));
            }
            const o = !!(r & 2);
            const l = o ? d : p;
            if (l.length === 0 || l.some(e => !H.isTypeVar(e))) {
              c = false;
              i = d;
            } else {
              if (p.length === d.length) {
                const e = [...p];
                for (let t = 0; t < d.length; t++) {
                  let i = false;
                  for (let o = 0; o < e.length; o++) {
                    if (Ir(e[o], d[t], n == null ? undefined : n.createAddendum(), a, r, s)) {
                      i = true;
                      e.push(...e.splice(o, 1));
                      break;
                    }
                  }
                  if (!i) {
                    c = false;
                    break;
                  }
                }
                i = d;
              } else {
                if (d.length === 0) {
                  if (r & 2048) {
                    p.forEach(e => {
                      Ir(e, t, undefined, a, r, s);
                    });
                  }
                } else {
                  if (!Ir(o ? e : p[0], o ? d[0] : H.combineTypes(d), n == null ? undefined : n.createAddendum(), a, r, s)) {
                    c = false;
                  }
                }
              }
            }
          }
          if (c) {
            return true;
          }
          if (r & 32 && o) {
            return true;
          }
        }
        let l = false;
        i.forEach(i => {
          if (!l) {
            if (Ir(e, i, undefined, a, r, s)) {
              o = true;
            } else {
              if (!Ar(i, t, false, s) && !Ir(e, i, n == null ? undefined : n.createAddendum(), a, r, s)) {
                l = true;
              }
            }
          }
        }, true);
        return !l || !!(r & 32) && !!o || (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false);
      }
      function wr(e, t) {
        return !(t & 16384) && H.ClassType.isSpecialFormClass(e);
      }
      function Sr(e, t, n) {
        Z.getTypeVarArgsRecursive(e).forEach(e => {
          if (!H.TypeVarType.isBound(e) && !n.getMainConstraintSet().getTypeVar(e) && !H.isParamSpec(t) && !H.isTypeVarTuple(t)) {
            n.setBounds(e, t);
          }
        });
      }
      function Ar(e, t, n, a = 0) {
        const r = Pt(e);
        const s = H.isUnion(t) ? t.priv.subtypes : [t];
        for (const t of s) {
          if (!H.isTypeSame(t, e)) {
            if (H.isAnyOrUnknown(t)) {
              if (n) {
                return true;
              }
            } else {
              if (xr(t, r, a)) {
                return true;
              }
            }
          }
        }
        return false;
      }
      function xr(e, t, n) {
        var a;
        return !((a = e.props) === null || a === undefined ? undefined : a.condition) && (!!H.isAnyOrUnknown(e) || !!H.isAnyOrUnknown(t) || !!H.isClass(e) && !!e.shared.mro.some(e => H.isAnyOrUnknown(e)) || !!H.isClass(t) && !!t.shared.mro.some(e => H.isAnyOrUnknown(e)) || Ir(e, t, undefined, undefined, 0, n) && !Ir(t, e, undefined, undefined, 0, n));
      }
      function Pr(e, t, n, a, r, s) {
        if (r & 1) {
          let i = false;
          Z.doForEachSubtype(e, (o, l) => {
            if (!i && !Ir(o, t, n == null ? undefined : n.createAddendum(), a, r, s)) {
              let t = false;
              if (!H.isAnyOrUnknown(o)) {
                const n = Z.makeTypeVarsBound(o, undefined);
                Z.doForEachSubtype(e, (e, a) => {
                  if (l !== a && !t) {
                    if (Ir(Z.makeTypeVarsBound(e, undefined), n, undefined, undefined, 0, s)) {
                      t = true;
                    }
                  }
                });
              }
              if (!t) {
                i = true;
              }
            }
          });
          return !i || (n == null || n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), false);
        }
        const i = n ? new p.DiagnosticAddendum() : undefined;
        let o = false;
        if (Z.requiresSpecialization(e)) {
          if (Z.isNoneInstance(t) && Z.isOptionalType(e)) {
            o = true;
          } else {
            let n;
            let l;
            let p = 0;
            if (H.isClassInstance(t) && Z.isLiteralType(t) && H.UnionType.containsType(e, t, undefined, undefined, s)) {
              return true;
            }
            Z.doForEachSubtype(e, e => {
              const d = a == null ? undefined : a.clone();
              if (Ir(e, t, i == null ? undefined : i.createAddendum(), d, r, s) && (o = true, d)) {
                let r = d.getScore();
                if (H.isTypeVar(e)) {
                  if (!(a == null ? undefined : a.getMainConstraintSet().getTypeVar(e))) {
                    p++;
                    r += 0.001;
                  }
                }
                if (H.isTypeSame(e, $e(t))) {
                  r = Number.POSITIVE_INFINITY;
                }
                if (l === undefined || l <= r) {
                  l = r;
                  n = d;
                }
              }
            }, true);
            if (p > 1 && r & 8) {
              n = undefined;
            }
            if (a && n) {
              a.copyFromClone(n);
            }
          }
        } else {
          for (const n of e.priv.subtypes) {
            if (Ir(n, t, i == null ? undefined : i.createAddendum(), a, r, s)) {
              o = true;
              break;
            }
          }
        }
        if (!o) {
          if (H.isTypeVar(t) && H.TypeVarType.hasConstraints(t)) {
            o = Ir(e, Pt(t), i == null ? undefined : i.createAddendum(), a, r, s);
          }
        }
        return !!o || (n && i && (n.addMessage(g.LocAddendum.typeAssignmentMismatch().format(Hr(t, e))), n.addAddendum(i)), false);
      }
      function Dr(e, t = 0) {
        if (!H.isClassInstance(e) || !H.ClassType.isProtocolClass(e)) {
          return;
        }
        for (const t of e.shared.mro) {
          if (H.isClass(t) && H.ClassType.isProtocolClass(t)) {
            for (const e of H.ClassType.getSymbolTable(t)) {
              if (e[0] !== '__call__' && !e[1].isIgnoredForProtocolMatch()) {
                let t = false;
                if ((Ae == null ? undefined : Ae.functionClass) && H.isClass(Ae.functionClass) && H.ClassType.getSymbolTable(Ae.functionClass).has(e[0])) {
                  t = true;
                }
                if (!t) {
                  return;
                }
              }
            }
          }
        }
        const n = tt(e, '__call__', undefined, undefined, t);
        if (n) {
          return Z.makeFunctionTypeVarsBound(n);
        } else {
          return undefined;
        }
      }
      function Nr(e, t, n, a, r, s, i) {
        if (H.isTypeVar(e) && e.shared.isSynthesized && e.shared.boundType && H.isClassInstance(e.shared.boundType) && H.ClassType.isProtocolClass(e.shared.boundType)) {
          return true;
        }
        if (H.isTypeVarTuple(e) && !H.isUnpacked(t)) {
          return false;
        }
        let o = t;
        let l = e;
        let p = false;
        if (!(s & 16)) {
          const n = !!(s & 8);
          if (s & 2) {
            if (!n) {
              o = Xe(t, r, undefined, {
                useLowerBoundOnly: true
              });
            }
            p = Z.requiresSpecialization(o);
          } else {
            if (!n) {
              l = Xe(e, r, undefined, {
                useLowerBoundOnly: true
              });
            }
            p = Z.requiresSpecialization(l);
          }
        }
        if (p && Ir(o, l, undefined, r, s ^ 2 | 256, i)) {
          l = Xe(e, r);
        }
        return !!Ir(o, l, a == null ? undefined : a.createAddendum(), r, s, i) || (a && n !== undefined && a.addMessage(g.LocAddendum.paramAssignment().format({
          index: n + 1,
          sourceType: Yr(e),
          destType: Yr(t)
        })), false);
      }
      function Fr(e, t, n, a = 0) {
        if (!(a > H.maxTypeRecursionCount)) {
          a++;
          if (n.shared.typeParams.length > 0 && n.priv.typeArgs && n.priv.typeArgs.length <= n.shared.typeParams.length && !n.priv.tupleTypeArgs) {
            const r = new k.ConstraintTracker();
            I.addConstraintsForExpectedType(es, H.ClassType.specialize(n, undefined), t, r, M.getTypeVarScopesForNode(e), e.start);
            let s = false;
            const i = I.solveConstraints(es, r).getMainSolutionSet();
            const o = n.priv.typeArgs.map((t, r) => {
              const o = n.shared.typeParams[r];
              const l = i.getType(o);
              if (l) {
                if (H.isAnyOrUnknown(l) || H.isAnyOrUnknown(t)) {
                  s = true;
                  return l;
                }
                if (H.isClassInstance(l) && H.isClassInstance(t)) {
                  const n = Fr(e, l, t, a);
                  if (n) {
                    s = true;
                    return n;
                  }
                } else {
                  if (Z.containsAnyRecursive(l)) {
                    const e = H.TypeVarType.getVariance(o);
                    const n = Ir(l, t);
                    const a = Ir(t, l);
                    if ((e === 4 || n) && (e === 3 || a)) {
                      s = true;
                      return l;
                    }
                  }
                }
              }
              return t;
            });
            if (s) {
              return H.ClassType.specialize(n, o);
            }
          }
          if (H.ClassType.isSameGenericClass(t, n) && Z.containsAnyRecursive(n) && !Z.containsAnyRecursive(t)) {
            return t;
          } else {
            return undefined;
          }
        }
      }
      function Er(e, t, n) {
        const a = Z.mapSubtypes(n.type, n => {
          if (H.isClass(n) && Z.isLiteralType(n) && H.isUnion(t) && H.UnionType.containsType(t, n)) {
            return n;
          }
          const a = Z.mapSubtypes(t, t => {
            if (H.isAnyOrUnknown(t)) {
              return t;
            }
            if (Ir(t, n)) {
              if (H.isAny(n)) {
                return t;
              }
              if (H.isClass(t) && H.isClass(n) && H.TypeBase.isInstance(t) === H.TypeBase.isInstance(n)) {
                const a = Fr(e, t, n);
                if (a) {
                  n = a;
                }
                return n;
              }
              if (H.isTypeVar(t) || !H.isTypeVar(n) || H.TypeVarType.isBound(n)) {
                if (Z.containsAnyRecursive(n, false) && !Z.containsAnyRecursive(t)) {
                  return t;
                } else {
                  return n;
                }
              } else {
                return t;
              }
            }
          });
          if (H.isNever(a)) {
            return n;
          } else {
            return a;
          }
        });
        if (Z.isIncompleteUnknown(a)) {
          return {
            type: a
          };
        } else {
          if (H.isUnknown(a)) {
            return {
              type: H.combineTypes([a, t])
            };
          } else {
            return {
              type: a
            };
          }
        }
      }
      function Mr(e, t) {
        if (!H.FunctionType.isInstanceMethod(e) && !H.FunctionType.isClassMethod(e) && !H.FunctionType.isConstructorMethod(e)) {
          return true;
        }
        const n = E.getParamListDetails(e);
        if (n.params.length === 0) {
          return true;
        }
        const a = n.params[0].param;
        if (a.category !== 0 || !H.FunctionParam.isTypeDeclared(a)) {
          return true;
        }
        const r = H.FunctionType.isInstanceMethod(e) ? H.ClassType.cloneAsInstance(t) : t;
        return Ir(n.params[0].type, r, undefined, undefined, 0);
      }
      function Or(e, t, n, a, r = true) {
        var s;
        var i;
        const o = E.getParamListDetails(e);
        const l = E.getParamListDetails(t);
        const p = new k.ConstraintTracker();
        let d = true;
        if (!H.FunctionType.isGradualCallableForm(e) && !H.FunctionType.isGradualCallableForm(t)) {
          if (H.FunctionType.isStaticMethod(e)) {
            if (!H.FunctionType.isStaticMethod(t)) {
              if (n != null) {
                n.addMessage(g.LocAddendum.overrideNotStaticMethod());
              }
              d = false;
            }
          } else {
            if (H.FunctionType.isClassMethod(e)) {
              if (!H.FunctionType.isClassMethod(t)) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.overrideNotClassMethod());
                }
                d = false;
              }
            } else {
              if (H.FunctionType.isInstanceMethod(e)) {
                if (!H.FunctionType.isInstanceMethod(t)) {
                  if (n != null) {
                    n.addMessage(g.LocAddendum.overrideNotInstanceMethod());
                  }
                  d = false;
                }
              }
            }
          }
          let c = false;
          if (l.positionParamCount < o.positionParamCount) {
            if (l.argsIndex === undefined) {
              c = true;
            } else {
              const e = l.params[l.argsIndex].type;
              for (let t = l.positionParamCount; t < o.positionParamCount; t++) {
                if (!Ir(e, o.params[t].type, n == null ? undefined : n.createAddendum(), p, 2)) {
                  g.LocAddendum.overrideParamType().format({
                    index: t + 1,
                    baseType: Yr(o.params[t].type),
                    overrideType: Yr(e)
                  });
                  d = false;
                }
              }
            }
          } else {
            if (l.positionParamCount > o.positionParamCount) {
              for (let e = o.positionParamCount; e < l.positionParamCount; e++) {
                const t = l.params[e].param;
                if (t.category === 0 && t.name && !l.params[e].defaultType) {
                  c = true;
                }
              }
            }
          }
          if (c) {
            if (n != null) {
              n.addMessage(g.LocAddendum.overridePositionalParamCount().format({
                baseCount: o.params.length,
                overrideCount: l.params.length
              }));
            }
            d = false;
          }
          const u = Math.min(o.positionParamCount, l.positionParamCount);
          for (let e = 0; e < u; e++) {
            if (e === 0 && r && (H.FunctionType.isInstanceMethod(t) || H.FunctionType.isClassMethod(t) || H.FunctionType.isConstructorMethod(t))) {
              continue;
            }
            const s = o.params[e].param;
            const i = l.params[e].param;
            if (e >= o.positionOnlyParamCount && !B.isPrivateOrProtectedName(s.name || '') && o.params[e].kind !== E.ParamKind.Positional && s.category === 0 && a && s.name !== i.name) {
              if (i.category === 0) {
                if (!H.FunctionParam.isNameSynthesized(s)) {
                  if (l.params[e].kind === E.ParamKind.Positional) {
                    if (n != null) {
                      n.addMessage(g.LocAddendum.overrideParamNamePositionOnly().format({
                        index: e + 1,
                        baseName: s.name || '*'
                      }));
                    }
                  } else {
                    if (n != null) {
                      n.addMessage(g.LocAddendum.overrideParamName().format({
                        index: e + 1,
                        baseName: s.name || '*',
                        overrideName: i.name || '*'
                      }));
                    }
                  }
                  d = false;
                }
              }
            } else {
              if (e < l.positionOnlyParamCount && e >= o.positionOnlyParamCount) {
                if (!H.FunctionParam.isNameSynthesized(s) && o.params[e].kind !== E.ParamKind.Positional && o.params[e].kind !== E.ParamKind.ExpandedArgs) {
                  if (n != null) {
                    n.addMessage(g.LocAddendum.overrideParamNamePositionOnly().format({
                      index: e + 1,
                      baseName: s.name || '*'
                    }));
                  }
                  d = false;
                }
              } else {
                const t = o.params[e].type;
                const a = l.params[e].type;
                const c = H.isTypeVar(t) && t.shared.isSynthesized;
                const u = H.isTypeVar(a) && a.shared.isSynthesized;
                if ((!r || !c && !u) && (s.category !== i.category || !Ir(a, t, n == null ? undefined : n.createAddendum(), p, 2))) {
                  if (n != null) {
                    n.addMessage(g.LocAddendum.overrideParamType().format({
                      index: e + 1,
                      baseType: Yr(t),
                      overrideType: Yr(a)
                    }));
                  }
                  d = false;
                }
                if (o.params[e].defaultType && !l.params[e].defaultType) {
                  if (n != null) {
                    n.addMessage(g.LocAddendum.overrideParamNoDefault().format({
                      index: e + 1
                    }));
                  }
                  d = false;
                }
              }
            }
          }
          if (a && l.kwargsIndex === undefined) {
            for (let e = u; e < o.positionParamCount; e++) {
              const t = o.params[e];
              if (t.kind === E.ParamKind.Standard && t.param.category === 0) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.overrideParamNamePositionOnly().format({
                    index: e + 1,
                    baseName: t.param.name || '*'
                  }));
                }
                d = false;
              }
            }
          }
          if (o.argsIndex !== undefined) {
            if (l.argsIndex === undefined) {
              if (n != null) {
                n.addMessage(g.LocAddendum.overrideParamNameMissing().format({
                  name: (s = o.params[o.argsIndex].param.name) !== null && s !== undefined ? s : '?'
                }));
              }
              d = false;
            } else {
              const e = l.params[l.argsIndex].type;
              const t = o.params[o.argsIndex].type;
              if (!Ir(e, t, n == null ? undefined : n.createAddendum(), p, 2)) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.overrideParamKeywordType().format({
                    name: (i = l.params[l.argsIndex].param.name) !== null && i !== undefined ? i : '?',
                    baseType: Yr(t),
                    overrideType: Yr(e)
                  }));
                }
                d = false;
              }
            }
          }
          const m = o.params.filter(e => e.kind === E.ParamKind.Keyword && e.param.category === 0);
          const y = l.params.filter(e => e.kind === E.ParamKind.Keyword && e.param.category === 0);
          m.forEach(e => {
            var t;
            var a;
            var r;
            const s = y.find(t => e.param.name === t.param.name);
            if (s || l.kwargsIndex !== undefined) {
              let t = s == null ? undefined : s.type;
              if (!t) {
                t = l.params[l.kwargsIndex].type;
              }
              if (!Ir(t, e.type, n == null ? undefined : n.createAddendum(), p, 2)) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.overrideParamKeywordType().format({
                    name: (a = e.param.name) !== null && a !== undefined ? a : '?',
                    baseType: Yr(e.type),
                    overrideType: Yr(t)
                  }));
                }
                d = false;
              }
              if (s && e.defaultType && !s.defaultType) {
                if (n != null) {
                  n.addMessage(g.LocAddendum.overrideParamKeywordNoDefault().format({
                    name: (r = s.param.name) !== null && r !== undefined ? r : '?'
                  }));
                }
                d = false;
              }
            } else {
              if (n != null) {
                n.addMessage(g.LocAddendum.overrideParamNameMissing().format({
                  name: (t = e.param.name) !== null && t !== undefined ? t : '?'
                }));
              }
              d = false;
            }
          });
          y.forEach(e => {
            var t;
            if (!m.find(t => e.param.name === t.param.name)) {
              if (o.kwargsIndex === undefined) {
                if (!e.defaultType) {
                  if (n != null) {
                    n.addMessage(g.LocAddendum.overrideParamNameExtra().format({
                      name: (t = e.param.name) !== null && t !== undefined ? t : '?'
                    }));
                  }
                  d = false;
                }
              }
            }
          });
          if (o.kwargsIndex !== undefined && l.kwargsIndex === undefined) {
            if (n != null) {
              n.addMessage(g.LocAddendum.kwargsParamMissing().format({
                paramName: o.params[o.kwargsIndex].param.name
              }));
            }
            d = false;
          }
        }
        if (o.paramSpec && !l.paramSpec) {
          if (l.argsIndex === undefined || !H.isAnyOrUnknown(l.params[l.argsIndex].type) || l.kwargsIndex === undefined || !H.isAnyOrUnknown(l.params[l.kwargsIndex].type)) {
            if (n != null) {
              n.addMessage(g.LocAddendum.paramSpecMissingInOverride());
            }
            d = false;
          }
        }
        const c = hr(e);
        const u = Xe(hr(t), p);
        if (!Ir(c, u, n == null ? undefined : n.createAddendum(), p, 0)) {
          if (n != null) {
            n.addMessage(g.LocAddendum.overrideReturnType().format({
              baseType: Yr(c),
              overrideType: Yr(u)
            }));
          }
          d = false;
        }
        return d;
      }
      function zr(e) {
        const t = new Map();
        H.ClassType.getReverseMro(e).forEach(e => {
          if (H.isInstantiableClass(e)) {
            H.ClassType.getSymbolTable(e).forEach((n, a) => {
              const r = dn(e, a);
              if (r) {
                t.set(a, r);
              } else {
                t.delete(a);
              }
            });
          }
        });
        const n = [];
        t.forEach(e => {
          n.push(e);
        });
        return n;
      }
      function Ur(e, t, n, a = false, r, s, i = 0) {
        return Z.mapSignatures(t, t => {
          if (!e) {
            return H.FunctionType.clone(t, true);
          }
          if (H.FunctionType.isInstanceMethod(t)) {
            if (Z.isInstantiableMetaclass(e)) {
              return t;
            }
            const a = H.isClassInstance(e) ? e : H.ClassType.cloneAsInstance(Z.specializeWithDefaultTypeArgs(e));
            let o = false;
            if (H.isClassInstance(e) || n && Z.isInstantiableMetaclass(n)) {
              o = true;
            }
            return Vr(e, t, s, i, r ?? a, o);
          }
          if (H.FunctionType.isClassMethod(t) || a && H.FunctionType.isConstructorMethod(t)) {
            const n = H.isInstantiableClass(e) ? e : H.ClassType.cloneAsInstantiable(e);
            const a = r ? Z.convertToInstantiable(r) : undefined;
            return Vr(n, t, s, i, a ?? n, true);
          }
          if (H.FunctionType.isStaticMethod(t)) {
            return Vr(H.isInstantiableClass(e) ? e : H.ClassType.cloneAsInstantiable(e), t, s, i, undefined, false);
          }
          return t;
        });
      }
      function Vr(e, t, n, a, r, s = true) {
        const i = new k.ConstraintTracker();
        if (r && t.shared.parameters.length > 0) {
          const e = t.shared.parameters[0];
          const s = H.FunctionType.getParamType(t, 0);
          if (H.isTypeVar(s) && s.shared.boundType && H.isClassInstance(s.shared.boundType) && H.ClassType.isProtocolClass(s.shared.boundType)) {
            i.setBounds(s, H.TypeBase.isInstantiable(s) ? Z.convertToInstance(r) : r);
          } else {
            const o = n == null ? undefined : n.createAddendum();
            if (!Ir(s, r, o == null ? undefined : o.createAddendum(), i, 8192, a) && e.name && !H.FunctionParam.isNameSynthesized(e) && H.FunctionParam.isTypeDeclared(e)) {
              if (o) {
                o.addMessage(g.LocMessage.bindTypeMismatch().format({
                  type: Yr(r),
                  methodName: t.shared.name || '<anonymous>',
                  paramName: e.name
                }));
              }
              return;
            }
          }
        }
        hr(t);
        const o = Xe(t, i);
        if (H.isFunction(o)) {
          return H.FunctionType.clone(o, s, e);
        } else {
          if (H.isOverloaded(o)) {
            return H.FunctionType.clone(H.OverloadedType.getOverloads(o)[0], s, e);
          } else {
            return undefined;
          }
        }
      }
      function Rr(e) {
        return e.getDeclarations().some(e => Lr(e));
      }
      function Lr(e) {
        return e.type === 1 && !!e.isFinal;
      }
      function Br(e) {
        if (e.type !== 1 || !e.typeAnnotationNode) {
          return false;
        }
        if (e.typeAnnotationNode.nodeType !== 38 && e.typeAnnotationNode.nodeType !== 35 && e.typeAnnotationNode.nodeType !== 48) {
          return false;
        }
        const t = Ze(e.typeAnnotationNode, {
          varTypeAnnotation: true,
          allowClassVar: true
        });
        return H.isClassInstance(t) && H.ClassType.isBuiltIn(t, 'TypeAlias');
      }
      function jr(e) {
        var t;
        return e.type === 1 && !!e.typeAliasName && !e.typeAnnotationNode && ((t = e.node.parent) === null || t === undefined ? undefined : t.nodeType) === 3 && qr(e.node.parent.d.rightExpr, false);
      }
      function qr(e, t) {
        switch (e.nodeType) {
          case 0:
          case 55:
          case 4:
          case 54:
          case 6:
          case 51:
          case 56:
          case 52:
          case 9:
          case 11:
          case 46:
          case 60:
          case 61:
          case 33:
          case 40:
          case 18:
          case 34:
          case 45:
            return false;
          case 48:
          case 49:
            return t;
          case 14:
            return e.d.constType === 26;
          case 7:
            return e.d.operator === 6 && qr(e.d.leftExpr, true) && qr(e.d.rightExpr, true);
          case 27:
          case 35:
            return qr(e.d.leftExpr, t);
        }
        return true;
      }
      function Gr(e) {
        var t;
        if (Z.isEllipsisType(e)) {
          return false;
        }
        if (H.isUnknown(e)) {
          return !!((t = e.props) === null || t === undefined ? undefined : t.specialForm) && !!H.ClassType.isBuiltIn(e.props.specialForm, 'UnionType');
        }
        let n = true;
        Z.doForEachSubtype(e, e => {
          if (!H.TypeBase.isInstantiable(e) && !Z.isNoneInstance(e)) {
            n = false;
          }
        });
        return n;
      }
      function Wr(e) {
        return jr(e) || Kr(e);
      }
      function Kr(e) {
        var t;
        if (e.type !== 1 || !e.node.parent || e.node.parent.nodeType !== 3 || ((t = e.node.parent.d.rightExpr) === null || t === undefined ? undefined : t.nodeType) !== 9) {
          return false;
        }
        const n = e.node.parent.d.rightExpr.d.leftExpr;
        if ((n.nodeType === 38 && n.d.value) === 'TypedDict' || n.nodeType === 35 && n.d.member.d.value === 'TypedDict' && n.d.leftExpr.nodeType === 38) {
          const e = qe(n, 2).type;
          if (H.isInstantiableClass(e) && H.ClassType.isBuiltIn(e, 'TypedDict')) {
            return true;
          }
        }
        return false;
      }
      function $r(e) {
        return $.printObjectTypeForClass(e, n.printTypeFlags, hr);
      }
      function Hr(e, t, n) {
        const a = Yr(e, n);
        const r = Yr(t, n);
        if (a !== r) {
          return {
            sourceType: a,
            destType: r
          };
        }
        const s = Yr(e, {
          ...(n ?? {}),
          useFullyQualifiedNames: true
        });
        const i = Yr(t, {
          ...(n ?? {}),
          useFullyQualifiedNames: true
        });
        if (s !== i) {
          return {
            sourceType: s,
            destType: i
          };
        } else {
          return {
            sourceType: a,
            destType: r
          };
        }
      }
      function Zr(e) {
        return v.getFileInfo(e).diagnosticRuleSet.enableExperimentalFeatures;
      }
      function Yr(e, t) {
        let a = n.printTypeFlags;
        if (t == null ? undefined : t.expandTypeAlias) {
          a |= 32;
        }
        if (t == null ? undefined : t.enforcePythonSyntax) {
          a |= 256;
        }
        if (t == null ? undefined : t.useTypingUnpack) {
          a |= 512;
        }
        if (t == null ? undefined : t.printUnknownWithAny) {
          a |= 1;
        }
        if (t == null ? undefined : t.printTypeVarVariance) {
          a |= 2048;
        }
        if (t == null ? undefined : t.omitTypeArgsIfUnknown) {
          a |= 2;
        }
        if (t == null ? undefined : t.useFullyQualifiedNames) {
          a |= 4096;
        }
        return $.printType(e, a, hr);
      }
      function Jr() {
        return ' '.repeat(Ce);
      }
      function Qr(e) {
        const t = v.getFileInfo(e);
        return (c.convertOffsetsToRange(e.start, e.start + e.length, t.lines).start.line + 1).toString();
      }
      const Xr = a(function (e, t) {
        var n;
        var a;
        var r;
        let s;
        let i = false;
        if (H.FunctionType.isStubDefinition(e)) {
          return H.UnknownType.create();
        }
        if (H.FunctionType.isParamSpecValue(e)) {
          return H.UnknownType.create();
        }
        if (H.FunctionType.isOverloaded(e) && !H.FunctionType.isSynthesizedMethod(e)) {
          return H.UnknownType.create();
        }
        if (e.priv.inferredReturnType) {
          s = e.priv.inferredReturnType;
        } else {
          if (H.FunctionType.isInstanceMethod(e) && e.shared.name === '__init__') {
            s = pt();
          } else {
            if (e.shared.declaration) {
              const t = e.shared.declaration.node;
              if ((v.getFileInfo(t).diagnosticRuleSet.analyzeUnannotatedFunctions || !M.isUnannotatedFunction(t)) && !yt(t.d.suite)) {
                const n = v.getCodeFlowComplexity(t);
                if (e.shared.parameters.length <= 1 || e.shared.parameters.some(e => H.FunctionParam.isTypeDeclared(e)) || n < ee) {
                  let n;
                  (function (e) {
                    const t = ue.disableSpeculativeMode();
                    try {
                      e();
                      ue.enableSpeculativeMode(t);
                    } catch (e) {
                      ue.enableSpeculativeMode(t);
                      throw e;
                    }
                  })(() => {
                    n = Aa(t, H.FunctionType.isAbstractMethod(e));
                  });
                  s = n == null ? undefined : n.type;
                  if (n == null ? undefined : n.isIncomplete) {
                    i = true;
                  }
                }
              }
            }
          }
          if (!s) {
            s = H.UnknownType.create();
          }
          const t = [];
          if (e.shared.typeVarScopeId) {
            t.push(e.shared.typeVarScopeId);
          }
          if ((n = e.shared.methodClass) === null || n === undefined ? undefined : n.shared.typeVarScopeId) {
            t.push(e.shared.methodClass.shared.typeVarScopeId);
          }
          s = Z.makeTypeVarsFree(s, t);
          if (!i) {
            e.priv.inferredReturnType = s;
          }
        }
        if (!i && Z.isPartlyUnknown(s) && H.FunctionType.hasUnannotatedParams(e) && !H.FunctionType.isStubDefinition(e) && !H.FunctionType.isPyTypedDefinition(e) && t) {
          let n = false;
          let i = false;
          const o = (a = e.shared.declaration) === null || a === undefined ? undefined : a.node;
          if (o) {
            if (o.d.decorators.length > 0) {
              n = true;
            }
            if (o.d.isAsync) {
              i = true;
            }
          }
          if (!n && !i) {
            const n = function (e, t) {
              const n = t.args;
              let a;
              if (!e.shared.declaration) {
                return;
              }
              const r = e.shared.declaration.node;
              if (v.getCodeFlowComplexity(r) >= te) {
                return;
              }
              if (n.some(e => !e.paramName)) {
                return;
              }
              if (ke.some(e => e.functionNode === r)) {
                return;
              }
              const s = va(r);
              if (!s) {
                return;
              }
              if (n.length > X) {
                return;
              }
              if (ke.length >= Q) {
                return;
              }
              const i = [];
              let o = false;
              const l = M.isWithinLoop(t.errorNode);
              Qa(r, () => {
                var t;
                var p;
                const d = we;
                ke.push({
                  functionNode: r,
                  codeFlowAnalyzer: ts.createCodeFlowAnalyzer()
                });
                try {
                  we = new Map();
                  let d = true;
                  r.d.params.forEach((e, t) => {
                    if (e.d.name) {
                      let a;
                      const o = n.find(t => e.d.name.d.value === t.paramName);
                      if (o && o.argument.valueExpression) {
                        a = qe(o.argument.valueExpression).type;
                        if (!H.isUnknown(a)) {
                          d = false;
                        }
                      } else {
                        if (e.d.defaultValue) {
                          a = qe(e.d.defaultValue).type;
                          if (!H.isUnknown(a)) {
                            d = false;
                          }
                        } else {
                          if (t === 0 && (H.FunctionType.isInstanceMethod(s.functionType) || H.FunctionType.isClassMethod(s.functionType)) && s.functionType.shared.parameters.length > 0 && r.d.params[0].d.name) {
                            a = H.FunctionType.getParamType(s.functionType, 0);
                          }
                        }
                      }
                      if (!a) {
                        a = H.UnknownType.create();
                      }
                      if (l) {
                        a = Z.stripTypeForm(Ut($e(a), 0, true));
                      }
                      i.push(a);
                      Fe(e.d.name, {
                        type: a
                      }, 0);
                    }
                  });
                  if (!d) {
                    const n = (t = s.functionType.priv.callSiteReturnTypeCache) === null || t === undefined ? undefined : t.find(e => e.paramTypes.length === i.length && e.paramTypes.every((e, t) => H.isTypeSame(e, i[t])));
                    if (n) {
                      a = n.returnType;
                      o = true;
                    } else {
                      a = (p = Aa(r, H.FunctionType.isAbstractMethod(e))) === null || p === undefined ? undefined : p.type;
                    }
                  }
                } finally {
                  ke.pop();
                  we = d;
                }
              });
              if (a) {
                a = H.removeUnbound(a);
                if (!o) {
                  if (!s.functionType.priv.callSiteReturnTypeCache) {
                    s.functionType.priv.callSiteReturnTypeCache = [];
                  }
                  if (s.functionType.priv.callSiteReturnTypeCache.length >= ne) {
                    s.functionType.priv.callSiteReturnTypeCache = s.functionType.priv.callSiteReturnTypeCache.slice(1);
                  }
                  s.functionType.priv.callSiteReturnTypeCache.push({
                    paramTypes: i,
                    returnType: a
                  });
                }
                return a;
              } else {
                return undefined;
              }
            }(e, t);
            if (n && (s = n, (r = e.shared.declaration) === null || r === undefined ? undefined : r.node)) {
              const t = M.getTypeVarScopesForNode(e.shared.declaration.node);
              s = Z.makeTypeVarsFree(s, t);
            }
          }
        }
        return s;
      });
      const es = {
        runWithCancellationToken: function (e, t) {
          try {
            ge = e;
            return t();
          } finally {
            ge = undefined;
          }
        },
        getType: Le,
        getTypeResult: function (e) {
          return Ba(e, () => {
            Va(e);
          });
        },
        getTypeResultForDecorator: function (e) {
          return Ba(e, () => {
            Va(e.d.expr);
          });
        },
        getCachedType: function (e) {
          return Ne(e, 0);
        },
        getTypeOfExpression: qe,
        getTypeOfAnnotation: Ze,
        getTypeOfClass: ca,
        createSubclass: function (e, t, n) {
          var a;
          var r;
          l.assert(H.isInstantiableClass(t) && H.isInstantiableClass(n));
          let s = false;
          if (H.TypeBase.getInstantiableDepth(t) > 0 && H.TypeBase.getInstantiableDepth(n) > 0) {
            t = H.ClassType.cloneAsInstance(t);
            n = H.ClassType.cloneAsInstance(n);
            s = true;
          }
          const i = `<subclass of ${Yr(Z.convertToInstance(t), {
            omitTypeArgsIfUnknown: true
          })} and ${Yr(Z.convertToInstance(n), {
            omitTypeArgsIfUnknown: true
          })}>`;
          const o = v.getFileInfo(e);
          let p = t.shared.effectiveMetaclass;
          if (n.shared.effectiveMetaclass) {
            if (!p || !!Ir(p, n.shared.effectiveMetaclass)) {
              p = n.shared.effectiveMetaclass;
            }
          }
          let d = H.ClassType.createInstantiable(i, M.getClassFullName(e, o.moduleName, i), o.moduleName, o.fileUri, 0, M.getTypeSourceId(e), undefined, p, t.shared.docString);
          d.shared.baseClasses = [t, n];
          Z.computeMroLinearization(d);
          d = Z.addConditionToType(d, (a = t.props) === null || a === undefined ? undefined : a.condition);
          d = Z.addConditionToType(d, (r = n.props) === null || r === undefined ? undefined : r.condition);
          if (s) {
            d = H.ClassType.cloneAsInstantiable(d);
          }
          return d;
        },
        getTypeOfFunction: va,
        getTypeOfExpressionExpectingType: Ha,
        getExpectedType: Be,
        evaluateTypeForSubnode: Ba,
        evaluateTypesForStatement: La,
        evaluateTypesForMatchStatement: function (e) {
          if (De(e)) {
            return;
          }
          const t = qe(e.d.expr);
          let n = t.type;
          for (const t of e.d.cases) {
            if (!t.d.guardExpr) {
              n = O.narrowTypeBasedOnPattern(es, n, t.d.pattern, false);
            }
          }
          Fe(e, {
            type: n,
            isIncomplete: !!t.isIncomplete
          }, 0);
        },
        evaluateTypesForCaseStatement: Ma,
        evaluateTypeOfParam: Ra,
        canBeTruthy: Je,
        canBeFalsy: Ye,
        stripLiteralValue: $e,
        removeTruthinessFromType: function (e) {
          return Z.mapSubtypes(e, e => {
            const t = Pt(e);
            if (H.isClassInstance(t)) {
              if (t.priv.literalValue !== undefined) {
                let n;
                n = t.priv.literalValue instanceof H.EnumLiteral ? !Je(t) : !t.priv.literalValue;
                if (n) {
                  return e;
                } else {
                  return undefined;
                }
              }
              if (H.ClassType.isBuiltIn(t, 'bool')) {
                return H.ClassType.cloneWithLiteral(t, false);
              }
              if (H.ClassType.isBuiltIn(t, 'int')) {
                return H.ClassType.cloneWithLiteral(t, 0);
              }
              if (H.ClassType.isBuiltIn(t, ['str', 'bytes'])) {
                return H.ClassType.cloneWithLiteral(t, '');
              }
            }
            if (Ye(e)) {
              return e;
            }
          });
        },
        removeFalsinessFromType: function (e) {
          return Z.mapSubtypes(e, e => {
            const t = Pt(e);
            if (H.isClassInstance(t)) {
              if (t.priv.literalValue !== undefined) {
                let n;
                n = t.priv.literalValue instanceof H.EnumLiteral ? !Ye(t) : !!t.priv.literalValue;
                if (n) {
                  return e;
                } else {
                  return undefined;
                }
              }
              if (H.ClassType.isBuiltIn(t, 'bool')) {
                return H.ClassType.cloneWithLiteral(t, true);
              }
              if (Z.isNoneInstance(t)) {
                return;
              }
              if (H.ClassType.isBuiltIn(t, 'object')) {
                return e;
              }
            }
            if (Je(e)) {
              return e;
            }
          });
        },
        stripTypeGuard: Qe,
        solveAndApplyConstraints: Xe,
        verifyRaiseExceptionType: function (e, t) {
          const n = Za(e, 'BaseException');
          const a = qe(e).type;
          if (a && n && H.isInstantiableClass(n)) {
            const r = new p.DiagnosticAddendum();
            Z.doForEachSubtype(a, a => {
              const s = Pt(a);
              if (!H.isAnyOrUnknown(s) && !H.isNever(s) && (!t || !Z.isNoneInstance(s))) {
                if (H.isInstantiableClass(s) && s.priv.literalValue === undefined) {
                  if (Z.derivesFromClassRecursive(s, n, false)) {
                    let t;
                    Qa(e, () => {
                      t = w.validateConstructorArgs(es, e, [], s, false, undefined);
                    });
                    if (t && t.argumentErrors) {
                      r.addMessage(g.LocMessage.exceptionTypeNotInstantiable().format({
                        type: Yr(a)
                      }));
                    }
                  } else {
                    r.addMessage(g.LocMessage.exceptionTypeIncorrect().format({
                      type: Yr(a)
                    }));
                  }
                } else {
                  if (!H.isClassInstance(s) || !Z.derivesFromClassRecursive(H.ClassType.cloneAsInstantiable(s), n, false)) {
                    r.addMessage(g.LocMessage.exceptionTypeIncorrect().format({
                      type: Yr(a)
                    }));
                  }
                }
              }
            });
            if (!r.isEmpty()) {
              kt(d.DiagnosticRule.reportGeneralTypeIssues, g.LocMessage.expectedExceptionClass() + r.getString(), e);
            }
          }
        },
        verifyDeleteExpression: Ft,
        validateOverloadedArgTypes: on,
        validateInitSubclassArgs: Ta,
        isNodeReachable: gt,
        isAfterNodeReachable: ht,
        getNodeReachability: ft,
        getAfterNodeReachability: Tt,
        isAsymmetricAccessorAssignment: function (e) {
          return s.has(e.id);
        },
        suppressDiagnostics: Qa,
        isSpecialFormClass: wr,
        getDeclInfoForStringNode: function (e) {
          var t;
          const n = [];
          const a = [];
          const r = (t = Be(e)) === null || t === undefined ? undefined : t.type;
          if (r) {
            Z.doForEachSubtype(r, t => {
              var r;
              if (H.isClassInstance(t) && H.ClassType.isTypedDictClass(t) && ((r = t.shared.typedDictEntries) === null || r === undefined ? undefined : r.knownItems.get(e.d.value))) {
                const r = Z.lookUpObjectMember(t, e.d.value)?.symbol;
                if (r) {
                  o.appendArray(n, r.getDeclarations());
                  const e = r.getSynthesizedType();
                  if (e) {
                    a.push(e);
                  }
                }
              }
            });
          }
          if (n.length === 0) {
            return undefined;
          } else {
            return {
              decls: n,
              synthesizedTypes: a
            };
          }
        },
        getDeclInfoForNameNode: function (e, t = true) {
          var n;
          var a;
          var r;
          if (t && v.isCodeUnreachable(e)) {
            return;
          }
          const s = [];
          const i = [];
          const l = sr(e);
          if (l) {
            const t = V.getScopeForNode(e);
            if (t) {
              const n = t.lookUpSymbolRecursive(l.d.value);
              if (n) {
                const t = n.symbol.getDeclarations().filter(t => t.type === 8 && t.node === e.parent);
                o.appendArray(s, A.getDeclarationsWithUsesLocalNameRemoved(t));
              }
            }
          } else {
            if (e.parent && e.parent.nodeType === 35 && e === e.parent.d.member) {
              let t = Le(e.parent.d.leftExpr);
              if (t) {
                t = Pt(t);
                const n = e.parent.d.member.d.value;
                Z.doForEachSubtype(t, e => {
                  let t;
                  e = Pt(e);
                  if (H.isInstantiableClass(e)) {
                    let a = Z.lookUpClassMember(e, n, 64);
                    if (!a) {
                      a = Z.lookUpClassMember(e, n);
                    }
                    if (!a) {
                      const t = e.shared.effectiveMetaclass;
                      if (t && H.isInstantiableClass(t)) {
                        a = Z.lookUpClassMember(t, n);
                      }
                    }
                    if (a) {
                      t = a.symbol;
                    }
                  } else {
                    if (H.isClassInstance(e)) {
                      let a = Z.lookUpObjectMember(e, n, 64);
                      if (!a) {
                        a = Z.lookUpObjectMember(e, n);
                      }
                      if (a) {
                        t = a.symbol;
                      }
                    } else {
                      if (H.isModule(e)) {
                        t = H.ModuleType.getField(e, n);
                      }
                    }
                  }
                  if (t) {
                    const e = t.getTypedDeclarations();
                    if (e.length > 0) {
                      o.appendArray(s, e);
                    } else {
                      o.appendArray(s, t.getDeclarations());
                    }
                    const n = t.getSynthesizedType();
                    if (n) {
                      i.push(n);
                    }
                  }
                });
              }
            } else {
              if (e.parent && e.parent.nodeType === 37) {
                const t = e.parent.d.nameParts.findIndex(t => t === e);
                const n = v.getImportInfo(e.parent);
                if (t >= 0 && n && !n.isNativeLib && t < n.resolvedUris.length && n.resolvedUris[t]) {
                  La(e);
                  s.push(A.synthesizeAliasDeclaration(n.resolvedUris[t]));
                }
              } else {
                if (e.parent && e.parent.nodeType === 1 && e === e.parent.d.name) {
                  const t = e.parent;
                  const l = e.d.value;
                  if (((n = t.parent) === null || n === undefined ? undefined : n.nodeType) === 9) {
                    const e = Le(t.parent.d.leftExpr);
                    if (e) {
                      if (H.isFunction(e) && e.shared.declaration) {
                        const t = rr(e, l);
                        if (t) {
                          s.push(t);
                        }
                      } else {
                        if (H.isOverloaded(e)) {
                          H.OverloadedType.getOverloads(e).forEach(e => {
                            const t = rr(e, l);
                            if (t) {
                              s.push(t);
                            }
                          });
                        } else {
                          if (H.isInstantiableClass(e)) {
                            const n = (a = w.getBoundInitMethod(es, t.parent.d.leftExpr, H.ClassType.cloneAsInstance(e))) === null || a === undefined ? undefined : a.type;
                            if (n && H.isFunction(n)) {
                              const t = rr(n, l);
                              if (t) {
                                s.push(t);
                              } else {
                                if (H.ClassType.isDataClass(e) || H.ClassType.isTypedDictClass(e) || H.ClassType.hasNamedTupleEntry(e, l)) {
                                  const t = Z.lookUpClassMember(e, l);
                                  if (t) {
                                    o.appendArray(s, t.symbol.getDeclarations());
                                    const e = t.symbol.getSynthesizedType();
                                    if (e) {
                                      i.push(e);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (((r = t.parent) === null || r === undefined ? undefined : r.nodeType) === 10) {
                      const e = ca(t.parent);
                      if (e) {
                        Ta(t.parent, e.classType);
                      }
                    }
                  }
                } else {
                  const t = v.getFileInfo(e);
                  const n = M.isWithinTypeAnnotation(e, !T.isAnnotationEvaluationPostponed(v.getFileInfo(e)));
                  const a = !!M.getParentNodeOfType(e, 77);
                  const r = n || a || t.isStubFile;
                  const l = Ja(e, e.d.value, !r, n);
                  if (l) {
                    o.appendArray(s, l.symbol.getDeclarations());
                    const e = l.symbol.getSynthesizedType();
                    if (e) {
                      i.push(e);
                    }
                  }
                }
              }
            }
          }
          return {
            decls: s,
            synthesizedTypes: i
          };
        },
        getTypeForDeclaration: ir,
        resolveAliasDeclaration: pr,
        resolveAliasDeclarationWithInfo: dr,
        getTypeOfIterable: it,
        getTypeOfIterator: st,
        getGetterTypeFromProperty: function (e, t) {
          if (H.ClassType.isPropertyClass(e)) {
            if (e.priv.fgetInfo) {
              return hr(e.priv.fgetInfo.methodType);
            } else {
              return undefined;
            }
          }
        },
        getTypeOfArg: Ka,
        convertNodeToArg: en,
        buildTupleTypesList: function (e, t) {
          const n = [];
          for (const a of e) {
            let e;
            if (a.unpackedType) {
              e = a.unpackedType;
            } else {
              if (H.isUnpacked(a.type)) {
                e = a.type;
              }
            }
            if (e && H.isClassInstance(e) && e.priv.tupleTypeArgs) {
              const t = e.priv.tupleTypeArgs;
              if (t) {
                o.appendArray(n, t);
              } else {
                n.push({
                  type: H.UnknownType.create(),
                  isUnbounded: true
                });
              }
            } else {
              if (H.isNever(a.type) && a.isIncomplete && !a.unpackedType) {
                n.push({
                  type: H.UnknownType.create(true),
                  isUnbounded: false
                });
              } else {
                let e = Ut(a.type, 0, true);
                e = t ? Z.stripTypeForm($e(e)) : e;
                n.push({
                  type: e,
                  isUnbounded: !!a.unpackedType
                });
              }
            }
          }
          if (n.filter(e => e.isUnbounded).length > 1) {
            const e = n.findIndex(e => e.isUnbounded);
            const t = n.splice(e);
            n.push({
              type: H.combineTypes(t.map(e => e.type)),
              isUnbounded: true
            });
          }
          return n;
        },
        markNamesAccessed: function (e, t) {
          const n = v.getFileInfo(e);
          const a = V.getScopeForNode(e);
          if (a) {
            t.forEach(t => {
              const r = a.lookUpSymbolRecursive(t);
              if (r) {
                Et(n, r.symbol, e);
              }
            });
          }
        },
        expandPromotionTypes: function (e, t, n = false) {
          return Z.mapSubtypes(t, t => {
            if (!H.isClass(t) || !t.priv.includePromotions) {
              return t;
            }
            if (n && H.ClassType.isBuiltIn(t, 'bytes')) {
              return t;
            }
            const r = [H.ClassType.cloneRemoveTypePromotions(t)];
            const s = J.get(t.shared.fullName);
            if (s) {
              for (const n of s) {
                const s = n.split('.');
                let i = Za(e, s[s.length - 1]);
                if (i && H.isInstantiableClass(i)) {
                  i = H.ClassType.cloneRemoveTypePromotions(i);
                  if (H.isClassInstance(t)) {
                    i = H.ClassType.cloneAsInstance(i);
                  }
                  i = Z.addConditionToType(i, t.props?.condition);
                  r.push(i);
                }
              }
            }
            return H.combineTypes(r);
          });
        },
        makeTopLevelTypeVarsConcrete: Pt,
        mapSubtypesExpandTypeVars: Dt,
        isTypeSubsumedByOtherType: Ar,
        lookUpSymbolRecursive: Ja,
        getDeclaredTypeOfSymbol: yr,
        getEffectiveTypeOfSymbol: cr,
        getEffectiveTypeOfSymbolForUsage: ur,
        getInferredTypeOfDeclaration: lr,
        getDeclaredTypeForExpression: at,
        getDeclaredReturnType: fr,
        getInferredReturnType: Xr,
        getBestOverloadForArgs: function (e, t, n) {
          let a = 0;
          let r = [];
          const s = nn(e);
          let i;
          er(e, () => {
            H.OverloadedType.getOverloads(t.type).forEach(i => {
              nr(s, () => {
                const s = un(e, n, {
                  type: i,
                  isIncomplete: t.isIncomplete
                }, a);
                if (!s.argumentErrors) {
                  r.push(s);
                }
                a++;
              });
            });
          });
          r = sn(r);
          r.forEach((t, n) => {
            if (i === undefined) {
              nr(s, () => {
                const a = gn(e, t, new k.ConstraintTracker(), true);
                if (a && !a.argumentErrors) {
                  i = n;
                }
              });
            }
          });
          if (i === undefined) {
            return undefined;
          } else {
            return r[i].overload;
          }
        },
        getBuiltInType: Za,
        getTypeOfMember: Tr,
        getTypeOfBoundMember: et,
        getBoundMagicMethod: tt,
        getTypeOfMagicMethodCall: Pn,
        bindFunctionToClassOrObject: Ur,
        getCallbackProtocolType: Dr,
        getCallSignatureInfo: function (e, t, n) {
          const a = e.d.leftExpr;
          const r = Le(a);
          if (!r) {
            return;
          }
          const s = [];
          let i = 0;
          function o() {
            s.push({
              argCategory: i,
              typeResult: {
                type: H.UnknownType.create()
              },
              active: true
            });
          }
          e.d.args.forEach((e, a) => {
            let r = false;
            if (a === t) {
              if (n) {
                r = true;
              } else {
                o();
              }
            }
            i = e.d.argCategory;
            s.push({
              valueExpression: e.d.valueExpr,
              argCategory: e.d.argCategory,
              name: e.d.name,
              active: r
            });
          });
          if (e.d.args.length < t) {
            o();
          }
          let l = [];
          function p(t) {
            let n;
            nr(e, () => {
              n = fn(a, s, {
                type: t
              }, undefined, true, undefined);
            });
            l.push({
              type: nt(t),
              activeParam: n == null ? undefined : n.activeParam
            });
          }
          function d(e) {
            if (H.isFunction(e)) {
              p(e);
            } else {
              H.OverloadedType.getOverloads(e).forEach(e => {
                p(e);
              });
            }
          }
          Z.doForEachSubtype(r, e => {
            switch (e.category) {
              case 4:
              case 5:
                d(e);
                break;
              case 6:
                if (H.TypeBase.isInstantiable(e)) {
                  const t = w.createFunctionFromConstructor(es, e);
                  if (t) {
                    Z.doForEachSubtype(t, e => {
                      if (H.isFunction(e) || H.isOverloaded(e)) {
                        d(e);
                      }
                    });
                    const e = l.filter(e => !H.FunctionType.isGradualCallableForm(e.type) || e.type.shared.parameters.length > 2 || e.type.shared.docString || e.type.shared.deprecatedMessage);
                    if (e.length > 0) {
                      l = e;
                    }
                  }
                } else {
                  const t = tt(e, '__call__');
                  if (t) {
                    d(t);
                  }
                }
            }
          });
          if (l.length !== 0) {
            return {
              callNode: e,
              signatures: l
            };
          } else {
            return undefined;
          }
        },
        getAbstractSymbols: zr,
        narrowConstrainedTypeVar: function (e, t) {
          const n = v.getFlowNode(e);
          if (n) {
            return ts.narrowConstrainedTypeVar(n, t);
          }
        },
        assignType: Ir,
        validateOverrideMethod: function (e, t, n, a, r = true) {
          if (!H.isFunction(e) && !H.isOverloaded(e)) {
            a.addMessage(g.LocAddendum.overrideType().format({
              type: Yr(e)
            }));
            return false;
          }
          if (H.isFunction(e)) {
            if (H.isFunction(t)) {
              return Or(e, t, a, r);
            }
            const n = [...H.OverloadedType.getOverloads(t)];
            const s = H.OverloadedType.getImplementation(t);
            if (s && H.isFunction(s)) {
              n.push(s);
            }
            return !!n.some(t => Or(e, t, undefined, r)) || (a.addMessage(g.LocAddendum.overrideNoOverloadMatches()), false);
          }
          if (H.isFunction(t)) {
            return H.OverloadedType.getOverloads(e).every(e => !!n && !Mr(e, n) || Or(e, t, a == null ? undefined : a.createAddendum(), r));
          }
          let s = -1;
          const i = H.OverloadedType.getOverloads(e);
          for (const e of H.OverloadedType.getOverloads(t)) {
            let t;
            let o = i.findIndex((a, i) => {
              if (n && !Mr(a, n)) {
                return false;
              }
              const o = Or(a, e, undefined, r, false);
              if (o && i <= s && t === undefined) {
                t = i;
                return false;
              } else {
                return o;
              }
            });
            if (o < 0 && t !== undefined) {
              o = t;
            }
            if (o < 0) {
              break;
            }
            if (o < s) {
              a.addMessage(g.LocAddendum.overrideOverloadOrder());
              return false;
            }
            s = o;
          }
          if (s < i.length - 1) {
            const e = i.slice(s + 1);
            if (!n || e.some(e => Mr(e, n))) {
              a.addMessage(g.LocAddendum.overrideOverloadNoMatch());
              return false;
            }
          }
          return true;
        },
        validateCallArgs: pn,
        validateTypeArg: Ln,
        assignTypeToExpression: Nt,
        assignClassToSelf: _r,
        getTypedDictClassType: function () {
          if ((Ae == null ? undefined : Ae.typedDictPrivateClass) && H.isInstantiableClass(Ae.typedDictPrivateClass)) {
            return Ae.typedDictPrivateClass;
          } else {
            return undefined;
          }
        },
        getTupleClassType: ot,
        getDictClassType: function () {
          if ((Ae == null ? undefined : Ae.dictClass) && H.isInstantiableClass(Ae.dictClass)) {
            return Ae.dictClass;
          } else {
            return undefined;
          }
        },
        getStrClassType: function () {
          if ((Ae == null ? undefined : Ae.strClass) && H.isInstantiableClass(Ae.strClass)) {
            return Ae.strClass;
          } else {
            return undefined;
          }
        },
        getObjectType: lt,
        getNoneType: pt,
        getUnionClassType: function () {
          var e;
          if ((e = Ae == null ? undefined : Ae.unionTypeClass) !== null && e !== undefined) {
            return e;
          } else {
            return H.UnknownType.create();
          }
        },
        getTypeClassType: dt,
        getBuiltInObject: Ya,
        getTypingType: ct,
        assignTypeArgs: Cr,
        reportMissingTypeArgs: Rt,
        inferReturnTypeIfNecessary: gr,
        inferVarianceForClass: ya,
        isFinalVariable: Rr,
        isFinalVariableDeclaration: Lr,
        isExplicitTypeAliasDeclaration: Br,
        addInformation: bt,
        addUnusedCode: function (e, t) {
          if (!Ct(e)) {
            v.getFileInfo(e).diagnosticSink.addUnusedCodeWithTextRange(g.LocMessage.unreachableCode(), t);
          }
        },
        addUnreachableCode: function (e, t, n) {
          if (t !== K.Reachability.Reachable && !Ct(e)) {
            const a = v.getFileInfo(e);
            const r = a.diagnosticRuleSet.enableReachabilityAnalysis;
            if (t === K.Reachability.UnreachableAlways || r) {
              a.diagnosticSink.addUnreachableCodeWithTextRange(t === K.Reachability.UnreachableAlways ? g.LocMessage.unreachableCode() : g.LocMessage.unreachableCodeType(), n);
            }
          }
        },
        addDeprecated: function (e, t) {
          if (!Ct(t)) {
            v.getFileInfo(t).diagnosticSink.addDeprecatedWithTextRange(e, t);
          }
        },
        addDiagnostic: kt,
        addDiagnosticForTextRange: wt,
        printType: Yr,
        printSrcDestTypes: Hr,
        printFunctionParts: function (e, t) {
          const a = t ? n.printTypeFlags | t : n.printTypeFlags;
          return $.printFunctionParts(e, a, hr);
        },
        getTypeCacheEntryCount: function () {
          return Te.size;
        },
        disposeEvaluator: function () {
          he = new Set();
          fe = new Map();
          Te = new Map();
          ve = new Map();
          be = new Map();
        },
        useSpeculativeMode: nr,
        isSpeculativeModeInUse: ar,
        setTypeResultForNode: Ee,
        checkForCancellation: xe,
        printControlFlowGraph: function (e, t, n, a) {
          return ts.printControlFlowGraph(e, t, n, a);
        }
      };
      const ts = b.getCodeFlowEngine(es, ue);
      return es;
    };
    const i = require(91426);
    const o = require(58147);
    const l = require(48281);
    const p = require(11479);
    const d = require(65880);
    const c = require(56814);
    const u = require(63808);
    const m = require(88754);
    const y = require(27113);
    const g = require(67703);
    const h = require(85114);
    const f = require(96941);
    const T = require(12673);
    const v = __importStar(require(26687));
    const b = require(19914);
    const _ = require(50299);
    const C = require(70617);
    const I = require(10081);
    const k = require(86672);
    const w = require(20516);
    const S = require(57373);
    const A = require(83760);
    const x = require(26163);
    const P = require(21451);
    const D = require(39245);
    const N = require(60055);
    const F = require(19327);
    const E = require(44321);
    const M = __importStar(require(41557));
    const O = require(69932);
    const z = require(89460);
    const U = require(54500);
    const V = __importStar(require(95952));
    const R = require(28676);
    const L = require(58253);
    const B = require(12097);
    const j = require(4064);
    const q = require(63278);
    const G = require(17486);
    const W = require(66308);
    const K = require(83055);
    const $ = __importStar(require(55501));
    const H = require(21024);
    const Z = require(92324);
    const Y = new Map([['asyncio.futures.Future', u.pythonVersion3_9], ['asyncio.tasks.Task', u.pythonVersion3_9], ['builtins.dict', u.pythonVersion3_9], ['builtins.frozenset', u.pythonVersion3_9], ['builtins.list', u.pythonVersion3_9], ['builtins._PathLike', u.pythonVersion3_9], ['builtins.set', u.pythonVersion3_9], ['builtins.tuple', u.pythonVersion3_9], ['collections.ChainMap', u.pythonVersion3_9], ['collections.Counter', u.pythonVersion3_9], ['collections.defaultdict', u.pythonVersion3_9], ['collections.DefaultDict', u.pythonVersion3_9], ['collections.deque', u.pythonVersion3_9], ['collections.OrderedDict', u.pythonVersion3_9], ['queue.Queue', u.pythonVersion3_9]]);
    const J = new Map([['builtins.float', ['builtins.int']], ['builtins.complex', ['builtins.float', 'builtins.int']], ['builtins.bytes', ['builtins.bytearray', 'builtins.memoryview']]]);
    const Q = 2;
    const X = 6;
    const ee = 32;
    const te = 8;
    const ne = 8;
    const ae = 64;
    const re = 64;
    const se = 16;
    const ie = 64;
    const oe = 12;
    const le = 10;
    const pe = 16;
    const de = false;
    const ce = false;
    exports.maxCodeComplexity = 768;
  },
  83055: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Reachability = exports.maxInferredContainerDepth = exports.maxSubtypesForInferredType = undefined;
    exports.maxSubtypesForInferredType = 64;
    exports.maxInferredContainerDepth = 8;
    (function (e) {
      e[e.Reachable = 0] = 'Reachable';
      e[e.UnreachableAlways = 1] = 'UnreachableAlways';
      e[e.UnreachableByAnalysis = 2] = 'UnreachableByAnalysis';
    })(n || (exports.Reachability = n = {}));
  },
  23274: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createTypeEvaluatorWithTracker = function (e, t, n, o) {
      function l(e) {
        if (t.logCalls && n.logLevel === a.LogLevel.Log) {
          return (...a) => n.log(e.name, t => {
            if (e.name === 'importLookup' && a.length > 0) {
              t.add(o == null ? undefined : o.printFileOrModuleName(a[0]));
            } else {
              a.forEach(e => {
                t.add(o == null ? undefined : o.print(e));
              });
            }
            return s.timingStats.typeEvaluationTime.timeOperation(e, ...a);
          }, t.minimumLoggingThreshold, true);
        } else {
          if (r.isDebugMode()) {
            return e;
          } else {
            return s.timingStats.typeEvaluationTime.timeOperation.bind(s.timingStats.typeEvaluationTime, e);
          }
        }
      }
      e = l(e);
      const p = i.createTypeEvaluator(e, t, l);
      Object.keys(p).forEach(e => {
        const t = p[e];
        if (typeof t == 'function' && t.name) {
          p[e] = l(t);
        }
      });
      return p;
    };
    const a = require(25075);
    const r = require(34455);
    const s = require(71582);
    const i = require(90080);
  },
  18891: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getTypeNarrowingCallback = T;
    exports.getIsInstanceClassTypes = w;
    exports.narrowTypeForInstanceOrSubclass = S;
    exports.getElementTypeForContainerNarrowing = F;
    exports.narrowTypeForContainerElementType = E;
    exports.narrowTypeForDiscriminatedDictEntryComparison = O;
    exports.narrowTypeForDiscriminatedTupleComparison = z;
    exports.narrowTypeForDiscriminatedLiteralFieldComparison = U;
    exports.enumerateLiteralsForType = j;
    const i = require(48281);
    const o = require(85114);
    const l = require(26687);
    const p = require(10081);
    const d = require(86672);
    const c = require(21451);
    const u = __importStar(require(41557));
    const m = require(95952);
    const y = require(58253);
    const g = require(66308);
    const h = require(21024);
    const f = require(92324);
    function T(e, t, n, a, r = 0) {
      if (r > h.maxTypeRecursionCount) {
        return;
      }
      r++;
      if (n.nodeType === 4) {
        return function (e, t, n, a, r) {
          var s;
          if ((s = T(e, t, n.d.rightExpr, a, r)) !== null && s !== undefined) {
            return s;
          } else {
            return T(e, t, n.d.name, a, r);
          }
        }(e, t, n, a, r);
      }
      if (n.nodeType === 7) {
        const r = n.d.operator === 39 || n.d.operator === 40;
        const s = n.d.operator === 12 || n.d.operator === 28;
        const i = s || n.d.operator === 20 || n.d.operator === 21 || n.d.operator === 15 || n.d.operator === 16;
        if (r || s) {
          const i = n.d.operator === 39 || n.d.operator === 12 ? a : !a;
          if (n.d.rightExpr.nodeType === 14 && n.d.rightExpr.d.constType === 26) {
            let a = n.d.leftExpr;
            if (a.nodeType === 4) {
              a = a.d.name;
            }
            if (u.isMatchingExpression(t, a)) {
              return t => ({
                type: I(e, t, i),
                isIncomplete: false
              });
            }
            if (a.nodeType === 27 && u.isMatchingExpression(t, a.d.leftExpr) && a.d.items.length === 1 && !a.d.trailingComma && a.d.items[0].d.argCategory === 0 && !a.d.items[0].d.name && a.d.items[0].d.valueExpr.nodeType === 40 && a.d.items[0].d.valueExpr.d.isInteger && !a.d.items[0].d.valueExpr.d.isImaginary) {
              const t = a.d.items[0].d.valueExpr.d.value;
              if (typeof t == 'number') {
                return n => ({
                  type: C(e, n, i, t),
                  isIncomplete: false
                });
              }
            }
          }
          if (n.d.rightExpr.nodeType === 21) {
            let a = n.d.leftExpr;
            if (a.nodeType === 4) {
              a = a.d.name;
            }
            if (u.isMatchingExpression(t, a)) {
              return t => ({
                type: k(e, n, t, i),
                isIncomplete: false
              });
            }
          }
          if (n.d.leftExpr.nodeType === 9 && n.d.leftExpr.d.args.length === 1 && n.d.leftExpr.d.args[0].d.argCategory === 0) {
            const a = n.d.leftExpr.d.args[0].d.valueExpr;
            if (u.isMatchingExpression(t, a)) {
              const t = e.getTypeOfExpression(n.d.leftExpr.d.leftExpr, 2).type;
              if (h.isInstantiableClass(t) && h.ClassType.isBuiltIn(t, 'type')) {
                const t = e.getTypeOfExpression(n.d.rightExpr);
                const a = e.makeTopLevelTypeVarsConcrete(t.type);
                if (h.isInstantiableClass(a)) {
                  return n => ({
                    type: R(e, n, a, i),
                    isIncomplete: !!t.isIncomplete
                  });
                }
              }
            }
          }
          if (r) {
            if (u.isMatchingExpression(t, n.d.leftExpr)) {
              const t = e.getTypeOfExpression(n.d.rightExpr);
              const a = t.type;
              if (h.isClassInstance(a) && (h.ClassType.isEnumClass(a) || h.ClassType.isBuiltIn(a, 'bool')) && a.priv.literalValue !== undefined) {
                return n => ({
                  type: B(e, n, a, i, true),
                  isIncomplete: !!t.isIncomplete
                });
              }
              if (h.isInstantiableClass(a)) {
                return n => ({
                  type: L(e, n, a, i),
                  isIncomplete: !!t.isIncomplete
                });
              }
            }
            if (n.d.leftExpr.nodeType === 27 && n.d.leftExpr.d.items.length === 1 && !n.d.leftExpr.d.trailingComma && n.d.leftExpr.d.items[0].d.argCategory === 0 && u.isMatchingExpression(t, n.d.leftExpr.d.leftExpr)) {
              const t = e.getTypeOfExpression(n.d.leftExpr.d.items[0].d.valueExpr);
              const a = t.type;
              if (h.isClassInstance(a) && f.isLiteralType(a)) {
                if (h.ClassType.isBuiltIn(a, 'str')) {
                  const r = e.getTypeOfExpression(n.d.rightExpr).type;
                  if (h.isClassInstance(r) && r.priv.literalValue !== undefined) {
                    return n => ({
                      type: O(e, n, a, r, i),
                      isIncomplete: !!t.isIncomplete
                    });
                  }
                } else {
                  if (h.ClassType.isBuiltIn(a, 'int')) {
                    const t = e.getTypeOfExpression(n.d.rightExpr);
                    const r = t.type;
                    if (h.isClassInstance(r) && r.priv.literalValue !== undefined) {
                      let n = false;
                      if (h.ClassType.isBuiltIn(r, 'bool') || r.priv.literalValue instanceof h.EnumLiteral) {
                        n = true;
                      }
                      if (n) {
                        return n => ({
                          type: z(e, n, a, r, i),
                          isIncomplete: !!t.isIncomplete
                        });
                      }
                    }
                  }
                }
              }
            }
          }
          if (s) {
            const r = n.d.operator === 12 ? a : !a;
            if (u.isMatchingExpression(t, n.d.leftExpr)) {
              const t = e.getTypeOfExpression(n.d.rightExpr);
              const a = t.type;
              if (h.isClassInstance(a) && a.priv.literalValue !== undefined) {
                return n => ({
                  type: B(e, n, a, r, false),
                  isIncomplete: !!t.isIncomplete
                });
              }
            }
            if (n.d.leftExpr.nodeType === 27 && n.d.leftExpr.d.items.length === 1 && !n.d.leftExpr.d.trailingComma && n.d.leftExpr.d.items[0].d.argCategory === 0 && u.isMatchingExpression(t, n.d.leftExpr.d.leftExpr)) {
              const t = e.getTypeOfExpression(n.d.leftExpr.d.items[0].d.valueExpr);
              const a = t.type;
              if (h.isClassInstance(a) && f.isLiteralType(a) && h.ClassType.isBuiltIn(a, ['str', 'int'])) {
                const s = e.getTypeOfExpression(n.d.rightExpr);
                const i = s.type;
                if (f.isLiteralTypeOrUnion(i)) {
                  return n => {
                    let o;
                    o = h.ClassType.isBuiltIn(a, 'str') ? O(e, n, a, i, r) : z(e, n, a, i, r);
                    return {
                      type: o,
                      isIncomplete: !!t.isIncomplete || !!s.isIncomplete
                    };
                  };
                }
              }
            }
          }
          if (s && n.d.leftExpr.nodeType === 35 && u.isMatchingExpression(t, n.d.leftExpr.d.leftExpr)) {
            const t = e.getTypeOfExpression(n.d.rightExpr);
            const a = t.type;
            const r = n.d.leftExpr.d.member;
            if (h.isClassInstance(a) && (a.priv.literalValue !== undefined || f.isNoneInstance(a))) {
              return n => ({
                type: U(e, n, r.d.value, a, i),
                isIncomplete: !!t.isIncomplete
              });
            }
          }
          if (n.d.leftExpr.nodeType === 35 && u.isMatchingExpression(t, n.d.leftExpr.d.leftExpr)) {
            const t = e.getTypeOfExpression(n.d.rightExpr);
            const a = t.type;
            const r = n.d.leftExpr.d.member;
            if (h.isClassInstance(a) && (h.ClassType.isEnumClass(a) || h.ClassType.isBuiltIn(a, 'bool')) && a.priv.literalValue !== undefined) {
              return n => ({
                type: U(e, n, r.d.value, a, i),
                isIncomplete: !!t.isIncomplete
              });
            }
          }
          if (n.d.leftExpr.nodeType === 35 && u.isMatchingExpression(t, n.d.leftExpr.d.leftExpr) && n.d.rightExpr.nodeType === 14 && n.d.rightExpr.d.constType === 26) {
            const t = n.d.leftExpr.d.member;
            return n => ({
              type: V(e, n, t.d.value, i),
              isIncomplete: false
            });
          }
        }
        if (i && n.d.leftExpr.nodeType === 9 && n.d.leftExpr.d.args.length === 1) {
          const r = n.d.leftExpr.d.args[0].d.valueExpr;
          if (u.isMatchingExpression(t, r)) {
            const t = e.getTypeOfExpression(n.d.leftExpr.d.leftExpr, 2);
            const r = t.type;
            if (h.isFunction(r) && r.shared.fullName === 'builtins.len') {
              const r = e.getTypeOfExpression(n.d.rightExpr);
              const s = r.type;
              if (h.isClassInstance(s) && typeof s.priv.literalValue == 'number' && s.priv.literalValue >= 0) {
                let i = s.priv.literalValue;
                const o = n.d.operator === 12 || n.d.operator === 20 || n.d.operator === 21 ? a : !a;
                if (n.d.operator === 21 || n.d.operator === 15) {
                  i++;
                }
                const l = n.d.operator === 12 || n.d.operator === 28;
                return n => ({
                  type: P(e, n, i, o, !l),
                  isIncomplete: !!t.isIncomplete || !!r.isIncomplete
                });
              }
            }
          }
        }
        if (n.d.operator === 41 || n.d.operator === 42) {
          if (u.isMatchingExpression(t, n.d.leftExpr)) {
            const t = e.getTypeOfExpression(n.d.rightExpr);
            const r = t.type;
            const s = n.d.operator === 41 ? a : !a;
            return n => ({
              type: N(e, n, r, s),
              isIncomplete: !!t.isIncomplete
            });
          }
          if (u.isMatchingExpression(t, n.d.rightExpr)) {
            const t = e.getTypeOfExpression(n.d.leftExpr);
            const r = t.type;
            if (h.isClassInstance(r) && h.ClassType.isBuiltIn(r, 'str') && f.isLiteralType(r)) {
              const s = n.d.operator === 41 ? a : !a;
              return n => ({
                type: M(e, n, h.ClassType.cloneAsInstantiable(r), s),
                isIncomplete: !!t.isIncomplete
              });
            }
          }
        }
      }
      if (n.nodeType === 9) {
        if (n.d.args.length === 2) {
          const r = n.d.args[0].d.valueExpr;
          const s = n.d.args[1].d.valueExpr;
          if (u.isMatchingExpression(t, r)) {
            const t = e.getTypeOfExpression(n.d.leftExpr, 2);
            const r = t.type;
            if (h.isFunction(r) && h.FunctionType.isBuiltIn(r, ['isinstance', 'issubclass'])) {
              const i = h.FunctionType.isBuiltIn(r, 'isinstance');
              const o = e.getTypeOfExpression(s, 536871546);
              const l = o.type;
              const p = w(e, l);
              const d = !!t.isIncomplete || !!o.isIncomplete;
              if (p) {
                return t => ({
                  type: S(e, t, p, i, false, a, n),
                  isIncomplete: d
                });
              }
              if (d) {
                return e => ({
                  type: e,
                  isIncomplete: true
                });
              }
            }
          }
        }
        if (n.d.args.length === 1 && !n.d.args[0].d.name && u.isMatchingExpression(t, n.d.args[0].d.valueExpr)) {
          const t = e.getTypeOfExpression(n.d.leftExpr, 2);
          const r = t.type;
          if (h.isInstantiableClass(r) && h.ClassType.isBuiltIn(r, 'bool')) {
            return n => ({
              type: _(e, n, a),
              isIncomplete: !!t.isIncomplete
            });
          }
        }
        if (n.d.args.length >= 1) {
          const r = n.d.args[0].d.valueExpr;
          if (u.isMatchingExpression(t, r)) {
            let t = false;
            const r = e => e.shared.declaredReturnType && h.isClassInstance(e.shared.declaredReturnType) && h.ClassType.isBuiltIn(e.shared.declaredReturnType, ['TypeGuard', 'TypeIs']);
            const s = e.getTypeOfExpression(n.d.leftExpr, 2);
            const i = s.type;
            if (h.isFunction(i) && r(i) || h.isOverloaded(i) && h.OverloadedType.getOverloads(i).some(e => r(e)) || h.isClassInstance(i)) {
              t = true;
            }
            if (t) {
              const t = e.getTypeOfExpression(n);
              const r = t.type;
              if (h.isClassInstance(r) && h.ClassType.isBuiltIn(r, ['TypeGuard', 'TypeIs']) && r.priv.typeArgs && r.priv.typeArgs.length > 0) {
                const i = h.ClassType.isBuiltIn(r, 'TypeIs');
                const o = r.priv.typeArgs[0];
                const l = !!s.isIncomplete || !!t.isIncomplete;
                return t => ({
                  type: b(e, t, o, a, i, n),
                  isIncomplete: l
                });
              }
            }
          }
        }
      }
      if (u.isMatchingExpression(t, n)) {
        return t => ({
          type: _(e, t, a),
          isIncomplete: false
        });
      }
      const s = function (e, t, n, a, r) {
        if (n.nodeType !== 38 || t.nodeType !== 38 || n === t) {
          return;
        }
        const s = v(e, n, n, true);
        if (!s || s.length !== 1 || s[0].type !== 1) {
          return;
        }
        const i = v(e, t, n, false);
        if (!i) {
          return;
        }
        let l = [];
        if (i.length > 1) {
          l = i.filter(t => e.isNodeReachable(n, t.node) && e.isNodeReachable(t.node, s[0].node));
        }
        if (l.length !== 0) {
          return;
        }
        const p = s[0].inferredTypeSource;
        if (!p || u.isNodeContainedWithin(n, p) || !o.isExpressionNode(p)) {
          return;
        }
        return T(e, t, p, a, r);
      }(e, t, n, a, r);
      return s || (t.nodeType === 38 && n.nodeType === 55 && n.d.operator === 38 ? T(e, t, n.d.expr, !a, r) : undefined);
    }
    function v(e, t, n, a) {
      const r = m.getScopeForNode(t);
      if ((r == null ? undefined : r.type) !== 2 && (r == null ? undefined : r.type) !== 4) {
        return;
      }
      const s = r.lookUpSymbol(t.d.value);
      if (!s) {
        return;
      }
      const i = s.getDeclarations();
      if (a && i.length > 1) {
        return;
      }
      if (i.length === 0 || i.some(e => e.type !== 1 && e.type !== 2)) {
        return;
      }
      let o;
      if (i.some(e => {
        const t = e.type === 2 ? e.node.d.name : e.node;
        const n = u.getExecutionScopeNode(t);
        return !!o && n !== o || (o = n, false);
      })) {
        return;
      }
      const l = i.filter(t => e.isNodeReachable(n, t.node));
      if (l.length > 0) {
        return l;
      } else {
        return undefined;
      }
    }
    function b(e, t, n, a, r, s) {
      if (!r) {
        let e = t;
        if (a) {
          e = n;
          if (!!h.isTypeVar(t) && !h.isParamSpec(t) && !h.TypeVarType.hasConstraints(t)) {
            e = f.addConditionToType(e, [{
              typeVar: t,
              constraintIndex: 0
            }]);
          }
          return e;
        } else {
          return e;
        }
      }
      const i = [];
      f.doForEachSubtype(n, e => {
        i.push(f.convertToInstantiable(e));
      });
      return S(e, t, i, true, true, a, s);
    }
    function _(e, t, n) {
      return f.mapSubtypes(t, t => {
        if (n) {
          if (e.canBeTruthy(t)) {
            return e.removeFalsinessFromType(t);
          }
        } else {
          if (e.canBeFalsy(t)) {
            return e.removeTruthinessFromType(t);
          }
        }
      });
    }
    function C(e, t, n, a) {
      return e.mapSubtypesExpandTypeVars(t, undefined, t => {
        const r = f.getSpecializedTupleType(t);
        if (!r || f.isUnboundedTupleClass(r) || !r.priv.tupleTypeArgs) {
          return t;
        }
        const s = r.priv.tupleTypeArgs.length;
        if (a < 0 || a >= s) {
          return t;
        }
        const i = e.makeTopLevelTypeVarsConcrete(r.priv.tupleTypeArgs[a].type);
        if (n) {
          if (!e.assignType(i, e.getNoneType())) {
            return;
          }
        } else {
          if (f.isNoneInstance(i)) {
            return;
          }
        }
        return t;
      });
    }
    function I(e, t, n) {
      const a = f.mapSubtypes(t, e => f.transformPossibleRecursiveTypeAlias(e));
      let r = false;
      const s = e.mapSubtypesExpandTypeVars(a, undefined, (t, a) => {
        var s;
        if (h.isAnyOrUnknown(t)) {
          return t;
        }
        let i = false;
        if (h.isTypeVar(a) && !h.TypeVarType.isSelf(a)) {
          if (a.shared.constraints.some(t => e.assignType(t, e.getNoneType()))) {
            i = true;
          }
          if (a.shared.boundType && e.assignType(a.shared.boundType, e.getNoneType())) {
            i = true;
          }
        }
        const o = i ? t : a;
        if (f.isNoneInstance(t)) {
          r = true;
          return n ? o : undefined;
        } else {
          if (e.assignType(t, e.getNoneType())) {
            r = true;
            return n ? f.addConditionToType(e.getNoneType(), (s = t.props) === null || s === undefined ? undefined : s.condition) : o;
          } else {
            if (n) {
              return undefined;
            } else {
              return o;
            }
          }
        }
      });
      if (n && r) {
        return f.mapSubtypes(s, e => f.isNoneInstance(e) ? e : undefined);
      } else {
        return s;
      }
    }
    function k(e, t, n, a) {
      var r;
      var s;
      const i = f.mapSubtypes(n, e => f.transformPossibleRecursiveTypeAlias(e));
      const o = (s = (r = e.getBuiltInObject(t, 'EllipsisType')) !== null && r !== undefined ? r : e.getBuiltInObject(t, 'ellipsis')) !== null && s !== undefined ? s : h.AnyType.create();
      return e.mapSubtypesExpandTypeVars(i, undefined, (e, t) => {
        var n;
        if (h.isAnyOrUnknown(e)) {
          return e;
        }
        const r = h.isTypeVar(t) && !h.TypeVarType.hasConstraints(t) ? t : e;
        if (h.isClassInstance(e) && h.ClassType.isBuiltIn(e, 'object')) {
          if (a) {
            return f.addConditionToType(o, (n = e.props) === null || n === undefined ? undefined : n.condition);
          } else {
            return r;
          }
        }
        if ((h.isClassInstance(e) && h.ClassType.isBuiltIn(e, ['EllipsisType', 'ellipsis'])) === a) {
          return e;
        } else {
          return undefined;
        }
      });
    }
    function w(e, t) {
      let n = false;
      const a = [];
      const r = (t, s = 0) => {
        if (!(s > h.maxTypeRecursionCount)) {
          if (h.isClass(t) && h.TypeBase.isInstance(t) && f.isTupleClass(t)) {
            if (t.priv.tupleTypeArgs) {
              t.priv.tupleTypeArgs.forEach(e => {
                r(e.type, s + 1);
              });
            }
          } else {
            f.doForEachSubtype(t, t => {
              [t].forEach(t => {
                if (h.isClass(t)) {
                  t = f.specializeWithUnknownTypeArgs(t, e.getTupleClassType());
                  if (h.isInstantiableClass(t) && h.ClassType.isBuiltIn(t, 'Callable')) {
                    t = f.convertToInstantiable(f.getUnknownTypeForCallable());
                  }
                }
                if (h.isInstantiableClass(t)) {
                  if (!t.priv.includeSubclasses && t.priv.includePromotions) {
                    t = h.ClassType.cloneRemoveTypePromotions(t);
                  }
                  a.push(t);
                } else {
                  if (h.isTypeVar(t) && h.TypeBase.isInstantiable(t)) {
                    a.push(t);
                  } else {
                    if (f.isNoneTypeClass(t)) {
                      i.assert(h.isInstantiableClass(t));
                      a.push(t);
                    } else {
                      if (h.isFunction(t) && t.shared.parameters.length === 2 && t.shared.parameters[0].category === 1 && t.shared.parameters[1].category === 2) {
                        a.push(t);
                      } else {
                        n = true;
                      }
                    }
                  }
                }
              });
            });
          }
        }
      };
      f.doForEachSubtype(t, e => {
        r(e);
      });
      if (n) {
        return undefined;
      } else {
        return a;
      }
    }
    function S(e, t, n, a, r, s, i) {
      const o = A(e, t, n, a, r, s, false, i);
      if (h.isNever(o)) {
        return A(e, t, n, a, r, s, true, i);
      } else {
        return o;
      }
    }
    function A(e, t, n, a, r, s, i, o) {
      const c = f.mapSubtypes(t, t => {
        let c = t;
        let m = false;
        let g = n;
        if (!a) {
          const a = h.isClassInstance(t) && h.ClassType.isBuiltIn(t, 'type');
          if (f.isMetaclassInstance(t) && !a) {
            g = n.map(e => f.convertToInstantiable(e));
          } else {
            const n = f.convertToInstance(t);
            c = h.isClassInstance(t) && h.ClassType.isBuiltIn(t, 'type') && h.isAnyOrUnknown(n) ? f.convertToInstance(e.getObjectType()) : n;
            m = true;
          }
        }
        const T = function (e, t, n, a, r, s, i) {
          let o = f.mapSubtypes(t, e => f.transformPossibleRecursiveTypeAlias(e));
          o = e.expandPromotionTypes(i, o);
          const c = e => a ? e : f.makeTypeVarsFree(e, u.getTypeVarScopesForNode(i));
          const m = (t, o, m, g) => {
            var T;
            var v;
            var b;
            var _;
            var C;
            const I = [];
            let k = false;
            let w = false;
            for (const g of n) {
              const n = e.makeTopLevelTypeVarsConcrete(g);
              if (h.isInstantiableClass(n)) {
                const l = n.shared.effectiveMetaclass;
                if (f.isInstantiableMetaclass(o) && h.TypeBase.getInstantiableDepth(n) > 0 && l && h.isInstantiableClass(l)) {
                  const t = f.convertToInstance(o);
                  let n = e.assignType(c(t), h.ClassType.cloneAsInstance(l));
                  if (h.ClassType.isBuiltIn(l, 'type') && !l.priv.isTypeArgExplicit) {
                    if (!h.isClass(t) || !h.ClassType.isBuiltIn(t, 'type')) {
                      n = false;
                    }
                  }
                  if (n) {
                    if (r) {
                      I.push(g);
                      k = true;
                    } else {
                      if (!h.isTypeSame(t, l) || !!l.priv.includeSubclasses) {
                        I.push(t);
                        w = true;
                      }
                    }
                    continue;
                  }
                }
                let y = o;
                if (!a) {
                  y = f.makeTypeVarsFree(y, u.getTypeVarScopesForNode(i));
                }
                if (h.isInstantiableClass(y) && h.ClassType.isTypedDictClass(y)) {
                  const t = e.getDictClassType();
                  const n = e.getStrClassType();
                  if (t && n) {
                    y = h.ClassType.specialize(t, [h.ClassType.cloneAsInstance(n), h.UnknownType.create()]);
                  }
                }
                const _ = e.assignType(g, y, undefined, undefined, 81920);
                let C = e.assignType(y, g, undefined, undefined, 81920);
                if (_) {
                  k = true;
                }
                if (h.ClassType.isBuiltIn(y, 'TypeForm')) {
                  w = true;
                  C = true;
                }
                if (_) {
                  if (!a && n.priv.includeSubclasses) {
                    w = true;
                  }
                  if (C && !h.ClassType.isSameGenericClass(y, n)) {
                    if (!h.ClassType.isBuiltIn(n, 'type') || h.TypeBase.getInstantiableDepth(y) === 0) {
                      w = true;
                    }
                  }
                }
                if (h.isTypeVar(t) && h.isTypeVar(g)) {
                  w = true;
                }
                if (r) {
                  if (_) {
                    if (h.isTypeVar(t) && h.TypeVarType.isSelf(t)) {
                      I.push(f.addConditionToType(t, m));
                    } else {
                      I.push(f.addConditionToType(o, m));
                    }
                  } else {
                    if (C) {
                      let t = g;
                      if (h.isClass(g) && (h.ClassType.isSpecialBuiltIn(g) || g.shared.typeParams.length > 0) && !g.priv.isTypeArgExplicit && !h.ClassType.isSameGenericClass(o, g)) {
                        const n = new d.ConstraintTracker();
                        const a = h.ClassType.specialize(g, undefined);
                        if (p.addConstraintsForExpectedType(e, h.ClassType.cloneAsInstance(a), h.ClassType.cloneAsInstance(o), n, undefined, i.start)) {
                          t = e.solveAndApplyConstraints(a, n, {
                            replaceUnsolved: {
                              scopeIds: f.getTypeVarScopeIds(g),
                              useUnknown: true,
                              tupleClassType: e.getTupleClassType()
                            }
                          });
                        }
                      }
                      I.push(f.addConditionToType(t, m));
                    } else {
                      if (h.ClassType.isSameGenericClass(h.ClassType.cloneAsInstance(o), h.ClassType.cloneAsInstance(n))) {
                        if (!a && ((T = o.priv) === null || T === undefined ? undefined : T.literalValue) === undefined && ((v = n.priv) === null || v === undefined ? undefined : v.literalValue) === undefined) {
                          const a = x(e, o, n);
                          I.push(a ?? t);
                        }
                      } else {
                        if (s && !h.ClassType.isFinal(o) && !h.ClassType.isFinal(n)) {
                          let a = e.createSubclass(i, o, n);
                          if (!!h.isTypeVar(t) && !h.isParamSpec(t) && !h.TypeVarType.hasConstraints(t)) {
                            a = f.addConditionToType(a, [{
                              typeVar: t,
                              constraintIndex: 0
                            }]);
                          }
                          I.push(f.addConditionToType(a, (b = o.props) === null || b === undefined ? undefined : b.condition));
                        }
                      }
                    }
                  }
                } else {
                  if (h.isAnyOrUnknown(t) || f.derivesFromAnyOrUnknown(t) && !h.isTypeSame(o, n)) {
                    I.push(f.addConditionToType(t, m));
                  }
                }
              } else {
                if (h.isTypeVar(g) && h.TypeBase.isInstantiable(g)) {
                  if (h.TypeBase.isInstance(t)) {
                    if (h.isTypeVar(t) && h.isTypeSame(f.convertToInstance(g), t)) {
                      if (r) {
                        I.push(t);
                      } else {
                        k = true;
                      }
                    } else {
                      if (r) {
                        I.push(f.convertToInstance(g));
                      } else {
                        I.push(t);
                        w = true;
                      }
                    }
                  }
                } else {
                  if (h.isFunction(g)) {
                    let n = false;
                    if (h.isClass(o)) {
                      n = !!h.TypeBase.isInstantiable(t) || !!f.lookUpClassMember(o, '__call__', 16);
                    }
                    if (n) {
                      if (r) {
                        I.push(f.convertToInstantiable(t));
                      } else {
                        k = true;
                      }
                    } else {
                      if (e.assignType(c(o), g, undefined, undefined, 16384)) {
                        if (r) {
                          I.push(f.addConditionToType(g, (_ = o.props) === null || _ === undefined ? undefined : _.condition));
                        }
                      } else {
                        if (s && r) {
                          const e = `<callable subtype of ${o.shared.name}>`;
                          const t = l.getFileInfo(i);
                          let n = h.ClassType.createInstantiable(e, u.getClassFullName(i, t.moduleName, e), t.moduleName, t.fileUri, 0, u.getTypeSourceId(i), undefined, o.shared.effectiveMetaclass, o.shared.docString);
                          n.shared.baseClasses = [o];
                          f.computeMroLinearization(n);
                          n = f.addConditionToType(n, (C = o.props) === null || C === undefined ? undefined : C.condition);
                          const a = h.FunctionType.createSynthesizedInstance('__call__');
                          const r = h.FunctionParam.create(0, h.ClassType.cloneAsInstance(n), h.FunctionParamFlags.TypeDeclared, 'self');
                          h.FunctionType.addParam(a, r);
                          h.FunctionType.addDefaultParams(a);
                          a.shared.declaredReturnType = h.UnknownType.create();
                          h.ClassType.getSymbolTable(n).set('__call__', y.Symbol.createWithType(4, a));
                          I.push(h.ClassType.cloneAsInstance(n));
                        }
                      }
                    }
                  }
                }
              }
            }
            if (!r && (!k || !!w)) {
              I.push(f.convertToInstantiable(g));
            }
            return I.map(e => f.convertToInstance(e));
          };
          const g = t => h.isInstantiableClass(t) && e.getCallbackProtocolType(h.ClassType.cloneAsInstance(t)) !== undefined;
          const T = (t, s) => {
            const i = [];
            if (r) {
              for (const r of n) {
                const n = e.makeTopLevelTypeVarsConcrete(r);
                if (!a && g(n)) {
                  i.push(f.convertToInstance(t));
                } else {
                  if (e.assignType(c(t), f.convertToInstance(n))) {
                    if (h.isFunction(r)) {
                      i.push(f.convertToInstance(s));
                    } else {
                      i.push(f.convertToInstance(r));
                    }
                  } else {
                    if (e.assignType(f.convertToInstance(c(n)), t)) {
                      i.push(f.convertToInstance(t));
                    }
                  }
                }
              }
            } else {
              if (n.every(n => {
                const r = e.makeTopLevelTypeVarsConcrete(n);
                if (!a && g(r)) {
                  return false;
                }
                if (h.isFunction(r) && h.FunctionType.isGradualCallableForm(r)) {
                  return false;
                }
                const s = e.assignType(f.convertToInstance(c(r)), t);
                const i = e.assignType(c(t), f.convertToInstance(r));
                return !s || i;
              })) {
                i.push(f.convertToInstance(t));
              }
            }
            return i;
          };
          const v = () => n.some(e => !!f.isNoneTypeClass(e) || h.isInstantiableClass(e) && h.ClassType.isBuiltIn(e, 'NoneType'));
          const b = [];
          const _ = [];
          const C = e.mapSubtypesExpandTypeVars(o, {
            expandCallback: t => e.expandPromotionTypes(i, t)
          }, (t, a) => {
            const s = f.getTypeCondition(t) ? t : a;
            if (r && h.isAnyOrUnknown(t)) {
              b.push(h.combineTypes(n.map(e => f.convertToInstance(e))));
              _.push(t);
              return;
            }
            if (f.isNoneInstance(t)) {
              if (v() === r) {
                return t;
              } else {
                return undefined;
              }
            }
            if ((h.isModule(t) || h.isClassInstance(t) && h.ClassType.isBuiltIn(t, 'ModuleType')) && r) {
              const t = n.filter(t => {
                const n = e.makeTopLevelTypeVarsConcrete(t);
                return h.isInstantiableClass(n) && h.ClassType.isProtocolClass(n);
              });
              if (t.length > 0) {
                return f.convertToInstance(h.combineTypes(t));
              }
            }
            if (h.isClass(t)) {
              return h.combineTypes(m(a, h.ClassType.cloneAsInstantiable(t), f.getTypeCondition(t), s));
            } else {
              if (h.isFunction(t) || h.isOverloaded(t)) {
                return h.combineTypes(T(t, a));
              } else {
                if (r) {
                  return undefined;
                } else {
                  return s;
                }
              }
            }
          });
          if (h.isNever(C) && b.length > 0) {
            return h.combineTypes(b);
          }
          if (h.isNever(C) && _.length > 0) {
            return h.combineTypes(_);
          }
          return C;
        }(e, c, g, r, s, i, o);
        if (m) {
          return f.convertToInstantiable(T);
        } else {
          return T;
        }
      });
      return c;
    }
    function x(e, t, n) {
      var a;
      var r;
      i.assert(h.isInstantiableClass(t) && h.isInstantiableClass(n));
      i.assert(h.ClassType.isSameGenericClass(t, n));
      i.assert(((a = t.priv) === null || a === undefined ? undefined : a.literalValue) === undefined);
      i.assert(((r = n.priv) === null || r === undefined ? undefined : r.literalValue) === undefined);
      if (h.ClassType.isBuiltIn(t, 'tuple')) {
        return function (e, t) {
          var n;
          var a;
          if (!t.priv.tupleTypeArgs || f.isTupleGradualForm(t)) {
            return f.addConditionToType(e, (n = t.props) === null || n === undefined ? undefined : n.condition);
          }
          if (!e.priv.tupleTypeArgs || f.isTupleGradualForm(e)) {
            return f.addConditionToType(t, (a = e.props) === null || a === undefined ? undefined : a.condition);
          }
          return;
        }(t, t);
      }
    }
    function P(e, t, n, a, r) {
      return f.mapSubtypes(t, t => {
        const s = e.makeTopLevelTypeVarsConcrete(t);
        if (!h.isClassInstance(s) || !f.isTupleClass(s) || !s.priv.tupleTypeArgs) {
          return t;
        }
        if (s.priv.tupleTypeArgs.some(e => h.isUnpackedTypeVarTuple(e.type))) {
          return t;
        }
        if (!s.priv.tupleTypeArgs.some(e => e.isUnbounded)) {
          if ((r ? s.priv.tupleTypeArgs.length < n : s.priv.tupleTypeArgs.length === n) === a) {
            return t;
          } else {
            return undefined;
          }
        }
        const i = n - s.priv.tupleTypeArgs.length + 1;
        if (!r) {
          if (i < 0) {
            if (a) {
              return undefined;
            } else {
              return t;
            }
          }
          if (!a) {
            const e = s.priv.tupleTypeArgs.length - 1;
            if (n === e) {
              return D(s, 1, true);
            } else {
              return t;
            }
          }
          return D(s, i, false);
        }
        if (h.isParamSpec(t) && t.priv.paramSpecAccess) {
          return t;
        }
        if (i > 32) {
          return t;
        }
        if (a) {
          if (i < 1) {
            return;
          }
          const e = [];
          for (let t = 0; t < i; t++) {
            e.push(D(s, t, false));
          }
          return h.combineTypes(e);
        }
        return D(s, i, true);
      });
    }
    function D(e, t, n) {
      const a = [];
      e.priv.tupleTypeArgs.forEach(e => {
        if (e.isUnbounded) {
          for (let n = 0; n < t; n++) {
            a.push({
              isUnbounded: false,
              type: e.type
            });
          }
          if (n) {
            a.push(e);
          }
        } else {
          a.push(e);
        }
      });
      return f.specializeTupleClass(e, a);
    }
    function N(e, t, n, a) {
      if (a) {
        const a = F(n);
        if (a) {
          return E(e, t, e.makeTopLevelTypeVarsConcrete(a));
        } else {
          return t;
        }
      }
      if (!h.isClassInstance(n) || !h.ClassType.isBuiltIn(n, 'tuple') || !n.priv.tupleTypeArgs) {
        return t;
      }
      const r = [];
      n.priv.tupleTypeArgs.forEach(e => {
        if (!e.isUnbounded) {
          if (f.isNoneInstance(e.type) || h.isClassInstance(e.type) && f.isLiteralType(e.type)) {
            r.push(e.type);
          }
        }
      });
      if (r.length === 0) {
        return t;
      } else {
        return f.mapSubtypes(t, t => {
          t = e.makeTopLevelTypeVarsConcrete(t);
          if (h.isClassInstance(t) && t.priv.literalValue === undefined) {
            const n = j(e, t);
            if (n && n.length > 0) {
              return h.combineTypes(n.filter(e => !r.some(t => h.isTypeSame(t, e))));
            }
          }
          if (!r.some(e => h.isTypeSame(e, t))) {
            return t;
          }
        });
      }
    }
    function F(e) {
      if (!h.isClassInstance(e) || !h.ClassType.isBuiltIn(e, ['list', 'set', 'frozenset', 'deque', 'tuple', 'dict', 'defaultdict', 'OrderedDict'])) {
        return;
      }
      if (!e.priv.typeArgs || e.priv.typeArgs.length < 1) {
        return;
      }
      let t = e.priv.typeArgs[0];
      if (f.isTupleClass(e) && e.priv.tupleTypeArgs) {
        t = h.combineTypes(e.priv.tupleTypeArgs.map(e => e.type));
      }
      return t;
    }
    function E(e, t, n) {
      return e.mapSubtypesExpandTypeVars(t, undefined, t => f.mapSubtypes(n, n => {
        if (h.isAnyOrUnknown(n)) {
          return t;
        } else {
          if (e.assignType(t, n)) {
            return f.stripTypeForm(f.addConditionToType(n, t.props?.condition));
          } else {
            if (e.assignType(n, t)) {
              return f.stripTypeForm(f.addConditionToType(t, n.props?.condition));
            } else {
              return undefined;
            }
          }
        }
      }));
    }
    function M(e, t, n, a) {
      return e.mapSubtypesExpandTypeVars(t, undefined, (t, r) => {
        var s;
        var i;
        if (h.isParamSpec(r)) {
          return r;
        }
        if (h.isClassInstance(t) && h.ClassType.isTypedDictClass(t)) {
          const r = g.getTypedDictMembersForClass(e, t, true);
          const o = (s = r.knownItems.get(n.priv.literalValue)) !== null && s !== undefined ? s : r.extraItems;
          if (a) {
            if (!o) {
              return;
            }
            if (o.isRequired || o.isProvided) {
              return t;
            }
            const e = new Map((i = t.priv.typedDictNarrowedEntries) !== null && i !== undefined ? i : []);
            e.set(n.priv.literalValue, {
              valueType: o.valueType,
              isReadOnly: o.isReadOnly,
              isRequired: false,
              isProvided: true
            });
            return h.ClassType.cloneAsInstance(h.ClassType.cloneForNarrowedTypedDictEntries(h.ClassType.cloneAsInstantiable(t), e));
          }
          if (o !== undefined && (o.isRequired || o.isProvided)) {
            return undefined;
          } else {
            return t;
          }
        }
        return t;
      });
    }
    function O(e, t, n, a, r) {
      let s = true;
      const i = f.mapSubtypes(t, t => {
        if (h.isClassInstance(t) && h.ClassType.isTypedDictClass(t)) {
          const s = g.getTypedDictMembersForClass(e, t).knownItems.get(n.priv.literalValue);
          if (s && f.isLiteralTypeOrUnion(s.valueType)) {
            if (r) {
              let n = false;
              f.doForEachSubtype(a, t => {
                if (e.assignType(s.valueType, t)) {
                  n = true;
                }
              });
              if (n) {
                return t;
              } else {
                return undefined;
              }
            }
            {
              let n = false;
              f.doForEachSubtype(a, t => {
                if (!e.assignType(t, s.valueType)) {
                  n = true;
                }
              });
              if (n) {
                return t;
              } else {
                return undefined;
              }
            }
          }
        }
        s = false;
        return t;
      });
      if (s) {
        return i;
      } else {
        return t;
      }
    }
    function z(e, t, n, a, r) {
      let s = true;
      const i = f.mapSubtypes(t, t => {
        if (h.isClassInstance(t) && h.ClassType.isTupleClass(t) && !f.isUnboundedTupleClass(t) && typeof n.priv.literalValue == 'number' && h.isClassInstance(a)) {
          const s = n.priv.literalValue;
          if (t.priv.tupleTypeArgs && s >= 0 && s < t.priv.tupleTypeArgs.length) {
            const n = t.priv.tupleTypeArgs[s]?.type;
            if (n && f.isLiteralTypeOrUnion(n)) {
              if (r) {
                if (e.assignType(n, a)) {
                  return t;
                } else {
                  return undefined;
                }
              } else {
                if (e.assignType(a, n)) {
                  return undefined;
                } else {
                  return t;
                }
              }
            }
          }
        }
        s = false;
        return t;
      });
      if (s) {
        return i;
      } else {
        return t;
      }
    }
    function U(e, t, n, a, r) {
      return f.mapSubtypes(t, t => {
        let i;
        if (h.isClassInstance(t)) {
          i = f.lookUpObjectMember(t, n);
        } else {
          if (h.isInstantiableClass(t)) {
            i = f.lookUpClassMember(t, n);
          }
        }
        if (i && i.isTypeDeclared) {
          let n = e.getTypeOfMember(i);
          if (h.isClassInstance(t) && h.isClassInstance(n) && f.isProperty(n)) {
            const e = n.priv.fgetInfo?.methodType;
            if (e && e.shared.declaredReturnType) {
              const t = h.FunctionType.getEffectiveReturnType(e);
              if (t) {
                n = t;
              }
            }
          }
          if (f.isLiteralTypeOrUnion(n, true)) {
            if (r) {
              if (e.assignType(n, a)) {
                return t;
              } else {
                return undefined;
              }
            } else {
              if (e.assignType(a, n)) {
                return undefined;
              } else {
                return t;
              }
            }
          }
        }
        return t;
      });
    }
    function V(e, t, n, a) {
      return f.mapSubtypes(t, t => {
        let r;
        if (h.isClassInstance(t)) {
          r = f.lookUpObjectMember(t, n);
        } else {
          if (h.isInstantiableClass(t)) {
            r = f.lookUpClassMember(t, n);
          }
        }
        if (r && r.isTypeDeclared) {
          const t = e.makeTopLevelTypeVarsConcrete(e.getTypeOfMember(r));
          let n = true;
          if (a) {
            f.doForEachSubtype(t, t => {
              t = e.makeTopLevelTypeVarsConcrete(t);
              if (f.isProperty(t) || f.isMaybeDescriptorInstance(t)) {
                n = false;
              }
              if (h.isAnyOrUnknown(t) || f.isNoneInstance(t) || h.isNever(t)) {
                n = false;
              }
            });
          } else {
            n = f.isNoneInstance(t);
          }
          if (n) {
            return;
          }
        }
        return t;
      });
    }
    function R(e, t, n, a) {
      return e.mapSubtypesExpandTypeVars(t, undefined, (e, t) => {
        var r;
        if (h.isClassInstance(e)) {
          const t = h.ClassType.isDerivedFrom(n, h.ClassType.cloneAsInstantiable(e));
          if (a) {
            if (t) {
              if (h.ClassType.isSameGenericClass(h.ClassType.cloneAsInstantiable(e), n)) {
                return f.addConditionToType(e, f.getTypeCondition(n));
              } else {
                return f.addConditionToType(h.ClassType.cloneAsInstance(n), (r = e.props) === null || r === undefined ? undefined : r.condition);
              }
            }
            if (!n.priv.includeSubclasses) {
              return;
            }
          } else {
            if (!n.priv.includeSubclasses) {
              if (t && h.ClassType.isFinal(e)) {
                return;
              }
              return e;
            }
          }
        } else {
          if (h.isAnyOrUnknown(e)) {
            if (a) {
              return h.ClassType.cloneAsInstance(f.addConditionToType(n, f.getTypeCondition(e)));
            } else {
              return e;
            }
          }
        }
        return t;
      });
    }
    function L(e, t, n, a) {
      return f.mapSubtypes(t, t => {
        let r = e.makeTopLevelTypeVarsConcrete(t);
        if (a) {
          if (h.isClassInstance(r) && h.TypeBase.isInstance(t) && h.ClassType.isBuiltIn(r, 'type')) {
            r = r.priv.typeArgs && r.priv.typeArgs.length > 0 ? f.convertToInstantiable(r.priv.typeArgs[0]) : h.UnknownType.create();
          }
          if (h.isAnyOrUnknown(r)) {
            return f.addConditionToType(n, f.getTypeCondition(r));
          }
          if (h.isClass(r)) {
            if (h.TypeBase.isInstance(r)) {
              if (h.ClassType.isBuiltIn(r, 'object')) {
                return n;
              } else {
                return undefined;
              }
            }
            const e = function (e, t, n, a) {
              if (h.isTypeVar(n) || a.priv.literalValue !== undefined) {
                return h.isTypeSame(f.convertToInstance(n), e);
              }
              if (a.priv.includeSubclasses) {
                return false;
              }
              if (h.ClassType.isDerivedFrom(t, a)) {
                return true;
              }
              if (h.ClassType.isBuiltIn(a, 'dict') && h.ClassType.isTypedDictClass(t)) {
                return true;
              }
              return false;
            }(t, r, n, n);
            if (!n.priv.includeSubclasses) {
              if (!r.priv.includeSubclasses) {
                if (h.ClassType.isSameGenericClass(r, n)) {
                  return n;
                } else {
                  return undefined;
                }
              }
              if (e) {
                return f.addConditionToType(n, f.getTypeCondition(r));
              }
              if (h.ClassType.isDerivedFrom(n, r)) {
                return f.addConditionToType(n, f.getTypeCondition(r));
              } else {
                return undefined;
              }
            }
            if (h.ClassType.isFinal(r) && !e) {
              return;
            }
          }
        } else {
          if (h.isInstantiableClass(r) && h.ClassType.isSameGenericClass(n, r) && h.ClassType.isFinal(n)) {
            return;
          }
        }
        return t;
      });
    }
    function B(e, t, n, a, r) {
      return e.mapSubtypesExpandTypeVars(t, undefined, t => {
        t = e.makeTopLevelTypeVarsConcrete(t);
        if (h.isAnyOrUnknown(t)) {
          if (a) {
            return n;
          } else {
            return t;
          }
        }
        if (h.isClassInstance(t) && h.ClassType.isSameGenericClass(n, t)) {
          if (t.priv.literalValue !== undefined) {
            const e = h.ClassType.isLiteralValueSame(t, n);
            if (e && !a || !e && a) {
              return;
            }
            return t;
          }
          if (a) {
            return n;
          }
          {
            const a = j(e, t);
            if (a && a.length > 0) {
              return h.combineTypes(a.filter(e => !h.ClassType.isLiteralValueSame(e, n)));
            }
          }
        } else {
          if (a && (r || f.isNoneInstance(t))) {
            if (e.assignType(t, n)) {
              return n;
            } else {
              return undefined;
            }
          }
        }
        return t;
      });
    }
    function j(e, t) {
      if (h.ClassType.isBuiltIn(t, 'bool')) {
        return [h.ClassType.cloneWithLiteral(t, true), h.ClassType.cloneWithLiteral(t, false)];
      }
      if (h.ClassType.isEnumClass(t)) {
        if (t.shared.baseClasses.some(e => h.isClass(e) && h.ClassType.isBuiltIn(e, 'Flag'))) {
          return;
        }
        const n = [];
        h.ClassType.getSymbolTable(t).forEach((a, r) => {
          var s;
          if (!a.isIgnoredForProtocolMatch()) {
            let i = e.getEffectiveTypeOfSymbol(a);
            i = (s = c.transformTypeForEnumMember(e, t, r)) !== null && s !== undefined ? s : i;
            if (h.isClassInstance(i) && h.ClassType.isSameGenericClass(t, i) && i.priv.literalValue !== undefined) {
              n.push(i);
            }
          }
        });
        return n;
      }
    }
  },
  55501: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.printType = function (e, t, n) {
      const a = new k(t, n);
      a.build(e);
      return f(e, t, n, a, [], 0);
    };
    exports.printFunctionParts = function (e, t, n) {
      const a = new k(t, n);
      a.build(e);
      return b(e, t, n, a, [], 0);
    };
    exports.printObjectTypeForClass = function (e, t, n) {
      const a = new k(t, n);
      a.build(e);
      return v(e, t, n, a, [], 0);
    };
    exports.isLiteralValueTruncated = y;
    exports.printLiteralValueTruncated = g;
    exports.printLiteralValue = h;
    const i = require(58147);
    const o = require(48281);
    const l = require(44321);
    const p = __importStar(require(41557));
    const d = require(14400);
    const c = require(21024);
    const u = require(92324);
    const m = 50;
    function y(e) {
      return typeof e.priv.literalValue == 'string' && e.priv.literalValue.length > m;
    }
    function g(e) {
      if (e.shared.name === 'bytes') {
        return 'bytes';
      } else {
        o.assert(e.shared.name === 'str');
        return 'LiteralString';
      }
    }
    function h(e, t = '\'') {
      const n = e.priv.literalValue;
      if (n === undefined) {
        return '';
      }
      let a;
      if (typeof n == 'string') {
        let r = n;
        if (n.length > m) {
          r = n.substring(0, m) + '';
        }
        a = e.shared.name === 'bytes' ? d.printBytesLiteral(r) : d.printStringLiteral(r, t);
      } else {
        if (typeof n == 'boolean') {
          a = n ? 'True' : 'False';
        } else {
          if (n instanceof c.EnumLiteral) {
            a = `${n.className}.${n.itemName}`;
          } else {
            if (typeof n == 'bigint') {
              a = n.toString();
              if (a.endsWith('n')) {
                a = a.substring(0, a.length - 1);
              }
            } else {
              a = n.toString();
            }
          }
        }
      }
      return a;
    }
    function f(e, t, n, a, r, s) {
      var i;
      var o;
      var l;
      var p;
      if (s > c.maxTypeRecursionCount) {
        if (t & 256) {
          return 'Any';
        } else {
          return '<Recursive>';
        }
      }
      s++;
      const d = t;
      const m = !!(t & 16);
      t &= -145;
      const b = (i = e.props) === null || i === undefined ? undefined : i.typeAliasInfo;
      if (b) {
        let i = true;
        if (t & 32) {
          if (r.find(t => t === e)) {
            i = false;
          }
        } else {
          i = false;
        }
        if (!i) {
          try {
            r.push(e);
            let i = t & 4096 ? b.shared.fullName : b.shared.name;
            if (!a.isUnique(i)) {
              i = b.shared.fullName;
            }
            const o = b.shared.typeParams;
            if (o && o.length > 0) {
              let e;
              if (b.typeArgs) {
                if (!(t & 2) || !!b.typeArgs.some(e => !c.isUnknown(e))) {
                  e = [];
                  b.typeArgs.forEach((i, l) => {
                    const p = l < o.length ? o[l] : o[o.length - 1];
                    if (c.isTypeVarTuple(p) && c.isClassInstance(i) && u.isTupleClass(i) && i.priv.tupleTypeArgs && i.priv.tupleTypeArgs.every(e => !e.isUnbounded)) {
                      i.priv.tupleTypeArgs.forEach(i => {
                        e.push(f(i.type, t, n, a, r, s));
                      });
                    } else {
                      e.push(f(i, t, n, a, r, s));
                    }
                  });
                }
              } else {
                if (!(t & 2) || !!o.some(e => !c.isUnknown(e))) {
                  e = [];
                  o.forEach(i => {
                    e.push(f(i, t, n, a, r, s));
                  });
                }
              }
              if (e) {
                if (e.length === 0) {
                  i += '[()]';
                } else {
                  i += `[${e.join(', ')}]`;
                }
              }
            }
            if (e.category !== 9) {
              return i;
            }
          } finally {
            r.pop();
          }
        }
      }
      if (r.find(t => {
        var n;
        return t === e || !!((n = t.props) === null || n === undefined ? undefined : n.typeAliasInfo) && t.props.typeAliasInfo.shared.fullName === (b == null ? undefined : b.shared.fullName);
      }) || r.length > c.maxTypeRecursionCount) {
        if (c.isTypeVar(e) && e.shared.isSynthesized && e.shared.recursiveAlias) {
          return e.shared.recursiveAlias.name;
        }
        if (b) {
          if (!b.shared.typeParams) {
            let e = t & 4096 ? b.shared.fullName : b.shared.name;
            if (!a.isUnique(e)) {
              e = b.shared.fullName;
            }
            return e;
          }
          try {
            r.push(e);
            return f(e, t & -33, n, a, r, s);
          } finally {
            r.pop();
          }
        }
        return '...';
      }
      try {
        r.push(e);
        const i = !(t & 320);
        const b = e => {
          var t;
          if (((t = e.props) === null || t === undefined ? undefined : t.condition) && i) {
            return '*';
          } else {
            return '';
          }
        };
        const k = (e, t) => `${C(e, t)}${b(e)}`;
        switch (e.category) {
          case 0:
            if (t & 256) {
              return 'Any';
            } else {
              return 'Unbound';
            }
          case 1:
            if (t & 257) {
              return 'Any';
            } else {
              return 'Unknown';
            }
          case 7:
            if (t & 256) {
              return 'Any';
            } else {
              return `Module("${e.priv.moduleName}")`;
            }
          case 6:
            if (c.TypeBase.isInstance(e)) {
              if (e.priv.literalValue !== undefined) {
                if (y(e) && t & 256) {
                  return g(e);
                } else {
                  return `Literal[${h(e)}]`;
                }
              } else {
                return `${v(e, t, n, a, r, s)}${b(e)}`;
              }
            }
            {
              let i;
              if (e.priv.literalValue !== undefined) {
                i = y(e) && t & 256 ? g(e) : `Literal[${h(e)}]`;
                return k(e, i);
              }
              if ((o = e.props) === null || o === undefined ? undefined : o.specialForm) {
                return f(e.props.specialForm, t, n, a, r, s);
              }
              i = v(e, t, n, a, r, s);
              return k(e, i);
            }
          case 4:
            if (c.TypeBase.isInstantiable(e)) {
              return `type[${T(c.FunctionType.cloneAsInstance(e), t, n, a, r, s)}]`;
            }
            return T(e, d, n, a, r, s);
          case 5:
            {
              const i = c.OverloadedType.getOverloads(e).map(e => f(e, t, n, a, r, s));
              if (t & 256) {
                return 'Callable[..., Any]';
              } else {
                if (i.length === 1) {
                  return i[0];
                } else {
                  return `Overload[${i.join(', ')}]`;
                }
              }
            }
          case 8:
            if (c.TypeBase.isInstantiable(e) && ((l = e.props) === null || l === undefined ? undefined : l.specialForm) && !((p = e.props) === null || p === undefined ? undefined : p.typeAliasInfo)) {
              return f(e.props.specialForm, t, n, a, r, s);
            }
            return function (e, t, n, a, r, s, i) {
              const o = new Set();
              const l = new Set();
              if (!(t & 32) && e.priv.typeAliasSources) {
                for (const n of e.priv.typeAliasSources) {
                  let p = true;
                  let d = true;
                  const m = new Set();
                  for (const t of n.priv.subtypes) {
                    let n = 0;
                    let a = false;
                    const r = u.convertToInstance(t);
                    for (const t of e.priv.subtypes) {
                      if (c.isTypeSame(r, t)) {
                        if (!o.has(n)) {
                          d = false;
                        }
                        m.add(n);
                        a = true;
                        break;
                      }
                      n++;
                    }
                    if (!a) {
                      p = false;
                      break;
                    }
                  }
                  if (p && !d) {
                    l.add(f(n, t, a, r, s, i));
                    m.forEach(e => o.add(e));
                  }
                }
              }
              const p = e.priv.subtypes.findIndex(e => u.isNoneInstance(e));
              if (p >= 0 && !o.has(p)) {
                const o = u.removeNoneFromUnion(e);
                if (c.isNever(o)) {
                  return 'None';
                }
                const l = f(o, t, a, r, s, i);
                if (t & 8) {
                  const e = l + ' | None';
                  if (n) {
                    return `(${e})`;
                  } else {
                    return e;
                  }
                }
                return `Optional[${l}]`;
              }
              const d = new Set();
              const m = new Set();
              u.doForEachSubtype(e, (e, n) => {
                if (!o.has(n)) {
                  if (c.isClassInstance(e) && e.priv.literalValue !== undefined) {
                    if (y(e) && t & 256) {
                      l.add(g(e));
                    } else {
                      d.add(h(e));
                    }
                  } else {
                    if (c.isInstantiableClass(e) && e.priv.literalValue !== undefined) {
                      if (y(e) && t & 256) {
                        l.add(`type[${g(e)}]`);
                      } else {
                        m.add(h(e));
                      }
                    } else {
                      l.add(f(e, t, a, r, s, i));
                    }
                  }
                }
              });
              const T = [];
              l.forEach(e => T.push(e));
              if (d.size > 0) {
                const e = [];
                d.forEach(t => e.push(t));
                T.push(`Literal[${e.join(', ')}]`);
              }
              if (m.size > 0) {
                const e = [];
                m.forEach(t => e.push(t));
                T.push(`type[Literal[${e.join(', ')}]]`);
              }
              if (T.length === 1) {
                return T[0];
              }
              if (t & 8) {
                const e = T.join(' | ');
                if (n) {
                  return `(${e})`;
                } else {
                  return e;
                }
              }
              return `Union[${T.join(', ')}]`;
            }(e, t & 8 ? t | 128 : t, m, n, a, r, s);
          case 9:
            {
              if (e.shared.isSynthesized) {
                if (e.shared.recursiveAlias) {
                  if (t & 32 && e.shared.boundType) {
                    return f(c.TypeBase.isInstance(e) ? u.convertToInstance(e.shared.boundType) : e.shared.boundType, t, n, a, r, s);
                  } else {
                    return e.shared.recursiveAlias.name;
                  }
                }
                if (c.TypeVarType.isSelf(e) && e.shared.boundType) {
                  let i = f(e.shared.boundType, t & -33, n, a, r, s);
                  if (!c.isAnyOrUnknown(e.shared.boundType)) {
                    i = t & 256 || t & 8192 ? 'Self' : `Self@${i}`;
                  }
                  if (c.TypeBase.isInstantiable(e)) {
                    return `${C(e, i)}`;
                  } else {
                    return i;
                  }
                }
                if (t & 257) {
                  return 'Any';
                } else {
                  return 'Unknown';
                }
              }
              if (c.isParamSpec(e)) {
                const n = I(e, !(t & 256) && !(t & 8192));
                if (e.priv.paramSpecAccess) {
                  return `${n}.${e.priv.paramSpecAccess}`;
                } else {
                  return n;
                }
              }
              let i = I(e, !(t & 256) && !(t & 8192));
              if (e.priv.isUnpacked) {
                i = _(i, t);
              }
              if (c.isTypeVarTuple(e) && e.priv.isInUnion) {
                i = `Union[${i}]`;
              }
              if (c.TypeBase.isInstantiable(e)) {
                i = `${C(e, i)}`;
              }
              if (!c.isTypeVarTuple(e) && t & 2048) {
                const t = function (e) {
                  var t;
                  const n = (t = e.priv.computedVariance) !== null && t !== undefined ? t : e.shared.declaredVariance;
                  if (n === 2) {
                    return 'invariant';
                  }
                  if (n === 3) {
                    return 'covariant';
                  }
                  if (n === 4) {
                    return 'contravariant';
                  }
                  return '';
                }(e);
                if (t) {
                  i = `${i} (${t})`;
                }
              }
              return i;
            }
          case 3:
            if (e.priv.isNoReturn) {
              return 'NoReturn';
            } else {
              return 'Never';
            }
          case 2:
            if (e.priv.isEllipsis) {
              return '...';
            } else {
              return 'Any';
            }
        }
        return '';
      } finally {
        r.pop();
      }
    }
    function T(e, t, n, a, r, s) {
      if (t & 256) {
        const i = c.FunctionType.getParamSpecFromArgsKwargs(e);
        const o = i ? c.FunctionType.cloneRemoveParamSpecArgsKwargs(e) : e;
        let l = false;
        if (o.shared.parameters.length === 0) {
          l = true;
        } else {
          if (o.shared.parameters.every(e => e.category === 0)) {
            if (!o.shared.parameters[o.shared.parameters.length - 1].name) {
              l = true;
            }
          }
        }
        const p = n(o);
        let d = 'Any';
        if (p) {
          d = f(p, t, n, a, r, s);
        }
        if (l) {
          const e = [];
          o.shared.parameters.forEach((i, l) => {
            if (i.name) {
              const i = c.FunctionType.getParamType(o, l);
              if (r.length < c.maxTypeRecursionCount) {
                e.push(f(i, t, n, a, r, s));
              } else {
                e.push('Any');
              }
            }
          });
          if (i) {
            if (e.length > 0) {
              return `Callable[Concatenate[${e.join(', ')}, ${i.shared.name}], ${d}]`;
            } else {
              return `Callable[${i.shared.name}, ${d}]`;
            }
          } else {
            return `Callable[[${e.join(', ')}], ${d}]`;
          }
        }
        return `Callable[..., ${d}]`;
      }
      {
        const i = b(e, t, n, a, r, s);
        const o = `(${i[0].join(', ')})`;
        if (c.FunctionType.isParamSpecValue(e)) {
          if (i[0].length === 1 && i[0][0] === '...') {
            return i[0][0];
          } else {
            return o;
          }
        }
        const l = `${o} -> ${i[1]}`;
        if (t & 128) {
          return `(${l})`;
        } else {
          return l;
        }
      }
    }
    function v(e, t, n, a, r, s) {
      var o;
      var l;
      let p = e.priv.aliasName;
      if (!p) {
        p = t & 4096 ? e.shared.fullName : e.shared.name;
      }
      if (c.ClassType.isBuiltIn(e, 'NoneType')) {
        p = 'None';
      }
      if (!a.isUnique(p)) {
        p = e.shared.fullName;
      }
      if (!c.ClassType.isPseudoGenericClass(e)) {
        const d = c.ClassType.getTypeParams(e);
        const u = d.length > 0 ? d[d.length - 1] : undefined;
        const m = !!u && c.isTypeVarTuple(u);
        const y = (o = e.priv.tupleTypeArgs) !== null && o !== undefined ? o : (l = e.priv.typeArgs) === null || l === undefined ? undefined : l.map(e => ({
          type: e,
          isUnbounded: false
        }));
        if (y) {
          if (y.length > 0) {
            const o = [];
            let l = true;
            y.forEach((e, p) => {
              const u = p < d.length ? d[p] : undefined;
              if (u && c.isTypeVarTuple(u) && c.isClassInstance(e.type) && c.ClassType.isBuiltIn(e.type, 'tuple') && e.type.priv.tupleTypeArgs) {
                if (e.type.priv.tupleTypeArgs.length === 0) {
                  if (!c.isUnknown(e.type)) {
                    l = false;
                  }
                  if (p === 0) {
                    o.push(_('tuple[()]', t));
                  }
                } else {
                  i.appendArray(o, e.type.priv.tupleTypeArgs.map(e => {
                    if (!c.isUnknown(e.type)) {
                      l = false;
                    }
                    const i = f(e.type, t, n, a, r, s);
                    if (e.isUnbounded) {
                      return _(`tuple[${i}, ...]`, t);
                    } else {
                      return i;
                    }
                  }));
                }
              } else {
                if (!c.isUnknown(e.type)) {
                  l = false;
                }
                const i = f(e.type, t, n, a, r, s);
                if (e.isUnbounded) {
                  if (y.length === 1) {
                    o.push(i, '...');
                  } else {
                    o.push(_(`tuple[${i}, ...]`, t));
                  }
                } else {
                  o.push(i);
                }
              }
            });
            if (e.priv.isUnpacked) {
              p = _(p, t);
            }
            if (!(t & 2) || !l) {
              p += `[${o.join(', ')}]`;
            }
          } else {
            if (e.priv.isUnpacked) {
              p = _(p, t);
            }
            if (c.ClassType.isTupleClass(e) || m) {
              p += '[()]';
            }
          }
        } else {
          if (e.priv.isUnpacked) {
            p = _(p, t);
          }
          if (d.length > 0) {
            if (!(t & 2) || !!d.some(e => !c.isUnknown(e))) {
              p += `[${d.map(e => f(e, t, n, a, r, s)).join(', ')}]`;
            }
          }
        }
      }
      if (e.priv.isTypedDictPartial) {
        if (!(t & 256)) {
          p = `Partial[${p}]`;
        }
      }
      return p;
    }
    function b(e, t, n, a, r, s) {
      const i = [];
      let o = false;
      const d = c.FunctionType.getParamSpecFromArgsKwargs(e);
      if (d) {
        e = c.FunctionType.cloneRemoveParamSpecArgsKwargs(e);
      }
      e.shared.parameters.forEach((d, u) => {
        const m = c.FunctionType.getParamType(e, u);
        const y = c.FunctionType.getParamDefaultType(e, u);
        if (u === e.shared.parameters.length - 1 && d.category === 1 && c.isTypeVarTuple(m)) {
          const o = c.FunctionType.getParamType(e, u);
          if (c.isClassInstance(o) && c.ClassType.isBuiltIn(o, 'tuple') && o.priv.tupleTypeArgs) {
            o.priv.tupleTypeArgs.forEach(e => {
              const o = f(e.type, t, n, a, r, s);
              i.push(o);
            });
            return;
          }
        }
        if (l.isTypedKwargs(d, m) && t & 1024 && m.category === 6) {
          m.shared.typedDictEntries.knownItems.forEach((e, o) => {
            const l = f(e.valueType, t, n, a, r, s);
            i.push(`${o}: ${l}`);
          });
          return;
        }
        let g = '';
        if (d.category === 1) {
          if (!d.name || !c.FunctionParam.isNameSynthesized(d)) {
            g += '*';
          }
        } else {
          if (d.category === 2) {
            g += '**';
          }
        }
        let h = false;
        if (d.name && !c.FunctionParam.isNameSynthesized(d)) {
          g += d.name;
          o = true;
          h = true;
        } else {
          if (t & 256) {
            g += `__p${u}`;
            o = true;
            h = true;
          }
        }
        let T = '=';
        let v = false;
        if (d.name) {
          if (c.FunctionParam.isTypeDeclared(d) || c.FunctionParam.isTypeInferred(d)) {
            const i = c.FunctionType.getParamType(e, u);
            let o = r.length < c.maxTypeRecursionCount ? f(i, t, n, a, r, s) : '';
            if (h) {
              g += ': ';
            } else {
              if (d.category === 1 && !c.isUnpacked(i)) {
                g += '*';
              }
            }
            if (d.category === 2 && c.isUnpacked(i)) {
              o = t & 256 ? `Unpack[${o.substring(1)}]` : `*${o}`;
            }
            g += o;
            if (c.isParamSpec(i)) {
              if (d.category === 1 || d.category === 2) {
                v = true;
              }
            }
            T = ' = ';
          } else {
            if (!(t & 2)) {
              if (!c.FunctionParam.isNameSynthesized(d)) {
                g += ': ';
              }
              g += t & 257 ? 'Any' : 'Unknown';
              T = ' = ';
            }
          }
        } else {
          if (d.category === 0) {
            if (!o) {
              return;
            }
            g += '/';
          }
        }
        if (y) {
          if (d.defaultExpr) {
            g += T + p.printExpression(d.defaultExpr);
          } else {
            g += T + '...';
          }
        }
        if (c.FunctionType.isGradualCallableForm(e) && !v) {
          if (d.category === 1) {
            g = '...';
          } else {
            if (d.category === 2) {
              return;
            }
          }
        }
        i.push(g);
      });
      if (d) {
        if (t & 256) {
          i.push(`*args: ${d}.args`);
          i.push(`**kwargs: ${d}.kwargs`);
        } else {
          i.push(`**${f(d, t, n, a, r, s)}`);
        }
      }
      const u = n(e);
      const m = r.length < c.maxTypeRecursionCount ? f(u, t | 144, n, a, r, s) : '';
      return [i, m];
    }
    function _(e, t) {
      if (t & 512) {
        return `Unpack[${e}]`;
      } else {
        return `*${e}`;
      }
    }
    function C(e, t) {
      var n;
      var a;
      const r = ((a = (n = e.props) === null || n === undefined ? undefined : n.instantiableDepth) !== null && a !== undefined ? a : 0) + 1;
      for (let e = 0; e < r; e++) {
        t = `type[${t}]`;
      }
      return t;
    }
    function I(e, t) {
      return c.TypeVarType.getReadableName(e, t);
    }
    class k {
      constructor(e, t) {
        this._printTypeFlags = e;
        this._returnTypeCallback = t;
        this._map = new Map();
      }
      build(e, t = [], n = 0) {
        var a;
        var r;
        if (n > c.maxTypeRecursionCount) {
          return;
        }
        n++;
        const s = (a = e.props) === null || a === undefined ? undefined : a.typeAliasInfo;
        if (s) {
          let a = true;
          if (this._printTypeFlags & 32) {
            if (t.find(t => t === e)) {
              a = false;
            }
          } else {
            a = false;
          }
          if (!a) {
            const a = this._printTypeFlags & 4096 ? s.shared.fullName : s.shared.name;
            this._addIfUnique(a, e, true);
            if (s.typeArgs) {
              t.push(e);
              try {
                s.typeArgs.forEach(e => {
                  this.build(e, t, n);
                });
              } finally {
                t.pop();
              }
            }
            return;
          }
        }
        try {
          t.push(e);
          switch (e.category) {
            case 4:
              {
                e.shared.parameters.forEach((a, r) => {
                  const s = c.FunctionType.getParamType(e, r);
                  this.build(s, t, n);
                });
                const a = this._returnTypeCallback(e);
                this.build(a, t, n);
                break;
              }
            case 5:
              c.OverloadedType.getOverloads(e).forEach(e => {
                this.build(e, t, n);
              });
              break;
            case 6:
              {
                if (e.priv.literalValue !== undefined) {
                  break;
                }
                let a = e.priv.aliasName;
                if (!a) {
                  a = this._printTypeFlags & 4096 ? e.shared.fullName : e.shared.name;
                }
                this._addIfUnique(a, e);
                if (!c.ClassType.isPseudoGenericClass(e)) {
                  if (e.priv.tupleTypeArgs) {
                    e.priv.tupleTypeArgs.forEach(e => {
                      this.build(e.type, t, n);
                    });
                  } else {
                    if (e.priv.typeArgs) {
                      e.priv.typeArgs.forEach(e => {
                        this.build(e, t, n);
                      });
                    }
                  }
                }
                break;
              }
            case 8:
              u.doForEachSubtype(e, e => {
                this.build(e, t, n);
              });
              if ((r = e.priv.typeAliasSources) !== null && r !== undefined) {
                r.forEach(e => {
                  this.build(e, t, n);
                });
              }
          }
        } finally {
          t.pop();
        }
      }
      isUnique(e) {
        const t = this._map.get(e);
        return !t || t.length === 1;
      }
      _addIfUnique(e, t, n = false) {
        const a = this._map.get(e);
        if (a) {
          if (!a.some(e => this._isSameTypeName(e, t, n))) {
            a.push(t);
          }
        } else {
          this._map.set(e, [t]);
        }
      }
      _isSameTypeName(e, t, n) {
        var a;
        var r;
        var s;
        var i;
        if (n) {
          return ((r = (a = e.props) === null || a === undefined ? undefined : a.typeAliasInfo) === null || r === undefined ? undefined : r.shared.fullName) === ((i = (s = t.props) === null || s === undefined ? undefined : s.typeAliasInfo) === null || i === undefined ? undefined : i.shared.fullName);
        }
        if (c.isClass(e) && c.isClass(t)) {
          while (c.TypeBase.isInstantiable(e)) {
            e = c.ClassType.cloneAsInstance(e);
          }
          while (c.TypeBase.isInstantiable(t)) {
            t = c.ClassType.cloneAsInstance(t);
          }
          return c.ClassType.isSameGenericClass(e, t);
        }
        return false;
      }
    }
  },
  14400: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.printStringLiteral = function (e, t = '"') {
      const n = /'/g;
      const a = /\\"/g;
      let r = JSON.stringify(e).toString();
      if (t !== '"') {
        r = `'${r.substring(1, r.length - 1).replace(a, '"').replace(n, '\\\'')}'`;
      }
      return r;
    };
    exports.printBytesLiteral = function (e) {
      let t = '';
      for (let n = 0; n < e.length; n++) {
        const a = e.substring(n, n + 1);
        const r = a.charCodeAt(0);
        t += r >= 20 && r <= 126 ? r === 34 ? `\\${a}` : a : `\\x${(r >> 4 & 15).toString(16)}${(r & 15).toString(16)}`;
      }
      return `b"${t}"`;
    };
  },
  70930: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeStubWriter = undefined;
    const i = require(85114);
    const o = __importStar(require(26687));
    const l = __importStar(require(41557));
    const p = require(88744);
    const d = require(95952);
    const c = __importStar(require(12097));
    const u = require(21024);
    class m {
      constructor(e) {
        this.importName = e;
        this.isAccessed = false;
      }
    }
    class y extends m {
      constructor(e, t, n) {
        super(e);
        this.alias = t;
        this.symbol = n;
      }
    }
    class g extends m {
      constructor(e, t, n) {
        super(e);
        this.isWildcardImport = t;
        this.node = n;
        this.symbols = [];
      }
      addSymbol(e, t, n, a = false) {
        if (!this.symbols.find(e => e.name === t)) {
          this.symbols.push({
            symbol: e,
            name: t,
            alias: n,
            isAccessed: a
          });
        }
      }
    }
    class h extends p.ParseTreeWalker {
      constructor(e, t) {
        super();
        this._accessedImportedSymbols = e;
        this._treatStringsAsSymbols = t;
      }
      analyze(e) {
        this.walk(e);
      }
      walk(e) {
        if (!o.isCodeUnreachable(e)) {
          super.walk(e);
        }
      }
      visitName(e) {
        this._accessedImportedSymbols.add(e.d.value);
        return true;
      }
      visitMemberAccess(e) {
        const t = this._getRecursiveModuleAccessExpression(e.d.leftExpr);
        if (t) {
          this._accessedImportedSymbols.add(`${t}.${e.d.member.d.value}`);
        }
        return true;
      }
      visitString(e) {
        if (this._treatStringsAsSymbols) {
          this._accessedImportedSymbols.add(e.d.value);
        }
        return true;
      }
      _getRecursiveModuleAccessExpression(e) {
        if (e.nodeType === 38) {
          return e.d.value;
        }
        if (e.nodeType === 35) {
          const t = this._getRecursiveModuleAccessExpression(e.d.leftExpr);
          if (!t) {
            return;
          }
          return `${t}.${e.d.member.d.value}`;
        }
      }
    }
    class f extends p.ParseTreeWalker {
      constructor(e, t, n) {
        super();
        this._stubPath = e;
        this._sourceFile = t;
        this._evaluator = n;
        this._indentAmount = 0;
        this._includeAllImports = false;
        this._typeStubText = '';
        this._lineEnd = '\n';
        this._tab = '    ';
        this._classNestCount = 0;
        this._functionNestCount = 0;
        this._ifNestCount = 0;
        this._emittedSuite = false;
        this._emitDocString = true;
        this._trackedImportAs = new Map();
        this._trackedImportFrom = new Map();
        this._accessedImportedSymbols = new Set();
        if (this._stubPath.fileName === '__init__.pyi') {
          this._includeAllImports = true;
        }
      }
      write() {
        const e = this._sourceFile.getParseResults();
        this._lineEnd = e.tokenizerOutput.predominantEndOfLineSequence;
        this._tab = e.tokenizerOutput.predominantTabSequence;
        this.walk(e.parserOutput.parseTree);
        this._writeFile();
      }
      walk(e) {
        if (!o.isCodeUnreachable(e)) {
          super.walk(e);
        }
      }
      visitClass(e) {
        const t = e.d.name.d.value;
        this._emittedSuite = true;
        this._emitDocString = true;
        this._emitDecorators(e.d.decorators);
        let n = `class ${t}`;
        if (e.d.typeParams) {
          n += this._printTypeParams(e.d.typeParams);
        }
        const a = e.d.arguments.filter(e => e.d.name !== undefined || e.d.argCategory !== 0 || e.d.valueExpr.nodeType !== 38 || e.d.valueExpr.d.value !== 'object');
        if (a.length > 0) {
          n += `(${a.map(e => {
            let t = '';
            if (e.d.name) {
              t = e.d.name.d.value + '=';
            }
            t += this._printExpression(e.d.valueExpr);
            return t;
          }).join(', ')})`;
        }
        n += ':';
        this._emitLine(n);
        this._emitSuite(() => {
          this._classNestCount++;
          this.walk(e.d.suite);
          this._classNestCount--;
        });
        this._emitLine('');
        this._emitLine('');
        return false;
      }
      visitFunction(e) {
        const t = e.d.name.d.value;
        if (this._functionNestCount === 0 && !c.isPrivateOrProtectedName(t)) {
          this._emittedSuite = true;
          this._emitDocString = true;
          this._emitDecorators(e.d.decorators);
          let n;
          let a = e.d.isAsync ? 'async ' : '';
          a += `def ${t}`;
          if (e.d.typeParams) {
            a += this._printTypeParams(e.d.typeParams);
          }
          a += `(${e.d.params.map((t, n) => this._printParam(t, e, n)).join(', ')})`;
          if (e.d.returnAnnotation) {
            n = this._printExpression(e.d.returnAnnotation, true);
          } else {
            if (e.d.funcAnnotationComment) {
              n = this._printExpression(e.d.funcAnnotationComment.d.returnAnnotation, true);
            } else {
              if (e.d.name.d.value === '__init__') {
                n = 'None';
              } else {
                if (e.d.name.d.value === '__str__') {
                  n = 'str';
                } else {
                  if (['__int__', '__hash__'].some(t => t === e.d.name.d.value)) {
                    n = 'int';
                  } else {
                    if (['__eq__', '__ne__', '__gt__', '__lt__', '__ge__', '__le__'].some(t => t === e.d.name.d.value)) {
                      n = 'bool';
                    }
                  }
                }
              }
            }
          }
          if (n) {
            a += ` -> ${n}`;
          }
          a += ':';
          if (!n) {
            const t = this._evaluator.getTypeOfFunction(e);
            if (t && u.isFunction(t.functionType)) {
              let e = this._evaluator.getInferredReturnType(t.functionType);
              e = u.removeUnknownFromUnion(e);
              if (!u.isNever(e) && !u.isUnknown(e)) {
                a += ` # -> ${this._evaluator.printType(e, {
                  enforcePythonSyntax: true
                })}:`;
              }
            }
          }
          this._emitLine(a);
          this._emitSuite(() => {
            this._functionNestCount++;
            this.walk(e.d.suite);
            this._functionNestCount--;
          });
          this._emitLine('');
        }
        return false;
      }
      visitWhile(e) {
        this._emitDocString = false;
        return false;
      }
      visitFor(e) {
        this._emitDocString = false;
        return false;
      }
      visitTry(e) {
        this._emitDocString = false;
        this.walk(e.d.trySuite);
        return false;
      }
      visitWith(e) {
        this._emitDocString = false;
        return false;
      }
      visitIf(e) {
        this._emitDocString = false;
        if (this._functionNestCount === 0 && this._ifNestCount === 0) {
          this._ifNestCount++;
          this._emittedSuite = true;
          this._emitLine(`if ${this._printExpression(e.d.testExpr)}:`);
          this._emitSuite(() => {
            this.walkMultiple(e.d.ifSuite.d.statements);
          });
          const t = e.d.elseSuite;
          if (t) {
            this._emitLine('else:');
            this._emitSuite(() => {
              if (t.nodeType === 22) {
                this.walkMultiple([t.d.testExpr, t.d.ifSuite, t.d.elseSuite]);
              } else {
                this.walkMultiple(t.d.statements);
              }
            });
          }
          this._ifNestCount--;
        }
        return false;
      }
      visitTypeAlias(e) {
        let t = '';
        t = this._printExpression(e.d.name);
        if (e.d.typeParams) {
          t += this._printTypeParams(e.d.typeParams);
        }
        t += ' = ';
        t += this._printExpression(e.d.expr);
        this._emitLine(t);
        return false;
      }
      visitAssignment(e) {
        var t;
        let n = false;
        let a = '';
        if (e.d.leftExpr.nodeType === 38) {
          if (e.d.leftExpr.d.value === '__all__') {
            if (this._functionNestCount === 0 && this._ifNestCount === 0) {
              this._emittedSuite = true;
              a = this._printExpression(e.d.leftExpr);
              a += ' = ';
              a += this._printExpression(e.d.rightExpr);
              this._emitLine(a);
            }
            return false;
          }
          if (this._functionNestCount === 0) {
            a = this._printExpression(e.d.leftExpr);
            if (e.d.annotationComment) {
              a += `: ${this._printExpression(e.d.annotationComment, true)}`;
            }
            const r = this._evaluator.getType(e.d.leftExpr);
            if ((t = r == null ? undefined : r.props) === null || t === undefined ? undefined : t.typeAliasInfo) {
              n = true;
            } else {
              if (e.d.rightExpr.nodeType === 9) {
                const t = this._evaluator.getType(e.d.rightExpr.d.leftExpr);
                if (t && u.isInstantiableClass(t) && u.ClassType.isBuiltIn(t, ['TypeVar', 'TypeVarTuple', 'ParamSpec', 'NewType'])) {
                  n = true;
                }
              }
            }
          }
        } else {
          if (e.d.leftExpr.nodeType === 54) {
            const t = e.d.leftExpr.d.valueExpr;
            const r = this._evaluator.getTypeOfAnnotation(e.d.leftExpr.d.annotation, {
              varTypeAnnotation: true,
              allowClassVar: true
            });
            if (u.isClassInstance(r) && u.ClassType.isBuiltIn(r, 'TypeAlias')) {
              n = true;
            }
            if (t.nodeType === 38 && this._functionNestCount === 0) {
              a = `${this._printExpression(t)}: ${this._printExpression(e.d.leftExpr.d.annotation, true)}`;
            }
          }
        }
        if (a) {
          this._emittedSuite = true;
          a += ' = ';
          a += n ? this._printExpression(e.d.rightExpr) : '...';
          this._emitLine(a);
        }
        return false;
      }
      visitAugmentedAssignment(e) {
        if (e.d.leftExpr.nodeType === 38 && e.d.leftExpr.d.value === '__all__' && e.d.operator === 1 && this._functionNestCount === 0 && this._ifNestCount === 0) {
          let t = this._printExpression(e.d.leftExpr);
          t += ' += ';
          t += this._printExpression(e.d.rightExpr);
          this._emitLine(t);
        }
        return false;
      }
      visitTypeAnnotation(e) {
        if (this._functionNestCount === 0) {
          let t = '';
          if (e.d.valueExpr.nodeType === 38) {
            t = this._printExpression(e.d.valueExpr);
          } else {
            if (e.d.valueExpr.nodeType === 35) {
              const n = e.d.valueExpr.d.leftExpr;
              if (n.nodeType === 38 && n.d.value === 'self') {
                const n = e.d.valueExpr.d.member.d.value;
                if (!c.isPrivateOrProtectedName(n)) {
                  t = this._printExpression(e.d.valueExpr);
                }
              }
            }
          }
          if (t) {
            t += `: ${this._printExpression(e.d.annotation, true)}`;
            this._emitLine(t);
          }
        }
        return false;
      }
      visitImport(e) {
        if (this._functionNestCount > 0 || this._classNestCount > 0) {
          return false;
        }
        const t = d.getScopeForNode(e);
        if (t) {
          e.d.list.forEach(e => {
            const n = this._printModuleName(e.d.module);
            if (!this._trackedImportAs.has(n)) {
              const a = e.d.alias ? e.d.alias.d.value : e.d.module.d.nameParts.length > 0 ? e.d.module.d.nameParts[0].d.value : '';
              const r = t.lookUpSymbolRecursive(a);
              if (r) {
                const t = new y(n, e.d.alias ? e.d.alias.d.value : undefined, r.symbol);
                this._trackedImportAs.set(n, t);
              }
            }
          });
        }
        return false;
      }
      visitImportFrom(e) {
        if (this._functionNestCount > 0 || this._classNestCount > 0) {
          return false;
        }
        const t = d.getScopeForNode(e);
        if (t) {
          const n = this._printModuleName(e.d.module);
          let a = this._trackedImportFrom.get(n);
          if (!a) {
            a = new g(n, e.d.isWildcardImport, e);
            this._trackedImportFrom.set(n, a);
          }
          e.d.imports.forEach(e => {
            const n = e.d.alias ? e.d.alias.d.value : e.d.name.d.value;
            const r = t.lookUpSymbolRecursive(n);
            if (r) {
              a.addSymbol(r.symbol, e.d.name.d.value, e.d.alias ? e.d.alias.d.value : undefined, false);
            }
          });
        }
        return false;
      }
      visitStatementList(e) {
        if (e.d.statements.length > 0 && e.d.statements[0].nodeType === 48 && !this._emittedSuite && this._emitDocString) {
          this._emitLine(this._printExpression(e.d.statements[0]));
        }
        this._emitDocString = false;
        this.walkMultiple(e.d.statements);
        return false;
      }
      _emitSuite(e) {
        this._increaseIndent(() => {
          const t = this._emittedSuite;
          this._emittedSuite = false;
          e();
          if (!this._emittedSuite) {
            this._emitLine('...');
          }
          this._emittedSuite = t;
        });
      }
      _increaseIndent(e) {
        this._indentAmount++;
        e();
        this._indentAmount--;
      }
      _emitDecorators(e) {
        e.forEach(e => {
          this._emitLine(`@${this._printExpression(e.d.expr)}`);
        });
      }
      _printHeaderDocString() {
        return `"""${this._lineEnd}This type stub file was generated by pyright.${this._lineEnd}"""${this._lineEnd}${this._lineEnd}`;
      }
      _emitLine(e) {
        for (let e = 0; e < this._indentAmount; e++) {
          this._typeStubText += this._tab;
        }
        this._typeStubText += e + this._lineEnd;
      }
      _printTypeParams(e) {
        return `[${e.d.params.map(e => this._printTypeParam(e)).join(',')}]`;
      }
      _printTypeParam(e) {
        let t = '';
        if (e.d.typeParamKind === i.TypeParamKind.TypeVarTuple) {
          t += '*';
        } else {
          if (e.d.typeParamKind === i.TypeParamKind.ParamSpec) {
            t += '**';
          }
        }
        t += e.d.name.d.value;
        if (e.d.boundExpr) {
          t += ': ';
          t += this._printExpression(e.d.boundExpr);
        }
        if (e.d.defaultExpr) {
          t += ' = ';
          t += this._printExpression(e.d.defaultExpr);
        }
        return t;
      }
      _printModuleName(e) {
        let t = '';
        for (let n = 0; n < e.d.leadingDots; n++) {
          t += '.';
        }
        t += e.d.nameParts.map(e => e.d.value).join('.');
        return t;
      }
      _printParam(e, t, n) {
        let a = '';
        if (e.d.category === 1) {
          a += '*';
        } else {
          if (e.d.category === 2) {
            a += '**';
          }
        }
        if (e.d.name) {
          a += e.d.name.d.value;
        } else {
          if (e.d.category === 0) {
            a += '/';
          }
        }
        const r = l.getTypeAnnotationForParam(t, n);
        let s = '';
        if (r) {
          s = this._printExpression(r, true);
        }
        if (s) {
          a += `: ${s}`;
        }
        if (e.d.defaultValue) {
          a += s ? ' = ...' : '=...';
        }
        return a;
      }
      _printExpression(e, t = false, n = false) {
        new h(this._accessedImportedSymbols, n).analyze(e);
        let a = t ? 1 : 0;
        a |= 2;
        return l.printExpression(e, a);
      }
      _printTrackedImports() {
        let e = '';
        let t = false;
        this._trackedImportAs.forEach(n => {
          if (this._accessedImportedSymbols.has(n.alias || n.importName)) {
            n.isAccessed = true;
          }
          if (n.isAccessed || this._includeAllImports) {
            e += `import ${n.importName}`;
            if (n.alias) {
              e += ` as ${n.alias}`;
            }
            e += this._lineEnd;
            t = true;
          }
        });
        this._trackedImportFrom.forEach(n => {
          n.symbols.forEach(e => {
            if (this._accessedImportedSymbols.has(e.alias || e.name)) {
              e.isAccessed = true;
            }
          });
          if (n.isWildcardImport) {
            e += `from ${n.importName} import *${this._lineEnd}`;
            t = true;
          }
          const a = n.symbols.filter(e => e.isAccessed || this._includeAllImports).sort((e, t) => e.name < t.name ? -1 : e.name > t.name ? 1 : 0);
          if (a.length > 0 && n.importName !== '__future__') {
            e += `from ${n.importName} import `;
            e += a.map(e => {
              let t = e.name;
              if (e.alias) {
                t += ` as ${e.alias}`;
              }
              return t;
            }).join(', ');
            e += this._lineEnd;
            t = true;
          }
        });
        if (t) {
          e += this._lineEnd;
        }
        return e;
      }
      _writeFile() {
        let e = this._printHeaderDocString();
        e += this._printTrackedImports();
        e += this._typeStubText;
        this._sourceFile.fileSystem.writeFileSync(this._stubPath, e, 'utf8');
      }
    }
    exports.TypeStubWriter = f;
  },
  92324: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeVarTransformer = exports.UniqueSignatureTracker = undefined;
    exports.isOptionalType = function (e) {
      if (l.isUnion(e)) {
        return l.findSubtype(e, e => d(e)) !== undefined;
      }
      return false;
    };
    exports.isNoneInstance = d;
    exports.isNoneTypeClass = function (e) {
      return l.isInstantiableClass(e) && l.ClassType.isBuiltIn(e, 'NoneType');
    };
    exports.removeNoneFromUnion = function (e) {
      return l.removeFromUnion(e, e => d(e));
    };
    exports.isIncompleteUnknown = function (e) {
      return l.isUnknown(e) && e.priv.isIncomplete;
    };
    exports.isTypeVarSame = function (e, t) {
      if (l.isTypeSame(e, t)) {
        return true;
      }
      if (l.isParamSpec(e) || l.isTypeVarTuple(e) || !l.TypeVarType.hasBound(e)) {
        return false;
      }
      if (!l.isUnion(t)) {
        return false;
      }
      let n = true;
      y(t, t => {
        if (n && !l.isTypeSame(e, t)) {
          const a = T(t);
          if (!a || !a.some(t => t.typeVar.priv.nameWithScope === e.priv.nameWithScope)) {
            n = false;
          }
        }
      });
      return n;
    };
    exports.makeInferenceContext = function (e, t, n) {
      if (!e) {
        return;
      }
      return {
        expectedType: e,
        isTypeIncomplete: t,
        returnTypeOverride: n
      };
    };
    exports.mapSubtypes = c;
    exports.mapSignatures = function (e, t) {
      if (l.isFunction(e)) {
        return t(e);
      }
      const n = [];
      let a = false;
      l.OverloadedType.getOverloads(e).forEach((e, r) => {
        const s = t(e);
        if (s !== e) {
          a = true;
        }
        if (s) {
          n.push(s);
        }
      });
      if (n.length === 0) {
        return;
      }
      const r = l.OverloadedType.getImplementation(e);
      let s = r;
      if (r && l.isFunction(r)) {
        s = t(r);
        if (s) {
          a = true;
        }
      }
      if (!a) {
        return e;
      }
      if (n.length === 1) {
        return n[0];
      }
      return l.OverloadedType.create(n, s);
    };
    exports.cleanIncompleteUnknown = function e(t, n = 0) {
      if (n >= l.maxTypeRecursionCount) {
        return t;
      }
      n++;
      const a = c(t, t => {
        if (!l.isUnknown(t) || !t.priv.isIncomplete) {
          if (l.isClass(t) && t.priv.typeArgs) {
            let a = false;
            if (t.priv.tupleTypeArgs) {
              const r = t.priv.tupleTypeArgs.map(t => {
                const r = e(t.type, n);
                if (r !== t.type) {
                  a = true;
                }
                return {
                  type: r,
                  isUnbounded: t.isUnbounded,
                  isOptional: t.isOptional
                };
              });
              if (a) {
                return H(t, r, !!t.priv.isTypeArgExplicit, !!t.priv.isUnpacked);
              }
            } else {
              const r = t.priv.typeArgs.map(t => {
                const r = e(t, n);
                if (r !== t) {
                  a = true;
                }
                return r;
              });
              if (a) {
                return l.ClassType.specialize(t, r, !!t.priv.isTypeArgExplicit);
              }
            }
          }
          return t;
        }
      });
      if (l.isNever(a)) {
        return t;
      } else {
        return a;
      }
    };
    exports.sortTypes = u;
    exports.doForEachSubtype = y;
    exports.someSubtypes = function (e, t) {
      if (l.isUnion(e)) {
        return e.priv.subtypes.some(e => t(e));
      } else {
        return t(e);
      }
    };
    exports.allSubtypes = function (e, t) {
      if (l.isUnion(e)) {
        return e.priv.subtypes.every(e => {
          t(e);
        });
      } else {
        return t(e);
      }
    };
    exports.doForEachSignature = g;
    exports.areTypesSame = function (e, t) {
      if (e.length < 2) {
        return true;
      }
      for (let n = 1; n < e.length; n++) {
        if (!l.isTypeSame(e[0], e[n], t)) {
          return false;
        }
      }
      return true;
    };
    exports.preserveUnknown = h;
    exports.isUnionableType = function (e) {
      if (e.every(e => {
        var t;
        return ((t = e.props) === null || t === undefined ? undefined : t.typeForm) !== undefined;
      })) {
        return true;
      }
      let t = 3;
      for (const n of e) {
        t &= n.flags;
      }
      return !!(t & 1) && !(t & 2);
    };
    exports.derivesFromAnyOrUnknown = function (e) {
      let t = false;
      y(e, n => {
        if (l.isAnyOrUnknown(e)) {
          t = true;
        } else {
          if (l.isInstantiableClass(n)) {
            if (l.ClassType.derivesFromAnyOrUnknown(n)) {
              t = true;
            }
          } else {
            if (l.isClassInstance(n) && l.ClassType.derivesFromAnyOrUnknown(n)) {
              t = true;
            }
          }
        }
      });
      return t;
    };
    exports.getFullNameOfType = function (e) {
      var t;
      var n;
      if ((n = (t = e.props) === null || t === undefined ? undefined : t.typeAliasInfo) === null || n === undefined ? undefined : n.shared.fullName) {
        return e.props.typeAliasInfo.shared.fullName;
      }
      switch (e.category) {
        case 2:
        case 1:
          return 'typing.Any';
        case 6:
        case 4:
          return e.shared.fullName;
        case 7:
          return e.priv.moduleName;
        case 5:
          {
            const t = l.OverloadedType.getOverloads(e);
            if (t.length > 0) {
              return t[0].shared.fullName;
            }
            const n = l.OverloadedType.getImplementation(e);
            if (n && l.isFunction(n)) {
              return n.shared.fullName;
            }
          }
      }
      return;
    };
    exports.addConditionToType = f;
    exports.getTypeCondition = T;
    exports.isTypeAliasPlaceholder = function (e) {
      return l.isTypeVar(e) && l.TypeVarType.isTypeAliasPlaceholder(e);
    };
    exports.isTypeAliasRecursive = function (e, t) {
      var n;
      var a;
      if (t.category !== 8) {
        return t === e || l.isUnbound(t) && ((n = t.props) === null || n === undefined ? undefined : n.typeAliasInfo) && t.props.typeAliasInfo.shared.name === ((a = e.shared.recursiveAlias) === null || a === undefined ? undefined : a.name);
      }
      return l.findSubtype(t, t => l.isTypeVar(t) && t.shared === e.shared) !== undefined;
    };
    exports.transformPossibleRecursiveTypeAlias = function e(t, n = 0) {
      var a;
      var r;
      if (n >= l.maxTypeRecursionCount) {
        return t;
      }
      n++;
      if (t) {
        const s = (a = t.props) === null || a === undefined ? undefined : a.typeAliasInfo;
        if (l.isTypeVar(t) && ((r = t.shared.recursiveAlias) === null || r === undefined ? undefined : r.name) && t.shared.boundType) {
          const a = l.TypeBase.isInstance(t) ? W(t.shared.boundType) : t.shared.boundType;
          if (!(s == null ? undefined : s.typeArgs) || !t.shared.recursiveAlias.typeParams) {
            return e(a, n);
          }
          const r = B(t.shared.recursiveAlias.typeParams, s.typeArgs);
          return e(N(a, r), n);
        }
        if (l.isUnion(t) && t.priv.includesRecursiveTypeAlias) {
          let a = c(t, t => e(t, n));
          if (a !== t && s) {
            a = l.TypeBase.cloneForTypeAlias(a, s);
          }
          return a;
        }
      }
      return t;
    };
    exports.getTypeVarScopeId = v;
    exports.getTypeVarScopeIds = function (e) {
      const t = [];
      const n = v(e);
      if (n) {
        t.push(n);
      }
      if (l.isFunction(e) && e.priv.constructorTypeVarScopeId) {
        t.push(e.priv.constructorTypeVarScopeId);
      }
      return t;
    };
    exports.specializeWithUnknownTypeArgs = b;
    exports.getUnknownForTypeVar = _;
    exports.getUnknownForTypeVarTuple = C;
    exports.getUnknownTypeForCallable = function () {
      const e = l.FunctionType.createSynthesizedInstance('', 32768);
      l.FunctionType.addDefaultParams(e);
      e.shared.declaredReturnType = l.UnknownType.create();
      return e;
    };
    exports.selfSpecializeClass = function (e, t) {
      if (e.shared.typeParams.length === 0) {
        return e;
      }
      if (e.priv.typeArgs && !(t == null ? undefined : t.overrideTypeArgs)) {
        return e;
      }
      const n = e.shared.typeParams.map(e => {
        if (l.isTypeVarTuple(e)) {
          e = l.TypeVarType.cloneForUnpacked(e);
        }
        if (t == null ? undefined : t.useBoundTypeVars) {
          return l.TypeVarType.cloneAsBound(e);
        } else {
          return e;
        }
      });
      return l.ClassType.specialize(e, n);
    };
    exports.getSpecializedTupleType = function (e) {
      let t;
      if (l.isInstantiableClass(e)) {
        t = e;
      } else {
        if (l.isClassInstance(e)) {
          t = l.ClassType.cloneAsInstantiable(e);
        }
      }
      if (!t) {
        return;
      }
      const n = t.shared.mro.find(e => l.isInstantiableClass(e) && S(e));
      if (!n || !l.isInstantiableClass(n)) {
        return;
      }
      if (l.ClassType.isSameGenericClass(t, n)) {
        return t;
      }
      const a = L(t);
      return N(n, a);
    };
    exports.isLiteralType = I;
    exports.isLiteralTypeOrUnion = function (e, t = false) {
      if (l.isClassInstance(e)) {
        return !!t && !!d(e) || e.priv.literalValue !== undefined;
      }
      if (l.isUnion(e)) {
        return !l.findSubtype(e, e => !l.isClassInstance(e) || (d(e) ? !t : e.priv.literalValue === undefined));
      }
      return false;
    };
    exports.isLiteralLikeType = k;
    exports.containsLiteralType = function (e, t = false) {
      class n extends p.TypeWalker {
        constructor(e) {
          super();
          this._includeTypeArgs = e;
          this.foundLiteral = false;
        }
        visitClass(e) {
          if (l.isClassInstance(e) && k(e)) {
            this.foundLiteral = true;
            this.cancelWalk();
          }
          if (this._includeTypeArgs) {
            super.visitClass(e);
          }
        }
      }
      const a = new n(t);
      a.walk(e);
      return a.foundLiteral;
    };
    exports.getLiteralTypeClassName = function e(t) {
      if (l.isClassInstance(t)) {
        if (t.priv.literalValue !== undefined && l.ClassType.isBuiltIn(t)) {
          return t.shared.name;
        } else {
          return undefined;
        }
      }
      if (l.isUnion(t)) {
        let n;
        let a = false;
        y(t, t => {
          const r = e(t);
          if (r) {
            if (!n) {
              n = r;
            }
          } else {
            a = true;
          }
        });
        if (a) {
          return undefined;
        } else {
          return n;
        }
      }
      return;
    };
    exports.stripTypeForm = function (e) {
      var t;
      if ((t = e.props) === null || t === undefined ? undefined : t.typeForm) {
        return l.TypeBase.cloneWithTypeForm(e, undefined);
      }
      return e;
    };
    exports.stripTypeFormRecursive = function e(t, n = 0) {
      var a;
      if (n > l.maxTypeRecursionCount) {
        return t;
      }
      n++;
      if ((a = t.props) === null || a === undefined ? undefined : a.typeForm) {
        t = l.TypeBase.cloneWithTypeForm(t, undefined);
      }
      return c(t, t => e(t, n));
    };
    exports.getUnionSubtypeCount = function (e) {
      if (l.isUnion(e)) {
        return e.priv.subtypes.length;
      }
      return 1;
    };
    exports.isEllipsisType = function (e) {
      return l.isAny(e) && e.priv.isEllipsis;
    };
    exports.isProperty = function (e) {
      return l.isClassInstance(e) && l.ClassType.isPropertyClass(e);
    };
    exports.isCallableType = function e(t) {
      if (l.isFunction(t) || l.isOverloaded(t) || l.isAnyOrUnknown(t)) {
        return true;
      }
      if (G(t)) {
        return true;
      }
      if (l.isClass(t)) {
        if (l.TypeBase.isInstantiable(t)) {
          return true;
        }
        return !!E(t, '__call__', 16);
      }
      if (l.isUnion(t)) {
        return t.priv.subtypes.every(t => e(t));
      }
      return false;
    };
    exports.isDescriptorInstance = function (e, t = false) {
      if (l.isUnion(e)) {
        return e.priv.subtypes.every(e => w(e, t));
      }
      return w(e, t);
    };
    exports.isMaybeDescriptorInstance = w;
    exports.isTupleGradualForm = function (e) {
      return l.isClassInstance(e) && S(e) && e.priv.tupleTypeArgs && e.priv.tupleTypeArgs.length === 1 && l.isAnyOrUnknown(e.priv.tupleTypeArgs[0].type) && e.priv.tupleTypeArgs[0].isUnbounded;
    };
    exports.isTupleClass = S;
    exports.isUnboundedTupleClass = A;
    exports.isTupleIndexUnambiguous = function (e, t) {
      if (!e.priv.tupleTypeArgs) {
        return false;
      }
      const n = e.priv.tupleTypeArgs.findIndex(e => e.isUnbounded || l.isUnpackedTypeVarTuple(e.type) || l.isUnpackedTypeVar(e.type));
      if (t < 0) {
        const a = n < 0 ? 0 : n;
        return (t += e.priv.tupleTypeArgs.length) >= a;
      }
      const a = n < 0 ? e.priv.tupleTypeArgs.length : n;
      return t < a;
    };
    exports.partiallySpecializeType = x;
    exports.addSolutionForSelfType = P;
    exports.ensureSignaturesAreUnique = function (e, t, n) {
      return new ae(t, n).apply(e, 0);
    };
    exports.makeFunctionTypeVarsBound = function (e) {
      const t = [];
      g(e, e => {
        const n = v(e);
        if (n) {
          t.push(n);
        }
      });
      return D(e, t);
    };
    exports.makeTypeVarsBound = D;
    exports.makeTypeVarsFree = function (e, t) {
      if (t.length === 0) {
        return e;
      }
      return new se(t).apply(e, 0);
    };
    exports.applySolvedTypeVars = N;
    exports.validateTypeVarDefault = function (e, t, n) {
      if (e.shared.isDefaultExplicit && J(e.shared.defaultType)) {
        new ne(t, n).apply(e.shared.defaultType, 0);
      }
    };
    exports.transformExpectedType = function (e, t, n) {
      return new oe(t, n).apply(e, 0);
    };
    exports.getProtocolSymbols = function (e) {
      const t = new Map();
      if (e.shared.flags & 512) {
        F(e, t, 512);
      }
      return t;
    };
    exports.getProtocolSymbolsRecursive = F;
    exports.getContainerDepth = function e(t, n = 0) {
      if (n > l.maxTypeRecursionCount) {
        return 1;
      }
      n++;
      if (!l.isClassInstance(t)) {
        return 0;
      }
      let a = 0;
      if (t.priv.tupleTypeArgs) {
        t.priv.tupleTypeArgs.forEach(t => {
          y(t.type, t => {
            const r = e(t, n);
            a = Math.max(r, a);
          });
        });
      } else {
        if (!t.priv.typeArgs) {
          return 0;
        }
        t.priv.typeArgs.forEach(t => {
          y(t, t => {
            const r = e(t, n);
            a = Math.max(r, a);
          });
        });
      }
      return 1 + a;
    };
    exports.lookUpObjectMember = E;
    exports.lookUpClassMember = M;
    exports.getClassMemberIterator = O;
    exports.isMemberReadOnly = z;
    exports.getClassIterator = U;
    exports.getClassFieldsRecursive = function (e) {
      const t = new Map();
      l.ClassType.getReverseMro(e).forEach(n => {
        const a = x(n, e, undefined);
        if (l.isClass(a)) {
          l.ClassType.getSymbolTable(a).forEach((e, r) => {
            if (!e.isIgnoredForProtocolMatch() && e.hasTypedDeclarations()) {
              t.set(r, {
                classType: a,
                unspecializedClassType: n,
                symbol: e,
                isInstanceMember: e.isInstanceMember(),
                isClassMember: e.isClassMember(),
                isClassVar: o.isEffectivelyClassVar(e, l.ClassType.isDataClass(a)),
                isReadOnly: z(a, r),
                isTypeDeclared: true,
                skippedUndeclaredType: false
              });
            }
          });
        } else {
          t.clear();
        }
      });
      return t;
    };
    exports.addTypeVarsToListIfUnique = V;
    exports.getTypeVarArgsRecursive = function e(t, n = 0) {
      var a;
      if (n > l.maxTypeRecursionCount) {
        return [];
      }
      n++;
      const r = (a = t.props) === null || a === undefined ? undefined : a.typeAliasInfo;
      if (r) {
        const t = [];
        if (r.typeArgs) {
          if (r != null) {
            r.typeArgs.forEach(a => {
              V(t, e(a, n));
            });
          }
          return t;
        }
        if (r.shared.typeParams) {
          r.shared.typeParams.forEach(e => {
            V(t, [e]);
          });
          return t;
        }
      }
      if (l.isTypeVar(t)) {
        if (t.shared.recursiveAlias || l.TypeVarType.isBound(t)) {
          return [];
        } else {
          if (l.isParamSpec(t) && t.priv.paramSpecAccess) {
            return [l.TypeVarType.cloneForParamSpecAccess(t, undefined)];
          } else {
            return [l.TypeBase.isInstantiable(t) ? l.TypeVarType.cloneAsInstance(t) : t];
          }
        }
      }
      if (l.isClass(t)) {
        const a = [];
        const r = t.priv.tupleTypeArgs ? t.priv.tupleTypeArgs.map(e => e.type) : t.priv.typeArgs;
        if (r) {
          r.forEach(t => {
            V(a, e(t, n));
          });
        }
        return a;
      }
      if (l.isUnion(t)) {
        const a = [];
        y(t, t => {
          V(a, e(t, n));
        });
        return a;
      }
      if (l.isFunction(t)) {
        const a = [];
        for (let r = 0; r < t.shared.parameters.length; r++) {
          V(a, e(l.FunctionType.getParamType(t, r), n));
        }
        const r = l.FunctionType.getEffectiveReturnType(t);
        if (r) {
          V(a, e(r, n));
        }
        return a;
      }
      return [];
    };
    exports.specializeWithDefaultTypeArgs = R;
    exports.buildSolutionFromSpecializedClass = L;
    exports.buildSolution = B;
    exports.specializeForBaseClass = function (e, t) {
      if (l.ClassType.getTypeParams(t).length === 0) {
        return t;
      }
      const n = L(e);
      const a = N(t, n);
      r.assert(l.isInstantiableClass(a));
      return a;
    };
    exports.derivesFromStdlibClass = function (e, t) {
      return e.shared.mro.some(e => l.isClass(e) && l.ClassType.isBuiltIn(e, t));
    };
    exports.derivesFromClassRecursive = function e(t, n, a) {
      if (l.ClassType.isSameGenericClass(t, n)) {
        return true;
      }
      for (const r of t.shared.baseClasses) {
        if (l.isInstantiableClass(r)) {
          if (e(r, n, a)) {
            return true;
          }
        } else {
          if (!a && l.isAnyOrUnknown(r)) {
            return true;
          }
        }
      }
      return false;
    };
    exports.synthesizeTypeVarForSelfCls = j;
    exports.getDeclaredGeneratorReturnType = function (e) {
      const t = l.FunctionType.getEffectiveReturnType(e);
      if (t) {
        const e = Y(t);
        if (e) {
          if (e.length >= 3) {
            return e[2];
          } else {
            return l.UnknownType.create();
          }
        }
      }
      return;
    };
    exports.getGeneratorYieldType = function (e, t) {
      let n = true;
      const a = c(e, e => {
        if (l.isAnyOrUnknown(e)) {
          return e;
        }
        if (l.isClassInstance(e)) {
          if ([['AsyncIterable', 'Iterable'], ['AsyncIterator', 'Iterator'], ['AsyncGenerator', 'Generator'], ['', 'AwaitableGenerator']].some(n => l.ClassType.isBuiltIn(e, t ? n[0] : n[1]))) {
            if (e.priv.typeArgs && e.priv.typeArgs.length >= 1) {
              return e.priv.typeArgs[0];
            } else {
              return l.UnknownType.create();
            }
          }
        }
        n = false;
      });
      if (n) {
        return a;
      } else {
        return undefined;
      }
    };
    exports.isInstantiableMetaclass = function (e) {
      return l.isInstantiableClass(e) && e.shared.mro.some(e => l.isClass(e) && l.ClassType.isBuiltIn(e, 'type'));
    };
    exports.isMetaclassInstance = q;
    exports.isEffectivelyInstantiable = G;
    exports.convertToInstance = W;
    exports.convertToInstantiable = K;
    exports.getMembersForClass = function (e, t, n) {
      e.shared.mro.forEach(e => {
        if (l.isInstantiableClass(e)) {
          const a = l.ClassType.isTypedDictClass(e);
          l.ClassType.getSymbolTable(e).forEach((e, r) => {
            if ((e.isClassMember() || n && e.isInstanceMember()) && (!a || !o.isTypedDictMemberAccessedThroughIndex(e)) && !e.isInitVar()) {
              const n = t.get(r);
              if (n) {
                if (!n.hasTypedDeclarations() && e.hasTypedDeclarations()) {
                  t.set(r, e);
                }
              } else {
                t.set(r, e);
              }
            }
          });
        }
      });
      if (!n) {
        const n = e.shared.effectiveMetaclass;
        if (n && l.isInstantiableClass(n)) {
          for (const e of n.shared.mro) {
            if (!l.isInstantiableClass(e)) {
              break;
            }
            l.ClassType.getSymbolTable(e).forEach((e, n) => {
              const a = t.get(n);
              if (a) {
                if (!a.hasTypedDeclarations() && e.hasTypedDeclarations()) {
                  t.set(n, e);
                }
              } else {
                t.set(n, e);
              }
            });
          }
        }
      }
    };
    exports.getMembersForModule = function (e, t) {
      if (e.priv.loaderFields) {
        e.priv.loaderFields.forEach((e, n) => {
          t.set(n, e);
        });
      }
      e.priv.fields.forEach((e, n) => {
        t.set(n, e);
      });
    };
    exports.containsAnyRecursive = function (e, t = true) {
      class n extends p.TypeWalker {
        constructor(e) {
          super();
          this._includeUnknown = e;
          this.foundAny = false;
        }
        visitAny(e) {
          this.foundAny = true;
          this.cancelWalk();
        }
        visitUnknown(e) {
          if (this._includeUnknown) {
            this.foundAny = true;
            this.cancelWalk();
          }
        }
      }
      const a = new n(t);
      a.walk(e);
      return a.foundAny;
    };
    exports.containsAnyOrUnknown = function (e, t) {
      class n extends p.TypeWalker {
        constructor(e) {
          super();
          this._recurse = e;
        }
        visitTypeAlias(e) {}
        visitUnknown(e) {
          this.anyOrUnknownType = this.anyOrUnknownType ? h(this.anyOrUnknownType, e) : e;
        }
        visitAny(e) {
          this.anyOrUnknownType = this.anyOrUnknownType ? h(this.anyOrUnknownType, e) : e;
        }
        visitClass(e) {
          if (this._recurse) {
            super.visitClass(e);
          }
        }
        visitFunction(e) {
          if (this._recurse) {
            if (l.FunctionType.isGradualCallableForm(e)) {
              this.anyOrUnknownType = this.anyOrUnknownType ? h(this.anyOrUnknownType, l.AnyType.create()) : l.AnyType.create();
            }
            super.visitFunction(e);
          }
        }
      }
      const a = new n(t);
      a.walk(e);
      return a.anyOrUnknownType;
    };
    exports.isPartlyUnknown = function e(t, n = 0) {
      var a;
      var r;
      if (n > l.maxTypeRecursionCount) {
        return false;
      }
      n++;
      if (l.isUnknown(t)) {
        return true;
      }
      const s = (a = t.props) === null || a === undefined ? undefined : a.typeAliasInfo;
      if ((s == null ? undefined : s.typeArgs) && s.typeArgs.some(t => e(t, n))) {
        return true;
      }
      if (l.isUnion(t)) {
        return l.findSubtype(t, t => e(t, n)) !== undefined;
      }
      if (l.isClass(t)) {
        if (!t.priv.includeSubclasses) {
          return false;
        }
        if (!l.ClassType.isPseudoGenericClass(t)) {
          const a = ((r = t.priv.tupleTypeArgs) === null || r === undefined ? undefined : r.map(e => e.type)) || t.priv.typeArgs;
          if (a) {
            for (const t of a) {
              if (e(t, n)) {
                return true;
              }
            }
          }
        }
        return false;
      }
      if (l.isOverloaded(t)) {
        return l.OverloadedType.getOverloads(t).some(t => e(t, n));
      }
      if (l.isFunction(t)) {
        for (let a = 0; a < t.shared.parameters.length; a++) {
          if (t.shared.parameters[a].name) {
            const r = l.FunctionType.getParamType(t, a);
            if (e(r, n)) {
              return true;
            }
          }
        }
        return !!t.shared.declaredReturnType && !l.FunctionType.isParamSpecValue(t) && !!e(t.shared.declaredReturnType, n);
      }
      return false;
    };
    exports.explodeGenericClass = function (e) {
      if (!e.priv.typeArgs || e.priv.typeArgs.length !== 1 || !l.isUnion(e.priv.typeArgs[0])) {
        return e;
      }
      return l.combineTypes(e.priv.typeArgs[0].priv.subtypes.map(t => l.ClassType.specialize(e, [t])));
    };
    exports.combineSameSizedTuples = function (e, t) {
      if (!t || !l.isInstantiableClass(t) || A(t)) {
        return e;
      }
      let n;
      let a = true;
      y(e, e => {
        if (l.isClassInstance(e)) {
          let t;
          if (l.isClass(e) && S(e) && !A(e)) {
            t = e;
          }
          if (!t) {
            t = e.shared.mro.find(e => l.isClass(e) && S(e) && !A(e));
          }
          if (t && l.isClass(t) && t.priv.tupleTypeArgs) {
            if (n) {
              if (n.length === t.priv.tupleTypeArgs.length) {
                t.priv.tupleTypeArgs.forEach((e, t) => {
                  n[t].push(e.type);
                });
              } else {
                a = false;
              }
            } else {
              n = t.priv.tupleTypeArgs.map(e => [e.type]);
            }
          } else {
            a = false;
          }
        } else {
          a = false;
        }
      });
      if (!a || !n) {
        return e;
      }
      return W(H(t, n.map(e => ({
        type: l.combineTypes(e),
        isUnbounded: false
      }))));
    };
    exports.combineTupleTypeArgs = $;
    exports.specializeTupleClass = H;
    exports.makePacked = function (e) {
      if (l.isUnpackedClass(e)) {
        return l.ClassType.cloneForPacked(e);
      }
      if (l.isUnpackedTypeVarTuple(e) && !e.priv.isInUnion) {
        return l.TypeVarType.cloneForPacked(e);
      }
      if (l.isUnpackedTypeVar(e)) {
        return l.TypeVarType.cloneForPacked(e);
      }
      return e;
    };
    exports.makeUnpacked = function (e) {
      if (l.isClass(e)) {
        return l.ClassType.cloneForUnpacked(e);
      }
      if (l.isTypeVarTuple(e) && !e.priv.isInUnion) {
        return l.TypeVarType.cloneForUnpacked(e);
      }
      if (l.isTypeVar(e)) {
        return l.TypeVarType.cloneForUnpacked(e);
      }
      return e;
    };
    exports.getGeneratorTypeArgs = Y;
    exports.requiresTypeArgs = function (e) {
      if (e.shared.typeParams.length > 0) {
        const t = e.shared.typeParams[0];
        return !t.shared.isSynthesized && !t.shared.isDefaultExplicit;
      }
      if (l.ClassType.isSpecialBuiltIn(e)) {
        if (['Tuple', 'Callable', 'Generic', 'Type', 'Optional', 'Union', 'Literal', 'Annotated', 'TypeGuard', 'TypeIs'].some(t => t === (e.priv.aliasName || e.shared.name))) {
          return true;
        }
      }
      return false;
    };
    exports.requiresSpecialization = J;
    exports.invertVariance = function (e) {
      if (e === 4) {
        return 3;
      }
      if (e === 3) {
        return 4;
      }
      return e;
    };
    exports.combineVariances = function (e, t) {
      if (e === 1) {
        return t;
      }
      if (t === 2 || t === 3 && e === 4 || t === 4 && e === 3) {
        return 2;
      }
      return e;
    };
    exports.isVarianceOfTypeArgCompatible = function e(t, n) {
      if (n === 1 || n === 0) {
        return true;
      }
      if (!l.isTypeVar(t) || l.isParamSpec(t) || l.isTypeVarTuple(t)) {
        if (l.isClassInstance(t) && t.shared.typeParams && t.shared.typeParams.length > 0) {
          return t.shared.typeParams.every((a, r) => {
            let s;
            if (l.isParamSpec(a) || l.isTypeVarTuple(a)) {
              return true;
            }
            if (t.priv.typeArgs && r < t.priv.typeArgs.length) {
              s = t.priv.typeArgs[r];
            }
            const i = a.shared.declaredVariance;
            if (i === 0) {
              return true;
            }
            let o = 2;
            if (i === 3) {
              o = n;
            } else {
              if (i === 4) {
                if (n === 3) {
                  o = 4;
                } else {
                  if (n === 4) {
                    o = 3;
                  }
                }
              }
            }
            return e(s ?? l.UnknownType.create(), o);
          });
        }
      } else {
        const e = t.shared.declaredVariance;
        if (e === 4 || e === 3) {
          return e === n;
        }
      }
      return true;
    };
    exports.computeMroLinearization = function (e) {
      let t = true;
      e.shared.mro = [];
      const n = e.shared.baseClasses.filter((t, n) => {
        if (l.isInstantiableClass(t) && l.ClassType.isBuiltIn(t, 'Generic')) {
          if (l.ClassType.isProtocolClass(e) || l.ClassType.isTypedDictClass(e)) {
            return false;
          }
          if (e.shared.baseClasses.some((e, t) => t > n && l.isInstantiableClass(e) && e.priv.typeArgs && e.priv.isTypeArgExplicit)) {
            return false;
          }
        }
        return true;
      });
      const a = [];
      n.forEach(e => {
        if (l.isInstantiableClass(e)) {
          const t = L(e);
          a.push(e.shared.mro.map(e => N(e, t)));
        } else {
          a.push([e]);
        }
      });
      a.push(n.map(t => N(t, L(e))));
      const r = L(e);
      let s = N(e, r);
      if (!l.isClass(s) && !l.isAnyOrUnknown(s)) {
        s = l.UnknownType.create();
      }
      function i(e, t) {
        return t.some(t => t.findIndex(t => l.isInstantiableClass(t) && l.ClassType.isSameGenericClass(t, e)) > 0);
      }
      function o(e, t) {
        for (let n = 0; n < t.length; n++) {
          t[n] = t[n].filter(t => !l.isInstantiableClass(t) || !l.ClassType.isSameGenericClass(t, e));
        }
      }
      e.shared.mro.push(s);
      while (true) {
        let n;
        let r = false;
        for (let t = 0; t < a.length; t++) {
          const s = a[t];
          if (s.length > 0) {
            if (n === undefined) {
              n = s;
            }
            if (!l.isInstantiableClass(s[0])) {
              r = true;
              let t = s[0];
              if (!l.isClass(t) && !l.isAnyOrUnknown(t)) {
                t = l.UnknownType.create();
              }
              e.shared.mro.push(t);
              s.shift();
              break;
            }
            if (!i(s[0], a)) {
              r = true;
              e.shared.mro.push(s[0]);
              o(s[0], a);
              break;
            }
          }
        }
        if (!n) {
          break;
        }
        if (!r) {
          t = false;
          if (l.isInstantiableClass(n[0])) {
            e.shared.mro.push(n[0]);
            o(n[0], a);
          } else {
            let t = n[0];
            if (!l.isClass(t) && !l.isAnyOrUnknown(t)) {
              t = l.UnknownType.create();
            }
            e.shared.mro.push(t);
            n.shift();
          }
        }
      }
      return t;
    };
    exports.getDeclaringModulesForType = function (e) {
      const t = [];
      Q(e, t);
      return t;
    };
    exports.convertTypeToParamSpecValue = X;
    exports.simplifyFunctionToParamSpec = ee;
    const a = require(58147);
    const r = require(48281);
    const s = require(70617);
    const i = require(58253);
    const o = require(4064);
    const l = require(21024);
    const p = require(8307);
    function d(e) {
      return l.isClassInstance(e) && l.ClassType.isBuiltIn(e, 'NoneType');
    }
    function c(e, t, n) {
      var a;
      if (l.isUnion(e)) {
        const r = (n == null ? undefined : n.sortSubtypes) ? u(e.priv.subtypes) : e.priv.subtypes;
        for (let s = 0; s < r.length; s++) {
          const i = r[s];
          const o = t(i);
          if (i !== o) {
            const i = r.slice(0, s);
            const p = t => {
              if (t) {
                i.push(f(t, T(e)));
              }
            };
            p(o);
            s++;
            for (; s < r.length; s++) {
              p(t(r[s]));
            }
            let d = l.combineTypes(i, {
              skipElideRedundantLiterals: n == null ? undefined : n.skipElideRedundantLiterals
            });
            if (n == null ? undefined : n.retainTypeAlias) {
              if ((a = e.props) === null || a === undefined ? undefined : a.typeAliasInfo) {
                d = l.TypeBase.cloneForTypeAlias(d, e.props.typeAliasInfo);
              }
            } else {
              if (l.isUnion(d)) {
                l.UnionType.addTypeAliasSource(d, e);
              }
            }
            return d;
          }
        }
        return e;
      }
      const r = t(e);
      return r || l.NeverType.createNever();
    }
    function u(e) {
      return e.slice(0).sort((e, t) => m(e, t));
    }
    function m(e, t, n = 0) {
      var a;
      var r;
      if (n > l.maxTypeRecursionCount) {
        return 0;
      }
      n++;
      if (e.category !== t.category) {
        return t.category - e.category;
      }
      switch (e.category) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 8:
          return 0;
        case 4:
          {
            const n = t;
            const s = e.shared.parameters.length;
            const i = n.shared.parameters.length;
            if (s !== i) {
              return i - s;
            }
            for (let t = 0; t < s; t++) {
              const a = e.shared.parameters[t];
              const r = n.shared.parameters[t];
              if (a.category !== r.category) {
                return r.category - a.category;
              }
              const s = m(l.FunctionType.getParamType(e, t), l.FunctionType.getParamType(n, t));
              if (s !== 0) {
                return s;
              }
            }
            const o = m((a = l.FunctionType.getEffectiveReturnType(e)) !== null && a !== undefined ? a : l.UnknownType.create(), (r = l.FunctionType.getEffectiveReturnType(n)) !== null && r !== undefined ? r : l.UnknownType.create());
            if (o !== 0) {
              return o;
            }
            const p = e.shared.name;
            const d = n.shared.name;
            if (p < d) {
              return -1;
            } else {
              if (p > d) {
                return 1;
              } else {
                return 0;
              }
            }
          }
        case 5:
          {
            const n = t;
            const a = l.OverloadedType.getOverloads(e);
            const r = l.OverloadedType.getOverloads(n);
            const s = a.length;
            const i = r.length;
            if (s !== i) {
              return i - s;
            }
            for (let e = 0; e < s; e++) {
              const t = m(a[e], r[e]);
              if (t !== 0) {
                return t;
              }
            }
            return 0;
          }
        case 6:
          {
            const a = t;
            if (l.isClassInstance(e) && l.isInstantiableClass(a)) {
              return -1;
            }
            if (l.isInstantiableClass(e) && l.isClassInstance(a)) {
              return 1;
            }
            if (I(e)) {
              if (!I(a)) {
                return -1;
              }
              if (l.ClassType.isSameGenericClass(e, a)) {
                const t = e.priv.literalValue;
                const n = a.priv.literalValue;
                if (typeof t == 'string' && typeof n == 'string' || typeof t == 'number' && typeof n == 'number') {
                  if (t < n) {
                    return -1;
                  }
                  if (t > n) {
                    return 1;
                  }
                }
              }
            } else {
              if (I(a)) {
                return 1;
              }
            }
            if (l.ClassType.isBuiltIn(e, 'NoneType')) {
              return 1;
            }
            if (l.ClassType.isBuiltIn(a, 'NoneType')) {
              return -1;
            }
            if (e.shared.typeParams.length > 0 || S(e)) {
              if (a.shared.typeParams.length === 0) {
                return 1;
              }
            } else {
              if (a.shared.typeParams.length > 0 || S(a)) {
                return -1;
              }
            }
            const r = e.shared.name;
            const s = t.shared.name;
            if (r < s) {
              return -1;
            }
            if (r > s) {
              return 1;
            }
            const i = e.priv.typeArgs ? e.priv.typeArgs.length : 0;
            const o = a.priv.typeArgs ? a.priv.typeArgs.length : 0;
            if (i < o) {
              return -1;
            }
            if (i > o) {
              return 1;
            }
            for (let t = 0; t < i; t++) {
              const r = m(e.priv.typeArgs[t], a.priv.typeArgs[t], n);
              if (r !== 0) {
                return r;
              }
            }
            return 0;
          }
        case 7:
          {
            const n = e.priv.moduleName;
            const a = t.priv.moduleName;
            if (n < a) {
              return -1;
            } else {
              if (n === a) {
                return 0;
              } else {
                return 1;
              }
            }
          }
        case 9:
          {
            const n = e.shared.name;
            const a = t.shared.name;
            if (n < a) {
              return -1;
            } else {
              if (n === a) {
                return 0;
              } else {
                return 1;
              }
            }
          }
      }
      return 1;
    }
    function y(e, t, n = false) {
      if (l.isUnion(e)) {
        const a = n ? u(e.priv.subtypes) : e.priv.subtypes;
        a.forEach((e, n) => {
          t(e, n, a);
        });
      } else {
        t(e, 0, [e]);
      }
    }
    function g(e, t) {
      if (l.isFunction(e)) {
        t(e, 0);
      } else {
        l.OverloadedType.getOverloads(e).forEach((e, n) => {
          t(e, n);
        });
      }
    }
    function h(e, t) {
      if (l.isUnknown(e) && e.priv.isIncomplete) {
        return e;
      } else {
        if (l.isUnknown(t) && t.priv.isIncomplete) {
          return t;
        } else {
          if (l.isUnknown(e) || l.isUnknown(t)) {
            return l.UnknownType.create();
          } else {
            return l.AnyType.create();
          }
        }
      }
    }
    function f(e, t, n) {
      var a;
      var r;
      if (!t) {
        return e;
      }
      if ((n == null ? undefined : n.skipSelfCondition) && (t = t.filter(e => !l.TypeVarType.isSelf(e.typeVar))).length === 0) {
        return e;
      }
      if ((n == null ? undefined : n.skipBoundTypeVars) && (t = t.filter(e => e.typeVar.shared.constraints.length > 0)).length === 0) {
        return e;
      }
      switch (e.category) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 7:
        case 9:
          return e;
        case 4:
          return l.TypeBase.cloneForCondition(e, l.TypeCondition.combine((a = e.props) === null || a === undefined ? undefined : a.condition, t));
        case 5:
          return l.OverloadedType.create(l.OverloadedType.getOverloads(e).map(e => f(e, t)));
        case 6:
          return l.TypeBase.cloneForCondition(e, l.TypeCondition.combine((r = e.props) === null || r === undefined ? undefined : r.condition, t));
        case 8:
          return l.combineTypes(e.priv.subtypes.map(e => f(e, t)));
      }
    }
    function T(e) {
      var t;
      switch (e.category) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 7:
        case 9:
        case 5:
        case 8:
          return;
        case 6:
        case 4:
          if ((t = e.props) === null || t === undefined) {
            return undefined;
          } else {
            return t.condition;
          }
      }
    }
    function v(e) {
      if (l.isClass(e) || l.isFunction(e)) {
        return e.shared.typeVarScopeId;
      } else {
        if (l.isTypeVar(e)) {
          return e.priv.scopeId;
        } else {
          return undefined;
        }
      }
    }
    function b(e, t) {
      if (e.shared.typeParams.length === 0) {
        return e;
      } else {
        if (S(e)) {
          return l.ClassType.cloneIncludeSubclasses(H(e, [{
            type: l.UnknownType.create(),
            isUnbounded: true
          }], false), !!e.priv.includeSubclasses);
        } else {
          return l.ClassType.specialize(e, e.shared.typeParams.map(e => _(e, t)), false, e.priv.includeSubclasses);
        }
      }
    }
    function _(e, t) {
      if (l.isParamSpec(e)) {
        return l.ParamSpecType.getUnknown();
      } else {
        if (l.isTypeVarTuple(e) && t) {
          return C(t);
        } else {
          return l.UnknownType.create();
        }
      }
    }
    function C(e) {
      r.assert(l.isInstantiableClass(e) && l.ClassType.isBuiltIn(e, 'tuple'));
      return l.ClassType.cloneAsInstance(H(e, [{
        type: l.UnknownType.create(),
        isUnbounded: true
      }], true, true));
    }
    function I(e) {
      return l.TypeBase.isInstance(e) && e.priv.literalValue !== undefined;
    }
    function k(e) {
      return e.priv.literalValue !== undefined || !!l.ClassType.isBuiltIn(e, 'LiteralString');
    }
    function w(e, t = false) {
      if (l.isUnion(e)) {
        return e.priv.subtypes.some(e => w(e, t));
      } else {
        return !!l.isClassInstance(e) && !!l.ClassType.getSymbolTable(e).has('__get__') && (!t || !!l.ClassType.getSymbolTable(e).has('__set__'));
      }
    }
    function S(e) {
      return l.ClassType.isBuiltIn(e, 'tuple');
    }
    function A(e) {
      var t;
      if ((t = e.priv.tupleTypeArgs) === null || t === undefined) {
        return undefined;
      } else {
        return t.some(e => e.isUnbounded || l.isUnpackedTypeVarTuple(e.type) || l.isUnpackedTypeVar(e.type));
      }
    }
    function x(e, t, n, a) {
      if (l.ClassType.isUnspecialized(t) && !a) {
        return e;
      }
      const r = L(t);
      if (a) {
        P(r, t, a);
      }
      let s = N(e, r, {
        typeClassType: n
      });
      if (l.isClass(s) && (s.priv.fgetInfo || s.priv.fsetInfo || s.priv.fdelInfo)) {
        function i(e) {
          if (e) {
            return {
              methodType: x(e.methodType, t, n, a),
              classType: e.classType
            };
          }
        }
        s = l.TypeBase.cloneType(s);
        s.priv.fgetInfo = i(s.priv.fgetInfo);
        s.priv.fsetInfo = i(s.priv.fsetInfo);
        s.priv.fdelInfo = i(s.priv.fdelInfo);
      }
      return s;
    }
    function P(e, t, n) {
      const a = j(t, false);
      const r = c(W(n), e => l.isClass(e) && e.priv.literalValue !== undefined ? l.ClassType.cloneWithLiteral(e, undefined) : e);
      e.setType(a, r);
    }
    function D(e, t) {
      if (t && t.length === 0) {
        return e;
      }
      return new re(t).apply(e, 0);
    }
    function N(e, t, n = {}) {
      if (t.isEmpty() && !n.replaceUnsolved) {
        return e;
      }
      return new ie(t, n).apply(e, 0);
    }
    function F(e, t, n = 512, a = 0) {
      if (!(a > l.maxTypeRecursionCount)) {
        e.shared.baseClasses.forEach(e => {
          if (l.isClass(e) && e.shared.flags & n) {
            F(e, t, n, a + 1);
          }
        });
        l.ClassType.getSymbolTable(e).forEach((n, a) => {
          if (!n.isIgnoredForProtocolMatch()) {
            t.set(a, {
              symbol: n,
              classType: e,
              unspecializedClassType: e,
              isInstanceMember: n.isInstanceMember(),
              isClassMember: n.isClassMember(),
              isClassVar: o.isEffectivelyClassVar(n, false),
              isReadOnly: false,
              isTypeDeclared: n.hasTypedDeclarations(),
              skippedUndeclaredType: false
            });
          }
        });
      }
    }
    function E(e, t, n = 0, a) {
      if (l.isClassInstance(e)) {
        return M(e, t, n, a);
      }
    }
    function M(e, t, n = 0, a) {
      var r;
      var s;
      const i = e.shared.effectiveMetaclass;
      if (i && l.isClass(i) && !l.ClassType.isBuiltIn(i, 'type')) {
        const e = (r = O(i, t, 32).next()) === null || r === undefined ? undefined : r.value;
        if (e && !l.isAnyOrUnknown(e.classType)) {
          e.isClassMember = true;
          return e;
        }
      }
      if ((s = O(e, t, n, a).next()) === null || s === undefined) {
        return undefined;
      } else {
        return s.value;
      }
    }
    function* O(e, t, n = 0, a) {
      const r = !!(n & 64);
      let s = false;
      if (l.isClass(e)) {
        let p = 0;
        if (n & 1 && l.isClass(e)) {
          a = l.isClassInstance(e) ? l.ClassType.cloneAsInstantiable(e) : e;
        }
        if (n & 2) {
          p |= 1;
        }
        if (n & 4) {
          p |= 2;
        }
        if (n & 8) {
          p |= 4;
        }
        const d = U(e, p, a);
        for (const [a, p] of d) {
          if (!l.isInstantiableClass(a)) {
            if (!r) {
              const e = l.isAnyOrUnknown(a) ? a : l.UnknownType.create();
              const t = {
                symbol: i.Symbol.createWithType(0, a),
                isInstanceMember: false,
                isClassMember: true,
                isClassVar: false,
                classType: e,
                unspecializedClassType: e,
                isReadOnly: false,
                isTypeDeclared: false,
                skippedUndeclaredType: false
              };
              yield t;
            }
            continue;
          }
          if (!l.isInstantiableClass(p)) {
            continue;
          }
          const d = l.ClassType.getSymbolTable(p);
          if (!(n & 16)) {
            const e = d.get(t);
            if (e && e.isInstanceMember()) {
              const n = e.hasTypedDeclarations();
              if (!r || n) {
                const r = {
                  symbol: e,
                  isInstanceMember: true,
                  isClassMember: e.isClassMember(),
                  isClassVar: o.isEffectivelyClassVar(e, l.ClassType.isDataClass(p)),
                  classType: p,
                  unspecializedClassType: a,
                  isReadOnly: z(p, t),
                  isTypeDeclared: n,
                  skippedUndeclaredType: s
                };
                yield r;
              } else {
                s = true;
              }
            }
          }
          if (!(n & 32)) {
            let n = d.get(t);
            if (n && n.isClassMember()) {
              const d = n.hasTypedDeclarations();
              if (!r || d) {
                let r = n.isInstanceMember();
                let c = true;
                const u = l.ClassType.isDataClass(p);
                const m = l.ClassType.isTypedDictClass(p);
                if (d && (u || m)) {
                  const e = n.getDeclarations();
                  if (e.length > 0 && e[0].type === 1) {
                    r = true;
                    c = u;
                  }
                }
                if (t === '__call__' && e.priv.partialCallType && l.ClassType.isSameGenericClass(l.TypeBase.isInstance(e) ? l.ClassType.cloneAsInstantiable(e) : e, p)) {
                  n = i.Symbol.createWithType(4, e.priv.partialCallType);
                }
                const y = {
                  symbol: n,
                  isInstanceMember: r,
                  isClassMember: c,
                  isClassVar: o.isEffectivelyClassVar(n, u),
                  classType: p,
                  unspecializedClassType: a,
                  isReadOnly: false,
                  isTypeDeclared: d,
                  skippedUndeclaredType: s
                };
                yield y;
              } else {
                s = true;
              }
            }
          }
        }
      } else {
        if (l.isAnyOrUnknown(e)) {
          const t = {
            symbol: i.Symbol.createWithType(0, e),
            isInstanceMember: false,
            isClassMember: true,
            isClassVar: false,
            classType: e,
            unspecializedClassType: e,
            isReadOnly: false,
            isTypeDeclared: false,
            skippedUndeclaredType: false
          };
          yield t;
        }
      }
    }
    function z(e, t) {
      var n;
      if (l.ClassType.hasNamedTupleEntry(e, t)) {
        return true;
      }
      if (l.ClassType.isDataClassFrozen(e)) {
        const a = (n = e.shared) === null || n === undefined ? undefined : n.dataClassEntries;
        if (a == null ? undefined : a.some(e => e.name === t)) {
          return true;
        }
      }
      return false;
    }
    function* U(e, t = 0, n) {
      if (l.isClass(e)) {
        let a = n === undefined;
        for (const r of e.shared.mro) {
          if (!a && n) {
            if (l.isClass(r)) {
              if (l.ClassType.isSameGenericClass(r, n)) {
                a = true;
                continue;
              }
              continue;
            }
            a = true;
          }
          const s = x(r, e, undefined);
          if (t & 2 && l.isInstantiableClass(s) && l.ClassType.isBuiltIn(s, 'object')) {
            break;
          }
          if (t & 4 && l.isInstantiableClass(s) && l.ClassType.isBuiltIn(s, 'type')) {
            break;
          }
          yield [r, s];
          if (t & 1) {
            break;
          }
        }
      }
    }
    function V(e, t, n) {
      for (const a of t) {
        if ((!n || a.priv.scopeId === n) && !e.find(e => l.isTypeSame(e, a))) {
          e.push(a);
        }
      }
    }
    function R(e) {
      if (e.shared.typeParams.length === 0 || e.priv.typeArgs || !e.shared.typeVarScopeId) {
        return e;
      }
      return N(e, new s.ConstraintSolution(), {
        replaceUnsolved: {
          scopeIds: [e.shared.typeVarScopeId],
          tupleClassType: undefined
        }
      });
    }
    function L(e) {
      const t = l.ClassType.getTypeParams(e);
      let n;
      n = e.priv.tupleTypeArgs ? [W(H(e, e.priv.tupleTypeArgs, e.priv.isTypeArgExplicit, true))] : e.priv.typeArgs;
      return B(t, n);
    }
    function B(e, t) {
      const n = new s.ConstraintSolution();
      if (t) {
        e.forEach((e, a) => {
          if (a < t.length) {
            n.setType(e, t[a]);
          }
        });
        return n;
      } else {
        return n;
      }
    }
    function j(e, t) {
      var n;
      const a = l.TypeVarType.createInstance('__type_of_self__');
      const r = (n = v(e)) !== null && n !== undefined ? n : '';
      a.shared.isSynthesized = true;
      a.shared.isSynthesizedSelf = true;
      a.priv.scopeId = r;
      a.priv.scopeName = '';
      a.priv.nameWithScope = l.TypeVarType.makeNameWithScope(a.shared.name, r, a.priv.scopeName);
      const s = l.ClassType.specialize(e, undefined, false, !!e.priv.includeSubclasses);
      a.shared.boundType = l.ClassType.cloneAsInstance(s);
      if (t) {
        return l.TypeVarType.cloneAsInstantiable(a);
      } else {
        return a;
      }
    }
    function q(e) {
      return l.isClassInstance(e) && e.shared.mro.some(e => l.isClass(e) && l.ClassType.isBuiltIn(e, 'type'));
    }
    function G(e, t, n = 0) {
      return !(n > l.maxTypeRecursionCount) && (n++, !!l.TypeBase.isInstantiable(e) || !!(t == null ? undefined : t.honorTypeVarBounds) && !!l.isTypeVar(e) && !!e.shared.boundType && !!G(e.shared.boundType, t, n) || !!q(e) || !!l.isUnion(e) && e.priv.subtypes.every(e => G(e, t, n)));
    }
    function W(e, t = true) {
      var n;
      var a;
      if (((n = e.cached) === null || n === undefined ? undefined : n.instanceType) && t) {
        return e.cached.instanceType;
      }
      let r = c(e, e => {
        switch (e.category) {
          case 6:
            if (l.ClassType.isBuiltIn(e, 'type')) {
              if (l.TypeBase.isInstance(e)) {
                if (!e.priv.typeArgs || e.priv.typeArgs.length < 1) {
                  return l.UnknownType.create();
                } else {
                  return e.priv.typeArgs[0];
                }
              }
              if (e.priv.typeArgs && e.priv.typeArgs.length > 0 && !l.isAnyOrUnknown(e.priv.typeArgs[0])) {
                return K(e.priv.typeArgs[0]);
              }
            }
            return l.ClassType.cloneAsInstance(e, t);
          case 4:
            if (l.TypeBase.isInstantiable(e)) {
              return l.FunctionType.cloneAsInstance(e);
            }
            break;
          case 9:
            if (l.TypeBase.isInstantiable(e)) {
              return l.TypeVarType.cloneAsInstance(e);
            }
            break;
          case 2:
            return l.AnyType.convertToInstance(e);
          case 1:
            return l.UnknownType.convertToInstance(e);
          case 3:
            return l.NeverType.convertToInstance(e);
          case 0:
            return l.UnboundType.convertToInstance(e);
        }
        return e;
      }, {
        skipElideRedundantLiterals: true
      });
      const s = (a = e.props) === null || a === undefined ? undefined : a.typeAliasInfo;
      if (s && e !== r) {
        r = l.TypeBase.cloneForTypeAlias(r, s);
      }
      if (e !== r && t) {
        if (!e.cached) {
          e.cached = {};
        }
        e.cached.instanceType = r;
      }
      return r;
    }
    function K(e, t = true) {
      var n;
      if ((n = e.cached) === null || n === undefined ? undefined : n.instantiableType) {
        return e.cached.instantiableType;
      }
      const a = c(e, e => {
        switch (e.category) {
          case 6:
            return l.ClassType.cloneAsInstantiable(e, t);
          case 4:
            return l.FunctionType.cloneAsInstantiable(e);
          case 9:
            return l.TypeVarType.cloneAsInstantiable(e);
        }
        return e;
      });
      if (e !== a) {
        if (!e.cached) {
          e.cached = {};
        }
        e.cached.instantiableType = a;
      }
      return a;
    }
    function $(e) {
      const t = [];
      e.forEach(e => {
        if (l.isTypeVar(e.type)) {
          if (l.isUnpackedTypeVarTuple(e.type)) {
            t.push(l.TypeVarType.cloneForUnpacked(e.type, true));
            return;
          }
          if (l.isUnpackedTypeVar(e.type)) {
            if (e.type.shared.boundType && l.isClassInstance(e.type.shared.boundType) && S(e.type.shared.boundType) && e.type.shared.boundType.priv.tupleTypeArgs) {
              t.push($(e.type.shared.boundType.priv.tupleTypeArgs));
            }
            return;
          }
        }
        t.push(e.type);
      });
      return l.combineTypes(t);
    }
    function H(e, t, n = true, a = false) {
      const r = l.ClassType.specialize(e, [$(t)], n, undefined, t);
      if (a) {
        r.priv.isUnpacked = true;
      }
      return r;
    }
    function Z(e) {
      if (l.isClassInstance(e) && S(e) && e.priv.tupleTypeArgs && e.priv.isUnpacked) {
        return l.combineTypes(e.priv.tupleTypeArgs.map(e => e.type));
      } else {
        return e;
      }
    }
    function Y(e) {
      var t;
      if (l.isClassInstance(e)) {
        if (l.ClassType.isBuiltIn(e, ['Generator', 'AsyncGenerator'])) {
          return e.priv.typeArgs;
        }
        if (l.ClassType.isBuiltIn(e, 'AwaitableGenerator')) {
          if ((t = e.priv.typeArgs) === null || t === undefined) {
            return undefined;
          } else {
            return t.slice(0, 3);
          }
        }
      }
    }
    function J(e, t, n = 0) {
      var a;
      if (n > l.maxTypeRecursionCount) {
        return false;
      }
      n++;
      const r = !(t == null ? undefined : t.ignorePseudoGeneric) && !(t == null ? undefined : t.ignoreSelf);
      if (r && ((a = e.cached) === null || a === undefined ? undefined : a.requiresSpecialization) !== undefined) {
        return e.cached.requiresSpecialization;
      }
      const s = function (e, t, n = 0) {
        var a;
        var r;
        if ((a = e.props) === null || a === undefined ? undefined : a.condition) {
          return true;
        }
        switch (e.category) {
          case 6:
            return (!l.ClassType.isPseudoGenericClass(e) || !(t == null ? undefined : t.ignorePseudoGeneric)) && (!!e.priv.isTypeArgExplicit || !(t == null ? undefined : t.ignoreImplicitTypeArgs)) && (!!e.priv.tupleTypeArgs && !!e.priv.tupleTypeArgs.some(e => J(e.type, t, n)) || (e.priv.typeArgs ? e.priv.typeArgs.some(e => J(e, t, n)) : l.ClassType.getTypeParams(e).length > 0));
          case 4:
            {
              for (let a = 0; a < e.shared.parameters.length; a++) {
                if (J(l.FunctionType.getParamType(e, a), t, n)) {
                  return true;
                }
              }
              const a = e.priv.specializedTypes && e.priv.specializedTypes.returnType ? e.priv.specializedTypes.returnType : e.shared.declaredReturnType;
              if (a) {
                if (J(a, t, n)) {
                  return true;
                }
              } else {
                if (e.priv.inferredReturnType && J(e.priv.inferredReturnType, t, n)) {
                  return true;
                }
              }
              return false;
            }
          case 5:
            {
              if (l.OverloadedType.getOverloads(e).some(e => J(e, t, n))) {
                return true;
              }
              const a = l.OverloadedType.getImplementation(e);
              return !!a && J(a, t, n);
            }
          case 8:
            return e.priv.subtypes.some(e => J(e, t, n));
          case 9:
            {
              if (!e.shared.recursiveAlias) {
                return !l.TypeVarType.isSelf(e) || !(t == null ? undefined : t.ignoreSelf);
              }
              const a = (r = e.props) === null || r === undefined ? undefined : r.typeAliasInfo;
              if (a == null ? undefined : a.typeArgs) {
                return a.typeArgs.some(e => J(e, t, n));
              }
            }
        }
        return false;
      }(e, t, n);
      if (r) {
        if (e.cached === undefined) {
          e.cached = {};
        }
        e.cached.requiresSpecialization = s;
      }
      return s;
    }
    function Q(e, t, n = 0) {
      if (n > l.maxTypeRecursionCount) {
        return;
      }
      n++;
      const a = e => {
        if (e && !t.some(t => t === e)) {
          t.push(e);
        }
      };
      switch (e.category) {
        case 6:
        case 4:
          a(e.shared.moduleName);
          break;
        case 5:
          {
            l.OverloadedType.getOverloads(e).forEach(e => {
              Q(e, t, n);
            });
            const a = l.OverloadedType.getImplementation(e);
            if (a) {
              Q(a, t, n);
            }
            break;
          }
        case 8:
          y(e, e => {
            Q(e, t, n);
          });
          break;
        case 7:
          a(e.priv.moduleName);
      }
    }
    function X(e) {
      if (l.isParamSpec(e)) {
        const t = l.FunctionType.createInstance('', '', '', 65536);
        l.FunctionType.addParamSpecVariadics(t, e);
        t.shared.typeVarScopeId = v(e);
        return t;
      }
      if (l.isFunction(e)) {
        if (l.FunctionType.isParamSpecValue(e)) {
          return e;
        }
        const t = l.FunctionType.createInstance('', '', '', e.shared.flags | 65536, e.shared.docString);
        t.shared.deprecatedMessage = e.shared.deprecatedMessage;
        e.shared.parameters.forEach((n, a) => {
          l.FunctionType.addParam(t, l.FunctionParam.create(n.category, l.FunctionType.getParamType(e, a), n.flags, n.name, l.FunctionType.getParamDefaultType(e, a), n.defaultExpr));
        });
        t.shared.typeVarScopeId = e.shared.typeVarScopeId;
        t.priv.constructorTypeVarScopeId = e.priv.constructorTypeVarScopeId;
        return t;
      }
      return l.ParamSpecType.getUnknown();
    }
    function ee(e) {
      const t = l.FunctionType.getParamSpecFromArgsKwargs(e);
      const n = l.FunctionType.cloneRemoveParamSpecArgsKwargs(e);
      let a = n.shared.parameters.length > 0;
      if (n.shared.parameters.length === 1) {
        const e = n.shared.parameters[0];
        if (l.isPositionOnlySeparator(e)) {
          a = false;
        }
      }
      if (!a && t) {
        return t;
      } else {
        return e;
      }
    }
    exports.UniqueSignatureTracker = class {
      constructor() {
        this._trackedSignatures = [];
      }
      getTrackedSignatures() {
        return this._trackedSignatures;
      }
      addTrackedSignatures(e) {
        e.forEach(e => {
          e.expressionOffsets.forEach(t => {
            this.addSignature(e.type, t);
          });
        });
      }
      findSignature(e) {
        let t = e;
        if (l.isFunction(e) && e.priv.overloaded) {
          t = e.priv.overloaded;
        }
        return this._trackedSignatures.find(e => l.isTypeSame(t, e.type));
      }
      addSignature(e, t) {
        var n;
        const a = l.isFunction(e) && (n = e.priv.overloaded) !== null && n !== undefined ? n : e;
        const r = this.findSignature(a);
        if (r) {
          if (!r.expressionOffsets.some(e => e === t)) {
            r.expressionOffsets.push(t);
          }
        } else {
          this._trackedSignatures.push({
            type: a,
            expressionOffsets: [t]
          });
        }
      }
    };
    class te {
      constructor() {
        this._pendingTypeVarTransformations = new Set();
        this._pendingFunctionTransformations = [];
      }
      get pendingTypeVarTransformations() {
        return this._pendingTypeVarTransformations;
      }
      apply(e, t) {
        var n;
        var r;
        var s;
        if (t > l.maxTypeRecursionCount) {
          return e;
        }
        t++;
        if ((n = (e = this.transformGenericTypeAlias(e, t)).props) === null || n === undefined ? undefined : n.condition) {
          e = this.transformConditionalType(e, t);
        }
        if (this.canSkipTransform(e)) {
          return e;
        }
        if (l.isAnyOrUnknown(e)) {
          return e;
        }
        if (d(e)) {
          return e;
        }
        if (l.isTypeVar(e)) {
          const n = (r = e.props) === null || r === undefined ? undefined : r.typeAliasInfo;
          if (e.shared.recursiveAlias) {
            if (!(n == null ? undefined : n.typeArgs)) {
              return e;
            }
            let a = false;
            const r = n.typeArgs.map(e => {
              const n = this.apply(e, t);
              if (n !== e) {
                a = true;
              }
              return n;
            });
            if (a) {
              return l.TypeBase.cloneForTypeAlias(e, {
                ...n,
                typeArgs: r
              });
            } else {
              return e;
            }
          }
          let a = e;
          if (!this._isTypeVarScopePending(e.priv.scopeId)) {
            let n;
            if (l.isParamSpec(e) && e.priv.paramSpecAccess) {
              n = e.priv.paramSpecAccess;
              e = l.TypeVarType.cloneForParamSpecAccess(e, undefined);
            }
            a = (s = this.transformTypeVar(e, t)) !== null && s !== undefined ? s : e;
            if (l.isParamSpec(e) && a !== e) {
              a = ee(X(a));
            }
            if (n) {
              a = l.isParamSpec(a) ? l.TypeVarType.cloneForParamSpecAccess(a, n) : l.UnknownType.create();
            }
            if (l.isTypeVarTuple(e) && e.priv.isInUnion) {
              a = Z(a);
            }
            if (e.priv.scopeId) {
              this._pendingTypeVarTransformations.add(e.priv.scopeId);
              a = this.apply(a, t);
              this._pendingTypeVarTransformations.delete(e.priv.scopeId);
            }
          }
          return a;
        }
        if (l.isUnion(e)) {
          const n = c(e, e => {
            let n = this.apply(e, t);
            if (l.isTypeVarTuple(e) && !l.isTypeVarTuple(n)) {
              const e = [];
              y(n, t => {
                e.push(Z(t));
              });
              n = l.combineTypes(e);
            }
            if (this.transformUnionSubtype) {
              return this.transformUnionSubtype(e, n, t);
            } else {
              return n;
            }
          }, {
            retainTypeAlias: true
          });
          if (l.isNever(n)) {
            return l.UnknownType.create();
          } else {
            return n;
          }
        }
        if (l.isClass(e)) {
          return this.transformTypeVarsInClassType(e, t);
        }
        if (l.isFunction(e)) {
          if (this._pendingFunctionTransformations.some(t => t === e)) {
            return e;
          }
          this._pendingFunctionTransformations.push(e);
          const n = this.transformTypeVarsInFunctionType(e, t);
          this._pendingFunctionTransformations.pop();
          return n;
        }
        if (l.isOverloaded(e)) {
          if (this._pendingFunctionTransformations.some(t => t === e)) {
            return e;
          }
          this._pendingFunctionTransformations.push(e);
          let n = false;
          const r = l.OverloadedType.getOverloads(e);
          const s = [];
          r.forEach(e => {
            const r = this.transformTypeVarsInFunctionType(e, t);
            if (l.isFunction(r)) {
              s.push(r);
            } else {
              a.appendArray(s, l.OverloadedType.getOverloads(r));
            }
            if (r !== e) {
              n = true;
            }
          });
          const i = l.OverloadedType.getImplementation(e);
          let o = i;
          if (i) {
            o = this.apply(i, t);
            if (o !== i) {
              n = true;
            }
          }
          this._pendingFunctionTransformations.pop();
          if (n) {
            return l.OverloadedType.create(s, o);
          } else {
            return e;
          }
        }
        return e;
      }
      canSkipTransform(e) {
        return !J(e);
      }
      transformTypeVar(e, t) {}
      transformTupleTypeVar(e, t) {}
      transformUnionSubtype(e, t, n) {
        return t;
      }
      doForEachConstraintSet(e) {
        return e();
      }
      transformGenericTypeAlias(e, t) {
        var n;
        const a = (n = e.props) === null || n === undefined ? undefined : n.typeAliasInfo;
        if (!a || !a.shared.typeParams || !a.typeArgs) {
          return e;
        }
        let r = false;
        const s = a.typeArgs.map(n => {
          const a = this.apply(n, t);
          if (e !== a) {
            r = true;
          }
          return a;
        });
        if (r) {
          return l.TypeBase.cloneForTypeAlias(e, {
            ...a,
            typeArgs: s
          });
        } else {
          return e;
        }
      }
      transformConditionalType(e, t) {
        return e;
      }
      transformTypeVarsInClassType(e, t) {
        var n;
        const r = l.ClassType.getTypeParams(e);
        if (r.length === 0 && !l.ClassType.isSpecialBuiltIn(e) && !l.ClassType.isBuiltIn(e, 'type')) {
          return e;
        }
        let s;
        let i;
        let o = false;
        let p = true;
        if (l.ClassType.isTupleClass(e)) {
          if (e.priv.tupleTypeArgs) {
            i = [];
            e.priv.tupleTypeArgs.forEach(n => {
              const r = this.apply(n.type, t);
              if (r !== n.type) {
                o = true;
              }
              if (l.isUnpackedTypeVarTuple(n.type) && l.isClassInstance(r) && S(r) && r.priv.tupleTypeArgs) {
                a.appendArray(i, r.priv.tupleTypeArgs);
              } else {
                if (l.isUnpackedClass(r) && r.priv.tupleTypeArgs) {
                  a.appendArray(i, r.priv.tupleTypeArgs);
                } else {
                  if (!n.isUnbounded || !l.isTypeVar(n.type) || !l.isNever(r) || e.priv.tupleTypeArgs.length !== 1) {
                    i.push({
                      type: r,
                      isUnbounded: n.isUnbounded,
                      isOptional: n.isOptional
                    });
                  }
                }
              }
            });
          } else {
            if (r.length > 0) {
              i = this.transformTupleTypeVar(r[0], t);
              if (i) {
                o = true;
              } else {
                const e = this.apply(r[0], t);
                i = [{
                  type: e,
                  isUnbounded: true
                }];
                o = true;
                p = false;
              }
            }
          }
          if (i && i.length > 0) {
            s = [$(i)];
          }
        }
        if (!s) {
          const a = (n = e.priv.typeArgs) !== null && n !== undefined ? n : r;
          if (!e.priv.typeArgs) {
            p = false;
          }
          s = a.map(e => {
            let n = this.apply(e, t);
            if (n !== e) {
              o = true;
              if (l.isTypeVar(e) && l.isTypeVarTuple(e) && e.priv.isInUnion) {
                n = Z(n);
              }
            }
            return n;
          });
        }
        if (o) {
          return l.ClassType.specialize(e, s, p, undefined, i);
        } else {
          return e;
        }
      }
      transformTypeVarsInFunctionType(e, t) {
        return this.doForEachConstraintSet(() => {
          let n = e;
          const a = l.FunctionType.getEffectiveReturnType(n);
          const r = a ? this.apply(a, t) : undefined;
          let s = a !== r;
          const i = {
            parameterTypes: [],
            parameterDefaultTypes: undefined,
            returnType: r
          };
          const o = l.FunctionType.getParamSpecFromArgsKwargs(n);
          if (o) {
            const e = this.transformTypeVar(o, t);
            if (e) {
              const t = X(e);
              const a = l.FunctionType.getParamSpecFromArgsKwargs(t);
              if (t.shared.parameters.length > 0 || !a || !l.isTypeSame(o, a)) {
                n = l.FunctionType.applyParamSpecValue(n, t);
              }
            }
          }
          let p;
          let d;
          const c = [];
          for (let e = 0; e < n.shared.parameters.length; e++) {
            const a = l.FunctionType.getParamType(n, e);
            const r = this.apply(a, t);
            i.parameterTypes.push(r);
            let o = l.FunctionType.getParamDefaultType(n, e);
            if (o) {
              const e = this.apply(o, t);
              if (e !== o) {
                o = e;
                s = true;
              }
            }
            c.push(o);
            if (p === undefined && l.isTypeVarTuple(a) && n.shared.parameters[e].category === 1) {
              p = e;
              if (l.isClassInstance(r) && S(r) && r.priv.isUnpacked) {
                d = r.priv.tupleTypeArgs;
              }
            }
            if (a !== r) {
              s = true;
            }
          }
          let u;
          if (n.priv.inferredReturnType) {
            u = this.apply(n.priv.inferredReturnType, t);
            if (u !== n.priv.inferredReturnType) {
              s = true;
            }
          }
          if (n.priv.boundToType) {
            const e = this.apply(n.priv.boundToType, t);
            if (e !== n.priv.boundToType && l.isClass(e)) {
              n = l.FunctionType.clone(n, false, e);
            }
          }
          if (n.priv.strippedFirstParamType) {
            const e = this.apply(n.priv.strippedFirstParamType, t);
            if (e !== n.priv.strippedFirstParamType) {
              n = l.TypeBase.cloneType(n);
              n.priv.strippedFirstParamType = e;
            }
          }
          if (!s) {
            return n;
          }
          if (c.some(e => e !== undefined)) {
            i.parameterDefaultTypes = c;
          }
          if (!d) {
            return l.FunctionType.specialize(n, i, u);
          }
          const m = l.TypeBase.isInstantiable(n) ? l.FunctionType.createInstantiable(n.shared.flags | 64) : l.FunctionType.createSynthesizedInstance('', n.shared.flags);
          let y = false;
          let g = false;
          i.parameterTypes.forEach((e, t) => {
            if (t === p) {
              let e = false;
              d.forEach(t => {
                l.FunctionType.addParam(m, l.FunctionParam.create(t.isUnbounded || l.isTypeVarTuple(t.type) ? 1 : 0, t.type, l.FunctionParamFlags.NameSynthesized | l.FunctionParamFlags.TypeDeclared, `__p${m.shared.parameters.length}`));
                if (t.isUnbounded) {
                  e = true;
                }
              });
              if (e) {
                g = true;
              } else {
                y = true;
              }
            } else {
              const a = n.shared.parameters[t];
              if (l.isKeywordOnlySeparator(a) || a.category === 2) {
                y = false;
              }
              if (a.category === 0 && a.name && y) {
                l.FunctionType.addKeywordOnlyParamSeparator(m);
                y = false;
              }
              if (a.category !== 0 || !!a.name || !g) {
                l.FunctionType.addParam(m, l.FunctionParam.create(a.category, e, a.flags, a.name && l.FunctionParam.isNameSynthesized(a) ? `__p${m.shared.parameters.length}` : a.name, l.FunctionType.getParamDefaultType(n, t), a.defaultExpr));
              }
            }
          });
          m.shared.declaredReturnType = i.returnType;
          return m;
        });
      }
      _isTypeVarScopePending(e) {
        return !!e && this._pendingTypeVarTransformations.has(e);
      }
    }
    exports.TypeVarTransformer = te;
    class ne extends te {
      constructor(e, t) {
        super();
        this._liveTypeParams = e;
        this._invalidTypeVars = t;
      }
      transformTypeVar(e) {
        const t = this._liveTypeParams.find(t => t.shared.name === e.shared.name);
        if (!t || l.isParamSpec(t) !== l.isParamSpec(e)) {
          this._invalidTypeVars.add(e.shared.name);
        }
        return l.UnknownType.create();
      }
    }
    class ae extends te {
      constructor(e, t) {
        super();
        this._signatureTracker = e;
        this._expressionOffset = t;
      }
      transformGenericTypeAlias(e, t) {
        return e;
      }
      transformTypeVarsInClassType(e, t) {
        return e;
      }
      transformTypeVarsInFunctionType(e, t) {
        if (e.shared.typeParams.length === 0) {
          return super.transformTypeVarsInFunctionType(e, t);
        }
        let n = e;
        const a = this._signatureTracker.findSignature(e);
        if (a) {
          let t = a.expressionOffsets.findIndex(e => e === this._expressionOffset);
          if (t < 0) {
            t = a.expressionOffsets.length;
          }
          if (t > 0) {
            const a = new s.ConstraintSolution();
            e.shared.typeParams.forEach(e => {
              if (e.priv.scopeType === 1) {
                const n = l.TypeVarType.cloneForNewName(e, `${e.shared.name}(${t})`);
                a.setType(e, n);
              }
            });
            n = N(e, a);
            r.assert(l.isFunction(n) || l.isOverloaded(n));
          }
        }
        this._signatureTracker.addSignature(e, this._expressionOffset);
        return n;
      }
    }
    class re extends te {
      constructor(e) {
        super();
        this._scopeIds = e;
      }
      transformTypeVar(e) {
        if (this._isTypeVarInScope(e)) {
          return this._replaceTypeVar(e);
        }
      }
      _isTypeVarInScope(e) {
        return !!e.priv.scopeId && (!this._scopeIds || this._scopeIds.includes(e.priv.scopeId));
      }
      _replaceTypeVar(e) {
        return l.TypeVarType.cloneAsBound(e);
      }
    }
    class se extends te {
      constructor(e) {
        super();
        this._scopeIds = e;
      }
      transformTypeVar(e) {
        if (e.priv.freeTypeVar && this._isTypeVarInScope(e.priv.freeTypeVar)) {
          return e.priv.freeTypeVar;
        }
      }
      _isTypeVarInScope(e) {
        return !!e.priv.scopeId && this._scopeIds.includes(e.priv.scopeId);
      }
    }
    class ie extends te {
      constructor(e, t) {
        super();
        this._solution = e;
        this._options = t;
        this._isSolvingDefaultType = false;
      }
      transformTypeVar(e, t) {
        var n;
        var a;
        var r;
        const s = this._solution.getSolutionSet((n = this._activeConstraintSetIndex) !== null && n !== undefined ? n : 0);
        if (this._isSolvingDefaultType && !e.priv.scopeId) {
          const n = this._getReplacementForDefaultByName(e, s);
          return n || (e.shared.isDefaultExplicit ? this.apply(e.shared.defaultType, t) : l.UnknownType.create());
        }
        if (!this._shouldReplaceTypeVar(e)) {
          return;
        }
        let i = s.getType(e);
        if (i) {
          if (l.isParamSpec(e)) {
            return i;
          }
          i = l.TypeBase.isInstantiable(e) ? l.isAnyOrUnknown(i) && this._options.typeClassType && l.isInstantiableClass(this._options.typeClassType) ? l.ClassType.specialize(l.ClassType.cloneAsInstance(this._options.typeClassType), [i]) : K(i, false) : c(i, e => l.isClassInstance(e) && (e.priv.includeSubclasses || (e = l.ClassType.cloneAsInstance(l.ClassType.cloneAsInstantiable(e))), e.shared.typeParams && !e.priv.typeArgs && this._options.replaceUnsolved) ? this._options.replaceUnsolved.useUnknown ? b(e, this._options.replaceUnsolved.tupleClassType) : R(e) : e);
          if (l.isTypeVarTuple(i) && l.isTypeVarTuple(e) && e.priv.isUnpacked) {
            return l.TypeVarType.cloneForUnpacked(i, e.priv.isInUnion);
          }
          if (!l.isTypeVarTuple(i) && l.isTypeVar(i) && l.isTypeVar(e) && e.priv.isUnpacked) {
            return l.TypeVarType.cloneForUnpacked(i);
          }
          if (!l.isTypeVarTuple(e) && l.isClassInstance(i) && i.priv.tupleTypeArgs && i.priv.isUnpacked) {
            i = $(i.priv.tupleTypeArgs);
          }
          if (l.isUnpackedTypeVar(e) && l.isClass(i)) {
            i = l.ClassType.cloneForUnpacked(i);
          }
          if (!l.isTypeVar(i) || !l.TypeVarType.isUnification(i) || !this._options.replaceUnsolved) {
            return i;
          }
        }
        if (this._shouldReplaceUnsolvedTypeVar(e)) {
          if (e.shared.isDefaultExplicit && !((a = this._options.replaceUnsolved) === null || a === undefined ? undefined : a.useUnknown)) {
            return this._solveDefaultType(e, t);
          } else {
            return _(e, (r = this._options.replaceUnsolved) === null || r === undefined ? undefined : r.tupleClassType);
          }
        } else {
          return undefined;
        }
      }
      transformUnionSubtype(e, t) {
        var n;
        var a;
        var r;
        if (!((n = this._options.replaceUnsolved) === null || n === undefined ? undefined : n.eliminateUnsolvedInUnions)) {
          return t;
        }
        const s = this._solution.getSolutionSet((a = this._activeConstraintSetIndex) !== null && a !== undefined ? a : 0);
        if (l.isTypeVar(e)) {
          if (!this._shouldReplaceTypeVar(e) || !this._shouldReplaceUnsolvedTypeVar(e)) {
            return t;
          }
          const n = s.getType(e);
          if (n && (!l.isTypeVar(n) || !l.TypeVarType.isUnification(n))) {
            return t;
          }
          if (e === t) {
            return;
          }
          if (this._options.replaceUnsolved && l.isUnknown(t)) {
            return;
          }
        } else {
          if ((r = e.props) === null || r === undefined ? undefined : r.condition) {
            for (const t of e.props.condition) {
              if (l.TypeVarType.isUnification(t.typeVar) && !s.getType(t.typeVar)) {
                return;
              }
            }
          }
        }
        return t;
      }
      transformTupleTypeVar(e) {
        var t;
        if (!this._shouldReplaceTypeVar(e)) {
          const t = e.shared.defaultType;
          if (e.shared.isDefaultExplicit && l.isClassInstance(t) && t.priv.tupleTypeArgs) {
            return t.priv.tupleTypeArgs;
          } else {
            return undefined;
          }
        }
        const n = this._solution.getSolutionSet((t = this._activeConstraintSetIndex) !== null && t !== undefined ? t : 0).getType(e);
        if (n && l.isClassInstance(n) && n.priv.tupleTypeArgs && l.isUnpackedClass(n)) {
          return n.priv.tupleTypeArgs;
        }
      }
      transformConditionalType(e, t) {
        var n;
        var a;
        var r;
        var s;
        if (!((n = e.props) === null || n === undefined ? undefined : n.condition)) {
          return e;
        }
        const i = this._solution.getSolutionSet((a = this._activeConstraintSetIndex) !== null && a !== undefined ? a : 0);
        for (const t of e.props.condition) {
          if (!l.TypeVarType.hasConstraints(t.typeVar)) {
            continue;
          }
          const e = (s = (r = t.typeVar.priv) === null || r === undefined ? undefined : r.freeTypeVar) !== null && s !== undefined ? s : t.typeVar;
          if (!i.getType(e) || t.constraintIndex >= e.shared.constraints.length) {
            continue;
          }
          const n = i.getType(e);
          if (!n) {
            continue;
          }
          const a = e.shared.constraints[t.constraintIndex];
          if (!l.isTypeSame(a, n)) {
            return l.NeverType.createNever();
          }
        }
        return e;
      }
      doForEachConstraintSet(e) {
        const t = this._solution.getSolutionSets();
        if (t.length <= 1) {
          return e();
        }
        if (this._activeConstraintSetIndex !== undefined) {
          return e();
        }
        const n = t.map((t, n) => {
          this._activeConstraintSetIndex = n;
          return e();
        });
        this._activeConstraintSetIndex = undefined;
        const a = [];
        y(l.combineTypes(n), e => {
          r.assert(l.isFunction(e));
          e = l.FunctionType.cloneWithNewFlags(e, e.shared.flags | 256);
          a.push(e);
        });
        if (a.length === 1) {
          return a[0];
        } else {
          return l.OverloadedType.create(a);
        }
      }
      _getReplacementForDefaultByName(e, t) {
        let n;
        const a = `${e.shared.name}.`;
        t.doForEachTypeVar((e, t) => {
          if (t.startsWith(a)) {
            n = e;
          }
        });
        return n;
      }
      _shouldReplaceTypeVar(e) {
        return !!e.priv.scopeId && !l.TypeVarType.isBound(e);
      }
      _shouldReplaceUnsolvedTypeVar(e) {
        var t;
        if (this.pendingTypeVarTransformations.size > 0) {
          return false;
        }
        if (!e.priv.scopeId) {
          return false;
        }
        if (!this._options.replaceUnsolved) {
          return false;
        }
        if (!this._options.replaceUnsolved.scopeIds.includes(e.priv.scopeId)) {
          return false;
        }
        const n = (t = this._options.replaceUnsolved) === null || t === undefined ? undefined : t.unsolvedExemptTypeVars;
        return !n || !n.some(t => l.isTypeSame(t, e, {
          ignoreTypeFlags: true
        }));
      }
      _solveDefaultType(e, t) {
        const n = e.shared.defaultType;
        const a = this._isSolvingDefaultType;
        this._isSolvingDefaultType = true;
        const r = this.apply(n, t);
        this._isSolvingDefaultType = a;
        return r;
      }
    }
    class oe extends te {
      constructor(e, t) {
        super();
        this._liveTypeVarScopes = e;
        this._usageOffset = t;
      }
      transformTypeVar(e) {
        if (!this._isTypeVarLive(e)) {
          return l.TypeVarType.cloneAsUnificationVar(e, this._usageOffset);
        }
      }
      _isTypeVarLive(e) {
        return this._liveTypeVarScopes.some(t => {
          var n;
          return e.priv.scopeId === t || ((n = e.priv.freeTypeVar) === null || n === undefined ? undefined : n.priv.scopeId) === t;
        });
      }
    }
  },
  8307: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeWalker = undefined;
    const a = require(48281);
    const r = require(21024);
    exports.TypeWalker = class {
      constructor() {
        this._recursionCount = 0;
        this._isWalkCanceled = false;
        this._hitRecursionLimit = false;
      }
      get isRecursionLimitHit() {
        return this._hitRecursionLimit;
      }
      get isWalkCanceled() {
        return this._isWalkCanceled;
      }
      walk(e) {
        var t;
        if (this._recursionCount > r.maxTypeRecursionCount) {
          this._hitRecursionLimit = true;
        } else {
          if (!this._isWalkCanceled) {
            this._recursionCount++;
            if ((t = e.props) === null || t === undefined ? undefined : t.typeAliasInfo) {
              this.visitTypeAlias(e);
            }
            switch (e.category) {
              case 0:
                this.visitUnbound(e);
                break;
              case 2:
                this.visitAny(e);
                break;
              case 1:
                this.visitUnknown(e);
                break;
              case 3:
                this.visitNever(e);
                break;
              case 4:
                this.visitFunction(e);
                break;
              case 5:
                this.visitOverloaded(e);
                break;
              case 6:
                this.visitClass(e);
                break;
              case 7:
                this.visitModule(e);
                break;
              case 8:
                this.visitUnion(e);
                break;
              case 9:
                this.visitTypeVar(e);
                break;
              default:
                a.assertNever(e);
            }
            this._recursionCount--;
          }
        }
      }
      cancelWalk() {
        this._isWalkCanceled = true;
      }
      visitTypeAlias(e) {
        var t;
        const n = (t = e.props) === null || t === undefined ? undefined : t.typeAliasInfo;
        a.assert(n !== undefined);
        if (n.typeArgs) {
          for (const e of n.typeArgs) {
            this.walk(e);
            if (this._isWalkCanceled) {
              break;
            }
          }
        }
      }
      visitUnbound(e) {}
      visitAny(e) {}
      visitUnknown(e) {}
      visitNever(e) {}
      visitFunction(e) {
        var t;
        for (let t = 0; t < e.shared.parameters.length; t++) {
          if (e.shared.parameters[t].name) {
            const n = r.FunctionType.getParamType(e, t);
            this.walk(n);
            if (this._isWalkCanceled) {
              break;
            }
          }
        }
        if (!this._isWalkCanceled && !r.FunctionType.isParamSpecValue(e) && !r.FunctionType.isParamSpecValue(e)) {
          const n = (t = e.shared.declaredReturnType) !== null && t !== undefined ? t : e.priv.inferredReturnType;
          if (n) {
            this.walk(n);
          }
        }
      }
      visitOverloaded(e) {
        const t = r.OverloadedType.getOverloads(e);
        for (const e of t) {
          this.walk(e);
          if (this._isWalkCanceled) {
            break;
          }
        }
        const n = r.OverloadedType.getImplementation(e);
        if (n) {
          this.walk(n);
        }
      }
      visitClass(e) {
        var t;
        if (!r.ClassType.isPseudoGenericClass(e)) {
          const n = ((t = e.priv.tupleTypeArgs) === null || t === undefined ? undefined : t.map(e => e.type)) || e.priv.typeArgs;
          if (n) {
            for (const e of n) {
              this.walk(e);
              if (this._isWalkCanceled) {
                break;
              }
            }
          }
        }
      }
      visitModule(e) {}
      visitUnion(e) {
        for (const t of e.priv.subtypes) {
          this.walk(t);
          if (this._isWalkCanceled) {
            break;
          }
        }
      }
      visitTypeVar(e) {}
    };
  },
  66308: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createTypedDictType = function (e, t, n, a) {
      var r;
      var s;
      var i;
      var o;
      var l;
      const y = m.getFileInfo(t);
      let f;
      if (a.length === 0) {
        e.addDiagnostic(p.DiagnosticRule.reportCallIssue, u.LocMessage.typedDictFirstArg(), t);
      } else {
        const n = a[0];
        if (n.argCategory === 0 && n.valueExpression && n.valueExpression.nodeType === 48) {
          f = n.valueExpression.d.strings.map(e => e.d.value).join('');
        } else {
          e.addDiagnostic(p.DiagnosticRule.reportArgumentType, u.LocMessage.typedDictFirstArg(), a[0].valueExpression || t);
        }
      }
      const _ = f || 'TypedDict';
      const C = T.ClassType.createInstantiable(_, g.getClassFullName(t, y.moduleName, _), y.moduleName, y.fileUri, 4194308, g.getTypeSourceId(t), undefined, n.shared.effectiveMetaclass);
      C.shared.baseClasses.push(n);
      v.computeMroLinearization(C);
      const I = T.ClassType.getSymbolTable(C);
      I.set('__class__', h.Symbol.createWithType(68, C));
      let w = false;
      if (a.length < 2) {
        e.addDiagnostic(p.DiagnosticRule.reportCallIssue, u.LocMessage.typedDictSecondArgDict(), t);
      } else {
        const n = a[1];
        if (n.argCategory === 0 && n.valueExpression && n.valueExpression.nodeType === 18) {
          w = true;
          k(e, n.valueExpression, I, false);
        } else {
          if (n.name) {
            const t = new Set();
            for (let n = 1; n < a.length; n++) {
              const r = a[n];
              if (!r.name || !r.valueExpression) {
                continue;
              }
              if (t.has(r.name.d.value)) {
                e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictEntryUnique(), r.valueExpression);
                continue;
              }
              t.add(r.name.d.value);
              const s = new h.Symbol(8);
              const i = {
                type: 1,
                node: r.name,
                uri: y.fileUri,
                typeAnnotationNode: r.valueExpression,
                isRuntimeTypeExpression: true,
                range: d.convertOffsetsToRange(r.name.start, c.TextRange.getEnd(r.valueExpression), y.lines),
                moduleName: y.moduleName,
                isInExceptSuite: false
              };
              s.addDeclaration(i);
              I.set(r.name.d.value, s);
            }
          } else {
            e.addDiagnostic(p.DiagnosticRule.reportArgumentType, u.LocMessage.typedDictSecondArgDict(), t);
          }
        }
      }
      if (w) {
        const n = a.slice(2);
        for (const a of n) {
          if (((r = a.name) === null || r === undefined ? undefined : r.d.value) === 'total' || ((s = a.name) === null || s === undefined ? undefined : s.d.value) === 'closed') {
            if (!a.valueExpression || a.valueExpression.nodeType !== 14 || a.valueExpression.d.constType !== 15 && a.valueExpression.d.constType !== 33) {
              e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictBoolParam().format({
                name: a.name.d.value
              }), a.valueExpression || t);
            } else {
              if (a.name.d.value === 'total' && a.valueExpression.d.constType === 15) {
                C.shared.flags |= 32;
              } else {
                if (a.name.d.value === 'closed' && a.valueExpression.d.constType === 33 && m.getFileInfo(t).diagnosticRuleSet.enableExperimentalFeatures) {
                  C.shared.flags |= 24;
                }
              }
            }
          } else {
            if (((i = a.name) === null || i === undefined ? undefined : i.d.value) === 'extra_items') {
              C.shared.typedDictExtraItemsExpr = a.valueExpression;
              C.shared.flags |= 16;
            } else {
              e.addDiagnostic(p.DiagnosticRule.reportCallIssue, u.LocMessage.typedDictExtraArgs(), a.valueExpression || t);
            }
          }
        }
        if (T.ClassType.isTypedDictMarkedClosed(C) && C.shared.typedDictExtraItemsExpr) {
          const a = n.find(e => {
            var t;
            return ((t = e.name) === null || t === undefined ? undefined : t.d.value) === 'extra_items';
          });
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictExtraItemsClosed(), (o = a == null ? undefined : a.valueExpression) !== null && o !== undefined ? o : t);
        }
      }
      b(e, t, C);
      if (((l = t.parent) === null || l === undefined ? undefined : l.nodeType) === 3 && f) {
        const n = t.parent.d.leftExpr;
        const a = n.nodeType === 54 ? n.d.valueExpr : n;
        if (a.nodeType === 38 && a.d.value !== f) {
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictAssignedName().format({
            name: f
          }), a);
        }
      }
      return C;
    };
    exports.createTypedDictTypeInlined = function (e, t, n) {
      const a = m.getFileInfo(t);
      const r = '<TypedDict>';
      const s = T.ClassType.createInstantiable(r, g.getClassFullName(t, a.moduleName, r), a.moduleName, a.fileUri, 4, g.getTypeSourceId(t), undefined, n.shared.effectiveMetaclass);
      s.shared.baseClasses.push(n);
      v.computeMroLinearization(s);
      k(e, t, T.ClassType.getSymbolTable(s), true);
      b(e, t, s);
      return s;
    };
    exports.synthesizeTypedDictClassMethods = b;
    exports.getTypedDictMembersForClass = _;
    exports.getTypedDictMappingEquivalent = C;
    exports.getTypedDictDictEquivalent = I;
    exports.getEffectiveExtraItemsEntryType = S;
    exports.assignTypedDictToTypedDict = function (e, t, n, a, r, s, i = 0) {
      var o;
      var l;
      let p = true;
      const d = _(e, t);
      const c = _(e, n, true);
      const m = (o = c.extraItems) !== null && o !== undefined ? o : S(e, n);
      d.knownItems.forEach((o, l) => {
        if (!p && !a) {
          return;
        }
        const d = c.knownItems.get(l);
        if (d) {
          if (o.isRequired !== d.isRequired && !o.isReadOnly) {
            const n = o.isRequired ? u.LocAddendum.typedDictFieldRequired() : u.LocAddendum.typedDictFieldNotRequired();
            if (a != null) {
              a.createAddendum().addMessage(n.format({
                name: l,
                type: e.printType(T.ClassType.cloneAsInstance(t))
              }));
            }
            p = false;
          }
          if (!o.isReadOnly && d.isReadOnly) {
            if (a != null) {
              a.createAddendum().addMessage(u.LocAddendum.typedDictFieldNotReadOnly().format({
                name: l,
                type: e.printType(T.ClassType.cloneAsInstance(t))
              }));
            }
            p = false;
          }
          const n = a == null ? undefined : a.createAddendum();
          if (!e.assignType(o.valueType, d.valueType, n == null ? undefined : n.createAddendum(), r, o.isReadOnly ? s : s | 1, i)) {
            if (n != null) {
              n.addMessage(u.LocAddendum.memberTypeMismatch().format({
                name: l
              }));
            }
            p = false;
          }
        } else {
          if (o.isRequired || !o.isReadOnly) {
            if (a != null) {
              a.createAddendum().addMessage(u.LocAddendum.typedDictFieldMissing().format({
                name: l,
                type: e.printType(T.ClassType.cloneAsInstance(n))
              }));
            }
            p = false;
          } else {
            if (T.isClassInstance(m.valueType)) {
              const t = a == null ? undefined : a.createAddendum();
              if (!e.assignType(o.valueType, m.valueType, t == null ? undefined : t.createAddendum(), r, s, i)) {
                if (t != null) {
                  t.addMessage(u.LocAddendum.memberTypeMismatch().format({
                    name: l
                  }));
                }
                p = false;
              }
            }
          }
        }
      });
      if (!p && !a) {
        return false;
      }
      if (T.ClassType.isTypedDictEffectivelyClosed(t)) {
        const o = (l = d.extraItems) !== null && l !== undefined ? l : S(e, t);
        c.knownItems.forEach((o, l) => {
          if (!d.knownItems.has(l)) {
            if (d.extraItems) {
              if (o.isRequired && !d.extraItems.isReadOnly) {
                if (a != null) {
                  a.createAddendum().addMessage(u.LocAddendum.typedDictFieldNotRequired().format({
                    name: l,
                    type: e.printType(T.ClassType.cloneAsInstance(t))
                  }));
                }
                p = false;
              }
              const c = a == null ? undefined : a.createAddendum();
              if (e.assignType(d.extraItems.valueType, o.valueType, c == null ? undefined : c.createAddendum(), r, d.extraItems.isReadOnly ? s : s | 1, i)) {
                if (!d.extraItems.isReadOnly && o.isReadOnly) {
                  if (a != null) {
                    a.createAddendum().addMessage(u.LocAddendum.typedDictFieldNotReadOnly().format({
                      name: l,
                      type: e.printType(T.ClassType.cloneAsInstance(n))
                    }));
                  }
                  p = false;
                }
              } else {
                if (c != null) {
                  c.addMessage(u.LocAddendum.typedDictExtraFieldTypeMismatch().format({
                    name: l,
                    type: e.printType(T.ClassType.cloneAsInstance(t))
                  }));
                }
                p = false;
              }
            } else {
              const n = a == null ? undefined : a.createAddendum();
              if (n != null) {
                n.addMessage(u.LocAddendum.typedDictExtraFieldNotAllowed().format({
                  name: l,
                  type: e.printType(T.ClassType.cloneAsInstance(t))
                }));
              }
              p = false;
            }
          }
        });
        const y = a == null ? undefined : a.createAddendum();
        if (e.assignType(o.valueType, m.valueType, y == null ? undefined : y.createAddendum(), r, o.isReadOnly ? s : s | 1, i)) {
          if (!o.isReadOnly && m.isReadOnly) {
            if (a != null) {
              a.createAddendum().addMessage(u.LocAddendum.typedDictFieldNotReadOnly().format({
                name: 'extra_items',
                type: e.printType(T.ClassType.cloneAsInstance(t))
              }));
            }
            p = false;
          }
        } else {
          if (y != null) {
            y.addMessage(u.LocAddendum.typedDictExtraFieldTypeMismatch().format({
              name: 'extra_items',
              type: e.printType(T.ClassType.cloneAsInstance(n))
            }));
          }
          p = false;
        }
      }
      return p;
    };
    exports.assignToTypedDict = function (e, t, n, a, r) {
      o.assert(T.isClassInstance(t));
      o.assert(T.ClassType.isTypedDictClass(t));
      o.assert(n.length === a.length);
      let s = true;
      const i = new Map();
      let l;
      let p = t;
      if (t.shared.typeParams.length > 0) {
        l = new y.ConstraintTracker();
        if (t.priv.typeArgs) {
          p = T.ClassType.specialize(t, undefined);
        }
      }
      const d = _(e, p);
      n.forEach((n, o) => {
        const p = n.type;
        if (T.isClassInstance(p) && T.ClassType.isBuiltIn(p, 'str') && v.isLiteralType(p)) {
          const c = p.priv.literalValue;
          const m = d.knownItems.get(c);
          if (m) {
            const t = r == null ? undefined : r.createAddendum();
            if (!e.assignType(m.valueType, a[o].type, t == null ? undefined : t.createAddendum(), l, 256)) {
              if (t) {
                t.addMessage(u.LocAddendum.typedDictFieldTypeMismatch().format({
                  name: p.priv.literalValue,
                  type: e.printType(a[o].type)
                }));
                t.addTextRange(n.node);
              }
              s = false;
            }
            if (!m.isRequired) {
              i.set(c, {
                valueType: a[o].type,
                isReadOnly: !!a[o].isReadOnly,
                isRequired: false,
                isProvided: true
              });
            }
            m.isProvided = true;
          } else {
            if (d.extraItems) {
              const t = r == null ? undefined : r.createAddendum();
              if (!e.assignType(d.extraItems.valueType, a[o].type, t == null ? undefined : t.createAddendum(), l, 256)) {
                if (t) {
                  t.addMessage(u.LocAddendum.typedDictFieldTypeMismatch().format({
                    name: 'extra_items',
                    type: e.printType(a[o].type)
                  }));
                  t.addTextRange(n.node);
                }
                s = false;
              }
            } else {
              s = false;
              if (r) {
                const a = r == null ? undefined : r.createAddendum();
                a.addMessage(u.LocAddendum.typedDictFieldUndefined().format({
                  name: p.priv.literalValue,
                  type: e.printType(T.ClassType.cloneAsInstance(t))
                }));
                a.addTextRange(n.node);
              }
            }
          }
        } else {
          s = false;
        }
      });
      if (!s) {
        return;
      }
      d.knownItems.forEach((n, a) => {
        if (n.isRequired && !n.isProvided) {
          if (r) {
            r.addMessage(u.LocAddendum.typedDictFieldRequired().format({
              name: a,
              type: e.printType(t)
            }));
          }
          s = false;
        }
      });
      if (!s) {
        return;
      }
      const c = l ? e.solveAndApplyConstraints(p, l) : t;
      if (i.size === 0) {
        return c;
      } else {
        return T.ClassType.cloneForNarrowedTypedDictEntries(c, i);
      }
    };
    exports.getTypeOfIndexedTypedDict = function (e, t, n, a) {
      if (t.d.items.length !== 1) {
        e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typeArgsMismatchOne().format({
          received: t.d.items.length
        }), t);
        return {
          type: T.UnknownType.create()
        };
      }
      if (t.d.trailingComma || t.d.items[0].d.name || t.d.items[0].d.argCategory !== 0) {
        return;
      }
      const r = _(e, n, a.method === 'get');
      const s = e.getTypeOfExpression(t.d.items[0].d.valueExpr);
      const i = s.type;
      let o = new l.DiagnosticAddendum();
      let d = true;
      const c = v.mapSubtypes(i, t => {
        if (T.isAnyOrUnknown(t)) {
          return t;
        }
        if (T.isClassInstance(t) && T.ClassType.isBuiltIn(t, 'str')) {
          if (t.priv.literalValue === undefined) {
            return T.UnknownType.create();
          }
          const p = t.priv.literalValue;
          const c = r.knownItems.get(p) ?? r.extraItems;
          if (c) {
            if (c.isRequired || c.isProvided || a.method !== 'get') {
              if (c.isReadOnly && a.method !== 'get') {
                o.addMessage(u.LocAddendum.keyReadOnly().format({
                  name: p,
                  type: e.printType(n)
                }));
              }
            } else {
              o.addMessage(u.LocAddendum.keyNotRequired().format({
                name: p,
                type: e.printType(n)
              }));
            }
            if (a.method === 'set') {
              if (!e.assignType(c.valueType, a.setType?.type ?? T.AnyType.create(), o)) {
                d = false;
              }
            } else {
              if (a.method === 'del' && c.isRequired) {
                o.addMessage(u.LocAddendum.keyRequiredDeleted().format({
                  name: p
                }));
                d = false;
              }
            }
            return c.valueType;
          } else {
            o.addMessage(u.LocAddendum.keyUndefined().format({
              name: p,
              type: e.printType(n)
            }));
            d = false;
            return T.UnknownType.create();
          }
        }
        o.addMessage(u.LocAddendum.typeNotStringLiteral().format({
          type: e.printType(t)
        }));
        d = false;
        return T.UnknownType.create();
      });
      if (!!a.setExpectedTypeDiag && !o.isEmpty() && !a.setExpectedTypeDiag.isEmpty()) {
        o = a.setExpectedTypeDiag;
      }
      if (!o.isEmpty()) {
        let n;
        n = a.method === 'set' ? u.LocMessage.typedDictSet() : a.method === 'del' ? u.LocMessage.typedDictDelete() : u.LocMessage.typedDictAccess();
        e.addDiagnostic(d ? p.DiagnosticRule.reportTypedDictNotRequiredAccess : p.DiagnosticRule.reportGeneralTypeIssues, n + o.getString(), t);
      }
      return {
        type: c,
        isIncomplete: !!s.isIncomplete
      };
    };
    exports.narrowForKeyAssignment = function (e, t) {
      var n;
      if (!T.ClassType.isTypedDictClass(e) || !e.shared.typedDictEntries) {
        return e;
      }
      const a = e.shared.typedDictEntries.knownItems.get(t);
      if (!a || a.isRequired) {
        return e;
      }
      const r = (n = e.priv.typedDictNarrowedEntries) === null || n === undefined ? undefined : n.get(t);
      if (r == null ? undefined : r.isProvided) {
        return e;
      }
      const s = e.priv.typedDictNarrowedEntries ? new Map(e.priv.typedDictNarrowedEntries) : new Map();
      s.set(t, {
        isProvided: true,
        isRequired: false,
        isReadOnly: a.isReadOnly,
        valueType: a.valueType
      });
      return T.ClassType.cloneForNarrowedTypedDictEntries(e, s);
    };
    const i = require(58147);
    const o = require(48281);
    const l = require(11479);
    const p = require(65880);
    const d = require(56814);
    const c = require(88754);
    const u = require(67703);
    const m = __importStar(require(26687));
    const y = require(86672);
    const g = __importStar(require(41557));
    const h = require(58253);
    const f = require(4064);
    const T = require(21024);
    const v = require(92324);
    function b(e, t, n) {
      var a;
      o.assert(T.ClassType.isTypedDictClass(n));
      const r = T.FunctionType.createSynthesizedInstance('__new__', 1);
      T.FunctionType.addParam(r, T.FunctionParam.create(0, n, T.FunctionParamFlags.TypeDeclared, 'cls'));
      T.FunctionType.addDefaultParams(r);
      r.shared.declaredReturnType = T.ClassType.cloneAsInstance(n);
      r.priv.constructorTypeVarScopeId = v.getTypeVarScopeId(n);
      const s = T.FunctionType.createSynthesizedInstance('__init__', 256);
      T.FunctionType.addParam(s, T.FunctionParam.create(0, T.ClassType.cloneAsInstance(n), T.FunctionParamFlags.TypeDeclared, 'self'));
      s.shared.declaredReturnType = e.getNoneType();
      s.priv.constructorTypeVarScopeId = v.getTypeVarScopeId(n);
      T.FunctionType.addParam(s, T.FunctionParam.create(0, T.ClassType.cloneAsInstance(n), T.FunctionParamFlags.TypeDeclared, '__map'));
      const l = _(e, n);
      const p = (a = l.extraItems) !== null && a !== undefined ? a : S(e, n);
      let d = l.knownItems.size > 0;
      if (l.knownItems.size > 0) {
        T.FunctionType.addPositionOnlyParamSeparator(s);
        T.FunctionType.addKeywordOnlyParamSeparator(s);
      }
      const c = T.FunctionType.createSynthesizedInstance('__init__', 256);
      T.FunctionType.addParam(c, T.FunctionParam.create(0, T.ClassType.cloneAsInstance(n), T.FunctionParamFlags.TypeDeclared, 'self'));
      c.shared.declaredReturnType = e.getNoneType();
      c.priv.constructorTypeVarScopeId = v.getTypeVarScopeId(n);
      if (l.knownItems.size > 0) {
        T.FunctionType.addKeywordOnlyParamSeparator(c);
      }
      l.knownItems.forEach((e, t) => {
        T.FunctionType.addParam(s, T.FunctionParam.create(0, e.valueType, T.FunctionParamFlags.TypeDeclared, t, e.valueType));
        T.FunctionType.addParam(c, T.FunctionParam.create(0, e.valueType, T.FunctionParamFlags.TypeDeclared, t, e.isRequired ? undefined : e.valueType));
        if (!e.isReadOnly) {
          d = false;
        }
      });
      if (l.extraItems && !T.isNever(l.extraItems.valueType)) {
        T.FunctionType.addParam(s, T.FunctionParam.create(2, l.extraItems.valueType, T.FunctionParamFlags.TypeDeclared, 'kwargs'));
        T.FunctionType.addParam(c, T.FunctionParam.create(2, l.extraItems.valueType, T.FunctionParamFlags.TypeDeclared, 'kwargs'));
      }
      const u = T.ClassType.getSymbolTable(n);
      const m = T.OverloadedType.create([s, c]);
      u.set('__init__', h.Symbol.createWithType(4, m));
      u.set('__new__', h.Symbol.createWithType(4, r));
      const y = e.getBuiltInType(t, 'str');
      if (T.isInstantiableClass(y)) {
        const f = T.FunctionParam.create(0, T.ClassType.cloneAsInstance(n), T.FunctionParamFlags.TypeDeclared, 'self');
        function b(e) {
          let t = T.TypeVarType.createInstance('__TDefault');
          t = T.TypeVarType.cloneForScopeId(t, e.shared.typeVarScopeId, n.shared.name, 1);
          return t;
        }
        function k(n, a, r, s = false, i = false) {
          const o = T.FunctionType.createSynthesizedInstance('get', 256);
          T.FunctionType.addParam(o, f);
          o.shared.typeVarScopeId = g.getScopeIdForNode(t);
          T.FunctionType.addParam(o, T.FunctionParam.create(0, n, T.FunctionParamFlags.TypeDeclared, 'k'));
          if (r) {
            const e = b(o);
            let t;
            let n;
            if (s) {
              t = T.AnyType.create();
              n = a;
            } else {
              t = i ? a : T.combineTypes([a, e]);
              n = t;
            }
            T.FunctionType.addParam(o, T.FunctionParam.create(0, t, T.FunctionParamFlags.TypeDeclared, 'default'));
            o.shared.declaredReturnType = n;
          } else {
            o.shared.declaredReturnType = s ? a : T.combineTypes([a, e.getNoneType()]);
          }
          return o;
        }
        function w(e, n, a) {
          const r = T.FunctionParam.create(0, e, T.FunctionParamFlags.TypeDeclared, 'k');
          const s = T.FunctionType.createSynthesizedInstance('pop', 256);
          T.FunctionType.addParam(s, f);
          T.FunctionType.addParam(s, r);
          s.shared.declaredReturnType = n;
          const i = T.FunctionType.createSynthesizedInstance('pop', 256);
          T.FunctionType.addParam(i, f);
          T.FunctionType.addParam(i, r);
          i.shared.typeVarScopeId = g.getScopeIdForNode(t);
          const o = b(i);
          let l;
          let p;
          if (a) {
            l = T.AnyType.create();
            p = n;
          } else {
            l = T.combineTypes([n, o]);
            p = l;
          }
          T.FunctionType.addParam(i, T.FunctionParam.create(0, l, T.FunctionParamFlags.TypeDeclared, 'default', l));
          i.shared.declaredReturnType = p;
          return [s, i];
        }
        function A(e, t) {
          const n = T.FunctionType.createSynthesizedInstance('setdefault', 256);
          T.FunctionType.addParam(n, f);
          T.FunctionType.addParam(n, T.FunctionParam.create(0, e, T.FunctionParamFlags.TypeDeclared, 'k'));
          T.FunctionType.addParam(n, T.FunctionParam.create(0, t, T.FunctionParamFlags.TypeDeclared, 'default'));
          n.shared.declaredReturnType = t;
          return n;
        }
        function x(t) {
          const n = T.FunctionType.createSynthesizedInstance('delitem', 256);
          T.FunctionType.addParam(n, f);
          T.FunctionType.addParam(n, T.FunctionParam.create(0, t, T.FunctionParamFlags.TypeDeclared, 'k'));
          n.shared.declaredReturnType = e.getNoneType();
          return n;
        }
        function P() {
          const a = T.FunctionType.createSynthesizedInstance('update', 256);
          T.FunctionType.addParam(a, f);
          const r = T.FunctionType.createSynthesizedInstance('update', 256);
          T.FunctionType.addParam(r, f);
          const s = T.FunctionType.createSynthesizedInstance('update', 256);
          T.FunctionType.addParam(s, f);
          T.FunctionType.addParam(a, T.FunctionParam.create(0, d ? T.NeverType.createNever() : T.ClassType.cloneAsInstance(T.ClassType.cloneForPartialTypedDict(n)), T.FunctionParamFlags.TypeDeclared, '__m'));
          if (l.knownItems.size > 0) {
            T.FunctionType.addPositionOnlyParamSeparator(a);
            T.FunctionType.addKeywordOnlyParamSeparator(s);
          }
          a.shared.declaredReturnType = e.getNoneType();
          r.shared.declaredReturnType = e.getNoneType();
          s.shared.declaredReturnType = e.getNoneType();
          const i = [];
          const o = e.getBuiltInType(t, 'tuple');
          l.knownItems.forEach((e, t) => {
            if (!e.isReadOnly) {
              if (o && T.isInstantiableClass(o) && y && T.isInstantiableClass(y)) {
                const n = v.specializeTupleClass(T.ClassType.cloneAsInstance(o), [{
                  type: T.ClassType.cloneWithLiteral(T.ClassType.cloneAsInstance(y), t),
                  isUnbounded: false
                }, {
                  type: e.valueType,
                  isUnbounded: false
                }]);
                i.push(n);
              }
              T.FunctionType.addParam(s, T.FunctionParam.create(0, e.valueType, T.FunctionParamFlags.TypeDeclared, t, T.AnyType.create(true)));
            }
          });
          const p = e.getTypingType(t, 'Iterable');
          if (p && T.isInstantiableClass(p)) {
            const e = T.ClassType.cloneAsInstance(p);
            T.FunctionType.addParam(r, T.FunctionParam.create(0, T.ClassType.specialize(e, [T.combineTypes(i)]), T.FunctionParamFlags.TypeDeclared, '__m'));
          }
          if (l.knownItems.size > 0) {
            T.FunctionType.addPositionOnlyParamSeparator(r);
          }
          return T.OverloadedType.create([r, a, s]);
        }
        const D = [];
        const N = [];
        const F = [];
        l.knownItems.forEach((e, t) => {
          const n = T.ClassType.cloneAsInstance(T.ClassType.cloneWithLiteral(y, t));
          D.push(k(n, e.valueType, false, e.isRequired));
          D.push(k(n, e.valueType, true, e.isRequired, e.isRequired));
          if (!e.isRequired && !e.isReadOnly) {
            i.appendArray(N, w(n, e.valueType, e.isRequired));
          }
          if (!e.isReadOnly) {
            F.push(A(n, e.valueType));
          }
        });
        const E = T.ClassType.cloneAsInstance(y);
        if (T.ClassType.isTypedDictEffectivelyClosed(n)) {
          D.push(k(E, T.combineTypes([p.valueType, e.getNoneType()]), false, true));
          D.push(k(E, p.valueType, true));
        } else {
          D.push(k(E, T.AnyType.create(), false));
          D.push(k(E, T.AnyType.create(), true));
        }
        u.set('get', h.Symbol.createWithType(4, T.OverloadedType.create(D)));
        if (N.length > 0) {
          u.set('pop', h.Symbol.createWithType(4, T.OverloadedType.create(N)));
        }
        if (F.length > 0) {
          u.set('setdefault', h.Symbol.createWithType(4, T.OverloadedType.create(F)));
        }
        if (!d) {
          u.set('__delitem__', h.Symbol.createWithType(4, x(E)));
        }
        u.set('update', h.Symbol.createWithType(4, P()));
        const M = I(e, n);
        if (M) {
          const z = T.FunctionType.createSynthesizedInstance('clear');
          T.FunctionType.addParam(z, f);
          z.shared.declaredReturnType = e.getNoneType();
          u.set('clear', h.Symbol.createWithType(4, z));
          const U = T.FunctionType.createSynthesizedInstance('popitem');
          T.FunctionType.addParam(U, f);
          let V = e.getTupleClassType();
          V = V && T.isInstantiableClass(V) ? v.specializeTupleClass(T.ClassType.cloneAsInstance(V), [{
            type: E,
            isUnbounded: false
          }, {
            type: M,
            isUnbounded: false
          }], true) : T.UnknownType.create();
          U.shared.declaredReturnType = V;
          u.set('popitem', h.Symbol.createWithType(4, U));
        }
        const O = C(e, n);
        if (O) {
          let R = E;
          if (l.extraItems && T.isNever(l.extraItems.valueType)) {
            R = T.combineTypes(Array.from(l.knownItems.keys()).map(e => T.ClassType.cloneWithLiteral(E, e)));
          }
          ['items', 'keys', 'values'].forEach(n => {
            const a = T.FunctionType.createSynthesizedInstance(n);
            T.FunctionType.addParam(a, f);
            const r = e.getTypingType(t, `dict_${n}`);
            if (r && T.isInstantiableClass(r) && r.shared.typeParams.length === 2) {
              a.shared.declaredReturnType = T.ClassType.specialize(T.ClassType.cloneAsInstance(r), [R, O]);
              u.set(n, h.Symbol.createWithType(4, a));
            }
          });
        }
      }
    }
    function _(e, t, n = false) {
      var a;
      if (!t.shared.typedDictEntries) {
        const n = {
          knownItems: new Map(),
          extraItems: undefined
        };
        w(e, t, n);
        if (T.ClassType.isTypedDictMarkedClosed(t) && !n.extraItems) {
          n.extraItems = {
            valueType: T.NeverType.createNever(),
            isReadOnly: false,
            isRequired: false,
            isProvided: false
          };
        }
        t.shared.typedDictEntries = n;
      }
      const r = v.buildSolutionFromSpecializedClass(t);
      const s = new Map();
      t.shared.typedDictEntries.knownItems.forEach((e, n) => {
        const a = {
          ...e
        };
        a.valueType = v.applySolvedTypeVars(a.valueType, r);
        if (t.priv.isTypedDictPartial) {
          a.isRequired = false;
          if (a.isReadOnly) {
            a.valueType = T.NeverType.createNever();
          } else {
            a.isReadOnly = true;
          }
        }
        s.set(n, a);
      });
      if (n && t.priv.typedDictNarrowedEntries) {
        t.priv.typedDictNarrowedEntries.forEach((e, t) => {
          const n = {
            ...e
          };
          n.valueType = v.applySolvedTypeVars(n.valueType, r);
          s.set(t, n);
        });
      }
      return {
        knownItems: s,
        extraItems: (a = t.shared.typedDictEntries) === null || a === undefined ? undefined : a.extraItems
      };
    }
    function C(e, t) {
      o.assert(T.isInstantiableClass(t));
      o.assert(T.ClassType.isTypedDictClass(t));
      if (!T.ClassType.isTypedDictEffectivelyClosed(t)) {
        return;
      }
      const n = _(e, t);
      const a = [];
      n.knownItems.forEach(e => {
        a.push(e.valueType);
      });
      if (n.extraItems) {
        a.push(n.extraItems.valueType);
      }
      const r = T.combineTypes(a);
      if (T.isClassInstance(r) && T.ClassType.isBuiltIn(r, 'object')) {
        return undefined;
      } else {
        return r;
      }
    }
    function I(e, t, n = 0) {
      o.assert(T.isInstantiableClass(t));
      o.assert(T.ClassType.isTypedDictClass(t));
      if (!T.ClassType.isTypedDictEffectivelyClosed(t)) {
        return;
      }
      const a = _(e, t);
      if (!a.extraItems || a.extraItems.isReadOnly) {
        return;
      }
      let r = a.extraItems.valueType;
      let s = true;
      a.knownItems.forEach(t => {
        if (t.isReadOnly || t.isRequired) {
          s = false;
        }
        r = T.combineTypes([r, t.valueType]);
        if (!e.assignType(r, t.valueType, undefined, undefined, 1, n + 1)) {
          s = false;
        }
      });
      if (s) {
        return r;
      } else {
        return undefined;
      }
    }
    function k(e, t, n, a) {
      const r = new Set();
      const s = m.getFileInfo(t);
      t.d.items.forEach(t => {
        if (t.nodeType !== 20) {
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictSecondArgDictEntry(), t);
          return;
        }
        if (t.d.keyExpr.nodeType !== 48) {
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictEntryName(), t.d.keyExpr);
          return;
        }
        const i = t.d.keyExpr.d.strings.map(e => e.d.value).join('');
        if (!i) {
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictEmptyName(), t.d.keyExpr);
          return;
        }
        if (r.has(i)) {
          e.addDiagnostic(p.DiagnosticRule.reportGeneralTypeIssues, u.LocMessage.typedDictEntryUnique(), t.d.keyExpr);
          return;
        }
        r.add(i);
        const o = new h.Symbol(8);
        const l = {
          type: 1,
          node: t.d.keyExpr,
          uri: s.fileUri,
          typeAnnotationNode: t.d.valueExpr,
          isRuntimeTypeExpression: !a,
          range: d.convertOffsetsToRange(t.d.keyExpr.start, c.TextRange.getEnd(t.d.keyExpr), s.lines),
          moduleName: s.moduleName,
          isInExceptSuite: false,
          isInInlinedTypedDict: true
        };
        o.addDeclaration(l);
        n.set(i, o);
      });
      e.setTypeResultForNode(t, {
        type: T.UnknownType.create()
      });
    }
    function w(e, t, n, a = 0) {
      o.assert(T.ClassType.isTypedDictClass(t));
      if (a > T.maxTypeRecursionCount) {
        return;
      }
      a++;
      t.shared.baseClasses.forEach(r => {
        if (T.isInstantiableClass(r) && T.ClassType.isTypedDictClass(r)) {
          const s = v.partiallySpecializeType(r, t, e.getTypeClassType());
          o.assert(T.isClass(s));
          w(e, s, n, a);
        }
      });
      const r = v.buildSolutionFromSpecializedClass(t);
      if (T.ClassType.isTypedDictMarkedClosed(t)) {
        n.extraItems = {
          valueType: T.NeverType.createNever(),
          isReadOnly: false,
          isRequired: false,
          isProvided: false
        };
      } else {
        if (t.shared.typedDictExtraItemsExpr) {
          const a = e.getTypeOfExpressionExpectingType(t.shared.typedDictExtraItemsExpr, {
            allowReadOnly: true
          });
          n.extraItems = {
            valueType: v.convertToInstance(a.type),
            isReadOnly: !!a.isReadOnly,
            isRequired: false,
            isProvided: true
          };
        }
      }
      T.ClassType.getSymbolTable(t).forEach((a, s) => {
        if (!a.isIgnoredForProtocolMatch()) {
          const i = f.getLastTypedDeclarationForSymbol(a);
          if (i && i.type === 1) {
            let i = e.getEffectiveTypeOfSymbol(a);
            i = v.applySolvedTypeVars(i, r);
            let o = !T.ClassType.isCanOmitDictValues(t);
            let l = false;
            if (!function (e, t) {
              return t.getDeclarations().some(t => {
                if (t.type !== 1 || !t.typeAnnotationNode) {
                  return false;
                }
                return !!e.getTypeOfExpressionExpectingType(t.typeAnnotationNode, {
                  allowFinal: true,
                  allowRequired: true,
                  allowReadOnly: true
                }).isRequired;
              });
            }(e, a)) {
              if (function (e, t) {
                return t.getDeclarations().some(t => {
                  if (t.type !== 1 || !t.typeAnnotationNode) {
                    return false;
                  }
                  return !!e.getTypeOfExpressionExpectingType(t.typeAnnotationNode, {
                    allowFinal: true,
                    allowRequired: true,
                    allowReadOnly: true
                  }).isNotRequired;
                });
              }(e, a)) {
                o = false;
              }
            } else {
              o = true;
            }
            if (function (e, t) {
              return t.getDeclarations().some(t => {
                if (t.type !== 1 || !t.typeAnnotationNode) {
                  return false;
                }
                return !!e.getTypeOfExpressionExpectingType(t.typeAnnotationNode, {
                  allowFinal: true,
                  allowRequired: true,
                  allowReadOnly: true
                }).isReadOnly;
              });
            }(e, a)) {
              l = true;
            }
            const p = {
              valueType: i,
              isReadOnly: l,
              isRequired: o,
              isProvided: false
            };
            n.knownItems.set(s, p);
          }
        }
      });
    }
    function S(e, t) {
      var n;
      o.assert(T.ClassType.isTypedDictClass(t));
      if (T.ClassType.isTypedDictMarkedClosed(t)) {
        if ((n = t.shared.typedDictEntries) === null || n === undefined ? undefined : n.extraItems) {
          return t.shared.typedDictEntries.extraItems;
        } else {
          return {
            valueType: T.NeverType.createNever(),
            isReadOnly: true,
            isRequired: false,
            isProvided: false
          };
        }
      } else {
        return {
          valueType: e.getObjectType(),
          isReadOnly: true,
          isRequired: false,
          isProvided: false
        };
      }
    }
  },
  21024: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeVarType = exports.ParamSpecType = exports.TypeVarKind = exports.UnionType = exports.TypeCondition = exports.AnyType = exports.NeverType = exports.OverloadedType = exports.FunctionType = exports.FunctionParam = exports.FunctionParamFlags = exports.ClassType = exports.ModuleType = exports.UnknownType = exports.UnboundType = exports.TypeBase = exports.maxTypeRecursionCount = exports.EnumLiteral = exports.UnificationScopeId = undefined;
    exports.isPositionOnlySeparator = C;
    exports.isKeywordOnlySeparator = I;
    exports.isNever = k;
    exports.isAny = function (e) {
      return e.category === 2;
    };
    exports.isUnknown = w;
    exports.isAnyOrUnknown = S;
    exports.isUnbound = A;
    exports.isUnion = x;
    exports.isPossiblyUnbound = function e(t) {
      if (A(t)) {
        return true;
      }
      if (x(t)) {
        return t.priv.subtypes.find(t => e(t)) !== undefined;
      }
      return false;
    };
    exports.isClass = P;
    exports.isInstantiableClass = D;
    exports.isClassInstance = N;
    exports.isModule = function (e) {
      return e.category === 7;
    };
    exports.isTypeVar = F;
    exports.isParamSpec = E;
    exports.isTypeVarTuple = M;
    exports.isUnpackedTypeVarTuple = O;
    exports.isUnpackedTypeVar = z;
    exports.isUnpackedClass = U;
    exports.isUnpacked = function (e) {
      return O(e) || z(e) || U(e);
    };
    exports.isFunction = V;
    exports.isOverloaded = function (e) {
      return e.category === 5;
    };
    exports.getTypeAliasInfo = function (e) {
      var t;
      var n;
      if ((t = e.props) === null || t === undefined ? undefined : t.typeAliasInfo) {
        return e.props.typeAliasInfo;
      }
      if (F(e) && e.shared.recursiveAlias && e.shared.boundType && ((n = e.shared.boundType.props) === null || n === undefined ? undefined : n.typeAliasInfo)) {
        return e.shared.boundType.props.typeAliasInfo;
      }
      return;
    };
    exports.isTypeSame = R;
    exports.removeUnknownFromUnion = function (e) {
      return L(e, e => w(e));
    };
    exports.removeUnbound = function (e) {
      if (x(e)) {
        return L(e, e => A(e));
      }
      if (A(e)) {
        return l.create();
      }
      return e;
    };
    exports.removeFromUnion = L;
    exports.findSubtype = B;
    exports.combineTypes = j;
    exports.isSameWithoutLiteralValue = q;
    const a = require(58147);
    const r = require(48281);
    exports.UnificationScopeId = '-';
    class s {
      constructor(e, t, n, a, r) {
        this.classFullName = e;
        this.className = t;
        this.itemName = n;
        this.itemType = a;
        this.isReprEnum = r;
      }
      getName() {
        return `${this.classFullName}.${this.itemName}`;
      }
    }
    var i;
    var o;
    var l;
    var p;
    var d;
    var c;
    var u;
    var m;
    var y;
    var g;
    var h;
    var f;
    var T;
    var v;
    var b;
    var _;
    function C(e) {
      return e.category === 0 && !e.name;
    }
    function I(e) {
      return e.category === 1 && !e.name;
    }
    function k(e) {
      return e.category === 3;
    }
    function w(e) {
      return e.category === 1;
    }
    function S(e) {
      return e.category === 2 || e.category === 1 || !!x(e) && e.priv.subtypes.find(e => !S(e)) === undefined;
    }
    function A(e) {
      return e.category === 0;
    }
    function x(e) {
      return e.category === 8;
    }
    function P(e) {
      return e.category === 6;
    }
    function D(e) {
      return e.category === 6 && i.isInstantiable(e);
    }
    function N(e) {
      return e.category === 6 && i.isInstance(e);
    }
    function F(e) {
      return e.category === 9;
    }
    function E(e) {
      return e.category === 9 && e.shared.kind === v.ParamSpec;
    }
    function M(e) {
      return e.category === 9 && e.shared.kind === v.TypeVarTuple;
    }
    function O(e) {
      return M(e) && !!e.priv.isUnpacked && !e.priv.isInUnion;
    }
    function z(e) {
      return F(e) && !M(e) && !!e.priv.isUnpacked;
    }
    function U(e) {
      return !!P(e) && !!e.priv.isUnpacked;
    }
    function V(e) {
      return e.category === 4;
    }
    function R(e, n, a = {}, r = 0) {
      var s;
      var i;
      var o;
      var p;
      var c;
      var u;
      var y;
      var g;
      if (e === n) {
        return true;
      }
      if (e.category !== n.category) {
        if (a.treatAnySameAsUnknown) {
          if (e.category === 2 && n.category === 1) {
            return true;
          }
          if (e.category === 1 && n.category === 2) {
            return true;
          }
        }
        return false;
      }
      if (!a.ignoreTypeFlags && (e.flags & 3) != (n.flags & 3)) {
        return false;
      }
      if (r > exports.maxTypeRecursionCount) {
        return true;
      }
      r++;
      if (a.honorTypeForm) {
        const t = (s = e.props) === null || s === undefined ? undefined : s.typeForm;
        const o = (i = n.props) === null || i === undefined ? undefined : i.typeForm;
        if (t) {
          if (!o) {
            return false;
          }
          if (!R(t, o, a, r)) {
            return false;
          }
        } else {
          if (o) {
            return false;
          }
        }
      }
      switch (e.category) {
        case 6:
          {
            const t = n;
            if (!d.isSameGenericClass(e, t, r)) {
              return false;
            }
            if (!a.ignoreConditions && !f.isSame((o = e.props) === null || o === undefined ? undefined : o.condition, (p = n.props) === null || p === undefined ? undefined : p.condition)) {
              return false;
            }
            if (!a.ignorePseudoGeneric || !d.isPseudoGenericClass(e)) {
              if (e.priv.tupleTypeArgs && t.priv.tupleTypeArgs) {
                const n = e.priv.tupleTypeArgs || [];
                const s = t.priv.tupleTypeArgs || [];
                if (n.length !== s.length) {
                  return false;
                }
                for (let e = 0; e < n.length; e++) {
                  if (!R(n[e].type, s[e].type, {
                    ...a,
                    ignoreTypeFlags: false
                  }, r)) {
                    return false;
                  }
                  if (n[e].isUnbounded !== s[e].isUnbounded) {
                    return false;
                  }
                }
              } else {
                const n = e.priv.typeArgs || [];
                const s = t.priv.typeArgs || [];
                const i = Math.max(n.length, s.length);
                for (let e = 0; e < i; e++) {
                  if (!R(e < n.length ? n[e] : l.create(), e < s.length ? s[e] : l.create(), {
                    ...a,
                    ignoreTypeFlags: false
                  }, r)) {
                    return false;
                  }
                }
              }
            }
            return !!d.isLiteralValueSame(e, t) && !e.priv.isUnpacked == !t.priv.isUnpacked && !e.priv.isTypedDictPartial == !t.priv.isTypedDictPartial && (!a.honorIsTypeArgExplicit || !!e.priv.isTypeArgExplicit == !!t.priv.isTypeArgExplicit) && (!!a.ignoreTypedDictNarrowEntries || !!d.isTypedDictNarrowedEntriesSame(e, t));
          }
        case 4:
          {
            const t = n;
            const s = e.shared.parameters;
            const i = t.shared.parameters;
            if (s.length !== i.length) {
              return false;
            }
            if (m.isGradualCallableForm(e) !== m.isGradualCallableForm(t)) {
              return false;
            }
            const o = s.findIndex(e => C(e));
            const l = i.findIndex(e => C(e));
            for (let n = 0; n < s.length; n++) {
              const p = s[n];
              const d = i[n];
              if (p.category !== d.category) {
                return false;
              }
              const c = o !== undefined && n > o;
              if (c !== (l !== undefined && n > l)) {
                return false;
              }
              if (c) {
                if (p.name !== d.name) {
                  return false;
                }
              } else {
                if (C(p) && C(d)) {
                  continue;
                }
                if (I(p) && I(d)) {
                  continue;
                }
              }
              if (!R(m.getParamType(e, n), m.getParamType(t, n), {
                ...a,
                ignoreTypeFlags: false
              }, r)) {
                return false;
              }
            }
            let p = e.shared.declaredReturnType;
            if (e.priv.specializedTypes && e.priv.specializedTypes.returnType) {
              p = e.priv.specializedTypes.returnType;
            }
            if (!p && e.priv.inferredReturnType) {
              p = e.priv.inferredReturnType;
            }
            let d = t.shared.declaredReturnType;
            if (t.priv.specializedTypes && t.priv.specializedTypes.returnType) {
              d = t.priv.specializedTypes.returnType;
            }
            if (!d && t.priv.inferredReturnType) {
              d = t.priv.inferredReturnType;
            }
            return !p && !d || !!p && !!d && !!R(p, d, {
              ...a,
              ignoreTypeFlags: false
            }, r);
          }
        case 5:
          {
            const t = n;
            if (e.priv._overloads.length !== t.priv._overloads.length) {
              return false;
            }
            for (let n = 0; n < e.priv._overloads.length; n++) {
              if (!R(e.priv._overloads[n], t.priv._overloads[n], a, r)) {
                return false;
              }
            }
            return true;
          }
        case 8:
          {
            const t = n;
            const s = e.priv.subtypes;
            const i = t.priv.subtypes;
            if (s.length !== i.length) {
              return false;
            }
            const o = new Set();
            return B(e, e => !T.containsType(t, e, a, o, r)) === undefined;
          }
        case 9:
          {
            const t = n;
            if (e.priv.scopeId !== t.priv.scopeId) {
              return false;
            }
            if (e.priv.nameWithScope !== t.priv.nameWithScope) {
              return false;
            }
            if (e.shared.recursiveAlias && t.shared.recursiveAlias) {
              const t = ((u = (c = e == null ? undefined : e.props) === null || c === undefined ? undefined : c.typeAliasInfo) === null || u === undefined ? undefined : u.typeArgs) || [];
              const s = ((g = (y = n == null ? undefined : n.props) === null || y === undefined ? undefined : y.typeAliasInfo) === null || g === undefined ? undefined : g.typeArgs) || [];
              const i = Math.max(t.length, s.length);
              for (let e = 0; e < i; e++) {
                if (!R(e < t.length ? t[e] : h.create(), e < s.length ? s[e] : h.create(), {
                  ...a,
                  ignoreTypeFlags: false
                }, r)) {
                  return false;
                }
              }
            }
            if (M(e) && M(t) && !e.priv.isInUnion != !t.priv.isInUnion) {
              return false;
            }
            if (e.shared === t.shared) {
              return true;
            }
            if (E(e) !== E(t)) {
              return false;
            }
            if (M(e) !== M(t)) {
              return false;
            }
            if (e.shared.name !== t.shared.name || e.shared.isSynthesized !== t.shared.isSynthesized || e.shared.declaredVariance !== t.shared.declaredVariance || e.priv.scopeId !== t.priv.scopeId) {
              return false;
            }
            const s = e.shared.boundType;
            const i = t.shared.boundType;
            if (s) {
              if (!i || !R(s, i, {
                ...a,
                ignoreTypeFlags: false
              }, r)) {
                return false;
              }
            } else {
              if (i) {
                return false;
              }
            }
            const o = e.shared.constraints;
            const l = t.shared.constraints;
            if (o.length !== l.length) {
              return false;
            }
            for (let e = 0; e < o.length; e++) {
              if (!R(o[e], l[e], {
                ...a,
                ignoreTypeFlags: false
              }, r)) {
                return false;
              }
            }
            return true;
          }
        case 7:
          {
            const t = n;
            return e.priv.fields === t.priv.fields || e.priv.fields.size === 0 && t.priv.fields.size === 0;
          }
        case 1:
          {
            const t = n;
            return e.priv.isIncomplete === t.priv.isIncomplete;
          }
      }
      return true;
    }
    function L(e, t) {
      if (x(e)) {
        const n = e.priv.subtypes.filter(e => !t(e));
        if (n.length < e.priv.subtypes.length) {
          const t = j(n);
          if (x(t)) {
            T.addTypeAliasSource(t, e);
          }
          return t;
        }
      }
      return e;
    }
    function B(e, t) {
      if (x(e)) {
        return e.priv.subtypes.find(e => t(e));
      } else {
        if (t(e)) {
          return e;
        } else {
          return undefined;
        }
      }
    }
    function j(e, t) {
      var n;
      var r;
      let s;
      [s, e] = a.partition(e, k);
      if (e.length === 0) {
        if (s.length > 0) {
          if ((n = s.find(e => e.priv.isNoReturn)) !== null && n !== undefined) {
            return n;
          } else {
            return s[0];
          }
        } else {
          return g.createNever();
        }
      }
      let i;
      let o = true;
      if (e.length > 1) {
        for (let t = 1; t < e.length; t++) {
          if (e[t] !== e[0]) {
            o = false;
            break;
          }
        }
      }
      if (o) {
        return e[0];
      }
      const p = new Set();
      for (let t = 0; t < e.length; t++) {
        const n = e[t];
        if (x(n)) {
          if (!i) {
            i = e.slice(0, t);
          }
          i = i.concat(n.priv.subtypes);
          if ((r = n.props) === null || r === undefined ? undefined : r.typeAliasInfo) {
            p.add(n);
          } else {
            if (n.priv.typeAliasSources) {
              n.priv.typeAliasSources.forEach(e => {
                p.add(e);
              });
            }
          }
        } else {
          if (i) {
            i.push(n);
          }
        }
      }
      i = i ?? e;
      i = i.sort((e, t) => P(e) && e.priv.literalValue !== undefined ? 1 : P(t) && t.priv.literalValue !== undefined ? -1 : N(e) && e.priv.isEmptyContainer ? 1 : N(t) && t.priv.isEmptyContainer ? -1 : 0);
      if (i.length === 0) {
        return l.create();
      }
      const c = T.create();
      if (p.size > 0) {
        c.priv.typeAliasSources = p;
      }
      let u = false;
      i.forEach((e, n) => {
        if (n === 0) {
          T.addType(c, e);
        } else {
          if ((t == null ? undefined : t.maxSubtypeCount) === undefined || c.priv.subtypes.length < t.maxSubtypeCount) {
            (function (e, t, n) {
              var a;
              var r;
              var s;
              if (P(t) && !((a = t.props) === null || a === undefined ? undefined : a.condition)) {
                const n = N(t) ? e.priv.literalInstances : e.priv.literalClasses;
                if (d.isBuiltIn(t, 'str') && t.priv.literalValue !== undefined && n.literalStrMap !== undefined) {
                  if (!n.literalStrMap.has(t.priv.literalValue)) {
                    T.addType(e, t);
                  }
                  return;
                }
                if (d.isBuiltIn(t, 'int') && t.priv.literalValue !== undefined && n.literalIntMap !== undefined) {
                  if (!n.literalIntMap.has(t.priv.literalValue)) {
                    T.addType(e, t);
                  }
                  return;
                }
                if (d.isEnumClass(t) && t.priv.literalValue !== undefined && n.literalEnumMap !== undefined) {
                  const a = t.priv.literalValue;
                  if (!n.literalEnumMap.has(a.getName())) {
                    T.addType(e, t);
                  }
                  return;
                }
              }
              const i = P(t) && d.isPseudoGenericClass(t);
              for (let a = 0; a < e.priv.subtypes.length; a++) {
                const o = e.priv.subtypes[a];
                if (R(o, t, {
                  honorTypeForm: true
                })) {
                  return;
                }
                if (i && R(o, t, {
                  ignorePseudoGeneric: true,
                  honorTypeForm: true
                })) {
                  e.priv.subtypes[a] = d.specialize(t, t.shared.typeParams.map(() => l.create()));
                  return;
                }
                if (N(o) && N(t)) {
                  if (n && q(o, t) && o.priv.literalValue === undefined) {
                    return;
                  }
                  if (d.isBuiltIn(o, 'bool') && !((r = o.props) === null || r === undefined ? undefined : r.condition) && d.isBuiltIn(t, 'bool') && !((s = t.props) === null || s === undefined ? undefined : s.condition) && t.priv.literalValue !== undefined && !t.priv.literalValue === o.priv.literalValue) {
                    e.priv.subtypes[a] = d.cloneWithLiteral(o, undefined);
                    return;
                  }
                  if (d.isTypedDictClass(o) && d.isSameGenericClass(o, t) && !o.priv.typeArgs && !t.priv.typeArgs) {
                    if (d.isTypedDictNarrower(t, o)) {
                      return;
                    }
                    if (d.isTypedDictNarrower(o, t)) {
                      e.priv.subtypes[a] = t;
                      return;
                    }
                  }
                }
                if (N(t) && t.priv.isEmptyContainer && N(o) && d.isSameGenericClass(o, t)) {
                  return;
                }
              }
              T.addType(e, t);
            })(c, e, !(t == null ? undefined : t.skipElideRedundantLiterals));
          } else {
            u = true;
          }
        }
      });
      if (u) {
        return h.create();
      } else {
        if (c.priv.subtypes.length === 1) {
          return c.priv.subtypes[0];
        } else {
          return c;
        }
      }
    }
    function q(e, t) {
      return !!R(e, t) || (D(t) && t.priv.literalValue !== undefined ? R(e, t = d.cloneWithLiteral(t, undefined)) : !!N(t) && t.priv.literalValue !== undefined && R(e, t = d.cloneWithLiteral(t, undefined), {
        ignoreConditions: true
      }));
    }
    exports.EnumLiteral = s;
    exports.maxTypeRecursionCount = 20;
    (function (e) {
      function t(e) {
        const t = {
          ...e
        };
        if (e.props) {
          t.props = {
            ...e.props
          };
        }
        if (e.priv) {
          t.priv = {
            ...e.priv
          };
        }
        t.cached = undefined;
        return t;
      }
      e.isInstantiable = function (e) {
        return !!(e.flags & 1);
      };
      e.isInstance = function (e) {
        return !!(e.flags & 2);
      };
      e.isAmbiguous = function (e) {
        return !!(e.flags & 4);
      };
      e.addProps = function (e) {
        if (!e.props) {
          e.props = {
            instantiableDepth: undefined,
            specialForm: undefined,
            typeForm: undefined,
            typeAliasInfo: undefined,
            condition: undefined
          };
        }
        return e.props;
      };
      e.getInstantiableDepth = function (e) {
        var t;
        var n;
        if ((n = (t = e.props) === null || t === undefined ? undefined : t.instantiableDepth) !== null && n !== undefined) {
          return n;
        } else {
          return 0;
        }
      };
      e.setSpecialForm = function (t, n) {
        e.addProps(t).specialForm = n;
      };
      e.setInstantiableDepth = function (t, n) {
        e.addProps(t).instantiableDepth = n;
      };
      e.setTypeAliasInfo = function (t, n) {
        e.addProps(t).typeAliasInfo = n;
      };
      e.setTypeForm = function (t, n) {
        e.addProps(t).typeForm = n;
      };
      e.setCondition = function (t, n) {
        e.addProps(t).condition = n;
      };
      e.cloneType = t;
      e.cloneAsSpecialForm = function (t, n) {
        const a = e.cloneType(t);
        e.setSpecialForm(a, n);
        return a;
      };
      e.cloneTypeAsInstance = function (t, n) {
        var a;
        var s;
        r.assert(e.isInstantiable(t));
        const i = e.cloneType(t);
        if ((a = i.props) === null || a === undefined ? undefined : a.typeForm) {
          e.setTypeForm(i, undefined);
        }
        const o = (s = i.props) === null || s === undefined ? undefined : s.instantiableDepth;
        if (o === undefined) {
          i.flags &= -2;
          i.flags |= 2;
        } else {
          if (o <= 1) {
            e.setInstantiableDepth(i, undefined);
          } else {
            e.setInstantiableDepth(i, o - 1);
          }
        }
        if (n) {
          if (!t.cached) {
            t.cached = {};
          }
          t.cached.typeBaseInstanceType = i;
        }
        return i;
      };
      e.cloneTypeAsInstantiable = function (t, n) {
        var a;
        var r;
        var s;
        const i = e.cloneType(t);
        if (e.isInstance(t)) {
          i.flags &= -3;
          i.flags |= 1;
        } else {
          const n = (a = t.props) === null || a === undefined ? undefined : a.instantiableDepth;
          e.setInstantiableDepth(i, n === undefined ? 1 : n + 1);
        }
        if ((r = i.props) === null || r === undefined ? undefined : r.typeAliasInfo) {
          e.setTypeAliasInfo(i, undefined);
        }
        if ((s = i.props) === null || s === undefined ? undefined : s.typeForm) {
          e.setTypeForm(i, undefined);
        }
        if (n) {
          if (!t.cached) {
            t.cached = {};
          }
          t.cached.typeBaseInstantiableType = i;
        }
        return i;
      };
      e.cloneForTypeAlias = function (n, a) {
        const r = t(n);
        e.setTypeAliasInfo(r, a);
        return r;
      };
      e.cloneWithTypeForm = function (n, a) {
        const r = t(n);
        e.setTypeForm(r, a);
        return r;
      };
      e.cloneForCondition = function (n, a) {
        var r;
        if (((r = n.props) === null || r === undefined ? undefined : r.condition) === undefined && a === undefined) {
          return n;
        }
        const s = t(n);
        e.setCondition(s, a);
        return s;
      };
      e.cloneForAmbiguousType = function (n) {
        if (e.isAmbiguous(n)) {
          return n;
        }
        const a = t(n);
        a.flags |= 4;
        return a;
      };
    })(i || (exports.TypeBase = i = {}));
    (function (e) {
      const t = {
        category: 0,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: undefined
      };
      e.create = function () {
        return t;
      };
      e.convertToInstance = function (t) {
        var n;
        if ((n = t.props) === null || n === undefined ? undefined : n.specialForm) {
          return e.create();
        } else {
          return t;
        }
      };
    })(o || (exports.UnboundType = o = {}));
    (function (e) {
      const t = {
        category: 1,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isIncomplete: false,
          possibleType: undefined
        }
      };
      const n = {
        category: 1,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isIncomplete: true,
          possibleType: undefined
        }
      };
      e.create = function (e = false) {
        if (e) {
          return n;
        } else {
          return t;
        }
      };
      e.createPossibleType = function (e, t) {
        return {
          category: 1,
          flags: 3,
          props: undefined,
          cached: undefined,
          shared: undefined,
          priv: {
            isIncomplete: t,
            possibleType: e
          }
        };
      };
      e.convertToInstance = function (t) {
        var n;
        if ((n = t.props) === null || n === undefined ? undefined : n.specialForm) {
          return e.create(t.priv.isIncomplete);
        } else {
          return t;
        }
      };
    })(l || (exports.UnknownType = l = {}));
    (function (e) {
      e.create = function (e, t, n) {
        return {
          category: 7,
          flags: 1,
          props: undefined,
          cached: undefined,
          shared: undefined,
          priv: {
            fields: n || new Map(),
            docString: undefined,
            notPresentFieldType: undefined,
            loaderFields: new Map(),
            moduleName: e,
            fileUri: t
          }
        };
      };
      e.getField = function (e, t) {
        let n = e.priv.fields.get(t);
        if (e.priv.loaderFields) {
          if (n) {
            if (n.getDeclarations().length === 1) {
              const a = e.priv.loaderFields.get(t);
              if (a && !a.isExternallyHidden()) {
                n = a;
              }
            }
          } else {
            n = e.priv.loaderFields.get(t);
          }
        }
        return n;
      };
    })(p || (exports.ModuleType = p = {}));
    (function (e) {
      function n(e, t) {
        if (!(e.shared.flags & 1)) {
          return false;
        }
        if (t !== undefined) {
          return (Array.isArray(t) ? t : [t]).some(t => t === e.shared.name || t === e.shared.fullName || t === e.priv.aliasName);
        }
        return true;
      }
      function a(n, a, r = 0) {
        if (!n.priv.isTypedDictPartial != !a.priv.isTypedDictPartial) {
          return false;
        }
        if (i.isInstance(n) !== i.isInstance(a)) {
          return false;
        }
        if (i.getInstantiableDepth(n) !== i.getInstantiableDepth(a)) {
          return false;
        }
        const s = n.shared;
        const o = a.shared;
        if (s === o) {
          return true;
        }
        if (s.fullName !== o.fullName || s.flags !== o.flags || s.typeSourceId !== o.typeSourceId || s.baseClasses.length !== o.baseClasses.length || s.typeParams.length !== o.typeParams.length) {
          return false;
        }
        if (r > exports.maxTypeRecursionCount) {
          return true;
        }
        r++;
        if (e.isBuiltIn(n, 'NamedTuple') && e.isBuiltIn(a, 'NamedTuple')) {
          return true;
        }
        if (e.isBuiltIn(n, 'tuple') && e.isBuiltIn(a, 'tuple')) {
          return true;
        }
        for (let e = 0; e < s.baseClasses.length; e++) {
          if (!R(s.baseClasses[e], o.baseClasses[e], {
            ignorePseudoGeneric: true
          }, r)) {
            return false;
          }
        }
        if ((s.declaredMetaclass || o.declaredMetaclass) && (!s.declaredMetaclass || !o.declaredMetaclass || !R(s.declaredMetaclass, o.declaredMetaclass, {
          ignorePseudoGeneric: true
        }, r))) {
          return false;
        }
        for (let e = 0; e < s.typeParams.length; e++) {
          if (!R(s.typeParams[e], o.typeParams[e], {
            ignorePseudoGeneric: true
          }, r)) {
            return false;
          }
        }
        return true;
      }
      e.createInstantiable = function (e, t, n, a, r, s, i, o, l) {
        return {
          category: 6,
          flags: 1,
          props: undefined,
          cached: undefined,
          shared: {
            name: e,
            fullName: t,
            moduleName: n,
            fileUri: a,
            flags: r,
            typeSourceId: s,
            baseClasses: [],
            declaredMetaclass: i,
            effectiveMetaclass: o,
            mro: [],
            fields: new Map(),
            typeParams: [],
            docString: l
          },
          priv: {}
        };
      };
      e.cloneAsInstance = function (e, t = true) {
        var n;
        var a;
        if (i.isInstance(e)) {
          return e;
        }
        if (t && ((n = e.cached) === null || n === undefined ? undefined : n.typeBaseInstanceType)) {
          return e.cached.typeBaseInstanceType;
        }
        const r = i.cloneTypeAsInstance(e, t);
        if ((a = r.props) === null || a === undefined ? undefined : a.specialForm) {
          i.setSpecialForm(r, undefined);
        }
        if (t) {
          r.priv.includeSubclasses = true;
        }
        return r;
      };
      e.cloneAsInstantiable = function (e, t = true) {
        var n;
        if (t && ((n = e.cached) === null || n === undefined ? undefined : n.typeBaseInstantiableType)) {
          return e.cached.typeBaseInstantiableType;
        }
        const a = i.cloneTypeAsInstantiable(e, t);
        if (t) {
          a.priv.includeSubclasses = true;
        }
        return a;
      };
      e.specialize = function (e, t, n, a = false, r, s) {
        const o = i.cloneType(e);
        o.priv.typeArgs = (t == null ? undefined : t.length) === 0 ? undefined : t;
        if (n === undefined) {
          n = !!t;
        }
        o.priv.isTypeArgExplicit = n;
        if (a) {
          o.priv.includeSubclasses = true;
        }
        o.priv.tupleTypeArgs = r ? [...r] : undefined;
        if (s !== undefined) {
          o.priv.isEmptyContainer = s;
        }
        return o;
      };
      e.cloneIncludeSubclasses = function (e, t = true) {
        if (!!e.priv.includeSubclasses === t) {
          return e;
        }
        const n = i.cloneType(e);
        n.priv.includeSubclasses = t;
        return n;
      };
      e.cloneWithLiteral = function (e, t) {
        var n;
        const a = i.cloneType(e);
        a.priv.literalValue = t;
        if ((n = a.props) === null || n === undefined ? undefined : n.typeAliasInfo) {
          i.setTypeAliasInfo(a, undefined);
        }
        return a;
      };
      e.cloneForDeprecatedInstance = function (e, t) {
        const n = i.cloneType(e);
        n.priv.deprecatedInstanceMessage = t;
        return n;
      };
      e.cloneForTypingAlias = function (e, t) {
        const n = i.cloneType(e);
        n.priv.aliasName = t;
        return n;
      };
      e.cloneForNarrowedTypedDictEntries = function (e, t) {
        const n = i.cloneType(e);
        n.priv.typedDictNarrowedEntries = t;
        return n;
      };
      e.cloneForPartialTypedDict = function (e) {
        const t = i.cloneType(e);
        t.priv.isTypedDictPartial = true;
        return t;
      };
      e.cloneRemoveTypePromotions = function (e) {
        if (!e.priv.includePromotions) {
          return e;
        }
        const t = i.cloneType(e);
        if (t.priv.includePromotions !== undefined) {
          t.priv.includePromotions = undefined;
        }
        return t;
      };
      e.cloneForPartial = function (e, t) {
        const n = i.cloneType(e);
        n.priv.partialCallType = t;
        return n;
      };
      e.cloneForUnpacked = function (e) {
        if (e.priv.isUnpacked) {
          return e;
        }
        const t = i.cloneType(e);
        t.priv.isUnpacked = true;
        return t;
      };
      e.cloneForPacked = function (e) {
        if (!e.priv.isUnpacked) {
          return e;
        }
        const t = i.cloneType(e);
        t.priv.isUnpacked = false;
        return t;
      };
      e.cloneWithNewFlags = function (e, t) {
        const n = i.cloneType(e);
        n.shared = {
          ...n.shared
        };
        n.shared.flags = t;
        return n;
      };
      e.isLiteralValueSame = function (e, t) {
        if (e.priv.literalValue === undefined) {
          return t.priv.literalValue === undefined;
        } else {
          return t.priv.literalValue !== undefined && (e.priv.literalValue instanceof s ? t.priv.literalValue instanceof s && e.priv.literalValue.itemName === t.priv.literalValue.itemName : e.priv.literalValue === t.priv.literalValue);
        }
      };
      e.isTypedDictNarrowedEntriesSame = function (e, t) {
        if (e.priv.typedDictNarrowedEntries) {
          if (!t.priv.typedDictNarrowedEntries) {
            return false;
          }
          const n = e.priv.typedDictNarrowedEntries;
          const a = t.priv.typedDictNarrowedEntries;
          if (n.size !== a.size) {
            return false;
          }
          let r;
          let s;
          for ([r, s] of n.entries()) {
            const e = a.get(r);
            if (!e) {
              return false;
            }
            if (s.isProvided !== e.isProvided) {
              return false;
            }
          }
        } else {
          if (t.priv.typedDictNarrowedEntries) {
            return false;
          }
        }
        return true;
      };
      e.isTypedDictNarrower = function (e, t) {
        var n;
        const a = t.priv.typedDictNarrowedEntries;
        if (!a) {
          return true;
        }
        const r = (n = e.priv.typedDictNarrowedEntries) !== null && n !== undefined ? n : new Map();
        let s;
        let i;
        for ([s, i] of a.entries()) {
          if (i.isProvided) {
            const e = r.get(s);
            if (!(e == null ? undefined : e.isProvided)) {
              return false;
            }
          }
        }
        return true;
      };
      e.isUnspecialized = function (e) {
        return e.shared.typeParams.length > 0 && e.priv.typeArgs === undefined;
      };
      e.isSpecialBuiltIn = function (e, t) {
        return (!!(e.shared.flags & 2) || !!e.priv.aliasName) && (t === undefined || e.shared.name === t);
      };
      e.isBuiltIn = n;
      e.supportsAbstractMethods = function (e) {
        return !!(e.shared.flags & 64);
      };
      e.isDataClass = function (e) {
        return !!e.shared.dataClassBehaviors;
      };
      e.isDataClassSkipGenerateInit = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.skipGenerateInit);
      };
      e.isDataClassSkipGenerateEq = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.skipGenerateEq);
      };
      e.isDataClassFrozen = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.frozen);
      };
      e.isDataClassGenerateOrder = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.generateOrder);
      };
      e.isDataClassKeywordOnly = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.keywordOnly);
      };
      e.isDataClassGenerateSlots = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.generateSlots);
      };
      e.isDataClassGenerateHash = function (e) {
        var t;
        return !!((t = e.shared.dataClassBehaviors) === null || t === undefined ? undefined : t.generateHash);
      };
      e.isTypeCheckOnly = function (e) {
        return !!(e.shared.flags & 1048576);
      };
      e.isNewTypeClass = function (e) {
        return !!(e.shared.flags & 2097152);
      };
      e.isValidTypeAliasClass = function (e) {
        return !!(e.shared.flags & 4194304);
      };
      e.isSpecialFormClass = function (e) {
        return !!(e.shared.flags & 8388608);
      };
      e.isIllegalIsinstanceClass = function (e) {
        return !!(e.shared.flags & 16777216);
      };
      e.isTypedDictClass = function (e) {
        return !!(e.shared.flags & 4);
      };
      e.isCanOmitDictValues = function (e) {
        return !!(e.shared.flags & 32);
      };
      e.isTypedDictMarkedClosed = function (e) {
        return !!(e.shared.flags & 8);
      };
      e.isTypedDictEffectivelyClosed = function (e) {
        return !!(e.shared.flags & 16);
      };
      e.isEnumClass = function (e) {
        return !!(e.shared.flags & 65536);
      };
      e.isPropertyClass = function (e) {
        return !!(e.shared.flags & 128);
      };
      e.isClassProperty = function (e) {
        return !!(e.shared.flags & 131072);
      };
      e.isFinal = function (e) {
        return !!(e.shared.flags & 256);
      };
      e.isProtocolClass = function (e) {
        return !!(e.shared.flags & 512);
      };
      e.isDefinedInStub = function (e) {
        return !!(e.shared.flags & 262144);
      };
      e.isPseudoGenericClass = function (e) {
        return !!(e.shared.flags & 1024);
      };
      e.getDataClassEntries = function (e) {
        var t;
        var n;
        if ((n = (t = e.shared).synthesizeMethodsDeferred) !== null && n !== undefined) {
          n.call(t);
        }
        return e.shared.dataClassEntries || [];
      };
      e.isRuntimeCheckable = function (e) {
        return !!(e.shared.flags & 2048);
      };
      e.isTypingExtensionClass = function (e) {
        return !!(e.shared.flags & 4096);
      };
      e.isPartiallyEvaluated = function (e) {
        return !!(e.shared.flags & 8192);
      };
      e.hasCustomClassGetItem = function (e) {
        return !!(e.shared.flags & 16384);
      };
      e.isTupleClass = function (e) {
        return !!(e.shared.flags & 32768);
      };
      e.getTypeParams = function (e) {
        return e.shared.typeParams;
      };
      e.derivesFromAnyOrUnknown = function (e) {
        return e.shared.mro.some(e => S(e));
      };
      e.getSymbolTable = function (e) {
        var t;
        var n;
        if ((n = (t = e.shared).synthesizeMethodsDeferred) !== null && n !== undefined) {
          n.call(t);
        }
        return e.shared.fields;
      };
      e.getInheritedSlotsNames = function (e) {
        var t;
        var n;
        var a;
        var r;
        if ((n = (t = e.shared).synthesizeMethodsDeferred) !== null && n !== undefined) {
          n.call(t);
        }
        if ((r = (a = e.shared).calculateInheritedSlotsNamesDeferred) !== null && r !== undefined) {
          r.call(a);
        }
        return e.shared.inheritedSlotsNamesCached;
      };
      e.isHierarchyPartiallyEvaluated = function (t) {
        return e.isPartiallyEvaluated(t) || t.shared.mro.some(t => P(t) && e.isPartiallyEvaluated(t));
      };
      e.hasNamedTupleEntry = function (e, t) {
        return !!e.shared.namedTupleEntries && e.shared.namedTupleEntries.has(t);
      };
      e.isSameGenericClass = a;
      e.isDerivedFrom = function t(r, s, i) {
        if (a(r, s)) {
          return (s.priv.literalValue === undefined || r.priv.literalValue !== undefined && !!e.isLiteralValueSame(s, r)) && (i && i.push(r), true);
        }
        if (n(r) && n(s, 'object')) {
          if (i) {
            i.push(s);
          }
          return true;
        }
        if (e.isBuiltIn(r, 'property') && e.isBuiltIn(s, 'property')) {
          if (i) {
            i.push(r);
          }
          return true;
        }
        for (const e of r.shared.baseClasses) {
          if (D(e)) {
            if (t(e, s, i)) {
              if (i) {
                i.push(r);
              }
              return true;
            }
          } else {
            if (S(e)) {
              if (i) {
                i.push(l.create());
              }
              return true;
            }
          }
        }
        return false;
      };
      e.getReverseMro = function (e) {
        return e.shared.mro.slice(0).reverse();
      };
    })(d || (exports.ClassType = d = {}));
    (function (e) {
      e[e.None = 0] = 'None';
      e[e.NameSynthesized = 1] = 'NameSynthesized';
      e[e.TypeDeclared = 2] = 'TypeDeclared';
      e[e.TypeInferred = 4] = 'TypeInferred';
    })(c || (exports.FunctionParamFlags = c = {}));
    (function (e) {
      e.create = function (e, t, n = c.None, a, r, s) {
        return {
          category: e,
          flags: n,
          name: a,
          _type: t,
          _defaultType: r,
          defaultExpr: s
        };
      };
      e.isNameSynthesized = function (e) {
        return !!(e.flags & c.NameSynthesized);
      };
      e.isTypeDeclared = function (e) {
        return !!(e.flags & c.TypeDeclared);
      };
      e.isTypeInferred = function (e) {
        return !!(e.flags & c.TypeInferred);
      };
    })(u || (exports.FunctionParam = u = {}));
    (function (e) {
      function t(e, t, n, a, r, s) {
        return {
          category: 4,
          flags: r,
          props: undefined,
          cached: undefined,
          shared: {
            name: e,
            fullName: t,
            moduleName: n,
            flags: a,
            typeParams: [],
            parameters: [],
            declaredReturnType: undefined,
            declaration: undefined,
            typeVarScopeId: undefined,
            docString: s,
            deprecatedMessage: undefined,
            methodClass: undefined,
            decoratorDataClassBehaviors: undefined
          },
          priv: {}
        };
      }
      function n(e = false) {
        return [u.create(1, e ? l.create() : h.create(), e ? c.None : c.TypeDeclared, 'args'), u.create(2, e ? l.create() : h.create(), e ? c.None : c.TypeDeclared, 'kwargs')];
      }
      function a(e, t) {
        r.assert(t < e.shared.parameters.length, 'Parameter types array overflow');
        if (e.priv.specializedTypes && t < e.priv.specializedTypes.parameterTypes.length) {
          return e.priv.specializedTypes.parameterTypes[t];
        } else {
          return e.shared.parameters[t]._type;
        }
      }
      function s(e, t) {
        e.shared.parameters.push(t);
        if (e.priv.specializedTypes) {
          e.priv.specializedTypes.parameterTypes.push(t._type);
        }
      }
      e.createInstance = function (e, n, a, r, s) {
        return t(e, n, a, r, 2, s);
      };
      e.createInstantiable = function (e, n) {
        return t('', '', '', e, 1, n);
      };
      e.createSynthesizedInstance = function (e, n = 0) {
        return t(e, '', '', n | 64, 2);
      };
      e.clone = function (e, t = false, n) {
        var r;
        var s;
        const o = i.cloneType(e);
        o.shared = {
          ...e.shared
        };
        o.priv.preBoundFlags = o.shared.flags;
        o.priv.boundToType = n;
        if (n) {
          if (e.shared.name === '__new__' || e.shared.name === '__init__') {
            o.priv.constructorTypeVarScopeId = n.shared.typeVarScopeId;
          }
        }
        if (t) {
          if (e.shared.parameters.length > 0) {
            if (e.shared.parameters[0].category === 0) {
              if (e.shared.parameters.length > 0 && !u.isTypeInferred(e.shared.parameters[0])) {
                o.priv.strippedFirstParamType = a(e, 0);
              }
              o.shared.parameters = e.shared.parameters.slice(1);
            }
          } else {
            t = false;
          }
          o.shared.flags &= -4;
          o.shared.flags |= 4;
        }
        if ((r = e.props) === null || r === undefined ? undefined : r.typeAliasInfo) {
          i.setTypeAliasInfo(o, e.props.typeAliasInfo);
        }
        if (e.priv.specializedTypes) {
          o.priv.specializedTypes = {
            parameterTypes: t ? e.priv.specializedTypes.parameterTypes.slice(1) : e.priv.specializedTypes.parameterTypes,
            parameterDefaultTypes: t ? (s = e.priv.specializedTypes.parameterDefaultTypes) === null || s === undefined ? undefined : s.slice(1) : e.priv.specializedTypes.parameterDefaultTypes,
            returnType: e.priv.specializedTypes.returnType
          };
        }
        o.priv.inferredReturnType = e.priv.inferredReturnType;
        return o;
      };
      e.cloneAsInstance = function (e) {
        var t;
        var n;
        if ((t = e.cached) === null || t === undefined ? undefined : t.typeBaseInstanceType) {
          return e.cached.typeBaseInstanceType;
        }
        const a = i.cloneTypeAsInstance(e, true);
        if ((n = a.props) === null || n === undefined ? undefined : n.specialForm) {
          i.setSpecialForm(a, undefined);
        }
        return a;
      };
      e.cloneAsInstantiable = function (e) {
        var t;
        if ((t = e.cached) === null || t === undefined ? undefined : t.typeBaseInstantiableType) {
          return e.cached.typeBaseInstantiableType;
        } else {
          return i.cloneTypeAsInstantiable(e, true);
        }
      };
      e.specialize = function (e, t, n) {
        const a = i.cloneType(e);
        r.assert(t.parameterTypes.length === e.shared.parameters.length);
        if (t.parameterDefaultTypes) {
          r.assert(t.parameterDefaultTypes.length === e.shared.parameters.length);
        }
        a.priv.specializedTypes = t;
        a.priv.inferredReturnType = n;
        return a;
      };
      e.applyParamSpecValue = function (t, n) {
        const a = n.shared.parameters.some(e => C(e));
        const s = e.cloneRemoveParamSpecArgsKwargs(i.cloneType(t), a);
        const o = e.getParamSpecFromArgsKwargs(t);
        r.assert(o !== undefined);
        s.shared = {
          ...s.shared
        };
        s.shared.typeParams = s.shared.typeParams.filter(e => !R(e, o));
        const l = Array.from(s.shared.parameters);
        s.shared.parameters = [...l, ...n.shared.parameters.map((t, a) => u.create(t.category, e.getParamType(n, a), t.flags & c.NameSynthesized | c.TypeDeclared, t.name, e.getParamDefaultType(n, a), t.defaultExpr))];
        if (s.shared.docString === undefined) {
          s.shared.docString = n.shared.docString;
        }
        if (s.shared.deprecatedMessage === undefined) {
          s.shared.deprecatedMessage = n.shared.deprecatedMessage;
        }
        s.shared.flags = t.shared.flags & 65792;
        if (t.shared.methodClass) {
          s.shared.flags |= t.shared.flags & 7;
        } else {
          s.shared.flags |= n.shared.flags & 7;
        }
        s.shared.flags |= n.shared.flags & 32768;
        s.shared.flags |= 64;
        if (s.shared.declaration) {
          s.shared.declaration = undefined;
        }
        const p = s.priv.specializedTypes;
        if (p) {
          n.shared.parameters.forEach((t, a) => {
            var r;
            p.parameterTypes.push(e.getParamType(n, a));
            if (p.parameterDefaultTypes) {
              if ((r = p.parameterDefaultTypes) !== null && r !== undefined) {
                r.push(e.getParamDefaultType(n, a));
              }
            }
          });
        }
        s.priv.constructorTypeVarScopeId = n.priv.constructorTypeVarScopeId;
        if (!s.shared.methodClass && n.shared.methodClass) {
          s.shared.methodClass = n.shared.methodClass;
        }
        return s;
      };
      e.cloneWithNewFlags = function (e, t) {
        const n = i.cloneType(e);
        n.shared = {
          ...e.shared
        };
        n.shared.flags = t;
        return n;
      };
      e.cloneWithNewTypeVarScopeId = function (e, t, n, a) {
        const r = i.cloneType(e);
        r.shared = {
          ...e.shared
        };
        r.shared.typeVarScopeId = t;
        r.priv.constructorTypeVarScopeId = n;
        r.shared.typeParams = a;
        return r;
      };
      e.cloneWithDocString = function (e, t) {
        const n = i.cloneType(e);
        n.shared = {
          ...e.shared
        };
        n.shared.docString = t;
        return n;
      };
      e.cloneWithDeprecatedMessage = function (e, t) {
        const n = i.cloneType(e);
        n.shared = {
          ...e.shared
        };
        n.shared.deprecatedMessage = t;
        return n;
      };
      e.cloneRemoveParamSpecArgsKwargs = function (t, n = false) {
        const a = t.shared.parameters.length;
        if (a < 2) {
          return t;
        }
        const r = t.shared.parameters[a - 2];
        const s = t.shared.parameters[a - 1];
        if (r.category !== 1 || s.category !== 2) {
          return t;
        }
        const o = e.getParamType(t, a - 2);
        const l = e.getParamType(t, a - 1);
        if (!E(o) || !E(l) || !R(o, l)) {
          return t;
        }
        const p = i.cloneType(t);
        p.shared = {
          ...t.shared
        };
        const d = p.shared;
        let c = 2;
        if (a >= 3 && C(d.parameters[a - 3]) && (a === 3 || n)) {
          c = 3;
        }
        d.parameters = d.parameters.slice(0, d.parameters.length - c);
        if (t.priv.specializedTypes) {
          p.priv.specializedTypes = {
            ...t.priv.specializedTypes
          };
          p.priv.specializedTypes.parameterTypes = p.priv.specializedTypes.parameterTypes.slice(0, p.priv.specializedTypes.parameterTypes.length - c);
          if (p.priv.specializedTypes.parameterDefaultTypes) {
            p.priv.specializedTypes.parameterDefaultTypes = p.priv.specializedTypes.parameterDefaultTypes.slice(0, p.priv.specializedTypes.parameterDefaultTypes.length - c);
          }
        }
        if (t.priv.inferredReturnType) {
          p.priv.inferredReturnType = t.priv.inferredReturnType;
        }
        return p;
      };
      e.getParamSpecFromArgsKwargs = function (t) {
        const n = t.shared.parameters;
        if (n.length < 2) {
          return;
        }
        const a = n[n.length - 2];
        const r = e.getParamType(t, n.length - 2);
        const s = n[n.length - 1];
        const i = e.getParamType(t, n.length - 1);
        if (a.category === 1 && E(r) && r.priv.paramSpecAccess === 'args' && s.category === 2 && E(i) && i.priv.paramSpecAccess === 'kwargs') {
          return _.cloneForParamSpecAccess(r, undefined);
        } else {
          return undefined;
        }
      };
      e.addParamSpecVariadics = function (t, n) {
        e.addParam(t, u.create(1, _.cloneForParamSpecAccess(n, 'args'), c.TypeDeclared, 'args'));
        e.addParam(t, u.create(2, _.cloneForParamSpecAccess(n, 'kwargs'), c.TypeDeclared, 'kwargs'));
      };
      e.addDefaultParams = function (t, a = false) {
        n(a).forEach(n => {
          e.addParam(t, n);
        });
      };
      e.getDefaultParams = n;
      e.hasDefaultParams = function (t) {
        let n = false;
        let a = false;
        for (let r = 0; r < t.shared.parameters.length; r++) {
          const s = t.shared.parameters[r];
          if (s.name) {
            if (s.category === 0) {
              return false;
            }
            if (s.category === 1) {
              n = true;
            } else {
              if (s.category === 2) {
                a = true;
              }
            }
            if (!S(e.getParamType(t, r))) {
              return false;
            }
          }
        }
        return n && a;
      };
      e.isInstanceMethod = function (e) {
        return !(e.shared.flags & 7);
      };
      e.isConstructorMethod = function (e) {
        return !!(e.shared.flags & 1);
      };
      e.isStaticMethod = function (e) {
        return !!(e.shared.flags & 4);
      };
      e.isClassMethod = function (e) {
        return !!(e.shared.flags & 2);
      };
      e.isAbstractMethod = function (e) {
        return !!(e.shared.flags & 8);
      };
      e.isGenerator = function (e) {
        return !!(e.shared.flags & 16);
      };
      e.isSynthesizedMethod = function (e) {
        return !!(e.shared.flags & 64);
      };
      e.isTypeCheckOnly = function (e) {
        return !!(e.shared.flags & 128);
      };
      e.isOverloaded = function (e) {
        return !!(e.shared.flags & 256);
      };
      e.isDefaultParamCheckDisabled = function (e) {
        return !!(e.shared.flags & 32);
      };
      e.isAsync = function (e) {
        return !!(e.shared.flags & 512);
      };
      e.isStubDefinition = function (e) {
        return !!(e.shared.flags & 2048);
      };
      e.isPyTypedDefinition = function (e) {
        return !!(e.shared.flags & 4096);
      };
      e.isFinal = function (e) {
        return !!(e.shared.flags & 8192);
      };
      e.hasUnannotatedParams = function (e) {
        return !!(e.shared.flags & 16384);
      };
      e.isGradualCallableForm = function (e) {
        return !!(e.shared.flags & 32768);
      };
      e.isParamSpecValue = function (e) {
        return !!(e.shared.flags & 65536);
      };
      e.isPartiallyEvaluated = function (e) {
        return !!(e.shared.flags & 131072);
      };
      e.isOverridden = function (e) {
        return !!(e.shared.flags & 262144);
      };
      e.isBuiltIn = function (e, t) {
        if (!(e.shared.flags & 1048576)) {
          return false;
        }
        if (t !== undefined) {
          return (Array.isArray(t) ? t : [t]).some(t => t === e.shared.name || t === e.shared.fullName);
        }
        return true;
      };
      e.getDeclaredParamType = function (e, t) {
        return e.shared.parameters[t]._type;
      };
      e.getParamType = a;
      e.getParamDefaultType = function (e, t) {
        var n;
        r.assert(t < e.shared.parameters.length, 'Parameter types array overflow');
        if (((n = e.priv.specializedTypes) === null || n === undefined ? undefined : n.parameterDefaultTypes) && t < e.priv.specializedTypes.parameterDefaultTypes.length) {
          const n = e.priv.specializedTypes.parameterDefaultTypes[t];
          if (n) {
            return n;
          }
        }
        return e.shared.parameters[t]._defaultType;
      };
      e.addParam = s;
      e.addPositionOnlyParamSeparator = function (e) {
        s(e, u.create(0, h.create()));
      };
      e.addKeywordOnlyParamSeparator = function (e) {
        s(e, u.create(1, h.create()));
      };
      e.getEffectiveReturnType = function (e, t = true) {
        var n;
        if ((n = e.priv.specializedTypes) === null || n === undefined ? undefined : n.returnType) {
          return e.priv.specializedTypes.returnType;
        } else {
          if (e.shared.declaredReturnType) {
            return e.shared.declaredReturnType;
          } else {
            if (t) {
              return e.priv.inferredReturnType;
            } else {
              return undefined;
            }
          }
        }
      };
    })(m || (exports.FunctionType = m = {}));
    (function (e) {
      e.create = function (t, n) {
        const a = {
          category: 5,
          flags: 2,
          props: undefined,
          cached: undefined,
          shared: undefined,
          priv: {
            _overloads: [],
            _implementation: n
          }
        };
        t.forEach(t => {
          e.addOverload(a, t);
        });
        if (n && V(n)) {
          n.priv.overloaded = a;
        }
        return a;
      };
      e.addOverload = function (e, t) {
        t.priv.overloaded = e;
        e.priv._overloads.push(t);
      };
      e.getOverloads = function (e) {
        return e.priv._overloads;
      };
      e.getImplementation = function (e) {
        return e.priv._implementation;
      };
    })(y || (exports.OverloadedType = y = {}));
    (function (e) {
      const t = {
        category: 3,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isNoReturn: false
        }
      };
      const n = {
        category: 3,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isNoReturn: true
        }
      };
      e.createNever = function () {
        return t;
      };
      e.createNoReturn = function () {
        return n;
      };
      e.convertToInstance = function (t) {
        var n;
        var a;
        if (((n = t.props) === null || n === undefined ? undefined : n.specialForm) || ((a = t.props) === null || a === undefined ? undefined : a.typeForm)) {
          if (t.priv.isNoReturn) {
            return e.createNoReturn();
          } else {
            return e.createNever();
          }
        } else {
          return t;
        }
      };
    })(g || (exports.NeverType = g = {}));
    (function (e) {
      const t = {
        category: 2,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isEllipsis: false
        }
      };
      const n = {
        category: 2,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isEllipsis: false
        }
      };
      const a = {
        category: 2,
        flags: 3,
        props: undefined,
        cached: undefined,
        shared: undefined,
        priv: {
          isEllipsis: true
        }
      };
      e.create = function (e = false) {
        if (e) {
          return a;
        } else {
          return n;
        }
      };
      e.createSpecialForm = function () {
        return t;
      };
    })(h || (exports.AnyType = h = {}));
    (function (e) {
      e.convertToInstance = function (t) {
        var n;
        if ((n = t.props) === null || n === undefined ? undefined : n.specialForm) {
          return e.create();
        } else {
          return t;
        }
      };
    })(h || (exports.AnyType = h = {}));
    (function (e) {
      function t(e, t) {
        if (e.typeVar.shared.name < t.typeVar.shared.name) {
          return -1;
        } else {
          if (e.typeVar.shared.name > t.typeVar.shared.name) {
            return 1;
          } else {
            if (e.constraintIndex < t.constraintIndex) {
              return -1;
            } else {
              if (e.constraintIndex > t.constraintIndex) {
                return 1;
              } else {
                return 0;
              }
            }
          }
        }
      }
      e.combine = function (e, n) {
        if (!e) {
          return n;
        }
        if (!n) {
          return e;
        }
        const a = Array.from(e);
        n.forEach(e => {
          if (!a.some(n => t(e, n) === 0)) {
            a.push(e);
          }
        });
        return a.sort(t);
      };
      e.isSame = function (e, t) {
        if (e) {
          return !!t && e.length === t.length && e.find((e, n) => e.typeVar.priv.nameWithScope !== t[n].typeVar.priv.nameWithScope || e.constraintIndex !== t[n].constraintIndex) === undefined;
        } else {
          return !t;
        }
      };
      e.isCompatible = function (e, t) {
        if (!e || !t) {
          return true;
        }
        for (const n of e) {
          let e = false;
          const a = t.find(t => n.typeVar.priv.nameWithScope === t.typeVar.priv.nameWithScope && (e = true, n.constraintIndex === t.constraintIndex));
          if (e && !a) {
            return false;
          }
        }
        return true;
      };
    })(f || (exports.TypeCondition = f = {}));
    (function (e) {
      e.create = function () {
        return {
          category: 8,
          flags: 3,
          props: undefined,
          cached: undefined,
          shared: undefined,
          priv: {
            subtypes: [],
            literalInstances: {
              literalStrMap: undefined,
              literalIntMap: undefined,
              literalEnumMap: undefined
            },
            literalClasses: {
              literalStrMap: undefined,
              literalIntMap: undefined,
              literalEnumMap: undefined
            },
            typeAliasSources: undefined,
            includesRecursiveTypeAlias: false
          }
        };
      };
      e.addType = function (e, t) {
        var n;
        var a;
        if (P(t) && t.priv.literalValue !== undefined && !((n = t.props) === null || n === undefined ? undefined : n.condition)) {
          const n = N(t) ? e.priv.literalInstances : e.priv.literalClasses;
          if (d.isBuiltIn(t, 'str')) {
            if (n.literalStrMap === undefined) {
              n.literalStrMap = new Map();
            }
            n.literalStrMap.set(t.priv.literalValue, t);
          } else {
            if (d.isBuiltIn(t, 'int')) {
              if (n.literalIntMap === undefined) {
                n.literalIntMap = new Map();
              }
              n.literalIntMap.set(t.priv.literalValue, t);
            } else {
              if (d.isEnumClass(t)) {
                if (n.literalEnumMap === undefined) {
                  n.literalEnumMap = new Map();
                }
                const e = t.priv.literalValue;
                n.literalEnumMap.set(e.getName(), t);
              }
            }
          }
        }
        e.flags &= t.flags;
        e.priv.subtypes.push(t);
        if (F(t) && ((a = t.shared.recursiveAlias) === null || a === undefined ? undefined : a.name)) {
          e.priv.includesRecursiveTypeAlias = true;
        }
      };
      e.containsType = function (e, t, n = {}, a, r = 0) {
        var s;
        if (P(t) && ((s = t.props) === null || s === undefined ? undefined : s.condition) === undefined && t.priv.literalValue !== undefined) {
          const n = N(t) ? e.priv.literalInstances : e.priv.literalClasses;
          if (d.isBuiltIn(t, 'str') && n.literalStrMap !== undefined) {
            return n.literalStrMap.has(t.priv.literalValue);
          }
          if (d.isBuiltIn(t, 'int') && n.literalIntMap !== undefined) {
            return n.literalIntMap.has(t.priv.literalValue);
          }
          if (d.isEnumClass(t) && n.literalEnumMap !== undefined) {
            const e = t.priv.literalValue;
            return n.literalEnumMap.has(e.getName());
          }
        }
        const i = e.priv.subtypes.findIndex((e, s) => !(a == null ? undefined : a.has(s)) && R(e, t, n, r));
        return !(i < 0) && (a == null || a.add(i), true);
      };
      e.addTypeAliasSource = function (e, t) {
        var n;
        if (t.category === 8) {
          const a = ((n = t.props) === null || n === undefined ? undefined : n.typeAliasInfo) ? [t] : t.priv.typeAliasSources;
          if (a) {
            if (!e.priv.typeAliasSources) {
              e.priv.typeAliasSources = new Set();
            }
            a.forEach(t => {
              e.priv.typeAliasSources.add(t);
            });
          }
        }
      };
    })(T || (exports.UnionType = T = {}));
    (function (e) {
      e[e.TypeVar = 0] = 'TypeVar';
      e[e.TypeVarTuple = 1] = 'TypeVarTuple';
      e[e.ParamSpec = 2] = 'ParamSpec';
    })(v || (exports.TypeVarKind = v = {}));
    (function (e) {
      e.getUnknown = function () {
        const e = m.createInstance('', '', '', 98304);
        m.addDefaultParams(e);
        return e;
      };
    })(b || (exports.ParamSpecType = b = {}));
    (function (e) {
      function n(e, t, n) {
        return `${e}.${t}.${n}`;
      }
      function a(e, t, n) {
        return {
          category: 9,
          flags: n,
          props: undefined,
          cached: undefined,
          shared: {
            kind: t,
            name: e,
            constraints: [],
            boundType: undefined,
            isDefaultExplicit: false,
            defaultType: l.create(),
            declaredVariance: 2,
            isSynthesized: false,
            isSynthesizedSelf: false,
            synthesizedIndex: undefined,
            isExemptFromBoundCheck: false,
            isTypeParamSyntax: false,
            recursiveAlias: undefined
          },
          priv: {}
        };
      }
      e.createInstance = function (e, t = v.TypeVar) {
        return a(e, t, 2);
      };
      e.createInstantiable = function (e, t = v.TypeVar) {
        return a(e, t, 1);
      };
      e.cloneAsInstance = function (t) {
        var n;
        var a;
        r.assert(i.isInstantiable(t));
        if ((n = t.cached) === null || n === undefined ? undefined : n.typeBaseInstanceType) {
          return t.cached.typeBaseInstanceType;
        }
        const s = i.cloneTypeAsInstance(t, true);
        if ((a = s.props) === null || a === undefined ? undefined : a.specialForm) {
          i.setSpecialForm(s, undefined);
        }
        if (s.priv.freeTypeVar) {
          s.priv.freeTypeVar = e.cloneAsInstance(s.priv.freeTypeVar);
        }
        return s;
      };
      e.cloneAsInstantiable = function (t) {
        var n;
        if ((n = t.cached) === null || n === undefined ? undefined : n.typeBaseInstantiableType) {
          return t.cached.typeBaseInstantiableType;
        }
        const a = i.cloneTypeAsInstantiable(t, true);
        if (a.priv.freeTypeVar) {
          a.priv.freeTypeVar = e.cloneAsInstantiable(a.priv.freeTypeVar);
        }
        return a;
      };
      e.cloneForNewName = function (e, t) {
        var a;
        const r = i.cloneType(e);
        r.shared = {
          ...e.shared
        };
        r.shared.name = t;
        if (r.priv.scopeId) {
          r.priv.nameWithScope = n(t, r.priv.scopeId, (a = r.priv.scopeName) !== null && a !== undefined ? a : '');
        }
        return r;
      };
      e.cloneForScopeId = function (e, t, a, r) {
        const s = i.cloneType(e);
        s.priv.nameWithScope = n(e.shared.name, t, a ?? '');
        s.priv.scopeId = t;
        s.priv.scopeName = a;
        s.priv.scopeType = r;
        return s;
      };
      e.cloneForUnpacked = function (t, n = false) {
        const a = i.cloneType(t);
        a.priv.isUnpacked = true;
        if (M(a) && n) {
          a.priv.isInUnion = n;
        }
        if (a.priv.freeTypeVar) {
          a.priv.freeTypeVar = e.cloneForUnpacked(a.priv.freeTypeVar, n);
        }
        return a;
      };
      e.cloneForPacked = function (t) {
        const n = i.cloneType(t);
        n.priv.isUnpacked = false;
        if (M(n)) {
          n.priv.isInUnion = false;
        }
        if (n.priv.freeTypeVar) {
          n.priv.freeTypeVar = e.cloneForPacked(n.priv.freeTypeVar);
        }
        return n;
      };
      e.cloneAsInvariant = function (t) {
        if (E(t) || M(t)) {
          return t;
        }
        if (t.shared.declaredVariance === 0) {
          return t;
        }
        if (t.shared.declaredVariance === 2 && !e.hasBound(t) && !e.hasConstraints(t)) {
          return t;
        }
        const n = i.cloneType(t);
        n.shared = {
          ...n.shared
        };
        n.shared.declaredVariance = 2;
        n.shared.boundType = undefined;
        n.shared.constraints = [];
        return n;
      };
      e.cloneForParamSpecAccess = function (e, t) {
        const n = i.cloneType(e);
        n.priv.paramSpecAccess = t;
        return n;
      };
      e.cloneAsSpecializedSelf = function (t, n) {
        r.assert(e.isSelf(t));
        const a = i.cloneType(t);
        a.shared = {
          ...a.shared
        };
        a.shared.boundType = n;
        return a;
      };
      e.cloneAsUnificationVar = function (n, a) {
        if (e.isUnification(n)) {
          return n;
        }
        let r = n.priv.nameWithScope;
        if (a) {
          r = `${n.priv.nameWithScope}-${a}`;
        }
        const s = i.cloneType(n);
        s.priv.isUnificationVar = true;
        s.priv.scopeId = exports.UnificationScopeId;
        s.priv.nameWithScope = r;
        return s;
      };
      e.cloneWithComputedVariance = function (e, t) {
        const n = i.cloneType(e);
        n.priv.computedVariance = t;
        return n;
      };
      e.makeNameWithScope = n;
      e.makeBoundScopeId = function (e) {
        if (e) {
          return `${e}*`;
        }
      };
      e.cloneAsBound = function (t) {
        if (t.priv.scopeId === undefined || t.priv.freeTypeVar) {
          return t;
        }
        const n = e.cloneForScopeId(t, e.makeBoundScopeId(t.priv.scopeId), t.priv.scopeName, t.priv.scopeType);
        n.priv.freeTypeVar = t;
        return n;
      };
      e.isBound = function (e) {
        return !!e.priv.freeTypeVar;
      };
      e.isUnification = function (e) {
        return e.priv.isUnificationVar;
      };
      e.addConstraint = function (e, t) {
        e.shared.constraints.push(t);
      };
      e.getNameWithScope = function (e) {
        return e.priv.nameWithScope || e.shared.name;
      };
      e.getReadableName = function (e, t = true) {
        if (e.priv.scopeName && t) {
          return `${e.shared.name}@${e.priv.scopeName}`;
        } else {
          return e.shared.name;
        }
      };
      e.getVariance = function (e) {
        var t;
        const n = (t = e.priv.computedVariance) !== null && t !== undefined ? t : e.shared.declaredVariance;
        r.assert(n !== 0, 'Expected variance to be inferred');
        if (n === 1) {
          return 3;
        } else {
          return n;
        }
      };
      e.isTypeAliasPlaceholder = function (e) {
        return !!e.shared.recursiveAlias && !e.shared.boundType;
      };
      e.isSelf = function (e) {
        return !!e.shared.isSynthesizedSelf;
      };
      e.hasConstraints = function (e) {
        return e.shared.constraints.length > 0;
      };
      e.hasBound = function (e) {
        return !!e.shared.boundType;
      };
    })(_ || (exports.TypeVarType = _ = {}));
  },
  1371: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.BackgroundAnalysisRunnerBase = exports.BackgroundAnalysisBase = undefined;
    const i = require(56911);
    const o = require(28167);
    const l = require(1811);
    const p = require(79253);
    const d = require(94953);
    const c = require(91426);
    const u = require(12522);
    const m = require(25075);
    const y = __importStar(require(48281));
    const g = require(11479);
    const h = require(34487);
    const f = require(51862);
    const T = require(27113);
    exports.BackgroundAnalysisBase = class {
      constructor(e) {
        this.console = e;
        this._onAnalysisCompletion = l.nullCallback;
        this._analysisCancellationToken = undefined;
        this._messageChannel = new o.MessageChannel();
        this._messageChannel.port1.on('message', e => this.handleBackgroundResponse(e));
      }
      dispose() {
        if (this._messageChannel) {
          this._messageChannel.port1.close();
          this._messageChannel.port2.close();
        }
        if (this._worker) {
          this._worker.terminate();
        }
      }
      setProgramView(e) {
        this.program = e;
      }
      setCompletionCallback(e) {
        this._onAnalysisCompletion = e ?? l.nullCallback;
      }
      setImportResolver(e) {
        this.enqueueRequest({
          requestType: 'setImportResolver',
          data: d.serialize(e.host.kind)
        });
      }
      setConfigOptions(e) {
        this.enqueueRequest({
          requestType: 'setConfigOptions',
          data: d.serialize(e)
        });
      }
      setTrackedFiles(e) {
        this.enqueueRequest({
          requestType: 'setTrackedFiles',
          data: d.serialize(e)
        });
      }
      setAllowedThirdPartyImports(e) {
        this.enqueueRequest({
          requestType: 'setAllowedThirdPartyImports',
          data: d.serialize(e)
        });
      }
      ensurePartialStubPackages(e) {
        this.enqueueRequest({
          requestType: 'ensurePartialStubPackages',
          data: d.serialize({
            executionRoot: e
          })
        });
      }
      setFileOpened(e, t, n, a) {
        this.enqueueRequest({
          requestType: 'setFileOpened',
          data: d.serialize({
            fileUri: e,
            version: t,
            contents: n,
            options: a
          })
        });
      }
      updateChainedUri(e, t) {
        this.enqueueRequest({
          requestType: 'updateChainedFileUri',
          data: d.serialize({
            fileUri: e,
            chainedUri: t
          })
        });
      }
      setFileClosed(e, t) {
        this.enqueueRequest({
          requestType: 'setFileClosed',
          data: d.serialize({
            fileUri: e,
            isTracked: t
          })
        });
      }
      addInterimFile(e) {
        this.enqueueRequest({
          requestType: 'addInterimFile',
          data: d.serialize({
            fileUri: e
          })
        });
      }
      markAllFilesDirty(e) {
        this.enqueueRequest({
          requestType: 'markAllFilesDirty',
          data: d.serialize({
            evenIfContentsAreSame: e
          })
        });
      }
      markFilesDirty(e, t) {
        this.enqueueRequest({
          requestType: 'markFilesDirty',
          data: d.serialize({
            fileUris: e,
            evenIfContentsAreSame: t
          })
        });
      }
      startAnalysis(e) {
        this._analysisCancellationToken = e;
        this.enqueueRequest({
          requestType: 'analyze',
          data: d.serialize(e)
        });
      }
      async analyzeFile(e, t) {
        c.throwIfCancellationRequested(t);
        const {
          port1: n,
          port2: a
        } = new o.MessageChannel();
        const r = d.getBackgroundWaiter(n);
        const s = c.getCancellationTokenId(t);
        this.enqueueRequest({
          requestType: 'analyzeFile',
          data: d.serialize({
            fileUri: e,
            cancellationId: s
          }),
          port: a
        });
        const i = await r;
        a.close();
        n.close();
        return i;
      }
      async getDiagnosticsForRange(e, t, n) {
        c.throwIfCancellationRequested(n);
        const {
          port1: a,
          port2: r
        } = new o.MessageChannel();
        const s = d.getBackgroundWaiter(a);
        const i = c.getCancellationTokenId(n);
        this.enqueueRequest({
          requestType: 'getDiagnosticsForRange',
          data: d.serialize({
            fileUri: e,
            range: t,
            cancellationId: i
          }),
          port: r
        });
        const l = await s;
        r.close();
        a.close();
        return _(l);
      }
      async writeTypeStub(e, t, n, a) {
        c.throwIfCancellationRequested(a);
        const {
          port1: r,
          port2: s
        } = new o.MessageChannel();
        const i = d.getBackgroundWaiter(r);
        const l = c.getCancellationTokenId(a);
        this.enqueueRequest({
          requestType: 'writeTypeStub',
          data: d.serialize({
            targetImportPath: e,
            targetIsSingleFile: t,
            stubPath: n,
            cancellationId: l
          }),
          port: s
        });
        await i;
        s.close();
        r.close();
      }
      invalidateAndForceReanalysis(e) {
        this.enqueueRequest({
          requestType: 'invalidateAndForceReanalysis',
          data: d.serialize({
            reason: e
          })
        });
      }
      restart() {
        this.enqueueRequest({
          requestType: 'restart',
          data: null
        });
      }
      shutdown() {
        if (this._worker) {
          this.enqueueRequest({
            requestType: 'shutdown',
            data: null
          });
        }
      }
      setup(e) {
        this._worker = e;
        e.on('message', e => this.onMessage(e));
        e.on('error', e => {
          this.log(m.LogLevel.Error, `Error occurred on background thread: ${JSON.stringify(e)}`);
        });
        this.enqueueRequest({
          requestType: 'start',
          data: '',
          port: this._messageChannel.port2
        });
      }
      onMessage(e) {
        switch (e.requestType) {
          case 'log':
            {
              const t = d.deserialize(e.data);
              this.log(t.level, t.message);
              break;
            }
          case 'analysisResult':
            this._onAnalysisCompletion(b(d.deserialize(e.data)));
            break;
          default:
            y.fail(`${e.requestType} is not expected. Message structure: ${JSON.stringify(e)}`);
        }
      }
      enqueueRequest(e) {
        if (this._worker) {
          this._worker.postMessage(e, e.port ? [e.port] : undefined);
        }
      }
      log(e, t) {
        m.log(this.console, e, t);
      }
      handleBackgroundResponse(e) {
        switch (e.requestType) {
          case 'analysisResult':
            this._onAnalysisCompletion(b(d.deserialize(e.data)));
            break;
          case 'analysisPaused':
            this.enqueueRequest({
              requestType: 'resumeAnalysis',
              data: d.serialize(this._analysisCancellationToken || i.CancellationToken.None)
            });
            break;
          case 'analysisDone':
            if (this._analysisCancellationToken) {
              h.disposeCancellationToken(this._analysisCancellationToken);
            }
            this._analysisCancellationToken = undefined;
            break;
          default:
            y.fail(`${e.requestType} is not expected. Message structure: ${JSON.stringify(e)}`);
        }
      }
    };
    class v extends d.BackgroundThreadBase {
      constructor(e) {
        super(o.workerData, e);
        this.serviceProvider = e;
        this.isCaseSensitive = true;
        const t = o.workerData;
        this.log(m.LogLevel.Info, `Background analysis(${o.threadId}) root directory: ${t.rootUri}`);
        this._configOptions = new u.ConfigOptions(T.Uri.parse(t.rootUri, e));
        this.importResolver = this.createImportResolver(e, this._configOptions, this.createHost());
        const n = this.getConsole();
        this.logTracker = new f.LogTracker(n, `BG(${o.threadId})`);
        this._program = new p.Program(this.importResolver, this._configOptions, e, this.logTracker, undefined, t.serviceId);
      }
      get program() {
        return this._program;
      }
      get responsePort() {
        y.assert(this._responsePort !== undefined, 'BG thread was not started properly. No response port');
        return this._responsePort;
      }
      start() {
        this.log(m.LogLevel.Info, `Background analysis(${o.threadId}) started`);
        if (o.parentPort !== null && o.parentPort !== undefined) {
          o.parentPort.on('message', this._onMessageWrapper.bind(this));
        }
        if (o.parentPort !== null && o.parentPort !== undefined) {
          o.parentPort.on('error', e => y.fail(`failed ${e}`));
        }
        if (o.parentPort !== null && o.parentPort !== undefined) {
          o.parentPort.on('exit', e => {
            if (e !== 0) {
              y.fail(`worker stopped with exit code ${e}`);
            }
          });
        }
      }
      onMessage(e) {
        var t;
        switch (e.requestType) {
          case 'start':
            this._responsePort = e.port;
            break;
          case 'cacheUsageBuffer':
            if ((t = this.serviceProvider.cacheManager()) !== null && t !== undefined) {
              t.handleCachedUsageBufferMessage(e);
            }
            break;
          case 'analyze':
            {
              const t = d.deserialize(e.data);
              this.handleAnalyze(this.responsePort, t);
              break;
            }
          case 'resumeAnalysis':
            {
              const t = d.deserialize(e.data);
              this.handleResumeAnalysis(this.responsePort, t);
              break;
            }
          case 'analyzeFile':
            d.run(() => {
              const {
                fileUri: t,
                cancellationId: n
              } = d.deserialize(e.data);
              const a = h.getCancellationTokenFromId(n);
              return this.handleAnalyzeFile(t, a);
            }, e.port);
            break;
          case 'getDiagnosticsForRange':
            d.run(() => {
              const {
                fileUri: t,
                range: n,
                cancellationId: a
              } = d.deserialize(e.data);
              const r = h.getCancellationTokenFromId(a);
              return this.handleGetDiagnosticsForRange(t, n, r);
            }, e.port);
            break;
          case 'writeTypeStub':
            d.run(() => {
              const {
                targetImportPath: t,
                targetIsSingleFile: n,
                stubPath: a,
                cancellationId: r
              } = d.deserialize(e.data);
              const s = h.getCancellationTokenFromId(r);
              this.handleWriteTypeStub(t, n, a, s);
            }, e.port);
            break;
          case 'setImportResolver':
            this.handleSetImportResolver(d.deserialize(e.data));
            break;
          case 'setConfigOptions':
            this.handleSetConfigOptions(d.deserialize(e.data));
            break;
          case 'setTrackedFiles':
            this.handleSetTrackedFiles(d.deserialize(e.data));
            break;
          case 'setAllowedThirdPartyImports':
            this.handleSetAllowedThirdPartyImports(d.deserialize(e.data));
            break;
          case 'ensurePartialStubPackages':
            {
              const {
                executionRoot: t
              } = d.deserialize(e.data);
              this.handleEnsurePartialStubPackages(t);
              break;
            }
          case 'setFileOpened':
            {
              const {
                fileUri: t,
                version: n,
                contents: a,
                options: r
              } = d.deserialize(e.data);
              this.handleSetFileOpened(t, n, a, r);
              break;
            }
          case 'updateChainedFileUri':
            {
              const {
                fileUri: t,
                chainedUri: n
              } = d.deserialize(e.data);
              this.handleUpdateChainedFileUri(t, n);
              break;
            }
          case 'setFileClosed':
            {
              const {
                fileUri: t,
                isTracked: n
              } = d.deserialize(e.data);
              this.handleSetFileClosed(t, n);
              break;
            }
          case 'addInterimFile':
            {
              const {
                fileUri: t
              } = d.deserialize(e.data);
              this.handleAddInterimFile(t);
              break;
            }
          case 'markAllFilesDirty':
            {
              const {
                evenIfContentsAreSame: t
              } = d.deserialize(e.data);
              this.handleMarkAllFilesDirty(t);
              break;
            }
          case 'markFilesDirty':
            {
              const {
                fileUris: t,
                evenIfContentsAreSame: n
              } = d.deserialize(e.data);
              this.handleMarkFilesDirty(t, n);
              break;
            }
          case 'invalidateAndForceReanalysis':
            {
              const {
                reason: t
              } = d.deserialize(e.data);
              this.handleInvalidateAndForceReanalysis(t);
              break;
            }
          case 'restart':
            this.handleRestart();
            break;
          case 'shutdown':
            this.handleShutdown();
            break;
          default:
            y.fail(`${e.requestType} is not expected. Message structure: ${JSON.stringify(e)}`);
        }
      }
      handleAnalyze(e, t) {
        const n = this.program.getFilesToAnalyzeCount();
        this.onAnalysisCompletion(e, {
          diagnostics: [],
          filesInProgram: this.program.getFileCount(),
          requiringAnalysisCount: n,
          checkingOnlyOpenFiles: this.program.isCheckingOnlyOpenFiles(),
          fatalErrorOccurred: false,
          configParseErrorOccurred: false,
          elapsedTime: 0,
          reason: 'analysis'
        });
        this.handleResumeAnalysis(e, t);
      }
      handleResumeAnalysis(e, t) {
        if (l.analyzeProgram(this.program, {
          openFilesTimeInMs: 50,
          noOpenFilesTimeInMs: 200
        }, this._configOptions, t => this.onAnalysisCompletion(e, t), this.getConsole(), t)) {
          this._analysisPaused(e, t);
        } else {
          this.analysisDone(e, t);
        }
      }
      handleAnalyzeFile(e, t) {
        c.throwIfCancellationRequested(t);
        return this.program.analyzeFile(e, t);
      }
      handleGetDiagnosticsForRange(e, t, n) {
        c.throwIfCancellationRequested(n);
        return this.program.getDiagnosticsForRange(e, t);
      }
      handleWriteTypeStub(e, t, n, a) {
        l.analyzeProgram(this.program, undefined, this._configOptions, l.nullCallback, this.getConsole(), a);
        this.program.writeTypeStub(e, t, n, a);
      }
      handleSetImportResolver(e) {
        this.importResolver = this.createImportResolver(this.getServiceProvider(), this._configOptions, this.createHost());
        this.program.setImportResolver(this.importResolver);
      }
      handleSetConfigOptions(e) {
        this._configOptions = e;
        this.importResolver = this.createImportResolver(this.getServiceProvider(), this._configOptions, this.importResolver.host);
        this.program.setConfigOptions(this._configOptions);
        this.program.setImportResolver(this.importResolver);
      }
      handleSetTrackedFiles(e) {
        const t = this.program.setTrackedFiles(e);
        this._reportDiagnostics(t, this.program.getFilesToAnalyzeCount(), 0);
      }
      handleSetAllowedThirdPartyImports(e) {
        this.program.setAllowedThirdPartyImports(e);
      }
      handleEnsurePartialStubPackages(e) {
        const t = this._configOptions.getExecutionEnvironments().find(t => {
          var n;
          return ((n = t.root) === null || n === undefined ? undefined : n.toString()) === e;
        });
        if (t) {
          this.importResolver.ensurePartialStubPackages(t);
        }
      }
      handleSetFileOpened(e, t, n, a) {
        this.program.setFileOpened(e, t, n, a ? {
          ...a,
          chainedFileUri: T.Uri.fromJsonObj(a == null ? undefined : a.chainedFileUri)
        } : undefined);
      }
      handleUpdateChainedFileUri(e, t) {
        this.program.updateChainedUri(e, t);
      }
      handleSetFileClosed(e, t) {
        const n = this.program.setFileClosed(e, t);
        this._reportDiagnostics(n, this.program.getFilesToAnalyzeCount(), 0);
      }
      handleAddInterimFile(e) {
        this.program.addInterimFile(e);
      }
      handleMarkFilesDirty(e, t) {
        this.program.markFilesDirty(e, t);
      }
      handleMarkAllFilesDirty(e) {
        this.program.markAllFilesDirty(e);
      }
      handleInvalidateAndForceReanalysis(e) {
        this.importResolver.invalidateCache();
        this.program.markAllFilesDirty(true);
      }
      handleRestart() {
        this.importResolver = this.createImportResolver(this.getServiceProvider(), this._configOptions, this.importResolver.host);
        this.program.setImportResolver(this.importResolver);
      }
      handleShutdown() {
        this._program.dispose();
        super.handleShutdown();
      }
      analysisDone(e, t) {
        e.postMessage({
          requestType: 'analysisDone',
          data: d.serialize(t)
        });
      }
      onAnalysisCompletion(e, t) {
        e.postMessage({
          requestType: 'analysisResult',
          data: d.serialize(t)
        });
      }
      _onMessageWrapper(e) {
        try {
          return this.onMessage(e);
        } catch (t) {
          this.log(m.LogLevel.Log, `Background analysis exception leak: ${t}`);
          if (c.OperationCanceledException.is(t)) {
            if (o.parentPort !== null && o.parentPort !== undefined) {
              o.parentPort.postMessage({
                kind: 'cancelled',
                data: t.message
              });
            }
            return;
          }
          if (o.parentPort !== null && o.parentPort !== undefined) {
            o.parentPort.postMessage({
              kind: 'failed',
              data: `Exception: for msg ${e.requestType}: ${t.message} in ${t.stack}`
            });
          }
        }
      }
      _reportDiagnostics(e, t, n) {
        if (o.parentPort) {
          this.onAnalysisCompletion(o.parentPort, {
            diagnostics: e,
            filesInProgram: this.program.getFileCount(),
            requiringAnalysisCount: t,
            checkingOnlyOpenFiles: this.program.isCheckingOnlyOpenFiles(),
            fatalErrorOccurred: false,
            configParseErrorOccurred: false,
            elapsedTime: n,
            reason: 'tracking'
          });
        }
      }
      _analysisPaused(e, t) {
        e.postMessage({
          requestType: 'analysisPaused',
          data: d.serialize(t)
        });
      }
    }
    function b(e) {
      e.diagnostics = e.diagnostics.map(e => ({
        fileUri: T.Uri.fromJsonObj(e.fileUri),
        version: e.version,
        diagnostics: _(e.diagnostics)
      }));
      return e;
    }
    function _(e) {
      return e.map(e => {
        const t = new g.Diagnostic(e.category, e.message, e.range, e.priority);
        if (e._actions) {
          for (const n of e._actions) {
            t.addAction(n);
          }
        }
        if (e._rule) {
          t.setRule(e._rule);
        }
        if (e._relatedInfo) {
          for (const n of e._relatedInfo) {
            t.addRelatedInfo(n.message, n.uri, n.range);
          }
        }
        return t;
      });
    }
    exports.BackgroundAnalysisRunnerBase = v;
  },
  94953: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.BackgroundThreadBase = exports.BackgroundConsole = undefined;
    exports.serializeReplacer = b;
    exports.serialize = _;
    exports.deserializeReviver = C;
    exports.deserialize = I;
    exports.run = function (e, t, n = _) {
      try {
        const a = e();
        if (c.isThenable(a)) {
          return a.then(e => {
            t.postMessage({
              kind: 'ok',
              data: n(e)
            });
          }, e => {
            if (l.OperationCanceledException.is(e)) {
              t.postMessage({
                kind: 'cancelled',
                data: e.message
              });
            } else {
              t.postMessage({
                kind: 'failed',
                data: `Exception: ${e.message} in ${e.stack}`
              });
            }
          });
        } else {
          t.postMessage({
            kind: 'ok',
            data: n(a)
          });
          return;
        }
      } catch (e) {
        if (l.OperationCanceledException.is(e)) {
          t.postMessage({
            kind: 'cancelled',
            data: e.message
          });
          return;
        }
        t.postMessage({
          kind: 'failed',
          data: `Exception: ${e.message} in ${e.stack}`
        });
      }
    };
    exports.getBackgroundWaiter = function (e, t = I) {
      return new Promise((n, a) => {
        e.on('message', e => {
          switch (e.kind) {
            case 'ok':
              n(t(e.data));
              break;
            case 'cancelled':
              a(new l.OperationCanceledException());
              break;
            case 'failed':
              a(e.data);
              break;
            default:
              u.fail(`unknown kind ${e.kind}`);
          }
        });
      });
    };
    const i = require(28167);
    const o = require(32720);
    const l = require(91426);
    const p = require(12522);
    const d = require(25075);
    const c = require(34455);
    const u = __importStar(require(48281));
    const m = require(27643);
    const y = require(71745);
    const g = require(42856);
    require(23070);
    const h = require(27113);
    const f = require(90355);
    const T = require(34487);
    class v {
      constructor() {
        this._level = d.LogLevel.Log;
      }
      get level() {
        return this._level;
      }
      set level(e) {
        this._level = e;
      }
      log(e) {
        this.post(d.LogLevel.Log, e);
      }
      info(e) {
        this.post(d.LogLevel.Info, e);
      }
      warn(e) {
        this.post(d.LogLevel.Warn, e);
      }
      error(e) {
        this.post(d.LogLevel.Error, e);
      }
      post(e, t) {
        if (i.parentPort !== null && i.parentPort !== undefined) {
          i.parentPort.postMessage({
            requestType: 'log',
            data: _({
              level: e,
              message: t
            })
          });
        }
      }
    }
    exports.BackgroundConsole = v;
    function b(e) {
      var t;
      if (h.Uri.is(e) && e.toJsonObj !== undefined) {
        return {
          __serialized_uri_val: e.toJsonObj()
        };
      }
      if (e instanceof Map) {
        return {
          __serialized_map_val: [...e]
        };
      }
      if (e instanceof Set) {
        return {
          __serialized_set_val: [...e]
        };
      }
      if (e instanceof RegExp) {
        return {
          __serialized_regexp_val: {
            source: e.source,
            flags: e.flags
          }
        };
      }
      if (e instanceof p.ConfigOptions) {
        return {
          __serialized_config_options: Object.entries(e).reduce((e, t, n) => ({
            ...e,
            [t[0]]: t[1]
          }), {})
        };
      }
      if (f.CancellationToken.is(e)) {
        return {
          cancellation_token_val: (t = l.getCancellationTokenId(e)) !== null && t !== undefined ? t : null
        };
      } else {
        return e;
      }
    }
    function _(e) {
      return JSON.stringify(e, (e, t) => b(t));
    }
    function C(e) {
      if (e && typeof e == 'object') {
        if (e.__serialized_uri_val !== undefined) {
          return h.Uri.fromJsonObj(e.__serialized_uri_val);
        }
        if (e.__serialized_map_val) {
          return new Map(e.__serialized_map_val);
        }
        if (e.__serialized_set_val) {
          return new Set(e.__serialized_set_val);
        }
        if (e.__serialized_regexp_val) {
          return new RegExp(e.__serialized_regexp_val.source, e.__serialized_regexp_val.flags);
        }
        if (e.__serialized_config_options) {
          const t = new p.ConfigOptions(e.__serialized_config_options.projectRoot);
          Object.assign(t, e.__serialized_config_options);
          return t;
        }
        if (Object.keys(e).includes('cancellation_token_val')) {
          return T.getCancellationTokenFromId(e.cancellation_token_val);
        }
      }
      return e;
    }
    function I(e) {
      if (e) {
        return JSON.parse(e, (e, t) => C(t));
      }
    }
    exports.BackgroundThreadBase = class {
      constructor(e, t) {
        let n;
        l.setCancellationFolderName(e.cancellationFolderName);
        this._serviceProvider = t ?? new g.ServiceProvider();
        if (!this._serviceProvider.tryGet(y.ServiceKeys.console)) {
          this._serviceProvider.add(y.ServiceKeys.console, new v());
        }
        if (!this._serviceProvider.tryGet(y.ServiceKeys.tempFile)) {
          n = new m.RealTempFile();
          this._serviceProvider.add(y.ServiceKeys.tempFile, n);
        }
        if (!this._serviceProvider.tryGet(y.ServiceKeys.caseSensitivityDetector)) {
          this._serviceProvider.add(y.ServiceKeys.caseSensitivityDetector, n ?? new m.RealTempFile());
        }
        if (!this._serviceProvider.tryGet(y.ServiceKeys.fs)) {
          this._serviceProvider.add(y.ServiceKeys.fs, m.createFromRealFileSystem(this._serviceProvider.get(y.ServiceKeys.caseSensitivityDetector), this.getConsole()));
        }
        if (!this._serviceProvider.tryGet(y.ServiceKeys.cacheManager)) {
          this._serviceProvider.add(y.ServiceKeys.cacheManager, new o.CacheManager());
        }
        global.__rootDirectory = h.Uri.parse(e.rootUri, this._serviceProvider).getFilePath();
      }
      get fs() {
        return this._serviceProvider.fs();
      }
      log(e, t) {
        if (i.parentPort !== null && i.parentPort !== undefined) {
          i.parentPort.postMessage({
            requestType: 'log',
            data: _({
              level: e,
              message: t
            })
          });
        }
      }
      getConsole() {
        return this._serviceProvider.console();
      }
      getServiceProvider() {
        return this._serviceProvider;
      }
      handleShutdown() {
        const e = this._serviceProvider.tryGet(y.ServiceKeys.tempFile);
        if (c.Disposable.is(e)) {
          e.dispose();
        }
        if (i.parentPort !== null && i.parentPort !== undefined) {
          i.parentPort.close();
        }
      }
    };
  },
  18177: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CommandResult = undefined;
    const a = require(38659);
    var r;
    (function (e) {
      e.is = function (e) {
        return e && e.label !== undefined && e.edits && a.WorkspaceEdit.is(e.edits);
      };
    })(r || (exports.CommandResult = r = {}));
  },
  76737: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeStubCreator = exports.CreateTypeStubCommand = undefined;
    const a = require(91426);
    const r = require(92196);
    const s = require(27113);
    exports.CreateTypeStubCommand = class {
      constructor(e) {
        this._ls = e;
      }
      async execute(e, t) {
        if (!e.arguments || e.arguments.length < 2) {
          return;
        }
        const n = s.Uri.parse(e.arguments[0], this._ls.serviceProvider);
        const a = e.arguments[1];
        const r = s.Uri.parse(e.arguments[2], this._ls.serviceProvider);
        const o = await this._ls.getWorkspaceForFile(r ?? n);
        return await new i(this._ls).create(o, a, t);
      }
    };
    class i {
      constructor(e) {
        this._ls = e;
      }
      async create(e, t, n) {
        const s = await r.AnalyzerServiceExecutor.cloneService(this._ls, e, {
          typeStubTargetImportName: t,
          useBackgroundAnalysis: true
        });
        try {
          await s.writeTypeStubInBackground(n);
          s.dispose();
          const e = `Type stub was successfully created for '${t}'.`;
          this._ls.window.showInformationMessage(e);
          this._ls.reanalyze();
        } catch (e) {
          if (a.OperationCanceledException.is(e)) {
            const e = `Type stub creation for '${t}' was canceled`;
            this._ls.console.error(e);
          } else {
            let n = '';
            if (e instanceof Error) {
              n = `: ${e.message}`;
            }
            n = `An error occurred when creating type stub for '${t}'${n}`;
            this._ls.console.error(n);
            this._ls.window.showErrorMessage(n);
          }
        }
      }
    }
    exports.TypeStubCreator = i;
  },
  89577: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DumpFileDebugInfo = exports.DumpFileDebugInfoCommand = undefined;
    const a = require(26687);
    const r = require(41557);
    const s = require(88744);
    const i = require(21024);
    const o = require(91426);
    const l = require(34455);
    const p = require(56814);
    const d = require(88754);
    const c = require(27113);
    const u = require(85114);
    exports.DumpFileDebugInfoCommand = class {
      constructor(e) {
        this._ls = e;
      }
      async execute(e, t) {
        o.throwIfCancellationRequested(t);
        if (!e.arguments || e.arguments.length < 2) {
          return [];
        }
        const n = c.Uri.parse(e.arguments[0], this._ls.serviceProvider);
        const a = await this._ls.getWorkspaceForFile(n);
        return new m().dump(a, n, e.arguments, t);
      }
    };
    class m {
      dump(e, t, n, s) {
        return e.service.run(s => {
          const i = n[1];
          const o = e.service.getParseResults(e.service.fs.realCasePath(t));
          if (!o) {
            return [];
          }
          const l = [];
          const p = {
            info: e => {
              l.push(e);
            },
            log: e => {
              l.push(e);
            },
            error: e => {
              l.push(e);
            },
            warn: e => {
              l.push(e);
            }
          };
          p.info(`* Dump debug info for '${t.toUserVisibleString()}'`);
          switch (i) {
            case 'tokens':
              p.info(`* Token info (${o.tokenizerOutput.tokens.count} tokens)`);
              for (let e = 0; e < o.tokenizerOutput.tokens.count; e++) {
                const n = o.tokenizerOutput.tokens.getItemAt(e);
                p.info(`[${e}] ${_(t, n, o.tokenizerOutput.lines)}`);
              }
              break;
            case 'nodes':
              {
                p.info('* Node info');
                const e = new v(t, o.tokenizerOutput.lines);
                e.walk(o.parserOutput.parseTree);
                p.info(e.output);
                break;
              }
            case 'types':
              {
                const e = s.evaluator;
                const a = n[2];
                const r = n[3];
                if (!e || !a || !r) {
                  return [];
                }
                p.info('* Type info');
                p.info(`${g(t, e, o, a, r)}`);
                break;
              }
            case 'cachedtypes':
              {
                const e = s.evaluator;
                const a = n[2];
                const r = n[3];
                if (!e || !a || !r) {
                  return [];
                }
                p.info('* Cached Type info');
                p.info(`${g(t, e, o, a, r, true)}`);
                break;
              }
            case 'codeflowgraph':
              {
                const e = s.evaluator;
                const t = n[2];
                if (!e || t === undefined) {
                  return [];
                }
                const i = r.findNodeByOffset(o.parserOutput.parseTree, t);
                if (!i) {
                  return [];
                }
                const l = a.getFlowNode(i);
                if (!l) {
                  return [];
                }
                p.info('* CodeFlow Graph');
                e.printControlFlowGraph(l, undefined, 'Dump CodeFlowGraph', p);
              }
          }
          e.service.serviceProvider.console().info(l.join('\n'));
          return [];
        }, s);
      }
    }
    function y(e, t) {
      return JSON.stringify(e, t, 2).replace(/\\\\/g, '\\');
    }
    function g(e, t, n, a, s, o) {
      var p;
      var c;
      const m = new v(e, n.tokenizerOutput.lines);
      const g = (p = r.findNodeByOffset(n.parserOutput.parseTree, a)) !== null && p !== undefined ? p : r.findNodeByOffset(n.parserOutput.parseTree, s);
      if (!g) {
        return 'N/A';
      }
      const _ = new Set();
      if (g.nodeType === 38) {
        switch ((c = g.parent) === null || c === undefined ? undefined : c.nodeType) {
          case 10:
            {
              const e = o ? t.getCachedType(g.parent.d.name) : t.getTypeOfClass(g.parent);
              if (e) {
                return y(e, A);
              } else {
                return 'N/A';
              }
            }
          case 31:
            {
              const e = o ? t.getCachedType(g.parent.d.name) : t.getTypeOfFunction(g.parent);
              if (e) {
                return y(e, A);
              } else {
                return 'N/A';
              }
            }
        }
      }
      const I = d.TextRange.fromBounds(a, s);
      const k = function (e, t) {
        let n = e;
        while (n && !d.TextRange.containsRange(n, t)) {
          n = n.parent;
        }
        if (!n) {
          return;
        }
        while (!u.isExpressionNode(n)) {
          n = n.parent;
        }
        return n;
      }(g, I);
      if (!k) {
        return 'N/A';
      }
      const w = `Expression node found at ${C(k, n.tokenizerOutput.lines)} from the given span ${C(I, n.tokenizerOutput.lines)}\r\n`;
      const S = o ? t.getCachedType(k) : t.getType(k);
      if (S) {
        return w + y(S, A);
      } else {
        return w + 'No result';
      }
      function A(e, t) {
        if (t !== undefined) {
          if (!l.isNumber(t) && !l.isString(t)) {
            if (_.has(t)) {
              if (x(n = t) && n.details && P(n.details)) {
                return `<cycle> class '${t.shared.fullName}' typeSourceId:${t.shared.typeSourceId}`;
              } else {
                if (function (e) {
                  return x(e) && e.details && D(e.details);
                }(t)) {
                  return `<cycle> function '${t.shared.fullName}' parameter count:${t.shared.parameters.length}`;
                } else {
                  if (function (e) {
                    return x(e) && e.details && N(e.details);
                  }(t)) {
                    return `<cycle> function '${t.shared.name}' scope id:${t.priv.nameWithScope}`;
                  } else {
                    return undefined;
                  }
                }
              }
            }
            _.add(t);
          }
          var n;
          if (x(this) && e === 'category') {
            return function (e, t) {
              switch (e) {
                case 0:
                  return 'Unbound';
                case 1:
                  return 'Unknown';
                case 2:
                  return 'Any';
                case 3:
                  return 'Never';
                case 4:
                  return 'Function';
                case 5:
                  return 'Overloaded';
                case 6:
                  if (i.TypeBase.isInstantiable(t)) {
                    return 'Class';
                  } else {
                    return 'Object';
                  }
                case 7:
                  return 'Module';
                case 8:
                  return 'Union';
                case 9:
                  return 'TypeVar';
                default:
                  return `Unknown Value!! (${e})`;
              }
            }(t, this);
          }
          if (x(this) && e === 'flags') {
            return function (e) {
              const t = [];
              if (e & 1) {
                t.push('Instantiable');
              }
              if (e & 2) {
                t.push('Instance');
              }
              if (t.length === 0) {
                return 'None';
              } else {
                return t.join(',');
              }
            }(t);
          }
          if (P(this) && e === 'flags') {
            return h(T, t);
          }
          if (D(this) && e === 'flags') {
            return function (e) {
              return h(f, e);
            }(t);
          }
          if (N(this) && e === 'variance') {
            return function (e) {
              switch (e) {
                case 2:
                  return 'Invariant';
                case 3:
                  return 'Covariant';
                case 4:
                  return 'Contravariant';
                default:
                  return `Unknown Value!! (${e})`;
              }
            }(t);
          }
          if (function (e) {
            return e.category && e.type;
          }(this) && e === 'category') {
            return b(t);
          }
          if (t.nodeType && t.id) {
            m.visitNode(t);
            const e = m.output;
            m.reset();
            return e;
          }
          return t;
        }
      }
      function x(e) {
        return e.category && e.flags;
      }
      function P(e) {
        return e.name !== undefined && e.fullName !== undefined && e.moduleName !== undefined && e.baseClasses;
      }
      function D(e) {
        return e.name !== undefined && e.fullName !== undefined && e.moduleName !== undefined && e.parameters;
      }
      function N(e) {
        return e.name !== undefined && e.constraints && e.variance !== undefined;
      }
    }
    function h(e, t) {
      const n = [];
      e.forEach(e => {
        if (t & e[0]) {
          n.push(e[1]);
        }
      });
      if (n.length === 0) {
        if (t === 0) {
          return 'None';
        } else {
          return '<Unknown>';
        }
      } else {
        return n.join(',');
      }
    }
    exports.DumpFileDebugInfo = m;
    const f = [[8, 'AbstractMethod'], [512, 'Async'], [2, 'ClassMethod'], [1, 'ConstructorMethod'], [32, 'DisableDefaultChecks'], [8192, 'Final'], [16, 'Generator'], [256, 'Overloaded'], [65536, 'ParamSpecValue'], [131072, 'PartiallyEvaluated'], [4096, 'PyTypedDefinition'], [32768, 'SkipArgsKwargsCompatibilityCheck'], [4, 'StaticMethod'], [2048, 'StubDefinition'], [64, 'SynthesizedMethod'], [16384, 'UnannotatedParams']];
    const T = [[1, 'BuiltIn'], [32, 'CanOmitDictValues'], [131072, 'ClassProperty'], [262144, 'DefinedInStub'], [65536, 'EnumClass'], [256, 'Final'], [16384, 'HasCustomClassGetItem'], [8192, 'PartiallyEvaluated'], [128, 'PropertyClass'], [512, 'ProtocolClass'], [1024, 'PseudoGenericClass'], [2048, 'RuntimeCheckable'], [2, 'SpecialBuiltIn'], [64, 'SupportsAbstractMethods'], [32768, 'TupleClass'], [4, 'TypedDictClass'], [4096, 'TypingExtensionClass']];
    class v extends s.ParseTreeWalker {
      constructor(e, t) {
        super();
        this._uri = e;
        this._lines = t;
        this._indentation = '';
        this._output = '';
      }
      get output() {
        return this._output;
      }
      walk(e) {
        const t = this.visitNode(e);
        if (t.length > 0) {
          this._indentation += '  ';
          this.walkMultiple(t);
          this._indentation = this._indentation.substr(0, this._indentation.length - 2);
        }
      }
      reset() {
        this._indentation = '';
        this._output = '';
      }
      visitArgument(e) {
        this._log(`${this._getPrefix(e)} ${function (e) {
          switch (e) {
            case 0:
              return 'Simple';
            case 1:
              return 'UnpackedList';
            case 2:
              return 'UnpackedDictionary';
            default:
              return `Unknown Value!! (${e})`;
          }
        }(e.d.argCategory)}`);
        return true;
      }
      visitAssert(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitAssignment(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitAssignmentExpression(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitAugmentedAssignment(e) {
        this._log(`${this._getPrefix(e)} ${I(e.d.operator)}`);
        return true;
      }
      visitAwait(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitBinaryOperation(e) {
        this._log(`${this._getPrefix(e)} ${_(this._uri, e.d.operatorToken, this._lines)} ${I(e.d.operator)}} parenthesized:(${e.d.hasParens})`);
        return true;
      }
      visitBreak(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitCall(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitClass(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitComprehension(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitComprehensionFor(e) {
        this._log(`${this._getPrefix(e)} async:(${e.d.isAsync})`);
        return true;
      }
      visitComprehensionIf(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitContinue(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitConstant(e) {
        this._log(`${this._getPrefix(e)} ${k(e.d.constType)}`);
        return true;
      }
      visitDecorator(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitDel(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitDictionary(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitDictionaryKeyEntry(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitDictionaryExpandEntry(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitError(e) {
        this._log(`${this._getPrefix(e)} ${function (e) {
          switch (e) {
            case 0:
              return 'MissingIn';
            case 1:
              return 'MissingElse';
            case 2:
              return 'MissingExpression';
            case 3:
              return 'MissingIndexOrSlice';
            case 4:
              return 'MissingDecoratorCallName';
            case 5:
              return 'MissingCallCloseParen';
            case 6:
              return 'MissingIndexCloseBracket';
            case 7:
              return 'MissingMemberAccessName';
            case 8:
              return 'MissingTupleCloseParen';
            case 9:
              return 'MissingListCloseBracket';
            case 10:
              return 'MissingFunctionParameterList';
            case 11:
              return 'MissingPattern';
            case 12:
              return 'MissingPatternSubject';
            case 13:
              return 'MissingDictValue';
            case 15:
              return 'MaxDepthExceeded';
            default:
              return `Unknown Value!! (${e})`;
          }
        }(e.d.category)}`);
        return true;
      }
      visitEllipsis(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitIf(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitImport(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitImportAs(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitImportFrom(e) {
        this._log(`${this._getPrefix(e)} wildcard import:(${e.d.isWildcardImport}) paren:(${e.d.usesParens}) wildcard token:(${e.d.wildcardToken ? _(this._uri, e.d.wildcardToken, this._lines) : 'N/A'}) missing import keyword:(${e.d.missingImport})`);
        return true;
      }
      visitImportFromAs(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitIndex(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitExcept(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitFor(e) {
        this._log(`${this._getPrefix(e)} async:(${e.d.isAsync})`);
        return true;
      }
      visitFormatString(e) {
        this._log(`${this._getPrefix(e)} f-string`);
        return true;
      }
      visitFunction(e) {
        this._log(`${this._getPrefix(e)} async:(${e.d.isAsync})`);
        return true;
      }
      visitFunctionAnnotation(e) {
        this._log(`${this._getPrefix(e)} ellipsis:(${e.d.isEllipsis})`);
        return true;
      }
      visitGlobal(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitLambda(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitList(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitMemberAccess(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitModule(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitModuleName(e) {
        this._log(`${this._getPrefix(e)} leading dots:(${e.d.leadingDots}) trailing dot:(${e.d.hasTrailingDot})`);
        return true;
      }
      visitName(e) {
        this._log(`${this._getPrefix(e)} ${_(this._uri, e.d.token, this._lines)} ${e.d.value}`);
        return true;
      }
      visitNonlocal(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitNumber(e) {
        this._log(`${this._getPrefix(e)} ${e.d.value} int:(${e.d.isInteger}) imaginary:(${e.d.isImaginary})`);
        return true;
      }
      visitParameter(e) {
        this._log(`${this._getPrefix(e)} ${b(e.d.category)}`);
        return true;
      }
      visitPass(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitRaise(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitReturn(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitSet(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitSlice(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitStatementList(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitString(e) {
        this._log(`${this._getPrefix(e)} ${_(this._uri, e.d.token, this._lines)} ${e.d.value}`);
        return true;
      }
      visitStringList(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitSuite(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitTernary(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitTuple(e) {
        this._log(`${this._getPrefix(e)} paren:(${e.d.hasParens})`);
        return true;
      }
      visitTry(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitTypeAnnotation(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitUnaryOperation(e) {
        this._log(`${this._getPrefix(e)} ${_(this._uri, e.d.operatorToken, this._lines)} ${I(e.d.operator)}`);
        return true;
      }
      visitUnpack(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitWhile(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitWith(e) {
        this._log(`${this._getPrefix(e)} async:(${e.d.isAsync})`);
        return true;
      }
      visitWithItem(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitYield(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitYieldFrom(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitCase(e) {
        this._log(`${this._getPrefix(e)} isIrrefutable: ${e.d.isIrrefutable}`);
        return true;
      }
      visitMatch(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternAs(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternCapture(e) {
        this._log(`${this._getPrefix(e)} isStar:${e.d.isStar} isWildcard:${e.d.isWildcard}`);
        return true;
      }
      visitPatternClass(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternClassArgument(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternLiteral(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternMapping(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternMappingExpandEntry(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternMappingKeyEntry(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitPatternSequence(e) {
        this._log(`${this._getPrefix(e)} starEntryIndex: ${e.d.starEntryIndex}`);
        return true;
      }
      visitPatternValue(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitTypeAlias(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      visitTypeParameter(e) {
        this._log(`${this._getPrefix(e)} typeParamCategory:${function (e) {
          switch (e) {
            case u.TypeParamKind.TypeVar:
              return 'TypeVar';
            case u.TypeParamKind.TypeVarTuple:
              return 'TypeVarTuple';
            case u.TypeParamKind.ParamSpec:
              return 'ParamSpec';
          }
        }(e.d.typeParamKind)}`);
        return true;
      }
      visitTypeParameterList(e) {
        this._log(`${this._getPrefix(e)}`);
        return true;
      }
      _log(e) {
        this._output += `${this._indentation}${e}\r\n`;
      }
      _getPrefix(e) {
        const t = p.convertOffsetToPosition(e.start, this._lines);
        return `[${e.id}] '${this._uri.toString()}:${t.line + 1}:${t.character + 1}' => ${r.printParseNodeType(e.nodeType)} ${C(e, this._lines)} =>`;
      }
    }
    function b(e) {
      switch (e) {
        case 0:
          return 'Simple';
        case 1:
          return 'ArgsList';
        case 2:
          return 'KwargsDict';
      }
    }
    function _(e, t, n) {
      const a = p.convertOffsetToPosition(t.start, n);
      let r = `'${e.toUserVisibleString()}:${a.line + 1}:${a.character + 1}' (`;
      var s;
      r += function (e) {
        switch (e) {
          case 0:
            return 'Invalid';
          case 1:
            return 'EndOfStream';
          case 2:
            return 'NewLine';
          case 3:
            return 'Indent';
          case 4:
            return 'Dedent';
          case 5:
            return 'String';
          case 6:
            return 'Number';
          case 7:
            return 'Identifier';
          case 8:
            return 'Keyword';
          case 9:
            return 'Operator';
          case 10:
            return 'Colon';
          case 11:
            return 'Semicolon';
          case 12:
            return 'Comma';
          case 13:
            return 'OpenParenthesis';
          case 14:
            return 'CloseParenthesis';
          case 15:
            return 'OpenBracket';
          case 16:
            return 'CloseBracket';
          case 17:
            return 'OpenCurlyBrace';
          case 18:
            return 'CloseCurlyBrace';
          case 19:
            return 'Ellipsis';
          case 20:
            return 'Dot';
          case 21:
            return 'Arrow';
          case 22:
            return 'Backtick';
          default:
            return `Unknown Value!! (${e})`;
        }
      }(t.type);
      r += (s = t).newLineType ? `, ${function (e) {
        switch (e) {
          case 0:
            return 'CarriageReturn';
          case 1:
            return 'LineFeed';
          case 2:
            return 'CarriageReturnLineFeed';
          case 3:
            return 'Implied';
          default:
            return `Unknown Value!! (${e})`;
        }
      }(s.newLineType)}` : '';
      r += function (e) {
        if (e.operatorType) {
          return `, ${I(e.operatorType)}`;
        } else {
          return '';
        }
      }(t);
      r += function (e) {
        if (e.keywordType) {
          return `, ${k(e.keywordType)}`;
        } else {
          return '';
        }
      }(t);
      r += function (e) {
        if (e.flags) {
          return `, [${(t = e.flags, h(w, t))}]`;
        } else {
          return '';
        }
        var t;
      }(t);
      r += `, ${C(t, n)}`;
      r += ') ';
      r += JSON.stringify(t);
      return r;
    }
    function C(e, t) {
      const n = p.convertOffsetsToRange(e.start, d.TextRange.getEnd(e), t);
      return `(${n.start.line},${n.start.character})-(${n.end.line},${n.end.character})`;
    }
    function I(e) {
      switch (e) {
        case 0:
          return 'Add';
        case 1:
          return 'AddEqual';
        case 2:
          return 'Assign';
        case 3:
          return 'BitwiseAnd';
        case 4:
          return 'BitwiseAndEqual';
        case 5:
          return 'BitwiseInvert';
        case 6:
          return 'BitwiseOr';
        case 7:
          return 'BitwiseOrEqual';
        case 8:
          return 'BitwiseXor';
        case 9:
          return 'BitwiseXorEqual';
        case 10:
          return 'Divide';
        case 11:
          return 'DivideEqual';
        case 12:
          return 'Equals';
        case 13:
          return 'FloorDivide';
        case 14:
          return 'FloorDivideEqual';
        case 15:
          return 'GreaterThan';
        case 16:
          return 'GreaterThanOrEqual';
        case 17:
          return 'LeftShift';
        case 18:
          return 'LeftShiftEqual';
        case 19:
          return 'LessOrGreaterThan';
        case 20:
          return 'LessThan';
        case 21:
          return 'LessThanOrEqual';
        case 22:
          return 'MatrixMultiply';
        case 23:
          return 'MatrixMultiplyEqual';
        case 24:
          return 'Mod';
        case 25:
          return 'ModEqual';
        case 26:
          return 'Multiply';
        case 27:
          return 'MultiplyEqual';
        case 28:
          return 'NotEquals';
        case 29:
          return 'Power';
        case 30:
          return 'PowerEqual';
        case 31:
          return 'RightShift';
        case 32:
          return 'RightShiftEqual';
        case 33:
          return 'Subtract';
        case 34:
          return 'SubtractEqual';
        case 35:
          return 'Walrus';
        case 36:
          return 'And';
        case 37:
          return 'Or';
        case 38:
          return 'Not';
        case 39:
          return 'Is';
        case 40:
          return 'IsNot';
        case 41:
          return 'In';
        case 42:
          return 'NotIn';
        default:
          return `Unknown Value!! (${e})`;
      }
    }
    function k(e) {
      switch (e) {
        case 0:
          return 'And';
        case 1:
          return 'As';
        case 2:
          return 'Assert';
        case 3:
          return 'Async';
        case 4:
          return 'Await';
        case 5:
          return 'Break';
        case 7:
          return 'Class';
        case 8:
          return 'Continue';
        case 9:
          return 'Debug';
        case 10:
          return 'Def';
        case 11:
          return 'Del';
        case 12:
          return 'Elif';
        case 13:
          return 'Else';
        case 14:
          return 'Except';
        case 15:
          return 'False';
        case 16:
          return 'Finally';
        case 17:
          return 'For';
        case 18:
          return 'From';
        case 19:
          return 'Global';
        case 20:
          return 'If';
        case 21:
          return 'Import';
        case 22:
          return 'In';
        case 23:
          return 'Is';
        case 24:
          return 'Lambda';
        case 26:
          return 'None';
        case 27:
          return 'Nonlocal';
        case 28:
          return 'Not';
        case 29:
          return 'Or';
        case 30:
          return 'Pass';
        case 31:
          return 'Raise';
        case 32:
          return 'Return';
        case 33:
          return 'True';
        case 34:
          return 'Try';
        case 36:
          return 'While';
        case 37:
          return 'With';
        case 38:
          return 'Yield';
        default:
          return `Unknown Value!! (${e})`;
      }
    }
    const w = [[32, 'Bytes'], [2, 'DoubleQuote'], [64, 'Format'], [8, 'Raw'], [1, 'SingleQuote'], [4, 'Triplicate'], [16, 'Unicode'], [65536, 'Unterminated']];
  },
  64330: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.initializeDependencies = async function () {
      await a.ensureTomlModuleLoaded();
      require(73527).install();
    };
    const a = require(33351);
  },
  91426: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CancellationThrottle = exports.FileBasedToken = exports.DefaultCancellationProvider = exports.OperationCanceledException = undefined;
    exports.getCancellationFolderName = function () {
      return o;
    };
    exports.setCancellationFolderName = function (e) {
      o = e;
    };
    exports.invalidateTypeCacheIfCanceled = function (e) {
      try {
        return e();
      } catch (e) {
        if (l.is(e)) {
          e.isTypeCacheInvalid = true;
        }
        throw e;
      }
    };
    exports.throwIfCancellationRequested = function (e) {
      if (!s.isDebugMode() && e.isCancellationRequested) {
        throw new l();
      }
    };
    exports.onCancellationRequested = d;
    exports.CancelAfter = function (e, ...t) {
      const n = e.createCancellationTokenSource();
      const a = [];
      for (const e of t) {
        a.push(d(e, () => {
          n.cancel();
        }));
      }
      a.push(d(n.token, () => {
        a.forEach(e => e.dispose());
      }));
      return n;
    };
    exports.getCancellationTokenId = function (e) {
      if (e instanceof c) {
        return e.id;
      } else {
        return undefined;
      }
    };
    exports.raceCancellation = async function (e, ...t) {
      if (!e) {
        return Promise.race(t);
      }
      if (e.isCancellationRequested) {
        throw new l();
      }
      return new Promise((n, a) => {
        if (e.isCancellationRequested) {
          return a(new l());
        }
        const r = d(e, () => {
          r.dispose();
          a(new l());
        });
        Promise.race(t).then(n, a).finally(() => r.dispose());
      });
    };
    const a = require(90355);
    const r = require(56911);
    const s = require(34455);
    const i = require(5884);
    let o;
    class l extends r.ResponseError {
      constructor() {
        super(r.LSPErrorCodes.RequestCancelled, 'request cancelled');
        this.isTypeCacheInvalid = false;
      }
      static is(e) {
        return e.code === r.LSPErrorCodes.RequestCancelled;
      }
    }
    exports.OperationCanceledException = l;
    const p = r.Disposable.create(() => {});
    function d(e, t) {
      try {
        return e.onCancellationRequested(t);
      } catch {
        return p;
      }
    }
    exports.DefaultCancellationProvider = class {
      createCancellationTokenSource() {
        return new a.CancellationTokenSource();
      }
    };
    class c {
      constructor(e, t) {
        this._fs = t;
        this.isCancelled = false;
        this.cancellationFilePath = i.UriEx.file(e);
      }
      get id() {
        return this.cancellationFilePath.toString();
      }
      get isCancellationRequested() {
        return !!this.isCancelled || (u.shouldCheck() && this._pipeExists() && this.cancel(), this.isCancelled);
      }
      get onCancellationRequested() {
        if (!this._emitter) {
          this._emitter = new a.Emitter();
        }
        return this._emitter.event;
      }
      cancel() {
        if (!this.isCancelled) {
          this.isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(undefined);
            this._disposeEmitter();
          }
        }
      }
      dispose() {
        this._disposeEmitter();
      }
      _disposeEmitter() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = undefined;
        }
      }
      _pipeExists() {
        try {
          this._fs.statSync(this.cancellationFilePath);
          return true;
        } catch (e) {
          return false;
        }
      }
    }
    exports.FileBasedToken = c;
    class u {
      static shouldCheck() {
        const e = Date.now().valueOf();
        return e - this._lastCheckTimestamp >= 5 && (this._lastCheckTimestamp = e, true);
      }
    }
    exports.CancellationThrottle = u;
    u._lastCheckTimestamp = 0;
  },
  7095: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CaseSensitivityDetector = undefined;
    (function (e) {
      e.is = function (e) {
        return !!e.isCaseSensitive;
      };
    })(n || (exports.CaseSensitivityDetector = n = {}));
  },
  58147: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.emptyArray = undefined;
    exports.contains = r;
    exports.append = function (e, t) {
      if (t === undefined) {
        return e;
      }
      if (e === undefined) {
        return [t];
      }
      e.push(t);
      return e;
    };
    exports.appendArray = function (e, t) {
      if (t.length < 256) {
        e.push(...t);
        return;
      }
      for (const n of t) {
        e.push(n);
      }
    };
    exports.partition = function (e, t) {
      const n = [];
      const a = [];
      for (const r of e) {
        if (t(r)) {
          n.push(r);
        } else {
          a.push(r);
        }
      }
      return [n, a];
    };
    exports.find = function (e, t) {
      for (let n = 0; n < e.length; n++) {
        const a = e[n];
        if (t(a, n)) {
          return a;
        }
      }
      return;
    };
    exports.addRange = i;
    exports.insertAt = function (e, t, n) {
      if (t === 0) {
        e.unshift(n);
      } else {
        if (t === e.length) {
          e.push(n);
        } else {
          for (let n = e.length; n > t; n--) {
            e[n] = e[n - 1];
          }
          e[t] = n;
        }
      }
      return e;
    };
    exports.cloneAndSort = function (e, t) {
      if (e.length === 0) {
        return e;
      } else {
        return e.slice().sort(t);
      }
    };
    exports.stableSort = function (e, t) {
      const n = function (e) {
        return e.map(o);
      }(e);
      (function (e, t, n) {
        t.sort((t, r) => n(e[t], e[r]) || a.compareValues(t, r));
      })(e, n, t);
      return n.map(t => e[t]);
    };
    exports.map = function (e, t) {
      if (e) {
        return e.map(t);
      }
      return;
    };
    exports.some = l;
    exports.every = function (e, t) {
      if (e) {
        return e.every(t);
      }
      return true;
    };
    exports.binarySearch = function (e, t, n, a, r) {
      return p(e, n(t), n, a, r);
    };
    exports.binarySearchKey = p;
    exports.flatten = function (e) {
      const t = [];
      for (const n of e) {
        if (n) {
          if (a.isArray(n)) {
            i(t, n);
          } else {
            t.push(n);
          }
        }
      }
      return t;
    };
    exports.getNestedProperty = function (e, t) {
      return t.split('.').reduce((e, t) => e && e[t], e);
    };
    exports.getOrAdd = function (e, t, n) {
      const a = e.get(t);
      if (a !== undefined) {
        return a;
      }
      const r = n();
      e.set(t, r);
      return r;
    };
    exports.removeArrayElements = function (e, t) {
      for (let n = 0; n < e.length; n++) {
        if (t(e[n])) {
          e.splice(n, 1);
          n--;
        }
      }
      return e;
    };
    exports.createMapFromItems = function (e, t) {
      return e.map(e => t(e)).reduce((t, n, a) => {
        t.set(n, (t.get(n) || []).concat(e[a]));
        return t;
      }, new Map());
    };
    exports.addIfUnique = function (e, t, n = a.equateValues) {
      if (r(e, t, n)) {
        return e;
      }
      e.push(t);
      return e;
    };
    exports.getMapValues = function (e, t) {
      const n = [];
      e.forEach((e, a) => {
        if (t(a, e)) {
          n.push(e);
        }
      });
      return n;
    };
    exports.addIfNotNull = function (e, t) {
      if (t === undefined) {
        return e;
      }
      e.push(t);
      return e;
    };
    exports.arrayEquals = function (e, t, n) {
      if (e.length !== t.length) {
        return false;
      }
      return e.every((e, a) => n(e, t[a]));
    };
    const a = require(34455);
    function r(e, t, n = a.equateValues) {
      if (e) {
        for (const a of e) {
          if (n(a, t)) {
            return true;
          }
        }
      }
      return false;
    }
    function s(e, t) {
      if (t < 0) {
        return e.length + t;
      } else {
        return t;
      }
    }
    function i(e, t, n, a) {
      if (t === undefined || t.length === 0) {
        return e;
      }
      if (e === undefined) {
        return t.slice(n, a);
      }
      n = n === undefined ? 0 : s(t, n);
      a = a === undefined ? t.length : s(t, a);
      for (let r = n; r < a && r < t.length; r++) {
        if (t[r] !== undefined) {
          e.push(t[r]);
        }
      }
      return e;
    }
    function o(e, t) {
      return t;
    }
    function l(e, t) {
      return !!e && (t ? e.some(t) : e.length > 0);
    }
    function p(e, t, n, a, r) {
      if (!l(e)) {
        return -1;
      }
      let s = r || 0;
      let i = e.length - 1;
      while (s <= i) {
        const r = s + (i - s >> 1);
        switch (a(n(e[r]), t)) {
          case -1:
            s = r + 1;
            break;
          case 0:
            return r;
          case 1:
            i = r - 1;
        }
      }
      return ~s;
    }
    exports.emptyArray = [];
  },
  25463: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CommandLineOptions = exports.CommandLineLanguageServerOptions = exports.CommandLineConfigOptions = undefined;
    exports.getDiagnosticSeverityOverrides = function () {
      return ['error', 'warning', 'information', 'none'];
    };
    class n {
      constructor() {
        this.includeFileSpecs = [];
        this.excludeFileSpecs = [];
        this.ignoreFileSpecs = [];
      }
    }
    exports.CommandLineConfigOptions = n;
    class a {
      constructor() {
        this.logTypeEvaluationTime = false;
        this.typeEvaluationTimeThreshold = 50;
        this.enableAmbientAnalysis = true;
      }
    }
    exports.CommandLineLanguageServerOptions = a;
    exports.CommandLineOptions = class {
      constructor(e, t) {
        this.configSettings = new n();
        this.languageServerSettings = new a();
        this.executionRoot = e;
        this.fromLanguageServer = t;
      }
    };
  },
  23574: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createCommand = function (e, t, ...n) {
      const s = n.map(e => r.Uri.is(e) ? e.toString() : e);
      return a.Command.create(e, t, ...s);
    };
    const a = require(38659);
    const r = require(27113);
  },
  12522: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ConfigOptions = exports.SignatureDisplayType = exports.ExecutionEnvironment = exports.PythonPlatform = undefined;
    exports.cloneDiagnosticRuleSet = function (e) {
      return Object.assign({}, e);
    };
    exports.getBooleanDiagnosticRules = _;
    exports.getDiagLevelDiagnosticRules = C;
    exports.getStrictModeNotOverriddenRules = function () {
      return [m.DiagnosticRule.reportMissingModuleSource];
    };
    exports.getOffDiagnosticRuleSet = I;
    exports.getBasicDiagnosticRuleSet = k;
    exports.getStandardDiagnosticRuleSet = w;
    exports.getStrictDiagnosticRuleSet = S;
    exports.matchFileSpecs = function (e, t, n = true) {
      for (const a of e.include) {
        if (f.FileSpec.matchIncludeFileSpec(a.regExp, e.exclude, t, n)) {
          return true;
        }
      }
      return false;
    };
    exports.parseDiagLevel = function (e) {
      switch (e) {
        case false:
        case 'none':
          return 'none';
        case true:
        case 'error':
          return 'error';
        case 'warning':
          return 'warning';
        case 'information':
          return 'information';
        default:
          return;
      }
    };
    const i = require(16928);
    const o = require(16259);
    const l = __importStar(require(4883));
    const p = require(58147);
    const d = require(25463);
    const c = require(25075);
    const u = require(34455);
    const m = require(65880);
    const y = require(63808);
    const g = require(71745);
    const h = require(27113);
    const f = require(5884);
    var T;
    var v;
    (function (e) {
      e.Darwin = 'Darwin';
      e.Windows = 'Windows';
      e.Linux = 'Linux';
    })(T || (exports.PythonPlatform = T = {}));
    class b {
      constructor(e, t, n, a, r, s, i = false) {
        this.extraPaths = [];
        this.name = e;
        this.root = t;
        this.pythonVersion = a ?? y.latestStablePythonVersion;
        this.pythonPlatform = r;
        this.extraPaths = Array.from(s ?? []);
        this.diagnosticRuleSet = {
          ...n
        };
        this.skipNativeLibraries = i;
      }
    }
    function _(e = false) {
      const t = [m.DiagnosticRule.strictListInference, m.DiagnosticRule.strictSetInference, m.DiagnosticRule.strictDictionaryInference, m.DiagnosticRule.analyzeUnannotatedFunctions, m.DiagnosticRule.strictParameterNoneValue, m.DiagnosticRule.enableExperimentalFeatures, m.DiagnosticRule.deprecateTypingAliases, m.DiagnosticRule.disableBytesTypePromotions];
      if (e) {
        t.push(m.DiagnosticRule.enableTypeIgnoreComments);
        t.push(m.DiagnosticRule.enableReachabilityAnalysis);
      }
      return t;
    }
    function C() {
      return [m.DiagnosticRule.reportGeneralTypeIssues, m.DiagnosticRule.reportPropertyTypeMismatch, m.DiagnosticRule.reportFunctionMemberAccess, m.DiagnosticRule.reportMissingImports, m.DiagnosticRule.reportMissingModuleSource, m.DiagnosticRule.reportInvalidTypeForm, m.DiagnosticRule.reportMissingTypeStubs, m.DiagnosticRule.reportImportCycles, m.DiagnosticRule.reportUnusedImport, m.DiagnosticRule.reportUnusedClass, m.DiagnosticRule.reportUnusedFunction, m.DiagnosticRule.reportUnusedVariable, m.DiagnosticRule.reportDuplicateImport, m.DiagnosticRule.reportWildcardImportFromLibrary, m.DiagnosticRule.reportAbstractUsage, m.DiagnosticRule.reportArgumentType, m.DiagnosticRule.reportAssertTypeFailure, m.DiagnosticRule.reportAssignmentType, m.DiagnosticRule.reportAttributeAccessIssue, m.DiagnosticRule.reportCallIssue, m.DiagnosticRule.reportInconsistentOverload, m.DiagnosticRule.reportIndexIssue, m.DiagnosticRule.reportInvalidTypeArguments, m.DiagnosticRule.reportNoOverloadImplementation, m.DiagnosticRule.reportOperatorIssue, m.DiagnosticRule.reportOptionalSubscript, m.DiagnosticRule.reportOptionalMemberAccess, m.DiagnosticRule.reportOptionalCall, m.DiagnosticRule.reportOptionalIterable, m.DiagnosticRule.reportOptionalContextManager, m.DiagnosticRule.reportOptionalOperand, m.DiagnosticRule.reportRedeclaration, m.DiagnosticRule.reportReturnType, m.DiagnosticRule.reportTypedDictNotRequiredAccess, m.DiagnosticRule.reportUntypedFunctionDecorator, m.DiagnosticRule.reportUntypedClassDecorator, m.DiagnosticRule.reportUntypedBaseClass, m.DiagnosticRule.reportUntypedNamedTuple, m.DiagnosticRule.reportPrivateUsage, m.DiagnosticRule.reportTypeCommentUsage, m.DiagnosticRule.reportPrivateImportUsage, m.DiagnosticRule.reportConstantRedefinition, m.DiagnosticRule.reportDeprecated, m.DiagnosticRule.reportIncompatibleMethodOverride, m.DiagnosticRule.reportIncompatibleVariableOverride, m.DiagnosticRule.reportInconsistentConstructor, m.DiagnosticRule.reportOverlappingOverload, m.DiagnosticRule.reportPossiblyUnboundVariable, m.DiagnosticRule.reportMissingSuperCall, m.DiagnosticRule.reportUninitializedInstanceVariable, m.DiagnosticRule.reportInvalidStringEscapeSequence, m.DiagnosticRule.reportUnknownParameterType, m.DiagnosticRule.reportUnknownArgumentType, m.DiagnosticRule.reportUnknownLambdaType, m.DiagnosticRule.reportUnknownVariableType, m.DiagnosticRule.reportUnknownMemberType, m.DiagnosticRule.reportMissingParameterType, m.DiagnosticRule.reportMissingTypeArgument, m.DiagnosticRule.reportInvalidTypeVarUse, m.DiagnosticRule.reportCallInDefaultInitializer, m.DiagnosticRule.reportUnnecessaryIsInstance, m.DiagnosticRule.reportUnnecessaryCast, m.DiagnosticRule.reportUnnecessaryComparison, m.DiagnosticRule.reportUnnecessaryContains, m.DiagnosticRule.reportAssertAlwaysTrue, m.DiagnosticRule.reportSelfClsParameterName, m.DiagnosticRule.reportImplicitStringConcatenation, m.DiagnosticRule.reportUndefinedVariable, m.DiagnosticRule.reportUnhashable, m.DiagnosticRule.reportUnboundVariable, m.DiagnosticRule.reportInvalidStubStatement, m.DiagnosticRule.reportIncompleteStub, m.DiagnosticRule.reportUnsupportedDunderAll, m.DiagnosticRule.reportUnusedCallResult, m.DiagnosticRule.reportUnusedCoroutine, m.DiagnosticRule.reportUnusedExcept, m.DiagnosticRule.reportUnusedExpression, m.DiagnosticRule.reportUnnecessaryTypeIgnoreComment, m.DiagnosticRule.reportMatchNotExhaustive, m.DiagnosticRule.reportShadowedImports, m.DiagnosticRule.reportImplicitOverride];
    }
    function I() {
      return {
        printUnknownAsAny: true,
        omitTypeArgsIfUnknown: true,
        omitUnannotatedParamType: true,
        omitConditionalConstraint: true,
        pep604Printing: true,
        strictListInference: false,
        strictSetInference: false,
        strictDictionaryInference: false,
        analyzeUnannotatedFunctions: true,
        strictParameterNoneValue: true,
        enableExperimentalFeatures: false,
        enableTypeIgnoreComments: true,
        enableReachabilityAnalysis: false,
        deprecateTypingAliases: false,
        disableBytesTypePromotions: true,
        reportGeneralTypeIssues: 'none',
        reportPropertyTypeMismatch: 'none',
        reportFunctionMemberAccess: 'none',
        reportMissingImports: 'warning',
        reportMissingModuleSource: 'warning',
        reportInvalidTypeForm: 'warning',
        reportMissingTypeStubs: 'none',
        reportImportCycles: 'none',
        reportUnusedImport: 'none',
        reportUnusedClass: 'none',
        reportUnusedFunction: 'none',
        reportUnusedVariable: 'none',
        reportDuplicateImport: 'none',
        reportWildcardImportFromLibrary: 'none',
        reportAbstractUsage: 'none',
        reportArgumentType: 'none',
        reportAssertTypeFailure: 'none',
        reportAssignmentType: 'none',
        reportAttributeAccessIssue: 'none',
        reportCallIssue: 'none',
        reportInconsistentOverload: 'none',
        reportIndexIssue: 'none',
        reportInvalidTypeArguments: 'none',
        reportNoOverloadImplementation: 'none',
        reportOperatorIssue: 'none',
        reportOptionalSubscript: 'none',
        reportOptionalMemberAccess: 'none',
        reportOptionalCall: 'none',
        reportOptionalIterable: 'none',
        reportOptionalContextManager: 'none',
        reportOptionalOperand: 'none',
        reportRedeclaration: 'none',
        reportReturnType: 'none',
        reportTypedDictNotRequiredAccess: 'none',
        reportUntypedFunctionDecorator: 'none',
        reportUntypedClassDecorator: 'none',
        reportUntypedBaseClass: 'none',
        reportUntypedNamedTuple: 'none',
        reportPrivateUsage: 'none',
        reportTypeCommentUsage: 'none',
        reportPrivateImportUsage: 'none',
        reportConstantRedefinition: 'none',
        reportDeprecated: 'none',
        reportIncompatibleMethodOverride: 'none',
        reportIncompatibleVariableOverride: 'none',
        reportInconsistentConstructor: 'none',
        reportOverlappingOverload: 'none',
        reportPossiblyUnboundVariable: 'none',
        reportMissingSuperCall: 'none',
        reportUninitializedInstanceVariable: 'none',
        reportInvalidStringEscapeSequence: 'none',
        reportUnknownParameterType: 'none',
        reportUnknownArgumentType: 'none',
        reportUnknownLambdaType: 'none',
        reportUnknownVariableType: 'none',
        reportUnknownMemberType: 'none',
        reportMissingParameterType: 'none',
        reportMissingTypeArgument: 'none',
        reportInvalidTypeVarUse: 'none',
        reportCallInDefaultInitializer: 'none',
        reportUnnecessaryIsInstance: 'none',
        reportUnnecessaryCast: 'none',
        reportUnnecessaryComparison: 'none',
        reportUnnecessaryContains: 'none',
        reportAssertAlwaysTrue: 'none',
        reportSelfClsParameterName: 'none',
        reportImplicitStringConcatenation: 'none',
        reportUnboundVariable: 'none',
        reportUnhashable: 'none',
        reportUndefinedVariable: 'warning',
        reportInvalidStubStatement: 'none',
        reportIncompleteStub: 'none',
        reportUnsupportedDunderAll: 'none',
        reportUnusedCallResult: 'none',
        reportUnusedCoroutine: 'none',
        reportUnusedExcept: 'none',
        reportUnusedExpression: 'none',
        reportUnnecessaryTypeIgnoreComment: 'none',
        reportMatchNotExhaustive: 'none',
        reportShadowedImports: 'none',
        reportImplicitOverride: 'none'
      };
    }
    function k() {
      return {
        printUnknownAsAny: false,
        omitTypeArgsIfUnknown: false,
        omitUnannotatedParamType: true,
        omitConditionalConstraint: false,
        pep604Printing: true,
        strictListInference: false,
        strictSetInference: false,
        strictDictionaryInference: false,
        analyzeUnannotatedFunctions: true,
        strictParameterNoneValue: true,
        enableExperimentalFeatures: false,
        enableTypeIgnoreComments: true,
        enableReachabilityAnalysis: true,
        deprecateTypingAliases: false,
        disableBytesTypePromotions: true,
        reportGeneralTypeIssues: 'error',
        reportPropertyTypeMismatch: 'none',
        reportFunctionMemberAccess: 'none',
        reportMissingImports: 'error',
        reportMissingModuleSource: 'warning',
        reportInvalidTypeForm: 'error',
        reportMissingTypeStubs: 'none',
        reportImportCycles: 'none',
        reportUnusedImport: 'none',
        reportUnusedClass: 'none',
        reportUnusedFunction: 'none',
        reportUnusedVariable: 'none',
        reportDuplicateImport: 'none',
        reportWildcardImportFromLibrary: 'warning',
        reportAbstractUsage: 'error',
        reportArgumentType: 'error',
        reportAssertTypeFailure: 'error',
        reportAssignmentType: 'error',
        reportAttributeAccessIssue: 'error',
        reportCallIssue: 'error',
        reportInconsistentOverload: 'error',
        reportIndexIssue: 'error',
        reportInvalidTypeArguments: 'error',
        reportNoOverloadImplementation: 'error',
        reportOperatorIssue: 'error',
        reportOptionalSubscript: 'error',
        reportOptionalMemberAccess: 'error',
        reportOptionalCall: 'error',
        reportOptionalIterable: 'error',
        reportOptionalContextManager: 'error',
        reportOptionalOperand: 'error',
        reportRedeclaration: 'error',
        reportReturnType: 'error',
        reportTypedDictNotRequiredAccess: 'error',
        reportUntypedFunctionDecorator: 'none',
        reportUntypedClassDecorator: 'none',
        reportUntypedBaseClass: 'none',
        reportUntypedNamedTuple: 'none',
        reportPrivateUsage: 'none',
        reportTypeCommentUsage: 'none',
        reportPrivateImportUsage: 'error',
        reportConstantRedefinition: 'none',
        reportDeprecated: 'none',
        reportIncompatibleMethodOverride: 'none',
        reportIncompatibleVariableOverride: 'none',
        reportInconsistentConstructor: 'none',
        reportOverlappingOverload: 'none',
        reportPossiblyUnboundVariable: 'none',
        reportMissingSuperCall: 'none',
        reportUninitializedInstanceVariable: 'none',
        reportInvalidStringEscapeSequence: 'warning',
        reportUnknownParameterType: 'none',
        reportUnknownArgumentType: 'none',
        reportUnknownLambdaType: 'none',
        reportUnknownVariableType: 'none',
        reportUnknownMemberType: 'none',
        reportMissingParameterType: 'none',
        reportMissingTypeArgument: 'none',
        reportInvalidTypeVarUse: 'warning',
        reportCallInDefaultInitializer: 'none',
        reportUnnecessaryIsInstance: 'none',
        reportUnnecessaryCast: 'none',
        reportUnnecessaryComparison: 'none',
        reportUnnecessaryContains: 'none',
        reportAssertAlwaysTrue: 'warning',
        reportSelfClsParameterName: 'warning',
        reportImplicitStringConcatenation: 'none',
        reportUnboundVariable: 'error',
        reportUnhashable: 'error',
        reportUndefinedVariable: 'error',
        reportInvalidStubStatement: 'none',
        reportIncompleteStub: 'none',
        reportUnsupportedDunderAll: 'warning',
        reportUnusedCallResult: 'none',
        reportUnusedCoroutine: 'error',
        reportUnusedExcept: 'error',
        reportUnusedExpression: 'warning',
        reportUnnecessaryTypeIgnoreComment: 'none',
        reportMatchNotExhaustive: 'none',
        reportShadowedImports: 'none',
        reportImplicitOverride: 'none'
      };
    }
    function w() {
      return {
        printUnknownAsAny: false,
        omitTypeArgsIfUnknown: false,
        omitUnannotatedParamType: true,
        omitConditionalConstraint: false,
        pep604Printing: true,
        strictListInference: false,
        strictSetInference: false,
        strictDictionaryInference: false,
        analyzeUnannotatedFunctions: true,
        strictParameterNoneValue: true,
        enableExperimentalFeatures: false,
        enableTypeIgnoreComments: true,
        enableReachabilityAnalysis: true,
        deprecateTypingAliases: false,
        disableBytesTypePromotions: true,
        reportGeneralTypeIssues: 'error',
        reportPropertyTypeMismatch: 'none',
        reportFunctionMemberAccess: 'error',
        reportMissingImports: 'error',
        reportMissingModuleSource: 'warning',
        reportInvalidTypeForm: 'error',
        reportMissingTypeStubs: 'none',
        reportImportCycles: 'none',
        reportUnusedImport: 'none',
        reportUnusedClass: 'none',
        reportUnusedFunction: 'none',
        reportUnusedVariable: 'none',
        reportDuplicateImport: 'none',
        reportWildcardImportFromLibrary: 'warning',
        reportAbstractUsage: 'error',
        reportArgumentType: 'error',
        reportAssertTypeFailure: 'error',
        reportAssignmentType: 'error',
        reportAttributeAccessIssue: 'error',
        reportCallIssue: 'error',
        reportInconsistentOverload: 'error',
        reportIndexIssue: 'error',
        reportInvalidTypeArguments: 'error',
        reportNoOverloadImplementation: 'error',
        reportOperatorIssue: 'error',
        reportOptionalSubscript: 'error',
        reportOptionalMemberAccess: 'error',
        reportOptionalCall: 'error',
        reportOptionalIterable: 'error',
        reportOptionalContextManager: 'error',
        reportOptionalOperand: 'error',
        reportRedeclaration: 'error',
        reportReturnType: 'error',
        reportTypedDictNotRequiredAccess: 'error',
        reportUntypedFunctionDecorator: 'none',
        reportUntypedClassDecorator: 'none',
        reportUntypedBaseClass: 'none',
        reportUntypedNamedTuple: 'none',
        reportPrivateUsage: 'none',
        reportTypeCommentUsage: 'none',
        reportPrivateImportUsage: 'error',
        reportConstantRedefinition: 'none',
        reportDeprecated: 'none',
        reportIncompatibleMethodOverride: 'error',
        reportIncompatibleVariableOverride: 'error',
        reportInconsistentConstructor: 'none',
        reportOverlappingOverload: 'error',
        reportPossiblyUnboundVariable: 'error',
        reportMissingSuperCall: 'none',
        reportUninitializedInstanceVariable: 'none',
        reportInvalidStringEscapeSequence: 'warning',
        reportUnknownParameterType: 'none',
        reportUnknownArgumentType: 'none',
        reportUnknownLambdaType: 'none',
        reportUnknownVariableType: 'none',
        reportUnknownMemberType: 'none',
        reportMissingParameterType: 'none',
        reportMissingTypeArgument: 'none',
        reportInvalidTypeVarUse: 'warning',
        reportCallInDefaultInitializer: 'none',
        reportUnnecessaryIsInstance: 'none',
        reportUnnecessaryCast: 'none',
        reportUnnecessaryComparison: 'none',
        reportUnnecessaryContains: 'none',
        reportAssertAlwaysTrue: 'warning',
        reportSelfClsParameterName: 'warning',
        reportImplicitStringConcatenation: 'none',
        reportUnboundVariable: 'error',
        reportUnhashable: 'error',
        reportUndefinedVariable: 'error',
        reportInvalidStubStatement: 'none',
        reportIncompleteStub: 'none',
        reportUnsupportedDunderAll: 'warning',
        reportUnusedCallResult: 'none',
        reportUnusedCoroutine: 'error',
        reportUnusedExcept: 'error',
        reportUnusedExpression: 'warning',
        reportUnnecessaryTypeIgnoreComment: 'none',
        reportMatchNotExhaustive: 'none',
        reportShadowedImports: 'none',
        reportImplicitOverride: 'none'
      };
    }
    function S() {
      return {
        printUnknownAsAny: false,
        omitTypeArgsIfUnknown: false,
        omitUnannotatedParamType: false,
        omitConditionalConstraint: false,
        pep604Printing: true,
        strictListInference: true,
        strictSetInference: true,
        strictDictionaryInference: true,
        analyzeUnannotatedFunctions: true,
        strictParameterNoneValue: true,
        enableExperimentalFeatures: false,
        enableTypeIgnoreComments: true,
        enableReachabilityAnalysis: true,
        deprecateTypingAliases: false,
        disableBytesTypePromotions: true,
        reportGeneralTypeIssues: 'error',
        reportPropertyTypeMismatch: 'none',
        reportFunctionMemberAccess: 'error',
        reportMissingImports: 'error',
        reportMissingModuleSource: 'warning',
        reportInvalidTypeForm: 'error',
        reportMissingTypeStubs: 'error',
        reportImportCycles: 'none',
        reportUnusedImport: 'error',
        reportUnusedClass: 'error',
        reportUnusedFunction: 'error',
        reportUnusedVariable: 'error',
        reportDuplicateImport: 'error',
        reportWildcardImportFromLibrary: 'error',
        reportAbstractUsage: 'error',
        reportArgumentType: 'error',
        reportAssertTypeFailure: 'error',
        reportAssignmentType: 'error',
        reportAttributeAccessIssue: 'error',
        reportCallIssue: 'error',
        reportInconsistentOverload: 'error',
        reportIndexIssue: 'error',
        reportInvalidTypeArguments: 'error',
        reportNoOverloadImplementation: 'error',
        reportOperatorIssue: 'error',
        reportOptionalSubscript: 'error',
        reportOptionalMemberAccess: 'error',
        reportOptionalCall: 'error',
        reportOptionalIterable: 'error',
        reportOptionalContextManager: 'error',
        reportOptionalOperand: 'error',
        reportRedeclaration: 'error',
        reportReturnType: 'error',
        reportTypedDictNotRequiredAccess: 'error',
        reportUntypedFunctionDecorator: 'error',
        reportUntypedClassDecorator: 'error',
        reportUntypedBaseClass: 'error',
        reportUntypedNamedTuple: 'error',
        reportPrivateUsage: 'error',
        reportTypeCommentUsage: 'error',
        reportPrivateImportUsage: 'error',
        reportConstantRedefinition: 'error',
        reportDeprecated: 'error',
        reportIncompatibleMethodOverride: 'error',
        reportIncompatibleVariableOverride: 'error',
        reportInconsistentConstructor: 'error',
        reportOverlappingOverload: 'error',
        reportPossiblyUnboundVariable: 'error',
        reportMissingSuperCall: 'none',
        reportUninitializedInstanceVariable: 'none',
        reportInvalidStringEscapeSequence: 'error',
        reportUnknownParameterType: 'error',
        reportUnknownArgumentType: 'error',
        reportUnknownLambdaType: 'error',
        reportUnknownVariableType: 'error',
        reportUnknownMemberType: 'error',
        reportMissingParameterType: 'error',
        reportMissingTypeArgument: 'error',
        reportInvalidTypeVarUse: 'error',
        reportCallInDefaultInitializer: 'none',
        reportUnnecessaryIsInstance: 'error',
        reportUnnecessaryCast: 'error',
        reportUnnecessaryComparison: 'error',
        reportUnnecessaryContains: 'error',
        reportAssertAlwaysTrue: 'error',
        reportSelfClsParameterName: 'error',
        reportImplicitStringConcatenation: 'none',
        reportUnboundVariable: 'error',
        reportUnhashable: 'error',
        reportUndefinedVariable: 'error',
        reportInvalidStubStatement: 'error',
        reportIncompleteStub: 'error',
        reportUnsupportedDunderAll: 'error',
        reportUnusedCallResult: 'none',
        reportUnusedCoroutine: 'error',
        reportUnusedExcept: 'error',
        reportUnusedExpression: 'error',
        reportUnnecessaryTypeIgnoreComment: 'none',
        reportMatchNotExhaustive: 'error',
        reportShadowedImports: 'none',
        reportImplicitOverride: 'none'
      };
    }
    exports.ExecutionEnvironment = b;
    (function (e) {
      e.compact = 'compact';
      e.formatted = 'formatted';
    })(v || (exports.SignatureDisplayType = v = {}));
    class A {
      constructor(e) {
        this.include = [];
        this.exclude = [];
        this.ignore = [];
        this.strict = [];
        this.defineConstant = new Map();
        this.autoImportCompletions = true;
        this.indexing = false;
        this.logTypeEvaluationTime = false;
        this.typeEvaluationTimeThreshold = 50;
        this.initializedFromJson = false;
        this.disableTaggedHints = false;
        this.executionEnvironments = [];
        this.effectiveTypeCheckingMode = 'standard';
        this.projectRoot = e;
        this.diagnosticRuleSet = A.getDiagnosticRuleSet();
        this.functionSignatureDisplay = v.formatted;
      }
      static getDiagnosticRuleSet(e) {
        if (e === 'strict') {
          return {
            printUnknownAsAny: false,
            omitTypeArgsIfUnknown: false,
            omitUnannotatedParamType: false,
            omitConditionalConstraint: false,
            pep604Printing: true,
            strictListInference: true,
            strictSetInference: true,
            strictDictionaryInference: true,
            analyzeUnannotatedFunctions: true,
            strictParameterNoneValue: true,
            enableExperimentalFeatures: false,
            enableTypeIgnoreComments: true,
            enableReachabilityAnalysis: true,
            deprecateTypingAliases: false,
            disableBytesTypePromotions: true,
            reportGeneralTypeIssues: 'error',
            reportPropertyTypeMismatch: 'none',
            reportFunctionMemberAccess: 'error',
            reportMissingImports: 'error',
            reportMissingModuleSource: 'warning',
            reportInvalidTypeForm: 'error',
            reportMissingTypeStubs: 'error',
            reportImportCycles: 'none',
            reportUnusedImport: 'error',
            reportUnusedClass: 'error',
            reportUnusedFunction: 'error',
            reportUnusedVariable: 'error',
            reportDuplicateImport: 'error',
            reportWildcardImportFromLibrary: 'error',
            reportAbstractUsage: 'error',
            reportArgumentType: 'error',
            reportAssertTypeFailure: 'error',
            reportAssignmentType: 'error',
            reportAttributeAccessIssue: 'error',
            reportCallIssue: 'error',
            reportInconsistentOverload: 'error',
            reportIndexIssue: 'error',
            reportInvalidTypeArguments: 'error',
            reportNoOverloadImplementation: 'error',
            reportOperatorIssue: 'error',
            reportOptionalSubscript: 'error',
            reportOptionalMemberAccess: 'error',
            reportOptionalCall: 'error',
            reportOptionalIterable: 'error',
            reportOptionalContextManager: 'error',
            reportOptionalOperand: 'error',
            reportRedeclaration: 'error',
            reportReturnType: 'error',
            reportTypedDictNotRequiredAccess: 'error',
            reportUntypedFunctionDecorator: 'error',
            reportUntypedClassDecorator: 'error',
            reportUntypedBaseClass: 'error',
            reportUntypedNamedTuple: 'error',
            reportPrivateUsage: 'error',
            reportTypeCommentUsage: 'error',
            reportPrivateImportUsage: 'error',
            reportConstantRedefinition: 'error',
            reportDeprecated: 'error',
            reportIncompatibleMethodOverride: 'error',
            reportIncompatibleVariableOverride: 'error',
            reportInconsistentConstructor: 'error',
            reportOverlappingOverload: 'error',
            reportPossiblyUnboundVariable: 'error',
            reportMissingSuperCall: 'none',
            reportUninitializedInstanceVariable: 'none',
            reportInvalidStringEscapeSequence: 'error',
            reportUnknownParameterType: 'error',
            reportUnknownArgumentType: 'error',
            reportUnknownLambdaType: 'error',
            reportUnknownVariableType: 'error',
            reportUnknownMemberType: 'error',
            reportMissingParameterType: 'error',
            reportMissingTypeArgument: 'error',
            reportInvalidTypeVarUse: 'error',
            reportCallInDefaultInitializer: 'none',
            reportUnnecessaryIsInstance: 'error',
            reportUnnecessaryCast: 'error',
            reportUnnecessaryComparison: 'error',
            reportUnnecessaryContains: 'error',
            reportAssertAlwaysTrue: 'error',
            reportSelfClsParameterName: 'error',
            reportImplicitStringConcatenation: 'none',
            reportUnboundVariable: 'error',
            reportUnhashable: 'error',
            reportUndefinedVariable: 'error',
            reportInvalidStubStatement: 'error',
            reportIncompleteStub: 'error',
            reportUnsupportedDunderAll: 'error',
            reportUnusedCallResult: 'none',
            reportUnusedCoroutine: 'error',
            reportUnusedExcept: 'error',
            reportUnusedExpression: 'error',
            reportUnnecessaryTypeIgnoreComment: 'none',
            reportMatchNotExhaustive: 'error',
            reportShadowedImports: 'none',
            reportImplicitOverride: 'none'
          };
        } else {
          if (e === 'basic') {
            return {
              printUnknownAsAny: false,
              omitTypeArgsIfUnknown: false,
              omitUnannotatedParamType: true,
              omitConditionalConstraint: false,
              pep604Printing: true,
              strictListInference: false,
              strictSetInference: false,
              strictDictionaryInference: false,
              analyzeUnannotatedFunctions: true,
              strictParameterNoneValue: true,
              enableExperimentalFeatures: false,
              enableTypeIgnoreComments: true,
              enableReachabilityAnalysis: true,
              deprecateTypingAliases: false,
              disableBytesTypePromotions: true,
              reportGeneralTypeIssues: 'error',
              reportPropertyTypeMismatch: 'none',
              reportFunctionMemberAccess: 'none',
              reportMissingImports: 'error',
              reportMissingModuleSource: 'warning',
              reportInvalidTypeForm: 'error',
              reportMissingTypeStubs: 'none',
              reportImportCycles: 'none',
              reportUnusedImport: 'none',
              reportUnusedClass: 'none',
              reportUnusedFunction: 'none',
              reportUnusedVariable: 'none',
              reportDuplicateImport: 'none',
              reportWildcardImportFromLibrary: 'warning',
              reportAbstractUsage: 'error',
              reportArgumentType: 'error',
              reportAssertTypeFailure: 'error',
              reportAssignmentType: 'error',
              reportAttributeAccessIssue: 'error',
              reportCallIssue: 'error',
              reportInconsistentOverload: 'error',
              reportIndexIssue: 'error',
              reportInvalidTypeArguments: 'error',
              reportNoOverloadImplementation: 'error',
              reportOperatorIssue: 'error',
              reportOptionalSubscript: 'error',
              reportOptionalMemberAccess: 'error',
              reportOptionalCall: 'error',
              reportOptionalIterable: 'error',
              reportOptionalContextManager: 'error',
              reportOptionalOperand: 'error',
              reportRedeclaration: 'error',
              reportReturnType: 'error',
              reportTypedDictNotRequiredAccess: 'error',
              reportUntypedFunctionDecorator: 'none',
              reportUntypedClassDecorator: 'none',
              reportUntypedBaseClass: 'none',
              reportUntypedNamedTuple: 'none',
              reportPrivateUsage: 'none',
              reportTypeCommentUsage: 'none',
              reportPrivateImportUsage: 'error',
              reportConstantRedefinition: 'none',
              reportDeprecated: 'none',
              reportIncompatibleMethodOverride: 'none',
              reportIncompatibleVariableOverride: 'none',
              reportInconsistentConstructor: 'none',
              reportOverlappingOverload: 'none',
              reportPossiblyUnboundVariable: 'none',
              reportMissingSuperCall: 'none',
              reportUninitializedInstanceVariable: 'none',
              reportInvalidStringEscapeSequence: 'warning',
              reportUnknownParameterType: 'none',
              reportUnknownArgumentType: 'none',
              reportUnknownLambdaType: 'none',
              reportUnknownVariableType: 'none',
              reportUnknownMemberType: 'none',
              reportMissingParameterType: 'none',
              reportMissingTypeArgument: 'none',
              reportInvalidTypeVarUse: 'warning',
              reportCallInDefaultInitializer: 'none',
              reportUnnecessaryIsInstance: 'none',
              reportUnnecessaryCast: 'none',
              reportUnnecessaryComparison: 'none',
              reportUnnecessaryContains: 'none',
              reportAssertAlwaysTrue: 'warning',
              reportSelfClsParameterName: 'warning',
              reportImplicitStringConcatenation: 'none',
              reportUnboundVariable: 'error',
              reportUnhashable: 'error',
              reportUndefinedVariable: 'error',
              reportInvalidStubStatement: 'none',
              reportIncompleteStub: 'none',
              reportUnsupportedDunderAll: 'warning',
              reportUnusedCallResult: 'none',
              reportUnusedCoroutine: 'error',
              reportUnusedExcept: 'error',
              reportUnusedExpression: 'warning',
              reportUnnecessaryTypeIgnoreComment: 'none',
              reportMatchNotExhaustive: 'none',
              reportShadowedImports: 'none',
              reportImplicitOverride: 'none'
            };
          } else {
            if (e === 'off') {
              return {
                printUnknownAsAny: true,
                omitTypeArgsIfUnknown: true,
                omitUnannotatedParamType: true,
                omitConditionalConstraint: true,
                pep604Printing: true,
                strictListInference: false,
                strictSetInference: false,
                strictDictionaryInference: false,
                analyzeUnannotatedFunctions: true,
                strictParameterNoneValue: true,
                enableExperimentalFeatures: false,
                enableTypeIgnoreComments: true,
                enableReachabilityAnalysis: false,
                deprecateTypingAliases: false,
                disableBytesTypePromotions: true,
                reportGeneralTypeIssues: 'none',
                reportPropertyTypeMismatch: 'none',
                reportFunctionMemberAccess: 'none',
                reportMissingImports: 'warning',
                reportMissingModuleSource: 'warning',
                reportInvalidTypeForm: 'warning',
                reportMissingTypeStubs: 'none',
                reportImportCycles: 'none',
                reportUnusedImport: 'none',
                reportUnusedClass: 'none',
                reportUnusedFunction: 'none',
                reportUnusedVariable: 'none',
                reportDuplicateImport: 'none',
                reportWildcardImportFromLibrary: 'none',
                reportAbstractUsage: 'none',
                reportArgumentType: 'none',
                reportAssertTypeFailure: 'none',
                reportAssignmentType: 'none',
                reportAttributeAccessIssue: 'none',
                reportCallIssue: 'none',
                reportInconsistentOverload: 'none',
                reportIndexIssue: 'none',
                reportInvalidTypeArguments: 'none',
                reportNoOverloadImplementation: 'none',
                reportOperatorIssue: 'none',
                reportOptionalSubscript: 'none',
                reportOptionalMemberAccess: 'none',
                reportOptionalCall: 'none',
                reportOptionalIterable: 'none',
                reportOptionalContextManager: 'none',
                reportOptionalOperand: 'none',
                reportRedeclaration: 'none',
                reportReturnType: 'none',
                reportTypedDictNotRequiredAccess: 'none',
                reportUntypedFunctionDecorator: 'none',
                reportUntypedClassDecorator: 'none',
                reportUntypedBaseClass: 'none',
                reportUntypedNamedTuple: 'none',
                reportPrivateUsage: 'none',
                reportTypeCommentUsage: 'none',
                reportPrivateImportUsage: 'none',
                reportConstantRedefinition: 'none',
                reportDeprecated: 'none',
                reportIncompatibleMethodOverride: 'none',
                reportIncompatibleVariableOverride: 'none',
                reportInconsistentConstructor: 'none',
                reportOverlappingOverload: 'none',
                reportPossiblyUnboundVariable: 'none',
                reportMissingSuperCall: 'none',
                reportUninitializedInstanceVariable: 'none',
                reportInvalidStringEscapeSequence: 'none',
                reportUnknownParameterType: 'none',
                reportUnknownArgumentType: 'none',
                reportUnknownLambdaType: 'none',
                reportUnknownVariableType: 'none',
                reportUnknownMemberType: 'none',
                reportMissingParameterType: 'none',
                reportMissingTypeArgument: 'none',
                reportInvalidTypeVarUse: 'none',
                reportCallInDefaultInitializer: 'none',
                reportUnnecessaryIsInstance: 'none',
                reportUnnecessaryCast: 'none',
                reportUnnecessaryComparison: 'none',
                reportUnnecessaryContains: 'none',
                reportAssertAlwaysTrue: 'none',
                reportSelfClsParameterName: 'none',
                reportImplicitStringConcatenation: 'none',
                reportUnboundVariable: 'none',
                reportUnhashable: 'none',
                reportUndefinedVariable: 'warning',
                reportInvalidStubStatement: 'none',
                reportIncompleteStub: 'none',
                reportUnsupportedDunderAll: 'none',
                reportUnusedCallResult: 'none',
                reportUnusedCoroutine: 'none',
                reportUnusedExcept: 'none',
                reportUnusedExpression: 'none',
                reportUnnecessaryTypeIgnoreComment: 'none',
                reportMatchNotExhaustive: 'none',
                reportShadowedImports: 'none',
                reportImplicitOverride: 'none'
              };
            } else {
              return {
                printUnknownAsAny: false,
                omitTypeArgsIfUnknown: false,
                omitUnannotatedParamType: true,
                omitConditionalConstraint: false,
                pep604Printing: true,
                strictListInference: false,
                strictSetInference: false,
                strictDictionaryInference: false,
                analyzeUnannotatedFunctions: true,
                strictParameterNoneValue: true,
                enableExperimentalFeatures: false,
                enableTypeIgnoreComments: true,
                enableReachabilityAnalysis: true,
                deprecateTypingAliases: false,
                disableBytesTypePromotions: true,
                reportGeneralTypeIssues: 'error',
                reportPropertyTypeMismatch: 'none',
                reportFunctionMemberAccess: 'error',
                reportMissingImports: 'error',
                reportMissingModuleSource: 'warning',
                reportInvalidTypeForm: 'error',
                reportMissingTypeStubs: 'none',
                reportImportCycles: 'none',
                reportUnusedImport: 'none',
                reportUnusedClass: 'none',
                reportUnusedFunction: 'none',
                reportUnusedVariable: 'none',
                reportDuplicateImport: 'none',
                reportWildcardImportFromLibrary: 'warning',
                reportAbstractUsage: 'error',
                reportArgumentType: 'error',
                reportAssertTypeFailure: 'error',
                reportAssignmentType: 'error',
                reportAttributeAccessIssue: 'error',
                reportCallIssue: 'error',
                reportInconsistentOverload: 'error',
                reportIndexIssue: 'error',
                reportInvalidTypeArguments: 'error',
                reportNoOverloadImplementation: 'error',
                reportOperatorIssue: 'error',
                reportOptionalSubscript: 'error',
                reportOptionalMemberAccess: 'error',
                reportOptionalCall: 'error',
                reportOptionalIterable: 'error',
                reportOptionalContextManager: 'error',
                reportOptionalOperand: 'error',
                reportRedeclaration: 'error',
                reportReturnType: 'error',
                reportTypedDictNotRequiredAccess: 'error',
                reportUntypedFunctionDecorator: 'none',
                reportUntypedClassDecorator: 'none',
                reportUntypedBaseClass: 'none',
                reportUntypedNamedTuple: 'none',
                reportPrivateUsage: 'none',
                reportTypeCommentUsage: 'none',
                reportPrivateImportUsage: 'error',
                reportConstantRedefinition: 'none',
                reportDeprecated: 'none',
                reportIncompatibleMethodOverride: 'error',
                reportIncompatibleVariableOverride: 'error',
                reportInconsistentConstructor: 'none',
                reportOverlappingOverload: 'error',
                reportPossiblyUnboundVariable: 'error',
                reportMissingSuperCall: 'none',
                reportUninitializedInstanceVariable: 'none',
                reportInvalidStringEscapeSequence: 'warning',
                reportUnknownParameterType: 'none',
                reportUnknownArgumentType: 'none',
                reportUnknownLambdaType: 'none',
                reportUnknownVariableType: 'none',
                reportUnknownMemberType: 'none',
                reportMissingParameterType: 'none',
                reportMissingTypeArgument: 'none',
                reportInvalidTypeVarUse: 'warning',
                reportCallInDefaultInitializer: 'none',
                reportUnnecessaryIsInstance: 'none',
                reportUnnecessaryCast: 'none',
                reportUnnecessaryComparison: 'none',
                reportUnnecessaryContains: 'none',
                reportAssertAlwaysTrue: 'warning',
                reportSelfClsParameterName: 'warning',
                reportImplicitStringConcatenation: 'none',
                reportUnboundVariable: 'error',
                reportUnhashable: 'error',
                reportUndefinedVariable: 'error',
                reportInvalidStubStatement: 'none',
                reportIncompleteStub: 'none',
                reportUnsupportedDunderAll: 'warning',
                reportUnusedCallResult: 'none',
                reportUnusedCoroutine: 'error',
                reportUnusedExcept: 'error',
                reportUnusedExpression: 'warning',
                reportUnnecessaryTypeIgnoreComment: 'none',
                reportMatchNotExhaustive: 'none',
                reportShadowedImports: 'none',
                reportImplicitOverride: 'none'
              };
            }
          }
        }
      }
      getDefaultExecEnvironment() {
        return new b(this._getEnvironmentName(), this.projectRoot, this.diagnosticRuleSet, this.defaultPythonVersion, this.defaultPythonPlatform, this.defaultExtraPaths, this.skipNativeLibraries);
      }
      findExecEnvironment(e) {
        var t;
        if ((t = this.executionEnvironments.find(t => {
          const n = h.Uri.is(t.root) ? t.root : this.projectRoot.resolvePaths(t.root || '');
          return e.startsWith(n);
        })) !== null && t !== undefined) {
          return t;
        } else {
          return this.getDefaultExecEnvironment();
        }
      }
      getExecutionEnvironments() {
        if (this.executionEnvironments.length > 0) {
          return this.executionEnvironments;
        } else {
          return [this.getDefaultExecEnvironment()];
        }
      }
      initializeTypeCheckingMode(e, t) {
        this.diagnosticRuleSet = A.getDiagnosticRuleSet(e);
        this.effectiveTypeCheckingMode = e;
        if (t) {
          this.applyDiagnosticOverrides(t);
        }
      }
      initializeFromJson(e, t, n, a) {
        var r;
        this.initializedFromJson = true;
        const s = (r = n.tryGet(g.ServiceKeys.console)) !== null && r !== undefined ? r : new c.NullConsole();
        if (e.include !== undefined) {
          if (Array.isArray(e.include)) {
            this.include = [];
            e.include.forEach((e, n) => {
              if (typeof e != 'string') {
                s.error(`Index ${n} of "include" array should be a string.`);
              } else {
                if (i.isAbsolute(e)) {
                  s.error(`Ignoring path "${e}" in "include" array because it is not relative.`);
                } else {
                  this.include.push(f.getFileSpec(t, e));
                }
              }
            });
          } else {
            s.error('Config "include" entry must contain an array.');
          }
        }
        if (e.exclude !== undefined) {
          if (Array.isArray(e.exclude)) {
            this.exclude = [];
            e.exclude.forEach((e, n) => {
              if (typeof e != 'string') {
                s.error(`Index ${n} of "exclude" array should be a string.`);
              } else {
                if (i.isAbsolute(e)) {
                  s.error(`Ignoring path "${e}" in "exclude" array because it is not relative.`);
                } else {
                  this.exclude.push(f.getFileSpec(t, e));
                }
              }
            });
          } else {
            s.error('Config "exclude" entry must contain an array.');
          }
        }
        if (e.ignore !== undefined) {
          if (Array.isArray(e.ignore)) {
            this.ignore = [];
            e.ignore.forEach((e, n) => {
              if (typeof e != 'string') {
                s.error(`Index ${n} of "ignore" array should be a string.`);
              } else {
                this.ignore.push(f.getFileSpec(t, e));
              }
            });
          } else {
            s.error('Config "ignore" entry must contain an array.');
          }
        }
        if (e.strict !== undefined) {
          if (Array.isArray(e.strict)) {
            this.strict = [];
            e.strict.forEach((e, n) => {
              if (typeof e != 'string') {
                s.error(`Index ${n} of "strict" array should be a string.`);
              } else {
                if (i.isAbsolute(e)) {
                  s.error(`Ignoring path "${e}" in "strict" array because it is not relative.`);
                } else {
                  this.strict.push(f.getFileSpec(t, e));
                }
              }
            });
          } else {
            s.error('Config "strict" entry must contain an array.');
          }
        }
        if (e.typeCheckingMode !== undefined) {
          if (e.typeCheckingMode === 'off' || e.typeCheckingMode === 'basic' || e.typeCheckingMode === 'standard' || e.typeCheckingMode === 'strict') {
            this.initializeTypeCheckingMode(e.typeCheckingMode);
          } else {
            s.error('Config "typeCheckingMode" entry must contain "off", "basic", "standard", or "strict".');
          }
        }
        if (e.useLibraryCodeForTypes !== undefined) {
          if (typeof e.useLibraryCodeForTypes == 'boolean') {
            this.useLibraryCodeForTypes = e.useLibraryCodeForTypes;
          } else {
            s.error('Config "useLibraryCodeForTypes" entry must be true or false.');
          }
        }
        const o = {
          ...this.diagnosticRuleSet
        };
        _(true).forEach(t => {
          o[t] = this._convertBoolean(e[t], t, o[t]);
        });
        C().forEach(t => {
          o[t] = this._convertDiagnosticLevel(e[t], t, o[t]);
        });
        this.diagnosticRuleSet = {
          ...o
        };
        if (e.venvPath !== undefined) {
          if (typeof e.venvPath != 'string') {
            s.error('Config "venvPath" field must contain a string.');
          } else {
            this.venvPath = t.resolvePaths(e.venvPath);
          }
        }
        if (e.venv !== undefined) {
          if (typeof e.venv != 'string') {
            s.error('Config "venv" field must contain a string.');
          } else {
            this.venv = e.venv;
          }
        }
        const l = [];
        if (e.extraPaths !== undefined) {
          if (Array.isArray(e.extraPaths)) {
            e.extraPaths.forEach((e, n) => {
              if (typeof e != 'string') {
                s.error(`Config "extraPaths" field ${n} must be a string.`);
              } else {
                l.push(t.resolvePaths(e));
              }
            });
            this.defaultExtraPaths = [...l];
          } else {
            s.error('Config "extraPaths" field must contain an array.');
          }
        }
        if (e.pythonVersion !== undefined) {
          if (typeof e.pythonVersion == 'string') {
            const t = y.PythonVersion.fromString(e.pythonVersion);
            if (t) {
              this.defaultPythonVersion = t;
            } else {
              s.error('Config "pythonVersion" field contains unsupported version.');
            }
          } else {
            s.error('Config "pythonVersion" field must contain a string.');
          }
        }
        if (e.pythonPlatform !== undefined) {
          if (typeof e.pythonPlatform != 'string') {
            s.error('Config "pythonPlatform" field must contain a string.');
          } else {
            this.defaultPythonPlatform = e.pythonPlatform;
          }
        }
        if (e.skipNativeLibraries) {
          if (typeof e.skipNativeLibraries == 'boolean') {
            this.skipNativeLibraries = e.skipNativeLibraries;
          } else {
            s.error('Config "skipNativeLibraries" field must contain a boolean.');
          }
        }
        if (e.typeshedPath !== undefined) {
          if (typeof e.typeshedPath != 'string') {
            s.error('Config "typeshedPath" field must contain a string.');
          } else {
            this.typeshedPath = e.typeshedPath ? t.resolvePaths(e.typeshedPath) : undefined;
          }
        }
        if (e.typingsPath !== undefined) {
          if (typeof e.typingsPath != 'string') {
            s.error('Config "typingsPath" field must contain a string.');
          } else {
            s.error('Config "typingsPath" is now deprecated. Please, use stubPath instead.');
            this.stubPath = t.resolvePaths(e.typingsPath);
          }
        }
        if (e.stubPath !== undefined) {
          if (typeof e.stubPath != 'string') {
            s.error('Config "stubPath" field must contain a string.');
          } else {
            this.stubPath = t.resolvePaths(e.stubPath);
          }
        }
        if (e.verboseOutput !== undefined) {
          if (typeof e.verboseOutput != 'boolean') {
            s.error('Config "verboseOutput" field must be true or false.');
          } else {
            this.verboseOutput = e.verboseOutput;
          }
        }
        if (e.defineConstant !== undefined) {
          if (typeof e.defineConstant != 'object' || Array.isArray(e.defineConstant)) {
            s.error('Config "defineConstant" field must contain a map indexed by constant names.');
          } else {
            Object.getOwnPropertyNames(e.defineConstant).forEach(t => {
              const n = e.defineConstant[t];
              const a = typeof n;
              if (a !== 'boolean' && a !== 'string') {
                s.error(`Defined constant "${t}" must be associated with a boolean or string value.`);
              } else {
                this.defineConstant.set(t, n);
              }
            });
          }
        }
        if (e.useLibraryCodeForTypes !== undefined) {
          if (typeof e.useLibraryCodeForTypes != 'boolean') {
            s.error('Config "useLibraryCodeForTypes" field must be true or false.');
          } else {
            this.useLibraryCodeForTypes = e.useLibraryCodeForTypes;
          }
        }
        if (e.autoImportCompletions !== undefined) {
          if (typeof e.autoImportCompletions != 'boolean') {
            s.error('Config "autoImportCompletions" field must be true or false.');
          } else {
            this.autoImportCompletions = e.autoImportCompletions;
          }
        }
        if (e.indexing !== undefined) {
          if (typeof e.indexing != 'boolean') {
            s.error('Config "indexing" field must be true or false.');
          } else {
            this.indexing = e.indexing;
          }
        }
        if (e.logTypeEvaluationTime !== undefined) {
          if (typeof e.logTypeEvaluationTime != 'boolean') {
            s.error('Config "logTypeEvaluationTime" field must be true or false.');
          } else {
            this.logTypeEvaluationTime = e.logTypeEvaluationTime;
          }
        }
        if (e.typeEvaluationTimeThreshold !== undefined) {
          if (typeof e.typeEvaluationTimeThreshold != 'number') {
            s.error('Config "typeEvaluationTimeThreshold" field must be a number.');
          } else {
            this.typeEvaluationTimeThreshold = e.typeEvaluationTimeThreshold;
          }
        }
        if (e.functionSignatureDisplay !== undefined) {
          if (typeof e.functionSignatureDisplay != 'string') {
            s.error('Config "functionSignatureDisplay" field must be true or false.');
          } else {
            if (e.functionSignatureDisplay === 'compact' || e.functionSignatureDisplay === 'formatted') {
              this.functionSignatureDisplay = e.functionSignatureDisplay;
            }
          }
        }
      }
      static resolveExtends(e, t) {
        if (e.extends !== undefined) {
          if (typeof e.extends == 'string') {
            return t.resolvePaths(e.extends);
          }
          console.error('Config "extends" field must contain a string.');
        }
      }
      ensureDefaultPythonPlatform(e, t) {
        if (this.defaultPythonPlatform === undefined) {
          this.defaultPythonPlatform = e.getPythonPlatform();
          if (this.defaultPythonPlatform !== undefined) {
            t.log(`Assuming Python platform ${this.defaultPythonPlatform}`);
          }
        }
      }
      ensureDefaultPythonVersion(e, t) {
        if (this.defaultPythonVersion !== undefined) {
          return;
        }
        const n = [];
        this.defaultPythonVersion = e.getPythonVersion(this.pythonPath, n);
        if (this.defaultPythonVersion !== undefined) {
          t.info(`Assuming Python version ${y.PythonVersion.toString(this.defaultPythonVersion)}`);
        }
        for (const e of n) {
          t.info(e);
        }
      }
      ensureDefaultExtraPaths(e, t, n) {
        const a = [];
        if (t) {
          const t = this.projectRoot.resolvePaths(l.src);
          if (e.existsSync(t) && !e.existsSync(t.resolvePaths('__init__.py'))) {
            a.push(e.realCasePath(t));
          }
        }
        if (n && n.length > 0) {
          for (const t of n) {
            const n = this.projectRoot.resolvePaths(t);
            a.push(e.realCasePath(n));
            if (f.isDirectory(e, n)) {
              p.appendArray(a, o.getPathsFromPthFiles(e, n));
            }
          }
        }
        if (a.length > 0) {
          this.defaultExtraPaths = a;
        }
      }
      applyDiagnosticOverrides(e) {
        if (e) {
          for (const t of C()) {
            const n = e[t];
            if (n !== undefined && !u.isBoolean(n) && d.getDiagnosticSeverityOverrides().includes(n)) {
              this.diagnosticRuleSet[t] = n;
            }
          }
          for (const t of _(true)) {
            const n = e[t];
            if (n !== undefined && u.isBoolean(n)) {
              this.diagnosticRuleSet[t] = n;
            }
          }
        }
      }
      setupExecutionEnvironments(e, t, n) {
        if (e.executionEnvironments !== undefined) {
          if (Array.isArray(e.executionEnvironments)) {
            this.executionEnvironments = [];
            e.executionEnvironments.forEach((e, a) => {
              const r = this._initExecutionEnvironmentFromJson(e, t, a, n, this.diagnosticRuleSet, this.defaultPythonVersion, this.defaultPythonPlatform, this.defaultExtraPaths || []);
              if (r) {
                this.executionEnvironments.push(r);
              }
            });
          } else {
            n.error('Config "executionEnvironments" field must contain an array.');
          }
        }
      }
      _getEnvironmentName() {
        var e;
        return this.pythonEnvironmentName || ((e = this.pythonPath) === null || e === undefined ? undefined : e.toString()) || 'python';
      }
      _convertBoolean(e, t, n) {
        if (e === undefined) {
          return n;
        } else {
          if (typeof e == 'boolean') {
            return !!e;
          } else {
            console.log(`Config "${t}" entry must be true or false.`);
            return n;
          }
        }
      }
      _convertDiagnosticLevel(e, t, n) {
        if (e === undefined) {
          return n;
        } else {
          if (typeof e == 'boolean') {
            if (e) {
              return 'error';
            } else {
              return 'none';
            }
          } else {
            if (typeof e != 'string' || e !== 'error' && e !== 'warning' && e !== 'information' && e !== 'none') {
              console.log(`Config "${t}" entry must be true, false, "error", "warning", "information" or "none".`);
              return n;
            } else {
              return e;
            }
          }
        }
      }
      _initExecutionEnvironmentFromJson(e, t, n, a, r, s, i, o) {
        try {
          const l = new b(this._getEnvironmentName(), t, r, s, i, o);
          if (e.root && typeof e.root == 'string') {
            l.root = t.resolvePaths(e.root);
          } else {
            a.error(`Config executionEnvironments index ${n}: missing root value.`);
          }
          if (e.extraPaths) {
            if (Array.isArray(e.extraPaths)) {
              e.extraPaths.forEach((e, r) => {
                if (typeof e != 'string') {
                  a.error(`Config executionEnvironments index ${n}: extraPaths field ${r} must be a string.`);
                } else {
                  l.extraPaths.push(t.resolvePaths(e));
                }
              });
            } else {
              a.error(`Config executionEnvironments index ${n}: extraPaths field must contain an array.`);
            }
          }
          if (e.pythonVersion) {
            if (typeof e.pythonVersion == 'string') {
              const t = y.PythonVersion.fromString(e.pythonVersion);
              if (t) {
                l.pythonVersion = t;
              } else {
                a.warn(`Config executionEnvironments index ${n} contains unsupported pythonVersion.`);
              }
            } else {
              a.error(`Config executionEnvironments index ${n} pythonVersion must be a string.`);
            }
          }
          if (e.pythonPlatform) {
            if (typeof e.pythonPlatform == 'string') {
              l.pythonPlatform = e.pythonPlatform;
            } else {
              a.error(`Config executionEnvironments index ${n} pythonPlatform must be a string.`);
            }
          }
          if (e.name) {
            if (typeof e.name == 'string') {
              l.name = e.name;
            } else {
              a.error(`Config executionEnvironments index ${n} name must be a string.`);
            }
          }
          _(true).forEach(t => {
            l.diagnosticRuleSet[t] = this._convertBoolean(e[t], t, l.diagnosticRuleSet[t]);
          });
          C().forEach(t => {
            l.diagnosticRuleSet[t] = this._convertDiagnosticLevel(e[t], t, l.diagnosticRuleSet[t]);
          });
          return l;
        } catch {
          a.error(`Config executionEnvironments index ${n} is not accessible.`);
        }
      }
    }
    exports.ConfigOptions = A;
  },
  25075: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ConsoleWithLogLevel = exports.Chainable = exports.StderrConsole = exports.StandardConsole = exports.NullConsole = exports.ConsoleInterface = exports.LogLevel = undefined;
    exports.getLevelNumber = c;
    exports.log = m;
    exports.convertLogLevel = function (e) {
      if (!e) {
        return l.Info;
      }
      switch (e.toLowerCase()) {
        case 'error':
          return l.Error;
        case 'warning':
          return l.Warn;
        case 'information':
        default:
          return l.Info;
        case 'trace':
          return l.Log;
      }
    };
    const i = __importStar(require(48281));
    const o = require(58147);
    var l;
    var p;
    (function (e) {
      e.Error = 'error';
      e.Warn = 'warn';
      e.Info = 'info';
      e.Log = 'log';
    })(l || (exports.LogLevel = l = {}));
    (function (e) {
      function t(e) {
        return e.error !== undefined && e.warn !== undefined && e.info !== undefined && e.log !== undefined;
      }
      e.is = t;
      e.hasLevel = function (e) {
        return t(e) && 'level' in e;
      };
    })(p || (exports.ConsoleInterface = p = {}));
    const d = new Map([[l.Error, 0], [l.Warn, 1], [l.Info, 2], [l.Log, 3]]);
    function c(e) {
      var t;
      if ((t = d.get(e)) !== null && t !== undefined) {
        return t;
      } else {
        return 3;
      }
    }
    exports.NullConsole = class {
      constructor() {
        this.logCount = 0;
        this.infoCount = 0;
        this.warnCount = 0;
        this.errorCount = 0;
      }
      log(e) {
        this.logCount++;
      }
      info(e) {
        this.infoCount++;
      }
      warn(e) {
        this.warnCount++;
      }
      error(e) {
        this.errorCount++;
      }
    };
    exports.StandardConsole = class {
      constructor(e = l.Log) {
        this._maxLevel = e;
      }
      get level() {
        return this._maxLevel;
      }
      log(e) {
        if (c(this._maxLevel) >= c(l.Log)) {
          console.log(e);
        }
      }
      info(e) {
        if (c(this._maxLevel) >= c(l.Info)) {
          console.info(e);
        }
      }
      warn(e) {
        if (c(this._maxLevel) >= c(l.Warn)) {
          console.warn(e);
        }
      }
      error(e) {
        if (c(this._maxLevel) >= c(l.Error)) {
          console.error(e);
        }
      }
    };
    var u;
    exports.StderrConsole = class {
      constructor(e = l.Log) {
        this._maxLevel = e;
      }
      get level() {
        return this._maxLevel;
      }
      log(e) {
        if (c(this._maxLevel) >= c(l.Log)) {
          console.error(e);
        }
      }
      info(e) {
        if (c(this._maxLevel) >= c(l.Info)) {
          console.error(e);
        }
      }
      warn(e) {
        if (c(this._maxLevel) >= c(l.Warn)) {
          console.error(e);
        }
      }
      error(e) {
        if (c(this._maxLevel) >= c(l.Error)) {
          console.error(e);
        }
      }
    };
    (function (e) {
      e.is = function (e) {
        return e && e.addChain && e.removeChain;
      };
    })(u || (exports.Chainable = u = {}));
    function m(e, t, n) {
      switch (t) {
        case l.Log:
          e.log(n);
          break;
        case l.Info:
          e.info(n);
          break;
        case l.Warn:
          e.warn(n);
          break;
        case l.Error:
          e.error(n);
          break;
        default:
          i.fail(`${t} is not expected`);
      }
    }
    exports.ConsoleWithLogLevel = class {
      constructor(e, t = '') {
        this._console = e;
        this._name = t;
        this._chains = [];
        this._maxLevel = 2;
        this._disposed = false;
      }
      get level() {
        switch (this._maxLevel) {
          case 0:
            return l.Error;
          case 1:
            return l.Warn;
          case 2:
            return l.Info;
        }
        return l.Log;
      }
      set level(e) {
        let t = c(e);
        if (t === undefined) {
          t = c(l.Info);
        }
        this._maxLevel = t;
      }
      dispose() {
        this._disposed = true;
      }
      error(e) {
        this._log(l.Error, `${this._prefix}${e}`);
      }
      warn(e) {
        this._log(l.Warn, `${this._prefix}${e}`);
      }
      info(e) {
        this._log(l.Info, `${this._prefix}${e}`);
      }
      log(e) {
        this._log(l.Log, `${this._prefix}${e}`);
      }
      addChain(e) {
        o.addIfUnique(this._chains, e);
      }
      removeChain(e) {
        o.removeArrayElements(this._chains, t => t === e);
      }
      get _prefix() {
        if (this._name) {
          return `(${this._name}) `;
        } else {
          return '';
        }
      }
      _log(e, t) {
        if (!this._disposed) {
          this._processChains(e, t);
          if (!(this._getNumericalLevel(e) > this._maxLevel)) {
            m(this._console, e, t);
          }
        }
      }
      _getNumericalLevel(e) {
        const t = c(e);
        i.assert(t !== undefined, 'Logger: unknown log level.');
        if (t !== undefined) {
          return t;
        } else {
          return 2;
        }
      }
      _processChains(e, t) {
        this._chains.forEach(n => m(n, e, t));
      }
    };
  },
  34455: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Disposable = undefined;
    exports.returnFalse = function () {
      return false;
    };
    exports.returnTrue = function () {
      return true;
    };
    exports.returnUndefined = function () {
      return;
    };
    exports.identity = function (e) {
      return e;
    };
    exports.toLowerCase = function (e) {
      return e.toLowerCase();
    };
    exports.equateValues = function (e, t) {
      return e === t;
    };
    exports.compareComparableValues = r;
    exports.compareValues = function (e, t) {
      return r(e, t);
    };
    exports.isArray = function (e) {
      if (Array.isArray) {
        return Array.isArray(e);
      } else {
        return e instanceof Array;
      }
    };
    exports.isString = function (e) {
      return typeof e == 'string';
    };
    exports.isNumber = function (e) {
      return typeof e == 'number';
    };
    exports.isBoolean = function (e) {
      return typeof e == 'boolean';
    };
    exports.hasProperty = function (e, t) {
      return s.call(e, t);
    };
    exports.toBoolean = function (e) {
      if ((e == null ? undefined : e.trim().toUpperCase()) === 'TRUE') {
        return true;
      }
      return false;
    };
    exports.test_setDebugMode = function (e) {
      const t = i;
      i = e;
      return t;
    };
    exports.isDebugMode = function () {
      if (i === undefined) {
        const e = process.execArgv.join();
        i = e.includes('inspect') || e.includes('debug');
      }
      return i;
    };
    exports.isThenable = function (e) {
      return typeof (e == null ? undefined : e.then) == 'function';
    };
    exports.isDefined = function (e) {
      return e !== undefined;
    };
    exports.getEnumNames = function (e) {
      const t = [];
      for (const n in e) {
        if (isNaN(Number(n))) {
          t.push(n);
        }
      }
      return t;
    };
    exports.containsOnlyWhitespace = function (e, t) {
      if (t) {
        e = e.substring(t.start, a.TextRange.getEnd(t));
      }
      return /^\s*$/.test(e);
    };
    const a = require(88754);
    function r(e, t) {
      if (e === t) {
        return 0;
      } else {
        if (e === undefined) {
          return -1;
        } else {
          if (t === undefined) {
            return 1;
          } else {
            if (e < t) {
              return -1;
            } else {
              return 1;
            }
          }
        }
      }
    }
    const s = Object.prototype.hasOwnProperty;
    let i;
    var o;
    (function (e) {
      e.is = function (e) {
        return e && typeof e.dispose == 'function';
      };
    })(o || (exports.Disposable = o = {}));
  },
  77313: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.randomBytesHex = function (e) {
      if (r) {
        return r.randomBytes(e).toString('hex');
      }
      if (crypto) {
        const n = crypto.getRandomValues(new Uint8Array(e));
        t = n;
        return [...t].map(e => e.toString(16).padStart(2, '0')).join('');
      }
      var t;
      a.fail('crypto library not found');
    };
    const a = require(48281);
    let r;
    try {
      r = require(76982);
      if (!(r == null ? undefined : r.randomBytes)) {
        r = undefined;
      }
    } catch {}
  },
  48281: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.assert = function e(t, n, a, r) {
      if (!t) {
        if (a) {
          n += `\r
Verbose Debug Information: ${typeof a == 'string' ? a : a()}`;
        }
        s(n ? `False expression: ${n}` : 'False expression.', r || e);
      }
    };
    exports.fail = s;
    exports.assertDefined = i;
    exports.assertEachDefined = function e(t, n, a) {
      for (const r of t) {
        i(r, n, a || e);
      }
    };
    exports.assertNever = function e(t, n = 'Illegal value:', a) {
      let r = '';
      try {
        r = JSON.stringify(t);
      } catch {}
      s(`${n} ${r}`, a || e);
    };
    exports.getFunctionName = function (e) {
      if (typeof e != 'function') {
        return '';
      }
      if (r.hasProperty(e, 'name')) {
        return e.name;
      }
      {
        const t = Function.prototype.toString.call(e);
        const n = /^function\s+([\w$]+)\s*\(/.exec(t);
        if (n) {
          return n[1];
        } else {
          return '';
        }
      }
    };
    exports.formatEnum = function (e = 0, t, n) {
      const s = function (e) {
        const t = [];
        for (const n of Object.keys(e)) {
          const a = e[n];
          if (typeof a == 'number') {
            t.push([a, n]);
          }
        }
        return a.stableSort(t, (e, t) => r.compareValues(e[0], t[0]));
      }(t);
      if (e === 0) {
        if (s.length > 0 && s[0][0] === 0) {
          return s[0][1];
        } else {
          return '0';
        }
      }
      if (n) {
        let t = '';
        let n = e;
        for (const [a, r] of s) {
          if (a > e) {
            break;
          }
          if (a !== 0 && a & e) {
            t = `${t}${t ? '|' : ''}${r}`;
            n &= ~a;
          }
        }
        if (n === 0) {
          return t;
        }
      } else {
        for (const [t, n] of s) {
          if (t === e) {
            return n;
          }
        }
      }
      return e.toString();
    };
    exports.getErrorString = function (e) {
      return (e.stack ? e.stack.toString() : undefined) || (typeof e.message == 'string' ? e.message : undefined) || JSON.stringify(e);
    };
    exports.getSerializableError = function (e) {
      if (!e) {
        return;
      }
      if (JSON.stringify(e).length > 2) {
        return e;
      }
      const t = e.name && r.isString(e.name) ? e.name : 'noname';
      const n = e.message && r.isString(e.message) ? e.message : 'nomessage';
      const a = e.stack && r.isString(e.stack) ? e.stack : undefined;
      return {
        name: t,
        message: n,
        stack: a
      };
    };
    const a = require(58147);
    const r = require(34455);
    function s(e, t) {
      const n = new Error(e ? `Debug Failure. ${e}` : 'Debug Failure.');
      if (Error.captureStackTrace) {
        Error.captureStackTrace(n, t || s);
      }
      throw n;
    }
    function i(e, t, n) {
      if (e == null) {
        s(t, n || i);
      }
    }
  },
  51507: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createDeferred = a;
    exports.createDeferredFrom = function (...e) {
      const t = a();
      Promise.all(e).then(t.resolve.bind(t)).catch(t.reject.bind(t));
      return t;
    };
    exports.createDeferredFromPromise = function (e) {
      const t = a();
      e.then(t.resolve.bind(t)).catch(t.reject.bind(t));
      return t;
    };
    class n {
      constructor(e = null) {
        this._scope = e;
        this._resolved = false;
        this._rejected = false;
        this._promise = new Promise((e, t) => {
          this._resolve = e;
          this._reject = t;
        });
      }
      get promise() {
        return this._promise;
      }
      get resolved() {
        return this._resolved;
      }
      get rejected() {
        return this._rejected;
      }
      get completed() {
        return this._rejected || this._resolved;
      }
      resolve(e) {
        this._resolve.apply(this._scope ? this._scope : this, arguments);
        this._resolved = true;
      }
      reject(e) {
        this._reject.apply(this._scope ? this._scope : this, arguments);
        this._rejected = true;
      }
    }
    function a(e = null) {
      return new n(e);
    }
  },
  11479: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DiagnosticAddendum = exports.Diagnostic = exports.DiagnosticRelatedInfo = exports.TaskListPriority = exports.defaultMaxDiagnosticLineCount = exports.defaultMaxDiagnosticDepth = undefined;
    exports.convertLevelToCategory = function (e) {
      switch (e) {
        case 'error':
          return 0;
        case 'warning':
          return 1;
        case 'information':
          return 2;
        default:
          throw new Error(`${e} is not expected`);
      }
    };
    exports.compareDiagnostics = function (e, t) {
      if (e.range.start.line < t.range.start.line) {
        return -1;
      }
      if (e.range.start.line > t.range.start.line) {
        return 1;
      }
      if (e.range.start.character < t.range.start.character) {
        return -1;
      }
      if (e.range.start.character > t.range.start.character) {
        return 1;
      }
      return 0;
    };
    const a = require(58147);
    const r = require(27113);
    exports.defaultMaxDiagnosticDepth = 5;
    exports.defaultMaxDiagnosticLineCount = 8;
    var s;
    var i;
    (function (e) {
      e.High = 'High';
      e.Normal = 'Normal';
      e.Low = 'Low';
    })(s || (exports.TaskListPriority = s = {}));
    (function (e) {
      e.toJsonObj = function (e) {
        return {
          message: e.message,
          uri: e.uri.toJsonObj(),
          range: e.range,
          priority: e.priority
        };
      };
      e.fromJsonObj = function (e) {
        return {
          message: e.message,
          uri: r.Uri.fromJsonObj(e.uri),
          range: e.range,
          priority: e.priority
        };
      };
    })(i || (exports.DiagnosticRelatedInfo = i = {}));
    class o {
      constructor(e, t, n, a = s.Normal) {
        this.category = e;
        this.message = t;
        this.range = n;
        this.priority = a;
        this._relatedInfo = [];
      }
      toJsonObj() {
        return {
          category: this.category,
          message: this.message,
          range: this.range,
          priority: this.priority,
          actions: this._actions,
          rule: this._rule,
          relatedInfo: this._relatedInfo.map(e => i.toJsonObj(e))
        };
      }
      static fromJsonObj(e) {
        const t = new o(e.category, e.message, e.range, e.priority);
        t._actions = e.actions;
        t._rule = e.rule;
        t._relatedInfo = e.relatedInfo.map(e => i.fromJsonObj(e));
        return t;
      }
      addAction(e) {
        if (this._actions === undefined) {
          this._actions = [e];
        } else {
          this._actions.push(e);
        }
      }
      getActions() {
        return this._actions;
      }
      setRule(e) {
        this._rule = e;
      }
      getRule() {
        return this._rule;
      }
      addRelatedInfo(e, t, n, a = s.Normal) {
        this._relatedInfo.push({
          uri: t,
          message: e,
          range: n,
          priority: a
        });
      }
      getRelatedInfo() {
        return this._relatedInfo;
      }
    }
    exports.Diagnostic = o;
    class l {
      constructor() {
        this._messages = [];
        this._childAddenda = [];
      }
      addMessage(e) {
        this._messages.push(e);
      }
      addMessageMultiline(e) {
        e.split('\n').forEach(e => {
          this._messages.push(e);
        });
      }
      addTextRange(e) {
        this._range = e;
      }
      createAddendum() {
        var e;
        const t = new l();
        t._nestLevel = ((e = this._nestLevel) !== null && e !== undefined ? e : 0) + 1;
        this.addAddendum(t);
        return t;
      }
      getString(e = exports.defaultMaxDiagnosticDepth, n = exports.defaultMaxDiagnosticLineCount) {
        let a = this._getLinesRecursive(e, n);
        if (a.length > n) {
          a = a.slice(0, n);
          a.push('  ...');
        }
        const r = a.join('\n');
        if (r.length > 0) {
          return `
${r}`;
        } else {
          return '';
        }
      }
      isEmpty() {
        return this._getMessageCount() === 0;
      }
      addAddendum(e) {
        this._childAddenda.push(e);
      }
      getChildren() {
        return this._childAddenda;
      }
      getMessages() {
        return this._messages;
      }
      getNestLevel() {
        var e;
        if ((e = this._nestLevel) !== null && e !== undefined) {
          return e;
        } else {
          return 0;
        }
      }
      getEffectiveTextRange() {
        const e = this._getTextRangeRecursive();
        if ((e == null ? undefined : e.length) !== 0) {
          return e;
        }
      }
      _getTextRangeRecursive(e = 0) {
        if (e > 64) {
          return;
        }
        e++;
        const t = this._childAddenda.map(t => t._getTextRangeRecursive(e)).filter(e => !!e);
        if (t.length > 1) {
          return {
            start: 0,
            length: 0
          };
        } else {
          if (t.length === 1) {
            return t[0];
          } else {
            if (this._range) {
              return this._range;
            } else {
              return undefined;
            }
          }
        }
      }
      _getMessageCount(e = 0) {
        if (e > 64) {
          return 0;
        }
        let t = this._messages.length;
        for (const n of this._childAddenda) {
          t += n._getMessageCount(e + 1);
        }
        return t;
      }
      _getLinesRecursive(e, t, n = 0) {
        if (e <= 0 || n > 64) {
          return [];
        }
        let r = [];
        for (const s of this._childAddenda) {
          const i = this._messages.length > 0 ? e - 1 : e;
          a.appendArray(r, s._getLinesRecursive(i, t, n + 1));
          if (r.length >= t) {
            r = r.slice(0, t);
            break;
          }
        }
        const s = this._messages.length > 0 ? '' : '';
        return this._messages.concat(r).map(e => s + e);
      }
    }
    exports.DiagnosticAddendum = l;
  },
  65880: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DiagnosticRule = undefined;
    (function (e) {
      e.strictListInference = 'strictListInference';
      e.strictSetInference = 'strictSetInference';
      e.strictDictionaryInference = 'strictDictionaryInference';
      e.analyzeUnannotatedFunctions = 'analyzeUnannotatedFunctions';
      e.strictParameterNoneValue = 'strictParameterNoneValue';
      e.enableExperimentalFeatures = 'enableExperimentalFeatures';
      e.enableTypeIgnoreComments = 'enableTypeIgnoreComments';
      e.enableReachabilityAnalysis = 'enableReachabilityAnalysis';
      e.deprecateTypingAliases = 'deprecateTypingAliases';
      e.disableBytesTypePromotions = 'disableBytesTypePromotions';
      e.reportGeneralTypeIssues = 'reportGeneralTypeIssues';
      e.reportPropertyTypeMismatch = 'reportPropertyTypeMismatch';
      e.reportFunctionMemberAccess = 'reportFunctionMemberAccess';
      e.reportMissingImports = 'reportMissingImports';
      e.reportMissingModuleSource = 'reportMissingModuleSource';
      e.reportInvalidTypeForm = 'reportInvalidTypeForm';
      e.reportMissingTypeStubs = 'reportMissingTypeStubs';
      e.reportImportCycles = 'reportImportCycles';
      e.reportUnusedImport = 'reportUnusedImport';
      e.reportUnusedClass = 'reportUnusedClass';
      e.reportUnusedFunction = 'reportUnusedFunction';
      e.reportUnusedVariable = 'reportUnusedVariable';
      e.reportDuplicateImport = 'reportDuplicateImport';
      e.reportWildcardImportFromLibrary = 'reportWildcardImportFromLibrary';
      e.reportAbstractUsage = 'reportAbstractUsage';
      e.reportArgumentType = 'reportArgumentType';
      e.reportAssertTypeFailure = 'reportAssertTypeFailure';
      e.reportAssignmentType = 'reportAssignmentType';
      e.reportAttributeAccessIssue = 'reportAttributeAccessIssue';
      e.reportCallIssue = 'reportCallIssue';
      e.reportInconsistentOverload = 'reportInconsistentOverload';
      e.reportIndexIssue = 'reportIndexIssue';
      e.reportInvalidTypeArguments = 'reportInvalidTypeArguments';
      e.reportNoOverloadImplementation = 'reportNoOverloadImplementation';
      e.reportOperatorIssue = 'reportOperatorIssue';
      e.reportOptionalSubscript = 'reportOptionalSubscript';
      e.reportOptionalMemberAccess = 'reportOptionalMemberAccess';
      e.reportOptionalCall = 'reportOptionalCall';
      e.reportOptionalIterable = 'reportOptionalIterable';
      e.reportOptionalContextManager = 'reportOptionalContextManager';
      e.reportOptionalOperand = 'reportOptionalOperand';
      e.reportRedeclaration = 'reportRedeclaration';
      e.reportReturnType = 'reportReturnType';
      e.reportTypedDictNotRequiredAccess = 'reportTypedDictNotRequiredAccess';
      e.reportUntypedFunctionDecorator = 'reportUntypedFunctionDecorator';
      e.reportUntypedClassDecorator = 'reportUntypedClassDecorator';
      e.reportUntypedBaseClass = 'reportUntypedBaseClass';
      e.reportUntypedNamedTuple = 'reportUntypedNamedTuple';
      e.reportPrivateUsage = 'reportPrivateUsage';
      e.reportTypeCommentUsage = 'reportTypeCommentUsage';
      e.reportPrivateImportUsage = 'reportPrivateImportUsage';
      e.reportConstantRedefinition = 'reportConstantRedefinition';
      e.reportDeprecated = 'reportDeprecated';
      e.reportIncompatibleMethodOverride = 'reportIncompatibleMethodOverride';
      e.reportIncompatibleVariableOverride = 'reportIncompatibleVariableOverride';
      e.reportInconsistentConstructor = 'reportInconsistentConstructor';
      e.reportOverlappingOverload = 'reportOverlappingOverload';
      e.reportPossiblyUnboundVariable = 'reportPossiblyUnboundVariable';
      e.reportMissingSuperCall = 'reportMissingSuperCall';
      e.reportUninitializedInstanceVariable = 'reportUninitializedInstanceVariable';
      e.reportInvalidStringEscapeSequence = 'reportInvalidStringEscapeSequence';
      e.reportUnknownParameterType = 'reportUnknownParameterType';
      e.reportUnknownArgumentType = 'reportUnknownArgumentType';
      e.reportUnknownLambdaType = 'reportUnknownLambdaType';
      e.reportUnknownVariableType = 'reportUnknownVariableType';
      e.reportUnknownMemberType = 'reportUnknownMemberType';
      e.reportMissingParameterType = 'reportMissingParameterType';
      e.reportMissingTypeArgument = 'reportMissingTypeArgument';
      e.reportInvalidTypeVarUse = 'reportInvalidTypeVarUse';
      e.reportCallInDefaultInitializer = 'reportCallInDefaultInitializer';
      e.reportUnnecessaryIsInstance = 'reportUnnecessaryIsInstance';
      e.reportUnnecessaryCast = 'reportUnnecessaryCast';
      e.reportUnnecessaryComparison = 'reportUnnecessaryComparison';
      e.reportUnnecessaryContains = 'reportUnnecessaryContains';
      e.reportAssertAlwaysTrue = 'reportAssertAlwaysTrue';
      e.reportSelfClsParameterName = 'reportSelfClsParameterName';
      e.reportImplicitStringConcatenation = 'reportImplicitStringConcatenation';
      e.reportUndefinedVariable = 'reportUndefinedVariable';
      e.reportUnboundVariable = 'reportUnboundVariable';
      e.reportUnhashable = 'reportUnhashable';
      e.reportInvalidStubStatement = 'reportInvalidStubStatement';
      e.reportIncompleteStub = 'reportIncompleteStub';
      e.reportUnsupportedDunderAll = 'reportUnsupportedDunderAll';
      e.reportUnusedCallResult = 'reportUnusedCallResult';
      e.reportUnusedCoroutine = 'reportUnusedCoroutine';
      e.reportUnusedExcept = 'reportUnusedExcept';
      e.reportUnusedExpression = 'reportUnusedExpression';
      e.reportUnnecessaryTypeIgnoreComment = 'reportUnnecessaryTypeIgnoreComment';
      e.reportMatchNotExhaustive = 'reportMatchNotExhaustive';
      e.reportShadowedImports = 'reportShadowedImports';
      e.reportImplicitOverride = 'reportImplicitOverride';
    })(n || (exports.DiagnosticRule = n = {}));
  },
  36316: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TextRangeDiagnosticSink = exports.DiagnosticSink = exports.FileDiagnostics = undefined;
    const a = require(58147);
    const r = require(11479);
    const s = require(56814);
    const i = require(89740);
    const o = require(27113);
    var l;
    (function (e) {
      e.toJsonObj = function (e) {
        return {
          fileUri: e.fileUri.toJsonObj(),
          version: e.version,
          diagnostics: e.diagnostics.map(e => e.toJsonObj())
        };
      };
      e.fromJsonObj = function (e) {
        return {
          fileUri: o.Uri.fromJsonObj(e.fileUri),
          version: e.version,
          diagnostics: e.diagnostics.map(e => r.Diagnostic.fromJsonObj(e))
        };
      };
    })(l || (exports.FileDiagnostics = l = {}));
    class p {
      constructor(e) {
        this._diagnosticList = e || [];
        this._diagnosticMap = new Map();
      }
      fetchAndClear() {
        const e = this._diagnosticList;
        this._diagnosticList = [];
        this._diagnosticMap.clear();
        return e;
      }
      addError(e, t) {
        return this.addDiagnostic(new r.Diagnostic(0, e, t));
      }
      addWarning(e, t) {
        return this.addDiagnostic(new r.Diagnostic(1, e, t));
      }
      addInformation(e, t) {
        return this.addDiagnostic(new r.Diagnostic(2, e, t));
      }
      addUnusedCode(e, t, n) {
        const a = new r.Diagnostic(3, e, t);
        if (n) {
          a.addAction(n);
        }
        return this.addDiagnostic(a);
      }
      addUnreachableCode(e, t, n) {
        const a = new r.Diagnostic(4, e, t);
        if (n) {
          a.addAction(n);
        }
        return this.addDiagnostic(a);
      }
      addDeprecated(e, t, n) {
        const a = new r.Diagnostic(5, e, t);
        if (n) {
          a.addAction(n);
        }
        return this.addDiagnostic(a);
      }
      addDiagnostic(e) {
        const t = `${e.range.start.line},${e.range.start.character}-${e.range.end.line}-${e.range.end.character}:${i.hashString(e.message)}}`;
        if (!this._diagnosticMap.has(t)) {
          this._diagnosticList.push(e);
          this._diagnosticMap.set(t, e);
        }
        return e;
      }
      addDiagnostics(e) {
        a.appendArray(this._diagnosticList, e);
      }
      getErrors() {
        return this._diagnosticList.filter(e => e.category === 0);
      }
      getWarnings() {
        return this._diagnosticList.filter(e => e.category === 1);
      }
      getInformation() {
        return this._diagnosticList.filter(e => e.category === 2);
      }
      getUnusedCode() {
        return this._diagnosticList.filter(e => e.category === 3);
      }
      getUnreachableCode() {
        return this._diagnosticList.filter(e => e.category === 4);
      }
      getDeprecated() {
        return this._diagnosticList.filter(e => e.category === 5);
      }
    }
    exports.DiagnosticSink = p;
    exports.TextRangeDiagnosticSink = class extends p {
      constructor(e, t) {
        super(t);
        this._lines = e;
      }
      addDiagnosticWithTextRange(e, t, n) {
        const a = s.convertOffsetsToRange(n.start, n.start + n.length, this._lines);
        switch (e) {
          case 'error':
            return this.addError(t, a);
          case 'warning':
            return this.addWarning(t, a);
          case 'information':
            return this.addInformation(t, a);
          default:
            throw new Error(`${e} is not expected value`);
        }
      }
      addUnusedCodeWithTextRange(e, t, n) {
        return this.addUnusedCode(e, s.convertOffsetsToRange(t.start, t.start + t.length, this._lines), n);
      }
      addUnreachableCodeWithTextRange(e, t, n) {
        return this.addUnreachableCode(e, s.convertOffsetsToRange(t.start, t.start + t.length, this._lines), n);
      }
      addDeprecatedWithTextRange(e, t, n) {
        return this.addDeprecated(e, s.convertOffsetsToRange(t.start, t.start + t.length, this._lines), n);
      }
    };
  },
  71458: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.PyrightDocStringService = exports.DocStringService = undefined;
    const a = require(12670);
    const r = require(81073);
    var s;
    (function (e) {
      e.is = function (e) {
        return !!e.convertDocStringToMarkdown && !!e.convertDocStringToPlainText && !!e.extractParameterDocumentation;
      };
    })(s || (exports.DocStringService = s = {}));
    exports.PyrightDocStringService = class {
      convertDocStringToPlainText(e) {
        return a.convertDocStringToPlainText(e);
      }
      convertDocStringToMarkdown(e) {
        return a.convertDocStringToMarkdown(e);
      }
      extractParameterDocumentation(e, t) {
        return r.extractParameterDocumentation(e, t);
      }
      clone() {
        return this;
      }
    };
  },
  90010: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FileEditAction = exports.TextEditAction = undefined;
    const a = require(88754);
    var r;
    var s;
    (function (e) {
      e.is = function (e) {
        return !!e.range && e.replacementText !== undefined;
      };
    })(r || (exports.TextEditAction = r = {}));
    (function (e) {
      e.is = function (e) {
        return e.fileUri !== undefined && r.is(e);
      };
      e.areEqual = function (e, t) {
        return e === t || e.fileUri.equals(t.fileUri) && a.rangesAreEqual(e.range, t.range) && e.replacementText === t.replacementText;
      };
    })(s || (exports.FileEditAction = s = {}));
  },
  10775: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.resolvePathWithEnvVariables = function (e, t, n) {
      const a = e.rootUri;
      const r = c(t, a ?? o.Uri.empty(), n);
      const s = e.service.serviceProvider.get(p.ServiceKeys.caseSensitivityDetector);
      if (function (e) {
        const t = /^[a-zA-Z]:\\?/;
        return /^[a-zA-Z][a-zA-Z0-9+.-]*:\/?\/?/.test(e) && !t.test(e);
      }(r)) {
        return o.Uri.parse(l.normalizeSlashes(r, '/'), s);
      }
      if (a) {
        return a.resolvePaths(l.normalizeSlashes(r, '/'));
      }
      if (t.includes('${workspaceFolder')) {
        return;
      }
      if (!l.isRootedDiskPath(l.normalizeSlashes(r))) {
        return;
      }
      return o.Uri.file(r, s);
    };
    exports.expandPathVariables = c;
    const i = __importStar(require(70857));
    const o = require(27113);
    const l = require(54010);
    const p = require(71745);
    const d = require(89740);
    function c(e, t, n) {
      const a = (t, n) => {
        e = e.replace(t, n);
      };
      e = e.replace(/\$\{workspaceFolder\}/g, t.getPath());
      for (const t of n) {
        if (!t.rootUri) {
          continue;
        }
        const n = d.escapeRegExp(t.workspaceName);
        const a = RegExp(`\\$\\{workspaceFolder:${n}\\}`, 'g');
        e = e.replace(a, t.rootUri.getPath());
      }
      if (process.env.HOME !== undefined) {
        a(/\$\{env:HOME\}/g, process.env.HOME || '');
      }
      if (process.env.USERNAME !== undefined) {
        a(/\$\{env:USERNAME\}/g, process.env.USERNAME || '');
      }
      if (process.env.VIRTUAL_ENV !== undefined) {
        a(/\$\{env:VIRTUAL_ENV\}/g, process.env.VIRTUAL_ENV || '');
      }
      if (i.homedir) {
        a(/(?:^|\/)~(?=\/)/g, i.homedir() || process.env.HOME || process.env.USERPROFILE || '~');
      }
      return e;
    }
  },
  56507: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ReferenceUseCase = undefined;
    (function (e) {
      e[e.Rename = 0] = 'Rename';
      e[e.References = 1] = 'References';
    })(n || (exports.ReferenceUseCase = n = {}));
  },
  44562: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    Promise.prototype.ignoreErrors = function () {
      this.catch(e => {
        console.log(e);
      });
    };
  },
  34487: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FileBasedCancellationProvider = undefined;
    exports.getCancellationStrategyFromArgv = function (e) {
      let t;
      for (let a = 0; a < e.length; a++) {
        const r = e[a];
        if (r === '--cancellationReceive') {
          t = n(e[a + 1]);
        } else {
          const e = r.split('=');
          if (e[0] === '--cancellationReceive') {
            t = n(e[1]);
          }
        }
      }
      if (t && !c.getCancellationFolderName()) {
        c.setCancellationFolderName(t.folderName);
      }
      t = t || d.CancellationReceiverStrategy.Message;
      return {
        receiver: t,
        sender: d.CancellationSenderStrategy.Message
      };
      function n(e) {
        const t = function (e) {
          const t = /^file:(.+)$/;
          const n = e.match(t);
          if (n) {
            return n[1];
          } else {
            return undefined;
          }
        }(e);
        if (t) {
          return new f(t);
        } else {
          return undefined;
        }
      }
    };
    exports.disposeCancellationToken = function (e) {
      if (e instanceof c.FileBasedToken) {
        e.dispose();
      }
    };
    exports.getCancellationTokenFromId = function (e) {
      if (!e) {
        return d.CancellationToken.None;
      }
      return new c.FileBasedToken(e, new m());
    };
    const i = __importStar(require(79896));
    const o = __importStar(require(70857));
    const l = __importStar(require(16928));
    const p = require(90355);
    const d = require(56911);
    const c = require(91426);
    const u = require(5884);
    class m {
      statSync(e) {
        return i.statSync(e.getFilePath());
      }
    }
    class y extends c.FileBasedToken {
      constructor(e) {
        super(e, new m());
        this._disposed = false;
      }
      get isCancellationRequested() {
        return this.isCancelled;
      }
      cancel() {
        if (!this._disposed && !this.isCancelled) {
          this._createPipe();
          super.cancel();
        }
      }
      dispose() {
        this._disposed = true;
        super.dispose();
        this._removePipe();
      }
      _createPipe() {
        try {
          i.writeFileSync(this.cancellationFilePath.getFilePath(), '', {
            flag: 'w'
          });
        } catch {}
      }
      _removePipe() {
        try {
          i.unlinkSync(this.cancellationFilePath.getFilePath());
        } catch {}
      }
    }
    class g {
      constructor(e, t = false) {
        this._cancellationId = e;
        this._ownFile = t;
      }
      get token() {
        if (!this._token) {
          this._token = this._ownFile ? new y(this._cancellationId) : new c.FileBasedToken(this._cancellationId, new m());
        }
        return this._token;
      }
      cancel() {
        if (this._token) {
          if (this._token.isCancellationRequested) {
            return;
          }
          this._token.cancel();
        } else {
          this._token = d.CancellationToken.Cancelled;
        }
      }
      dispose() {
        if (this._token) {
          if (this._token instanceof c.FileBasedToken) {
            this._token.dispose();
          }
        } else {
          this._token = d.CancellationToken.None;
        }
      }
    }
    function h(e, t) {
      return u.UriEx.file(l.join(function (e) {
        return l.join(o.tmpdir(), 'python-languageserver-cancellation', e);
      }(e), `cancellation-${String(t)}.tmp`)).toString();
    }
    class f {
      constructor(e) {
        this.folderName = e;
      }
      createCancellationTokenSource(e) {
        return new g(h(this.folderName, e));
      }
    }
    let T = 0;
    exports.FileBasedCancellationProvider = class {
      constructor(e) {
        this._prefix = e;
      }
      createCancellationTokenSource() {
        const e = c.getCancellationFolderName();
        if (e) {
          return new g(h(e, `${this._prefix}-${String(T++)}`), true);
        } else {
          return new p.CancellationTokenSource();
        }
      }
    };
  },
  66643: (module, exports) => {
    var n;
    var a;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.VirtualDirent = exports.TempFile = exports.FileSystem = undefined;
    (function (e) {
      e.is = function (e) {
        return e.createFileSystemWatcher && e.createReadStream && e.createWriteStream && e.copyFileSync;
      };
    })(n || (exports.FileSystem = n = {}));
    (function (e) {
      e.is = function (e) {
        return e.tmpdir && e.tmpfile;
      };
    })(a || (exports.TempFile = a = {}));
    exports.VirtualDirent = class {
      constructor(e, t, n) {
        this.name = e;
        this._file = t;
        this.parentPath = n;
      }
      get path() {
        return this.parentPath;
      }
      isFile() {
        return this._file;
      }
      isDirectory() {
        return !this._file;
      }
      isBlockDevice() {
        return false;
      }
      isCharacterDevice() {
        return false;
      }
      isSymbolicLink() {
        return false;
      }
      isFIFO() {
        return false;
      }
      isSocket() {
        return false;
      }
    };
  },
  12060: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.nullFileWatcherProvider = exports.nullFileWatcherHandler = undefined;
    exports.ignoredWatchEventFunction = function (e) {
      const t = e.map(e => e.toLowerCase());
      return e => {
        if (!e || e.indexOf('__pycache__') >= 0) {
          return true;
        }
        const n = e.toLowerCase();
        return t.every(e => n.indexOf(e) < 0);
      };
    };
    exports.nullFileWatcherHandler = {
      onFileChange(e, t) {}
    };
    exports.nullFileWatcherProvider = {
      createFileWatcher: (e, t) => n
    };
    const n = {
      close() {}
    };
  },
  12913: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FullAccessHost = exports.LimitedAccessHost = undefined;
    const i = __importStar(require(35317));
    const o = require(91426);
    const l = require(12522);
    const p = require(48281);
    const d = require(50918);
    const c = require(54010);
    const u = require(63808);
    const m = require(71745);
    const y = require(27113);
    const g = require(5884);
    const h = ['import os, os.path, sys', 'normalize = lambda p: os.path.normcase(os.path.normpath(p))', 'cwd = normalize(os.getcwd())', 'orig_sys_path = [p for p in sys.path if p != ""]', 'sys.path[:] = [p for p in sys.path if p != "" and normalize(p) != cwd]'];
    const f = [...h, 'import sys, json', 'json.dump(dict(path=orig_sys_path, prefix=sys.prefix), sys.stdout)'].join('; ');
    const T = [...h, 'import sys, json', 'json.dump(tuple(sys.version_info), sys.stdout)'].join('; ');
    class v extends d.NoAccessHost {
      get kind() {
        return 1;
      }
      getPythonPlatform(e) {
        if (process.platform === 'darwin') {
          return l.PythonPlatform.Darwin;
        } else {
          if (process.platform === 'linux') {
            return l.PythonPlatform.Linux;
          } else {
            if (process.platform === 'win32') {
              return l.PythonPlatform.Windows;
            } else {
              return undefined;
            }
          }
        }
      }
    }
    exports.LimitedAccessHost = v;
    class b extends v {
      constructor(e) {
        super();
        this.serviceProvider = e;
      }
      get kind() {
        return 0;
      }
      static createHost(e, t) {
        switch (e) {
          case 2:
            return new d.NoAccessHost();
          case 1:
            return new v();
          case 0:
            return new b(t);
          default:
            p.assertNever(e);
        }
      }
      getPythonSearchPaths(e, t) {
        const n = t ?? [];
        let a = this._executePythonInterpreter(e == null ? undefined : e.getFilePath(), e => this._getSearchPathResultFromInterpreter(e, n));
        if (!a) {
          a = {
            paths: [],
            prefix: undefined
          };
        }
        n.push(`Received ${a.paths.length} paths from interpreter`);
        a.paths.forEach(e => {
          n.push(`  ${e}`);
        });
        return a;
      }
      getPythonVersion(e, t) {
        const n = t ?? [];
        try {
          const t = this._executePythonInterpreter(e == null ? undefined : e.getFilePath(), e => this._executeCodeInInterpreter(e, ['-I'], T));
          const a = JSON.parse(t);
          if (!Array.isArray(a) || a.length < 5) {
            n.push(`Python version ${t} from interpreter is unexpected format`);
            return;
          }
          const r = u.PythonVersion.create(a[0], a[1], a[2], a[3], a[4]);
          if (r === undefined) {
            n.push(`Python version ${t} from interpreter is unsupported`);
            return;
          } else {
            return r;
          }
        } catch {
          n.push('Unable to get Python version from interpreter');
          return;
        }
      }
      runScript(e, t, n, a, r) {
        o.throwIfCancellationRequested(r);
        return new Promise((s, l) => {
          let p = '';
          let d = '';
          const c = ['-I', t.getFilePath(), ...n];
          const u = this._executePythonInterpreter(e == null ? undefined : e.getFilePath(), e => i.spawn(e, c, {
            cwd: a.getFilePath(),
            shell: this.shouldUseShellToRunInterpreter(e)
          }));
          const m = o.onCancellationRequested(r, () => {
            if (u) {
              try {
                if (u.pid && u.exitCode === null) {
                  if (process.platform === 'win32') {
                    i.execSync(`taskkill /pid ${u.pid} /T /F > NUL 2>&1`);
                  } else {
                    process.kill(u.pid);
                  }
                }
              } catch {}
            }
            l(new o.OperationCanceledException());
          });
          if (u) {
            u.stdout.on('data', e => p = p.concat(e));
            u.stderr.on('data', e => d = d.concat(e));
            u.on('error', e => {
              m.dispose();
              l(e);
            });
            u.on('exit', () => {
              m.dispose();
              s({
                stdout: p,
                stderr: d
              });
            });
          } else {
            m.dispose();
            l(new Error(`Cannot start python interpreter with script ${t}`));
          }
        });
      }
      shouldUseShellToRunInterpreter(e) {
        return process.platform === 'win32' && !!c.getAnyExtensionFromPath(e, ['.bat', '.cmd'], true);
      }
      _executePythonInterpreter(e, t) {
        if (e) {
          return t(e);
        }
        {
          let e;
          try {
            if (process.platform !== 'win32') {
              e = t('python3');
            }
          } catch {}
          if (e !== undefined) {
            return e;
          } else {
            return t('python');
          }
        }
      }
      _executeCodeInInterpreter(e, t, n) {
        const a = this.shouldUseShellToRunInterpreter(e);
        if (a) {
          n = `"${n}"`;
        }
        t.push('-c', n);
        return i.execFileSync(e, t, {
          encoding: 'utf8',
          shell: a
        });
      }
      _getSearchPathResultFromInterpreter(e, t) {
        const n = {
          paths: [],
          prefix: undefined
        };
        try {
          t.push(`Executing interpreter: '${e}'`);
          const a = this._executeCodeInInterpreter(e, [], f);
          const r = this.serviceProvider.get(m.ServiceKeys.caseSensitivityDetector);
          try {
            const e = JSON.parse(a);
            for (let a of e.path) {
              a = a.trim();
              if (a) {
                const e = c.normalizePath(a);
                const s = y.Uri.file(e, r);
                if (this.serviceProvider.fs().existsSync(s) && g.isDirectory(this.serviceProvider.fs(), s)) {
                  n.paths.push(s);
                } else {
                  t.push(`Skipping '${e}' because it is not a valid directory`);
                }
              }
            }
            n.prefix = y.Uri.file(e.prefix, r);
            if (n.paths.length === 0) {
              t.push('Found no valid directories');
            }
          } catch (e) {
            t.push(`Could not parse output: '${a}'`);
            throw e;
          }
        } catch {
          return;
        }
        return n;
      }
    }
    exports.FullAccessHost = b;
  },
  50918: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.NoAccessHost = undefined;
    exports.NoAccessHost = class {
      get kind() {
        return 2;
      }
      getPythonSearchPaths(e, t) {
        if (t != null) {
          t.push('No access to python executable.');
        }
        return {
          paths: [],
          prefix: undefined
        };
      }
      getPythonVersion(e, t) {}
      getPythonPlatform(e) {}
      async runScript(e, t, n, a, r) {
        return {
          stdout: '',
          stderr: ''
        };
      }
    };
  },
  1394: (module, exports) => {
    var n;
    var a;
    var r;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CommandService = exports.WindowService = exports.WindowInterface = undefined;
    (function (e) {
      e.is = function (e) {
        return !!e && e.showErrorMessage !== undefined && e.showWarningMessage !== undefined && e.showInformationMessage !== undefined;
      };
    })(n || (exports.WindowInterface = n = {}));
    (function (e) {
      e.is = function (e) {
        return e.createGoToOutputAction !== undefined && n.is(e);
      };
    })(a || (exports.WindowService = a = {}));
    (function (e) {
      e.is = function (e) {
        return !!e && e.sendCommand !== undefined;
      };
    })(r || (exports.CommandService = r = {}));
  },
  51862: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.LogTracker = undefined;
    exports.getPathForLogging = function (e, t) {
      if (e.isMappedUri(t)) {
        return e.getOriginalUri(t);
      }
      return t;
    };
    const a = require(25075);
    const r = require(71582);
    exports.LogTracker = class {
      constructor(e, t) {
        this._console = e;
        this.prefix = t;
        this._dummyState = new s();
        this._previousTitles = [];
        this._indentation = '';
      }
      get logLevel() {
        const e = this._console.level;
        if (e != null) {
          return e;
        } else {
          return a.LogLevel.Error;
        }
      }
      log(e, t, n = -1, r = false) {
        if (this._console === undefined) {
          return t(this._dummyState);
        }
        const i = this._console.level;
        if (i === undefined || i !== a.LogLevel.Log && i !== a.LogLevel.Info) {
          return t(this._dummyState);
        }
        const o = this._indentation;
        this._previousTitles.push(`${o}${e} ...`);
        this._indentation += '  ';
        const l = new s();
        try {
          return t(l);
        } finally {
          const t = l.duration;
          this._indentation = o;
          if (this._previousTitles.length > 0 && (l.isSuppressed() || t <= n)) {
            this._previousTitles.pop();
          } else {
            this._printPreviousTitles();
            let n = `[${this.prefix}] ${this._indentation}${e}${l.get()} (${t}ms)`;
            if (r && l.fileReadTotal + l.tokenizeTotal + l.parsingTotal + l.resolveImportsTotal + l.bindingTotal > 0) {
              n += ` [f:${l.fileReadTotal}, t:${l.tokenizeTotal}, p:${l.parsingTotal}, i:${l.resolveImportsTotal}, b:${l.bindingTotal}]`;
            }
            this._console.log(n);
            if (t >= 2000) {
              this._console.info(`[${this.prefix}] Long operation: ${e} (${t}ms)`);
            }
          }
        }
      }
      _printPreviousTitles() {
        this._previousTitles.pop();
        if (!(this._previousTitles.length <= 0)) {
          for (const e of this._previousTitles) {
            this._console.log(`[${this.prefix}] ${e}`);
          }
          this._previousTitles.length = 0;
        }
      }
    };
    class s {
      constructor() {
        this._start = new r.Duration();
        this._startFile = r.timingStats.readFileTime.totalTime;
        this._startToken = r.timingStats.tokenizeFileTime.totalTime;
        this._startParse = r.timingStats.parseFileTime.totalTime;
        this._startImport = r.timingStats.resolveImportsTime.totalTime;
        this._startBind = r.timingStats.bindTime.totalTime;
      }
      get duration() {
        return this._start.getDurationInMilliseconds();
      }
      get fileReadTotal() {
        return r.timingStats.readFileTime.totalTime - this._startFile;
      }
      get tokenizeTotal() {
        return r.timingStats.tokenizeFileTime.totalTime - this._startToken;
      }
      get parsingTotal() {
        return r.timingStats.parseFileTime.totalTime - this._startParse;
      }
      get resolveImportsTotal() {
        return r.timingStats.resolveImportsTime.totalTime - this._startImport;
      }
      get bindingTotal() {
        return r.timingStats.bindTime.totalTime - this._startBind;
      }
      add(e) {
        if (e) {
          this._addendum = e;
        }
      }
      get() {
        if (this._addendum) {
          return ` [${this._addendum}]`;
        } else {
          return '';
        }
      }
      suppress() {
        this._suppress = true;
      }
      isSuppressed() {
        return !!this._suppress;
      }
    }
  },
  56412: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.toLSPAny = function (e) {
      return e;
    };
    exports.fromLSPAny = function (e) {
      return e;
    };
    exports.getSymbolKind = function (e, t, n = '') {
      var s;
      switch (e.type) {
        case 6:
        case 7:
          return a.SymbolKind.Class;
        case 5:
          {
            if (!e.isMethod) {
              return a.SymbolKind.Function;
            }
            const n = (s = t == null ? undefined : t.getTypeForDeclaration(e)) === null || s === undefined ? undefined : s.type;
            if (n && r.isMaybeDescriptorInstance(n, false)) {
              return a.SymbolKind.Property;
            } else {
              return a.SymbolKind.Method;
            }
          }
        case 8:
          return a.SymbolKind.Module;
        case 2:
          if (n === 'self' || n === 'cls' || n === '_') {
            return;
          }
          return a.SymbolKind.Variable;
        case 3:
          return a.SymbolKind.TypeParameter;
        case 1:
          if (n === '_') {
            return;
          }
          if (e.isConstant || e.isFinal) {
            return a.SymbolKind.Constant;
          } else {
            return a.SymbolKind.Variable;
          }
        default:
          return a.SymbolKind.Variable;
      }
    };
    exports.isNullProgressReporter = function (e) {
      const t = e.begin.toString();
      return t.substring(t.indexOf('{') + 1, t.lastIndexOf('}')).trim() === '';
    };
    const a = require(56911);
    const r = require(92324);
  },
  16066: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getHeapStatistics = undefined;
    exports.getSystemMemoryInfo = function () {
      if (!i.totalmem || !i.freemem) {
        return {
          total: 0,
          free: 0
        };
      }
      return {
        total: i.totalmem(),
        free: i.freemem()
      };
    };
    const i = __importStar(require(70857));
    exports.getHeapStatistics = function () {
      try {
        const e = require(11493).getHeapStatistics;
        if (e) {
          return e;
        }
      } catch {}
      return () => ({
        total_heap_size: 0,
        total_heap_size_executable: 0,
        total_physical_size: 0,
        total_available_size: 0,
        used_heap_size: 0,
        heap_size_limit: 0,
        malloced_memory: 0,
        peak_malloced_memory: 0,
        does_zap_garbage: 0,
        number_of_native_contexts: 0,
        number_of_detached_contexts: 0,
        total_global_handles_size: 0,
        used_global_handles_size: 0,
        external_memory: 0
      });
    }();
  },
  4883: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.configFileName = exports.pyprojectTomlName = exports.requirementsFileName = exports.defaultStubsDirectory = exports.stubsSuffix = exports.src = exports.distPackages = exports.sitePackages = exports.lib64 = exports.libAlternate = exports.lib = exports.typeshedFallback = undefined;
    exports.typeshedFallback = 'typeshed-fallback';
    exports.lib = 'lib';
    exports.libAlternate = 'Lib';
    exports.lib64 = 'lib64';
    exports.sitePackages = 'site-packages';
    exports.distPackages = 'dist-packages';
    exports.src = 'src';
    exports.stubsSuffix = '-stubs';
    exports.defaultStubsDirectory = 'typings';
    exports.requirementsFileName = 'requirements.txt';
    exports.pyprojectTomlName = 'pyproject.toml';
    exports.configFileName = 'pyrightconfig.json';
  },
  54010: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FileSpec = undefined;
    exports.getDirectoryPath = m;
    exports.getRootLength = y;
    exports.getPathSeparator = g;
    exports.getPathComponents = h;
    exports.reducePathComponents = f;
    exports.combinePathComponents = T;
    exports.getRelativePath = function (e, t) {
      if (!e.startsWith(w(t))) {
        return;
      }
      const n = h(e);
      const a = h(t);
      const r = g(e);
      let s = '.';
      for (let e = a.length; e < n.length; e++) {
        s += r + n[e];
      }
      return s;
    };
    exports.normalizeSlashes = b;
    exports.resolvePaths = function (e, ...t) {
      return D(o.some(t) ? _(e, ...t) : b(e));
    };
    exports.combinePaths = _;
    exports.containsPath = function (e, t, n, a) {
      if (typeof n == 'string') {
        e = _(n, e);
        t = _(n, t);
      } else {
        if (typeof n == 'boolean') {
          a = n;
        }
      }
      if (e === undefined || t === undefined) {
        return false;
      }
      if (e === t) {
        return true;
      }
      const r = h(e);
      const s = h(t);
      if (s.length < r.length) {
        return false;
      }
      const i = a ? d.equateStringsCaseInsensitive : d.equateStringsCaseSensitive;
      for (let e = 0; e < r.length; e++) {
        if (!(e === 0 ? d.equateStringsCaseInsensitive : i)(r[e], s[e])) {
          return false;
        }
      }
      return true;
    };
    exports.changeAnyExtension = function (e, t, n, a) {
      const r = n !== undefined && a !== undefined ? C(e, n, a) : C(e);
      if (r) {
        return e.slice(0, e.length - r.length) + (t.startsWith('.') ? t : `.${t}`);
      } else {
        return e;
      }
    };
    exports.getAnyExtensionFromPath = C;
    exports.getBaseFileName = I;
    exports.getRelativePathFromDirectory = function (e, t, n) {
      return T(k(e, t, n));
    };
    exports.getRelativePathComponentsFromDirectory = k;
    exports.ensureTrailingDirectorySeparator = w;
    exports.hasTrailingDirectorySeparator = S;
    exports.stripTrailingDirectorySeparator = A;
    exports.getFileExtension = x;
    exports.getFileName = P;
    exports.getShortenedFileName = function (e, t = 15) {
      const n = P(e);
      const a = m(e);
      if (a.length > t) {
        return `...${a.slice(a.length - t)}${i.sep}${n}`;
      }
      return e;
    };
    exports.stripFileExtension = function (e, t = false) {
      const n = x(e, t);
      return e.substr(0, e.length - n.length);
    };
    exports.normalizePath = D;
    exports.getWildcardRegexPattern = function (e, t) {
      let n = D(_(e, t));
      if (!N(n)) {
        n = w(n);
      }
      const a = h(n);
      const r = F(g(e));
      const s = `(${r}[^${r}][^${r}]*)*?`;
      const i = new RegExp(`[^\\w\\s${r}]`, 'g');
      if (a.length > 0) {
        a[0] = A(a[0]);
        if (a[0].startsWith('\\\\')) {
          a[0] = `\\\\${a[0]}`;
        }
      }
      let o = '';
      let l = true;
      for (let e of a) {
        if (e === '**') {
          o += s;
        } else {
          if (!l) {
            e = r + e;
          }
          o += e.replace(i, e => e === '*' ? `[^${r}]*` : e === '?' ? `[^${r}]` : `\\${e}`);
          l = false;
        }
      }
      return o;
    };
    exports.isDirectoryWildcardPatternPresent = function (e) {
      const t = D(e);
      const n = h(t);
      for (const e of n) {
        if (e === '**') {
          return true;
        }
      }
      return false;
    };
    exports.getWildcardRoot = function (e, t) {
      let n = D(_(e, t));
      if (!N(n)) {
        n = w(n);
      }
      const a = h(n);
      const r = g(n);
      if (a.length > 0) {
        a[0] = A(a[0]);
      }
      if (a.length === 1 && !a[0]) {
        return r;
      }
      let s = '';
      let i = true;
      for (let e of a) {
        if (e === '**') {
          break;
        }
        if (e.match(/[*?]/)) {
          break;
        }
        if (!i) {
          e = r + e;
        }
        s += e;
        i = false;
      }
      return s;
    };
    exports.hasPythonExtension = N;
    exports.getRegexEscapedSeparator = F;
    exports.isRootedDiskPath = function (e) {
      return y(e) > 0;
    };
    exports.isDiskPathRoot = function (e) {
      const t = y(e);
      return t > 0 && t === e.length;
    };
    const i = __importStar(require(16928));
    const o = require(58147);
    const l = require(34455);
    const p = __importStar(require(48281));
    const d = require(89740);
    const c = /\.pyi?$/;
    var u;
    function m(e) {
      return e.substr(0, Math.max(y(e), e.lastIndexOf(i.sep)));
    }
    function y(e, t = i.sep) {
      if (e.charAt(0) === t) {
        if (e.charAt(1) !== t) {
          return 1;
        }
        const n = e.indexOf(t, 2);
        if (n < 0) {
          return e.length;
        } else {
          return n + 1;
        }
      }
      if (e.charAt(1) === ':') {
        if (e.charAt(2) === t) {
          return 3;
        }
        if (e.length === 2) {
          return 2;
        }
      }
      return 0;
    }
    function g(e) {
      return i.sep;
    }
    function h(e) {
      const t = b(e);
      const n = y(t);
      const a = t.substring(0, n);
      const r = g();
      const s = t.substring(n).split(r);
      if (s.length > 0 && !s[s.length - 1]) {
        s.pop();
      }
      return f([a, ...s]);
    }
    function f(e) {
      if (!o.some(e)) {
        return [];
      }
      const t = [e[0]];
      for (let n = 1; n < e.length; n++) {
        const a = e[n];
        if (a && a !== '.') {
          if (a === '..') {
            if (t.length > 1) {
              if (t[t.length - 1] !== '..') {
                t.pop();
                continue;
              }
            } else {
              if (t[0]) {
                continue;
              }
            }
          }
          t.push(a);
        }
      }
      return t;
    }
    function T(e) {
      if (e.length === 0) {
        return '';
      }
      const t = e[0] && w(e[0]);
      const n = g();
      return b(t + e.slice(1).join(n));
    }
    (function (e) {
      e.is = function (e) {
        const t = e;
        return t && !!t.wildcardRoot && !!t.regExp;
      };
      e.isInPath = function (e, t) {
        return !!t.find(t => t.regExp.test(e));
      };
      e.matchesIncludeFileRegex = function (e, t = true) {
        return !t || c.test(e);
      };
      e.matchIncludeFileSpec = function (t, n, a, r = true) {
        return !!t.test(a) && !e.isInPath(a, n) && !!e.matchesIncludeFileRegex(a, r);
      };
    })(u || (exports.FileSpec = u = {}));
    const v = e => e === '/' ? '\\' : '/';
    function b(e, t = i.sep) {
      if (e.includes(v(t))) {
        const n = /[\\/]/g;
        return e.replace(n, t);
      }
      return e;
    }
    function _(e, ...t) {
      if (e) {
        e = b(e);
      }
      for (let n of t) {
        if (n) {
          n = b(n);
          e = e && y(n) === 0 ? w(e) + n : n;
        }
      }
      return e;
    }
    function C(e, t, n) {
      if (t) {
        return function (e, t, n) {
          if (typeof t == 'string') {
            return E(e, t, n) || '';
          }
          for (const a of t) {
            const t = E(e, a, n);
            if (t) {
              return t;
            }
          }
          return '';
        }(A(e), t, n ? d.equateStringsCaseInsensitive : d.equateStringsCaseSensitive);
      }
      const a = I(e);
      const r = a.lastIndexOf('.');
      if (r >= 0) {
        return a.substring(r);
      } else {
        return '';
      }
    }
    function I(e, t, n) {
      if (y(e = b(e)) === e.length) {
        return '';
      }
      const a = (e = A(e)).slice(Math.max(y(e), e.lastIndexOf(i.sep) + 1));
      const r = t !== undefined && n !== undefined ? C(a, t, n) : undefined;
      if (r) {
        return a.slice(0, a.length - r.length);
      } else {
        return a;
      }
    }
    function k(e, t, n) {
      p.assert(y(e) > 0 == y(t) > 0, 'Paths must either both be absolute or both be relative');
      const a = typeof n == 'function' ? n : l.identity;
      const r = function (e, t, n, a) {
        const r = h(e);
        const s = h(t);
        let i;
        for (i = 0; i < r.length && i < s.length; i++) {
          const e = a(r[i]);
          const t = a(s[i]);
          if (!(i === 0 ? d.equateStringsCaseInsensitive : n)(e, t)) {
            break;
          }
        }
        if (i === 0) {
          return s;
        }
        const o = s.slice(i);
        const l = [];
        for (; i < r.length; i++) {
          l.push('..');
        }
        return ['', ...l, ...o];
      }(e, t, typeof n == 'boolean' && n ? d.equateStringsCaseInsensitive : d.equateStringsCaseSensitive, a);
      return r;
    }
    function w(e) {
      const t = g();
      if (S(e)) {
        return e;
      } else {
        return e + t;
      }
    }
    function S(e) {
      if (e.length === 0) {
        return false;
      }
      const t = e.charCodeAt(e.length - 1);
      return t === 47 || t === 92;
    }
    function A(e) {
      if (S(e)) {
        return e.slice(0, e.length - 1);
      } else {
        return e;
      }
    }
    function x(e, t = false) {
      if (!t) {
        return i.extname(e);
      }
      const n = (e = P(e)).indexOf('.');
      return e.slice(n);
    }
    function P(e) {
      return i.basename(e);
    }
    function D(e) {
      return b(i.normalize(e));
    }
    function N(e) {
      return e.endsWith('.py') || e.endsWith('.pyi');
    }
    function F(e = i.sep) {
      if (e === '/') {
        return '/';
      } else {
        return '\\\\';
      }
    }
    function E(e, t, n) {
      if (!t.startsWith('.')) {
        t = `.${t}`;
      }
      if (e.length >= t.length && e.charCodeAt(e.length - t.length) === 46) {
        const a = e.slice(e.length - t.length);
        if (n(a, t)) {
          return a;
        }
      }
    }
  },
  56814: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.convertOffsetToPosition = s;
    exports.convertOffsetsToRange = i;
    exports.convertPositionToOffset = o;
    exports.convertRangeToTextRange = function (e, t) {
      const n = o(e.start, t);
      if (n === undefined) {
        return;
      }
      const a = o(e.end, t);
      if (a === undefined) {
        return;
      }
      return r.TextRange.fromBounds(n, a);
    };
    exports.convertTextRangeToRange = function (e, t) {
      return i(e.start, r.TextRange.getEnd(e), t);
    };
    exports.getLineEndPosition = function (e, t, n) {
      return s(l(e, t, n), e.lines);
    };
    exports.getLineEndOffset = l;
    const a = require(48281);
    const r = require(88754);
    function s(e, t) {
      if (t.end === 0) {
        return {
          line: 0,
          character: 0
        };
      }
      const n = e >= t.end ? t.count - 1 : t.getItemContaining(e);
      a.assert(n >= 0 && n <= t.count);
      const r = t.getItemAt(n);
      a.assert(r !== undefined);
      return {
        line: n,
        character: Math.max(0, Math.min(r.length, e - r.start))
      };
    }
    function i(e, t, n) {
      return {
        start: s(e, n),
        end: s(t, n)
      };
    }
    function o(e, t) {
      if (!(e.line >= t.count)) {
        return t.getItemAt(e.line).start + e.character;
      }
    }
    function l(e, t, n) {
      const a = e.lines.getItemAt(n);
      const s = r.TextRange.getEnd(a);
      let i = 0;
      for (let e = s - 1; e >= a.start; e--) {
        const n = t[e];
        if (n !== '\r' && n !== '\n') {
          break;
        }
        i++;
      }
      return s - i;
    }
  },
  30442: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ProgressReportTracker = undefined;
    exports.ProgressReportTracker = class {
      constructor(e) {
        this._reporter = e;
        this._isDisplayingProgress = false;
      }
      isEnabled(e) {
        var t;
        return !!this._isDisplayingProgress || (t = this._reporter.isEnabled(e)) !== null && t !== undefined && t;
      }
      begin() {
        if (!this._isDisplayingProgress) {
          this._isDisplayingProgress = true;
          this._reporter.begin();
        }
      }
      report(e) {
        if (this._isDisplayingProgress) {
          this._reporter.report(e);
        }
      }
      end() {
        if (this._isDisplayingProgress) {
          this._isDisplayingProgress = false;
          this._reporter.end();
        }
      }
    };
  },
  63808: (module, exports) => {
    var n;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.latestStablePythonVersion = exports.pythonVersion3_14 = exports.pythonVersion3_13 = exports.pythonVersion3_12 = exports.pythonVersion3_11 = exports.pythonVersion3_10 = exports.pythonVersion3_9 = exports.pythonVersion3_8 = exports.pythonVersion3_7 = exports.pythonVersion3_6 = exports.pythonVersion3_5 = exports.pythonVersion3_4 = exports.pythonVersion3_3 = exports.pythonVersion3_2 = exports.pythonVersion3_1 = exports.pythonVersion3_0 = exports.PythonVersion = undefined;
    (function (e) {
      function t(e, t, n, a, r) {
        return {
          major: e,
          minor: t,
          micro: n,
          releaseLevel: a,
          serial: r
        };
      }
      function n(e, t) {
        return e.major === t.major && e.minor === t.minor && (e.micro === undefined || t.micro === undefined || e.micro === t.micro && (e.releaseLevel === undefined || t.releaseLevel === undefined || e.releaseLevel === t.releaseLevel && (e.serial === undefined || t.serial === undefined || e.serial === t.serial)));
      }
      function a(e, t) {
        return e.major > t.major || !(e.major < t.major) && (e.minor > t.minor || !(e.minor < t.minor) && e.micro !== undefined && t.micro !== undefined && !(e.micro < t.micro) && (e.micro > t.micro || e.releaseLevel !== undefined && t.releaseLevel !== undefined && !(e.releaseLevel < t.releaseLevel) && (e.releaseLevel > t.releaseLevel || e.serial !== undefined && t.serial !== undefined && !(e.serial < t.serial) && e.serial > t.serial)));
      }
      function r(e, t) {
        return n(e, t) || a(e, t);
      }
      function s(e) {
        return `${e.major}.${e.minor}`;
      }
      e.is = function (e) {
        return !!e && typeof e.major == 'number' && typeof e.minor == 'number' && (e.micro === undefined || typeof e.micro == 'number') && (e.releaseLevel === undefined || typeof e.releaseLevel == 'string') && (e.serial === undefined || typeof e.serial == 'number');
      };
      e.create = t;
      e.isEqualTo = n;
      e.isGreaterThan = a;
      e.isGreaterOrEqualTo = r;
      e.isLessThan = function (e, t) {
        return !r(e, t);
      };
      e.isLessOrEqualTo = function (e, t) {
        return !a(e, t);
      };
      e.toMajorMinorString = s;
      e.toString = function (e) {
        let t = s(e);
        if (e.micro === undefined) {
          return t;
        } else {
          t += `.${e.micro}`;
          return e.releaseLevel === undefined ? t : (t += `.${e.releaseLevel}`, e.serial === undefined || (t += `.${e.serial}`), t);
        }
      };
      e.fromString = function (e) {
        const n = e.split('.');
        if (n.length < 2) {
          return;
        }
        const a = parseInt(n[0], 10);
        const r = parseInt(n[1], 10);
        if (isNaN(a) || isNaN(r)) {
          return;
        }
        let s;
        let i;
        let o;
        if (n.length >= 3) {
          s = parseInt(n[2], 10);
          if (isNaN(s)) {
            s = undefined;
          }
        }
        if (n.length >= 4) {
          if (['alpha', 'beta', 'candidate', 'final'].some(e => e === n[3])) {
            i = n[3];
          }
        }
        if (n.length >= 5) {
          o = parseInt(n[4], 10);
          if (isNaN(o)) {
            o = undefined;
          }
        }
        return t(a, r, s, i, o);
      };
    })(n || (exports.PythonVersion = n = {}));
    exports.pythonVersion3_0 = n.create(3, 0);
    exports.pythonVersion3_1 = n.create(3, 1);
    exports.pythonVersion3_2 = n.create(3, 2);
    exports.pythonVersion3_3 = n.create(3, 3);
    exports.pythonVersion3_4 = n.create(3, 4);
    exports.pythonVersion3_5 = n.create(3, 5);
    exports.pythonVersion3_6 = n.create(3, 6);
    exports.pythonVersion3_7 = n.create(3, 7);
    exports.pythonVersion3_8 = n.create(3, 8);
    exports.pythonVersion3_9 = n.create(3, 9);
    exports.pythonVersion3_10 = n.create(3, 10);
    exports.pythonVersion3_11 = n.create(3, 11);
    exports.pythonVersion3_12 = n.create(3, 12);
    exports.pythonVersion3_13 = n.create(3, 13);
    exports.pythonVersion3_14 = n.create(3, 14);
    exports.latestStablePythonVersion = exports.pythonVersion3_13;
  },
  27643: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.RealTempFile = exports.WorkspaceFileWatcherProvider = exports.RealFileSystem = undefined;
    exports.createFromRealFileSystem = function (e, t, n) {
      return new x(e, t ?? new c.NullConsole(), n ?? m.nullFileWatcherProvider);
    };
    const i = require(49054);
    const o = require(21859);
    const l = __importStar(require(79896));
    const p = __importStar(require(57417));
    const d = require(28167);
    const c = require(25075);
    const u = require(77313);
    const m = require(12060);
    const y = require(54010);
    const g = require(16867);
    const h = require(27113);
    const f = require(5884);
    p.setGracefulCleanup();
    const T = '.zip';
    const v = '.egg';
    const b = '.jar';
    function _(e) {
      let t = e.indexOf(T);
      if (t <= 0 && (t = e.indexOf(v), t <= 0 && (t = e.indexOf(b), t <= 0))) {
        return null;
      }
      if (e[t - 1] === i.ppath.sep) {
        return null;
      }
      const n = t + 4;
      if (e.length > n && e[n] !== i.ppath.sep) {
        return null;
      } else {
        return e.slice(0, n);
      }
    }
    function C(e) {
      return e.endsWith(T) || e.endsWith(v) || e.endsWith(b);
    }
    const I = [Buffer.from([80, 75, 3, 4]), Buffer.from([80, 75, 5, 6]), Buffer.from([80, 75, 7, 8])];
    function k(e, t) {
      let n;
      try {
        n = e.openSync(t, 'r');
        const a = Buffer.alloc(4);
        if (e.readSync(n, a, 0, 4, 0) < 4) {
          return false;
        }
        for (const e of I) {
          if (a.compare(e) === 0) {
            return true;
          }
        }
        return false;
      } catch {
        return false;
      } finally {
        if (n !== undefined) {
          e.closeSync(n);
        }
      }
    }
    class w extends i.ZipOpenFS {
      findZip(e) {
        if (this.filter && !this.filter.test(e)) {
          return null;
        }
        let t = '';
        while (true) {
          const n = _(e.substr(t.length));
          if (!n) {
            return null;
          }
          t = this.pathUtils.join(t, n);
          if (this.isZip.has(t) === false) {
            if (this.notZip.has(t)) {
              continue;
            }
            try {
              if (!this.baseFs.lstatSync(t).isFile()) {
                this.notZip.add(t);
                continue;
              }
              if (!k(this.baseFs, t)) {
                this.notZip.add(t);
                continue;
              }
              try {
                this.getZipSync(t, () => {});
              } catch {
                this.notZip.add(t);
                continue;
              }
            } catch {
              return null;
            }
            this.isZip.add(t);
          }
          return {
            archivePath: t,
            subPath: this.pathUtils.join(i.PortablePath.root, e.substr(t.length))
          };
        }
      }
      getZipSync(e, t) {
        return super.getZipSync(e, t);
      }
    }
    class S extends i.PosixFS {
      constructor() {
        const e = new w({
          libzip: () => o.getLibzipSync(),
          useCache: true,
          maxOpenFiles: 80,
          readOnlyArchives: true
        });
        super(new i.VirtualFS({
          baseFs: e
        }));
        this._eggZipOpenFS = e;
      }
      isZip(e) {
        return !!this._eggZipOpenFS.findZip(this.mapToBase(e));
      }
    }
    const A = new S();
    class x {
      constructor(e, t, n) {
        this._caseSensitiveDetector = e;
        this._console = t;
        this._fileWatcherProvider = n;
      }
      existsSync(e) {
        if (e.isEmpty() || !g.FileUri.isFileUri(e)) {
          return false;
        }
        const t = e.getFilePath();
        try {
          return A.existsSync(t);
        } catch {
          return false;
        }
      }
      mkdirSync(e, t) {
        const n = e.getFilePath();
        A.mkdirSync(n, t);
      }
      chdir(e) {
        const t = e.getFilePath();
        if (d.isMainThread) {
          process.chdir(t);
        }
      }
      readdirSync(e) {
        const t = e.getFilePath();
        return A.readdirSync(t);
      }
      readdirEntriesSync(e) {
        const t = e.getFilePath();
        return A.readdirSync(t, {
          withFileTypes: true
        }).map(e => C(e.name) && e.isFile() && A.isZip(t) ? {
          name: e.name,
          parentPath: t,
          path: t,
          isFile: () => false,
          isDirectory: () => true,
          isBlockDevice: () => false,
          isCharacterDevice: () => false,
          isSymbolicLink: () => false,
          isFIFO: () => false,
          isSocket: () => false
        } : e);
      }
      readFileSync(e, t = null) {
        const n = e.getFilePath();
        if (t === 'utf8' || t === 'utf-8') {
          return A.readFileSync(n, 'utf8');
        } else {
          return A.readFileSync(n);
        }
      }
      writeFileSync(e, t, n) {
        const a = e.getFilePath();
        A.writeFileSync(a, t, n || undefined);
      }
      statSync(e) {
        if (g.FileUri.isFileUri(e)) {
          const t = e.getFilePath();
          const n = A.statSync(t);
          if (C(t) && n.isFile() && A.isZip(t)) {
            n.isFile = () => false;
            n.isDirectory = () => true;
            n.isZipDirectory = () => true;
            return n;
          } else {
            return n;
          }
        }
        return {
          isFile: () => false,
          isDirectory: () => false,
          isBlockDevice: () => false,
          isCharacterDevice: () => false,
          isSymbolicLink: () => false,
          isFIFO: () => false,
          isSocket: () => false,
          dev: 0,
          atimeMs: 0,
          mtimeMs: 0,
          ctimeMs: 0,
          birthtimeMs: 0,
          size: 0,
          blksize: 0,
          blocks: 0,
          ino: 0,
          mode: 0,
          nlink: 0,
          uid: 0,
          gid: 0,
          rdev: 0,
          atime: new Date(),
          mtime: new Date(),
          ctime: new Date(),
          birthtime: new Date()
        };
      }
      rmdirSync(e) {
        const t = e.getFilePath();
        A.rmdirSync(t);
      }
      unlinkSync(e) {
        const t = e.getFilePath();
        A.unlinkSync(t);
      }
      realpathSync(e) {
        try {
          const t = e.getFilePath();
          return h.Uri.file(A.realpathSync(t), this._caseSensitiveDetector);
        } catch (t) {
          return e;
        }
      }
      getModulePath() {
        return f.getRootUri(this._caseSensitiveDetector) || h.Uri.empty();
      }
      createFileSystemWatcher(e, t) {
        return this._fileWatcherProvider.createFileWatcher(e.map(e => e.getFilePath()), t);
      }
      createReadStream(e) {
        const t = e.getFilePath();
        return A.createReadStream(t);
      }
      createWriteStream(e) {
        const t = e.getFilePath();
        return A.createWriteStream(t);
      }
      copyFileSync(e, t) {
        const n = e.getFilePath();
        const a = t.getFilePath();
        A.copyFileSync(n, a);
      }
      readFile(e) {
        const t = e.getFilePath();
        return A.readFilePromise(t);
      }
      async readFileText(e, t) {
        const n = e.getFilePath();
        if (t === 'utf8' || t === 'utf-8') {
          return A.readFilePromise(n, 'utf8');
        }
        return (await A.readFilePromise(n)).toString(t);
      }
      realCasePath(e) {
        try {
          if (!this.existsSync(e)) {
            return e;
          }
          const t = l.realpathSync.native(e.getFilePath());
          if (e.getFilePath().toLowerCase() !== t.toLowerCase() || y.getRootLength(t) !== y.getRootLength(e.getFilePath())) {
            return e;
          } else {
            return h.Uri.file(t, this._caseSensitiveDetector);
          }
        } catch (t) {
          this._console.log(`Failed to get real file system casing for ${e}: ${t}`);
          return e;
        }
      }
      isMappedUri(e) {
        return false;
      }
      getOriginalUri(e) {
        return e;
      }
      getMappedUri(e) {
        return e;
      }
      isInZip(e) {
        const t = e.getFilePath();
        return /[^\\/]\.(?:egg|zip|jar)[\\/]/.test(t) && A.isZip(t);
      }
    }
    exports.RealFileSystem = x;
    exports.WorkspaceFileWatcherProvider = class {
      constructor() {
        this._fileWatchers = [];
      }
      createFileWatcher(e, t) {
        const n = this;
        const a = {
          close() {
            n._fileWatchers = n._fileWatchers.filter(e => e !== a);
          },
          workspacePaths: e,
          eventHandler: t
        };
        n._fileWatchers.push(a);
        return a;
      }
      onFileChange(e, t) {
        this._fileWatchers.forEach(n => {
          if (n.workspacePaths.some(e => t.getFilePath().startsWith(e))) {
            n.eventHandler(e, t.getFilePath());
          }
        });
      }
    };
    exports.RealTempFile = class {
      constructor() {}
      tmpdir() {
        return h.Uri.file(this._getTmpDir().name, this);
      }
      tmpfile(e) {
        const t = p.fileSync({
          dir: this._getTmpDir().name,
          discardDescriptor: true,
          ...e
        });
        return h.Uri.file(t.name, this);
      }
      mktmpdir() {
        const e = p.dirSync();
        return h.Uri.file(e.name, this);
      }
      dispose() {
        var e;
        try {
          if ((e = this._tmpdir) !== null && e !== undefined) {
            e.removeCallback();
          }
          this._tmpdir = undefined;
        } catch {}
      }
      isCaseSensitive(e) {
        return !e.startsWith(g.FileUriSchema) || this._isLocalFileSystemCaseSensitive();
      }
      _isLocalFileSystemCaseSensitive() {
        if (this._caseSensitivity === undefined) {
          this._caseSensitivity = this._isFileSystemCaseSensitiveInternal();
        }
        return this._caseSensitivity;
      }
      _getTmpDir() {
        if (!this._tmpdir) {
          this._tmpdir = p.dirSync({
            prefix: 'pyright'
          });
        }
        return this._tmpdir;
      }
      _isFileSystemCaseSensitiveInternal() {
        let e;
        try {
          let t;
          let n;
          do {
            t = `${u.randomBytesHex(21)}-a`;
            e = y.combinePaths(this._getTmpDir().name, t);
            n = y.combinePaths(this._getTmpDir().name, t.toUpperCase());
          } while (l.existsSync(e) || l.existsSync(n));
          l.writeFileSync(e, '', 'utf8');
          return !l.existsSync(n);
        } catch (e) {
          return false;
        } finally {
          if (e) {
            try {
              l.unlinkSync(e);
            } catch (e) {}
          }
        }
      }
    };
  },
  71745: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ServiceKeys = undefined;
    const a = require(42856);
    var r;
    (function (e) {
      e.fs = new a.ServiceKey();
      e.console = new a.ServiceKey();
      e.sourceFileFactory = new a.ServiceKey();
      e.partialStubs = new a.ServiceKey();
      e.symbolDefinitionProvider = new a.GroupServiceKey();
      e.symbolUsageProviderFactory = new a.GroupServiceKey();
      e.stateMutationListeners = new a.GroupServiceKey();
      e.tempFile = new a.ServiceKey();
      e.cacheManager = new a.ServiceKey();
      e.debugInfoInspector = new a.ServiceKey();
      e.caseSensitivityDetector = new a.ServiceKey();
      e.docStringService = new a.ServiceKey();
      e.windowService = new a.ServiceKey();
      e.commandService = new a.ServiceKey();
    })(r || (exports.ServiceKeys = r = {}));
  },
  42856: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ServiceProvider = exports.GroupServiceKey = exports.ServiceKey = undefined;
    const i = require(58147);
    const o = __importStar(require(48281));
    class l {}
    exports.ServiceKey = class extends l {
      constructor() {
        super(...arguments);
        this.kind = 'singleton';
      }
    };
    exports.GroupServiceKey = class extends l {
      constructor() {
        super(...arguments);
        this.kind = 'group';
      }
    };
    class p {
      constructor() {
        this._container = new Map();
      }
      add(e, t) {
        if (e.kind !== 'group') {
          if (e.kind !== 'singleton') {
            o.assertNever(e, `Unknown key type ${typeof e}`);
          } else {
            if (t !== undefined) {
              this._container.set(e, t);
            } else {
              this.remove(e);
            }
          }
        } else {
          this._addGroupService(e, t);
        }
      }
      remove(e, t) {
        if (e.kind !== 'group') {
          if (e.kind !== 'singleton') {
            o.assertNever(e, `Unknown key type ${typeof e}`);
          } else {
            this._container.delete(e);
          }
        } else {
          this._removeGroupService(e, t);
        }
      }
      tryGet(e) {
        return this._container.get(e);
      }
      get(e) {
        e.kind;
        const t = this.tryGet(e);
        if (t === undefined) {
          throw new Error(`Global service provider not initialized for ${e.toString()}`);
        }
        return t;
      }
      clone() {
        const e = new p();
        this._container.forEach((t, n) => {
          if (n.kind === 'group') {
            e._container.set(n, [...(t ?? [])]);
          } else {
            if (t.clone !== undefined) {
              e._container.set(n, t.clone());
            } else {
              e._container.set(n, t);
            }
          }
        });
        return e;
      }
      _addGroupService(e, t) {
        const n = this.tryGet(e);
        if (n !== undefined) {
          if (t !== undefined) {
            i.addIfUnique(n, t);
          }
        } else {
          this._container.set(e, [t]);
        }
      }
      _removeGroupService(e, t) {
        const n = this.tryGet(e);
        if (n !== undefined) {
          i.removeArrayElements(n, e => e === t);
        }
      }
    }
    exports.ServiceProvider = p;
  },
  23070: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.createServiceProvider = function (...e) {
      const t = new c.ServiceProvider();
      e.forEach(e => {
        if (d.FileSystem.is(e)) {
          t.add(o.ServiceKeys.fs, e);
        }
        if (p.ConsoleInterface.is(e)) {
          t.add(o.ServiceKeys.console, e);
        }
        if (r.ISourceFileFactory.is(e)) {
          t.add(o.ServiceKeys.sourceFileFactory, e);
        }
        if (i.SupportPartialStubs.is(e)) {
          t.add(o.ServiceKeys.partialStubs, e);
        }
        if (d.TempFile.is(e)) {
          t.add(o.ServiceKeys.tempFile, e);
        }
        if (l.CaseSensitivityDetector.is(e)) {
          t.add(o.ServiceKeys.caseSensitivityDetector, e);
        }
        if (a.CacheManager.is(e)) {
          t.add(o.ServiceKeys.cacheManager, e);
        }
        if (u.DocStringService.is(e)) {
          t.add(o.ServiceKeys.docStringService, e);
        }
        if (m.WindowService.is(e)) {
          t.add(o.ServiceKeys.windowService, e);
        }
        if (m.CommandService.is(e)) {
          t.add(o.ServiceKeys.commandService, e);
        }
      });
      return t;
    };
    const a = require(32720);
    const r = require(60356);
    const s = require(53266);
    const i = require(62226);
    const o = require(71745);
    const l = require(7095);
    const p = require(25075);
    const d = require(66643);
    const c = require(42856);
    const u = require(71458);
    const m = require(1394);
    c.ServiceProvider.prototype.fs = function () {
      return this.get(o.ServiceKeys.fs);
    };
    c.ServiceProvider.prototype.console = function () {
      return this.get(o.ServiceKeys.console);
    };
    c.ServiceProvider.prototype.partialStubs = function () {
      return this.get(o.ServiceKeys.partialStubs);
    };
    c.ServiceProvider.prototype.tmp = function () {
      return this.tryGet(o.ServiceKeys.tempFile);
    };
    c.ServiceProvider.prototype.sourceFileFactory = function () {
      return this.tryGet(o.ServiceKeys.sourceFileFactory) || y;
    };
    c.ServiceProvider.prototype.docStringService = function () {
      return this.tryGet(o.ServiceKeys.docStringService) || new u.PyrightDocStringService();
    };
    c.ServiceProvider.prototype.cacheManager = function () {
      return this.tryGet(o.ServiceKeys.cacheManager);
    };
    const y = {
      createSourceFile: (e, t, n, a, r, i, o, l, p) => new s.SourceFile(e, t, n, a, r, i, o, l, p)
    };
  },
  89740: function (module, exports, require) {
    var __importDefault = this && this.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.computeCompletionSimilarity = function (e, t) {
      if (t.startsWith(e)) {
        return 1;
      }
      const n = t.toLocaleLowerCase();
      const a = e.toLocaleLowerCase();
      if (n.startsWith(a)) {
        return 0.75;
      }
      let s = n.length;
      let i = Number.MAX_VALUE;
      while (s > 0) {
        const e = r.default(n.substr(0, s), a);
        if (e < i) {
          i = e;
        }
        s--;
      }
      if (i >= e.length) {
        return 0;
      }
      return (e.length - i) / e.length * 0.5;
    };
    exports.isPatternInSymbol = function (e, t) {
      const n = e.toLocaleLowerCase();
      const a = t.toLocaleLowerCase();
      const r = n.length;
      const s = a.length;
      let i = 0;
      let o = 0;
      while (i < r && o < s) {
        if (n[i] === a[o]) {
          i += 1;
        }
        o += 1;
      }
      return i === r;
    };
    exports.hashString = function (e) {
      let t = 0;
      for (let n = 0; n < e.length; n++) {
        t = (t << 5) - t + e.charCodeAt(n) | 0;
      }
      return t;
    };
    exports.compareStringsCaseInsensitive = i;
    exports.compareStringsCaseSensitive = o;
    exports.getStringComparer = function (e) {
      if (e) {
        return i;
      } else {
        return o;
      }
    };
    exports.equateStringsCaseInsensitive = function (e, t) {
      return i(e, t) === 0;
    };
    exports.equateStringsCaseSensitive = function (e, t) {
      return o(e, t) === 0;
    };
    exports.getCharacterCount = function (e, t) {
      let n = 0;
      for (let a = 0; a < e.length; a++) {
        if (e[a] === t) {
          n++;
        }
      }
      return n;
    };
    exports.getLastDottedString = function (e) {
      const t = e.lastIndexOf('.');
      if (t > 0) {
        return e.substring(t + 1);
      } else {
        return e;
      }
    };
    exports.truncate = function (e, t) {
      if (e.length > t) {
        return e.substring(0, t - 3) + '...';
      }
      return e;
    };
    exports.escapeRegExp = function (e) {
      return e.replace(/[\\^$.*+?()[\]{}|]/g, '\\$&');
    };
    const r = __importDefault(require(44653));
    const s = require(34455);
    function i(e, t) {
      if (e === t) {
        return 0;
      } else {
        if (e === undefined) {
          return -1;
        } else {
          if (t === undefined) {
            return 1;
          } else {
            return s.compareComparableValues(e.toUpperCase(), t.toUpperCase());
          }
        }
      }
    }
    function o(e, t) {
      return s.compareComparableValues(e, t);
    }
  },
  93779: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TextEditTracker = undefined;
    const i = require(26687);
    const o = require(47610);
    const l = __importStar(require(41557));
    const p = require(58147);
    const d = __importStar(require(48281));
    const c = require(90010);
    const u = require(56814);
    const m = require(88754);
    const y = require(27113);
    exports.TextEditTracker = class {
      constructor(e = true) {
        this._mergeOnlyDuplications = e;
        this._nodesRemoved = new Map();
        this._results = new Map();
        this._pendingNodeToRemove = [];
      }
      addEdits(...e) {
        e.forEach(e => this.addEdit(e.fileUri, e.range, e.replacementText));
      }
      addEdit(e, t, n) {
        const a = p.getOrAdd(this._results, e.key, () => []);
        const r = this._getEditsToMerge(a, t, n);
        if (r.length > 0) {
          this._removeEdits(a, r);
          m.extendRange(t, r.map(e => e.range));
        }
        a.push({
          fileUri: e,
          range: t,
          replacementText: n
        });
      }
      addEditWithTextRange(e, t, n) {
        const a = i.getFileInfo(e.parserOutput.parseTree).fileUri;
        if (e.text.substr(t.start, t.length) !== n) {
          this.addEdit(a, u.convertTextRangeToRange(t, e.tokenizerOutput.lines), n);
        }
      }
      deleteImportName(e, t) {
        const n = t.nodeType === 24 ? t.parent.d.list : t.parent.d.imports;
        const a = i.getFileInfo(e.parserOutput.parseTree).fileUri;
        o.getTextRangeForImportNameDeletion(e, n, n.findIndex(e => e === t)).forEach(t => this.addEditWithTextRange(e, t, ''));
        this._markNodeRemoved(t, e);
        let r = 0;
        for (r = n.length - 1; r >= 0 && this._nodesRemoved.has(n[r]); r--);
        if (r === -1) {
          const n = t.parent;
          if (n) {
            this.addEdit(a, l.getFullStatementRange(n, e), '');
          }
        } else {
          if (r >= 0 && r < n.length - 2) {
            const t = m.TextRange.getEnd(n[r]);
            const a = m.TextRange.getEnd(n[r + 1]) - t;
            this.addEditWithTextRange(e, {
              start: t,
              length: a
            }, '');
          }
        }
      }
      addOrUpdateImport(e, t, n, a, r, s) {
        if (!r || !this._tryUpdateImport(e, t, n, r, s)) {
          this._addImport(e, t, n, a, r);
        }
      }
      removeNodes(...e) {
        this._pendingNodeToRemove.push(...e);
      }
      isNodeRemoved(e) {
        return this._nodesRemoved.has(e);
      }
      getEdits(e) {
        this._processNodeRemoved(e);
        const t = [];
        this._results.forEach(e => p.appendArray(t, e));
        return t;
      }
      _addImport(e, t, n, a, r) {
        const s = i.getFileInfo(e.parserOutput.parseTree).fileUri;
        this.addEdits(...o.getTextEditsForAutoImportInsertion(r ?? [], n, t, a, e, u.convertOffsetToPosition(e.parserOutput.parseTree.length, e.tokenizerOutput.lines)).map(e => ({
          fileUri: s,
          range: e.range,
          replacementText: e.replacementText
        })));
      }
      _tryUpdateImport(e, t, n, a, r) {
        if (!r) {
          return false;
        }
        const s = t.orderedImports.find(e => e.node.nodeType === 25 && (e.moduleName === n.nameForImportFrom || e.moduleName === n.name));
        if (!s || s.node.nodeType !== 25 || s.node.d.isWildcardImport) {
          return false;
        }
        const l = i.getFileInfo(e.parserOutput.parseTree).fileUri;
        const p = o.getTextEditsForAutoImportSymbolAddition(a, s, e);
        if (s.node !== r.currentFromImport) {
          this.addEdits(...p.map(e => ({
            fileUri: l,
            range: e.range,
            replacementText: e.replacementText
          })));
          return true;
        }
        const d = r.originalModuleName.split('.');
        const c = n.name.split('.');
        if (!o.haveSameParentModule(d, c)) {
          return false;
        }
        if (a.length !== 1 || p.length !== 1) {
          return false;
        }
        const m = this._getDeletionsForSpan(l, p[0].range);
        if (m.length === 0) {
          this.addEdit(l, p[0].range, p[0].replacementText);
          return true;
        }
        const y = d[d.length - 1];
        const g = c[c.length - 1];
        const h = a[0].alias === g ? y : a[0].alias;
        const f = r.currentFromImport.d.imports.find(e => {
          var t;
          return e.d.name.d.value === y && ((t = e.d.alias) === null || t === undefined ? undefined : t.d.value) === h;
        });
        return !!f && (this._removeEdits(l, m), f.d.alias && this._nodesRemoved.delete(f.d.alias), this.addEdit(l, u.convertTextRangeToRange(f.d.name, e.tokenizerOutput.lines), g), true);
      }
      _getDeletionsForSpan(e, t) {
        return this._getOverlappingForSpan(e, t).filter(e => e.replacementText === '');
      }
      _removeEdits(e, t) {
        var n;
        if (y.Uri.is(e)) {
          e = (n = this._results.get(e.key)) !== null && n !== undefined ? n : [];
        }
        p.removeArrayElements(e, e => t.some(t => c.FileEditAction.areEqual(e, t)));
      }
      _getEditsToMerge(e, t, n) {
        const a = this._getOverlappingForSpan(e, t);
        if (this._mergeOnlyDuplications && a.length > 0) {
          if (n === '') {
            return a.filter(e => e.replacementText === '');
          } else {
            return a.filter(e => e.replacementText === n && (m.doesRangeContain(t, e.range) || m.doesRangeContain(e.range, t)));
          }
        } else {
          return a.filter(e => e.replacementText === '' || e.replacementText === n && (m.doesRangeContain(t, e.range) || m.doesRangeContain(e.range, t)));
        }
      }
      _getOverlappingForSpan(e, t) {
        var n;
        if (y.Uri.is(e)) {
          e = (n = this._results.get(e.key)) !== null && n !== undefined ? n : [];
        }
        return e.filter(e => m.doRangesIntersect(e.range, t));
      }
      _processNodeRemoved(e) {
        while (this._pendingNodeToRemove.length > 0) {
          const t = this._pendingNodeToRemove.length;
          const n = this._pendingNodeToRemove[this._pendingNodeToRemove.length - 1];
          this._handleImportNameNode(n, e);
          if (this._pendingNodeToRemove.length === t) {
            d.assert(`please add handler for ${n.node.nodeType}`);
            this._pendingNodeToRemove.pop();
            const e = i.getFileInfo(n.parseFileResults.parserOutput.parseTree);
            this.addEdit(e.fileUri, u.convertTextRangeToRange(n.node, e.lines), '');
          }
        }
      }
      _handleImportNameNode(e, t) {
        const n = e.node;
        if (n.nodeType !== 38) {
          return false;
        }
        const a = e.parseFileResults.parserOutput.parseTree;
        const r = i.getFileInfo(a);
        const s = o.getContainingImportStatement(l.findNodeByOffset(a, n.start), t);
        if (!s) {
          return false;
        }
        const p = o.getAllImportNames(s);
        const d = this._pendingNodeToRemove.filter(e => p.some(t => m.TextRange.overlapsRange(e.node, t)));
        if (p.length === d.length) {
          this.addEdit(r.fileUri, l.getFullStatementRange(s, e.parseFileResults), '');
          this._removeNodesHandled(d);
          return true;
        }
        const c = [];
        for (let e = 0; e < p.length; e++) {
          const t = p[e];
          if (d.some(e => m.TextRange.overlapsRange(e.node, t))) {
            c.push(e);
          }
        }
        if (c.length === 0) {
          return false;
        }
        o.getTextRangeForImportNameDeletion(e.parseFileResults, p, ...c).forEach(e => this.addEdit(r.fileUri, u.convertTextRangeToRange(e, r.lines), ''));
        this._removeNodesHandled(d);
        return true;
      }
      _removeNodesHandled(e) {
        e.forEach(e => this._markNodeRemoved(e.node, e.parseFileResults));
        p.removeArrayElements(this._pendingNodeToRemove, e => this._nodesRemoved.has(e.node));
      }
      _markNodeRemoved(e, t) {
        this._nodesRemoved.set(e, t);
        if (e.nodeType === 24) {
          this._nodesRemoved.set(e.d.module, t);
          e.d.module.d.nameParts.forEach(e => this._nodesRemoved.set(e, t));
          if (e.d.alias) {
            this._nodesRemoved.set(e.d.alias, t);
          }
        } else {
          if (e.nodeType === 26) {
            this._nodesRemoved.set(e.d.name, t);
            if (e.d.alias) {
              this._nodesRemoved.set(e.d.alias, t);
            }
          }
        }
      }
    };
  },
  88754: (module, exports) => {
    var n;
    var a;
    var r;
    function s(e, t) {
      if (e.line < t.line) {
        return -1;
      } else {
        if (e.line > t.line) {
          return 1;
        } else {
          if (e.character < t.character) {
            return -1;
          } else {
            if (e.character > t.character) {
              return 1;
            } else {
              return 0;
            }
          }
        }
      }
    }
    function i() {
      return {
        line: 0,
        character: 0
      };
    }
    function o(e, t) {
      return s(e, t) === 0;
    }
    function l(e) {
      return e.character === 0 && e.line === 0;
    }
    function p(e, t) {
      if (t) {
        if (Array.isArray(t)) {
          t.forEach(t => {
            p(e, t);
          });
        } else {
          if (s(t.start, e.start) < 0) {
            e.start = t.start;
          }
          if (s(t.end, e.end) > 0) {
            e.end = t.end;
          }
        }
      }
    }
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Range = exports.Position = exports.TextRange = undefined;
    exports.comparePositions = s;
    exports.getEmptyPosition = i;
    exports.doRangesOverlap = function (e, t) {
      if (s(t.start, e.end) >= 0) {
        return false;
      }
      if (s(e.start, t.end) >= 0) {
        return false;
      }
      return true;
    };
    exports.doRangesIntersect = function (e, t) {
      if (s(t.start, e.end) > 0) {
        return false;
      }
      if (s(e.start, t.end) > 0) {
        return false;
      }
      return true;
    };
    exports.doesRangeContain = function e(t, n) {
      if (a.is(n)) {
        return s(t.start, n) <= 0 && s(t.end, n) >= 0;
      }
      return e(t, n.start) && e(t, n.end);
    };
    exports.positionsAreEqual = o;
    exports.rangesAreEqual = function (e, t) {
      return o(e.start, t.start) && o(e.end, t.end);
    };
    exports.getEmptyRange = function () {
      return {
        start: {
          line: 0,
          character: 0
        },
        end: {
          line: 0,
          character: 0
        }
      };
    };
    exports.isEmptyPosition = l;
    exports.isEmptyRange = function (e) {
      return l(e.start) && l(e.end);
    };
    exports.extendRange = p;
    exports.combineRange = function (e) {
      if (e.length === 0) {
        return;
      }
      const t = e[0];
      for (let n = 1; n < e.length; n++) {
        p(t, e[n]);
      }
      return t;
    };
    (function (e) {
      function t(e, t) {
        if (e < 0) {
          throw new Error('start must be non-negative');
        }
        if (t < 0) {
          throw new Error('length must be non-negative');
        }
        return {
          start: e,
          length: t
        };
      }
      function n(e) {
        return e.start + e.length;
      }
      function a(e, t) {
        return t >= e.start && t <= n(e);
      }
      function r(e, t) {
        let a = e;
        if (t) {
          if (Array.isArray(t)) {
            t.forEach(e => {
              a = r(a, e);
            });
          } else {
            if (t.start < a.start) {
              a = {
                start: t.start,
                length: a.length + a.start - t.start
              };
            }
            const e = n(t);
            const r = n(a);
            if (e > r) {
              a = {
                start: a.start,
                length: a.length + e - r
              };
            }
          }
        }
        return a;
      }
      e.create = t;
      e.fromBounds = function (e, n) {
        if (e < 0) {
          throw new Error('start must be non-negative');
        }
        if (e > n) {
          throw new Error('end must be greater than or equal to start');
        }
        return t(e, n - e);
      };
      e.getEnd = n;
      e.contains = function (e, t) {
        return t >= e.start && t < n(e);
      };
      e.containsRange = function (e, t) {
        return t.start >= e.start && n(t) <= n(e);
      };
      e.overlaps = a;
      e.overlapsRange = function (e, t) {
        return a(e, t.start) || a(t, e.start);
      };
      e.extend = r;
      e.combine = function (e) {
        if (e.length === 0) {
          return;
        }
        let t = {
          start: e[0].start,
          length: e[0].length
        };
        for (let n = 1; n < e.length; n++) {
          t = r(t, e[n]);
        }
        return t;
      };
    })(n || (exports.TextRange = n = {}));
    (function (e) {
      e.is = function (e) {
        const t = e;
        return t && t.line !== undefined && t.character !== undefined;
      };
      e.print = function (e) {
        return `(${e.line}:${e.character})`;
      };
    })(a || (exports.Position = a = {}));
    (function (e) {
      e.is = function (e) {
        const t = e;
        return t && t.start !== undefined && t.end !== undefined;
      };
      e.print = function (e) {
        return `${a.print(e.start)}-${a.print(e.end)}`;
      };
    })(r || (exports.Range = r = {}));
  },
  95418: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TextRangeCollection = undefined;
    exports.getIndexContaining = r;
    const a = require(88754);
    function r(e, t, n = a.TextRange.contains) {
      if (e.length === 0) {
        return -1;
      }
      let r = 0;
      let i = e.length - 1;
      while (r <= i) {
        const o = Math.floor(r + (i - r) / 2);
        const l = s(e, o, r, i);
        if (l === undefined) {
          return -1;
        }
        if (n(l.item, t)) {
          return l.index;
        }
        const p = s(e, o + 1, o + 1, i);
        if (p === undefined) {
          return -1;
        }
        if (o < e.length - 1 && a.TextRange.getEnd(l.item) <= t && t < p.item.start) {
          return -1;
        }
        if (t < l.item.start) {
          i = o - 1;
        } else {
          r = o + 1;
        }
      }
      return -1;
    }
    function s(e, t, n, a) {
      const r = e[t];
      if (r) {
        return {
          index: t,
          item: r
        };
      }
      for (let n = t + 1; n <= a; n++) {
        const t = e[n];
        if (t) {
          return {
            index: n,
            item: t
          };
        }
      }
      for (let a = t - 1; a >= n; a--) {
        const t = e[a];
        if (t) {
          return {
            index: a,
            item: t
          };
        }
      }
    }
    exports.TextRangeCollection = class {
      constructor(e) {
        this._items = e;
      }
      get start() {
        if (this._items.length > 0) {
          return this._items[0].start;
        } else {
          return 0;
        }
      }
      get end() {
        const e = this._items[this._items.length - 1];
        if (this._items.length > 0) {
          return e.start + e.length;
        } else {
          return 0;
        }
      }
      get length() {
        return this.end - this.start;
      }
      get count() {
        return this._items.length;
      }
      contains(e) {
        return e >= this.start && e < this.end;
      }
      getItemAt(e) {
        if (e < 0 || e >= this._items.length) {
          throw new Error('index is out of range');
        }
        return this._items[e];
      }
      getItemAtPosition(e) {
        if (this.count === 0) {
          return -1;
        }
        if (e < this.start) {
          return -1;
        }
        if (e > this.end) {
          return -1;
        }
        let t = 0;
        let n = this.count - 1;
        while (t < n) {
          const a = Math.floor(t + (n - t) / 2);
          const r = this._items[a];
          if (e >= r.start && (a >= this.count - 1 || e < this._items[a + 1].start)) {
            return a;
          }
          if (e < r.start) {
            n = a - 1;
          } else {
            t = a + 1;
          }
        }
        return t;
      }
      getItemContaining(e) {
        if (this.count === 0 || e < this.start || e > this.end) {
          return -1;
        } else {
          return r(this._items, e);
        }
      }
    };
  },
  71582: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.timingStats = exports.TimingStats = exports.TimingStat = exports.Duration = undefined;
    class n {
      constructor() {
        this._startTime = Date.now();
      }
      getDurationInMilliseconds() {
        return Date.now() - this._startTime;
      }
      getDurationInSeconds() {
        return this.getDurationInMilliseconds() / 1000;
      }
    }
    exports.Duration = n;
    class a {
      constructor() {
        this.totalTime = 0;
        this.callCount = 0;
        this.isTiming = false;
      }
      timeOperation(e, ...t) {
        this.callCount++;
        if (this.isTiming) {
          return e(...t);
        }
        {
          this.isTiming = true;
          const a = new n();
          const r = e(...t);
          this.totalTime += a.getDurationInMilliseconds();
          this.isTiming = false;
          return r;
        }
      }
      subtractFromTime(e) {
        if (this.isTiming) {
          this.isTiming = false;
          const t = new n();
          e();
          this.totalTime -= t.getDurationInMilliseconds();
          this.isTiming = true;
        } else {
          e();
        }
      }
      printTime() {
        const e = this.totalTime / 1000;
        return (Math.round(e * 100) / 100).toString() + 'sec';
      }
    }
    exports.TimingStat = a;
    class r {
      constructor() {
        this.totalDuration = new n();
        this.findFilesTime = new a();
        this.readFileTime = new a();
        this.tokenizeFileTime = new a();
        this.parseFileTime = new a();
        this.resolveImportsTime = new a();
        this.cycleDetectionTime = new a();
        this.bindTime = new a();
        this.typeCheckerTime = new a();
        this.typeEvaluationTime = new a();
      }
      printSummary(e) {
        e.info(`Completed in ${this.totalDuration.getDurationInSeconds()}sec`);
      }
      printDetails(e) {
        e.info('');
        e.info('Timing stats');
        e.info(`Find Source Files:    ${this.findFilesTime.printTime()}`);
        e.info(`Read Source Files:    ${this.readFileTime.printTime()}`);
        e.info(`Tokenize:             ${this.tokenizeFileTime.printTime()}`);
        e.info(`Parse:                ${this.parseFileTime.printTime()}`);
        e.info(`Resolve Imports:      ${this.resolveImportsTime.printTime()}`);
        e.info(`Bind:                 ${this.bindTime.printTime()}`);
        e.info(`Check:                ${this.typeCheckerTime.printTime()}`);
        e.info(`Detect Cycles:        ${this.cycleDetectionTime.printTime()}`);
      }
      getTotalDuration() {
        return this.totalDuration.getDurationInSeconds();
      }
    }
    exports.TimingStats = r;
    exports.timingStats = new r();
  },
  33351: (module, exports, require) => {
    let a;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.parse = undefined;
    exports.ensureTomlModuleLoaded = async function () {
      await r;
    };
    const r = (async () => {
      a = await Promise.resolve().then(require.bind(require, 69214));
    })();
    exports.parse = e => {
      if (!a) {
        throw new Error('TOML module not loaded');
      }
      return a.parse(e);
    };
  },
  56426: function (module, exports, require) {
    var a = this && this.__decorate || function (e, t, n, a) {
      var r;
      var s = arguments.length;
      var i = s < 3 ? t : a === null ? a = Object.getOwnPropertyDescriptor(t, n) : a;
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') {
        i = Reflect.decorate(e, t, n, a);
      } else {
        for (var o = e.length - 1; o >= 0; o--) {
          if (r = e[o]) {
            i = (s < 3 ? r(i) : s > 3 ? r(t, n, i) : r(t, n)) || i;
          }
        }
      }
      if (s > 3 && i) {
        Object.defineProperty(t, n, i);
      }
      return i;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.BaseUri = undefined;
    const r = require(58147);
    const s = require(54010);
    const i = require(12365);
    class o {
      constructor(e) {
        this._key = e;
      }
      get key() {
        return this._key;
      }
      get fileNameWithoutExtensions() {
        const e = this.fileName;
        const t = e.lastIndexOf('.');
        if (t > 0) {
          return e.slice(0, t);
        } else {
          return e;
        }
      }
      get packageUri() {
        return this.addExtension('.py');
      }
      get packageStubUri() {
        return this.addExtension('.pyi');
      }
      get initPyUri() {
        return this.combinePathsUnsafe('__init__.py');
      }
      get initPyiUri() {
        return this.combinePathsUnsafe('__init__.pyi');
      }
      get pytypedUri() {
        return this.combinePathsUnsafe('py.typed');
      }
      isEmpty() {
        return false;
      }
      replaceExtension(e) {
        const t = this.getDirectory();
        const n = this.fileName;
        const a = n.slice(0, n.length - this.lastExtension.length) + e;
        return t.combinePathsUnsafe(a);
      }
      addExtension(e) {
        return this.addPath(e);
      }
      hasExtension(e) {
        if (this.isCaseSensitive) {
          return this.lastExtension === e;
        } else {
          return this.lastExtension.toLowerCase() === e.toLowerCase();
        }
      }
      containsExtension(e) {
        return this.fileName.split(/(?=\.)/g).some(t => this.isCaseSensitive ? t === e : t.toLowerCase() === e.toLowerCase());
      }
      getRootPathLength() {
        return this.getRootPath().length;
      }
      isUntitled() {
        return this.scheme === 'untitled';
      }
      equals(e) {
        return this.key === (e == null ? undefined : e.key);
      }
      pathStartsWith(e) {
        return this.getComparablePath().startsWith(e);
      }
      pathEndsWith(e) {
        return this.getComparablePath().endsWith(e);
      }
      pathIncludes(e) {
        return this.getComparablePath().includes(e);
      }
      getRelativePath(e) {
        if (this.scheme === e.scheme && e.isChild(this)) {
          const t = this.getRelativePathComponents(e);
          if (t.length > 0) {
            return ['.', ...t].join('/');
          }
        }
      }
      getPathComponents() {
        return Object.freeze(this.getPathComponentsImpl());
      }
      getRelativePathComponents(e) {
        const t = this.getPathComponents();
        const n = e.getPathComponents();
        let a;
        for (a = 0; a < t.length && a < n.length; a++) {
          const e = t[a];
          const r = n[a];
          if (!(this.isCaseSensitive ? e === r : e.toLowerCase() === r.toLowerCase())) {
            break;
          }
        }
        if (a === 0) {
          return n;
        }
        const r = n.slice(a);
        const s = [];
        for (; a < t.length; a++) {
          s.push('..');
        }
        return [...s, ...r];
      }
      getShortenedFileName(e = 15) {
        return s.getShortenedFileName(this.getPath(), e);
      }
      normalizeSlashes(e) {
        if (e.includes('\\')) {
          return e.replace(/\\/g, '/');
        } else {
          return e;
        }
      }
      static combinePathElements(e, t, ...n) {
        for (const a of n) {
          if (a) {
            if (e && s.getRootLength(a) === 0) {
              if (e.endsWith(t)) {
                e += a;
              } else {
                e += t + a;
              }
            } else {
              e = a;
            }
          }
        }
        return e;
      }
      reducePathComponents(e) {
        if (!r.some(e)) {
          return [];
        }
        const t = [e[0]];
        for (let n = 1; n < e.length; n++) {
          const a = e[n];
          if (a && a !== '.') {
            if (a === '..') {
              if (t.length > 1) {
                if (t[t.length - 1] !== '..') {
                  t.pop();
                  continue;
                }
              } else {
                if (t[0]) {
                  continue;
                }
              }
            }
            t.push(a);
          }
        }
        return t;
      }
    }
    exports.BaseUri = o;
    a([i.cacheProperty()], o.prototype, 'packageUri', null);
    a([i.cacheProperty()], o.prototype, 'packageStubUri', null);
    a([i.cacheProperty()], o.prototype, 'initPyUri', null);
    a([i.cacheProperty()], o.prototype, 'initPyiUri', null);
    a([i.cacheProperty()], o.prototype, 'pytypedUri', null);
  },
  1969: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ConstantUri = undefined;
    const a = require(56426);
    class r extends a.BaseUri {
      constructor(e) {
        super(e);
      }
      get scheme() {
        return '';
      }
      get isCaseSensitive() {
        return true;
      }
      get fileName() {
        return '';
      }
      get lastExtension() {
        return '';
      }
      get root() {
        return this;
      }
      get fragment() {
        return '';
      }
      get query() {
        return '';
      }
      equals(e) {
        return this === e;
      }
      toJsonObj() {
        throw new Error('constant uri can\'t be serialized');
      }
      toString() {
        return this.key;
      }
      toUserVisibleString() {
        return '';
      }
      matchesRegex(e) {
        return false;
      }
      withFragment(e) {
        return this;
      }
      withQuery(e) {
        return this;
      }
      addPath(e) {
        return this;
      }
      getDirectory() {
        return this;
      }
      isRoot() {
        return false;
      }
      isChild(e, t) {
        return false;
      }
      isLocal() {
        return false;
      }
      startsWith(e, t) {
        return false;
      }
      getPathLength() {
        return 0;
      }
      resolvePaths(...e) {
        return this;
      }
      combinePaths(...e) {
        return this;
      }
      combinePathsUnsafe(...e) {
        return this;
      }
      getPath() {
        return '';
      }
      getFilePath() {
        return '';
      }
      stripExtension() {
        return this;
      }
      stripAllExtensions() {
        return this;
      }
      getRootPath() {
        return '';
      }
      getComparablePath() {
        return '';
      }
      getPathComponentsImpl() {
        return [];
      }
    }
    exports.ConstantUri = r;
  },
  27594: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.EmptyUri = undefined;
    const a = require(1969);
    const r = '<empty>';
    class s extends a.ConstantUri {
      constructor() {
        super(r);
      }
      static get instance() {
        return s._instance;
      }
      toJsonObj() {
        return {
          _key: r
        };
      }
      static isEmptyUri(e) {
        return (e == null ? undefined : e._key) === r;
      }
      isEmpty() {
        return true;
      }
      toString() {
        return '';
      }
    }
    exports.EmptyUri = s;
    s._instance = new s();
  },
  16867: function (module, exports, require) {
    var a = this && this.__decorate || function (e, t, n, a) {
      var r;
      var s = arguments.length;
      var i = s < 3 ? t : a === null ? a = Object.getOwnPropertyDescriptor(t, n) : a;
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') {
        i = Reflect.decorate(e, t, n, a);
      } else {
        for (var o = e.length - 1; o >= 0; o--) {
          if (r = e[o]) {
            i = (s < 3 ? r(i) : s > 3 ? r(t, n, i) : r(t, n)) || i;
          }
        }
      }
      if (s > 3 && i) {
        Object.defineProperty(t, n, i);
      }
      return i;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FileUri = exports.FileUriSchema = undefined;
    const r = require(75559);
    const s = require(34455);
    const i = require(54010);
    const o = require(56426);
    const l = require(12365);
    exports.FileUriSchema = 'file';
    class p extends o.BaseUri {
      constructor(e, t, n, a, r, s) {
        super(s ? e : e.toLowerCase());
        this._filePath = t;
        this._query = n;
        this._fragment = a;
        this._originalString = r;
        this._isCaseSensitive = s;
      }
      get scheme() {
        return exports.FileUriSchema;
      }
      get fragment() {
        return this._fragment;
      }
      get query() {
        return this._query;
      }
      get fileName() {
        return i.getFileName(this._filePath);
      }
      get lastExtension() {
        return i.getFileExtension(this._filePath);
      }
      get root() {
        const e = this.getRootPath();
        if (e !== this._filePath) {
          return p.createFileUri(e, '', '', undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      get isCaseSensitive() {
        return this._isCaseSensitive;
      }
      static createFileUri(e, t, n, a, r) {
        e = i.isDiskPathRoot(e) ? i.ensureTrailingDirectorySeparator(e) : e;
        const s = p._createKey(e, t, n);
        return new p(s, e, t, n, a, r);
      }
      static isFileUri(e) {
        return (e == null ? undefined : e._filePath) !== undefined && (e == null ? undefined : e._key) !== undefined;
      }
      static fromJsonObj(e) {
        if (s.isArray(e)) {
          const t = e;
          return p.createFileUri(t[1], t[2], t[3], t[4], t[5] === 1);
        }
        return p.createFileUri(e._filePath, e._query, e._fragment, e._originalString, e._isCaseSensitive);
      }
      toJsonObj() {
        return [0, this._filePath, this._query, this._fragment, this._originalString, this._isCaseSensitive ? 1 : 0];
      }
      matchesRegex(e) {
        return e.test(this._getNormalizedPath());
      }
      toString() {
        if (!this._formattedString) {
          this._formattedString = this._originalString || r.URI.file(this._filePath).with({
            query: this._query,
            fragment: this._fragment
          }).toString();
        }
        return this._formattedString;
      }
      toUserVisibleString() {
        return this._filePath;
      }
      addPath(e) {
        return p.createFileUri(this._filePath + e, '', '', undefined, this._isCaseSensitive);
      }
      isRoot() {
        return i.isDiskPathRoot(this._filePath);
      }
      isChild(e) {
        return !!p.isFileUri(e) && e._filePath.length < this._filePath.length && this.startsWith(e);
      }
      isLocal() {
        return true;
      }
      startsWith(e) {
        if ((e == null ? undefined : e.scheme) !== this.scheme) {
          return false;
        }
        const t = e;
        if (this._filePath.length >= t._filePath.length) {
          const e = this._filePath.length > t._filePath.length && !i.hasTrailingDirectorySeparator(t._filePath) ? i.ensureTrailingDirectorySeparator(t._filePath) : t._filePath;
          if (this.isCaseSensitive) {
            return this._filePath.startsWith(e);
          } else {
            return this._filePath.toLowerCase().startsWith(e.toLowerCase());
          }
        }
        return false;
      }
      getPathLength() {
        return this._filePath.length;
      }
      getPath() {
        return this._getNormalizedPath();
      }
      getFilePath() {
        return this._filePath;
      }
      resolvePaths(...e) {
        let t = i.resolvePaths(this._filePath, ...e);
        if (i.hasTrailingDirectorySeparator(t) && t.length > 1) {
          t = t.slice(0, t.length - 1);
        }
        if (t !== this._filePath) {
          return p.createFileUri(t, '', '', undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      combinePaths(...e) {
        if (e.some(e => e.includes('..') || e.includes(p._separator) || e.includes('/') || e === '.')) {
          return this.resolvePaths(...e);
        } else {
          return this.combinePathsUnsafe(...e);
        }
      }
      combinePathsUnsafe(...e) {
        const t = o.BaseUri.combinePathElements(this._filePath, p._separator, ...e);
        if (t !== this._filePath) {
          return p.createFileUri(t, '', '', undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      getDirectory() {
        const e = this._filePath;
        let t = i.getDirectoryPath(e);
        if (i.hasTrailingDirectorySeparator(t) && t.length > 1) {
          t = t.slice(0, -1);
        }
        if (t !== e) {
          return p.createFileUri(t, '', '', undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      withFragment(e) {
        return p.createFileUri(this._filePath, this._query, e, undefined, this._isCaseSensitive);
      }
      withQuery(e) {
        return p.createFileUri(this._filePath, e, this._fragment, undefined, this._isCaseSensitive);
      }
      stripExtension() {
        const e = i.stripFileExtension(this._filePath);
        if (e !== this._filePath) {
          return p.createFileUri(e, this._query, this._fragment, undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      stripAllExtensions() {
        const e = i.stripFileExtension(this._filePath, true);
        if (e !== this._filePath) {
          return p.createFileUri(e, this._query, this._fragment, undefined, this._isCaseSensitive);
        } else {
          return this;
        }
      }
      getPathComponentsImpl() {
        const e = i.getPathComponents(this._filePath);
        if (e.length > 0 && e[0] === '') {
          e.shift();
        }
        return e.map(e => this.normalizeSlashes(e));
      }
      getRootPath() {
        return this._filePath.slice(0, i.getRootLength(this._filePath));
      }
      getComparablePath() {
        return this._getNormalizedPath();
      }
      static _createKey(e, t, n) {
        return `${e}${t ? `?${t}` : ''}${n ? `#${n}` : ''}`;
      }
      _getNormalizedPath() {
        if (this._normalizedPath === undefined) {
          this._normalizedPath = this.normalizeSlashes(this._filePath);
        }
        return this._normalizedPath;
      }
    }
    exports.FileUri = p;
    p._separator = i.getPathSeparator('');
    a([l.cacheProperty()], p.prototype, 'fileName', null);
    a([l.cacheProperty()], p.prototype, 'lastExtension', null);
    a([l.cacheProperty()], p.prototype, 'root', null);
    a([l.cacheMethodWithNoArgs()], p.prototype, 'getDirectory', null);
    a([l.cacheStaticFunc()], p, 'createFileUri', null);
  },
  12365: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.cacheProperty = function () {
      return function (e, t, n) {
        const a = n.get;
        n.get = function (...e) {
          const n = a.apply(this, e);
          Object.defineProperty(this, t, {
            get: () => n
          });
          return n;
        };
        return n;
      };
    };
    exports.cacheMethodWithNoArgs = function () {
      return function (e, t, n) {
        const a = n.value;
        n.value = function (...e) {
          const n = a.apply(this, e);
          this[t] = () => n;
          return n;
        };
        return n;
      };
    };
    exports.cacheStaticFunc = function () {
      return function (e, t, a) {
        const r = a.value;
        a.value = function (...e) {
          const a = `${t}+${e == null ? undefined : e.map(e => e == null ? undefined : e.toString()).join(',')}`;
          let s;
          if (n.has(a)) {
            s = n.get(a);
          } else {
            s = r.apply(this, e);
            n.set(a, s);
          }
          return s;
        };
        return a;
      };
    };
    const n = new Map();
  },
  27113: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Uri = undefined;
    const a = require(75559);
    const r = require(7095);
    const s = require(34455);
    const i = require(54010);
    const o = require(71745);
    const l = require(1969);
    const p = require(27594);
    const d = require(16867);
    const c = require(25747);
    function u(e) {
      let t;
      t = e.authority && e.path[0] === '/' && e.path.length === 1 ? `//${e.authority}${e.path}` : e.fsPath;
      if (t.match(/^\/[a-zA-Z]:\//)) {
        t = t.slice(1);
      }
      if (process?.platform === 'win32') {
        t = t.replace(/\//g, '\\');
      }
      return t;
    }
    function m(e) {
      const t = a.URI.isUri(e) ? e : a.URI.parse(e);
      const n = t.path.length > 0 ? a.Utils.resolvePath(t) : t;
      const r = n.toString();
      return {
        uri: n,
        str: r
      };
    }
    var y;
    (function (e) {
      e.file = function (e, t, n = false) {
        t = r.CaseSensitivityDetector.is(t) ? t : t.get(o.ServiceKeys.caseSensitivityDetector);
        const s = (e = n && !i.isRootedDiskPath(e) ? i.combinePaths(process.cwd(), e) : e).startsWith('file:') ? m(e) : m(a.URI.file(i.normalizeSlashes(e)));
        return d.FileUri.createFileUri(u(s.uri), s.uri.query, s.uri.fragment, s.str, t.isCaseSensitive(s.str));
      };
      e.parse = function (t, n) {
        if (!t) {
          return e.empty();
        }
        n = r.CaseSensitivityDetector.is(n) ? n : n.get(o.ServiceKeys.caseSensitivityDetector);
        const a = m(t);
        if (a.uri.scheme === d.FileUriSchema) {
          return d.FileUri.createFileUri(u(a.uri), a.uri.query, a.uri.fragment, a.str, n.isCaseSensitive(a.str));
        } else {
          return c.WebUri.createWebUri(a.uri.scheme, a.uri.authority, a.uri.path, a.uri.query, a.uri.fragment, a.str);
        }
      };
      e.constant = function (e) {
        return new l.ConstantUri(e);
      };
      e.empty = function () {
        return p.EmptyUri.instance;
      };
      e.DefaultWorkspaceRootComponent = '<default workspace root>';
      e.DefaultWorkspaceRootPath = `/${e.DefaultWorkspaceRootComponent}`;
      e.defaultWorkspace = function (t) {
        t = r.CaseSensitivityDetector.is(t) ? t : t.get(o.ServiceKeys.caseSensitivityDetector);
        return e.file(e.DefaultWorkspaceRootPath, t);
      };
      e.fromJsonObj = function (e) {
        if (s.isArray(e) && e[0] === 0 || d.FileUri.isFileUri(e)) {
          return d.FileUri.fromJsonObj(e);
        } else {
          if (c.WebUri.isWebUri(e)) {
            return c.WebUri.fromJsonObj(e);
          } else {
            if (p.EmptyUri.isEmptyUri(e)) {
              return p.EmptyUri.instance;
            } else {
              return e;
            }
          }
        }
      };
      e.is = function (e) {
        return !!e && typeof e._key == 'string';
      };
      e.isEmpty = function (e) {
        return !e || e.isEmpty();
      };
      e.equals = function (e, t) {
        var n;
        return e === t || (n = e == null ? undefined : e.equals(t)) !== null && n !== undefined && n;
      };
      e.isDefaultWorkspace = function (t) {
        return t.fileName.includes(e.DefaultWorkspaceRootComponent);
      };
    })(y || (exports.Uri = y = {}));
  },
  5884: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.UriEx = exports.FileSpec = undefined;
    exports.forEachAncestorDirectory = function (e, t) {
      while (true) {
        const n = t(e);
        if (n !== undefined) {
          return n;
        }
        const a = e.getDirectory();
        if (a.equals(e)) {
          return;
        }
        e = a;
      }
    };
    exports.makeDirectories = function (e, t, n) {
      if (!t.startsWith(n)) {
        return;
      }
      const a = t.getPathComponents();
      const r = n.getPathComponents();
      let s = n;
      for (let t = r.length; t < a.length; t++) {
        s = s.combinePaths(a[t]);
        if (!e.existsSync(s)) {
          e.mkdirSync(s);
        }
      }
    };
    exports.getFileSize = function (e, t) {
      const n = d(e, t);
      if (n == null ? undefined : n.isFile()) {
        return n.size;
      }
      return 0;
    };
    exports.fileExists = function (e, t) {
      return y(e, t, 0);
    };
    exports.directoryExists = function (e, t) {
      return y(e, t, 1);
    };
    exports.isDirectory = function (e, t) {
      var n;
      var a;
      return (a = (n = d(e, t)) === null || n === undefined ? undefined : n.isDirectory()) !== null && a !== undefined && a;
    };
    exports.isFile = function (e, t, n = false) {
      var a;
      var r;
      const s = d(e, t);
      if (s == null ? undefined : s.isFile()) {
        return true;
      }
      if (!n) {
        return false;
      }
      return (r = (a = s == null ? undefined : s.isZipDirectory) === null || a === undefined ? undefined : a.call(s)) !== null && r !== undefined && r;
    };
    exports.tryStat = d;
    exports.tryRealpath = function (e, t) {
      try {
        return e.realpathSync(t);
      } catch (e) {
        return;
      }
    };
    exports.getFileSystemEntries = function (e, t) {
      try {
        return c(e.readdirEntriesSync(t), e, t);
      } catch (e) {
        return {
          files: [],
          directories: []
        };
      }
    };
    exports.getFileSystemEntriesFromDirEntries = c;
    exports.getWildcardRegexPattern = u;
    exports.getWildcardRoot = m;
    exports.hasPythonExtension = function (e) {
      return e.hasExtension('.py') || e.hasExtension('.pyi');
    };
    exports.getFileSpec = function (e, t) {
      let n = u(e, t);
      const r = a.getRegexEscapedSeparator('/');
      n = `^(${n})($|${r})`;
      const s = new RegExp(n, e.isCaseSensitive ? undefined : 'i');
      const i = m(e, t);
      const o = a.isDirectoryWildcardPatternPresent(t);
      return {
        wildcardRoot: i,
        regExp: s,
        hasDirectoryWildcard: o
      };
    };
    exports.getDirectoryChangeKind = function (e, t, n) {
      if (t.equals(n)) {
        return 'Same';
      }
      const a = t.getRelativePathComponents(n);
      if (a.length === 2 && a[0] === '..' && a[1] !== '..') {
        return 'Renamed';
      }
      return 'Moved';
    };
    exports.deduplicateFolders = function (e, t = []) {
      const n = new Map();
      e.forEach(e => {
        e.forEach(e => {
          if (!n.has(e.key)) {
            for (const n of t) {
              if (e.startsWith(n)) {
                return;
              }
            }
            for (const t of n) {
              if (e.startsWith(t[1])) {
                return;
              }
              if (t[1].startsWith(e)) {
                n.delete(t[0]);
                n.set(e.key, e);
                return;
              }
            }
            n.set(e.key, e);
          }
        });
      });
      return [...n.values()];
    };
    exports.getRootUri = function (e) {
      e = i.CaseSensitivityDetector.is(e) ? e : e.get(s.ServiceKeys.caseSensitivityDetector);
      if (global.__rootDirectory) {
        return r.Uri.file(global.__rootDirectory, e);
      }
      return;
    };
    exports.convertUriToLspUriString = function (e, t) {
      return e.getOriginalUri(t).toString();
    };
    const a = require(54010);
    const r = require(27113);
    const s = require(71745);
    const i = require(7095);
    const o = /\.pyi?$/;
    var l;
    var p;
    function d(e, t) {
      try {
        if (e.existsSync(t)) {
          return e.statSync(t);
        }
      } catch (e) {
        return;
      }
    }
    function c(e, t, n) {
      const a = e.sort((e, t) => e.name < t.name ? -1 : e.name > t.name ? 1 : 0);
      const r = [];
      const s = [];
      for (const e of a) {
        if (e.name === '.' || e.name === '..') {
          continue;
        }
        const a = n.combinePaths(e.name);
        if (e.isFile()) {
          r.push(a);
        } else {
          if (e.isDirectory()) {
            s.push(a);
          } else {
            if (e.isSymbolicLink()) {
              const e = d(t, a);
              if (e == null ? undefined : e.isFile()) {
                r.push(a);
              } else {
                if (e == null ? undefined : e.isDirectory()) {
                  s.push(a);
                }
              }
            }
          }
        }
      }
      return {
        files: r,
        directories: s
      };
    }
    function u(e, t) {
      const n = e.resolvePaths(t);
      const r = Array.from(n.getPathComponents());
      const s = a.getRegexEscapedSeparator('/');
      const i = `(${s}[^${s}][^${s}]*)*?`;
      const o = new RegExp(`[^\\w\\s${s}]`, 'g');
      if (r.length > 0) {
        r[0] = a.stripTrailingDirectorySeparator(r[0]);
      }
      let l = '';
      let p = true;
      for (let e of r) {
        if (e === '**') {
          l += i;
        } else {
          if (!p) {
            e = s + e;
          }
          l += e.replace(o, e => e === '*' ? `[^${s}]*` : e === '?' ? `[^${s}]` : `\\${e}`);
          p = false;
        }
      }
      return l;
    }
    function m(e, t) {
      const n = e.resolvePaths(t);
      const a = Array.from(n.getPathComponents());
      let r = n.root;
      if (a.length > 0) {
        a.shift();
      }
      for (const e of a) {
        if (e === '**') {
          break;
        }
        if (/[*?]/.test(e)) {
          break;
        }
        r = r.resolvePaths(e);
      }
      return r;
    }
    function y(e, t, n) {
      try {
        const a = e.statSync(t);
        switch (n) {
          case 0:
            return a.isFile();
          case 1:
            return a.isDirectory();
          default:
            return false;
        }
      } catch (e) {
        return false;
      }
    }
    (function (e) {
      e.is = function (e) {
        const t = e;
        return t && !!t.wildcardRoot && !!t.regExp;
      };
      e.isInPath = function (e, t) {
        return !!t.find(t => e.matchesRegex(t.regExp));
      };
      e.matchesIncludeFileRegex = function (e, t = true) {
        return !t || e.matchesRegex(o);
      };
      e.matchIncludeFileSpec = function (t, n, a, r = true) {
        return !!a.matchesRegex(t) && !e.isInPath(a, n) && !!e.matchesIncludeFileRegex(a, r);
      };
    })(l || (exports.FileSpec = l = {}));
    (function (e) {
      e.file = function (e, t, n) {
        const s = a(t);
        return r.Uri.file(e, s, n);
      };
      e.parse = function (e, t) {
        const n = a(t);
        return r.Uri.parse(e, n);
      };
      const t = {
        isCaseSensitive: () => true
      };
      const n = {
        isCaseSensitive: () => false
      };
      function a(e) {
        if (e === undefined || e) {
          return t;
        } else {
          return n;
        }
      }
    })(p || (exports.UriEx = p = {}));
  },
  25747: function (module, exports, require) {
    var a = this && this.__decorate || function (e, t, n, a) {
      var r;
      var s = arguments.length;
      var i = s < 3 ? t : a === null ? a = Object.getOwnPropertyDescriptor(t, n) : a;
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') {
        i = Reflect.decorate(e, t, n, a);
      } else {
        for (var o = e.length - 1; o >= 0; o--) {
          if (r = e[o]) {
            i = (s < 3 ? r(i) : s > 3 ? r(t, n, i) : r(t, n)) || i;
          }
        }
      }
      if (s > 3 && i) {
        Object.defineProperty(t, n, i);
      }
      return i;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.WebUri = undefined;
    const r = require(54010);
    const s = require(56426);
    const i = require(12365);
    const o = require(75559);
    class l extends s.BaseUri {
      constructor(e, t, n, a, r, s, i) {
        super(e);
        this._scheme = t;
        this._authority = n;
        this._path = a;
        this._query = r;
        this._fragment = s;
        this._originalString = i;
      }
      get scheme() {
        return this._scheme;
      }
      get isCaseSensitive() {
        return true;
      }
      get fragment() {
        return this._fragment;
      }
      get query() {
        return this._query;
      }
      get root() {
        const e = this.getRootPath();
        if (e !== this._path) {
          return l.createWebUri(this._scheme, this._authority, e, '', '', undefined);
        } else {
          return this;
        }
      }
      get fileName() {
        const e = this._path.split('/');
        return e[e.length - 1];
      }
      get lastExtension() {
        const e = this.fileName;
        const t = e.lastIndexOf('.');
        if (t >= 0) {
          return e.slice(t);
        } else {
          return '';
        }
      }
      static createWebUri(e, t, n, a, r, s) {
        const i = l._createKey(e, t, n, a, r);
        return new l(i, e, t, n, a, r, s);
      }
      toString() {
        if (!this._originalString) {
          const e = o.URI.revive({
            scheme: this._scheme,
            authority: this._authority,
            path: this._path,
            query: this._query,
            fragment: this._fragment
          });
          this._originalString = e.toString();
        }
        return this._originalString;
      }
      toUserVisibleString() {
        return this.toString();
      }
      static isWebUri(e) {
        return (e == null ? undefined : e._scheme) !== undefined && (e == null ? undefined : e._key) !== undefined;
      }
      static fromJsonObj(e) {
        return l.createWebUri(e._scheme, e._authority, e._path, e._query, e._fragment, e._originalString);
      }
      toJsonObj() {
        return {
          _scheme: this._scheme,
          _authority: this._authority,
          _path: this._path,
          _query: this._query,
          _fragment: this._fragment,
          _originalString: this._originalString,
          _key: this.key
        };
      }
      matchesRegex(e) {
        return e.test(this._path);
      }
      addPath(e) {
        const t = this._path + e;
        return l.createWebUri(this._scheme, this._authority, t, this._query, this._fragment, undefined);
      }
      isRoot() {
        return this._path === this.getRootPath() && this._path.length > 0;
      }
      isChild(e) {
        return !!l.isWebUri(e) && e._path.length < this._path.length && this.startsWith(e);
      }
      isLocal() {
        return false;
      }
      startsWith(e) {
        if ((e == null ? undefined : e.scheme) !== this.scheme) {
          return false;
        }
        const t = e;
        if (this._path.length >= t._path.length) {
          const e = this._path.length > t._path.length && !r.hasTrailingDirectorySeparator(t._path) ? `${t._path}/` : t._path;
          return this._path.startsWith(e);
        }
        return false;
      }
      getPathLength() {
        return this._path.length;
      }
      getPath() {
        return this._path;
      }
      getFilePath() {
        return '';
      }
      resolvePaths(...e) {
        let t = this.normalizeSlashes(r.resolvePaths(this._path, ...e));
        if (r.hasTrailingDirectorySeparator(t) && t.length > 1) {
          t = t.slice(0, t.length - 1);
        }
        if (t !== this._path) {
          return l.createWebUri(this._scheme, this._authority, t, '', '', undefined);
        } else {
          return this;
        }
      }
      combinePaths(...e) {
        if (e.some(e => e.includes('..') || e.includes('/') || e === '.')) {
          return this.resolvePaths(...e);
        } else {
          return this.combinePathsUnsafe(...e);
        }
      }
      combinePathsUnsafe(...e) {
        const t = s.BaseUri.combinePathElements(this._path, '/', ...e);
        if (t !== this._path) {
          return l.createWebUri(this._scheme, this._authority, t, '', '', undefined);
        } else {
          return this;
        }
      }
      getDirectory() {
        if (this._path.length === 0) {
          return this;
        }
        const e = this._path.lastIndexOf('/');
        const t = e > 0 ? this._path.slice(0, e) : e === 0 ? '/' : '';
        return l.createWebUri(this._scheme, this._authority, t, this._query, this._fragment, undefined);
      }
      withFragment(e) {
        return l.createWebUri(this._scheme, this._authority, this._path, this._query, e, undefined);
      }
      withQuery(e) {
        return l.createWebUri(this._scheme, this._authority, this._path, e, this._fragment, undefined);
      }
      stripExtension() {
        const e = this._path;
        const t = e.lastIndexOf('.');
        if (t > 0) {
          return l.createWebUri(this._scheme, this._authority, e.slice(0, t), this._query, this._fragment, undefined);
        } else {
          return this;
        }
      }
      stripAllExtensions() {
        const e = this._path;
        const t = e.lastIndexOf('/');
        const n = e.indexOf('.', t > 0 ? t : 0);
        if (n > 0) {
          return l.createWebUri(this._scheme, this._authority, e.slice(0, n), this._query, this._fragment, undefined);
        } else {
          return this;
        }
      }
      getPathComponentsImpl() {
        const e = this.getRootPath();
        const t = this._path.slice(e.length).split('/');
        return this.reducePathComponents([e, ...t]).map(e => this.normalizeSlashes(e));
      }
      getRootPath() {
        const e = r.getRootLength(this._path, '/');
        return this._path.slice(0, e);
      }
      getComparablePath() {
        return this._path;
      }
      static _createKey(e, t, n, a, r) {
        return `${e}:${t}${n}${a ? `?${a}` : ''}${r ? `#${r}` : ''}`;
      }
    }
    exports.WebUri = l;
    a([i.cacheProperty()], l.prototype, 'root', null);
    a([i.cacheProperty()], l.prototype, 'fileName', null);
    a([i.cacheProperty()], l.prototype, 'lastExtension', null);
    a([i.cacheMethodWithNoArgs()], l.prototype, 'getDirectory', null);
    a([i.cacheStaticFunc()], l, 'createWebUri', null);
  },
  74382: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.convertToTextEdits = function (e) {
      return e.map(e => ({
        range: e.range,
        newText: e.replacementText
      }));
    };
    exports.convertToFileTextEdits = function (e, t) {
      return t.map(t => ({
        fileUri: e,
        ...t
      }));
    };
    exports.convertToWorkspaceEdit = function (e, t, n, r = 'default') {
      if (i.isArray(t)) {
        return function (e, t) {
          const n = {
            changes: {}
          };
          u(e, t, n);
          return n;
        }(e, t);
      }
      return function (e, t, n, r = 'default') {
        const i = {
          documentChanges: [],
          changeAnnotations: n
        };
        for (const n of t.fileOperations) {
          switch (n.kind) {
            case 'create':
              i.documentChanges.push(a.CreateFile.create(c.convertUriToLspUriString(e, n.fileUri), undefined, r));
              break;
            case 'rename':
            case 'delete':
              break;
            default:
              o.assertNever(n);
          }
        }
        const l = s.createMapFromItems(t.edits, t => c.convertUriToLspUriString(e, t.fileUri));
        for (const [e, t] of l) {
          i.documentChanges.push(a.TextDocumentEdit.create({
            uri: e,
            version: null
          }, Array.from(t.map(e => ({
            range: e.range,
            newText: e.replacementText,
            annotationId: r
          })))));
        }
        for (const n of t.fileOperations) {
          switch (n.kind) {
            case 'create':
              break;
            case 'rename':
              i.documentChanges.push(a.RenameFile.create(c.convertUriToLspUriString(e, n.oldFileUri), c.convertUriToLspUriString(e, n.newFileUri), undefined, r));
              break;
            case 'delete':
              i.documentChanges.push(a.DeleteFile.create(c.convertUriToLspUriString(e, n.fileUri), undefined, r));
              break;
            default:
              o.assertNever(n);
          }
        }
        return i;
      }(e, t, n, r);
    };
    exports.appendToWorkspaceEdit = u;
    exports.applyTextEditsToString = function (e, t, n) {
      const a = e.map(e => {
        var a;
        return {
          range: (a = l.convertRangeToTextRange(e.range, t)) !== null && a !== undefined ? a : {
            start: n.length,
            length: 0
          },
          text: e.replacementText
        };
      }).sort((e, t) => {
        const n = t.range.start - e.range.start;
        if (n !== 0) {
          return n;
        } else {
          return p.TextRange.getEnd(t.range) - p.TextRange.getEnd(e.range);
        }
      });
      let r = n;
      for (const e of a) {
        r = r.substr(0, e.range.start) + e.text + r.substr(p.TextRange.getEnd(e.range));
      }
      return r;
    };
    exports.applyWorkspaceEdit = function (e, t, n) {
      if (t.changes) {
        for (const a of Object.entries(t.changes)) {
          const t = d.Uri.parse(a[0], e.serviceProvider);
          const r = e.getSourceFileInfo(t);
          if (r && r.isTracked) {
            m(e, r, a[1]);
            n.set(t.key, t);
          }
        }
      }
      if (t.documentChanges) {
        for (const r of t.documentChanges) {
          if (a.TextDocumentEdit.is(r)) {
            const t = d.Uri.parse(r.textDocument.uri, e.serviceProvider);
            const s = e.getSourceFileInfo(t);
            if (!s || !s.isTracked) {
              continue;
            }
            m(e, s, r.edits.filter(e => a.TextEdit.is(e)));
            n.set(t.key, t);
          }
        }
      }
    };
    exports.applyDocumentChanges = m;
    exports.generateWorkspaceEdit = function (e, t, n, a) {
      var r;
      const s = {
        changes: {}
      };
      for (const i of a.values()) {
        const a = t.backgroundAnalysisProgram.program.getBoundSourceFile(i);
        const o = n.backgroundAnalysisProgram.program.getBoundSourceFile(i);
        if (!a || !o) {
          continue;
        }
        const p = a.getParseResults();
        if (p) {
          s.changes[c.convertUriToLspUriString(e, i)] = [{
            range: l.convertTextRangeToRange(p.parserOutput.parseTree, p.tokenizerOutput.lines),
            newText: (r = o.getFileContent()) !== null && r !== undefined ? r : ''
          }];
        }
      }
      return s;
    };
    const a = require(56911);
    const r = require(55890);
    const s = require(58147);
    const i = require(34455);
    const o = require(48281);
    const l = require(56814);
    const p = require(88754);
    const d = require(27113);
    const c = require(5884);
    function u(e, t, n) {
      t.forEach(t => {
        const a = c.convertUriToLspUriString(e, t.fileUri);
        n.changes[a] = n.changes[a] || [];
        n.changes[a].push({
          range: t.range,
          newText: t.replacementText
        });
      });
    }
    function m(e, t, n) {
      var a;
      var s;
      var i;
      var o;
      if (!t.isOpenByClient) {
        const n = t.sourceFile.getFileContent();
        e.setFileOpened(t.sourceFile.getUri(), 0, n ?? '', {
          isTracked: t.isTracked,
          ipythonMode: t.sourceFile.getIPythonMode(),
          chainedFileUri: (a = t.chainedSourceFile) === null || a === undefined ? undefined : a.sourceFile.getUri()
        });
      }
      const l = (s = t.sourceFile.getClientVersion()) !== null && s !== undefined ? s : 0;
      const p = t.sourceFile.getUri();
      const d = p.getFilePath();
      const c = r.TextDocument.create(d, 'python', l, (i = t.sourceFile.getOpenFileContents()) !== null && i !== undefined ? i : '');
      e.setFileOpened(p, l + 1, r.TextDocument.applyEdits(c, n), {
        isTracked: t.isTracked,
        ipythonMode: t.sourceFile.getIPythonMode(),
        chainedFileUri: (o = t.chainedSourceFile) === null || o === undefined ? undefined : o.sourceFile.getUri()
      });
    }
  },
  92196: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.AnalyzerServiceExecutor = undefined;
    const a = require(16259);
    const r = require(33970);
    const s = require(25463);
    const i = require(25075);
    const o = require(30741);
    class l {
      static runWithOptions(e, t, n) {
        var r;
        const o = function (e, t, n, r, o) {
          var l;
          var p;
          var d;
          var c;
          var u;
          var m;
          var y;
          const g = new s.CommandLineOptions(e, true);
          g.languageServerSettings.checkOnlyOpenFiles = t.openFilesOnly;
          g.configSettings.useLibraryCodeForTypes = t.useLibraryCodeForTypes;
          g.configSettings.typeCheckingMode = t.typeCheckingMode;
          g.languageServerSettings.autoImportCompletions = t.autoImportCompletions;
          g.languageServerSettings.indexing = t.indexing;
          g.languageServerSettings.taskListTokens = t.taskListTokens;
          g.languageServerSettings.logTypeEvaluationTime = (l = t.logTypeEvaluationTime) !== null && l !== undefined && l;
          g.languageServerSettings.typeEvaluationTimeThreshold = (p = t.typeEvaluationTimeThreshold) !== null && p !== undefined ? p : 50;
          g.languageServerSettings.enableAmbientAnalysis = n;
          g.configSettings.pythonEnvironmentName = o;
          g.languageServerSettings.disableTaggedHints = t.disableTaggedHints;
          if (n) {
            g.languageServerSettings.watchForSourceChanges = t.watchForSourceChanges;
            g.languageServerSettings.watchForLibraryChanges = t.watchForLibraryChanges;
            g.languageServerSettings.watchForConfigChanges = t.watchForConfigChanges;
          } else {
            g.languageServerSettings.watchForSourceChanges = false;
            g.languageServerSettings.watchForLibraryChanges = false;
            g.languageServerSettings.watchForConfigChanges = false;
          }
          if (t.venvPath) {
            g.languageServerSettings.venvPath = t.venvPath.getFilePath();
          }
          if (t.pythonPath) {
            if (!a.isPythonBinary(t.pythonPath.getFilePath())) {
              g.languageServerSettings.pythonPath = t.pythonPath.getFilePath();
            }
          }
          if (t.typeshedPath) {
            g.configSettings.typeshedPath = t.typeshedPath.getFilePath();
          }
          if (t.stubPath) {
            g.configSettings.stubPath = t.stubPath.getFilePath();
          }
          if (t.logLevel === i.LogLevel.Log) {
            g.configSettings.verboseOutput = true;
          }
          if (r) {
            g.languageServerSettings.typeStubTargetImportName = r;
          }
          g.configSettings.autoSearchPaths = t.autoSearchPaths;
          g.configSettings.extraPaths = (c = (d = t.extraPaths) === null || d === undefined ? undefined : d.map(e => e.getFilePath())) !== null && c !== undefined ? c : [];
          g.configSettings.diagnosticSeverityOverrides = t.diagnosticSeverityOverrides;
          g.configSettings.diagnosticBooleanOverrides = t.diagnosticBooleanOverrides;
          g.configSettings.includeFileSpecs = (u = t.includeFileSpecs) !== null && u !== undefined ? u : [];
          g.configSettings.excludeFileSpecs = (m = t.excludeFileSpecs) !== null && m !== undefined ? m : [];
          g.configSettings.ignoreFileSpecs = (y = t.ignoreFileSpecs) !== null && y !== undefined ? y : [];
          return g;
        }(e.rootUri, t, (r = n == null ? undefined : n.trackFiles) === null || r === undefined || r, n == null ? undefined : n.typeStubTargetImportName, n == null ? undefined : n.pythonEnvironmentName);
        e.service.setOptions(o);
      }
      static async cloneService(e, t, n) {
        const a = 'cloned service';
        const s = r.getNextServiceId(a);
        n = n ?? {};
        const i = {
          ...t,
          workspaceName: 'temp workspace for cloned service',
          rootUri: t.rootUri,
          kinds: [...t.kinds, o.WellKnownWorkspaceKinds.Cloned],
          service: t.service.clone(a, s, n.useBackgroundAnalysis ? e.createBackgroundAnalysis(s) : undefined, n.fileSystem),
          disableLanguageServices: true,
          disableTaggedHints: true,
          disableOrganizeImports: true,
          disableWorkspaceSymbol: true,
          isInitialized: o.createInitStatus(),
          searchPathsToWatch: []
        };
        const p = await e.getSettings(t);
        l.runWithOptions(i, p, {
          typeStubTargetImportName: n.typeStubTargetImportName,
          trackFiles: false
        });
        return i.service;
      }
    }
    exports.AnalyzerServiceExecutor = l;
  },
  16835: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.AutoImporter = undefined;
    exports.buildModuleSymbolsMap = function (e) {
      const t = new Map();
      e.forEach(e => {
        if (e.shadows.length > 0) {
          return;
        }
        const n = e.sourceFile.getUri();
        const a = e.sourceFile.getModuleSymbolTable();
        if (!a) {
          return;
        }
        const r = m.stripFileExtension(n.fileName);
        if (!p.isPrivateOrProtectedName(r) || !!l.isUserCode(e)) {
          t.set(n.key, {
            uri: n,
            *getSymbols() {
              for (const [t, n] of a) {
                if (!d.isVisibleExternally(n)) {
                  continue;
                }
                const a = n.getDeclarations();
                if (!a || a.length === 0) {
                  continue;
                }
                const r = a[0];
                if (!r) {
                  continue;
                }
                if (r.type === 8 && l.isUserCode(e)) {
                  continue;
                }
                const s = r.type !== 1 || r.isConstant || r.isFinal ? undefined : i.SymbolKind.Variable;
                yield {
                  symbol: {
                    symbol: n,
                    kind: s
                  },
                  name: t,
                  library: !l.isUserCode(e)
                };
              }
            }
          });
        }
      });
      return t;
    };
    exports.convertSymbolKindToCompletionItemKind = f;
    const i = require(56911);
    const o = require(47610);
    const l = require(3433);
    const p = __importStar(require(12097));
    const d = require(4064);
    const c = require(91426);
    const u = require(58147);
    const m = require(54010);
    const y = __importStar(require(89740));
    const g = require(5737);
    const h = require(56412);
    function f(e) {
      switch (e) {
        case i.SymbolKind.File:
          return i.CompletionItemKind.File;
        case i.SymbolKind.Module:
        case i.SymbolKind.Namespace:
          return i.CompletionItemKind.Module;
        case i.SymbolKind.Package:
          return i.CompletionItemKind.Folder;
        case i.SymbolKind.Class:
          return i.CompletionItemKind.Class;
        case i.SymbolKind.Method:
          return i.CompletionItemKind.Method;
        case i.SymbolKind.Property:
          return i.CompletionItemKind.Property;
        case i.SymbolKind.Field:
          return i.CompletionItemKind.Field;
        case i.SymbolKind.Constructor:
          return i.CompletionItemKind.Constructor;
        case i.SymbolKind.Enum:
          return i.CompletionItemKind.Enum;
        case i.SymbolKind.Interface:
          return i.CompletionItemKind.Interface;
        case i.SymbolKind.Function:
          return i.CompletionItemKind.Function;
        case i.SymbolKind.Variable:
        case i.SymbolKind.Array:
          return i.CompletionItemKind.Variable;
        case i.SymbolKind.String:
          return i.CompletionItemKind.Constant;
        case i.SymbolKind.Number:
        case i.SymbolKind.Boolean:
          return i.CompletionItemKind.Value;
        case i.SymbolKind.Constant:
        case i.SymbolKind.Null:
          return i.CompletionItemKind.Constant;
        case i.SymbolKind.Object:
        case i.SymbolKind.Key:
          return i.CompletionItemKind.Value;
        case i.SymbolKind.EnumMember:
          return i.CompletionItemKind.EnumMember;
        case i.SymbolKind.Struct:
          return i.CompletionItemKind.Struct;
        case i.SymbolKind.Event:
          return i.CompletionItemKind.Event;
        case i.SymbolKind.Operator:
          return i.CompletionItemKind.Operator;
        case i.SymbolKind.TypeParameter:
          return i.CompletionItemKind.TypeParameter;
        default:
          return;
      }
    }
    exports.AutoImporter = class {
      constructor(e, t, n, a, r, s, i) {
        this.program = e;
        this.execEnvironment = t;
        this.parseResults = n;
        this._invocationPosition = a;
        this._excludes = r;
        this.moduleSymbolMap = s;
        this.options = i;
        this._importStatements = o.getTopLevelImports(this.parseResults.parserOutput.parseTree, true);
      }
      getAutoImportCandidates(e, t, n, a) {
        const r = [];
        this.getCandidates(e, t, n, a).forEach(e => u.appendArray(r, e));
        return r;
      }
      get importResolver() {
        return this.program.importResolver;
      }
      getCompletionItemData(e) {
        return h.fromLSPAny(e.data);
      }
      getCandidates(e, t, n, a) {
        const r = new Map();
        const s = new Map();
        this.addImportsFromModuleMap(e, t, n, s, r, a);
        this.addImportsFromImportAliasMap(s, n, r, a);
        return r;
      }
      addImportsFromModuleMap(e, t, n, a, r, s) {
        this.moduleSymbolMap.forEach((i, o) => {
          const l = this.getUriProperties(this.moduleSymbolMap, i.uri);
          this.processModuleSymbolTable(i, i.uri, e, t, l, n, a, r, s);
        });
      }
      addImportsFromImportAliasMap(e, t, n, a) {
        c.throwIfCancellationRequested(a);
        e.forEach(e => {
          e.forEach((e, a) => {
            var r;
            var s;
            if (t) {
              if (this._importStatements.mapByFilePath.has(e.importParts.fileUri.key)) {
                return;
              }
              if (e.importParts.importFrom) {
                const t = this._importStatements.orderedImports.find(t => t.moduleName === e.importParts.importFrom);
                if (t && t.node.nodeType === 25 && t.node.d.imports.some(t => t.d.name.d.value === e.importParts.symbolName)) {
                  return;
                }
              }
            }
            if (this._containsName(e.importParts.importName, e.importParts.importFrom, n)) {
              return;
            }
            const i = this._getTextEditsForAutoImportByFilePath({
              name: e.importParts.symbolName,
              alias: t
            }, {
              name: (r = e.importParts.importFrom) !== null && r !== undefined ? r : e.importParts.importName
            }, e.importParts.importName, e.importGroup, e.importParts.fileUri);
            this._addResult(n, {
              name: e.importParts.importName,
              alias: t,
              symbol: e.symbol,
              kind: (s = e.itemKind) !== null && s !== undefined ? s : f(e.kind),
              source: e.importParts.importFrom,
              insertionText: i.insertionText,
              edits: i.edits,
              declUri: e.importParts.fileUri,
              originalName: a,
              originalDeclUri: e.fileUri
            });
          });
        });
      }
      processModuleSymbolTable(e, t, n, a, r, s, o, l, p) {
        var d;
        c.throwIfCancellationRequested(p);
        const [u, m, g] = this._getImportPartsForSymbols(t);
        if (!u) {
          return;
        }
        const h = y.getCharacterCount(u, '.');
        for (const {
          symbol: i,
          name: p
        } of e.getSymbols()) {
          if (!this.shouldIncludeVariable(i, p, r.isStub)) {
            continue;
          }
          if (!this._isSimilar(n, p, a)) {
            continue;
          }
          if (this._containsName(p, u, l)) {
            continue;
          }
          if (i.importAlias) {
            this._addToImportAliasMap(i.importAlias, {
              importParts: {
                symbolName: p,
                importName: p,
                importFrom: u,
                fileUri: t,
                dotCount: h,
                moduleNameAndType: g
              },
              importGroup: m,
              symbol: i.symbol,
              kind: i.importAlias.kind,
              itemKind: i.importAlias.itemKind,
              inDunderAll: i.inDunderAll,
              hasRedundantAlias: i.hasRedundantAlias,
              fileUri: i.importAlias.moduleUri
            }, o);
            continue;
          }
          const e = this.getNameForImportFrom(!r.isUserCode, t);
          const c = this._getTextEditsForAutoImportByFilePath({
            name: p,
            alias: s
          }, {
            name: u,
            nameForImportFrom: e
          }, p, m, t);
          this._addResult(l, {
            name: p,
            alias: s,
            symbol: i.symbol,
            source: u,
            kind: (d = i.itemKind) !== null && d !== undefined ? d : f(i.kind),
            insertionText: c.insertionText,
            edits: c.edits,
            declUri: t,
            originalName: p,
            originalDeclUri: t
          });
        }
        if (!r.isStub && !r.hasInit && !r.isUserCode) {
          return;
        }
        const T = this._getImportParts(t);
        if (!T) {
          return;
        }
        if (!this._isSimilar(n, T.importName, a)) {
          return;
        }
        if (!this._containsName(T.importName, T.importFrom, l)) {
          this._addToImportAliasMap({
            moduleUri: t,
            originalName: T.importName,
            kind: i.SymbolKind.Module,
            itemKind: i.CompletionItemKind.Module
          }, {
            importParts: T,
            importGroup: m,
            kind: i.SymbolKind.Module,
            itemKind: i.CompletionItemKind.Module,
            fileUri: t
          }, o);
        }
      }
      getNameForImportFrom(e, t) {}
      getUriProperties(e, t) {
        const n = t.getDirectory();
        const a = n.initPyUri;
        const r = n.initPyiUri;
        const s = t.hasExtension('.pyi');
        const i = e.has(a.key) || e.has(r.key);
        const o = this.program.getSourceFileInfo(t);
        return {
          isStub: s,
          hasInit: i,
          isUserCode: l.isUserCode(o)
        };
      }
      compareImportAliasData(e, t) {
        const n = e.importGroup - t.importGroup;
        if (n !== 0) {
          return n;
        }
        const a = e.importParts.dotCount - t.importParts.dotCount;
        if (a !== 0) {
          return a;
        } else {
          if (e.symbol && !t.symbol) {
            return -1;
          } else {
            if (!e.symbol && t.symbol) {
              return 1;
            } else {
              return y.getStringComparer()(e.importParts.importName, t.importParts.importName);
            }
          }
        }
      }
      shouldIncludeVariable(e, t, n) {
        return !!n || e.kind !== i.SymbolKind.Variable || p.isPublicConstantOrTypeAlias(t);
      }
      _addToImportAliasMap(e, t, n) {
        if (!n.has(e.moduleUri.key)) {
          const a = new Map();
          a.set(e.originalName, t);
          n.set(e.moduleUri.key, a);
          return;
        }
        const a = n.get(e.moduleUri.key);
        if (!a.has(e.originalName)) {
          a.set(e.originalName, t);
          return;
        }
        const r = a.get(e.originalName);
        if (!(this.compareImportAliasData(r, t) <= 0)) {
          a.set(e.originalName, t);
        }
      }
      _getImportPartsForSymbols(e) {
        const t = this._importStatements.mapByFilePath.get(e.key);
        if (t) {
          return [t.moduleName, o.getImportGroup(t), {
            importType: 2,
            isLocalTypingsFile: false,
            moduleName: t.moduleName
          }];
        }
        {
          const t = this._getModuleNameAndTypeFromFilePath(e);
          return [t.moduleName, o.getImportGroupFromModuleNameAndType(t), t];
        }
      }
      _getImportParts(e) {
        return t(m.stripFileExtension(e.fileName) === '__init__' ? this._getModuleNameAndTypeFromFilePath(e.getDirectory()) : this._getModuleNameAndTypeFromFilePath(e));
        function t(t) {
          const n = t.moduleName;
          if (!n) {
            return;
          }
          const a = n.lastIndexOf('.');
          const r = a > 0 ? n.substring(a + 1) : undefined;
          const s = a > 0 ? n.substring(0, a) : undefined;
          return {
            symbolName: r,
            importName: r ?? n,
            importFrom: s,
            fileUri: e,
            dotCount: y.getCharacterCount(n, '.'),
            moduleNameAndType: t
          };
        }
      }
      _isSimilar(e, t, n) {
        if (n === 1) {
          return e === t;
        }
        if (e.length <= 0 || t.length <= 0) {
          return false;
        }
        if (!this.options.patternMatcher) {
          const n = e[0] !== '_' && t[0] === '_' && t.length > 1 ? 1 : 0;
          return e[0].toLocaleLowerCase() === t[n].toLocaleLowerCase() && y.isPatternInSymbol(e, t);
        }
        return this.options.patternMatcher(e, t);
      }
      _shouldExclude(e) {
        return this._excludes.has(e, e => g.CompletionMap.labelOnlyIgnoringAutoImports(e, this.getCompletionItemData.bind(this)));
      }
      _containsName(e, t, n) {
        if (this._shouldExclude(e)) {
          return true;
        }
        const a = n.get(e);
        return !!(a == null ? undefined : a.some(e => e.source === t));
      }
      _getModuleNameAndTypeFromFilePath(e) {
        return this.importResolver.getModuleNameForImport(e, this.execEnvironment);
      }
      _getTextEditsForAutoImportByFilePath(e, t, n, a, r) {
        var s;
        var i;
        var l;
        var p;
        var d;
        var c;
        var u;
        var m;
        var y;
        const g = this._importStatements.mapByFilePath.get(r.key);
        if (g) {
          if (g.node.nodeType === 23) {
            const t = (i = (s = g.subnode) === null || s === undefined ? undefined : s.d.alias) === null || i === undefined ? undefined : i.d.value;
            if (e.name) {
              return {
                insertionText: `${t ?? g.moduleName}.${e.name}`,
                edits: []
              };
            }
            if (t) {
              return {
                insertionText: `${t}`,
                edits: []
              };
            }
          }
          if (e.name && g.node.nodeType === 25 && !g.node.d.isWildcardImport) {
            const a = g.node.d.imports.find(t => t.d.name.d.value === e.name);
            if (a) {
              const t = (l = a.d.alias) === null || l === undefined ? undefined : l.d.value;
              return {
                insertionText: `${t ?? e.name}`,
                edits: []
              };
            }
            if (t.name === g.moduleName) {
              return {
                insertionText: (p = e.alias) !== null && p !== undefined ? p : n,
                edits: this.options.lazyEdit ? undefined : o.getTextEditsForAutoImportSymbolAddition(e, g, this.parseResults)
              };
            }
          }
        } else {
          if (e.name) {
            const a = this._importStatements.orderedImports.find(e => e.moduleName === t.name);
            if (a && a.node.nodeType === 25 && !a.node.d.isWildcardImport) {
              const t = a.node.d.imports.find(t => t.d.name.d.value === e.name);
              if (!t) {
                return {
                  insertionText: (c = e.alias) !== null && c !== undefined ? c : n,
                  edits: this.options.lazyEdit ? undefined : o.getTextEditsForAutoImportSymbolAddition(e, a, this.parseResults)
                };
              }
              {
                const e = (d = t.d.alias) === null || d === undefined ? undefined : d.d.value;
                if (e) {
                  return {
                    insertionText: `${e}`,
                    edits: []
                  };
                }
              }
            }
            const s = (u = this._importStatements.implicitImports) === null || u === undefined ? undefined : u.get(r.key);
            if (s) {
              const t = (m = s.d.alias) === null || m === undefined ? undefined : m.d.value;
              return {
                insertionText: `${t ?? s.d.name.d.value}.${e.name}`,
                edits: []
              };
            }
          }
        }
        return {
          insertionText: (y = e.alias) !== null && y !== undefined ? y : n,
          edits: this.options.lazyEdit ? undefined : o.getTextEditsForAutoImportInsertion(e, t, this._importStatements, a, this.parseResults, this._invocationPosition)
        };
      }
      _addResult(e, t) {
        let n = e.get(t.name);
        if (!n) {
          n = [];
          e.set(t.name, n);
        }
        n.push(t);
      }
    };
  },
  10518: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CallHierarchyProvider = undefined;
    const i = require(56911);
    const o = __importStar(require(83760));
    const l = __importStar(require(41557));
    const p = require(88744);
    const d = require(3433);
    const c = require(92324);
    const u = require(21024);
    const m = require(91426);
    const y = require(58147);
    const g = require(34455);
    const h = require(56507);
    const f = require(56412);
    const T = require(56814);
    const v = require(71745);
    const b = require(88754);
    const _ = require(27113);
    const C = require(5884);
    const I = require(26005);
    const k = require(67032);
    const w = require(47091);
    exports.CallHierarchyProvider = class {
      constructor(e, t, n, a) {
        this._program = e;
        this._fileUri = t;
        this._position = n;
        this._token = a;
        this._parseResults = this._program.getParseResults(this._fileUri);
      }
      onPrepare() {
        var e;
        m.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const t = this._getDeclaration();
        if (!t || t.declarations.length === 0) {
          return null;
        }
        const {
          targetDecl: n,
          callItemUri: a,
          symbolName: r
        } = this._getTargetDeclaration(t);
        if (n.type !== 5 && n.type !== 6 && n.type !== 8) {
          return null;
        }
        if (n.type === 8) {
          const e = this._evaluator.resolveAliasDeclaration(n, true);
          if (!e) {
            return null;
          }
          if (e.type !== 5 && e.type !== 6) {
            return null;
          }
        }
        const s = {
          name: r,
          kind: (e = f.getSymbolKind(n, this._evaluator, r)) !== null && e !== undefined ? e : i.SymbolKind.Module,
          uri: C.convertUriToLspUriString(this._program.fileSystem, a),
          range: n.range,
          selectionRange: n.range
        };
        if (w.canNavigateToFile(this._program.fileSystem, _.Uri.parse(s.uri, this._program.serviceProvider))) {
          return [s];
        } else {
          return null;
        }
      }
      getIncomingCalls() {
        m.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const e = this._getDeclaration();
        if (!e || e.declarations.length === 0) {
          return null;
        }
        const {
          targetDecl: t,
          symbolName: n
        } = this._getTargetDeclaration(e);
        const a = [];
        const r = t.type === 8 ? [this._program.getSourceFileInfo(this._fileUri)] : this._program.getSourceFileInfoList();
        for (const e of r) {
          if (d.isUserCode(e) || e.isOpenByClient) {
            const r = e.sourceFile.getUri();
            const s = this._getIncomingCallsForDeclaration(r, n, t);
            if (s) {
              y.appendArray(a, s);
            }
            this._program.handleMemoryHighUsage();
          }
        }
        if (a.length === 0) {
          return null;
        } else {
          return a.filter(e => w.canNavigateToFile(this._program.fileSystem, _.Uri.parse(e.from.uri, this._program.serviceProvider)));
        }
      }
      getOutgoingCalls() {
        var e;
        m.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const t = this._getDeclaration();
        if (!t || t.declarations.length === 0) {
          return null;
        }
        const {
          targetDecl: n
        } = this._getTargetDeclaration(t);
        let a;
        const r = this._evaluator.resolveAliasDeclaration(n, true);
        if (!r) {
          return null;
        }
        if (r.type === 5) {
          a = r.node;
        } else {
          if (r.type === 6) {
            const t = (e = this._evaluator.getTypeForDeclaration(r)) === null || e === undefined ? undefined : e.type;
            if (t && u.isInstantiableClass(t)) {
              const e = c.lookUpClassMember(t, '__init__', 22);
              if (e) {
                const t = this._evaluator.getTypeOfMember(e);
                if (t && u.isFunction(t)) {
                  const t = e.symbol.getDeclarations();
                  if (t && t.length > 0) {
                    const e = t[0];
                    if (e.type === 5) {
                      a = e.node;
                    }
                  }
                }
              }
            }
          }
        }
        if (!a) {
          return null;
        }
        const s = new S(this._program.fileSystem, a, this._parseResults, this._evaluator, this._token).findCalls();
        if (s.length === 0) {
          return null;
        } else {
          return s.filter(e => w.canNavigateToFile(this._program.fileSystem, _.Uri.parse(e.to.uri, this._program.serviceProvider)));
        }
      }
      get _evaluator() {
        return this._program.evaluator;
      }
      _getTargetDeclaration(e) {
        const t = e.declarations;
        const n = e.nodeAtOffset;
        let a;
        let r;
        let s = t[0];
        for (const e of t) {
          if ((o.hasTypeForDeclaration(e) || !o.hasTypeForDeclaration(s)) && (e.type === 5 || e.type === 6) && (s = e, e.node === n)) {
            break;
          }
        }
        if (s.type === 8) {
          a = e.nodeAtOffset.d.value;
          r = this._fileUri;
        } else {
          a = o.getNameFromDeclaration(s) || e.symbolNames[0];
          r = s.uri;
        }
        return {
          targetDecl: s,
          callItemUri: r,
          symbolName: a
        };
      }
      _getIncomingCallsForDeclaration(e, t, n) {
        m.throwIfCancellationRequested(this._token);
        const a = new A(this._program, e, t, n, this._token).findCalls();
        if (a.length > 0) {
          return a;
        } else {
          return undefined;
        }
      }
      _getDeclaration() {
        return I.ReferencesProvider.getDeclarationForPosition(this._program, this._fileUri, this._position, undefined, h.ReferenceUseCase.References, this._token);
      }
    };
    class S extends p.ParseTreeWalker {
      constructor(e, t, n, a, r) {
        super();
        this._fs = e;
        this._parseRoot = t;
        this._parseResults = n;
        this._evaluator = a;
        this._cancellationToken = r;
        this._outgoingCalls = [];
      }
      findCalls() {
        this.walk(this._parseRoot);
        return this._outgoingCalls;
      }
      visitCall(e) {
        var t;
        let n;
        m.throwIfCancellationRequested(this._cancellationToken);
        if (e.d.leftExpr.nodeType === 38) {
          n = e.d.leftExpr;
        } else {
          if (e.d.leftExpr.nodeType === 35) {
            n = e.d.leftExpr.d.member;
          }
        }
        if (n) {
          const e = (t = this._evaluator.getDeclInfoForNameNode(n)) === null || t === undefined ? undefined : t.decls;
          if (e) {
            e.forEach(e => {
              this._addOutgoingCallForDeclaration(n, e);
            });
          }
        }
        return true;
      }
      visitMemberAccess(e) {
        m.throwIfCancellationRequested(this._cancellationToken);
        const t = this._evaluator.getType(e.d.leftExpr);
        if (t) {
          c.doForEachSubtype(t, t => {
            let n = t;
            n = this._evaluator.makeTopLevelTypeVarsConcrete(n);
            if (!u.isClassInstance(n)) {
              return;
            }
            const a = c.lookUpObjectMember(n, e.d.member.d.value);
            if (!a) {
              return;
            }
            const r = this._evaluator.getTypeOfMember(a);
            const s = a.symbol.getDeclarations();
            if (r && u.isClassInstance(r) && u.ClassType.isPropertyClass(r)) {
              s.forEach(t => {
                this._addOutgoingCallForDeclaration(e.d.member, t);
              });
            }
          });
        }
        return true;
      }
      _addOutgoingCallForDeclaration(e, t) {
        var n;
        var a;
        const r = this._evaluator.resolveAliasDeclaration(t, true);
        if (!r) {
          return;
        }
        if (r.type !== 5 && r.type !== 6) {
          return;
        }
        const s = {
          name: e.d.value,
          kind: (n = f.getSymbolKind(r, this._evaluator, e.d.value)) !== null && n !== undefined ? n : i.SymbolKind.Module,
          uri: C.convertUriToLspUriString(this._fs, r.uri),
          range: r.range,
          selectionRange: r.range
        };
        let l = this._outgoingCalls.find(e => e.to.uri === s.uri && b.rangesAreEqual(e.to.range, s.range));
        if (!l) {
          l = {
            to: s,
            fromRanges: []
          };
          this._outgoingCalls.push(l);
        }
        if (l && l.to.name !== e.d.value) {
          l.to.name = (a = o.getNameFromDeclaration(r)) !== null && a !== undefined ? a : e.d.value;
        }
        const p = T.convertOffsetsToRange(e.start, e.start + e.length, this._parseResults.tokenizerOutput.lines);
        l.fromRanges.push(p);
      }
    }
    class A extends p.ParseTreeWalker {
      constructor(e, t, n, a, r) {
        var s;
        super();
        this._program = e;
        this._fileUri = t;
        this._symbolName = n;
        this._targetDeclaration = a;
        this._cancellationToken = r;
        this._incomingCalls = [];
        this._declarations = [];
        this._parseResults = this._program.getParseResults(this._fileUri);
        this._usageProviders = ((s = this._program.serviceProvider.tryGet(v.ServiceKeys.symbolUsageProviderFactory)) !== null && s !== undefined ? s : []).map(e => e.tryCreateProvider(h.ReferenceUseCase.References, [this._targetDeclaration], this._cancellationToken)).filter(g.isDefined);
        this._declarations.push(this._targetDeclaration);
        this._usageProviders.forEach(e => e.appendDeclarationsTo(this._declarations));
      }
      findCalls() {
        this.walk(this._parseResults.parserOutput.parseTree);
        return this._incomingCalls;
      }
      visitCall(e) {
        let t;
        m.throwIfCancellationRequested(this._cancellationToken);
        if (e.d.leftExpr.nodeType === 38) {
          t = e.d.leftExpr;
        } else {
          if (e.d.leftExpr.nodeType === 35) {
            t = e.d.leftExpr.d.member;
          }
        }
        if (t && t.d.value === this._symbolName) {
          const e = this._getDeclarations(t);
          if (e) {
            if (this._targetDeclaration.type === 8) {
              const n = this._evaluator.resolveAliasDeclaration(this._targetDeclaration, true);
              if (n && e.some(e => o.areDeclarationsSame(e, n))) {
                this._addIncomingCallForDeclaration(t);
              }
            } else {
              if (e.some(e => this._declarations.some(t => o.areDeclarationsSame(e, t)))) {
                this._addIncomingCallForDeclaration(t);
              }
            }
          }
        }
        return true;
      }
      visitMemberAccess(e) {
        m.throwIfCancellationRequested(this._cancellationToken);
        if (e.d.member.d.value === this._symbolName) {
          const t = this._evaluator.getType(e.d.leftExpr);
          if (t) {
            c.doForEachSubtype(t, t => {
              let n = t;
              n = this._evaluator.makeTopLevelTypeVarsConcrete(n);
              if (!u.isClassInstance(n)) {
                return;
              }
              const a = c.lookUpObjectMember(n, e.d.member.d.value);
              if (!a) {
                return;
              }
              const r = this._evaluator.getTypeOfMember(a);
              const s = a.symbol.getDeclarations();
              if (r && s.some(e => o.areDeclarationsSame(e, this._targetDeclaration))) {
                this._addIncomingCallForDeclaration(e.d.member);
              }
            });
          }
        }
        return true;
      }
      get _evaluator() {
        return this._program.evaluator;
      }
      _getDeclarations(e) {
        const t = k.DocumentSymbolCollector.getDeclarationsForNode(this._program, e, true, this._cancellationToken);
        const n = [...t];
        this._usageProviders.forEach(a => a.appendDeclarationsAt(e, t, n));
        return n;
      }
      _addIncomingCallForDeclaration(e) {
        let t;
        let n = l.getExecutionScopeNode(e);
        while (n && n.nodeType === 76) {
          n = l.getExecutionScopeNode(n);
        }
        if (!n) {
          return;
        }
        if (n.nodeType === 36) {
          const e = T.convertOffsetsToRange(0, 0, this._parseResults.tokenizerOutput.lines);
          const n = this._program.fileSystem.getOriginalUri(this._fileUri).fileName;
          t = {
            name: `(module) ${n}`,
            kind: i.SymbolKind.Module,
            uri: C.convertUriToLspUriString(this._program.fileSystem, this._fileUri),
            range: e,
            selectionRange: e
          };
        } else {
          if (n.nodeType === 33) {
            const e = T.convertOffsetsToRange(n.start, n.start + n.length, this._parseResults.tokenizerOutput.lines);
            t = {
              name: '(lambda)',
              kind: i.SymbolKind.Function,
              uri: C.convertUriToLspUriString(this._program.fileSystem, this._fileUri),
              range: e,
              selectionRange: e
            };
          } else {
            const e = T.convertOffsetsToRange(n.d.name.start, n.d.name.start + n.d.name.length, this._parseResults.tokenizerOutput.lines);
            t = {
              name: n.d.name.d.value,
              kind: i.SymbolKind.Function,
              uri: C.convertUriToLspUriString(this._program.fileSystem, this._fileUri),
              range: e,
              selectionRange: e
            };
          }
        }
        let a = this._incomingCalls.find(e => e.from.uri === t.uri && b.rangesAreEqual(e.from.range, t.range));
        if (!a) {
          a = {
            from: t,
            fromRanges: []
          };
          this._incomingCalls.push(a);
        }
        const r = T.convertOffsetsToRange(e.start, e.start + e.length, this._parseResults.tokenizerOutput.lines);
        a.fromRanges.push(r);
      }
    }
  },
  29512: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CodeActionProvider = undefined;
    const a = require(56911);
    const r = require(91426);
    const s = require(23574);
    const i = require(74382);
    const o = require(67703);
    exports.CodeActionProvider = class {
      static mightSupport(e) {
        return !e || e.length === 0 || e.some(e => e.startsWith(a.CodeActionKind.QuickFix));
      }
      static async getCodeActionsForPosition(e, t, n, l, p) {
        r.throwIfCancellationRequested(p);
        const d = [];
        if (!e.rootUri || e.disableLanguageServices) {
          return d;
        }
        if (!this.mightSupport(l)) {
          return d;
        }
        const c = await e.service.getDiagnosticsForRange(t, n, p);
        const u = c.find(e => {
          const t = e.getActions();
          return t && t.find(e => e.action === 'pyright.createtypestub');
        });
        if (u) {
          const n = u.getActions().find(e => e.action === 'pyright.createtypestub');
          if (n) {
            const r = a.CodeAction.create(o.Localizer.CodeAction.createTypeStubFor().format({
              moduleName: n.moduleName
            }), s.createCommand(o.Localizer.CodeAction.createTypeStub(), 'pyright.createtypestub', e.rootUri.toString(), n.moduleName, t.toString()), a.CodeActionKind.QuickFix);
            d.push(r);
          }
        }
        const m = c.find(e => {
          const t = e.getActions();
          return t && t.find(e => e.action === 'renameShadowedFile');
        });
        if (m) {
          const t = m.getActions().find(e => e.action === 'renameShadowedFile');
          if (t) {
            const n = o.Localizer.CodeAction.renameShadowedFile().format({
              oldFile: t.oldUri.getShortenedFileName(),
              newFile: t.newUri.getShortenedFileName()
            });
            const r = {
              edits: [],
              fileOperations: [{
                kind: 'rename',
                oldFileUri: t.oldUri,
                newFileUri: t.newUri
              }]
            };
            const s = i.convertToWorkspaceEdit(e.service.fs, r);
            const l = a.CodeAction.create(n, s, a.CodeActionKind.QuickFix);
            d.push(l);
          }
        }
        return d;
      }
    };
  },
  5737: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CompletionMap = exports.CompletionProvider = exports.indexValueDetail = exports.autoImportDetail = undefined;
    const i = require(56911);
    const o = __importStar(require(26687));
    const l = require(28445);
    const p = require(83760);
    const d = require(21451);
    const c = require(75130);
    const u = require(44321);
    const m = __importStar(require(41557));
    const y = require(41557);
    const g = require(95952);
    const h = require(3113);
    const f = __importStar(require(12097));
    const T = require(4064);
    const v = require(66308);
    const b = require(30889);
    const _ = require(55501);
    const C = require(21024);
    const I = require(92324);
    const k = require(91426);
    const w = require(58147);
    const S = __importStar(require(48281));
    const A = require(48281);
    const x = require(56412);
    const P = require(56814);
    const D = require(63808);
    require(23070);
    const N = __importStar(require(89740));
    const F = require(88754);
    const E = require(27113);
    const M = require(74382);
    const O = require(67703);
    const z = require(85114);
    const U = require(49969);
    const V = require(16835);
    const R = require(51868);
    const L = require(67032);
    const B = require(39426);
    var j;
    var q;
    (function (e) {
      const t = ['True', 'False', 'None', 'and', 'or', 'not', 'is', 'lambda', 'yield', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'nonlocal', 'pass', 'raise', 'return', 'try', 'type', 'while', 'with'];
      const n = [...t, 'async', 'await'];
      const a = [...n, 'case', 'match'];
      e.forVersion = function (e) {
        if (D.PythonVersion.isGreaterOrEqualTo(e, D.pythonVersion3_10)) {
          return a;
        } else {
          if (D.PythonVersion.isGreaterOrEqualTo(e, D.pythonVersion3_5)) {
            return n;
          } else {
            return t;
          }
        }
      };
    })(j ||= {});
    (function (e) {
      e[e.LikelyKeyword = 0] = 'LikelyKeyword';
      e[e.RecentImportModuleName = 1] = 'RecentImportModuleName';
      e[e.ImportModuleName = 2] = 'ImportModuleName';
      e[e.LiteralValue = 3] = 'LiteralValue';
      e[e.NamedParameter = 4] = 'NamedParameter';
      e[e.RecentKeywordOrSymbol = 5] = 'RecentKeywordOrSymbol';
      e[e.RecentAutoImport = 6] = 'RecentAutoImport';
      e[e.Keyword = 7] = 'Keyword';
      e[e.EnumMember = 8] = 'EnumMember';
      e[e.NormalSymbol = 9] = 'NormalSymbol';
      e[e.PrivateSymbol = 10] = 'PrivateSymbol';
      e[e.DunderSymbol = 11] = 'DunderSymbol';
      e[e.AutoImport = 12] = 'AutoImport';
    })(q ||= {});
    exports.autoImportDetail = O.Localizer.Completion.autoImportDetail();
    exports.indexValueDetail = O.Localizer.Completion.indexValueDetail();
    class G {
      constructor(e, t, n, a, r) {
        this.program = e;
        this.fileUri = t;
        this.position = n;
        this.options = a;
        this.cancellationToken = r;
        this._stringLiteralContainer = undefined;
        this.execEnv = this.configOptions.findExecEnvironment(this.fileUri);
        this.parseResults = this.program.getParseResults(this.fileUri);
        this.sourceMapper = this.program.getSourceMapper(this.fileUri, this.cancellationToken, true);
      }
      getCompletions() {
        if (!this.program.getSourceFileInfo(this.fileUri)) {
          return null;
        }
        const e = this._getCompletions();
        return i.CompletionList.create(e == null ? undefined : e.toArray());
      }
      resolveCompletionItem(e) {
        k.throwIfCancellationRequested(this.cancellationToken);
        const t = this.getCompletionItemData(e);
        const n = e.label;
        let a = '';
        if (t.autoImportText) {
          a = t.autoImportText;
        }
        const r = G._mostRecentCompletions.findIndex(e => e.label === n && e.autoImportText === a);
        if (r > 0) {
          G._mostRecentCompletions = G._mostRecentCompletions.splice(r, 1);
        }
        if (r !== 0) {
          G._mostRecentCompletions.unshift({
            label: n,
            autoImportText: a
          });
        }
        if (G._mostRecentCompletions.length > 128) {
          G._mostRecentCompletions.pop();
        }
        if (t.symbolLabel) {
          if (t.moduleUri && c.ImportResolver.isSupportedImportSourceFile(E.Uri.parse(t.moduleUri, this.program.serviceProvider))) {
            const n = E.Uri.parse(t.moduleUri, this.program.serviceProvider);
            const a = b.getModuleDocStringFromUris([n], this.sourceMapper);
            if (!a) {
              return;
            }
            if (this.options.format === i.MarkupKind.Markdown) {
              const t = this.program.serviceProvider.docStringService().convertDocStringToMarkdown(a, b.isBuiltInModule(n));
              e.documentation = {
                kind: i.MarkupKind.Markdown,
                value: t
              };
            } else {
              if (this.options.format === i.MarkupKind.PlainText) {
                const t = this.program.serviceProvider.docStringService().convertDocStringToPlainText(a);
                e.documentation = {
                  kind: i.MarkupKind.PlainText,
                  value: t
                };
              }
            }
          } else {
            this.itemToResolve = e;
            if (t.autoImportText) {
              if (!e.additionalTextEdits) {
                const e = new W();
                this.addAutoImportCompletions(t.symbolLabel, 1, false, e);
              }
            } else {
              this.getCompletions();
            }
          }
        }
      }
      get evaluator() {
        return this.program.evaluator;
      }
      get importResolver() {
        return this.program.importResolver;
      }
      get configOptions() {
        return this.program.configOptions;
      }
      getCompletionItemData(e) {
        return x.fromLSPAny(e.data);
      }
      getMethodOverrideCompletions(e, t, n) {
        var a;
        var r;
        const s = m.getEnclosingClass(t, true);
        if (!s) {
          return;
        }
        const o = this.evaluator.getTypeOfClass(s);
        if (!o) {
          return;
        }
        const l = new Map();
        for (let e = 1; e < o.classType.shared.mro.length; e++) {
          const t = o.classType.shared.mro[e];
          if (C.isInstantiableClass(t)) {
            I.getMembersForClass(t, l, false);
          }
        }
        const p = (a = n == null ? undefined : n.some(e => m.checkDecorator(e, 'staticmethod'))) !== null && a !== undefined && a;
        const d = (r = n == null ? undefined : n.some(e => m.checkDecorator(e, 'classmethod'))) !== null && r !== undefined && r;
        const c = new W();
        l.forEach((n, a) => {
          var r;
          let s = T.getLastTypedDeclarationForSymbol(n);
          if (s && s.type === 5 && N.isPatternInSymbol(t.d.value, a)) {
            const l = (r = this.evaluator.getTypeForDeclaration(s)) === null || r === undefined ? undefined : r.type;
            if (!l) {
              return;
            }
            let u = C.isClassInstance(l) && C.ClassType.isPropertyClass(l);
            if (f.isDunderName(a)) {
              u = false;
            }
            if (!C.isFunction(l) && !u) {
              return;
            }
            if (u) {
              const e = n.getTypedDeclarations();
              if (e.length > 0 && e[0].type === 5) {
                s = e[0];
              }
            }
            const m = C.isFunction(l) && C.FunctionType.isStaticMethod(l);
            const y = C.isFunction(l) && C.FunctionType.isClassMethod(l) && a !== '__init_subclass__';
            if (p !== m || d !== y) {
              return;
            }
            const g = this._printMethodSignature(o.classType, s);
            let T;
            if (h.isStubFile(this.fileUri)) {
              T = `${g}: ...`;
            } else {
              T = `${g}:\n${this.printOverriddenMethodBody(o.classType, m, u, s, s.node.d.isAsync)}`;
            }
            const v = this.createReplaceEdits(e, t, T);
            this.addSymbol(a, n, t.d.value, c, {
              funcParensDisabled: true,
              edits: {
                format: this.options.snippet ? i.InsertTextFormat.Snippet : undefined,
                textEdit: v
              }
            });
          }
        });
        return c;
      }
      printOverriddenMethodBody(e, t, n, a, r) {
        let s = this.parseResults.tokenizerOutput.predominantTabSequence;
        if (e.shared.baseClasses.length === 1 && C.isClass(e.shared.baseClasses[0]) && e.shared.baseClasses[0].shared.fullName === 'builtins.object') {
          s += this.options.snippet ? '${0:pass}' : 'pass';
          return s;
        }
        if (a.node.d.params.length === 0) {
          s += this.options.snippet ? '${0:pass}' : 'pass';
          return s;
        }
        const i = function (e) {
          const t = [];
          let n = false;
          for (const a of e) {
            if (a.d.name) {
              t.push([a, a.d.category === 0 && !!a.d.name && n]);
            }
            if (a.d.category === 1) {
              n = true;
            }
          }
          return t;
        }(t ? a.node.d.params : a.node.d.params.slice(1));
        if (a.node.d.name.d.value !== '__init__') {
          s += 'return ';
        }
        if (r) {
          s += 'await ';
        }
        if (n) {
          return `${s}super().${a.node.d.name.d.value}`;
        } else {
          return `${s}super().${a.node.d.name.d.value}(${i.map(function (e) {
            var t;
            const n = (t = e[0].d.name) === null || t === undefined ? undefined : t.d.value;
            if (e[0].d.category === 1) {
              return `*${n}`;
            }
            if (e[0].d.category === 2) {
              return `**${n}`;
            }
            if (e[1]) {
              return `${n}=${n}`;
            } else {
              return n;
            }
          }).join(', ')})`;
        }
      }
      createReplaceEdits(e, t, n) {
        const a = (t == null ? undefined : t.nodeType) === 38 ? this.position.character - e.length + t.d.value.length : this.position.character;
        const r = {
          start: {
            line: this.position.line,
            character: this.position.character - e.length
          },
          end: {
            line: this.position.line,
            character: a
          }
        };
        return i.TextEdit.replace(r, n);
      }
      shouldProcessDeclaration(e) {
        return true;
      }
      addSymbol(e, t, n, a, r) {
        var s;
        var o;
        var l;
        var p;
        this.program.handleMemoryHighUsage();
        let d = T.getLastTypedDeclarationForSymbol(t);
        if (!d) {
          const e = t.getDeclarations();
          if (e.length > 0) {
            d = e[e.length - 1];
          }
        }
        if (!this.shouldProcessDeclaration(d)) {
          return;
        }
        d = d ? (s = this.evaluator.resolveAliasDeclaration(d, true)) !== null && s !== undefined ? s : d : undefined;
        const c = r.autoImportSource ? this.getAutoImportText(e, r.autoImportSource, r.autoImportAlias) : undefined;
        if (this.itemToResolve) {
          const n = this.getCompletionItemData(this.itemToResolve);
          if (n.symbolLabel !== e) {
            return;
          }
          if (this.itemToResolve.additionalTextEdits === undefined && ((o = r.edits) === null || o === undefined ? undefined : o.additionalTextEdits) !== undefined) {
            this.itemToResolve.additionalTextEdits = M.convertToTextEdits(r.edits.additionalTextEdits);
          }
          if (n.autoImportText) {
            return;
          }
          const a = this.evaluator.getEffectiveTypeOfSymbol(t);
          if (!a) {
            return;
          }
          const s = R.getTypeDetail(this.evaluator, a, d, e, r, this.configOptions.functionSignatureDisplay);
          const l = B.getDocumentationPartsForTypeAndDecl(this.sourceMapper, a, d, this.evaluator, {
            name: e,
            symbol: t,
            boundObjectOrClass: r.boundObjectOrClass
          });
          if (this.options.format === i.MarkupKind.Markdown || this.options.format === i.MarkupKind.PlainText) {
            this.itemToResolve.documentation = R.getCompletionItemDocumentation(this.program.serviceProvider, s, l, this.options.format, d);
          } else {
            A.fail(`Unsupported markup type: ${this.options.format}`);
          }
        } else {
          if (d) {
            let t = this._convertDeclarationTypeToItemKind(d);
            if (this._isEnumMember(r.boundObjectOrClass, e)) {
              t = i.CompletionItemKind.EnumMember;
            }
            this.addNameToCompletions((l = r.autoImportAlias) !== null && l !== undefined ? l : e, t, n, a, {
              autoImportText: c,
              extraCommitChars: r.extraCommitChars,
              funcParensDisabled: r.funcParensDisabled,
              edits: r.edits
            });
          } else {
            const s = (p = t.getSynthesizedType()) === null || p === undefined ? undefined : p.type;
            if (s) {
              const t = this._convertTypeToItemKind(s);
              this.addNameToCompletions(e, t, n, a, {
                extraCommitChars: r.extraCommitChars,
                funcParensDisabled: r.funcParensDisabled,
                edits: r.edits
              });
            }
          }
        }
      }
      getMemberAccessCompletions(e, t) {
        const n = new Map();
        const a = new W();
        let r = this.evaluator.getType(e);
        if (r) {
          r = this.evaluator.makeTopLevelTypeVarsConcrete(r);
          if (C.isUnknown(r) && r.priv.possibleType) {
            r = this.evaluator.makeTopLevelTypeVarsConcrete(r.priv.possibleType);
          }
          I.doForEachSubtype(r, r => {
            r = this.evaluator.makeTopLevelTypeVarsConcrete(r);
            if (C.isClass(r)) {
              const e = C.TypeBase.isInstance(r);
              I.getMembersForClass(r, n, e);
              if (C.ClassType.isEnumClass(r) && e) {
                for (const e of n.keys()) {
                  if (this._isEnumMember(r, e)) {
                    n.delete(e);
                  }
                }
              }
            } else {
              if (C.isModule(r)) {
                I.getMembersForModule(r, n);
              } else {
                if (C.isFunction(r) || C.isOverloaded(r)) {
                  const t = this.evaluator.getBuiltInType(e, 'function');
                  if (t && C.isInstantiableClass(t)) {
                    I.getMembersForClass(t, n, true);
                  }
                } else {
                  if (I.isNoneInstance(r)) {
                    const t = this.evaluator.getBuiltInType(e, 'object');
                    if (t && C.isInstantiableClass(t)) {
                      I.getMembersForClass(t, n, C.TypeBase.isInstance(r));
                    }
                  }
                }
              }
            }
            this._addSymbolsForSymbolTable(n, () => true, t, e, false, C.isClass(r) ? r : undefined, a);
          });
          return a;
        } else {
          return a;
        }
      }
      createAutoImporter(e, t) {
        const n = this.program.getSourceFileInfo(this.fileUri);
        const a = V.buildModuleSymbolsMap(this.program.getSourceFileInfoList().filter(e => e !== n));
        return new V.AutoImporter(this.program, this.execEnv, this.parseResults, this.position, e, a, {
          lazyEdit: t
        });
      }
      addAutoImportCompletions(e, t, n, a, r) {
        if (!this.configOptions.autoImportCompletions) {
          return;
        }
        const s = this.createAutoImporter(a, n);
        const i = [];
        w.appendArray(i, s.getAutoImportCandidates(e, t, undefined, this.cancellationToken));
        this.addImportResults(i, e, a, r);
      }
      addImportResults(e, t, n, a) {
        var r;
        var s;
        for (const o of e) {
          if (o.symbol) {
            this.addSymbol(o.name, o.symbol, t, n, {
              extraCommitChars: true,
              autoImportSource: o.source,
              autoImportAlias: o.alias,
              edits: {
                textEdit: this.createReplaceEdits(t, undefined, o.insertionText),
                additionalTextEdits: o.edits
              },
              funcParensDisabled: a
            });
          } else {
            this.addNameToCompletions((r = o.alias) !== null && r !== undefined ? r : o.name, (s = o.kind) !== null && s !== undefined ? s : i.CompletionItemKind.Module, t, n, {
              extraCommitChars: true,
              autoImportText: this.getAutoImportText(o.name, o.source, o.alias),
              edits: {
                textEdit: this.createReplaceEdits(t, undefined, o.insertionText),
                additionalTextEdits: o.edits
              },
              funcParensDisabled: a
            });
          }
        }
      }
      addExtraCommitChar(e) {}
      addNameToCompletions(e, n, a, r, s) {
        var o;
        var l;
        var p;
        var d;
        if (!(s == null ? undefined : s.autoImportText) && !N.isPatternInSymbol(a, e)) {
          return;
        }
        if (r.has(e, e => W.matchKindAndImportText(e, this.getCompletionItemData.bind(this)), n, (o = s == null ? undefined : s.autoImportText) === null || o === undefined ? undefined : o.importText)) {
          return;
        }
        const c = i.CompletionItem.create(e);
        c.kind = n;
        if (s == null ? undefined : s.extraCommitChars) {
          this.addExtraCommitChar(c);
        }
        const u = {
          uri: this.fileUri.toString(),
          position: this.position
        };
        if (!!(s == null ? undefined : s.funcParensDisabled) || !this.options.snippet) {
          u.funcParensDisabled = true;
        }
        if (s == null ? undefined : s.moduleUri) {
          u.moduleUri = s.moduleUri.toString();
        }
        c.data = x.toLSPAny(u);
        if ((s == null ? undefined : s.sortText) || (s == null ? undefined : s.itemDetail)) {
          c.sortText = s.sortText;
          c.detail = s.itemDetail;
        } else {
          if (s == null ? undefined : s.autoImportText) {
            c.sortText = this._makeSortText(q.AutoImport, `${e}.${this._formatInteger(s.autoImportText.source.length, 2)}.${s.autoImportText.source}`, s.autoImportText.importText);
            u.autoImportText = s.autoImportText.importText;
            c.detail = exports.autoImportDetail;
            if (s.autoImportText.source) {
              c.labelDetails = {
                description: s.autoImportText.source
              };
            }
          } else {
            if (n === i.CompletionItemKind.EnumMember) {
              c.sortText = this._makeSortText(q.EnumMember, e);
            } else {
              if (f.isDunderName(e)) {
                c.sortText = this._makeSortText(q.DunderSymbol, e);
              } else {
                if (a === '' && f.isPrivateOrProtectedName(e)) {
                  c.sortText = this._makeSortText(q.PrivateSymbol, e);
                } else {
                  c.sortText = this._makeSortText(q.NormalSymbol, e);
                }
              }
            }
          }
        }
        u.symbolLabel = e;
        if (this.options.format === i.MarkupKind.Markdown) {
          let e = '';
          if (s == null ? undefined : s.autoImportText) {
            e += s.autoImportText.importText;
            if (s.typeDetail || s.documentation) {
              e += '\n\n';
            }
          }
          if (s == null ? undefined : s.typeDetail) {
            e += `\`\`\`python
${s.typeDetail}
\`\`\`
`;
          }
          if (s == null ? undefined : s.documentation) {
            e += '---\n';
            e += this.program.serviceProvider.docStringService().convertDocStringToMarkdown(s.documentation, b.isBuiltInModule(s.moduleUri));
          }
          e = e.trimEnd();
          if (e) {
            c.documentation = {
              kind: i.MarkupKind.Markdown,
              value: e
            };
          }
        } else {
          if (this.options.format === i.MarkupKind.PlainText) {
            let e = '';
            if (s == null ? undefined : s.autoImportText) {
              e += s.autoImportText.importText;
              if (s.typeDetail || s.documentation) {
                e += '\n\n';
              }
            }
            if (s == null ? undefined : s.typeDetail) {
              e += s.typeDetail + '\n';
            }
            if (s == null ? undefined : s.documentation) {
              e += `
${this.program.serviceProvider.docStringService().convertDocStringToPlainText(s.documentation)}`;
            }
            e = e.trimEnd();
            if (e) {
              c.documentation = {
                kind: i.MarkupKind.PlainText,
                value: e
              };
            }
          } else {
            A.fail(`Unsupported markup type: ${this.options.format}`);
          }
        }
        if ((l = s == null ? undefined : s.edits) === null || l === undefined ? undefined : l.format) {
          c.insertTextFormat = s.edits.format;
        }
        if ((p = s == null ? undefined : s.edits) === null || p === undefined ? undefined : p.textEdit) {
          c.textEdit = s.edits.textEdit;
        }
        if (((d = s == null ? undefined : s.edits) === null || d === undefined ? undefined : d.additionalTextEdits) && (c.additionalTextEdits = M.convertToTextEdits(s.edits.additionalTextEdits), this.itemToResolve)) {
          if (this.getCompletionItemData(this.itemToResolve).autoImportText === u.autoImportText) {
            this.itemToResolve.additionalTextEdits = c.additionalTextEdits;
          }
        }
        r.set(c);
      }
      getAutoImportText(e, t, n) {
        const a = B.getAutoImportText(e, t, n);
        let r = '';
        if (this.options.format === i.MarkupKind.Markdown) {
          r = `\`\`\`\n${a}\n\`\`\``;
        } else {
          if (this.options.format === i.MarkupKind.PlainText) {
            r = a;
          } else {
            A.fail(`Unsupported markup type: ${this.options.format}`);
          }
        }
        return {
          source: t ?? '',
          importText: r
        };
      }
      get _fileContents() {
        var e;
        var t;
        if ((t = (e = this.parseResults) === null || e === undefined ? undefined : e.text) !== null && t !== undefined) {
          return t;
        } else {
          return '';
        }
      }
      _getCompletions() {
        var e;
        var t;
        const n = P.convertPositionToOffset(this.position, this.parseResults.tokenizerOutput.lines);
        if (n === undefined) {
          return;
        }
        let a = m.findNodeByOffset(this.parseResults.parserOutput.parseTree, n);
        const r = m.getTokenOverlapping(this.parseResults.tokenizerOutput.tokens, n);
        if ((r == null ? undefined : r.type) === 5) {
          const e = r;
          this._stringLiteralContainer = F.TextRange.contains(e, n) || e.flags & 65536 ? e : undefined;
        } else {
          if (a) {
            const e = m.getParentNodeOfType(a, 30);
            if (e) {
              this._stringLiteralContainer = e.d.token;
            }
          }
        }
        const s = a;
        const i = a ? m.getNodeDepth(a) : 0;
        if (!s || s.nodeType !== 38) {
          let t = n;
          let r = false;
          while (t >= 0) {
            t--;
            const n = this._fileContents.substr(t, 1);
            if (n === '(' || n === '\n' || n === '}') {
              break;
            }
            if (n === ',') {
              r = true;
            }
            const o = m.findNodeByOffset(this.parseResults.parserOutput.parseTree, t);
            if (o && o !== s) {
              if (m.getNodeDepth(o) > i) {
                a = o;
                if (r && ((e = a.parent) === null || e === undefined ? undefined : e.nodeType) === 26) {
                  a = a.parent;
                }
              }
              break;
            }
          }
        }
        if (a === undefined) {
          return;
        }
        const o = this.parseResults.tokenizerOutput.lines.getItemAt(this.position.line);
        const l = this._fileContents.substr(o.start, o.length);
        const p = l.substr(0, this.position.character);
        const d = l.substr(this.position.character);
        const c = p.search(/\w+$/);
        const u = c >= 0 ? p.substr(c) : '';
        if (this._isWithinComment(n)) {
          return;
        }
        let y = a;
        while (y && y.nodeType !== 0) {
          y = y.parent;
        }
        let g = y || a;
        while (true) {
          k.throwIfCancellationRequested(this.cancellationToken);
          if (g.nodeType === 49) {
            return this._getLiteralCompletions(g, n, u, p, d);
          }
          if (g.nodeType === 48 || g.nodeType === 30) {
            return;
          }
          if (g.nodeType === 37) {
            return this._getImportModuleCompletions(g);
          }
          if (g.nodeType === 0) {
            return this._getExpressionErrorCompletions(g, n, u, p, d);
          }
          if (g.nodeType === 35) {
            return this.getMemberAccessCompletions(g.d.leftExpr, u);
          }
          if (g.nodeType === 18) {
            const e = new W();
            if (this._tryAddTypedDictKeysFromDictionary(g, undefined, u, p, d, e)) {
              return e;
            }
          }
          const e = m.getFirstAncestorOrSelfOfKind(g, 20);
          if (e && ((t = e.parent) === null || t === undefined ? undefined : t.nodeType) === 18) {
            const t = e.parent;
            if (t.d.trailingCommaToken && t.d.trailingCommaToken.start < n) {
              const e = new W();
              if (this._tryAddTypedDictKeysFromDictionary(t, undefined, u, p, d, e)) {
                return e;
              }
            }
          }
          if (g.nodeType === 38) {
            const e = this._tryGetNameCompletions(g, n, u, p, d);
            if (e || e === undefined) {
              return e;
            }
          }
          if (g.nodeType === 34 && this.options.triggerCharacter === '[') {
            return;
          }
          if (g.nodeType === 25) {
            return this._getImportFromCompletions(g, n, u);
          }
          if (z.isExpressionNode(g)) {
            return this._getExpressionCompletions(g, u, p, d);
          }
          if (g.nodeType === 50) {
            if (g.parent && g.parent.nodeType === 28 && !g.parent.d.name && g.parent.d.typeExpr && F.TextRange.getEnd(g.parent.d.typeExpr) < n && n <= g.parent.d.exceptSuite.start) {
              return;
            }
            if (g.parent && g.parent.nodeType === 10 && (!g.parent.d.name || !g.parent.d.name.d.value) && g.parent.d.arguments.length === 0 && n <= g.parent.d.suite.start) {
              return;
            }
            return this._getStatementCompletions(g, u, p, d);
          }
          if (g.nodeType === 36) {
            return this._getStatementCompletions(g, u, p, d);
          }
          if (g.nodeType === 41 && g.length === 0 && g.parent && g.parent.nodeType === 33) {
            return;
          }
          if (!g.parent) {
            break;
          }
          g = g.parent;
        }
      }
      _tryGetNameCompletions(e, t, n, a, r) {
        var s;
        var i;
        var o;
        var p;
        if (!e.parent) {
          return false;
        }
        if (e.parent.nodeType !== 24 || e.parent.d.alias !== e) {
          if (e.parent.nodeType === 37) {
            if (e.parent.parent && e.parent.parent.nodeType === 24 && !e.parent.parent.d.alias && F.TextRange.getEnd(e.parent.parent) < t) {
              return;
            }
            return this._getImportModuleCompletions(e.parent);
          }
          if (e.parent.nodeType === 26) {
            if (e.parent.d.alias === e) {
              return;
            }
            const a = e.parent.parent;
            if (a && a.nodeType === 25) {
              if (!e.parent.d.alias && F.TextRange.getEnd(e.parent) < t) {
                return;
              }
              if (e.parent.d.name === e) {
                return this._getImportFromCompletions(a, t, n);
              } else {
                return this._getImportFromCompletions(a, t, '');
              }
            }
            return false;
          }
          if (e.parent.nodeType === 35 && e === e.parent.d.member) {
            return this.getMemberAccessCompletions(e.parent.d.leftExpr, n);
          }
          if (e.parent.nodeType !== 28 || e !== e.parent.d.name) {
            if (e.parent.nodeType === 31 && e === e.parent.d.name) {
              if ((s = e.parent.d.decorators) === null || s === undefined ? undefined : s.some(e => this._isOverload(e))) {
                return this._getMethodOverloadsCompletions(n, e);
              } else {
                return undefined;
              }
            }
            if ((e.parent.nodeType !== 41 || e !== e.parent.d.name) && (e.parent.nodeType !== 10 || e !== e.parent.d.name) && (e.parent.nodeType !== 29 || !F.TextRange.contains(e.parent.d.targetExpr, e.start)) && (e.parent.nodeType !== 12 || !F.TextRange.contains(e.parent.d.targetExpr, e.start))) {
              if (e.parent.nodeType === 3 || e.parent.nodeType === 4) {
                if ((e.parent.nodeType === 4 ? e.parent.d.name : e.parent.d.leftExpr) !== e || n.length === 0) {
                  return false;
                }
                const t = (i = this.evaluator.getDeclInfoForNameNode(e)) === null || i === undefined ? undefined : i.decls;
                if ((t == null ? undefined : t.length) !== 1 || !l.isVariableDeclaration(t[0]) || t[0].node !== e) {
                  return false;
                }
                const s = this._getExpressionCompletions(e, n, a, r);
                if (s) {
                  s.delete(e.d.value);
                }
                return s;
              }
              if (e.parent.nodeType === 47 && ((o = e.parent.parent) === null || o === undefined ? undefined : o.nodeType) === 50 && ((p = e.parent.parent.parent) === null || p === undefined ? undefined : p.nodeType) === 10) {
                const t = this._getClassVariableCompletions(e);
                if (t) {
                  return t;
                }
              }
              return false;
            }
          }
        }
      }
      _isWithinComment(e) {
        var t;
        var n;
        const a = function (e, t) {
          const n = t.getItemAtPosition(e);
          if (n < 0) {
            return;
          }
          let a = t.getItemAt(n);
          if (e > a.start && e < a.start + a.length) {
            return;
          }
          for (let e = n - 1; e >= 0; e--) {
            const n = t.getItemAt(e);
            if (a.start !== n.start) {
              break;
            }
            a = n;
          }
          if (e <= a.start) {
            return a;
          }
          S.assert(n + 1 < t.length);
          return t.getItemAt(n + 1);
        }(e, this.parseResults.tokenizerOutput.tokens);
        return !!a && (n = (t = a.comments) === null || t === undefined ? undefined : t.some(t => F.TextRange.overlaps(t, e))) !== null && n !== undefined && n;
      }
      _getExpressionErrorCompletions(e, t, n, a, r) {
        var s;
        switch (e.d.category) {
          case 0:
            return this._createSingleKeywordCompletion('in');
          case 1:
            return this._createSingleKeywordCompletion('else');
          case 7:
          case 2:
            {
              const t = this.parseResults.tokenizerOutput;
              const s = P.convertPositionToOffset(this.position, t.lines);
              const i = m.getTokenIndexAtLeft(t.tokens, s);
              const o = m.getTokenAtIndex(t.tokens, i);
              const l = m.getTokenAtIndex(t.tokens, i - 1);
              if (e.d.category === 2) {
                if ((o == null ? undefined : o.type) === 20 || (o == null ? undefined : o.type) === 19) {
                  break;
                }
                if ((o == null ? undefined : o.type) !== 8 || F.TextRange.getEnd(o) !== s) {
                  return this._getExpressionCompletions(e, n, a, r);
                }
                if ((l == null ? undefined : l.type) !== 20) {
                  return this._getExpressionCompletions(e, n, a, r);
                }
                const t = F.TextRange.getEnd(l);
                const i = m.findNodeByOffset(this.parseResults.parserOutput.parseTree, t);
                if ((i == null ? undefined : i.nodeType) !== 0 || i.d.category !== 7) {
                  return this._getExpressionCompletions(e, n, a, r);
                }
                e = i;
              } else {
                if (e.d.category === 7 && ((o == null ? undefined : o.type) === 20 || (o == null ? undefined : o.type) === 19) && ((l == null ? undefined : l.type) === 20 || (l == null ? undefined : l.type) === 19)) {
                  return;
                }
              }
              return this._getMissingMemberAccessNameCompletions(e, n);
            }
          case 4:
          case 8:
            return this._getExpressionCompletions(e, n, a, r);
          case 11:
          case 3:
            {
              let s = this._getLiteralCompletions(e, t, n, a, r);
              if (!s) {
                s = this._getExpressionCompletions(e, n, a, r);
              }
              return s;
            }
          case 10:
            if (e.d.child && e.d.child.nodeType === 38) {
              if ((s = e.d.decorators) === null || s === undefined ? undefined : s.some(e => this._isOverload(e))) {
                return this._getMethodOverloadsCompletions(n, e.d.child);
              } else {
                return this.getMethodOverrideCompletions(n, e.d.child, e.d.decorators);
              }
            }
        }
      }
      _getMissingMemberAccessNameCompletions(e, t) {
        if (e.d.child && z.isExpressionNode(e.d.child)) {
          return this.getMemberAccessCompletions(e.d.child, t);
        }
      }
      _isOverload(e) {
        return m.checkDecorator(e, 'overload');
      }
      _createSingleKeywordCompletion(e) {
        const t = i.CompletionItem.create(e);
        t.kind = i.CompletionItemKind.Keyword;
        t.sortText = this._makeSortText(q.LikelyKeyword, e);
        const n = new W();
        n.set(t);
        return n;
      }
      _addClassVariableTypeAnnotationCompletions(e, t, n) {
        var a;
        var r;
        var s;
        var o;
        if (((a = t.parent) === null || a === undefined ? undefined : a.nodeType) !== 54 || t.parent.d.valueExpr.nodeType !== 38 || t.parent.d.annotation !== t || ((r = t.parent.parent) === null || r === undefined ? undefined : r.nodeType) !== 47 || ((s = t.parent.parent.parent) === null || s === undefined ? undefined : s.nodeType) !== 50 || ((o = t.parent.parent.parent.parent) === null || o === undefined ? undefined : o.nodeType) !== 10) {
          return;
        }
        const p = m.getEnclosingClass(t, false);
        if (!p) {
          return;
        }
        const d = this.evaluator.getTypeOfClass(p);
        if (!d) {
          return;
        }
        const c = t.parent.d.valueExpr.d.value;
        const u = I.lookUpClassMember(d.classType, c, 17);
        if (u) {
          const t = this.evaluator.getTypeOfMember(u);
          const a = this.evaluator.printType(t, {
            enforcePythonSyntax: true,
            expandTypeAlias: false
          });
          this.addNameToCompletions(a, i.CompletionItemKind.Reference, e, n, {
            sortText: this._makeSortText(q.LikelyKeyword, a)
          });
          return;
        }
        const y = new Map();
        for (const e of d.classType.shared.mro) {
          if (e !== d.classType && C.isInstantiableClass(e)) {
            I.getMembersForClass(e, y, false);
          }
        }
        const g = y.get(c);
        if (!g) {
          return;
        }
        const f = g.getDeclarations().filter(e => l.isVariableDeclaration(e) && e.moduleName !== 'builtins');
        if (f.length === 0 || f.some(e => e.node && m.getEnclosingClass(e.node, false) === p)) {
          return;
        }
        const T = f.filter(e => e.typeAnnotationNode);
        if (T.length === 0) {
          return;
        }
        const v = h.isStubFile(this.fileUri) ? 3 : 2;
        const b = `${m.printExpression(T[T.length - 1].typeAnnotationNode, v)}`;
        this.addNameToCompletions(b, i.CompletionItemKind.Reference, e, n, {
          sortText: this._makeSortText(q.LikelyKeyword, b)
        });
      }
      _getClassVariableCompletions(e) {
        const t = m.getEnclosingClass(e, false);
        if (!t) {
          return;
        }
        const n = this.evaluator.getTypeOfClass(t);
        if (!n) {
          return;
        }
        const a = new Map();
        for (const e of n.classType.shared.mro) {
          if (C.isInstantiableClass(e)) {
            I.getMembersForClass(e, a, false);
          }
        }
        const r = new W();
        a.forEach((n, a) => {
          if (f.isPrivateName(a) || n.isPrivateMember() || n.isExternallyHidden() || !N.isPatternInSymbol(e.d.value, a)) {
            return;
          }
          const s = n.getDeclarations().filter(e => l.isVariableDeclaration(e) && e.moduleName !== 'builtins');
          if (s.length !== 0 && !s.some(e => e.node && m.getEnclosingClass(e.node, false) === t)) {
            this.addSymbol(a, n, e.d.value, r, {});
          }
        });
        if (r.size > 0) {
          return r;
        } else {
          return undefined;
        }
      }
      _getMethodOverloadsCompletions(e, t) {
        var n;
        const a = function (e, t) {
          const n = m.getEnclosingClass(t, false);
          if (n) {
            const t = e.getTypeOfClass(n);
            if (!t) {
              return;
            }
            const a = new Map();
            for (const e of t.classType.shared.mro) {
              if (C.isInstantiableClass(e)) {
                I.getMembersForClass(e, a, false);
              }
            }
            return a;
          }
          const a = m.getEnclosingModule(t);
          if (a) {
            const e = o.getScope(a);
            if (e == null) {
              return undefined;
            } else {
              return e.symbolTable;
            }
          }
          return;
        }(this.evaluator, t);
        if (!a) {
          return;
        }
        const r = ((n = t.parent) === null || n === undefined ? undefined : n.nodeType) === 31 || undefined;
        const s = new W();
        const i = m.getEnclosingFunction(t);
        a.forEach((n, a) => {
          const o = T.getLastTypedDeclarationForSymbol(n);
          if (!o || o.type !== 5) {
            return;
          }
          if (!o.node.d.decorators.some(e => this._isOverload(e))) {
            return;
          }
          const l = n.getDeclarations();
          if ((l.length !== 1 || !l.some(e => e.node === i)) && N.isPatternInSymbol(t.d.value, a)) {
            const i = this.createReplaceEdits(e, t, o.node.d.name.d.value);
            this.addSymbol(a, n, t.d.value, s, {
              funcParensDisabled: r,
              edits: {
                textEdit: i
              }
            });
          }
        });
        return s;
      }
      _printMethodSignature(e, t) {
        const n = t.node;
        let a;
        if (h.isStubFile(this.fileUri)) {
          a = true;
        } else {
          if (e.shared.moduleName === t.moduleName) {
            a = false;
          }
        }
        const r = h.isStubFile(this.fileUri) ? 3 : 2;
        const s = n.d.params.map((e, t) => {
          let s = '';
          if (e.d.category === 1) {
            s += '*';
          } else {
            if (e.d.category === 2) {
              s += '**';
            }
          }
          if (e.d.name) {
            s += e.d.name.d.value;
          }
          const i = m.getTypeAnnotationForParam(n, t);
          if (i) {
            s += `: ${m.printExpression(i, r)}`;
          }
          if (e.d.defaultValue) {
            s += i ? ' = ' : '=';
            s += a ?? !m.isSimpleDefault(e.d.defaultValue) ? '...' : m.printExpression(e.d.defaultValue, r);
          }
          if (s || e.d.name || e.d.category !== 0) {
            return s;
          } else {
            return '/';
          }
        }).join(', ');
        let i = n.d.name.d.value + '(' + s + ')';
        if (n.d.returnAnnotation) {
          i += ` -> ${m.printExpression(n.d.returnAnnotation, r)}`;
        } else {
          if (n.d.funcAnnotationComment) {
            i += ` -> ${m.printExpression(n.d.funcAnnotationComment.d.returnAnnotation, r)}`;
          }
        }
        return i;
      }
      _getStatementCompletions(e, t, n, a) {
        return this._getExpressionCompletions(e, t, n, a);
      }
      _getExpressionCompletions(e, t, n, a) {
        var r;
        var s;
        var o;
        if (!this._isIndexArgument(e) && e.nodeType === 40) {
          return;
        }
        if (((r = e.parent) === null || r === undefined ? undefined : r.nodeType) === 59 && e.parent === ((s = e.parent.d.target) === null || s === undefined ? undefined : s.parent)) {
          return;
        }
        const l = new W();
        if (n.slice(-2) === '..') {
          return l;
        }
        this._addClassVariableTypeAnnotationCompletions(t, e, l);
        this._addCallArgumentCompletions(e, t, n, a, false, l);
        this._addSymbols(e, t, l);
        this._findMatchingKeywords(j.forVersion(this.execEnv.pythonVersion), t).map(e => {
          if (l.has(e)) {
            return;
          }
          const t = i.CompletionItem.create(e);
          t.kind = i.CompletionItemKind.Keyword;
          t.sortText = this._makeSortText(q.Keyword, e);
          l.set(t);
        });
        if (!t.startsWith('_') && !this.itemToResolve) {
          const n = ((o = e.parent) === null || o === undefined ? undefined : o.nodeType) === 16;
          this.addAutoImportCompletions(t, 0.25, this.options.lazyEdit, l, n);
        }
        this._tryAddLiterals(e, t, n, a, l);
        return l;
      }
      _isIndexArgument(e) {
        const t = e.parent;
        return t && t.nodeType === 1 && t.d.argCategory === 0 && t.parent && t.parent.nodeType === 27 && t.parent.d.leftExpr && t.parent.d.leftExpr.nodeType === 38;
      }
      _addCallArgumentCompletions(e, t, n, a, r, s) {
        const i = P.convertPositionToOffset(this.position, this.parseResults.tokenizerOutput.lines);
        const o = y.getCallNodeAndActiveParamIndex(e, i, this.parseResults.tokenizerOutput.tokens);
        if (!o) {
          return;
        }
        const l = this.evaluator.getCallSignatureInfo(o.callNode, o.activeIndex, o.activeOrFake);
        if (l) {
          const e = P.convertOffsetToPosition(l.callNode.d.leftExpr.start + l.callNode.d.leftExpr.length, this.parseResults.tokenizerOutput.lines);
          if (F.comparePositions(this.position, e) > 0) {
            if (!r) {
              this._addNamedParameters(l, t, s);
            }
            this._addLiteralValuesForArgument(l, t, n, a, s);
          }
        }
      }
      _addLiteralValuesForArgument(e, t, n, a, r) {
        e.signatures.forEach(e => {
          if (!e.activeParam) {
            return;
          }
          const s = e.type;
          const i = s.shared.parameters.indexOf(e.activeParam);
          if (i < 0) {
            return;
          }
          const o = C.FunctionType.getParamType(s, i);
          this._addLiteralValuesForTargetType(o, t, n, a, r);
        });
      }
      _addLiteralValuesForTargetType(e, t, n, a, r) {
        const s = this._getQuoteInfo(t, n);
        this._getSubTypesWithLiteralValues(e).forEach(e => {
          if (C.ClassType.isBuiltIn(e, 'str')) {
            const n = _.printLiteralValue(e, s.quoteCharacter);
            if (s.stringValue === undefined) {
              this.addNameToCompletions(n, i.CompletionItemKind.Constant, t, r, {
                sortText: this._makeSortText(q.LiteralValue, e.priv.literalValue)
              });
            } else {
              this._addStringLiteralToCompletions(n.substr(1, n.length - 2), s, a, r);
            }
          }
        });
      }
      _getDictExpressionStringKeys(e, t) {
        const n = function (e) {
          if (e.nodeType === 18) {
            return e;
          }
          let t = e;
          while (t && t.nodeType !== 18 && t.nodeType !== 45) {
            t = t.parent;
            if (!t) {
              return;
            }
          }
          return t;
        }(e);
        if (n) {
          return n.d.items.flatMap(e => e.nodeType !== 20 || (t == null ? undefined : t.has(e.d.keyExpr.id)) ? [] : e.d.keyExpr.nodeType === 48 ? [e.d.keyExpr.d.strings.map(e => e.d.value).join('')] : []);
        } else {
          return [];
        }
      }
      _getSubTypesWithLiteralValues(e) {
        const t = [];
        I.doForEachSubtype(e, e => {
          if (C.isClassInstance(e) && I.isLiteralType(e)) {
            t.push(e);
          }
        });
        return t;
      }
      _getIndexKeyType(e) {
        const t = this.evaluator.getBoundMagicMethod(e, '__getitem__');
        if (t) {
          const e = [];
          I.doForEachSignature(t, t => {
            if (t.shared.parameters.length >= 1 && t.shared.parameters[0].category === 0) {
              e.push(C.FunctionType.getParamType(t, 0));
            }
          });
          if (e.length > 0) {
            return C.combineTypes(e);
          }
        }
      }
      _getIndexKeys(e, t) {
        var n;
        var a;
        var r;
        var s;
        var i;
        var o;
        var l;
        var p;
        var d;
        var c;
        const u = this.evaluator.getType(e.d.leftExpr);
        if (!u || !C.isClassInstance(u)) {
          return [];
        }
        const y = this._getIndexKeyType(u);
        if (y) {
          const e = [];
          this._getSubTypesWithLiteralValues(y).forEach(t => {
            if (C.ClassType.isBuiltIn(t, 'str') || C.ClassType.isBuiltIn(t, 'int') || C.ClassType.isBuiltIn(t, 'bool') || C.ClassType.isBuiltIn(t, 'bytes') || C.ClassType.isEnumClass(t)) {
              e.push(_.printLiteralValue(t, this.parseResults.tokenizerOutput.predominantSingleQuoteCharacter));
            }
          });
          if (e.length > 0) {
            return e;
          }
        }
        if (e.d.leftExpr.nodeType !== 38) {
          return [];
        }
        const g = (a = (n = this.evaluator.getDeclInfoForNameNode(e.d.leftExpr)) === null || n === undefined ? undefined : n.decls) !== null && a !== undefined ? a : [];
        const h = g.length > 0 ? g[0] : undefined;
        if (!h || h.type !== 1 && h.type !== 2) {
          return [];
        }
        if (!h.uri.equals(this.fileUri)) {
          return [];
        }
        let f = e.d.leftExpr;
        if (h.node) {
          const e = m.getEvaluationScopeNode(h.node).node;
          if ((r = m.getFileInfoFromNode(f)) === null || r === undefined ? undefined : r.fileUri.equals((s = m.getFileInfoFromNode(e)) === null || s === undefined ? undefined : s.fileUri)) {
            f = e;
          }
        }
        const T = L.DocumentSymbolCollector.collectFromNode(this.program, e.d.leftExpr, this.cancellationToken, f);
        const v = new Set();
        for (const e of T) {
          const n = ((i = e.node.parent) === null || i === undefined ? undefined : i.nodeType) === 54 ? e.node.parent : e.node;
          if (((o = n.parent) === null || o === undefined ? undefined : o.nodeType) === 3 || ((l = n.parent) === null || l === undefined ? undefined : l.nodeType) === 4) {
            if (n.parent.d.rightExpr.nodeType === 18) {
              const e = n.parent.d.rightExpr;
              for (const t of e.d.items.filter(e => e.nodeType === 20)) {
                const e = this.parseResults.text.substr(t.d.keyExpr.start, t.d.keyExpr.length).trim();
                if (e.length > 0) {
                  v.add(e);
                }
              }
            }
            if (n.parent.d.rightExpr.nodeType === 9) {
              const e = n.parent.d.rightExpr;
              const t = this.evaluator.getType(e.d.leftExpr);
              if (!t || !C.isInstantiableClass(t) || !C.ClassType.isBuiltIn(t, 'dict')) {
                continue;
              }
              for (const t of e.d.args) {
                const e = (d = (p = t.d.name) === null || p === undefined ? undefined : p.d.value.trim()) !== null && d !== undefined ? d : '';
                const n = this.parseResults.tokenizerOutput.predominantSingleQuoteCharacter;
                if (e.length > 0) {
                  v.add(`${n}${e}${n}`);
                }
              }
            }
          }
          if (((c = n.parent) === null || c === undefined ? undefined : c.nodeType) === 27 && n.parent.d.items.length === 1 && n.parent.d.items[0].d.valueExpr.nodeType !== 0 && !F.TextRange.containsRange(n.parent, t)) {
            const e = n.parent.d.items[0];
            const t = this.parseResults.text.substr(e.d.valueExpr.start, e.d.valueExpr.length).trim();
            if (t.length > 0) {
              v.add(t);
            }
          }
        }
        return Array.from(v);
      }
      _getLiteralCompletions(e, t, n, a, r) {
        if ((this.options.triggerCharacter === '"' || this.options.triggerCharacter === '\'') && e.start !== t - 1) {
          return;
        }
        const s = new W();
        if (this._tryAddLiterals(e, n, a, r, s)) {
          return s;
        } else {
          return undefined;
        }
      }
      _tryAddLiterals(e, n, a, r, s) {
        var o;
        var l;
        var p;
        var d;
        var c;
        var u;
        const m = function (e) {
          var t;
          if (!e.parent) {
            return;
          }
          if (e.nodeType !== 49) {
            return {
              parent: e.parent,
              child: e
            };
          }
          if (!e.parent.parent) {
            return;
          }
          if (((t = e.parent) === null || t === undefined ? undefined : t.nodeType) !== 48 || e.parent.d.strings.length > 1) {
            return;
          }
          return {
            parent: e.parent.parent,
            child: e.parent
          };
        }(e);
        if (!m) {
          return false;
        }
        const y = m.parent.nodeType === 3 ? m.parent.d.rightExpr === m.child ? m.child : undefined : z.isExpressionNode(m.child) ? m.child : undefined;
        if (y) {
          const e = this.evaluator.getExpectedType(y);
          if (e && I.containsLiteralType(e.type)) {
            this._addLiteralValuesForTargetType(e.type, n, a, r, s);
            return true;
          }
        }
        const g = m.parent;
        if (g) {
          let t;
          if (g.nodeType === 20 && g.d.keyExpr === m.child && ((o = g.parent) === null || o === undefined ? undefined : o.nodeType) === 18) {
            t = g.parent;
          } else {
            if ((g == null ? undefined : g.nodeType) === 45) {
              t = g;
            }
          }
          if (t && this._tryAddTypedDictKeysFromDictionary(t, e.nodeType === 49 ? e : undefined, n, a, r, s)) {
            return true;
          }
        }
        const h = m.parent;
        if (h.nodeType === 1 && ((l = h.parent) === null || l === undefined ? undefined : l.nodeType) === 27) {
          const o = e.nodeType === 49 ? a : '';
          if (this._tryAddTypedDictKeysFromIndexer(h.parent, n, o, r, s)) {
            return true;
          }
          const l = this._getQuoteInfo(n, o);
          const p = this._getIndexKeys(h.parent, e);
          let d = false;
          for (const a of p) {
            if (s.has(a)) {
              continue;
            }
            const o = /^["|'].*["|']$/.test(a);
            if (e.nodeType !== 49 || o) {
              d = true;
              if (o) {
                const e = a.substr(1, a.length - 2);
                this._addStringLiteralToCompletions(e, l, r, s, exports.indexValueDetail);
              } else {
                this.addNameToCompletions(a, i.CompletionItemKind.Constant, n, s, {
                  sortText: this._makeSortText(q.LiteralValue, a),
                  itemDetail: exports.indexValueDetail
                });
              }
            }
          }
          if (d) {
            return true;
          }
        }
        const f = m.parent;
        if (f.nodeType === 7 && [2, 12, 28].includes(f.d.operator)) {
          const e = this.evaluator.getType(f.d.leftExpr);
          if (e && I.containsLiteralType(e)) {
            this._addLiteralValuesForTargetType(e, n, a, r, s);
            return true;
          }
        }
        const T = m.parent;
        if (T.nodeType === 4 && T.d.rightExpr === m.child) {
          const e = this.evaluator.getType(T.d.name);
          if (e && I.containsLiteralType(e)) {
            this._addLiteralValuesForTargetType(e, n, a, r, s);
            return true;
          }
        }
        const v = m.parent;
        if (v.nodeType === 64 && v.d.pattern.nodeType === 0 && v.d.pattern.d.category === 11 && v.d.suite === m.child && ((p = v.parent) === null || p === undefined ? undefined : p.nodeType) === 63) {
          const e = this.evaluator.getType(v.parent.d.expr);
          if (e && I.containsLiteralType(e)) {
            this._addLiteralValuesForTargetType(e, n, a, r, s);
            return true;
          }
        }
        const b = m.parent;
        if ((b.nodeType === 67 || b.nodeType === 69) && ((d = b.parent) === null || d === undefined ? undefined : d.nodeType) === 66 && ((c = b.parent.parent) === null || c === undefined ? undefined : c.nodeType) === 64 && ((u = b.parent.parent.parent) === null || u === undefined ? undefined : u.nodeType) === 63) {
          const e = this.evaluator.getType(b.parent.parent.parent.d.expr);
          if (e && I.containsLiteralType(e)) {
            this._addLiteralValuesForTargetType(e, n, a, r, s);
            return true;
          }
        }
        if (e.nodeType === 49) {
          const t = P.convertPositionToOffset(this.position, this.parseResults.tokenizerOutput.lines);
          const i = e.parent.start < t && t < F.TextRange.getEnd(e);
          this._addCallArgumentCompletions(e, n, a, r, i, s);
          return true;
        }
        return false;
      }
      _tryAddTypedDictKeys(e, t, n, a, r, s) {
        let i = [];
        I.doForEachSubtype(e, e => {
          if (C.isClassInstance(e) && C.ClassType.isTypedDictClass(e)) {
            i.push(e);
          }
        });
        if (i.length === 0) {
          return false;
        }
        i = this._tryNarrowTypedDicts(i, t);
        const o = this._getQuoteInfo(n, a);
        const l = new Set(t);
        i.forEach(e => {
          v.getTypedDictMembersForClass(this.evaluator, e, true).knownItems.forEach((e, t) => {
            if (!l.has(t) && !s.has(t)) {
              l.add(t);
              this._addStringLiteralToCompletions(t, o, r, s);
            }
          });
        });
        return true;
      }
      _tryAddTypedDictKeysFromDictionary(e, t, n, a, r, s) {
        var i;
        const o = this.evaluator.getExpectedType(e);
        if (!o) {
          return false;
        }
        if (m.getNodeDepth(o.node) < m.getNodeDepth(e)) {
          return false;
        }
        const l = this._getDictExpressionStringKeys(e, t ? new Set([(i = t.parent) === null || i === undefined ? undefined : i.id]) : undefined);
        return this._tryAddTypedDictKeys(o.type, l, n, a, r, s);
      }
      _tryNarrowTypedDicts(e, t) {
        const n = e.flatMap(e => {
          const n = v.getTypedDictMembersForClass(this.evaluator, e, true);
          for (let e = 0; e < t.length; e++) {
            if (!n.knownItems.has(t[e])) {
              return [];
            }
          }
          return [e];
        });
        if (n.length === 0) {
          return e;
        } else {
          return n;
        }
      }
      _getQuoteInfo(e, t) {
        let n;
        let a = e;
        let r = this.parseResults.tokenizerOutput.predominantSingleQuoteCharacter;
        if (!this._stringLiteralContainer) {
          return {
            priorWord: e,
            priorText: t,
            filterText: a,
            stringValue: n,
            quoteCharacter: r
          };
        }
        if (t !== undefined) {
          const e = t.lastIndexOf('\'');
          const a = t.lastIndexOf('"');
          if (e > a) {
            n = t.substr(e + 1);
            r = '\'';
          } else {
            if (a > e) {
              n = t.substr(a + 1);
              r = '"';
            }
          }
        }
        if (this._stringLiteralContainer.flags & 64) {
          r = this._stringLiteralContainer.flags & 1 ? '"' : '\'';
        }
        if (n) {
          a = n;
        }
        return {
          priorWord: e,
          priorText: t,
          filterText: a,
          stringValue: n,
          quoteCharacter: r
        };
      }
      _tryAddTypedDictKeysFromIndexer(e, t, n, a, r) {
        if (!e) {
          return false;
        }
        const s = this.evaluator.getType(e.d.leftExpr);
        return !!s && this._tryAddTypedDictKeys(s, [], t, n, a, r);
      }
      _addStringLiteralToCompletions(e, t, n, a, r) {
        if (!N.isPatternInSymbol(t.filterText || '', e)) {
          return;
        }
        const s = `${t.quoteCharacter}${e}${t.quoteCharacter}`;
        if (a.has(s)) {
          return;
        }
        const o = i.CompletionItem.create(s);
        o.kind = i.CompletionItemKind.Constant;
        o.sortText = this._makeSortText(q.LiteralValue, s);
        let l = this.position.character;
        if (t.stringValue !== undefined) {
          l -= t.stringValue.length + 1;
        } else {
          if (t.priorWord) {
            l -= t.priorWord.length;
          }
        }
        let p = this.position.character;
        if (n !== undefined && n.startsWith(t.quoteCharacter)) {
          p++;
        }
        const d = {
          start: {
            line: this.position.line,
            character: l
          },
          end: {
            line: this.position.line,
            character: p
          }
        };
        o.textEdit = i.TextEdit.replace(d, s);
        o.detail = r;
        a.set(o);
      }
      _getImportFromCompletions(e, t, n) {
        var a;
        if (e.d.isWildcardImport) {
          return;
        }
        const r = o.getImportInfo(e.d.module);
        if (!r) {
          return;
        }
        const s = new W();
        const i = r.resolvedUris.length > 0 ? r.resolvedUris[r.resolvedUris.length - 1] : E.Uri.empty();
        const p = this.program.getParseResults(i);
        if (!p) {
          this._addImplicitImportsToCompletion(r, e, n, s);
          return s;
        }
        const d = (a = o.getScope(p.parserOutput.parseTree)) === null || a === undefined ? undefined : a.symbolTable;
        if (d) {
          this._addSymbolsForSymbolTable(d, (n, a) => n.getDeclarations().some(e => !l.isIntrinsicDeclaration(e)) && !e.d.imports.find(e => e.d.name.d.value === a && !F.TextRange.contains(e, t) && F.TextRange.getEnd(e) !== t), n, e, true, undefined, s);
          this._addImplicitImportsToCompletion(r, e, n, s);
          return s;
        } else {
          return s;
        }
      }
      _addImplicitImportsToCompletion(e, t, n, a) {
        e.implicitImports.forEach(e => {
          if (!t.d.imports.find(t => t.d.name.d.value === e.name)) {
            this.addNameToCompletions(e.name, i.CompletionItemKind.Module, n, a, {
              moduleUri: e.uri
            });
          }
        });
      }
      _findMatchingKeywords(e, t) {
        return e.filter(e => !t || N.isPatternInSymbol(t, e));
      }
      _addNamedParameters(e, t, n) {
        const a = new Set();
        e.signatures.forEach(e => {
          this._addNamedParametersToMap(e.type, a);
        });
        e.signatures.forEach(e => {
          var t;
          if (e.type.priv.boundToType) {
            Array.from(((t = e.type.priv.boundToType.shared.typedDictEntries) === null || t === undefined ? undefined : t.knownItems.keys()) || []).forEach(e => a.add(e));
          }
        });
        e.callNode.d.args.forEach(e => {
          if (e.d.name) {
            a.delete(e.d.name.d.value);
          }
        });
        a.forEach(e => {
          if (N.isPatternInSymbol(t, e)) {
            const t = e + '=';
            if (n.has(t)) {
              return;
            }
            const a = i.CompletionItem.create(t);
            a.kind = i.CompletionItemKind.Variable;
            const r = {
              uri: this.fileUri.toString(),
              position: this.position
            };
            a.data = x.toLSPAny(r);
            a.sortText = this._makeSortText(q.NamedParameter, e);
            a.filterText = e;
            n.set(a);
          }
        });
      }
      _addNamedParametersToMap(e, t) {
        u.getParamListDetails(e).params.forEach(e => {
          if (e.param.name && e.kind !== u.ParamKind.Positional && e.kind !== u.ParamKind.ExpandedArgs && !f.isPrivateOrProtectedName(e.param.name) && U.Tokenizer.isPythonIdentifier(e.param.name)) {
            t.add(e.param.name);
          }
        });
      }
      _addSymbols(e, t, n) {
        let a = e;
        while (a) {
          let r = g.getScopeForNode(a);
          if (r) {
            while (r) {
              this._addSymbolsForSymbolTable(r.symbolTable, () => true, t, e, false, undefined, n);
              r = r.parent;
            }
            if (a.nodeType === 10) {
              const r = this.evaluator.getTypeOfClass(a);
              if (r && C.isInstantiableClass(r.classType)) {
                r.classType.shared.mro.forEach((a, r) => {
                  if (C.isInstantiableClass(a)) {
                    this._addSymbolsForSymbolTable(C.ClassType.getSymbolTable(a), e => !!e.isClassMember() && e.getDeclarations().some(e => e.type === 1), t, e, false, undefined, n);
                  }
                });
              }
            }
            break;
          }
          a = a.parent;
        }
      }
      _addSymbolsForSymbolTable(e, t, n, a, r, s, i) {
        const o = m.isWithinAnnotationComment(a) || m.isWithinTypeAnnotation(a, false);
        e.forEach((e, l) => {
          var d;
          if ((!!T.isVisibleExternally(e) || !!e.getDeclarations().some(e => p.isDefinedInFile(e, this.fileUri))) && t(e, l) && !i.has(l)) {
            const t = !this._shouldShowAutoParensForClass(e, a);
            const p = ((d = a.parent) === null || d === undefined ? undefined : d.nodeType) === 16;
            this.addSymbol(l, e, n, i, {
              boundObjectOrClass: s,
              funcParensDisabled: r || o || t || p,
              extraCommitChars: !r && !!n
            });
          }
        });
      }
      _shouldShowAutoParensForClass(e, t) {
        var n;
        var a;
        if (e.getDeclarations().every(e => e.type !== 6)) {
          return true;
        }
        if (((n = t.parent) === null || n === undefined ? undefined : n.nodeType) === 1 && ((a = t.parent.parent) === null || a === undefined ? undefined : a.nodeType) !== 10) {
          return true;
        }
        const r = m.getTokenIndexAtLeft(this.parseResults.tokenizerOutput.tokens, t.start);
        const s = m.getTokenAtIndex(this.parseResults.tokenizerOutput.tokens, r);
        return s && s.type === 9 && s.operatorType === 2;
      }
      _getRecentListIndex(e, t) {
        return G._mostRecentCompletions.findIndex(n => n.label === e && n.autoImportText === t);
      }
      _makeSortText(e, t, n = '') {
        const a = this._getRecentListIndex(t, n);
        if (a >= 0) {
          if (e === q.AutoImport) {
            e = q.RecentAutoImport;
          } else {
            if (e === q.ImportModuleName) {
              e = q.RecentImportModuleName;
            } else {
              if (e === q.Keyword || e === q.NormalSymbol || e === q.PrivateSymbol || e === q.DunderSymbol) {
                e = q.RecentKeywordOrSymbol;
              }
            }
          }
        }
        return this._formatInteger(e, 2) + '.' + this._formatInteger(a, 4) + '.' + t;
      }
      _formatInteger(e, t) {
        const n = '0'.charCodeAt(0);
        let a = '';
        for (let r = 0; r < t; r++) {
          let t = Math.floor(e % 10);
          if (t < 0) {
            t = 9;
          }
          a = String.fromCharCode(t + n) + a;
          e = Math.floor(e / 10);
        }
        return a;
      }
      _convertDeclarationTypeToItemKind(e) {
        const t = this.evaluator.resolveAliasDeclaration(e, true);
        if (!t) {
          return i.CompletionItemKind.Variable;
        }
        switch (t.type) {
          case 0:
            if (t.intrinsicType === 'type[self]') {
              return i.CompletionItemKind.Class;
            } else {
              return i.CompletionItemKind.Variable;
            }
          case 2:
          case 4:
            return i.CompletionItemKind.Variable;
          case 3:
            return i.CompletionItemKind.TypeParameter;
          case 1:
            if (t.isConstant || t.isFinal) {
              return i.CompletionItemKind.Constant;
            } else {
              return i.CompletionItemKind.Variable;
            }
          case 5:
            if (this._isPossiblePropertyDeclaration(t)) {
              const e = this.evaluator.getTypeOfFunction(t.node);
              if (e && I.isMaybeDescriptorInstance(e.decoratedType, false)) {
                return i.CompletionItemKind.Property;
              }
            }
            if (t.isMethod) {
              return i.CompletionItemKind.Method;
            } else {
              return i.CompletionItemKind.Function;
            }
          case 6:
          case 7:
            return i.CompletionItemKind.Class;
          case 8:
            return i.CompletionItemKind.Module;
        }
      }
      _convertTypeToItemKind(e) {
        switch (e.category) {
          case 7:
            return i.CompletionItemKind.Module;
          case 6:
            return i.CompletionItemKind.Class;
          case 4:
          case 5:
            if (I.isMaybeDescriptorInstance(e, false)) {
              return i.CompletionItemKind.Property;
            } else {
              return i.CompletionItemKind.Function;
            }
          case 9:
            return i.CompletionItemKind.TypeParameter;
          default:
            return i.CompletionItemKind.Variable;
        }
      }
      _getImportModuleCompletions(e) {
        const t = {
          leadingDots: e.d.leadingDots,
          hasTrailingDot: e.d.hasTrailingDot || false,
          nameParts: e.d.nameParts.map(e => e.d.value),
          importedSymbols: new Set()
        };
        const n = this.importResolver.getCompletionSuggestions(this.fileUri, this.execEnv, t);
        const a = new W();
        if (!e.d.hasTrailingDot && e.parent && e.parent.nodeType === 25 && e.parent.d.missingImport) {
          const e = 'import';
          const t = i.CompletionItem.create(e);
          t.kind = i.CompletionItemKind.Keyword;
          t.sortText = this._makeSortText(q.Keyword, e);
          a.set(t);
        }
        n.forEach((e, t) => {
          this.addNameToCompletions(t, i.CompletionItemKind.Module, '', a, {
            sortText: this._makeSortText(q.ImportModuleName, t),
            moduleUri: e
          });
        });
        return a;
      }
      _isPossiblePropertyDeclaration(e) {
        return e.isMethod && e.node.d.decorators.length > 0;
      }
      _isEnumMember(e, t) {
        if (!e || !C.ClassType.isEnumClass(e)) {
          return false;
        }
        const n = d.transformTypeForEnumMember(this.evaluator, e, t);
        return n && C.isClassInstance(n) && C.ClassType.isSameGenericClass(n, C.TypeBase.isInstance(e) ? e : C.ClassType.cloneAsInstance(e)) && n.priv.literalValue instanceof C.EnumLiteral;
      }
    }
    exports.CompletionProvider = G;
    G._mostRecentCompletions = [];
    class W {
      constructor() {
        this._completions = new Map();
      }
      get size() {
        return this._completions.size;
      }
      set(e) {
        const t = this._completions.get(e.label);
        if (t) {
          if (Array.isArray(t)) {
            t.push(e);
          } else {
            this._completions.set(e.label, [t, e]);
          }
        } else {
          this._completions.set(e.label, e);
        }
      }
      get(e) {
        return this._completions.get(e);
      }
      has(e, t, n, a) {
        const r = this._completions.get(e);
        return !!r && (!t || t(r, n, a));
      }
      clear() {
        this._completions.clear();
      }
      delete(e) {
        return this._completions.delete(e);
      }
      toArray() {
        var e;
        const t = [];
        if ((e = this._completions) !== null && e !== undefined) {
          e.forEach(e => {
            if (Array.isArray(e)) {
              e.forEach(e => {
                t.push(e);
              });
            } else {
              t.push(e);
            }
          });
        }
        return t;
      }
      static matchKindAndImportText(e, t, n, a) {
        var r;
        if (Array.isArray(e)) {
          return !!e.find(e => {
            var r;
            return e.kind === n && ((r = t(e)) === null || r === undefined ? undefined : r.autoImportText) === a;
          });
        } else {
          return e.kind === n && ((r = t(e)) === null || r === undefined ? undefined : r.autoImportText) === a;
        }
      }
      static labelOnlyIgnoringAutoImports(e, t) {
        var n;
        if (Array.isArray(e)) {
          if (e.find(e => {
            var n;
            return !((n = t(e)) === null || n === undefined ? undefined : n.autoImportText);
          })) {
            return true;
          }
        } else {
          if (!((n = t(e)) === null || n === undefined ? undefined : n.autoImportText)) {
            return true;
          }
        }
        return false;
      }
    }
    exports.CompletionMap = W;
  },
  51868: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getTypeDetail = function (e, t, n, a, r, l) {
      if (!n) {
        if (i.isModule(t)) {
          return a;
        } else {
          return undefined;
        }
      }
      switch (n.type) {
        case 0:
        case 1:
        case 2:
        case 3:
          {
            let n = false;
            if (t && i.TypeBase.isInstantiable(t)) {
              const e = i.getTypeAliasInfo(t);
              if (e && e.shared.name === a) {
                n = true;
              }
            }
            if (t.category === 5 || t.category === 4) {
              return o.getToolTipForType(t, '', a, e, false, l);
            } else {
              return a + ': ' + e.printType(t, {
                expandTypeAlias: n
              });
            }
          }
        case 5:
          {
            const n = (r == null ? undefined : r.boundObjectOrClass) && (i.isFunction(t) || i.isOverloaded(t)) ? e.bindFunctionToClassOrObject(r.boundObjectOrClass, t) : t;
            if (!n) {
              return;
            }
            if (s.isProperty(n) && (r == null ? undefined : r.boundObjectOrClass) && i.isClassInstance(r.boundObjectOrClass)) {
              const t = e.getGetterTypeFromProperty(n, true) || i.UnknownType.create();
              return a + ': ' + e.printType(t) + ' (property)';
            }
            return o.getToolTipForType(n, '', a, e, false, l);
          }
        case 6:
        case 7:
          return `class ${a}()`;
        default:
          return a;
      }
    };
    exports.getCompletionItemDocumentation = function (e, t, n, s, i) {
      if (s === a.MarkupKind.Markdown) {
        let s = `\`\`\`python
${t}
\`\`\`
`;
        if (n) {
          s += '---\n';
          s += e.docStringService().convertDocStringToMarkdown(n, r.isBuiltInModule(i == null ? undefined : i.uri));
        }
        s = s.trimEnd();
        return {
          kind: a.MarkupKind.Markdown,
          value: s
        };
      }
      if (s === a.MarkupKind.PlainText) {
        let r = t + '\n';
        if (n) {
          r += '\n';
          r += e.docStringService().convertDocStringToPlainText(n);
        }
        r = r.trimEnd();
        return {
          kind: a.MarkupKind.PlainText,
          value: r
        };
      }
      return;
    };
    const a = require(38659);
    const r = require(30889);
    const s = require(92324);
    const i = require(21024);
    const o = require(39426);
  },
  65574: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.TypeDefinitionProvider = exports.DefinitionProvider = exports.DefinitionFilter = undefined;
    exports.addDeclarationsToDefinitions = v;
    exports.filterDefinitions = b;
    const i = require(26687);
    const o = require(28445);
    const l = __importStar(require(41557));
    const p = require(3113);
    const d = require(92324);
    const c = require(21024);
    const u = require(91426);
    const m = require(58147);
    const y = require(34455);
    const g = require(56814);
    const h = require(71745);
    const f = require(88754);
    var T;
    function v(e, t, n, a) {
      if (n) {
        n.forEach(n => {
          var r;
          let s = e.resolveAliasDeclaration(n, true, {
            allowExternallyHiddenAccess: true
          });
          if (!s || s.uri.isEmpty()) {
            return;
          }
          if (s.type === 8 && (s.isUnresolved || o.isUnresolvedAliasDeclaration(s))) {
            return;
          }
          if (s.type === 8 && s.symbolName && s.submoduleFallback && !s.submoduleFallback.uri.isEmpty()) {
            s = s.submoduleFallback;
          }
          I(a, {
            uri: s.uri,
            range: s.range
          });
          if (o.isFunctionDeclaration(s)) {
            const t = (r = e.getTypeForDeclaration(s)) === null || r === undefined ? undefined : r.type;
            if (t && c.isOverloaded(t)) {
              for (const e of c.OverloadedType.getOverloads(t).map(e => e.shared.declaration).filter(y.isDefined)) {
                I(a, {
                  uri: e.uri,
                  range: e.range
                });
              }
            }
          }
          if (!p.isStubFile(s.uri)) {
            return;
          }
          if (s.type === 8) {
            t.findModules(s.uri).map(e => {
              var t;
              if ((t = i.getFileInfo(e)) === null || t === undefined) {
                return undefined;
              } else {
                return t.fileUri;
              }
            }).filter(y.isDefined).forEach(e => I(a, {
              uri: e,
              range: {
                start: {
                  line: 0,
                  character: 0
                },
                end: {
                  line: 0,
                  character: 0
                }
              }
            }));
            return;
          }
          const l = t.findDeclarations(s);
          for (const e of l) {
            if (e && !e.uri.isEmpty()) {
              I(a, {
                uri: e.uri,
                range: e.range
              });
            }
          }
        });
      }
    }
    function b(e, t) {
      if (e === T.All) {
        return t;
      }
      const n = e === T.PreferStubs;
      const a = e => n === p.isStubFile(e.uri);
      if (t.find(a)) {
        return t.filter(a);
      } else {
        return t;
      }
    }
    (function (e) {
      e.All = 'all';
      e.PreferSource = 'preferSource';
      e.PreferStubs = 'preferStubs';
    })(T || (exports.DefinitionFilter = T = {}));
    class _ {
      constructor(e, t, n, a, r, s, i) {
        this.sourceMapper = e;
        this.evaluator = t;
        this._serviceProvider = n;
        this.node = a;
        this.offset = r;
        this._filter = s;
        this.token = i;
      }
      getDefinitionsForNode(e, t) {
        var n;
        u.throwIfCancellationRequested(this.token);
        const a = [];
        const r = (n = this._serviceProvider) === null || n === undefined ? undefined : n.tryGet(h.ServiceKeys.symbolDefinitionProvider);
        if (r) {
          r.forEach(n => {
            const r = n.tryGetDeclarations(e, t, this.token);
            this.resolveDeclarations(r, a);
          });
        }
        if (a.length === 0) {
          if (e.nodeType === 38) {
            const t = this.evaluator.getDeclInfoForNameNode(e);
            if (t) {
              this.resolveDeclarations(t.decls, a);
              this.addSynthesizedTypes(t.synthesizedTypes, a);
            }
          } else {
            if (e.nodeType === 49) {
              const t = this.evaluator.getDeclInfoForStringNode(e);
              if (t) {
                this.resolveDeclarations(t.decls, a);
                this.addSynthesizedTypes(t.synthesizedTypes, a);
              }
            }
          }
        }
        if (a.length !== 0) {
          return b(this._filter, a);
        }
      }
      resolveDeclarations(e, t) {
        v(this.evaluator, this.sourceMapper, e, t);
      }
      addSynthesizedTypes(e, t) {
        for (const n of e) {
          if (!n.node) {
            continue;
          }
          const e = i.getFileInfo(n.node);
          const a = g.convertOffsetsToRange(n.node.start, n.node.start + n.node.length, e.lines);
          t.push({
            uri: e.fileUri,
            range: a
          });
        }
      }
    }
    exports.DefinitionProvider = class extends _ {
      constructor(e, t, n, a, r) {
        const s = e.getSourceMapper(t, r);
        const i = e.getParseResults(t);
        const {
          node: o,
          offset: l
        } = C(i, n);
        super(s, e.evaluator, e.serviceProvider, o, l, a, r);
      }
      static getDefinitionsForNode(e, t, n, a, r) {
        return new _(e, t, undefined, n, a, T.All, r).getDefinitionsForNode(n, a);
      }
      getDefinitions() {
        if (this.node !== undefined) {
          return this.getDefinitionsForNode(this.node, this.offset);
        }
      }
    };
    function C(e, t) {
      if (!e) {
        return {
          node: undefined,
          offset: 0
        };
      }
      const n = g.convertPositionToOffset(t, e.tokenizerOutput.lines);
      if (n === undefined) {
        return {
          node: undefined,
          offset: 0
        };
      } else {
        return {
          node: l.findNodeByOffset(e.parserOutput.parseTree, n),
          offset: n
        };
      }
    }
    function I(e, t) {
      for (const n of e) {
        if (n.uri.equals(t.uri) && f.rangesAreEqual(n.range, t.range)) {
          return;
        }
      }
      e.push(t);
    }
    exports.TypeDefinitionProvider = class extends _ {
      constructor(e, t, n, a) {
        const r = e.getSourceMapper(t, a, false, true);
        const s = e.getParseResults(t);
        const {
          node: i,
          offset: o
        } = C(s, n);
        super(r, e.evaluator, e.serviceProvider, i, o, T.All, a);
        this._fileUri = t;
      }
      getDefinitions() {
        var e;
        var t;
        var n;
        u.throwIfCancellationRequested(this.token);
        if (this.node === undefined) {
          return;
        }
        const a = [];
        if (this.node.nodeType === 38) {
          const n = this.evaluator.getType(this.node);
          if (n) {
            let r = [];
            d.doForEachSubtype(n, e => {
              if ((e == null ? undefined : e.category) === 6) {
                m.appendArray(r, this.sourceMapper.findClassDeclarationsByType(this._fileUri, e));
              }
            });
            if (r.length === 0) {
              r = (t = (e = this.evaluator.getDeclInfoForNameNode(this.node)) === null || e === undefined ? undefined : e.decls) !== null && t !== undefined ? t : [];
            }
            this.resolveDeclarations(r, a);
          }
        } else {
          if (this.node.nodeType === 49) {
            const e = (n = this.evaluator.getDeclInfoForStringNode(this.node)) === null || n === undefined ? undefined : n.decls;
            this.resolveDeclarations(e, a);
          }
        }
        if (a.length !== 0) {
          return a;
        } else {
          return undefined;
        }
      }
    };
  },
  42634: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DocumentHighlightProvider = undefined;
    const i = require(56911);
    const o = __importStar(require(41557));
    const l = require(91426);
    const p = require(56507);
    const d = require(56814);
    const c = require(88754);
    const u = require(67032);
    exports.DocumentHighlightProvider = class {
      constructor(e, t, n, a) {
        this._program = e;
        this._fileUri = t;
        this._position = n;
        this._token = a;
        this._parseResults = this._program.getParseResults(this._fileUri);
      }
      getDocumentHighlight() {
        l.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return;
        }
        const e = d.convertPositionToOffset(this._position, this._parseResults.tokenizerOutput.lines);
        if (e === undefined) {
          return;
        }
        const t = o.findNodeByOffset(this._parseResults.parserOutput.parseTree, e);
        if (t === undefined) {
          return;
        }
        if (t.nodeType !== 38) {
          return;
        }
        const n = u.DocumentSymbolCollector.collectFromNode(this._program, t, this._token, this._parseResults.parserOutput.parseTree, {
          treatModuleInImportAndFromImportSame: true,
          useCase: p.ReferenceUseCase.References
        });
        const a = this._parseResults.tokenizerOutput.lines;
        return n.map(e => ({
          kind: e.node.nodeType === 38 && o.isWriteAccess(e.node) ? i.DocumentHighlightKind.Write : i.DocumentHighlightKind.Read,
          range: d.convertOffsetsToRange(e.range.start, c.TextRange.getEnd(e.range), a)
        }));
      }
    };
  },
  67032: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DocumentSymbolCollector = exports.AliasResolver = undefined;
    exports.getDeclarationsForNameNode = I;
    exports.addDeclarationIfUnique = k;
    const i = __importStar(require(26687));
    const o = require(28445);
    const l = require(83760);
    const p = require(41557);
    const d = require(88744);
    const c = __importStar(require(95952));
    const u = require(53266);
    const m = require(3433);
    const y = require(3113);
    const g = require(91426);
    const h = require(58147);
    const f = require(34455);
    const T = require(48281);
    const v = require(56507);
    const b = require(71745);
    class _ {
      constructor(e) {
        this._evaluator = e;
        this._caches = [undefined, undefined];
      }
      resolve(e, t) {
        const n = t ? 0 : 1;
        if (this._caches[n] && this._caches[n].original === e) {
          return this._caches[n].resolved;
        }
        const a = this._evaluator.resolveAliasDeclaration(e, t, {
          allowExternallyHiddenAccess: true,
          skipFileNeededCheck: true
        });
        this._caches[n] = {
          original: e,
          resolved: a
        };
        return a;
      }
    }
    exports.AliasResolver = _;
    class C extends d.ParseTreeWalker {
      constructor(e, t, n, a, r, s) {
        var i;
        var o;
        var l;
        var p;
        var d;
        super();
        this._program = e;
        this._startingNode = a;
        this._cancellationToken = r;
        this._results = [];
        this._dunderAllNameNodes = new Set();
        this._symbolNames = new Set();
        this._declarations = [];
        this._aliasResolver = new _(this._program.evaluator);
        t.forEach(e => this._symbolNames.add(e));
        this._declarations.push(...n);
        this._treatModuleInImportAndFromImportSame = (i = s == null ? undefined : s.treatModuleInImportAndFromImportSame) !== null && i !== undefined && i;
        this._skipUnreachableCode = (o = s == null ? undefined : s.skipUnreachableCode) === null || o === undefined || o;
        this._useCase = (l = s == null ? undefined : s.useCase) !== null && l !== undefined ? l : v.ReferenceUseCase.References;
        this._usageProviders = (p = s == null ? undefined : s.providers) !== null && p !== undefined ? p : ((d = this._program.serviceProvider.tryGet(b.ServiceKeys.symbolUsageProviderFactory)) !== null && d !== undefined ? d : []).map(e => e.tryCreateProvider(this._useCase, n, this._cancellationToken)).filter(f.isDefined);
        if ((s == null ? undefined : s.providers) === undefined) {
          this._usageProviders.forEach(e => {
            e.appendSymbolNamesTo(this._symbolNames);
            e.appendDeclarationsTo(this._declarations);
          });
        }
        this._setDunderAllNodes(this._startingNode);
      }
      static collectFromNode(e, t, n, a, r) {
        const s = this.getDeclarationsForNode(e, t, true, n);
        if (!(a = a ?? p.getModuleNode(t))) {
          return [];
        }
        return new C(e, [t.d.value], s, a, n, r).collect();
      }
      static getDeclarationsForNode(e, t, n, a) {
        g.throwIfCancellationRequested(a);
        const r = e.evaluator;
        if (!r) {
          return [];
        }
        const s = I(r, t, false);
        const l = i.getFileInfo(t);
        const p = l.fileUri;
        const d = [];
        const c = e.getSourceMapper(p, a);
        s.forEach(e => {
          const t = r.resolveAliasDeclaration(e, n);
          if (t && (k(d, t), c && y.isStubFile(t.uri))) {
            const e = c.findDeclarations(t);
            for (const t of e) {
              if (t && !t.uri.isEmpty()) {
                k(d, t);
              }
            }
          }
        });
        const h = e.getSourceFileInfo(p);
        if (h && h.sourceFile.getIPythonMode() === u.IPythonMode.CellDocs) {
          let n = l.builtinsScope;
          while (n && n.type === 4) {
            f(n == null ? undefined : n.lookUpSymbol(t.d.value), d);
            n = n == null ? undefined : n.parent;
          }
          m.collectImportedByCells(e, h).forEach(n => {
            var a;
            const r = (a = e.getParseResults(n.sourceFile.getUri())) === null || a === undefined ? undefined : a.parserOutput.parseTree;
            if (r) {
              const e = i.getScope(r);
              f(e == null ? undefined : e.lookUpSymbol(t.d.value), d);
            }
          });
        }
        return d;
        function f(e, t) {
          if (e != null) {
            e.getDeclarations().filter(e => !o.isAliasDeclaration(e)).forEach(e => {
              const a = r.resolveAliasDeclaration(e, n);
              if (a) {
                k(t, a);
              }
            });
          }
        }
      }
      collect() {
        this.walk(this._startingNode);
        return this._results;
      }
      walk(e) {
        if (!this._skipUnreachableCode || !i.isCodeUnreachable(e)) {
          super.walk(e);
        }
      }
      visitName(e) {
        g.throwIfCancellationRequested(this._cancellationToken);
        if (!this._symbolNames.has(e.d.value)) {
          return false;
        }
        if (this._declarations.length > 0) {
          const t = I(this._evaluator, e, this._skipUnreachableCode);
          if (t && t.length > 0 && this._resultsContainsDeclaration(e, t)) {
            this._addResult(e);
          }
        } else {
          this._addResult(e);
        }
        return false;
      }
      visitStringList(e) {
        if (this._declarations.some(t => {
          var n;
          return ((n = t.node) === null || n === undefined ? undefined : n.id) === e.id;
        })) {
          const t = e.d.strings.find(e => this._symbolNames.has(e.d.value));
          if (t && t.nodeType === 49) {
            this._addResult(t);
          }
        }
        return super.visitStringList(e);
      }
      visitString(e) {
        g.throwIfCancellationRequested(this._cancellationToken);
        if (this._dunderAllNameNodes.has(e)) {
          this._addResult(e);
        }
        return false;
      }
      get _evaluator() {
        return this._program.evaluator;
      }
      _addResult(e) {
        const t = e.nodeType === 38 ? e.d.token : p.getStringNodeValueRange(e);
        this._results.push({
          node: e,
          range: t
        });
      }
      _isDeclarationAllowed(e) {
        return this._declarations.some(t => l.areDeclarationsSame(t, e, this._treatModuleInImportAndFromImportSame, true));
      }
      _resultsContainsDeclaration(e, t) {
        const n = [...t];
        this._usageProviders.forEach(a => a.appendDeclarationsAt(e, t, n));
        return n.some(e => {
          const t = this._aliasResolver.resolve(e, false);
          if (!t) {
            return false;
          }
          if (this._isDeclarationAllowed(t)) {
            return true;
          }
          const n = this._getResolveAliasDeclaration(t);
          return !!n && n !== t && this._isDeclarationAllowed(n);
        });
      }
      _getResolveAliasDeclaration(e) {
        if (n(e)) {
          return l.getDeclarationsWithUsesLocalNameRemoved([e])[0];
        }
        const t = this._aliasResolver.resolve(e, true);
        if (n(t)) {
          return l.getDeclarationsWithUsesLocalNameRemoved([t])[0];
        } else {
          return t;
        }
        function n(e) {
          return !!e && e.type === 8 && e.node && e.usesLocalName && e.node.nodeType === 24;
        }
      }
      _setDunderAllNodes(e) {
        if (e.nodeType !== 36) {
          return;
        }
        const t = i.getDunderAllInfo(e);
        if (!t) {
          return;
        }
        const n = c.getScopeForNode(e);
        if (n) {
          t.stringNodes.forEach(e => {
            if (!this._symbolNames.has(e.d.value)) {
              return;
            }
            const t = n.lookUpSymbolRecursive(e.d.value);
            if (t && this._resultsContainsDeclaration(e, t.symbol.getDeclarations())) {
              this._dunderAllNameNodes.add(e);
            }
          });
        }
      }
    }
    function I(e, t, n = true) {
      var a;
      if (((a = t.parent) === null || a === undefined ? undefined : a.nodeType) !== 37) {
        return function (e, t, n = true) {
          var a;
          var r;
          var s;
          var i;
          T.assert(((a = t.parent) === null || a === undefined ? undefined : a.nodeType) !== 37);
          let p = ((r = e.getDeclInfoForNameNode(t, n)) === null || r === undefined ? undefined : r.decls) || [];
          if (((s = t.parent) === null || s === undefined ? undefined : s.nodeType) === 26) {
            p = p.filter(e => e.node === t.parent);
          }
          if (p.length === 0) {
            const n = e.getType(t);
            if ((n == null ? undefined : n.category) === 7) {
              return [l.synthesizeAliasDeclaration(n.priv.fileUri)];
            }
          }
          for (const t of p.filter(e => o.isAliasDeclaration(e) && !e.loadSymbolsFromPath)) {
            const a = t.node;
            if (a.nodeType !== 26) {
              h.appendArray(p, ((i = e.getDeclInfoForNameNode(a.d.module.d.nameParts[0], n)) === null || i === undefined ? undefined : i.decls) || []);
            }
          }
          return p;
        }(e, t, n);
      } else {
        return function (e, t) {
          var n;
          var a;
          var r;
          var s;
          var i;
          var p;
          var d;
          T.assert(((n = t.parent) === null || n === undefined ? undefined : n.nodeType) === 37);
          const u = t.parent;
          if (((a = u.parent) === null || a === undefined ? undefined : a.nodeType) === 24 || ((r = u.parent) === null || r === undefined ? undefined : r.nodeType) === 25) {
            const n = u.d.nameParts.findIndex(e => e === t);
            if (n === 0) {
              const n = [];
              h.appendArray(n, ((i = (s = e.getDeclInfoForNameNode(u.d.nameParts[0])) === null || s === undefined ? undefined : s.decls) === null || i === undefined ? undefined : i.filter(e => o.isAliasDeclaration(e))) || []);
              if (n.length === 0 || u.parent.nodeType !== 24) {
                return n;
              }
              const a = u.d.nameParts.length === 1 && u.parent.nodeType === 24 && !!u.parent.d.alias;
              const r = a ? u.parent.d.alias.d.value : u.d.nameParts[0].d.value;
              const d = (p = c.getScopeForNode(t)) === null || p === undefined ? undefined : p.lookUpSymbolRecursive(r);
              if (d && u.d.nameParts.length === 1) {
                let e = [];
                h.appendArray(e, d.symbol.getDeclarations().filter(e => o.isAliasDeclaration(e)));
                if (e.length > 1) {
                  e = e.filter(e => e.firstNamePart !== undefined ? e.firstNamePart === u.d.nameParts[0].d.value : e.node === u.parent);
                }
                if (a) {
                  e = l.getDeclarationsWithUsesLocalNameRemoved(e);
                }
                h.appendArray(n, e);
              }
              return n;
            }
            return n > 0 && ((d = e.getDeclInfoForNameNode(u.d.nameParts[n])) === null || d === undefined ? undefined : d.decls) || [];
          }
          return [];
        }(e, t);
      }
    }
    function k(e, t) {
      for (const n of e) {
        if (l.areDeclarationsSame(n, t, false, true)) {
          return;
        }
      }
      e.push(t);
    }
    exports.DocumentSymbolCollector = C;
  },
  86846: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DocumentSymbolProvider = undefined;
    exports.convertToFlatSymbols = l;
    const a = require(56911);
    const r = require(26687);
    const s = require(91426);
    const i = require(5884);
    const o = require(76135);
    function l(e, t, n) {
      const a = [];
      for (const r of n) {
        p(e.fileSystem, a, t, r);
      }
      return a;
    }
    function p(e, t, n, r, s) {
      const o = {
        name: r.name,
        kind: r.kind,
        location: a.Location.create(i.convertUriToLspUriString(e, n), r.range)
      };
      if (r.tags) {
        o.tags = r.tags;
      }
      if (s) {
        o.containerName = s.name;
      }
      t.push(o);
      if (r.children) {
        for (const a of r.children) {
          p(e, t, n, a, r);
        }
      }
    }
    exports.DocumentSymbolProvider = class {
      constructor(e, t, n, a, r) {
        this.program = e;
        this.uri = t;
        this._supportHierarchicalDocumentSymbol = n;
        this._indexOptions = a;
        this._token = r;
        this._parseResults = this.program.getParseResults(this.uri);
      }
      getSymbols() {
        if (!this._parseResults) {
          return [];
        }
        const e = this.getHierarchicalSymbols();
        if (this._supportHierarchicalDocumentSymbol) {
          return e;
        } else {
          return l(this.program, this.uri, e);
        }
      }
      getHierarchicalSymbols() {
        const e = [];
        const t = this.program.getParseResults(this.uri);
        if (!t) {
          return e;
        }
        const n = r.getFileInfo(t.parserOutput.parseTree);
        if (!n) {
          return e;
        }
        const a = o.SymbolIndexer.indexSymbols(n, t, this._indexOptions, this._token);
        this.appendDocumentSymbolsRecursive(a, e);
        return e;
      }
      appendDocumentSymbolsRecursive(e, t) {
        s.throwIfCancellationRequested(this._token);
        if (e) {
          for (const n of e) {
            if (n.alias) {
              continue;
            }
            if (!n.name) {
              continue;
            }
            const e = [];
            this.appendDocumentSymbolsRecursive(n.children, e);
            const a = {
              name: n.name,
              kind: n.kind,
              range: n.range,
              selectionRange: n.selectionRange,
              children: e
            };
            t.push(a);
          }
        }
      }
    };
  },
  55275: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DynamicFeatures = exports.DynamicFeature = undefined;
    exports.DynamicFeature = class {
      constructor(e) {
        this.name = e;
      }
      register() {
        this.registerFeature().then(e => {
          this.dispose();
          this._lastRegistration = e;
        });
      }
      update(e) {}
      dispose() {
        var e;
        if ((e = this._lastRegistration) !== null && e !== undefined) {
          e.dispose();
        }
        this._lastRegistration = undefined;
      }
    };
    exports.DynamicFeatures = class {
      constructor() {
        this._map = new Map();
      }
      add(e) {
        const t = this._map.get(e.name);
        if (t) {
          t.dispose();
        }
        this._map.set(e.name, e);
      }
      update(e) {
        for (const t of this._map.values()) {
          t.update(e);
        }
      }
      register() {
        for (const e of this._map.values()) {
          e.register();
        }
      }
      unregister() {
        for (const e of this._map.values()) {
          e.dispose();
        }
        this._map.clear();
      }
    };
  },
  86295: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.FileWatcherDynamicFeature = undefined;
    const a = require(56911);
    const r = require(5884);
    const s = require(55275);
    const i = require(34455);
    const o = require(4883);
    class l extends s.DynamicFeature {
      constructor(e, t, n, a) {
        super('file watcher');
        this._connection = e;
        this._hasWatchFileRelativePathCapability = t;
        this._fs = n;
        this._workspaceFactory = a;
      }
      registerFeature() {
        const e = a.WatchKind.Create | a.WatchKind.Change | a.WatchKind.Delete;
        const t = [{
          globPattern: `**/${o.configFileName}`,
          kind: e
        }, {
          globPattern: '**',
          kind: e
        }];
        if (this._hasWatchFileRelativePathCapability) {
          const n = this._workspaceFactory.getNonDefaultWorkspaces().map(e => [...e.searchPathsToWatch, ...e.service.getConfigOptions().getExecutionEnvironments().map(e => e.extraPaths).flat()]);
          r.deduplicateFolders(n, this._workspaceFactory.getNonDefaultWorkspaces().map(e => e.rootUri).filter(i.isDefined)).forEach(n => {
            const a = r.isFile(this._fs, n, true) ? {
              baseUri: n.getDirectory().toString(),
              pattern: n.fileName
            } : {
              baseUri: n.toString(),
              pattern: '**'
            };
            t.push({
              globPattern: a,
              kind: e
            });
          });
        }
        return this._connection.client.register(a.DidChangeWatchedFilesNotification.type, {
          watchers: t
        });
      }
    }
    exports.FileWatcherDynamicFeature = l;
  },
  79943: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.HoverProvider = undefined;
    exports.convertHoverResults = f;
    exports.addParameterResultsPart = T;
    exports.addDocumentationResultsPart = v;
    exports.getVariableTypeText = b;
    const i = require(56911);
    const o = require(28445);
    const l = __importStar(require(41557));
    const p = require(30889);
    const d = require(92324);
    const c = require(21024);
    const u = require(91426);
    const m = require(48281);
    const y = require(56814);
    const g = require(88754);
    const h = require(39426);
    function f(e, t) {
      if (!e) {
        return null;
      }
      const n = e.parts.map(e => {
        if (e.python) {
          if (t === i.MarkupKind.Markdown) {
            return `\`\`\`python
${e.text}
\`\`\`
`;
          }
          if (t === i.MarkupKind.PlainText) {
            return e.text + '\n\n';
          }
          m.fail(`Unsupported markup type: ${t}`);
        }
        return e.text;
      }).join('').trimEnd();
      return {
        contents: {
          kind: t,
          value: n
        },
        range: e.range
      };
    }
    function T(e, t, n, a, r) {
      var s;
      var i;
      let o;
      const p = l.getEnclosingFunction((n == null ? undefined : n.node) || t);
      if (p) {
        o = l.getDocString((i = (s = p == null ? undefined : p.d.suite) === null || s === undefined ? undefined : s.d.statements) !== null && i !== undefined ? i : []);
        if (o) {
          o = e.docStringService().extractParameterDocumentation(o, t.d.value, a);
        }
      }
      if (o) {
        r.push({
          python: false,
          text: o
        });
      }
    }
    function v(e, t, n, a, r) {
      if (t) {
        if (n === i.MarkupKind.Markdown) {
          const n = e.docStringService().convertDocStringToMarkdown(t, p.isBuiltInModule(r == null ? undefined : r.uri));
          if (a.length > 0 && n.length > 0) {
            a.push({
              text: '---\n'
            });
          }
          a.push({
            text: n,
            python: false
          });
          return;
        }
        if (n !== i.MarkupKind.PlainText) {
          m.fail(`Unsupported markup type: ${n}`);
        } else {
          a.push({
            text: e.docStringService().convertDocStringToPlainText(t),
            python: false
          });
        }
      }
    }
    function b(e, t, n, a, r, s) {
      var i;
      let o;
      let l = 'variable';
      if (t) {
        l = t.isConstant || e.isFinalVariableDeclaration(t) ? 'constant' : 'variable';
      }
      if (((i = a.props) === null || i === undefined ? undefined : i.typeAliasInfo) && r.nodeType === 38) {
        const t = c.getTypeAliasInfo(a);
        if ((t == null ? undefined : t.shared.name) === r.d.value) {
          if (!c.isTypeVar(a)) {
            return `(type) ${n} = ${e.printType(d.convertToInstance(h.getTypeForToolTip(e, r)), {
              expandTypeAlias: true
            })}`;
          }
          l = c.isParamSpec(a) ? 'param spec' : 'type variable';
          o = a.shared.name;
        }
      }
      if (a.category === 4 || a.category === 5) {
        return h.getToolTipForType(a, l, n, e, false, s);
      }
      return `(${l}) ${o ?? n + ': ' + e.printType(h.getTypeForToolTip(e, r))}`;
    }
    class _ {
      constructor(e, t, n, a, r) {
        this._program = e;
        this._fileUri = t;
        this._position = n;
        this._format = a;
        this._token = r;
        this._parseResults = this._program.getParseResults(this._fileUri);
        this._sourceMapper = this._program.getSourceMapper(this._fileUri, this._token, true);
      }
      getHover() {
        return f(this._getHoverResult(), this._format);
      }
      static getPrimaryDeclaration(e) {
        const t = e[0];
        if (t.type === 8 && e.length > 1 || t.type === 1 && e.length > 1 && t.isDefinedBySlots) {
          return e[1];
        } else {
          return t;
        }
      }
      get _evaluator() {
        return this._program.evaluator;
      }
      get _functionSignatureDisplay() {
        return this._program.configOptions.functionSignatureDisplay;
      }
      _getHoverResult() {
        var e;
        var t;
        u.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const n = y.convertPositionToOffset(this._position, this._parseResults.tokenizerOutput.lines);
        if (n === undefined) {
          return null;
        }
        let a = l.findNodeByOffset(this._parseResults.parserOutput.parseTree, n);
        if (a === undefined) {
          return null;
        }
        const r = {
          parts: [],
          range: {
            start: y.convertOffsetToPosition(a.start, this._parseResults.tokenizerOutput.lines),
            end: y.convertOffsetToPosition(g.TextRange.getEnd(a), this._parseResults.tokenizerOutput.lines)
          }
        };
        if (a.nodeType === 38) {
          if (((e = a.parent) === null || e === undefined ? undefined : e.nodeType) === 1 && a.parent.d.isNameSameAsValue && a.parent.d.name === a && a.parent.d.valueExpr.nodeType === 38) {
            a = a.parent.d.valueExpr;
          }
          const t = this._evaluator.getDeclInfoForNameNode(a);
          const n = t == null ? undefined : t.decls;
          if (n && n.length > 0) {
            const e = _.getPrimaryDeclaration(n);
            this._addResultsForDeclaration(r.parts, e, a);
          } else {
            if (t && t.synthesizedTypes.length > 0) {
              const e = a;
              if (t != null) {
                t.synthesizedTypes.forEach(t => {
                  this._addResultsForSynthesizedType(r.parts, t, e);
                });
              }
              this._addDocumentationPart(r.parts, a, undefined);
            } else {
              if ((!a.parent || a.parent.nodeType !== 37) && r.parts.length === 0) {
                const e = this._getType(a);
                let t;
                if (c.isModule(e)) {
                  t = `(module) ${a.d.value}`;
                } else {
                  let n = 'function';
                  let r = false;
                  if (d.isMaybeDescriptorInstance(e, false)) {
                    r = true;
                    n = 'property';
                  }
                  t = h.getToolTipForType(e, n, a.d.value, this._evaluator, r, this._functionSignatureDisplay);
                }
                this._addResultsPart(r.parts, t, true);
                this._addDocumentationPart(r.parts, a, undefined);
              }
            }
          }
        } else {
          if (a.nodeType === 49) {
            const e = (t = this._evaluator.getExpectedType(a)) === null || t === undefined ? undefined : t.type;
            if (e !== undefined) {
              this._tryAddPartsForTypedDictKey(a, e, r.parts);
            }
          }
        }
        if (r.parts.length > 0) {
          return r;
        } else {
          return null;
        }
      }
      _addResultsForDeclaration(e, t, n) {
        var a;
        var r;
        var s;
        const i = t.type === 8 ? this._evaluator.resolveAliasDeclaration(t, true) : t;
        if (!i || i.type === 8 && o.isUnresolvedAliasDeclaration(i)) {
          this._addResultsPart(e, `(import) ${n.d.value}${this._getTypeText(n)}`, true);
        } else {
          switch (i.type) {
            case 0:
              this._addResultsPart(e, n.d.value + this._getTypeText(n), true);
              this._addDocumentationPart(e, n, i);
              break;
            case 1:
              {
                let r = n;
                if (t.node.nodeType === 24 || t.node.nodeType === 26) {
                  if (t.node.d.alias && n !== t.node.d.alias && i.node.nodeType === 38) {
                    r = i.node;
                  }
                } else {
                  if (((a = n.parent) === null || a === undefined ? undefined : a.nodeType) === 1 && n.parent.d.name === n && t.node.nodeType === 38) {
                    r = t.node;
                  }
                }
                const s = this._getType(r);
                const o = b(this._evaluator, i, n.d.value, s, r, this._functionSignatureDisplay);
                this._addResultsPart(e, o, true);
                this._addDocumentationPart(e, n, i);
                break;
              }
            case 2:
              this._addResultsPart(e, `(parameter) ${n.d.value}${this._getTypeText(n)}`, true);
              T(this._program.serviceProvider, n, i, this._format, e);
              this._addDocumentationPart(e, n, i);
              break;
            case 3:
              {
                const t = l.getParentNodeOfType(n, 76);
                const a = (r = t == null ? undefined : t.parent) === null || r === undefined ? undefined : r.nodeType;
                const s = a === 10 || a === 77;
                this._addResultsPart(e, `(type parameter) ${n.d.value}${this._getTypeText(n, {
                  printTypeVarVariance: s
                })}`, true);
                this._addDocumentationPart(e, n, i);
                break;
              }
            case 6:
            case 7:
              {
                if (this._addInitOrNewMethodInsteadIfCallNode(n, e, i)) {
                  return;
                }
                const t = i.type === 6 ? i.node.d.name : n;
                this._addResultsPart(e, `(class) ${t.d.value}`, true);
                this._addDocumentationPart(e, n, i);
                break;
              }
            case 5:
              {
                let t = 'function';
                let a = false;
                if (i.isMethod) {
                  const e = (s = this._evaluator.getTypeForDeclaration(i)) === null || s === undefined ? undefined : s.type;
                  a = !!e && d.isMaybeDescriptorInstance(e, false);
                  t = a ? 'property' : 'method';
                }
                let r = this._getType(n);
                const o = this._getType(i.node.d.name);
                r = c.isAnyOrUnknown(r) ? o : r;
                const l = h.getToolTipForType(r, t, n.d.value, this._evaluator, a, this._functionSignatureDisplay);
                this._addResultsPart(e, l, true);
                this._addDocumentationPart(e, n, i);
                break;
              }
            case 8:
              this._addResultsPart(e, `(module) ${n.d.value}`, true);
              this._addDocumentationPart(e, n, i);
              break;
            case 4:
              {
                const t = d.convertToInstance(this._getType(n));
                const a = this._evaluator.printType(t, {
                  expandTypeAlias: true
                });
                this._addResultsPart(e, `(type) ${n.d.value} = ${a}`, true);
                this._addDocumentationPart(e, n, i);
                break;
              }
            default:
              m.assertNever(i);
          }
        }
      }
      _addResultsForSynthesizedType(e, t, n) {
        var a;
        let r;
        if (c.isModule(t.type)) {
          r = `(module) ${n.d.value}`;
        } else {
          const e = (a = t.node) !== null && a !== undefined ? a : n;
          const s = this._getType(e);
          r = b(this._evaluator, undefined, e.d.value, s, e, this._functionSignatureDisplay);
        }
        if (r) {
          this._addResultsPart(e, r, true);
        }
      }
      _tryAddPartsForTypedDictKey(e, t, n) {
        d.doForEachSubtype(t, t => {
          var a;
          var r;
          if (c.isClassInstance(t) && c.ClassType.isTypedDictClass(t)) {
            const s = (a = t.shared.typedDictEntries) === null || a === undefined ? undefined : a.knownItems.get(e.d.value);
            if (s) {
              if (n.length > 0) {
                n.push({
                  text: '\n\n---\n'
                });
              }
              const a = `(key) ${e.d.value}: ${this._evaluator.printType(s.valueType)}`;
              this._addResultsPart(n, a, true);
              const i = (r = c.ClassType.getSymbolTable(t).get(e.d.value)) === null || r === undefined ? undefined : r.getDeclarations();
              if (i !== undefined && (i == null ? undefined : i.length) !== 0) {
                const e = i[0];
                if (e.type === 1 && e.docString !== undefined) {
                  this._addDocumentationPartForType(n, t, e);
                }
              }
            }
          }
        });
      }
      _addInitOrNewMethodInsteadIfCallNode(e, t, n) {
        const a = h.getClassAndConstructorTypes(e, this._evaluator);
        if (!a) {
          return false;
        }
        if (a.methodType && (c.isFunction(a.methodType) || c.isOverloaded(a.methodType))) {
          this._addResultsPart(t, h.getConstructorTooltip(e.d.value, a.methodType, this._evaluator, this._functionSignatureDisplay), true);
          if (!this._addDocumentationPartForType(t, a.methodType, n)) {
            this._addDocumentationPartForType(t, a.classType, n);
          }
          return true;
        }
        return false;
      }
      _getType(e) {
        return h.getTypeForToolTip(this._evaluator, e);
      }
      _getTypeText(e, t) {
        const n = this._getType(e);
        return `: ${this._evaluator.printType(n, t)}`;
      }
      _addDocumentationPart(e, t, n) {
        const a = this._getType(t);
        this._addDocumentationPartForType(e, a, n, t.d.value);
      }
      _addDocumentationPartForType(e, t, n, a) {
        const r = h.getDocumentationPartsForTypeAndDecl(this._sourceMapper, t, n, this._evaluator, {
          name: a
        });
        v(this._program.serviceProvider, r, this._format, e, n);
        return !!r;
      }
      _addResultsPart(e, t, n = false) {
        e.push({
          python: n,
          text: t
        });
      }
    }
    exports.HoverProvider = _;
  },
  47091: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.canNavigateToFile = s;
    exports.convertDocumentRangesToLocation = function (e, t, n = i) {
      return t.map(t => n(e, t)).filter(e => !!e);
    };
    exports.convertDocumentRangeToLocation = i;
    const a = require(38659);
    const r = require(5884);
    function s(e, t) {
      return !e.isInZip(t);
    }
    function i(e, t) {
      if (s(e, t.uri)) {
        return a.Location.create(r.convertUriToLspUriString(e, t.uri), t.range);
      }
    }
  },
  26005: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ReferencesProvider = exports.FindReferencesTreeWalker = exports.ReferencesResult = undefined;
    const i = require(28445);
    const o = require(83760);
    const l = __importStar(require(41557));
    const p = require(3433);
    const d = require(4064);
    const c = require(21024);
    const u = require(91426);
    const m = require(58147);
    const y = require(34455);
    const g = require(48281);
    const h = require(56507);
    const f = require(56814);
    const T = require(71745);
    const v = require(88754);
    const b = require(67032);
    const _ = require(47091);
    class C {
      constructor(e, t, n, a, r, s, o) {
        this.requiresGlobalSearch = e;
        this.nodeAtOffset = t;
        this.symbolNames = n;
        this.declarations = a;
        this.useCase = r;
        this.providers = s;
        this._reporter = o;
        this._results = [];
        this.nonImportDeclarations = a.filter(e => {
          var t;
          if (!i.isAliasDeclaration(e)) {
            return true;
          }
          if (!e.usesLocalName || !e.node) {
            return false;
          }
          if (e.node.nodeType === 25) {
            return false;
          }
          const a = (t = e.node.d.alias) === null || t === undefined ? undefined : t.d.value;
          return !!n.some(e => e === a);
        });
      }
      get containsOnlyImportDecls() {
        return this.declarations.length > 0 && this.nonImportDeclarations.length === 0;
      }
      get locations() {
        return this._results.map(e => e.location);
      }
      get results() {
        return this._results;
      }
      addResults(...e) {
        if (e.length !== 0) {
          if (this._reporter) {
            this._reporter(e.map(e => e.location));
          }
          m.appendArray(this._results, e);
        }
      }
    }
    exports.ReferencesResult = C;
    class I {
      constructor(e, t, n, a, r, s = I.createDocumentRange) {
        this._program = e;
        this._fileUri = t;
        this._referencesResult = n;
        this._includeDeclaration = a;
        this._cancellationToken = r;
        this._createDocumentRange = s;
        this._parseResults = this._program.getParseResults(this._fileUri);
      }
      findReferences(e) {
        var t;
        if (e === undefined) {
          e = (t = this._parseResults) === null || t === undefined ? undefined : t.parserOutput.parseTree;
        }
        const n = [];
        if (!this._parseResults) {
          return n;
        }
        const a = new b.DocumentSymbolCollector(this._program, this._referencesResult.symbolNames, this._referencesResult.declarations, e, this._cancellationToken, {
          treatModuleInImportAndFromImportSame: true,
          skipUnreachableCode: false,
          useCase: this._referencesResult.useCase,
          providers: this._referencesResult.providers
        });
        for (const e of a.collect()) {
          if (this._includeDeclaration || e.node !== this._referencesResult.nodeAtOffset) {
            n.push({
              node: e.node,
              location: this._createDocumentRange(this._fileUri, e, this._parseResults),
              parentRange: e.node.parent ? {
                start: f.convertOffsetToPosition(e.node.parent.start, this._parseResults.tokenizerOutput.lines),
                end: f.convertOffsetToPosition(v.TextRange.getEnd(e.node.parent), this._parseResults.tokenizerOutput.lines)
              } : undefined
            });
          }
        }
        return n;
      }
      static createDocumentRange(e, t, n) {
        return {
          uri: e,
          range: {
            start: f.convertOffsetToPosition(t.range.start, n.tokenizerOutput.lines),
            end: f.convertOffsetToPosition(v.TextRange.getEnd(t.range), n.tokenizerOutput.lines)
          }
        };
      }
    }
    exports.FindReferencesTreeWalker = I;
    class k {
      constructor(e, t, n, a) {
        this._program = e;
        this._token = t;
        this._createDocumentRange = n;
        this._convertToLocation = a;
      }
      reportReferences(e, t, n, a) {
        const r = this._program.getSourceFileInfo(e);
        if (!r) {
          return;
        }
        if (!this._program.getParseResults(e)) {
          return;
        }
        const s = [];
        const i = a ? e => a.report(_.convertDocumentRangesToLocation(this._program.fileSystem, e, this._convertToLocation)) : e => m.appendArray(s, _.convertDocumentRangesToLocation(this._program.fileSystem, e, this._convertToLocation));
        const o = p.isUserCode(r);
        const l = k.getDeclarationForPosition(this._program, e, t, i, h.ReferenceUseCase.References, this._token);
        if (!l) {
          return;
        }
        if (!l.requiresGlobalSearch) {
          this.addReferencesToResult(r.sourceFile.getUri(), n, l);
        }
        for (const e of this._program.getSourceFileInfoList()) {
          u.throwIfCancellationRequested(this._token);
          if (e.isOpenByClient || !o || p.isUserCode(e)) {
            const t = e.sourceFile.getFileContent();
            if (!t || !!l.symbolNames.some(e => t.search(e) >= 0)) {
              this.addReferencesToResult(e.sourceFile.getUri(), n, l);
            }
            this._program.handleMemoryHighUsage();
          }
        }
        if (n) {
          for (const e of l.declarations) {
            u.throwIfCancellationRequested(this._token);
            if (l.locations.some(t => t.uri.equals(e.uri))) {
              continue;
            }
            const t = this._program.getSourceFileInfo(e.uri);
            if (!t) {
              continue;
            }
            const a = new C(l.requiresGlobalSearch, l.nodeAtOffset, l.symbolNames, l.declarations, l.useCase, l.providers);
            this.addReferencesToResult(t.sourceFile.getUri(), n, a);
            for (const t of a.results) {
              if (t.location.uri.equals(e.uri) && v.doesRangeContain(e.range, t.location.range)) {
                l.addResults(t);
              }
            }
          }
        }
        const d = new Set();
        const c = [];
        for (const e of s) {
          const t = `${e.uri.toString()}:${e.range.start.line}:${e.range.start.character}`;
          if (!d.has(t)) {
            d.add(t);
            c.push(e);
          }
        }
        return c;
      }
      addReferencesToResult(e, t, n) {
        if (!this._program.getParseResults(e)) {
          return;
        }
        const a = new I(this._program, e, n, t, this._token, this._createDocumentRange);
        n.addResults(...a.findReferences());
      }
      static getDeclarationForNode(e, t, n, a, r, s) {
        var i;
        u.throwIfCancellationRequested(s);
        const p = b.DocumentSymbolCollector.getDeclarationsForNode(e, n, false, s);
        if (p.length === 0) {
          return;
        }
        const m = function (e, t, n, a) {
          const r = e.lookUpSymbolRecursive(n, n.d.value, false);
          if (r && !s(r.symbol)) {
            return false;
          }
          return a.some(e => {
            var n;
            var a;
            if (!e.uri.equals(t)) {
              return true;
            }
            const r = l.getEvaluationScopeNode(e.node).node;
            return r.nodeType === 36 || r.nodeType === 10 || ((a = (n = e.node) === null || n === undefined ? undefined : n.parent) === null || a === undefined ? undefined : a.nodeType) === 35 && e.node === e.node.parent.d.member;
          });
          function s(e, t = 0) {
            return !(t > c.maxTypeRecursionCount) && (t++, !!d.isVisibleExternally(e) && e.getDeclarations().reduce((e, n) => {
              if (!e) {
                return false;
              }
              switch (n.type) {
                case 8:
                case 0:
                case 7:
                  return e;
                case 6:
                case 5:
                case 2:
                  return e && i(n.node.d.name, t);
                case 3:
                  return false;
                case 1:
                case 4:
                  return n.node.nodeType === 38 && e && i(n.node, t);
                default:
                  g.assertNever(n);
              }
            }, true));
          }
          function i(t, n) {
            const a = l.getEvaluationScopeNode(t).node;
            switch (a.nodeType) {
              case 10:
              case 31:
                {
                  const t = a.d.name;
                  const r = e.lookUpSymbolRecursive(t, t.d.value, false);
                  return !r || s(r.symbol, n);
                }
              case 33:
              case 11:
              case 76:
                return false;
              case 36:
                return true;
              default:
                g.assertNever(a);
            }
          }
        }(e.evaluator, t, n, p);
        const h = new Set(p.map(e => o.getNameFromDeclaration(e)).filter(e => !!e));
        h.add(n.d.value);
        const f = ((i = e.serviceProvider.tryGet(T.ServiceKeys.symbolUsageProviderFactory)) !== null && i !== undefined ? i : []).map(e => e.tryCreateProvider(r, p, s)).filter(y.isDefined);
        f.forEach(e => {
          e.appendSymbolNamesTo(h);
          e.appendDeclarationsTo(p);
        });
        return new C(m, n, Array.from(h.values()), p, r, f, a);
      }
      static getDeclarationForPosition(e, t, n, a, r, s) {
        u.throwIfCancellationRequested(s);
        const i = e.getParseResults(t);
        if (!i) {
          return;
        }
        const o = f.convertPositionToOffset(n, i.tokenizerOutput.lines);
        if (o === undefined) {
          return;
        }
        const p = l.findNodeByOffset(i.parserOutput.parseTree, o);
        if (p !== undefined && p.nodeType === 38) {
          return this.getDeclarationForNode(e, t, p, a, r, s);
        } else {
          return undefined;
        }
      }
    }
    exports.ReferencesProvider = k;
  },
  79725: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.RenameProvider = undefined;
    const a = require(3433);
    const r = require(91426);
    const s = require(48281);
    const i = require(56507);
    const o = require(56814);
    const l = require(74382);
    const p = require(26005);
    class d {
      constructor(e, t, n, a) {
        this._program = e;
        this._fileUri = t;
        this._position = n;
        this._token = a;
        this._parseResults = this._program.getParseResults(this._fileUri);
      }
      canRenameSymbol(e, t) {
        r.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const n = this._getReferenceResult();
        if (!n) {
          return null;
        }
        if (d.getRenameSymbolMode(this._program, this._fileUri, n, e, t) === 'none') {
          return null;
        } else {
          return o.convertTextRangeToRange(n.nodeAtOffset, this._parseResults.tokenizerOutput.lines);
        }
      }
      renameSymbol(e, t, n) {
        var i;
        r.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return null;
        }
        const o = this._getReferenceResult();
        if (!o) {
          return null;
        }
        const c = new p.ReferencesProvider(this._program, this._token);
        const u = d.getRenameSymbolMode(this._program, this._fileUri, o, t, n);
        switch (u) {
          case 'singleFileMode':
            c.addReferencesToResult(this._fileUri, true, o);
            break;
          case 'multiFileMode':
            for (const e of this._program.getSourceFileInfoList()) {
              if (a.isUserCode(e)) {
                const t = (i = e.sourceFile.getFileContent()) !== null && i !== undefined ? i : '';
                if (!o.symbolNames.some(e => t.search(e) >= 0)) {
                  continue;
                }
                c.addReferencesToResult(e.sourceFile.getUri(), true, o);
              }
              this._program.handleMemoryHighUsage();
            }
            break;
          case 'none':
            return null;
          default:
            s.assertNever(u);
        }
        const m = [];
        o.results.forEach(t => {
          var n;
          const a = t.node;
          let r = t.location.range;
          let s = e;
          if (a.nodeType === 38 && ((n = a.parent) === null || n === undefined ? undefined : n.nodeType) === 1 && a.parent.d.isNameSameAsValue && t.parentRange) {
            r = t.parentRange;
            s = a === a.parent.d.valueExpr ? `${a.d.value}=${e}` : `${e}=${a.d.value}`;
          }
          m.push({
            fileUri: t.location.uri,
            range: r,
            replacementText: s
          });
        });
        return l.convertToWorkspaceEdit(this._program.fileSystem, {
          edits: m,
          fileOperations: []
        });
      }
      static getRenameSymbolMode(e, t, n, r, s) {
        const i = e.getSourceFileInfo(t);
        const o = a.isUserCode(i);
        if (r || o && !n.requiresGlobalSearch || !o && i.isOpenByClient && n.declarations.every(t => e.getSourceFileInfo(t.uri) === i)) {
          return 'singleFileMode';
        } else {
          if (n.declarations.every(t => a.isUserCode(e.getSourceFileInfo(t.uri)))) {
            return 'multiFileMode';
          } else {
            return 'none';
          }
        }
      }
      _getReferenceResult() {
        const e = p.ReferencesProvider.getDeclarationForPosition(this._program, this._fileUri, this._position, undefined, i.ReferenceUseCase.Rename, this._token);
        if (e && !e.containsOnlyImportDecls && e.nonImportDeclarations.length !== 0) {
          return new p.ReferencesResult(e.requiresGlobalSearch, e.nodeAtOffset, e.symbolNames, e.nonImportDeclarations, e.useCase, e.providers);
        }
      }
    }
    exports.RenameProvider = d;
  },
  7380: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SignatureHelpProvider = undefined;
    const i = require(56911);
    const o = require(26687);
    const l = require(44321);
    const p = __importStar(require(41557));
    const d = require(41557);
    const c = require(30889);
    const u = require(91426);
    const m = require(56814);
    const y = require(49969);
    const g = require(39426);
    exports.SignatureHelpProvider = class {
      constructor(e, t, n, a, r, s, i, o, l) {
        this._program = e;
        this._fileUri = t;
        this._position = n;
        this._format = a;
        this._hasSignatureLabelOffsetCapability = r;
        this._hasActiveParameterCapability = s;
        this._context = i;
        this._docStringService = o;
        this._token = l;
        this._parseResults = this._program.getParseResults(this._fileUri);
        this._sourceMapper = this._program.getSourceMapper(this._fileUri, this._token, true);
      }
      getSignatureHelp() {
        return this._convert(this._getSignatureHelp());
      }
      get _evaluator() {
        return this._program.evaluator;
      }
      _getSignatureHelp() {
        var e;
        u.throwIfCancellationRequested(this._token);
        if (!this._parseResults) {
          return;
        }
        const t = m.convertPositionToOffset(this._position, this._parseResults.tokenizerOutput.lines);
        if (t === undefined) {
          return;
        }
        let n = p.findNodeByOffset(this._parseResults.parserOutput.parseTree, t);
        const a = n;
        const r = n ? p.getNodeDepth(n) : 0;
        let s = t - 1;
        while (s >= 0) {
          const e = this._parseResults.text.substr(s, 1);
          if (e === ',' || e === '(') {
            break;
          }
          const t = p.findNodeByOffset(this._parseResults.parserOutput.parseTree, s);
          if (t && t !== a) {
            if (p.getNodeDepth(t) > r) {
              n = t;
            }
            break;
          }
          s--;
        }
        if (n === undefined) {
          return;
        }
        const i = d.getCallNodeAndActiveParamIndex(n, t, this._parseResults.tokenizerOutput.tokens);
        if (!i) {
          return;
        }
        const o = this._evaluator.getCallSignatureInfo(i.callNode, i.activeIndex, i.activeOrFake);
        if (!o) {
          return;
        }
        return {
          signatures: o.signatures.map(e => this._makeSignature(o.callNode, e)),
          callHasParameters: !!((e = o.callNode.d.args) === null || e === undefined ? undefined : e.length)
        };
      }
      _convert(e) {
        var t;
        var n;
        var a;
        if (!e) {
          return;
        }
        const r = e.signatures.map(e => {
          let t = [];
          if (e.parameters) {
            t = e.parameters.map(e => {
              var t;
              return {
                label: this._hasSignatureLabelOffsetCapability ? [e.startOffset, e.endOffset] : e.text,
                documentation: {
                  kind: this._format,
                  value: (t = e.documentation) !== null && t !== undefined ? t : ''
                }
              };
            });
          }
          const n = i.SignatureInformation.create(e.label, undefined, ...t);
          if (e.documentation !== undefined) {
            n.documentation = e.documentation;
          }
          if (e.activeParameter !== undefined) {
            n.activeParameter = e.activeParameter;
          }
          return n;
        });
        const s = t => {
          var n;
          return t.activeParameter !== undefined || !e.callHasParameters && !((n = t.parameters) === null || n === undefined ? undefined : n.length);
        };
        let o = r.findIndex(s);
        if (o === -1) {
          o = undefined;
        }
        let l = o !== undefined ? r[o].activeParameter : undefined;
        if (((t = this._context) === null || t === undefined ? undefined : t.isRetrigger) && this._context.triggerKind !== i.SignatureHelpTriggerKind.Invoked) {
          const e = (n = this._context.activeSignatureHelp) === null || n === undefined ? undefined : n.activeSignature;
          if (e !== undefined && e < r.length) {
            const t = r[e];
            if (s(t)) {
              o = e;
              l = (a = t.activeParameter) !== null && a !== undefined ? a : undefined;
            }
          }
        }
        if (this._hasActiveParameterCapability || o === undefined) {
          l = Math.max(...r.map(e => {
            var t;
            var n;
            if ((n = (t = e.parameters) === null || t === undefined ? undefined : t.length) !== null && n !== undefined) {
              return n;
            } else {
              return 0;
            }
          }));
        }
        return {
          signatures: r,
          activeSignature: o,
          activeParameter: l
        };
      }
      _makeSignature(e, t) {
        var n;
        const a = t.type;
        const r = this._evaluator.printFunctionParts(a, 1024);
        const s = [];
        const p = (n = g.getFunctionDocStringFromType(a, this._sourceMapper, this._evaluator)) !== null && n !== undefined ? n : this._getDocStringFromCallNode(e);
        const d = o.getFileInfo(e);
        const u = l.getParamListDetails(a);
        let m;
        let h = '(';
        let f = true;
        const T = a.shared.parameters;
        r[0].forEach((e, n) => {
          let a = '';
          if (n < T.length) {
            a = T[n].name || '';
          } else {
            if (T.length > 0) {
              a = T[T.length - 1].name || '';
            }
          }
          if (!u.params.some(e => e.param.name === a && e.kind === l.ParamKind.Keyword) || !!y.Tokenizer.isPythonIdentifier(a)) {
            if (!f) {
              h += ', ';
            }
            f = false;
            s.push({
              startOffset: h.length,
              endOffset: h.length + e.length,
              text: e
            });
            if (a && t.activeParam && t.activeParam.name === a) {
              m = s.length - 1;
            }
            h += e;
          }
        });
        h += `) -> ${r[1]}`;
        if (t.activeParam && m === undefined) {
          m = T.indexOf(t.activeParam);
          if (m === -1) {
            m = undefined;
          }
        }
        if (m !== undefined) {
          const e = s[m];
          if (e) {
            e.documentation = this._docStringService.extractParameterDocumentation(p || '', T[m].name || '', this._format);
          }
        }
        const v = {
          label: h,
          parameters: s,
          activeParameter: m
        };
        if (p) {
          if (this._format === i.MarkupKind.Markdown) {
            v.documentation = {
              kind: i.MarkupKind.Markdown,
              value: this._docStringService.convertDocStringToMarkdown(p, c.isBuiltInModule(d == null ? undefined : d.fileUri))
            };
          } else {
            v.documentation = {
              kind: i.MarkupKind.PlainText,
              value: this._docStringService.convertDocStringToPlainText(p)
            };
          }
        }
        return v;
      }
      _getDocStringFromCallNode(e) {
        var t;
        var n;
        let a;
        const r = e.d.leftExpr;
        if (r.nodeType === 38) {
          a = r;
        } else {
          if (r.nodeType === 35) {
            a = r.d.member;
          }
        }
        if (a) {
          for (const e of (n = (t = this._evaluator.getDeclInfoForNameNode(a)) === null || t === undefined ? undefined : t.decls) !== null && n !== undefined ? n : []) {
            const t = this._evaluator.resolveAliasDeclaration(e, true);
            if (!t) {
              continue;
            }
            const n = this._evaluator.getType(a);
            if (!n) {
              continue;
            }
            const r = g.getDocumentationPartsForTypeAndDecl(this._sourceMapper, n, t, this._evaluator);
            if (r) {
              return r;
            }
          }
        }
      }
    };
  },
  76135: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.SymbolIndexer = undefined;
    exports.isIndexSymbolVisibleFlagSet = function (e, t) {
      return !!(e.visibilityFlags & t);
    };
    const i = __importStar(require(26687));
    const o = require(4064);
    const l = require(91426);
    const p = require(56412);
    const d = require(56814);
    const c = require(16835);
    function u(e, t, n, a, r, s) {
      l.throwIfCancellationRequested(s);
      const y = i.getScope(n);
      if (!y) {
        return;
      }
      y.symbolTable.forEach((n, i) => {
        if (n.isIgnoredForProtocolMatch()) {
          return;
        }
        let l = o.getLastTypedDeclarationForSymbol(n);
        if (!l && n.hasDeclarations()) {
          l = n.getDeclarations()[0];
        }
        if (l && (l.type !== 8 || m(l, a))) {
          (function (e, t, n, a, r, s, i, o) {
            const l = p.getSymbolKind(n, undefined, s);
            if (l === undefined) {
              return;
            }
            let y = n.range;
            let g = y;
            const h = [];
            if (n.type === 6 || n.type === 5) {
              u(e, t, n.node, a, h, o);
              g = d.convertOffsetsToRange(n.node.start, n.node.start + n.node.length, t.tokenizerOutput.lines);
            }
            if (n.type === 8) {
              if (!m(n, a)) {
                return;
              }
              if (n.node.nodeType === 24 && n.node.d.alias) {
                y = g = d.convertTextRangeToRange(n.node.d.alias.d.token, t.tokenizerOutput.lines);
              }
            }
            const f = {
              name: s,
              visibilityFlags: 1,
              kind: l,
              itemKind: c.convertSymbolKindToCompletionItemKind(l),
              alias: undefined,
              range: g,
              selectionRange: y,
              children: h
            };
            i.push(f);
          })(e, t, l, a, o.isVisibleExternally(n), i, r, s);
        }
      });
    }
    function m(e, t) {
      return !!t.includeAliases && (e.node.nodeType === 24 || e.node.nodeType === 26) && e.node.d.alias !== undefined;
    }
    exports.SymbolIndexer = class {
      static indexSymbols(e, t, n, a) {
        const r = [];
        u(e, t, t.parserOutput.parseTree, n, r, a);
        return r;
      }
    };
  },
  39426: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getToolTipForType = function (e, t, n, a, r, s) {
      let i = '';
      if (p.isOverloaded(e)) {
        i = t.length > 0 ? `(${t})\n` : '';
        i += `${m(e, a, s)}`;
      } else {
        if (p.isFunction(e)) {
          i = `${y(t, n, e, a, r, s)}`;
        } else {
          i = t.length > 0 ? `(${t}) ` : '';
          i += `${n}: ${a.printType(e)}`;
        }
      }
      return i;
    };
    exports.getOverloadedTooltip = m;
    exports.getFunctionTooltip = y;
    exports.getConstructorTooltip = function e(t, n, a, r) {
      let s = '';
      if (p.isOverloaded(n)) {
        p.OverloadedType.getOverloads(n).map(n => e(t, n, a, r)).forEach((e, t) => {
          s += e + ': ...\n\n';
        });
      } else {
        if (p.isFunction(n)) {
          const e = r === d.SignatureDisplayType.formatted ? `
${' '.repeat(u)}` : ' ';
          const i = g(a.printFunctionParts(n), e, r);
          s += `class ${t}${i}`;
        }
      }
      return s;
    };
    exports.getFunctionDocStringFromType = h;
    exports.getOverloadedDocStringsFromType = f;
    exports.getDocumentationPartsForTypeAndDecl = function (e, t, n, a, r) {
      var s;
      var i;
      const l = function (e, t, n, a) {
        var r;
        if (!t) {
          return;
        }
        if (t.type === 4) {
          return t.docString;
        }
        if (t.type === 1) {
          if (t.typeAliasName && t.docString) {
            return t.docString;
          }
          const n = (r = a == null ? undefined : a.getDeclarations().find(e => e.type === 1 && !!e.docString)) !== null && r !== undefined ? r : t;
          const s = o.getVariableDocString(n, e);
          if (s) {
            return s;
          }
        }
        if (t.type === 5) {
          const a = o.getPropertyDocStringInherited(t, e, n);
          if (a) {
            return a;
          }
        }
        return;
      }(e, n, a, r == null ? undefined : r.symbol);
      let d;
      if ((n == null ? undefined : n.type) === 8) {
        if (n.type === 8 && n.node && n.node.nodeType === 24 && (r == null ? undefined : r.name) && !n.node.d.alias) {
          const e = n.node.d.module.d.nameParts.find(e => e.d.value === r.name);
          if (e) {
            const t = (i = (s = a.getDeclInfoForNameNode(e)) === null || s === undefined ? undefined : s.decls) !== null && i !== undefined ? i : [n];
            n = t.length > 0 ? t[0] : n;
          }
        }
        d = o.getModuleDocStringFromUris([n.uri], e);
      }
      d = d ?? (t ? function (e, t, n, a, r) {
        if (p.isModule(t)) {
          const a = o.getModuleDocString(t, n, e);
          if (a) {
            return a;
          }
        } else {
          if (p.isInstantiableClass(t)) {
            const a = o.getClassDocString(t, n, e);
            if (a) {
              return a;
            }
          } else {
            if (p.isFunction(t)) {
              const n = r ? a.bindFunctionToClassOrObject(r, t) : t;
              if (n && p.isFunction(n)) {
                const t = h(n, e, a);
                if (t) {
                  return t;
                }
              }
            } else {
              if (p.isOverloaded(t)) {
                const n = r ? a.bindFunctionToClassOrObject(r, t) : t;
                if (n && p.isOverloaded(n)) {
                  const t = f(n, e, a).find(e => e);
                  if (t) {
                    return t;
                  }
                }
              }
            }
          }
        }
        return;
      }(e, t, n, a, r == null ? undefined : r.boundObjectOrClass) : undefined);
      if (l && d && l !== d) {
        return `${l}\n\n${d}`;
      } else {
        return l || d;
      }
    };
    exports.getAutoImportText = function (e, t, n) {
      let a;
      a = t ? `from ${t} import ${e}` : `import ${e}`;
      if (n) {
        a = `${a} as ${n}`;
      }
      return a;
    };
    exports.combineExpressionTypes = function (e, t) {
      const n = e.map(e => t.getType(e) || p.UnknownType.create());
      let a = p.combineTypes(n);
      if (n.length === 1 && a.category === 6 && p.ClassType.isBuiltIn(a, 'list') && a.priv.typeArgs) {
        a = a.priv.typeArgs[0];
      } else {
        if (n.length === 1 && a.category === 6 && p.ClassType.isBuiltIn(a, 'range')) {
          a = t.getBuiltInObject(e[0], 'int');
        }
      }
      return a;
    };
    exports.getClassAndConstructorTypes = function (e, t) {
      var n;
      var a;
      let r = e;
      if (((n = r == null ? undefined : r.parent) === null || n === undefined ? undefined : n.nodeType) === 35 && e === r.parent.d.member || ((a = r == null ? undefined : r.parent) === null || a === undefined ? undefined : a.nodeType) === 27) {
        r = e.parent;
      }
      if (!r || !r.parent || r.parent.nodeType !== 9 || r.parent.d.leftExpr !== r) {
        return;
      }
      const s = b(t, e);
      if (!p.isInstantiableClass(s)) {
        return;
      }
      const i = b(t, r.parent);
      if (!p.isClassInstance(i)) {
        return;
      }
      let o;
      const d = l.lookUpClassMember(s, '__init__', 16);
      if (d) {
        const n = t.getTypeOfMember(d);
        if (p.isFunction(n) || p.isOverloaded(n)) {
          o = T(t, e, i, n);
        }
      }
      if (!o || o && p.isFunction(o) && (p.FunctionType.hasDefaultParams(o) || o.shared.parameters.length === 0)) {
        const n = l.lookUpClassMember(s, '__new__', 20);
        if (n) {
          const a = t.getTypeOfMember(n);
          if (p.isFunction(a) || p.isOverloaded(a)) {
            o = T(t, e, i, a, true);
          }
        }
      }
      return {
        methodType: o,
        classType: s
      };
    };
    exports.bindFunctionToClassOrObjectToolTip = T;
    exports.limitOverloadBasedOnCall = v;
    exports.getTypeForToolTip = b;
    const i = __importStar(require(41557));
    const o = require(30889);
    const l = require(92324);
    const p = require(21024);
    const d = require(12522);
    const c = require(34455);
    const u = 4;
    function m(e, t, n, a = 70) {
      let r = '';
      const s = p.OverloadedType.getOverloads(e).map(e => y('', e.shared.name, e, t, false, n));
      for (let e = 0; e < s.length; e++) {
        if (e !== 0 && s[e].length > a && s[e - 1].length <= a) {
          r += '\n';
        }
        r += s[e] + ': ...';
        if (e < s.length - 1) {
          r += '\n';
          if (s[e].length > a) {
            r += '\n';
          }
        }
      }
      return r;
    }
    function y(e, t, n, a, r = false, s) {
      const i = e.length === 0 ? '' : `(${e}) `;
      const o = s === d.SignatureDisplayType.formatted ? `
${' '.repeat(u)}` : '';
      const l = a.printFunctionParts(n);
      const c = `${g(l, o, s)} -> ${l[1]}`;
      if (p.TypeBase.isInstantiable(n)) {
        return `${i}${t}: type[${c}]`;
      }
      const m = r ? ': ' : '';
      let y = '';
      if (!r) {
        y = 'def ';
        if (p.FunctionType.isAsync(n)) {
          y = `async ${y}`;
        }
      }
      return `${i}${y}${t}${m}${c}`;
    }
    function g(e, t, n) {
      if (n === d.SignatureDisplayType.formatted && e.length > 0 && e[0].length > 1) {
        return `(${t}${e[0].join(`,${t}`)}\n)`;
      } else {
        return `(${e[0].join(', ')})`;
      }
    }
    function h(e, t, n) {
      const a = e.shared.declaration;
      const r = a ? i.getEnclosingClass(a.node) : undefined;
      const s = r ? n.getTypeOfClass(r) : undefined;
      return o.getFunctionDocStringInherited(e, a, t, s == null ? undefined : s.classType);
    }
    function f(e, t, n) {
      const a = p.OverloadedType.getOverloads(e);
      if (a.length === 0) {
        return [];
      }
      const r = a[0].shared.declaration;
      const s = r ? i.getEnclosingClass(r.node) : undefined;
      const l = s ? n.getTypeOfClass(s) : undefined;
      return o.getOverloadedDocStringsInherited(e, a.map(e => e.shared.declaration).filter(c.isDefined), t, n, l == null ? undefined : l.classType);
    }
    function T(e, t, n, a, r) {
      const s = e.bindFunctionToClassOrObject(n, a, undefined, r);
      if (s) {
        return v(e, s, t);
      }
    }
    function v(e, t, n) {
      if (!p.isOverloaded(t) || n.nodeType !== 38) {
        return t;
      }
      const a = i.getCallForName(n);
      if (!a) {
        return t;
      }
      const r = e.getTypeResult(a);
      if (r && r.overloadsUsedForCall && r.overloadsUsedForCall.length !== 0) {
        if (r.overloadsUsedForCall.length === 1) {
          return r.overloadsUsedForCall[0];
        } else {
          return p.OverloadedType.create(r.overloadsUsedForCall);
        }
      } else {
        return t;
      }
    }
    function b(e, t) {
      var n;
      const a = (n = e.getType(t)) !== null && n !== undefined ? n : p.UnknownType.create();
      return v(e, a, t);
    }
  },
  46292: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.WorkspaceSymbolProvider = undefined;
    const i = require(26687);
    const o = require(3433);
    const l = require(91426);
    const p = require(58147);
    const d = __importStar(require(89740));
    const c = require(5884);
    const u = require(76135);
    exports.WorkspaceSymbolProvider = class {
      constructor(e, t, n, a) {
        this._workspaces = e;
        this._query = n;
        this._token = a;
        this._allSymbols = [];
        this._reporter = t ? e => t.report(e) : e => p.appendArray(this._allSymbols, e);
      }
      reportSymbols() {
        for (const e of this._workspaces) {
          if (!e.disableLanguageServices && !e.disableWorkspaceSymbol) {
            if (e.isInitialized.resolved()) {
              e.service.run(e => {
                this._reportSymbolsForProgram(e);
              }, this._token);
            }
          }
        }
        return this._allSymbols;
      }
      getSymbolsForDocument(e, t) {
        const n = [];
        const a = e.getParseResults(t);
        if (!a) {
          return n;
        }
        const r = i.getFileInfo(a.parserOutput.parseTree);
        if (!r) {
          return n;
        }
        const s = u.SymbolIndexer.indexSymbols(r, a, {
          includeAliases: false
        }, this._token);
        this.appendWorkspaceSymbolsRecursive(s, e, t, '', n);
        return n;
      }
      appendWorkspaceSymbolsRecursive(e, t, n, a, r) {
        l.throwIfCancellationRequested(this._token);
        if (e) {
          for (const s of e) {
            if (!s.alias) {
              if (d.isPatternInSymbol(this._query, s.name)) {
                const e = {
                  uri: c.convertUriToLspUriString(t.fileSystem, n),
                  range: s.selectionRange
                };
                const i = {
                  name: s.name,
                  kind: s.kind,
                  location: e
                };
                if (a.length) {
                  i.containerName = a;
                }
                r.push(i);
              }
              this.appendWorkspaceSymbolsRecursive(s.children, t, n, this._getContainerName(a, s.name), r);
            }
          }
        }
      }
      _reportSymbolsForProgram(e) {
        if (this._query) {
          for (const t of e.getSourceFileInfoList()) {
            if (!o.isUserCode(t)) {
              continue;
            }
            const n = this.getSymbolsForDocument(e, t.sourceFile.getUri());
            if (n.length > 0) {
              this._reporter(n);
            }
            e.handleMemoryHighUsage();
          }
        }
      }
      _getContainerName(e, t) {
        if (e.length > 0) {
          return `${e}.${t}`;
        } else {
          return t;
        }
      }
    };
  },
  67703: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.LocAddendum = exports.LocMessage = exports.Localizer = exports.ParameterizedString = undefined;
    exports.setGetRawString = function (e) {
      const t = w;
      w = e;
      return t;
    };
    exports.getRawStringFromMap = S;
    exports.setLocaleOverride = function (e) {
      C = undefined;
      k = e.toLowerCase();
    };
    exports.setForceEnglishDiagnostics = function (e) {
      A = e;
    };
    exports.getLocaleFromEnv = x;
    exports.loadStringsForLocale = P;
    const a = require(48281);
    const r = require(73068);
    const s = require(94397);
    const i = require(84268);
    const o = require(45458);
    const l = require(18154);
    const p = require(51667);
    const d = require(3879);
    const c = require(83472);
    const u = require(96838);
    const m = require(55169);
    const y = require(12957);
    const g = require(78483);
    const h = require(83132);
    const f = require(63982);
    const T = require(95610);
    class v {
      constructor(e) {
        this._formatString = e;
      }
      format(e) {
        let t = this._formatString;
        Object.keys(e).forEach(n => {
          t = t.replace(new RegExp(`{${n}}`, 'g'), e[n].toString());
        });
        return t;
      }
      getFormatString() {
        return this._formatString;
      }
    }
    exports.ParameterizedString = v;
    const b = 'en-us';
    const _ = new Map([['cs', r], ['de', s], ['en-us', i], ['en', i], ['es', o], ['fr', l], ['it', p], ['ja', d], ['ko', c], ['pl', u], ['pt-br', m], ['qps-ploc', y], ['ru', g], ['tr', h], ['zh-cn', f], ['zh-tw', T]]);
    let C;
    let I = {};
    let k;
    let w = function (e) {
      if (C === undefined) {
        C = function () {
          I = function () {
            const e = _.get(b);
            if (e) {
              return e;
            }
            console.error('Could not load default strings');
            return {};
          }();
          return P(x(), _);
        }();
      }
      const t = e.split('.');
      const n = (t[0] === 'Diagnostic' || t[0] === 'DiagnosticAddendum') && A ? S(I, t) : S(C, t) || S(I, t);
      if (n) {
        return n;
      }
      a.fail(`Missing localized string for key "${e}"`);
    };
    function S(e, t) {
      let n = e;
      for (const e of t) {
        if (!n[e]) {
          return;
        }
        n = n[e];
      }
      if (typeof n == 'string') {
        return n;
      } else {
        return n.message;
      }
    }
    let A = false;
    function x() {
      if (k) {
        return k;
      }
      try {
        const e = process?.env;
        const t = e == null ? undefined : e.VSCODE_NLS_CONFIG;
        if (t) {
          try {
            return JSON.parse(t).locale || b;
          } catch {}
        }
        const n = (e == null ? undefined : e.LC_ALL) || (e == null ? undefined : e.LC_MESSAGES) || (e == null ? undefined : e.LANG) || (e == null ? undefined : e.LANGUAGE);
        if (n) {
          const e = n.split('.');
          if (e.length > 0 && e[0]) {
            return e[0] || b;
          }
        }
      } catch {}
      return b;
    }
    function P(e, t) {
      if (e === b) {
        return {};
      }
      let n = t.get(e);
      if (n !== undefined) {
        return n;
      }
      const a = e.split('-');
      if (a.length > 0 && a[0] && (n = t.get(a[0]), n !== undefined)) {
        return n;
      } else {
        return {};
      }
    }
    var D;
    (function (e) {
      let t;
      let n;
      let a;
      let r;
      let s;
      (function (e) {
        e.annotatedMetadataInconsistent = () => new v(w('Diagnostic.annotatedMetadataInconsistent'));
        e.abstractMethodInvocation = () => new v(w('Diagnostic.abstractMethodInvocation'));
        e.annotatedParamCountMismatch = () => new v(w('Diagnostic.annotatedParamCountMismatch'));
        e.annotatedTypeArgMissing = () => w('Diagnostic.annotatedTypeArgMissing');
        e.annotationBytesString = () => w('Diagnostic.annotationBytesString');
        e.annotationFormatString = () => w('Diagnostic.annotationFormatString');
        e.annotationNotSupported = () => w('Diagnostic.annotationNotSupported');
        e.annotationRawString = () => w('Diagnostic.annotationRawString');
        e.annotationSpansStrings = () => w('Diagnostic.annotationSpansStrings');
        e.annotationStringEscape = () => w('Diagnostic.annotationStringEscape');
        e.argAssignment = () => new v(w('Diagnostic.argAssignment'));
        e.argAssignmentFunction = () => new v(w('Diagnostic.argAssignmentFunction'));
        e.argAssignmentParam = () => new v(w('Diagnostic.argAssignmentParam'));
        e.argAssignmentParamFunction = () => new v(w('Diagnostic.argAssignmentParamFunction'));
        e.argMissingForParam = () => new v(w('Diagnostic.argMissingForParam'));
        e.argMissingForParams = () => new v(w('Diagnostic.argMissingForParams'));
        e.argMorePositionalExpectedCount = () => new v(w('Diagnostic.argMorePositionalExpectedCount'));
        e.argMorePositionalExpectedOne = () => w('Diagnostic.argMorePositionalExpectedOne');
        e.argPositional = () => w('Diagnostic.argPositional');
        e.argPositionalExpectedCount = () => new v(w('Diagnostic.argPositionalExpectedCount'));
        e.argPositionalExpectedOne = () => w('Diagnostic.argPositionalExpectedOne');
        e.argTypePartiallyUnknown = () => w('Diagnostic.argTypePartiallyUnknown');
        e.argTypeUnknown = () => w('Diagnostic.argTypeUnknown');
        e.assertAlwaysTrue = () => w('Diagnostic.assertAlwaysTrue');
        e.assertTypeArgs = () => w('Diagnostic.assertTypeArgs');
        e.assertTypeTypeMismatch = () => new v(w('Diagnostic.assertTypeTypeMismatch'));
        e.assignmentExprContext = () => w('Diagnostic.assignmentExprContext');
        e.assignmentExprComprehension = () => new v(w('Diagnostic.assignmentExprComprehension'));
        e.assignmentExprInSubscript = () => w('Diagnostic.assignmentExprInSubscript');
        e.assignmentInProtocol = () => w('Diagnostic.assignmentInProtocol');
        e.assignmentTargetExpr = () => w('Diagnostic.assignmentTargetExpr');
        e.asyncNotInAsyncFunction = () => w('Diagnostic.asyncNotInAsyncFunction');
        e.awaitIllegal = () => w('Diagnostic.awaitIllegal');
        e.awaitNotAllowed = () => w('Diagnostic.awaitNotAllowed');
        e.awaitNotInAsync = () => w('Diagnostic.awaitNotInAsync');
        e.backticksIllegal = () => w('Diagnostic.backticksIllegal');
        e.baseClassCircular = () => w('Diagnostic.baseClassCircular');
        e.baseClassFinal = () => new v(w('Diagnostic.baseClassFinal'));
        e.baseClassIncompatible = () => new v(w('Diagnostic.baseClassIncompatible'));
        e.baseClassInvalid = () => w('Diagnostic.baseClassInvalid');
        e.baseClassMethodTypeIncompatible = () => new v(w('Diagnostic.baseClassMethodTypeIncompatible'));
        e.baseClassVariableTypeIncompatible = () => new v(w('Diagnostic.baseClassVariableTypeIncompatible'));
        e.baseClassUnknown = () => w('Diagnostic.baseClassUnknown');
        e.binaryOperationNotAllowed = () => w('Diagnostic.binaryOperationNotAllowed');
        e.bindTypeMismatch = () => new v(w('Diagnostic.bindTypeMismatch'));
        e.breakInExceptionGroup = () => w('Diagnostic.breakInExceptionGroup');
        e.breakOutsideLoop = () => w('Diagnostic.breakOutsideLoop');
        e.callableExtraArgs = () => w('Diagnostic.callableExtraArgs');
        e.callableFirstArg = () => w('Diagnostic.callableFirstArg');
        e.callableNotInstantiable = () => new v(w('Diagnostic.callableNotInstantiable'));
        e.callableSecondArg = () => w('Diagnostic.callableSecondArg');
        e.casePatternIsIrrefutable = () => w('Diagnostic.casePatternIsIrrefutable');
        e.classAlreadySpecialized = () => new v(w('Diagnostic.classAlreadySpecialized'));
        e.classDecoratorTypeUnknown = () => w('Diagnostic.classDecoratorTypeUnknown');
        e.classDefinitionCycle = () => new v(w('Diagnostic.classDefinitionCycle'));
        e.classGetItemClsParam = () => w('Diagnostic.classGetItemClsParam');
        e.classMethodClsParam = () => w('Diagnostic.classMethodClsParam');
        e.classNotRuntimeSubscriptable = () => new v(w('Diagnostic.classNotRuntimeSubscriptable'));
        e.classPatternBuiltInArgPositional = () => w('Diagnostic.classPatternBuiltInArgPositional');
        e.classPatternPositionalArgCount = () => new v(w('Diagnostic.classPatternPositionalArgCount'));
        e.classPatternTypeAlias = () => new v(w('Diagnostic.classPatternTypeAlias'));
        e.classPropertyDeprecated = () => w('Diagnostic.classPropertyDeprecated');
        e.classTypeParametersIllegal = () => w('Diagnostic.classTypeParametersIllegal');
        e.classVarNotAllowed = () => w('Diagnostic.classVarNotAllowed');
        e.classVarFirstArgMissing = () => w('Diagnostic.classVarFirstArgMissing');
        e.classVarOverridesInstanceVar = () => new v(w('Diagnostic.classVarOverridesInstanceVar'));
        e.classVarTooManyArgs = () => w('Diagnostic.classVarTooManyArgs');
        e.classVarWithTypeVar = () => w('Diagnostic.classVarWithTypeVar');
        e.clsSelfParamTypeMismatch = () => new v(w('Diagnostic.clsSelfParamTypeMismatch'));
        e.codeTooComplexToAnalyze = () => w('Diagnostic.codeTooComplexToAnalyze');
        e.collectionAliasInstantiation = () => new v(w('Diagnostic.collectionAliasInstantiation'));
        e.comparisonAlwaysFalse = () => new v(w('Diagnostic.comparisonAlwaysFalse'));
        e.comparisonAlwaysTrue = () => new v(w('Diagnostic.comparisonAlwaysTrue'));
        e.comprehensionInDict = () => w('Diagnostic.comprehensionInDict');
        e.comprehensionInSet = () => w('Diagnostic.comprehensionInSet');
        e.concatenateContext = () => w('Diagnostic.concatenateContext');
        e.concatenateParamSpecMissing = () => w('Diagnostic.concatenateParamSpecMissing');
        e.concatenateTypeArgsMissing = () => w('Diagnostic.concatenateTypeArgsMissing');
        e.conditionalOperandInvalid = () => new v(w('Diagnostic.conditionalOperandInvalid'));
        e.constantRedefinition = () => new v(w('Diagnostic.constantRedefinition'));
        e.coroutineInConditionalExpression = () => w('Diagnostic.coroutineInConditionalExpression');
        e.constructorParametersMismatch = () => new v(w('Diagnostic.constructorParametersMismatch'));
        e.containmentAlwaysFalse = () => new v(w('Diagnostic.containmentAlwaysFalse'));
        e.containmentAlwaysTrue = () => new v(w('Diagnostic.containmentAlwaysTrue'));
        e.continueInExceptionGroup = () => w('Diagnostic.continueInExceptionGroup');
        e.continueOutsideLoop = () => w('Diagnostic.continueOutsideLoop');
        e.dataClassBaseClassFrozen = () => w('Diagnostic.dataClassBaseClassFrozen');
        e.dataClassBaseClassNotFrozen = () => w('Diagnostic.dataClassBaseClassNotFrozen');
        e.dataClassConverterFunction = () => new v(w('Diagnostic.dataClassConverterFunction'));
        e.dataClassConverterOverloads = () => new v(w('Diagnostic.dataClassConverterOverloads'));
        e.dataClassFieldInheritedDefault = () => new v(w('Diagnostic.dataClassFieldInheritedDefault'));
        e.dataClassFieldWithDefault = () => w('Diagnostic.dataClassFieldWithDefault');
        e.dataClassFieldWithoutAnnotation = () => w('Diagnostic.dataClassFieldWithoutAnnotation');
        e.dataClassFieldWithPrivateName = () => w('Diagnostic.dataClassFieldWithPrivateName');
        e.dataClassPostInitParamCount = () => new v(w('Diagnostic.dataClassPostInitParamCount'));
        e.dataClassPostInitType = () => new v(w('Diagnostic.dataClassPostInitType'));
        e.dataClassSlotsOverwrite = () => w('Diagnostic.dataClassSlotsOverwrite');
        e.dataClassTransformExpectedBoolLiteral = () => w('Diagnostic.dataClassTransformExpectedBoolLiteral');
        e.dataClassTransformFieldSpecifier = () => new v(w('Diagnostic.dataClassTransformFieldSpecifier'));
        e.dataClassTransformPositionalParam = () => w('Diagnostic.dataClassTransformPositionalParam');
        e.dataClassTransformUnknownArgument = () => new v(w('Diagnostic.dataClassTransformUnknownArgument'));
        e.dataProtocolInSubclassCheck = () => w('Diagnostic.dataProtocolInSubclassCheck');
        e.declaredReturnTypePartiallyUnknown = () => new v(w('Diagnostic.declaredReturnTypePartiallyUnknown'));
        e.declaredReturnTypeUnknown = () => w('Diagnostic.declaredReturnTypeUnknown');
        e.defaultValueContainsCall = () => w('Diagnostic.defaultValueContainsCall');
        e.defaultValueNotAllowed = () => w('Diagnostic.defaultValueNotAllowed');
        e.deprecatedClass = () => new v(w('Diagnostic.deprecatedClass'));
        e.deprecatedConstructor = () => new v(w('Diagnostic.deprecatedConstructor'));
        e.deprecatedDescriptorDeleter = () => new v(w('Diagnostic.deprecatedDescriptorDeleter'));
        e.deprecatedDescriptorGetter = () => new v(w('Diagnostic.deprecatedDescriptorGetter'));
        e.deprecatedDescriptorSetter = () => new v(w('Diagnostic.deprecatedDescriptorSetter'));
        e.deprecatedFunction = () => new v(w('Diagnostic.deprecatedFunction'));
        e.deprecatedMethod = () => new v(w('Diagnostic.deprecatedMethod'));
        e.deprecatedPropertyDeleter = () => new v(w('Diagnostic.deprecatedPropertyDeleter'));
        e.deprecatedPropertyGetter = () => new v(w('Diagnostic.deprecatedPropertyGetter'));
        e.deprecatedPropertySetter = () => new v(w('Diagnostic.deprecatedPropertySetter'));
        e.deprecatedType = () => new v(w('Diagnostic.deprecatedType'));
        e.dictExpandIllegalInComprehension = () => w('Diagnostic.dictExpandIllegalInComprehension');
        e.dictInAnnotation = () => w('Diagnostic.dictInAnnotation');
        e.dictKeyValuePairs = () => w('Diagnostic.dictKeyValuePairs');
        e.dictUnpackIsNotMapping = () => w('Diagnostic.dictUnpackIsNotMapping');
        e.delTargetExpr = () => w('Diagnostic.delTargetExpr');
        e.dunderAllSymbolNotPresent = () => new v(w('Diagnostic.dunderAllSymbolNotPresent'));
        e.duplicateArgsParam = () => w('Diagnostic.duplicateArgsParam');
        e.duplicateBaseClass = () => w('Diagnostic.duplicateBaseClass');
        e.duplicateCatchAll = () => w('Diagnostic.duplicateCatchAll');
        e.duplicateEnumMember = () => new v(w('Diagnostic.duplicateEnumMember'));
        e.duplicateGenericAndProtocolBase = () => w('Diagnostic.duplicateGenericAndProtocolBase');
        e.duplicateImport = () => new v(w('Diagnostic.duplicateImport'));
        e.duplicateKwargsParam = () => w('Diagnostic.duplicateKwargsParam');
        e.duplicateKeywordOnly = () => w('Diagnostic.duplicateKeywordOnly');
        e.duplicateParam = () => new v(w('Diagnostic.duplicateParam'));
        e.duplicateCapturePatternTarget = () => new v(w('Diagnostic.duplicateCapturePatternTarget'));
        e.duplicateStarPattern = () => w('Diagnostic.duplicateStarPattern');
        e.duplicateStarStarPattern = () => w('Diagnostic.duplicateStarStarPattern');
        e.duplicatePositionOnly = () => w('Diagnostic.duplicatePositionOnly');
        e.duplicateUnpack = () => w('Diagnostic.duplicateUnpack');
        e.ellipsisAfterUnpacked = () => w('Diagnostic.ellipsisAfterUnpacked');
        e.ellipsisContext = () => w('Diagnostic.ellipsisContext');
        e.ellipsisSecondArg = () => w('Diagnostic.ellipsisSecondArg');
        e.enumClassOverride = () => new v(w('Diagnostic.enumClassOverride'));
        e.enumMemberDelete = () => new v(w('Diagnostic.enumMemberDelete'));
        e.enumMemberSet = () => new v(w('Diagnostic.enumMemberSet'));
        e.enumMemberTypeAnnotation = () => w('Diagnostic.enumMemberTypeAnnotation');
        e.exceptionGroupIncompatible = () => w('Diagnostic.exceptionGroupIncompatible');
        e.exceptGroupMismatch = () => w('Diagnostic.exceptGroupMismatch');
        e.exceptGroupRequiresType = () => w('Diagnostic.exceptGroupRequiresType');
        e.exceptionGroupTypeIncorrect = () => w('Diagnostic.exceptionGroupTypeIncorrect');
        e.exceptionTypeIncorrect = () => new v(w('Diagnostic.exceptionTypeIncorrect'));
        e.exceptionTypeNotClass = () => new v(w('Diagnostic.exceptionTypeNotClass'));
        e.exceptionTypeNotInstantiable = () => new v(w('Diagnostic.exceptionTypeNotInstantiable'));
        e.expectedAfterDecorator = () => w('Diagnostic.expectedAfterDecorator');
        e.expectedArrow = () => w('Diagnostic.expectedArrow');
        e.expectedAsAfterException = () => w('Diagnostic.expectedAsAfterException');
        e.expectedAssignRightHandExpr = () => w('Diagnostic.expectedAssignRightHandExpr');
        e.expectedBinaryRightHandExpr = () => w('Diagnostic.expectedBinaryRightHandExpr');
        e.expectedBoolLiteral = () => w('Diagnostic.expectedBoolLiteral');
        e.expectedCase = () => w('Diagnostic.expectedCase');
        e.expectedClassName = () => w('Diagnostic.expectedClassName');
        e.expectedCloseBrace = () => w('Diagnostic.expectedCloseBrace');
        e.expectedCloseBracket = () => w('Diagnostic.expectedCloseBracket');
        e.expectedCloseParen = () => w('Diagnostic.expectedCloseParen');
        e.expectedColon = () => w('Diagnostic.expectedColon');
        e.expectedComplexNumberLiteral = () => w('Diagnostic.expectedComplexNumberLiteral');
        e.expectedDecoratorExpr = () => w('Diagnostic.expectedDecoratorExpr');
        e.expectedDecoratorName = () => w('Diagnostic.expectedDecoratorName');
        e.expectedDecoratorNewline = () => w('Diagnostic.expectedDecoratorNewline');
        e.expectedDelExpr = () => w('Diagnostic.expectedDelExpr');
        e.expectedElse = () => w('Diagnostic.expectedElse');
        e.expectedEquals = () => w('Diagnostic.expectedEquals');
        e.expectedExceptionClass = () => w('Diagnostic.expectedExceptionClass');
        e.expectedExceptionObj = () => w('Diagnostic.expectedExceptionObj');
        e.expectedExpr = () => w('Diagnostic.expectedExpr');
        e.expectedIdentifier = () => w('Diagnostic.expectedIdentifier');
        e.expectedImport = () => w('Diagnostic.expectedImport');
        e.expectedImportAlias = () => w('Diagnostic.expectedImportAlias');
        e.expectedImportSymbols = () => w('Diagnostic.expectedImportSymbols');
        e.expectedIndentedBlock = () => w('Diagnostic.expectedIndentedBlock');
        e.expectedIn = () => w('Diagnostic.expectedIn');
        e.expectedInExpr = () => w('Diagnostic.expectedInExpr');
        e.expectedFunctionAfterAsync = () => w('Diagnostic.expectedFunctionAfterAsync');
        e.expectedFunctionName = () => w('Diagnostic.expectedFunctionName');
        e.expectedMemberName = () => w('Diagnostic.expectedMemberName');
        e.expectedModuleName = () => w('Diagnostic.expectedModuleName');
        e.expectedNameAfterAs = () => w('Diagnostic.expectedNameAfterAs');
        e.expectedNamedParameter = () => w('Diagnostic.expectedNamedParameter');
        e.expectedNewline = () => w('Diagnostic.expectedNewline');
        e.expectedNewlineOrSemicolon = () => w('Diagnostic.expectedNewlineOrSemicolon');
        e.expectedOpenParen = () => w('Diagnostic.expectedOpenParen');
        e.expectedParamName = () => w('Diagnostic.expectedParamName');
        e.expectedPatternExpr = () => w('Diagnostic.expectedPatternExpr');
        e.expectedPatternSubjectExpr = () => w('Diagnostic.expectedPatternSubjectExpr');
        e.expectedPatternValue = () => w('Diagnostic.expectedPatternValue');
        e.expectedReturnExpr = () => w('Diagnostic.expectedReturnExpr');
        e.expectedSliceIndex = () => w('Diagnostic.expectedSliceIndex');
        e.expectedTypeNotString = () => w('Diagnostic.expectedTypeNotString');
        e.expectedTypeParameterName = () => w('Diagnostic.expectedTypeParameterName');
        e.expectedYieldExpr = () => w('Diagnostic.expectedYieldExpr');
        e.finalClassIsAbstract = () => new v(w('Diagnostic.finalClassIsAbstract'));
        e.finalContext = () => w('Diagnostic.finalContext');
        e.finalInLoop = () => w('Diagnostic.finalInLoop');
        e.finalMethodOverride = () => new v(w('Diagnostic.finalMethodOverride'));
        e.finalNonMethod = () => new v(w('Diagnostic.finalNonMethod'));
        e.finalReassigned = () => new v(w('Diagnostic.finalReassigned'));
        e.finalRedeclaration = () => new v(w('Diagnostic.finalRedeclaration'));
        e.finalRedeclarationBySubclass = () => new v(w('Diagnostic.finalRedeclarationBySubclass'));
        e.finalTooManyArgs = () => w('Diagnostic.finalTooManyArgs');
        e.finalUnassigned = () => new v(w('Diagnostic.finalUnassigned'));
        e.formatStringBrace = () => w('Diagnostic.formatStringBrace');
        e.formatStringBytes = () => w('Diagnostic.formatStringBytes');
        e.formatStringDebuggingIllegal = () => w('Diagnostic.formatStringDebuggingIllegal');
        e.formatStringEscape = () => w('Diagnostic.formatStringEscape');
        e.formatStringExpectedConversion = () => w('Diagnostic.formatStringExpectedConversion');
        e.formatStringInPattern = () => w('Diagnostic.formatStringInPattern');
        e.formatStringIllegal = () => w('Diagnostic.formatStringIllegal');
        e.formatStringNestedFormatSpecifier = () => w('Diagnostic.formatStringNestedFormatSpecifier');
        e.formatStringNestedQuote = () => w('Diagnostic.formatStringNestedQuote');
        e.formatStringUnicode = () => w('Diagnostic.formatStringUnicode');
        e.formatStringUnterminated = () => w('Diagnostic.formatStringUnterminated');
        e.functionDecoratorTypeUnknown = () => w('Diagnostic.functionDecoratorTypeUnknown');
        e.functionInConditionalExpression = () => w('Diagnostic.functionInConditionalExpression');
        e.functionTypeParametersIllegal = () => w('Diagnostic.functionTypeParametersIllegal');
        e.futureImportLocationNotAllowed = () => w('Diagnostic.futureImportLocationNotAllowed');
        e.generatorAsyncReturnType = () => new v(w('Diagnostic.generatorAsyncReturnType'));
        e.generatorNotParenthesized = () => w('Diagnostic.generatorNotParenthesized');
        e.generatorSyncReturnType = () => new v(w('Diagnostic.generatorSyncReturnType'));
        e.genericBaseClassNotAllowed = () => w('Diagnostic.genericBaseClassNotAllowed');
        e.genericClassAssigned = () => w('Diagnostic.genericClassAssigned');
        e.genericClassDeleted = () => w('Diagnostic.genericClassDeleted');
        e.genericInstanceVariableAccess = () => w('Diagnostic.genericInstanceVariableAccess');
        e.genericNotAllowed = () => w('Diagnostic.genericNotAllowed');
        e.genericTypeAliasBoundTypeVar = () => new v(w('Diagnostic.genericTypeAliasBoundTypeVar'));
        e.genericTypeArgMissing = () => w('Diagnostic.genericTypeArgMissing');
        e.genericTypeArgTypeVar = () => w('Diagnostic.genericTypeArgTypeVar');
        e.genericTypeArgUnique = () => w('Diagnostic.genericTypeArgUnique');
        e.globalReassignment = () => new v(w('Diagnostic.globalReassignment'));
        e.globalRedefinition = () => new v(w('Diagnostic.globalRedefinition'));
        e.implicitStringConcat = () => w('Diagnostic.implicitStringConcat');
        e.importCycleDetected = () => w('Diagnostic.importCycleDetected');
        e.importDepthExceeded = () => new v(w('Diagnostic.importDepthExceeded'));
        e.importResolveFailure = () => new v(w('Diagnostic.importResolveFailure'));
        e.importSourceResolveFailure = () => new v(w('Diagnostic.importSourceResolveFailure'));
        e.importSymbolUnknown = () => new v(w('Diagnostic.importSymbolUnknown'));
        e.incompatibleMethodOverride = () => new v(w('Diagnostic.incompatibleMethodOverride'));
        e.inconsistentIndent = () => w('Diagnostic.inconsistentIndent');
        e.inconsistentTabs = () => w('Diagnostic.inconsistentTabs');
        e.initMethodSelfParamTypeVar = () => w('Diagnostic.initMethodSelfParamTypeVar');
        e.initMustReturnNone = () => w('Diagnostic.initMustReturnNone');
        e.initSubclassClsParam = () => w('Diagnostic.initSubclassClsParam');
        e.initSubclassCallFailed = () => w('Diagnostic.initSubclassCallFailed');
        e.initVarNotAllowed = () => w('Diagnostic.initVarNotAllowed');
        e.instanceMethodSelfParam = () => w('Diagnostic.instanceMethodSelfParam');
        e.instanceVarOverridesClassVar = () => new v(w('Diagnostic.instanceVarOverridesClassVar'));
        e.instantiateAbstract = () => new v(w('Diagnostic.instantiateAbstract'));
        e.instantiateProtocol = () => new v(w('Diagnostic.instantiateProtocol'));
        e.internalBindError = () => new v(w('Diagnostic.internalBindError'));
        e.internalParseError = () => new v(w('Diagnostic.internalParseError'));
        e.internalTypeCheckingError = () => new v(w('Diagnostic.internalTypeCheckingError'));
        e.invalidIdentifierChar = () => w('Diagnostic.invalidIdentifierChar');
        e.invalidStubStatement = () => w('Diagnostic.invalidStubStatement');
        e.invalidTokenChars = () => new v(w('Diagnostic.invalidTokenChars'));
        e.isInstanceInvalidType = () => new v(w('Diagnostic.isInstanceInvalidType'));
        e.isSubclassInvalidType = () => new v(w('Diagnostic.isSubclassInvalidType'));
        e.keyValueInSet = () => w('Diagnostic.keyValueInSet');
        e.keywordArgInTypeArgument = () => w('Diagnostic.keywordArgInTypeArgument');
        e.keywordArgShortcutIllegal = () => w('Diagnostic.keywordArgShortcutIllegal');
        e.keywordOnlyAfterArgs = () => w('Diagnostic.keywordOnlyAfterArgs');
        e.keywordParameterMissing = () => w('Diagnostic.keywordParameterMissing');
        e.keywordSubscriptIllegal = () => w('Diagnostic.keywordSubscriptIllegal');
        e.lambdaReturnTypeUnknown = () => w('Diagnostic.lambdaReturnTypeUnknown');
        e.lambdaReturnTypePartiallyUnknown = () => new v(w('Diagnostic.lambdaReturnTypePartiallyUnknown'));
        e.listAssignmentMismatch = () => new v(w('Diagnostic.listAssignmentMismatch'));
        e.listInAnnotation = () => w('Diagnostic.listInAnnotation');
        e.literalNamedUnicodeEscape = () => w('Diagnostic.literalNamedUnicodeEscape');
        e.literalUnsupportedType = () => w('Diagnostic.literalUnsupportedType');
        e.literalEmptyArgs = () => w('Diagnostic.literalEmptyArgs');
        e.literalNotAllowed = () => w('Diagnostic.literalNotAllowed');
        e.literalNotCallable = () => w('Diagnostic.literalNotCallable');
        e.matchIncompatible = () => w('Diagnostic.matchIncompatible');
        e.matchIsNotExhaustive = () => w('Diagnostic.matchIsNotExhaustive');
        e.maxParseDepthExceeded = () => w('Diagnostic.maxParseDepthExceeded');
        e.memberAccess = () => new v(w('Diagnostic.memberAccess'));
        e.memberDelete = () => new v(w('Diagnostic.memberDelete'));
        e.memberSet = () => new v(w('Diagnostic.memberSet'));
        e.metaclassConflict = () => w('Diagnostic.metaclassConflict');
        e.metaclassDuplicate = () => w('Diagnostic.metaclassDuplicate');
        e.metaclassIsGeneric = () => w('Diagnostic.metaclassIsGeneric');
        e.methodNotDefined = () => new v(w('Diagnostic.methodNotDefined'));
        e.methodNotDefinedOnType = () => new v(w('Diagnostic.methodNotDefinedOnType'));
        e.methodOrdering = () => w('Diagnostic.methodOrdering');
        e.methodOverridden = () => new v(w('Diagnostic.methodOverridden'));
        e.methodReturnsNonObject = () => new v(w('Diagnostic.methodReturnsNonObject'));
        e.missingSuperCall = () => new v(w('Diagnostic.missingSuperCall'));
        e.mixingBytesAndStr = () => w('Diagnostic.mixingBytesAndStr');
        e.moduleAsType = () => w('Diagnostic.moduleAsType');
        e.moduleNotCallable = () => w('Diagnostic.moduleNotCallable');
        e.moduleUnknownMember = () => new v(w('Diagnostic.moduleUnknownMember'));
        e.namedExceptAfterCatchAll = () => w('Diagnostic.namedExceptAfterCatchAll');
        e.namedParamAfterParamSpecArgs = () => new v(w('Diagnostic.namedParamAfterParamSpecArgs'));
        e.namedTupleEmptyName = () => w('Diagnostic.namedTupleEmptyName');
        e.namedTupleEntryRedeclared = () => new v(w('Diagnostic.namedTupleEntryRedeclared'));
        e.namedTupleFirstArg = () => w('Diagnostic.namedTupleFirstArg');
        e.namedTupleMultipleInheritance = () => w('Diagnostic.namedTupleMultipleInheritance');
        e.namedTupleNameKeyword = () => w('Diagnostic.namedTupleNameKeyword');
        e.namedTupleNameType = () => w('Diagnostic.namedTupleNameType');
        e.namedTupleNameUnique = () => w('Diagnostic.namedTupleNameUnique');
        e.namedTupleNoTypes = () => w('Diagnostic.namedTupleNoTypes');
        e.namedTupleSecondArg = () => w('Diagnostic.namedTupleSecondArg');
        e.newClsParam = () => w('Diagnostic.newClsParam');
        e.newTypeAnyOrUnknown = () => w('Diagnostic.newTypeAnyOrUnknown');
        e.newTypeBadName = () => w('Diagnostic.newTypeBadName');
        e.newTypeLiteral = () => w('Diagnostic.newTypeLiteral');
        e.newTypeNameMismatch = () => w('Diagnostic.newTypeNameMismatch');
        e.newTypeNotAClass = () => w('Diagnostic.newTypeNotAClass');
        e.newTypeParamCount = () => w('Diagnostic.newTypeParamCount');
        e.newTypeProtocolClass = () => w('Diagnostic.newTypeProtocolClass');
        e.nonDefaultAfterDefault = () => w('Diagnostic.nonDefaultAfterDefault');
        e.noneNotCallable = () => w('Diagnostic.noneNotCallable');
        e.noneNotIterable = () => w('Diagnostic.noneNotIterable');
        e.noneNotSubscriptable = () => w('Diagnostic.noneNotSubscriptable');
        e.noneNotUsableWith = () => w('Diagnostic.noneNotUsableWith');
        e.noneOperator = () => new v(w('Diagnostic.noneOperator'));
        e.noneUnknownMember = () => new v(w('Diagnostic.noneUnknownMember'));
        e.nonLocalNoBinding = () => new v(w('Diagnostic.nonLocalNoBinding'));
        e.nonLocalReassignment = () => new v(w('Diagnostic.nonLocalReassignment'));
        e.nonLocalRedefinition = () => new v(w('Diagnostic.nonLocalRedefinition'));
        e.nonLocalInModule = () => w('Diagnostic.nonLocalInModule');
        e.noOverload = () => new v(w('Diagnostic.noOverload'));
        e.noReturnContainsReturn = () => w('Diagnostic.noReturnContainsReturn');
        e.noReturnContainsYield = () => w('Diagnostic.noReturnContainsYield');
        e.noReturnReturnsNone = () => w('Diagnostic.noReturnReturnsNone');
        e.notRequiredArgCount = () => w('Diagnostic.notRequiredArgCount');
        e.notRequiredNotInTypedDict = () => w('Diagnostic.notRequiredNotInTypedDict');
        e.objectNotCallable = () => new v(w('Diagnostic.objectNotCallable'));
        e.obscuredClassDeclaration = () => new v(w('Diagnostic.obscuredClassDeclaration'));
        e.obscuredFunctionDeclaration = () => new v(w('Diagnostic.obscuredFunctionDeclaration'));
        e.obscuredMethodDeclaration = () => new v(w('Diagnostic.obscuredMethodDeclaration'));
        e.obscuredParameterDeclaration = () => new v(w('Diagnostic.obscuredParameterDeclaration'));
        e.obscuredTypeAliasDeclaration = () => new v(w('Diagnostic.obscuredTypeAliasDeclaration'));
        e.obscuredVariableDeclaration = () => new v(w('Diagnostic.obscuredVariableDeclaration'));
        e.operatorLessOrGreaterDeprecated = () => w('Diagnostic.operatorLessOrGreaterDeprecated');
        e.optionalExtraArgs = () => w('Diagnostic.optionalExtraArgs');
        e.orPatternIrrefutable = () => w('Diagnostic.orPatternIrrefutable');
        e.orPatternMissingName = () => w('Diagnostic.orPatternMissingName');
        e.overlappingKeywordArgs = () => new v(w('Diagnostic.overlappingKeywordArgs'));
        e.overlappingOverload = () => new v(w('Diagnostic.overlappingOverload'));
        e.overloadAbstractMismatch = () => new v(w('Diagnostic.overloadAbstractMismatch'));
        e.overloadAbstractImplMismatch = () => new v(w('Diagnostic.overloadAbstractImplMismatch'));
        e.overloadClassMethodInconsistent = () => new v(w('Diagnostic.overloadClassMethodInconsistent'));
        e.overloadFinalInconsistencyImpl = () => new v(w('Diagnostic.overloadFinalInconsistencyImpl'));
        e.overloadFinalInconsistencyNoImpl = () => new v(w('Diagnostic.overloadFinalInconsistencyNoImpl'));
        e.overloadImplementationMismatch = () => new v(w('Diagnostic.overloadImplementationMismatch'));
        e.overloadReturnTypeMismatch = () => new v(w('Diagnostic.overloadReturnTypeMismatch'));
        e.overloadStaticMethodInconsistent = () => new v(w('Diagnostic.overloadStaticMethodInconsistent'));
        e.overloadWithoutImplementation = () => new v(w('Diagnostic.overloadWithoutImplementation'));
        e.overriddenMethodNotFound = () => new v(w('Diagnostic.overriddenMethodNotFound'));
        e.overrideDecoratorMissing = () => new v(w('Diagnostic.overrideDecoratorMissing'));
        e.paramAfterKwargsParam = () => w('Diagnostic.paramAfterKwargsParam');
        e.paramAlreadyAssigned = () => new v(w('Diagnostic.paramAlreadyAssigned'));
        e.paramAnnotationMissing = () => new v(w('Diagnostic.paramAnnotationMissing'));
        e.paramNameMissing = () => new v(w('Diagnostic.paramNameMissing'));
        e.paramSpecArgsKwargsDuplicate = () => new v(w('Diagnostic.paramSpecArgsKwargsDuplicate'));
        e.paramSpecArgsKwargsUsage = () => w('Diagnostic.paramSpecArgsKwargsUsage');
        e.paramSpecArgsMissing = () => new v(w('Diagnostic.paramSpecArgsMissing'));
        e.paramSpecArgsUsage = () => w('Diagnostic.paramSpecArgsUsage');
        e.paramSpecAssignedName = () => new v(w('Diagnostic.paramSpecAssignedName'));
        e.paramSpecContext = () => w('Diagnostic.paramSpecContext');
        e.paramSpecDefaultNotTuple = () => w('Diagnostic.paramSpecDefaultNotTuple');
        e.paramSpecFirstArg = () => w('Diagnostic.paramSpecFirstArg');
        e.paramSpecKwargsUsage = () => w('Diagnostic.paramSpecKwargsUsage');
        e.paramSpecNotUsedByOuterScope = () => new v(w('Diagnostic.paramSpecNotUsedByOuterScope'));
        e.paramSpecUnknownArg = () => w('Diagnostic.paramSpecUnknownArg');
        e.paramSpecUnknownMember = () => new v(w('Diagnostic.paramSpecUnknownMember'));
        e.paramSpecUnknownParam = () => new v(w('Diagnostic.paramSpecUnknownParam'));
        e.paramTypeCovariant = () => w('Diagnostic.paramTypeCovariant');
        e.paramTypeUnknown = () => new v(w('Diagnostic.paramTypeUnknown'));
        e.paramAssignmentMismatch = () => new v(w('Diagnostic.paramAssignmentMismatch'));
        e.paramTypePartiallyUnknown = () => new v(w('Diagnostic.paramTypePartiallyUnknown'));
        e.parenthesizedContextManagerIllegal = () => w('Diagnostic.parenthesizedContextManagerIllegal');
        e.patternNeverMatches = () => new v(w('Diagnostic.patternNeverMatches'));
        e.positionArgAfterNamedArg = () => w('Diagnostic.positionArgAfterNamedArg');
        e.privateImportFromPyTypedModule = () => new v(w('Diagnostic.privateImportFromPyTypedModule'));
        e.positionOnlyAfterArgs = () => w('Diagnostic.positionOnlyAfterArgs');
        e.positionOnlyAfterKeywordOnly = () => w('Diagnostic.positionOnlyAfterKeywordOnly');
        e.positionOnlyAfterNon = () => w('Diagnostic.positionOnlyAfterNon');
        e.positionOnlyIncompatible = () => w('Diagnostic.positionOnlyIncompatible');
        e.positionOnlyFirstParam = () => w('Diagnostic.positionOnlyFirstParam');
        e.privateUsedOutsideOfClass = () => new v(w('Diagnostic.privateUsedOutsideOfClass'));
        e.privateUsedOutsideOfModule = () => new v(w('Diagnostic.privateUsedOutsideOfModule'));
        e.propertyOverridden = () => new v(w('Diagnostic.propertyOverridden'));
        e.propertyStaticMethod = () => w('Diagnostic.propertyStaticMethod');
        e.protectedUsedOutsideOfClass = () => new v(w('Diagnostic.protectedUsedOutsideOfClass'));
        e.protocolBaseClass = () => new v(w('Diagnostic.protocolBaseClass'));
        e.protocolBaseClassWithTypeArgs = () => w('Diagnostic.protocolBaseClassWithTypeArgs');
        e.protocolIllegal = () => w('Diagnostic.protocolIllegal');
        e.protocolNotAllowed = () => w('Diagnostic.protocolNotAllowed');
        e.protocolTypeArgMustBeTypeParam = () => w('Diagnostic.protocolTypeArgMustBeTypeParam');
        e.protocolUnsafeOverlap = () => new v(w('Diagnostic.protocolUnsafeOverlap'));
        e.protocolVarianceContravariant = () => new v(w('Diagnostic.protocolVarianceContravariant'));
        e.protocolVarianceCovariant = () => new v(w('Diagnostic.protocolVarianceCovariant'));
        e.protocolVarianceInvariant = () => new v(w('Diagnostic.protocolVarianceInvariant'));
        e.pyrightCommentInvalidDiagnosticBoolValue = () => w('Diagnostic.pyrightCommentInvalidDiagnosticBoolValue');
        e.pyrightCommentInvalidDiagnosticSeverityValue = () => w('Diagnostic.pyrightCommentInvalidDiagnosticSeverityValue');
        e.pyrightCommentMissingDirective = () => w('Diagnostic.pyrightCommentMissingDirective');
        e.pyrightCommentNotOnOwnLine = () => w('Diagnostic.pyrightCommentNotOnOwnLine');
        e.pyrightCommentUnknownDirective = () => new v(w('Diagnostic.pyrightCommentUnknownDirective'));
        e.pyrightCommentUnknownDiagnosticRule = () => new v(w('Diagnostic.pyrightCommentUnknownDiagnosticRule'));
        e.readOnlyArgCount = () => w('Diagnostic.readOnlyArgCount');
        e.readOnlyNotInTypedDict = () => w('Diagnostic.readOnlyNotInTypedDict');
        e.recursiveDefinition = () => new v(w('Diagnostic.recursiveDefinition'));
        e.relativeImportNotAllowed = () => w('Diagnostic.relativeImportNotAllowed');
        e.requiredArgCount = () => w('Diagnostic.requiredArgCount');
        e.requiredNotInTypedDict = () => w('Diagnostic.requiredNotInTypedDict');
        e.returnInAsyncGenerator = () => w('Diagnostic.returnInAsyncGenerator');
        e.returnMissing = () => new v(w('Diagnostic.returnMissing'));
        e.returnInExceptionGroup = () => w('Diagnostic.returnInExceptionGroup');
        e.returnOutsideFunction = () => w('Diagnostic.returnOutsideFunction');
        e.returnTypeContravariant = () => w('Diagnostic.returnTypeContravariant');
        e.returnTypeMismatch = () => new v(w('Diagnostic.returnTypeMismatch'));
        e.returnTypeUnknown = () => w('Diagnostic.returnTypeUnknown');
        e.returnTypePartiallyUnknown = () => new v(w('Diagnostic.returnTypePartiallyUnknown'));
        e.revealLocalsArgs = () => w('Diagnostic.revealLocalsArgs');
        e.revealLocalsNone = () => w('Diagnostic.revealLocalsNone');
        e.revealTypeArgs = () => w('Diagnostic.revealTypeArgs');
        e.revealTypeExpectedTextArg = () => w('Diagnostic.revealTypeExpectedTextArg');
        e.revealTypeExpectedTextMismatch = () => new v(w('Diagnostic.revealTypeExpectedTextMismatch'));
        e.revealTypeExpectedTypeMismatch = () => new v(w('Diagnostic.revealTypeExpectedTypeMismatch'));
        e.selfTypeContext = () => w('Diagnostic.selfTypeContext');
        e.selfTypeMetaclass = () => w('Diagnostic.selfTypeMetaclass');
        e.selfTypeWithTypedSelfOrCls = () => w('Diagnostic.selfTypeWithTypedSelfOrCls');
        e.setterGetterTypeMismatch = () => w('Diagnostic.setterGetterTypeMismatch');
        e.starPatternInAsPattern = () => w('Diagnostic.starPatternInAsPattern');
        e.starPatternInOrPattern = () => w('Diagnostic.starPatternInOrPattern');
        e.singleOverload = () => new v(w('Diagnostic.singleOverload'));
        e.slotsAttributeError = () => new v(w('Diagnostic.slotsAttributeError'));
        e.slotsClassVarConflict = () => new v(w('Diagnostic.slotsClassVarConflict'));
        e.starStarWildcardNotAllowed = () => w('Diagnostic.starStarWildcardNotAllowed');
        e.staticClsSelfParam = () => w('Diagnostic.staticClsSelfParam');
        e.stdlibModuleOverridden = () => new v(w('Diagnostic.stdlibModuleOverridden'));
        e.stringNonAsciiBytes = () => w('Diagnostic.stringNonAsciiBytes');
        e.stringNotSubscriptable = () => w('Diagnostic.stringNotSubscriptable');
        e.stringUnsupportedEscape = () => w('Diagnostic.stringUnsupportedEscape');
        e.stringUnterminated = () => w('Diagnostic.stringUnterminated');
        e.stubFileMissing = () => new v(w('Diagnostic.stubFileMissing'));
        e.stubUsesGetAttr = () => w('Diagnostic.stubUsesGetAttr');
        e.sublistParamsIncompatible = () => w('Diagnostic.sublistParamsIncompatible');
        e.superCallArgCount = () => w('Diagnostic.superCallArgCount');
        e.superCallFirstArg = () => new v(w('Diagnostic.superCallFirstArg'));
        e.superCallSecondArg = () => new v(w('Diagnostic.superCallSecondArg'));
        e.superCallZeroArgForm = () => w('Diagnostic.superCallZeroArgForm');
        e.superCallZeroArgFormStaticMethod = () => w('Diagnostic.superCallZeroArgFormStaticMethod');
        e.symbolIsUnbound = () => new v(w('Diagnostic.symbolIsUnbound'));
        e.symbolIsUndefined = () => new v(w('Diagnostic.symbolIsUndefined'));
        e.symbolIsPossiblyUnbound = () => new v(w('Diagnostic.symbolIsPossiblyUnbound'));
        e.symbolOverridden = () => new v(w('Diagnostic.symbolOverridden'));
        e.ternaryNotAllowed = () => w('Diagnostic.ternaryNotAllowed');
        e.totalOrderingMissingMethod = () => w('Diagnostic.totalOrderingMissingMethod');
        e.trailingCommaInFromImport = () => w('Diagnostic.trailingCommaInFromImport');
        e.tryWithoutExcept = () => w('Diagnostic.tryWithoutExcept');
        e.tupleAssignmentMismatch = () => new v(w('Diagnostic.tupleAssignmentMismatch'));
        e.tupleInAnnotation = () => w('Diagnostic.tupleInAnnotation');
        e.tupleIndexOutOfRange = () => new v(w('Diagnostic.tupleIndexOutOfRange'));
        e.typeAliasIllegalExpressionForm = () => w('Diagnostic.typeAliasIllegalExpressionForm');
        e.typeAliasIsRecursiveDirect = () => new v(w('Diagnostic.typeAliasIsRecursiveDirect'));
        e.typeAliasNotInModuleOrClass = () => w('Diagnostic.typeAliasNotInModuleOrClass');
        e.typeAliasRedeclared = () => new v(w('Diagnostic.typeAliasRedeclared'));
        e.typeAliasStatementIllegal = () => w('Diagnostic.typeAliasStatementIllegal');
        e.typeAliasStatementBadScope = () => w('Diagnostic.typeAliasStatementBadScope');
        e.typeAliasTypeBaseClass = () => w('Diagnostic.typeAliasTypeBaseClass');
        e.typeAliasTypeMustBeAssigned = () => w('Diagnostic.typeAliasTypeMustBeAssigned');
        e.typeAliasTypeNameArg = () => w('Diagnostic.typeAliasTypeNameArg');
        e.typeAliasTypeNameMismatch = () => w('Diagnostic.typeAliasTypeNameMismatch');
        e.typeAliasTypeParamInvalid = () => w('Diagnostic.typeAliasTypeParamInvalid');
        e.typeAnnotationCall = () => w('Diagnostic.typeAnnotationCall');
        e.typeAnnotationVariable = () => w('Diagnostic.typeAnnotationVariable');
        e.typeAnnotationWithCallable = () => w('Diagnostic.typeAnnotationWithCallable');
        e.typeArgListExpected = () => w('Diagnostic.typeArgListExpected');
        e.typeArgListNotAllowed = () => w('Diagnostic.typeArgListNotAllowed');
        e.typeArgsExpectingNone = () => new v(w('Diagnostic.typeArgsExpectingNone'));
        e.typeArgsMismatchOne = () => new v(w('Diagnostic.typeArgsMismatchOne'));
        e.typeArgsMissingForAlias = () => new v(w('Diagnostic.typeArgsMissingForAlias'));
        e.typeArgsMissingForClass = () => new v(w('Diagnostic.typeArgsMissingForClass'));
        e.typeArgsTooFew = () => new v(w('Diagnostic.typeArgsTooFew'));
        e.typeArgsTooMany = () => new v(w('Diagnostic.typeArgsTooMany'));
        e.typeAssignmentMismatch = () => new v(w('Diagnostic.typeAssignmentMismatch'));
        e.typeAssignmentMismatchWildcard = () => new v(w('Diagnostic.typeAssignmentMismatchWildcard'));
        e.typeCallNotAllowed = () => w('Diagnostic.typeCallNotAllowed');
        e.typeCheckOnly = () => new v(w('Diagnostic.typeCheckOnly'));
        e.typeCommentDeprecated = () => w('Diagnostic.typeCommentDeprecated');
        e.typedDictAccess = () => w('Diagnostic.typedDictAccess');
        e.typedDictAssignedName = () => new v(w('Diagnostic.typedDictAssignedName'));
        e.typedDictBadVar = () => w('Diagnostic.typedDictBadVar');
        e.typedDictBaseClass = () => w('Diagnostic.typedDictBaseClass');
        e.typedDictBoolParam = () => new v(w('Diagnostic.typedDictBoolParam'));
        e.typedDictClosedExtras = () => new v(w('Diagnostic.typedDictClosedExtras'));
        e.typedDictClosedNoExtras = () => new v(w('Diagnostic.typedDictClosedNoExtras'));
        e.typedDictDelete = () => w('Diagnostic.typedDictDelete');
        e.typedDictEmptyName = () => w('Diagnostic.typedDictEmptyName');
        e.typedDictEntryName = () => w('Diagnostic.typedDictEntryName');
        e.typedDictEntryUnique = () => w('Diagnostic.typedDictEntryUnique');
        e.typedDictExtraArgs = () => w('Diagnostic.typedDictExtraArgs');
        e.typedDictExtraItemsClosed = () => w('Diagnostic.typedDictExtraItemsClosed');
        e.typedDictFieldNotRequiredRedefinition = () => new v(w('Diagnostic.typedDictFieldNotRequiredRedefinition'));
        e.typedDictFieldReadOnlyRedefinition = () => new v(w('Diagnostic.typedDictFieldReadOnlyRedefinition'));
        e.typedDictFieldRequiredRedefinition = () => new v(w('Diagnostic.typedDictFieldRequiredRedefinition'));
        e.typedDictFirstArg = () => w('Diagnostic.typedDictFirstArg');
        e.typedDictInClassPattern = () => w('Diagnostic.typedDictInClassPattern');
        e.typedDictInitsubclassParameter = () => new v(w('Diagnostic.typedDictInitsubclassParameter'));
        e.typedDictNotAllowed = () => w('Diagnostic.typedDictNotAllowed');
        e.typedDictSecondArgDict = () => w('Diagnostic.typedDictSecondArgDict');
        e.typedDictSecondArgDictEntry = () => w('Diagnostic.typedDictSecondArgDictEntry');
        e.typedDictSet = () => w('Diagnostic.typedDictSet');
        e.typeExpectedClass = () => new v(w('Diagnostic.typeExpectedClass'));
        e.typeFormArgs = () => w('Diagnostic.typeFormArgs');
        e.typeGuardArgCount = () => w('Diagnostic.typeGuardArgCount');
        e.typeGuardParamCount = () => w('Diagnostic.typeGuardParamCount');
        e.typeIsReturnType = () => new v(w('Diagnostic.typeIsReturnType'));
        e.typeNotAwaitable = () => new v(w('Diagnostic.typeNotAwaitable'));
        e.typeNotIntantiable = () => new v(w('Diagnostic.typeNotIntantiable'));
        e.typeNotIterable = () => new v(w('Diagnostic.typeNotIterable'));
        e.typeNotSpecializable = () => new v(w('Diagnostic.typeNotSpecializable'));
        e.typeNotSubscriptable = () => new v(w('Diagnostic.typeNotSubscriptable'));
        e.typeNotUsableWith = () => new v(w('Diagnostic.typeNotUsableWith'));
        e.typeNotSupportBinaryOperator = () => new v(w('Diagnostic.typeNotSupportBinaryOperator'));
        e.typeNotSupportBinaryOperatorBidirectional = () => new v(w('Diagnostic.typeNotSupportBinaryOperatorBidirectional'));
        e.typeNotSupportUnaryOperator = () => new v(w('Diagnostic.typeNotSupportUnaryOperator'));
        e.typeNotSupportUnaryOperatorBidirectional = () => new v(w('Diagnostic.typeNotSupportUnaryOperatorBidirectional'));
        e.typeParameterBoundNotAllowed = () => w('Diagnostic.typeParameterBoundNotAllowed');
        e.typeParameterConstraintTuple = () => w('Diagnostic.typeParameterConstraintTuple');
        e.typeParameterExistingTypeParameter = () => new v(w('Diagnostic.typeParameterExistingTypeParameter'));
        e.typeParametersMissing = () => w('Diagnostic.typeParametersMissing');
        e.typeParameterNotDeclared = () => new v(w('Diagnostic.typeParameterNotDeclared'));
        e.typePartiallyUnknown = () => new v(w('Diagnostic.typePartiallyUnknown'));
        e.typeUnknown = () => new v(w('Diagnostic.typeUnknown'));
        e.typeVarAssignedName = () => new v(w('Diagnostic.typeVarAssignedName'));
        e.typeVarAssignmentMismatch = () => new v(w('Diagnostic.typeVarAssignmentMismatch'));
        e.typeVarBoundAndConstrained = () => w('Diagnostic.typeVarBoundAndConstrained');
        e.typeVarBoundGeneric = () => w('Diagnostic.typeVarBoundGeneric');
        e.typeVarConstraintGeneric = () => w('Diagnostic.typeVarConstraintGeneric');
        e.typeVarDefaultBoundMismatch = () => w('Diagnostic.typeVarDefaultBoundMismatch');
        e.typeVarDefaultConstraintMismatch = () => w('Diagnostic.typeVarDefaultConstraintMismatch');
        e.typeVarDefaultIllegal = () => w('Diagnostic.typeVarDefaultIllegal');
        e.typeVarDefaultInvalidTypeVar = () => new v(w('Diagnostic.typeVarDefaultInvalidTypeVar'));
        e.typeVarFirstArg = () => w('Diagnostic.typeVarFirstArg');
        e.typeVarInvalidForMemberVariable = () => new v(w('Diagnostic.typeVarInvalidForMemberVariable'));
        e.typeVarNoMember = () => new v(w('Diagnostic.typeVarNoMember'));
        e.typeVarNotSubscriptable = () => new v(w('Diagnostic.typeVarNotSubscriptable'));
        e.typeVarNotUsedByOuterScope = () => new v(w('Diagnostic.typeVarNotUsedByOuterScope'));
        e.typeVarPossiblyUnsolvable = () => new v(w('Diagnostic.typeVarPossiblyUnsolvable'));
        e.typeVarSingleConstraint = () => w('Diagnostic.typeVarSingleConstraint');
        e.typeVarsNotInGenericOrProtocol = () => w('Diagnostic.typeVarsNotInGenericOrProtocol');
        e.typeVarTupleContext = () => w('Diagnostic.typeVarTupleContext');
        e.typeVarTupleDefaultNotUnpacked = () => w('Diagnostic.typeVarTupleDefaultNotUnpacked');
        e.typeVarTupleMustBeUnpacked = () => w('Diagnostic.typeVarTupleMustBeUnpacked');
        e.typeVarTupleConstraints = () => w('Diagnostic.typeVarTupleConstraints');
        e.typeVarTupleUnknownParam = () => new v(w('Diagnostic.typeVarTupleUnknownParam'));
        e.typeVarUnknownParam = () => new v(w('Diagnostic.typeVarUnknownParam'));
        e.typeVarUsedByOuterScope = () => new v(w('Diagnostic.typeVarUsedByOuterScope'));
        e.typeVarUsedOnlyOnce = () => new v(w('Diagnostic.typeVarUsedOnlyOnce'));
        e.typeVarVariance = () => w('Diagnostic.typeVarVariance');
        e.typeVarWithDefaultFollowsVariadic = () => new v(w('Diagnostic.typeVarWithDefaultFollowsVariadic'));
        e.typeVarWithoutDefault = () => new v(w('Diagnostic.typeVarWithoutDefault'));
        e.unaccessedClass = () => new v(w('Diagnostic.unaccessedClass'));
        e.unaccessedFunction = () => new v(w('Diagnostic.unaccessedFunction'));
        e.unaccessedImport = () => new v(w('Diagnostic.unaccessedImport'));
        e.unaccessedSymbol = () => new v(w('Diagnostic.unaccessedSymbol'));
        e.unaccessedVariable = () => new v(w('Diagnostic.unaccessedVariable'));
        e.unannotatedFunctionSkipped = () => new v(w('Diagnostic.unannotatedFunctionSkipped'));
        e.unaryOperationNotAllowed = () => w('Diagnostic.unaryOperationNotAllowed');
        e.unexpectedAsyncToken = () => w('Diagnostic.unexpectedAsyncToken');
        e.unexpectedExprToken = () => w('Diagnostic.unexpectedExprToken');
        e.unexpectedIndent = () => w('Diagnostic.unexpectedIndent');
        e.unexpectedUnindent = () => w('Diagnostic.unexpectedUnindent');
        e.unhashableDictKey = () => w('Diagnostic.unhashableDictKey');
        e.unhashableSetEntry = () => w('Diagnostic.unhashableSetEntry');
        e.unionForwardReferenceNotAllowed = () => w('Diagnostic.unionForwardReferenceNotAllowed');
        e.unionSyntaxIllegal = () => w('Diagnostic.unionSyntaxIllegal');
        e.unionTypeArgCount = () => w('Diagnostic.unionTypeArgCount');
        e.uninitializedAbstractVariables = () => new v(w('Diagnostic.uninitializedAbstractVariables'));
        e.uninitializedInstanceVariable = () => new v(w('Diagnostic.uninitializedInstanceVariable'));
        e.unionUnpackedTuple = () => w('Diagnostic.unionUnpackedTuple');
        e.unionUnpackedTypeVarTuple = () => w('Diagnostic.unionUnpackedTypeVarTuple');
        e.unnecessaryCast = () => new v(w('Diagnostic.unnecessaryCast'));
        e.unnecessaryIsInstanceAlways = () => new v(w('Diagnostic.unnecessaryIsInstanceAlways'));
        e.unnecessaryIsSubclassAlways = () => new v(w('Diagnostic.unnecessaryIsSubclassAlways'));
        e.unnecessaryIsInstanceNever = () => new v(w('Diagnostic.unnecessaryIsInstanceNever'));
        e.unnecessaryIsSubclassNever = () => new v(w('Diagnostic.unnecessaryIsSubclassNever'));
        e.unnecessaryPyrightIgnore = () => w('Diagnostic.unnecessaryPyrightIgnore');
        e.unnecessaryPyrightIgnoreRule = () => new v(w('Diagnostic.unnecessaryPyrightIgnoreRule'));
        e.unnecessaryTypeIgnore = () => w('Diagnostic.unnecessaryTypeIgnore');
        e.unpackArgCount = () => w('Diagnostic.unpackArgCount');
        e.unpackedArgInTypeArgument = () => w('Diagnostic.unpackedArgInTypeArgument');
        e.unpackedArgWithVariadicParam = () => w('Diagnostic.unpackedArgWithVariadicParam');
        e.unpackedDictArgumentNotMapping = () => w('Diagnostic.unpackedDictArgumentNotMapping');
        e.unpackedDictSubscriptIllegal = () => w('Diagnostic.unpackedDictSubscriptIllegal');
        e.unpackedSubscriptIllegal = () => w('Diagnostic.unpackedSubscriptIllegal');
        e.unpackedTypedDictArgument = () => w('Diagnostic.unpackedTypedDictArgument');
        e.unpackedTypeVarTupleExpected = () => new v(w('Diagnostic.unpackedTypeVarTupleExpected'));
        e.unpackExpectedTypedDict = () => w('Diagnostic.unpackExpectedTypedDict');
        e.unpackExpectedTypeVarTuple = () => w('Diagnostic.unpackExpectedTypeVarTuple');
        e.unpackIllegalInComprehension = () => w('Diagnostic.unpackIllegalInComprehension');
        e.unpackInAnnotation = () => w('Diagnostic.unpackInAnnotation');
        e.unpackInDict = () => w('Diagnostic.unpackInDict');
        e.unpackInSet = () => w('Diagnostic.unpackInSet');
        e.unpackNotAllowed = () => w('Diagnostic.unpackNotAllowed');
        e.unpackOperatorNotAllowed = () => w('Diagnostic.unpackOperatorNotAllowed');
        e.unpackTuplesIllegal = () => w('Diagnostic.unpackTuplesIllegal');
        e.unreachableCode = () => w('Diagnostic.unreachableCode');
        e.unreachableCodeType = () => w('Diagnostic.unreachableCodeType');
        e.unreachableExcept = () => w('Diagnostic.unreachableExcept');
        e.unsupportedDunderAllOperation = () => w('Diagnostic.unsupportedDunderAllOperation');
        e.unusedCallResult = () => new v(w('Diagnostic.unusedCallResult'));
        e.unusedCoroutine = () => w('Diagnostic.unusedCoroutine');
        e.unusedExpression = () => w('Diagnostic.unusedExpression');
        e.varAnnotationIllegal = () => w('Diagnostic.varAnnotationIllegal');
        e.variableFinalOverride = () => new v(w('Diagnostic.variableFinalOverride'));
        e.variadicTypeArgsTooMany = () => w('Diagnostic.variadicTypeArgsTooMany');
        e.variadicTypeParamTooManyAlias = () => new v(w('Diagnostic.variadicTypeParamTooManyAlias'));
        e.variadicTypeParamTooManyClass = () => new v(w('Diagnostic.variadicTypeParamTooManyClass'));
        e.walrusIllegal = () => w('Diagnostic.walrusIllegal');
        e.walrusNotAllowed = () => w('Diagnostic.walrusNotAllowed');
        e.wildcardInFunction = () => w('Diagnostic.wildcardInFunction');
        e.wildcardPatternTypeUnknown = () => w('Diagnostic.wildcardPatternTypeUnknown');
        e.wildcardPatternTypePartiallyUnknown = () => w('Diagnostic.wildcardPatternTypePartiallyUnknown');
        e.wildcardLibraryImport = () => w('Diagnostic.wildcardLibraryImport');
        e.yieldFromIllegal = () => w('Diagnostic.yieldFromIllegal');
        e.yieldFromOutsideAsync = () => w('Diagnostic.yieldFromOutsideAsync');
        e.yieldOutsideFunction = () => w('Diagnostic.yieldOutsideFunction');
        e.yieldWithinComprehension = () => w('Diagnostic.yieldWithinComprehension');
        e.zeroCaseStatementsFound = () => w('Diagnostic.zeroCaseStatementsFound');
        e.zeroLengthTupleNotAllowed = () => w('Diagnostic.zeroLengthTupleNotAllowed');
      })(t = e.Diagnostic ||= {});
      (function (e) {
        e.annotatedNotAllowed = () => w('DiagnosticAddendum.annotatedNotAllowed');
        e.argParam = () => new v(w('DiagnosticAddendum.argParam'));
        e.argParamFunction = () => new v(w('DiagnosticAddendum.argParamFunction'));
        e.argsParamMissing = () => new v(w('DiagnosticAddendum.argsParamMissing'));
        e.argsPositionOnly = () => new v(w('DiagnosticAddendum.argsPositionOnly'));
        e.argumentType = () => new v(w('DiagnosticAddendum.argumentType'));
        e.argumentTypes = () => new v(w('DiagnosticAddendum.argumentTypes'));
        e.assignToNone = () => w('DiagnosticAddendum.assignToNone');
        e.asyncHelp = () => w('DiagnosticAddendum.asyncHelp');
        e.baseClassIncompatible = () => new v(w('DiagnosticAddendum.baseClassIncompatible'));
        e.baseClassIncompatibleSubclass = () => new v(w('DiagnosticAddendum.baseClassIncompatibleSubclass'));
        e.baseClassOverriddenType = () => new v(w('DiagnosticAddendum.baseClassOverriddenType'));
        e.baseClassOverridesType = () => new v(w('DiagnosticAddendum.baseClassOverridesType'));
        e.bytesTypePromotions = () => w('DiagnosticAddendum.bytesTypePromotions');
        e.conditionalRequiresBool = () => new v(w('DiagnosticAddendum.conditionalRequiresBool'));
        e.dataClassFrozen = () => new v(w('DiagnosticAddendum.dataClassFrozen'));
        e.dataClassFieldLocation = () => w('DiagnosticAddendum.dataClassFieldLocation');
        e.dataProtocolUnsupported = () => new v(w('DiagnosticAddendum.dataProtocolUnsupported'));
        e.descriptorAccessBindingFailed = () => new v(w('DiagnosticAddendum.descriptorAccessBindingFailed'));
        e.descriptorAccessCallFailed = () => new v(w('DiagnosticAddendum.descriptorAccessCallFailed'));
        e.finalMethod = () => w('DiagnosticAddendum.finalMethod');
        e.functionParamDefaultMissing = () => new v(w('DiagnosticAddendum.functionParamDefaultMissing'));
        e.functionParamName = () => new v(w('DiagnosticAddendum.functionParamName'));
        e.functionParamPositionOnly = () => new v(w('DiagnosticAddendum.functionParamPositionOnly'));
        e.functionReturnTypeMismatch = () => new v(w('DiagnosticAddendum.functionReturnTypeMismatch'));
        e.functionTooFewParams = () => new v(w('DiagnosticAddendum.functionTooFewParams'));
        e.genericClassNotAllowed = () => w('DiagnosticAddendum.genericClassNotAllowed');
        e.incompatibleGetter = () => w('DiagnosticAddendum.incompatibleGetter');
        e.incompatibleSetter = () => w('DiagnosticAddendum.incompatibleSetter');
        e.incompatibleDeleter = () => w('DiagnosticAddendum.incompatibleDeleter');
        e.initMethodLocation = () => new v(w('DiagnosticAddendum.initMethodLocation'));
        e.initMethodSignature = () => new v(w('DiagnosticAddendum.initMethodSignature'));
        e.initSubclassLocation = () => new v(w('DiagnosticAddendum.initSubclassLocation'));
        e.invariantSuggestionDict = () => w('DiagnosticAddendum.invariantSuggestionDict');
        e.invariantSuggestionList = () => w('DiagnosticAddendum.invariantSuggestionList');
        e.invariantSuggestionSet = () => w('DiagnosticAddendum.invariantSuggestionSet');
        e.isinstanceClassNotSupported = () => new v(w('DiagnosticAddendum.isinstanceClassNotSupported'));
        e.functionTooManyParams = () => new v(w('DiagnosticAddendum.functionTooManyParams'));
        e.keyNotRequired = () => new v(w('DiagnosticAddendum.keyNotRequired'));
        e.keyReadOnly = () => new v(w('DiagnosticAddendum.keyReadOnly'));
        e.keyRequiredDeleted = () => new v(w('DiagnosticAddendum.keyRequiredDeleted'));
        e.keyUndefined = () => new v(w('DiagnosticAddendum.keyUndefined'));
        e.kwargsParamMissing = () => new v(w('DiagnosticAddendum.kwargsParamMissing'));
        e.listAssignmentMismatch = () => new v(w('DiagnosticAddendum.listAssignmentMismatch'));
        e.literalAssignmentMismatch = () => new v(w('DiagnosticAddendum.literalAssignmentMismatch'));
        e.matchIsNotExhaustiveType = () => new v(w('DiagnosticAddendum.matchIsNotExhaustiveType'));
        e.matchIsNotExhaustiveHint = () => w('DiagnosticAddendum.matchIsNotExhaustiveHint');
        e.memberAssignment = () => new v(w('DiagnosticAddendum.memberAssignment'));
        e.memberIsAbstract = () => new v(w('DiagnosticAddendum.memberIsAbstract'));
        e.memberIsAbstractMore = () => new v(w('DiagnosticAddendum.memberIsAbstractMore'));
        e.memberIsClassVarInProtocol = () => new v(w('DiagnosticAddendum.memberIsClassVarInProtocol'));
        e.memberIsInitVar = () => new v(w('DiagnosticAddendum.memberIsInitVar'));
        e.memberIsInvariant = () => new v(w('DiagnosticAddendum.memberIsInvariant'));
        e.memberIsNotClassVarInClass = () => new v(w('DiagnosticAddendum.memberIsNotClassVarInClass'));
        e.memberIsNotClassVarInProtocol = () => new v(w('DiagnosticAddendum.memberIsNotClassVarInProtocol'));
        e.memberIsNotReadOnlyInProtocol = () => new v(w('DiagnosticAddendum.memberIsNotReadOnlyInProtocol'));
        e.memberIsReadOnlyInProtocol = () => new v(w('DiagnosticAddendum.memberIsReadOnlyInProtocol'));
        e.memberIsWritableInProtocol = () => new v(w('DiagnosticAddendum.memberIsWritableInProtocol'));
        e.memberSetClassVar = () => new v(w('DiagnosticAddendum.memberSetClassVar'));
        e.memberTypeMismatch = () => new v(w('DiagnosticAddendum.memberTypeMismatch'));
        e.memberUnknown = () => new v(w('DiagnosticAddendum.memberUnknown'));
        e.metaclassConflict = () => new v(w('DiagnosticAddendum.metaclassConflict'));
        e.missingGetter = () => w('DiagnosticAddendum.missingGetter');
        e.missingSetter = () => w('DiagnosticAddendum.missingSetter');
        e.missingDeleter = () => w('DiagnosticAddendum.missingDeleter');
        e.namedParamMissingInDest = () => new v(w('DiagnosticAddendum.namedParamMissingInDest'));
        e.namedParamMissingInSource = () => new v(w('DiagnosticAddendum.namedParamMissingInSource'));
        e.namedParamTypeMismatch = () => new v(w('DiagnosticAddendum.namedParamTypeMismatch'));
        e.namedTupleNotAllowed = () => w('DiagnosticAddendum.namedTupleNotAllowed');
        e.newMethodLocation = () => new v(w('DiagnosticAddendum.newMethodLocation'));
        e.newMethodSignature = () => new v(w('DiagnosticAddendum.newMethodSignature'));
        e.noneNotAllowed = () => w('DiagnosticAddendum.noneNotAllowed');
        e.newTypeClassNotAllowed = () => w('DiagnosticAddendum.newTypeClassNotAllowed');
        e.noOverloadAssignable = () => new v(w('DiagnosticAddendum.noOverloadAssignable'));
        e.orPatternMissingName = () => new v(w('DiagnosticAddendum.orPatternMissingName'));
        e.overloadIndex = () => new v(w('DiagnosticAddendum.overloadIndex'));
        e.overloadSignature = () => w('DiagnosticAddendum.overloadSignature');
        e.overloadNotAssignable = () => new v(w('DiagnosticAddendum.overloadNotAssignable'));
        e.overriddenMethod = () => w('DiagnosticAddendum.overriddenMethod');
        e.overriddenSymbol = () => w('DiagnosticAddendum.overriddenSymbol');
        e.overrideIsInvariant = () => w('DiagnosticAddendum.overrideIsInvariant');
        e.overrideInvariantMismatch = () => new v(w('DiagnosticAddendum.overrideInvariantMismatch'));
        e.overrideNoOverloadMatches = () => w('DiagnosticAddendum.overrideNoOverloadMatches');
        e.overrideNotClassMethod = () => w('DiagnosticAddendum.overrideNotClassMethod');
        e.overrideNotInstanceMethod = () => w('DiagnosticAddendum.overrideNotInstanceMethod');
        e.overrideNotStaticMethod = () => w('DiagnosticAddendum.overrideNotStaticMethod');
        e.overrideOverloadNoMatch = () => w('DiagnosticAddendum.overrideOverloadNoMatch');
        e.overrideOverloadOrder = () => w('DiagnosticAddendum.overrideOverloadOrder');
        e.overrideParamKeywordNoDefault = () => new v(w('DiagnosticAddendum.overrideParamKeywordNoDefault'));
        e.overrideParamKeywordType = () => new v(w('DiagnosticAddendum.overrideParamKeywordType'));
        e.overrideParamName = () => new v(w('DiagnosticAddendum.overrideParamName'));
        e.overrideParamNameExtra = () => new v(w('DiagnosticAddendum.overrideParamNameExtra'));
        e.overrideParamNameMissing = () => new v(w('DiagnosticAddendum.overrideParamNameMissing'));
        e.overrideParamNamePositionOnly = () => new v(w('DiagnosticAddendum.overrideParamNamePositionOnly'));
        e.overrideParamNoDefault = () => new v(w('DiagnosticAddendum.overrideParamNoDefault'));
        e.overrideParamType = () => new v(w('DiagnosticAddendum.overrideParamType'));
        e.overridePositionalParamCount = () => new v(w('DiagnosticAddendum.overridePositionalParamCount'));
        e.overrideReturnType = () => new v(w('DiagnosticAddendum.overrideReturnType'));
        e.overrideType = () => new v(w('DiagnosticAddendum.overrideType'));
        e.paramAssignment = () => new v(w('DiagnosticAddendum.paramAssignment'));
        e.paramSpecMissingInOverride = () => w('DiagnosticAddendum.paramSpecMissingInOverride');
        e.paramType = () => new v(w('DiagnosticAddendum.paramType'));
        e.privateImportFromPyTypedSource = () => new v(w('DiagnosticAddendum.privateImportFromPyTypedSource'));
        e.propertyAccessFromProtocolClass = () => w('DiagnosticAddendum.propertyAccessFromProtocolClass');
        e.propertyMethodIncompatible = () => new v(w('DiagnosticAddendum.propertyMethodIncompatible'));
        e.propertyMethodMissing = () => new v(w('DiagnosticAddendum.propertyMethodMissing'));
        e.propertyMissingDeleter = () => new v(w('DiagnosticAddendum.propertyMissingDeleter'));
        e.propertyMissingSetter = () => new v(w('DiagnosticAddendum.propertyMissingSetter'));
        e.protocolIncompatible = () => new v(w('DiagnosticAddendum.protocolIncompatible'));
        e.protocolMemberMissing = () => new v(w('DiagnosticAddendum.protocolMemberMissing'));
        e.protocolRequiresRuntimeCheckable = () => w('DiagnosticAddendum.protocolRequiresRuntimeCheckable');
        e.protocolSourceIsNotConcrete = () => new v(w('DiagnosticAddendum.protocolSourceIsNotConcrete'));
        e.protocolUnsafeOverlap = () => new v(w('DiagnosticAddendum.protocolUnsafeOverlap'));
        e.pyrightCommentIgnoreTip = () => w('DiagnosticAddendum.pyrightCommentIgnoreTip');
        e.readOnlyAttribute = () => new v(w('DiagnosticAddendum.readOnlyAttribute'));
        e.seeDeclaration = () => w('DiagnosticAddendum.seeDeclaration');
        e.seeClassDeclaration = () => w('DiagnosticAddendum.seeClassDeclaration');
        e.seeFunctionDeclaration = () => w('DiagnosticAddendum.seeFunctionDeclaration');
        e.seeMethodDeclaration = () => w('DiagnosticAddendum.seeMethodDeclaration');
        e.seeParameterDeclaration = () => w('DiagnosticAddendum.seeParameterDeclaration');
        e.seeTypeAliasDeclaration = () => w('DiagnosticAddendum.seeTypeAliasDeclaration');
        e.seeVariableDeclaration = () => w('DiagnosticAddendum.seeVariableDeclaration');
        e.tupleEntryTypeMismatch = () => new v(w('DiagnosticAddendum.tupleEntryTypeMismatch'));
        e.tupleAssignmentMismatch = () => new v(w('DiagnosticAddendum.tupleAssignmentMismatch'));
        e.tupleSizeIndeterminateSrc = () => new v(w('DiagnosticAddendum.tupleSizeIndeterminateSrc'));
        e.tupleSizeIndeterminateSrcDest = () => new v(w('DiagnosticAddendum.tupleSizeIndeterminateSrcDest'));
        e.tupleSizeMismatch = () => new v(w('DiagnosticAddendum.tupleSizeMismatch'));
        e.tupleSizeMismatchIndeterminateDest = () => new v(w('DiagnosticAddendum.tupleSizeMismatchIndeterminateDest'));
        e.typeAliasInstanceCheck = () => w('DiagnosticAddendum.typeAliasInstanceCheck');
        e.typeAssignmentMismatch = () => new v(w('DiagnosticAddendum.typeAssignmentMismatch'));
        e.typeBound = () => new v(w('DiagnosticAddendum.typeBound'));
        e.typeConstrainedTypeVar = () => new v(w('DiagnosticAddendum.typeConstrainedTypeVar'));
        e.typedDictBaseClass = () => new v(w('DiagnosticAddendum.typedDictBaseClass'));
        e.typedDictClassNotAllowed = () => w('DiagnosticAddendum.typedDictClassNotAllowed');
        e.typedDictExtraFieldNotAllowed = () => new v(w('DiagnosticAddendum.typedDictExtraFieldNotAllowed'));
        e.typedDictExtraFieldTypeMismatch = () => new v(w('DiagnosticAddendum.typedDictExtraFieldTypeMismatch'));
        e.typedDictFieldMissing = () => new v(w('DiagnosticAddendum.typedDictFieldMissing'));
        e.typedDictClosedExtraNotAllowed = () => new v(w('DiagnosticAddendum.typedDictClosedExtraNotAllowed'));
        e.typedDictClosedExtraTypeMismatch = () => new v(w('DiagnosticAddendum.typedDictClosedExtraTypeMismatch'));
        e.typedDictClosedFieldNotRequired = () => new v(w('DiagnosticAddendum.typedDictClosedFieldNotRequired'));
        e.typedDictFieldNotReadOnly = () => new v(w('DiagnosticAddendum.typedDictFieldNotReadOnly'));
        e.typedDictFieldNotRequired = () => new v(w('DiagnosticAddendum.typedDictFieldNotRequired'));
        e.typedDictFieldRequired = () => new v(w('DiagnosticAddendum.typedDictFieldRequired'));
        e.typedDictFieldTypeMismatch = () => new v(w('DiagnosticAddendum.typedDictFieldTypeMismatch'));
        e.typedDictFieldUndefined = () => new v(w('DiagnosticAddendum.typedDictFieldUndefined'));
        e.typedDictFinalMismatch = () => new v(w('DiagnosticAddendum.typedDictFinalMismatch'));
        e.typedDictKeyAccess = () => new v(w('DiagnosticAddendum.typedDictKeyAccess'));
        e.typedDictNotAllowed = () => w('DiagnosticAddendum.typedDictNotAllowed');
        e.typeIncompatible = () => new v(w('DiagnosticAddendum.typeIncompatible'));
        e.typeNotClass = () => new v(w('DiagnosticAddendum.typeNotClass'));
        e.typeParamSpec = () => new v(w('DiagnosticAddendum.typeParamSpec'));
        e.typeNotStringLiteral = () => new v(w('DiagnosticAddendum.typeNotStringLiteral'));
        e.typeOfSymbol = () => new v(w('DiagnosticAddendum.typeOfSymbol'));
        e.typeUnsupported = () => new v(w('DiagnosticAddendum.typeUnsupported'));
        e.typeVarDefaultOutOfScope = () => new v(w('DiagnosticAddendum.typeVarDefaultOutOfScope'));
        e.typeVarIsContravariant = () => new v(w('DiagnosticAddendum.typeVarIsContravariant'));
        e.typeVarIsCovariant = () => new v(w('DiagnosticAddendum.typeVarIsCovariant'));
        e.typeVarIsInvariant = () => new v(w('DiagnosticAddendum.typeVarIsInvariant'));
        e.typeVarsMissing = () => new v(w('DiagnosticAddendum.typeVarsMissing'));
        e.typeVarNotAllowed = () => w('DiagnosticAddendum.typeVarNotAllowed');
        e.typeVarTupleRequiresKnownLength = () => w('DiagnosticAddendum.typeVarTupleRequiresKnownLength');
        e.typeVarUnnecessarySuggestion = () => new v(w('DiagnosticAddendum.typeVarUnnecessarySuggestion'));
        e.typeVarUnsolvableRemedy = () => w('DiagnosticAddendum.typeVarUnsolvableRemedy');
        e.unhashableType = () => new v(w('DiagnosticAddendum.unhashableType'));
        e.uninitializedAbstractVariable = () => new v(w('DiagnosticAddendum.uninitializedAbstractVariable'));
        e.unreachableExcept = () => new v(w('DiagnosticAddendum.unreachableExcept'));
        e.useDictInstead = () => w('DiagnosticAddendum.useDictInstead');
        e.useListInstead = () => w('DiagnosticAddendum.useListInstead');
        e.useTupleInstead = () => w('DiagnosticAddendum.useTupleInstead');
        e.useTypeInstead = () => w('DiagnosticAddendum.useTypeInstead');
        e.varianceMismatchForClass = () => new v(w('DiagnosticAddendum.varianceMismatchForClass'));
        e.varianceMismatchForTypeAlias = () => new v(w('DiagnosticAddendum.varianceMismatchForTypeAlias'));
      })(n = e.DiagnosticAddendum ||= {});
      (function (e) {
        e.createTypeStub = () => w('CodeAction.createTypeStub');
        e.createTypeStubFor = () => new v(w('CodeAction.createTypeStubFor'));
        e.executingCommand = () => w('CodeAction.executingCommand');
        e.filesToAnalyzeOne = () => w('CodeAction.filesToAnalyzeOne');
        e.filesToAnalyzeCount = () => new v(w('CodeAction.filesToAnalyzeCount'));
        e.findingReferences = () => w('CodeAction.findingReferences');
        e.organizeImports = () => w('CodeAction.organizeImports');
        e.renameShadowedFile = () => new v(w('CodeAction.renameShadowedFile'));
      })(a = e.CodeAction ||= {});
      (function (e) {
        e.autoImportDetail = () => w('Completion.autoImportDetail');
        e.indexValueDetail = () => w('Completion.indexValueDetail');
      })(r = e.Completion ||= {});
      (function (e) {
        e.longOperation = () => w('Service.longOperation');
      })(s = e.Service ||= {});
    })(D || (exports.Localizer = D = {}));
    exports.LocMessage = D.Diagnostic;
    exports.LocAddendum = D.DiagnosticAddendum;
  },
  86500: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.run = async function (e, t) {
      await s.initializeDependencies();
      if (r.isMainThread) {
        e(a.createConnection(o()));
      } else {
        t();
      }
    };
    exports.getConnectionOptions = o;
    const a = require(8713);
    const r = require(28167);
    const s = require(64330);
    const i = require(34487);
    function o() {
      return {
        cancellationStrategy: i.getCancellationStrategyFromArgv(process.argv)
      };
    }
  },
  51651: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.CharacterStream = undefined;
    const a = require(4794);
    exports.CharacterStream = class {
      constructor(e) {
        this._text = e;
        this._position = 0;
        this._currentChar = e.length > 0 ? e.charCodeAt(0) : 0;
        this._isEndOfStream = e.length === 0;
      }
      get position() {
        return this._position;
      }
      set position(e) {
        this._position = e;
        this._checkBounds();
      }
      get currentChar() {
        return this._currentChar;
      }
      get nextChar() {
        if (this.position + 1 < this._text.length) {
          return this._text.charCodeAt(this.position + 1);
        } else {
          return 0;
        }
      }
      get prevChar() {
        if (this.position - 1 >= 0) {
          return this._text.charCodeAt(this.position - 1);
        } else {
          return 0;
        }
      }
      get length() {
        return this._text.length;
      }
      getText() {
        return this._text;
      }
      getCurrentChar() {
        return this._currentChar;
      }
      isEndOfStream() {
        return this._isEndOfStream;
      }
      lookAhead(e) {
        const t = this._position + e;
        if (t < 0 || t >= this._text.length) {
          return 0;
        } else {
          return this._text.charCodeAt(t);
        }
      }
      advance(e) {
        this.position += e;
      }
      moveNext() {
        if (this._position < this._text.length - 1) {
          this._position += 1;
          this._currentChar = this._text.charCodeAt(this._position);
          return true;
        } else {
          this.advance(1);
          return !this.isEndOfStream();
        }
      }
      isAtWhiteSpace() {
        return a.isWhiteSpace(this.currentChar);
      }
      isAtLineBreak() {
        return a.isLineBreak(this.currentChar);
      }
      skipLineBreak() {
        if (this._currentChar === 13) {
          this.moveNext();
          if (this.currentChar === 10) {
            this.moveNext();
          }
        } else {
          if (this._currentChar === 10) {
            this.moveNext();
          }
        }
      }
      skipWhitespace() {
        while (!this.isEndOfStream() && this.isAtWhiteSpace()) {
          this.moveNext();
        }
      }
      skipToEol() {
        while (!this.isEndOfStream() && !this.isAtLineBreak()) {
          this.moveNext();
        }
      }
      skipToWhitespace() {
        while (!this.isEndOfStream() && !this.isAtWhiteSpace()) {
          this.moveNext();
        }
      }
      charCodeAt(e) {
        return this._text.charCodeAt(e);
      }
      _checkBounds() {
        if (this._position < 0) {
          this._position = 0;
        }
        this._isEndOfStream = this._position >= this._text.length;
        if (this._isEndOfStream) {
          this._position = this._text.length;
        }
        this._currentChar = this._isEndOfStream ? 0 : this._text.charCodeAt(this._position);
      }
    };
  },
  4794: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.isIdentifierStartChar = function (e, t) {
      if (e < l) {
        return p[e] === o.StartIdentifierChar;
      }
      if (!u) {
        _(false);
        u = true;
      }
      let n;
      n = t !== undefined ? y(e, t) : d[e];
      return n === o.StartIdentifierChar;
    };
    exports.isIdentifierChar = function (e, t) {
      if (e < l) {
        return p[e] === o.StartIdentifierChar || p[e] === o.IdentifierChar;
      }
      if (!u) {
        _(false);
        u = true;
      }
      if (t !== undefined) {
        return y(e, t);
      }
      return d[e] === o.StartIdentifierChar || d[e] === o.IdentifierChar;
    };
    exports.isSurrogateChar = function (e) {
      if (e < l) {
        return false;
      }
      if (!u) {
        _(false);
        u = true;
      }
      return d[e] === o.SurrogateChar;
    };
    exports.isWhiteSpace = function (e) {
      return e === 32 || e === 9 || e === 12;
    };
    exports.isLineBreak = function (e) {
      return e === 13 || e === 10;
    };
    exports.isNumber = function (e) {
      return e >= 48 && e <= 57 || e === 95;
    };
    exports.isDecimal = m;
    exports.isHex = function (e) {
      return m(e) || e >= 97 && e <= 102 || e >= 65 && e <= 70 || e === 95;
    };
    exports.isOctal = function (e) {
      return e >= 48 && e <= 55 || e === 95;
    };
    exports.isBinary = function (e) {
      return e === 48 || e === 49 || e === 95;
    };
    const i = __importStar(require(14911));
    var o;
    (function (e) {
      e[e.NotIdentifierChar = 0] = 'NotIdentifierChar';
      e[e.StartIdentifierChar = 1] = 'StartIdentifierChar';
      e[e.IdentifierChar = 2] = 'IdentifierChar';
      e[e.SurrogateChar = 3] = 'SurrogateChar';
    })(o ||= {});
    const l = 256;
    const p = new Array(l);
    const d = {};
    const c = {};
    let u = false;
    function m(e) {
      return e >= 48 && e <= 57 || e === 95;
    }
    function y(e, t) {
      if (d[e] !== o.SurrogateChar) {
        return o.NotIdentifierChar;
      }
      const n = c[e];
      if (n) {
        return n[t];
      } else {
        return o.NotIdentifierChar;
      }
    }
    const g = [[95, 6277, 6278, 8472, 8494, 12443, 12444], i.unicodeLu, i.unicodeLl, i.unicodeLt, i.unicodeLo, i.unicodeLm, i.unicodeNl];
    const h = [i.unicodeLuSurrogate, i.unicodeLlSurrogate, i.unicodeLoSurrogate, i.unicodeLmSurrogate, i.unicodeNlSurrogate];
    const f = [[183, 903, 4969, 4970, 4971, 4972, 4973, 4974, 4975, 4976, 4977, 6618], i.unicodeMn, i.unicodeMc, i.unicodeNd, i.unicodePc];
    const T = [i.unicodeMnSurrogate, i.unicodeMcSurrogate, i.unicodeNdSurrogate];
    function v(e, t, n, a, r) {
      for (let s = 0; s < e.length; s++) {
        const i = e[s];
        let o;
        let p;
        if (Array.isArray(i)) {
          o = i[0];
          p = i[1];
        } else {
          o = p = i;
        }
        for (let e = o; e <= p; e++) {
          if (e < l) {
            a[e] = t;
          } else {
            r[e] = t;
          }
        }
        if (n && o >= l) {
          break;
        }
      }
    }
    function b(e, t) {
      for (const n in e) {
        if (!c[n]) {
          c[n] = {};
          d[n] = o.SurrogateChar;
        }
        v(e[n], t, false, c[n], c[n]);
      }
    }
    function _(e) {
      p.fill(o.NotIdentifierChar);
      f.forEach(t => {
        v(t, o.IdentifierChar, e, p, d);
      });
      g.forEach(t => {
        v(t, o.StartIdentifierChar, e, p, d);
      });
      if (!e) {
        for (const e of T) {
          b(e, o.IdentifierChar);
        }
        for (const e of h) {
          b(e, o.StartIdentifierChar);
        }
      }
    }
    _(true);
  },
  85114: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.DictionaryExpandEntryNode = exports.DictionaryKeyEntryNode = exports.DictionaryNode = exports.StringListNode = exports.FormatStringNode = exports.StringNode = exports.NumberNode = exports.EllipsisNode = exports.ConstantNode = exports.NameNode = exports.LambdaNode = exports.MemberAccessNode = exports.YieldFromNode = exports.YieldNode = exports.SliceNode = exports.IndexNode = exports.ComprehensionNode = exports.CallNode = exports.TupleNode = exports.UnpackNode = exports.TernaryNode = exports.AwaitNode = exports.AugmentedAssignmentNode = exports.FunctionAnnotationNode = exports.TypeAnnotationNode = exports.TypeAliasNode = exports.TypeParameterListNode = exports.TypeParameterNode = exports.TypeParamKind = exports.AssignmentNode = exports.AssignmentExpressionNode = exports.BinaryOperationNode = exports.UnaryOperationNode = exports.ErrorNode = exports.StatementListNode = exports.DecoratorNode = exports.WithItemNode = exports.WithNode = exports.ClassNode = exports.ParameterNode = exports.FunctionNode = exports.ExceptNode = exports.TryNode = exports.ComprehensionIfNode = exports.ComprehensionForNode = exports.ForNode = exports.WhileNode = exports.IfNode = exports.SuiteNode = exports.ModuleNode = undefined;
    exports.PatternValueNode = exports.PatternMappingExpandEntryNode = exports.PatternMappingKeyEntryNode = exports.PatternMappingNode = exports.PatternCaptureNode = exports.PatternClassArgumentNode = exports.PatternClassNode = exports.PatternLiteralNode = exports.PatternAsNode = exports.PatternSequenceNode = exports.CaseNode = exports.MatchNode = exports.RaiseNode = exports.ReturnNode = exports.ContinueNode = exports.BreakNode = exports.AssertNode = exports.NonlocalNode = exports.GlobalNode = exports.ImportFromAsNode = exports.ImportFromNode = exports.ImportAsNode = exports.ModuleNameNode = exports.ImportNode = exports.PassNode = exports.DelNode = exports.ArgumentNode = exports.ListNode = exports.SetNode = undefined;
    exports.getNextNodeId = function () {
      return r++;
    };
    exports.extendRange = s;
    exports.isExpressionNode = function (e) {
      switch (e.nodeType) {
        case 0:
        case 55:
        case 7:
        case 4:
        case 54:
        case 6:
        case 51:
        case 56:
        case 52:
        case 9:
        case 11:
        case 27:
        case 46:
        case 60:
        case 61:
        case 35:
        case 33:
        case 38:
        case 14:
        case 21:
        case 40:
        case 49:
        case 30:
        case 48:
        case 18:
        case 34:
        case 45:
          return true;
        default:
          return false;
      }
    };
    const a = require(88754);
    let r = 1;
    function s(e, t) {
      const n = a.TextRange.extend(e, t);
      e.start = n.start;
      e.length = n.length;
    }
    var i;
    var o;
    var l;
    var p;
    var d;
    var c;
    var u;
    var m;
    var y;
    var g;
    var h;
    var f;
    var T;
    var v;
    var b;
    var _;
    var C;
    var I;
    var k;
    var w;
    var S;
    var A;
    var x;
    var P;
    var D;
    var N;
    var F;
    var E;
    var M;
    var O;
    var z;
    var U;
    var V;
    var R;
    var L;
    var B;
    var j;
    var q;
    var G;
    var W;
    var K;
    var $;
    var H;
    var Z;
    var Y;
    var J;
    var Q;
    var X;
    var ee;
    var te;
    var ne;
    var ae;
    var re;
    var se;
    var ie;
    var oe;
    var le;
    var pe;
    var de;
    var ce;
    var ue;
    var me;
    var ye;
    var ge;
    var he;
    var fe;
    var Te;
    var ve;
    var be;
    var _e;
    var Ce;
    var Ie;
    var ke;
    var we;
    var Se;
    var Ae;
    var xe;
    var Pe;
    var De;
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 36,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            statements: []
          }
        };
      };
    })(i || (exports.ModuleNode = i = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 50,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            statements: [],
            typeComment: undefined
          }
        };
      };
    })(o || (exports.SuiteNode = o = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 22,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            testExpr: t,
            ifSuite: n,
            elseSuite: a
          }
        };
        t.parent = i;
        n.parent = i;
        s(i, t);
        s(i, n);
        if (a) {
          s(i, a);
          a.parent = i;
        }
        return i;
      };
    })(l || (exports.IfNode = l = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 57,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            testExpr: t,
            whileSuite: n
          }
        };
        t.parent = a;
        n.parent = a;
        s(a, n);
        return a;
      };
    })(p || (exports.WhileNode = p = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 29,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            targetExpr: t,
            iterableExpr: n,
            forSuite: a
          }
        };
        t.parent = i;
        n.parent = i;
        a.parent = i;
        s(i, a);
        return i;
      };
    })(d || (exports.ForNode = d = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 12,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            targetExpr: t,
            iterableExpr: n
          }
        };
        t.parent = a;
        n.parent = a;
        s(a, t);
        s(a, n);
        return a;
      };
    })(c || (exports.ComprehensionForNode = c = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 13,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            testExpr: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(u || (exports.ComprehensionIfNode = u = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 53,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            trySuite: t,
            exceptClauses: []
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(m || (exports.TryNode = m = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 28,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            exceptSuite: t,
            isExceptGroup: n
          }
        };
        t.parent = a;
        s(a, t);
        return a;
      };
    })(y || (exports.ExceptNode = y = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 31,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            decorators: [],
            isAsync: false,
            name: t,
            typeParams: a,
            params: [],
            returnAnnotation: undefined,
            funcAnnotationComment: undefined,
            suite: n
          }
        };
        t.parent = i;
        n.parent = i;
        if (a) {
          a.parent = i;
        }
        s(i, n);
        return i;
      };
    })(g || (exports.FunctionNode = g = {}));
    (function (e) {
      e.create = function (e, t) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 41,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            category: t,
            name: undefined,
            annotation: undefined,
            annotationComment: undefined,
            defaultValue: undefined
          }
        };
      };
    })(h || (exports.ParameterNode = h = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 10,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            decorators: [],
            name: t,
            typeParams: a,
            arguments: [],
            suite: n
          }
        };
        t.parent = i;
        n.parent = i;
        if (a) {
          a.parent = i;
        }
        s(i, n);
        return i;
      };
      e.createDummyForDecorators = function (e) {
        const t = {
          start: e[0].start,
          length: 0,
          nodeType: 10,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            decorators: e,
            name: {
              start: e[0].start,
              length: 0,
              nodeType: 38,
              id: 0,
              parent: undefined,
              a: undefined,
              d: {
                token: {
                  type: 7,
                  start: 0,
                  length: 0,
                  comments: [],
                  value: ''
                },
                value: ''
              }
            },
            typeParams: undefined,
            arguments: [],
            suite: {
              start: e[0].start,
              length: 0,
              nodeType: 50,
              id: 0,
              parent: undefined,
              a: undefined,
              d: {
                statements: [],
                typeComment: undefined
              }
            }
          }
        };
        e.forEach(e => {
          e.parent = t;
          s(t, e);
        });
        t.d.name.parent = t;
        t.d.suite.parent = t;
        return t;
      };
    })(f || (exports.ClassNode = f = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 58,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            withItems: [],
            suite: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(T || (exports.WithNode = T = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 59,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: e
          }
        };
        e.parent = t;
        return t;
      };
    })(v || (exports.WithItemNode = v = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 16,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(b || (exports.DecoratorNode = b = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 47,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            statements: []
          }
        };
      };
    })(_ || (exports.StatementListNode = _ = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 0,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            category: t,
            child: n,
            decorators: a
          }
        };
        if (n) {
          n.parent = i;
          s(i, n);
        }
        if (a) {
          a.forEach(e => {
            e.parent = i;
          });
          if (a.length > 0) {
            s(i, a[0]);
          }
        }
        return i;
      };
    })(C || (exports.ErrorNode = C = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 55,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            operator: n,
            operatorToken: e,
            expr: t,
            hasParens: false
          }
        };
        t.parent = a;
        s(a, t);
        return a;
      };
    })(I || (exports.UnaryOperationNode = I = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 7,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            operatorToken: n,
            operator: a,
            rightExpr: t,
            hasParens: false
          }
        };
        e.parent = i;
        t.parent = i;
        s(i, t);
        return i;
      };
    })(k || (exports.BinaryOperationNode = k = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 4,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            name: e,
            walrusToken: t,
            rightExpr: n,
            hasParens: false
          }
        };
        e.parent = a;
        n.parent = a;
        s(a, n);
        return a;
      };
    })(w || (exports.AssignmentExpressionNode = w = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 3,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            rightExpr: t
          }
        };
        e.parent = n;
        t.parent = n;
        s(n, t);
        return n;
      };
    })(S || (exports.AssignmentNode = S = {}));
    (function (e) {
      e[e.TypeVar = 0] = 'TypeVar';
      e[e.TypeVarTuple = 1] = 'TypeVarTuple';
      e[e.ParamSpec = 2] = 'ParamSpec';
    })(A || (exports.TypeParamKind = A = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 75,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            name: e,
            typeParamKind: t,
            boundExpr: n,
            defaultExpr: a
          }
        };
        e.parent = i;
        if (n) {
          n.parent = i;
          s(i, n);
        }
        if (a) {
          a.parent = i;
          s(i, a);
        }
        return i;
      };
    })(x || (exports.TypeParameterNode = x = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 76,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            params: n
          }
        };
        s(a, t);
        n.forEach(e => {
          s(a, e);
          e.parent = a;
        });
        return a;
      };
    })(P || (exports.TypeParameterListNode = P = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 77,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            name: t,
            typeParams: a,
            expr: n
          }
        };
        t.parent = i;
        n.parent = i;
        if (a) {
          a.parent = i;
        }
        s(i, n);
        return i;
      };
    })(D || (exports.TypeAliasNode = D = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 54,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            valueExpr: e,
            annotation: t
          }
        };
        e.parent = n;
        t.parent = n;
        s(n, t);
        return n;
      };
    })(N || (exports.TypeAnnotationNode = N = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 62,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            isEllipsis: t,
            paramAnnotations: n,
            returnAnnotation: a
          }
        };
        n.forEach(e => {
          e.parent = i;
        });
        a.parent = i;
        s(i, a);
        return i;
      };
    })(F || (exports.FunctionAnnotationNode = F = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 5,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            operator: n,
            rightExpr: t,
            destExpr: a
          }
        };
        e.parent = i;
        t.parent = i;
        a.parent = i;
        s(i, t);
        return i;
      };
    })(E || (exports.AugmentedAssignmentNode = E = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 6,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t,
            awaitToken: e,
            hasParens: false
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(M || (exports.AwaitNode = M = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 51,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            ifExpr: e,
            testExpr: t,
            elseExpr: n
          }
        };
        e.parent = a;
        t.parent = a;
        n.parent = a;
        s(a, n);
        return a;
      };
    })(O || (exports.TernaryNode = O = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 56,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t,
            starToken: e
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(z || (exports.UnpackNode = z = {}));
    (function (e) {
      e.create = function (e, t) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 52,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            items: [],
            hasParens: t
          }
        };
      };
    })(U || (exports.TupleNode = U = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 9,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            args: t,
            trailingComma: n
          }
        };
        e.parent = a;
        if (t.length > 0) {
          t.forEach(e => {
            e.parent = a;
          });
          s(a, t[t.length - 1]);
        }
        return a;
      };
    })(V || (exports.CallNode = V = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 11,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: e,
            forIfNodes: [],
            isGenerator: t,
            hasParens: false
          }
        };
        e.parent = n;
        return n;
      };
    })(R || (exports.ComprehensionNode = R = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        const i = {
          start: e.start,
          length: e.length,
          nodeType: 27,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            items: t,
            trailingComma: n
          }
        };
        e.parent = i;
        t.forEach(e => {
          e.parent = i;
        });
        s(i, a);
        return i;
      };
    })(L || (exports.IndexNode = L = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 46,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(B || (exports.SliceNode = B = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 60,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t
          }
        };
        if (t) {
          t.parent = n;
          s(n, t);
        }
        return n;
      };
    })(j || (exports.YieldNode = j = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 61,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(q || (exports.YieldFromNode = q = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 35,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leftExpr: e,
            member: t
          }
        };
        e.parent = n;
        t.parent = n;
        s(n, t);
        return n;
      };
    })(G || (exports.MemberAccessNode = G = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 33,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            params: [],
            expr: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(W || (exports.LambdaNode = W = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 38,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            token: e,
            value: e.value
          }
        };
      };
    })(K || (exports.NameNode = K = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 14,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            constType: e.keywordType
          }
        };
      };
    })($ || (exports.ConstantNode = $ = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 21,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(H || (exports.EllipsisNode = H = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 40,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            value: e.value,
            isInteger: e.isInteger,
            isImaginary: e.isImaginary
          }
        };
      };
    })(Z || (exports.NumberNode = Z = {}));
    (function (e) {
      e.create = function (e, t) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 49,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            token: e,
            value: t
          }
        };
      };
    })(Y || (exports.StringNode = Y = {}));
    (function (e) {
      e.create = function (e, t, n, a, i) {
        const o = {
          start: e.start,
          length: e.length,
          nodeType: 30,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            token: e,
            middleTokens: n,
            fieldExprs: a,
            formatExprs: i,
            value: ''
          }
        };
        a.forEach(e => {
          e.parent = o;
          s(o, e);
        });
        if (i) {
          i.forEach(e => {
            e.parent = o;
            s(o, e);
          });
        }
        if (t) {
          s(o, t);
        }
        return o;
      };
    })(J || (exports.FormatStringNode = J = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e[0].start,
          length: e[0].length,
          nodeType: 48,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            strings: e,
            annotation: undefined,
            hasParens: false
          }
        };
        if (e.length > 0) {
          e.forEach(e => {
            e.parent = t;
          });
          s(t, e[e.length - 1]);
        }
        return t;
      };
    })(Q || (exports.StringListNode = Q = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 18,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            items: [],
            trailingCommaToken: undefined
          }
        };
      };
    })(X || (exports.DictionaryNode = X = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 20,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            keyExpr: e,
            valueExpr: t
          }
        };
        e.parent = n;
        t.parent = n;
        s(n, t);
        return n;
      };
    })(ee || (exports.DictionaryKeyEntryNode = ee = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 19,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: e
          }
        };
        e.parent = t;
        return t;
      };
    })(te || (exports.DictionaryExpandEntryNode = te = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 45,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            items: []
          }
        };
      };
    })(ne || (exports.SetNode = ne = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 34,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            items: []
          }
        };
      };
    })(ae || (exports.ListNode = ae = {}));
    (function (e) {
      e.create = function (e, t, n) {
        const a = {
          start: e ? e.start : t.start,
          length: e ? e.length : t.length,
          nodeType: 1,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            argCategory: n,
            name: undefined,
            valueExpr: t,
            isNameSameAsValue: false
          }
        };
        t.parent = a;
        s(a, t);
        return a;
      };
    })(re || (exports.ArgumentNode = re = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 17,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            targets: []
          }
        };
      };
    })(se || (exports.DelNode = se = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 42,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(ie || (exports.PassNode = ie = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 23,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            list: []
          }
        };
      };
    })(oe || (exports.ImportNode = oe = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 37,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            leadingDots: 0,
            nameParts: []
          }
        };
      };
    })(le || (exports.ModuleNameNode = le = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 24,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            module: e
          }
        };
        e.parent = t;
        return t;
      };
    })(pe || (exports.ImportAsNode = pe = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 25,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            module: t,
            imports: [],
            isWildcardImport: false,
            usesParens: false
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(de || (exports.ImportFromNode = de = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 26,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            name: e
          }
        };
        e.parent = t;
        return t;
      };
    })(ce || (exports.ImportFromAsNode = ce = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 32,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            targets: []
          }
        };
      };
    })(ue || (exports.GlobalNode = ue = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 39,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            targets: []
          }
        };
      };
    })(me || (exports.NonlocalNode = me = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 2,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            testExpr: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(ye || (exports.AssertNode = ye = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 8,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(ge || (exports.BreakNode = ge = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 15,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(he || (exports.ContinueNode = he = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 44,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(fe || (exports.ReturnNode = fe = {}));
    (function (e) {
      e.create = function (e) {
        return {
          start: e.start,
          length: e.length,
          nodeType: 43,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {}
        };
      };
    })(Te || (exports.RaiseNode = Te = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 63,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: t,
            cases: []
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(ve || (exports.MatchNode = ve = {}));
    (function (e) {
      e.create = function (e, t, n, a, i) {
        const o = {
          start: e.start,
          length: e.length,
          nodeType: 64,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            pattern: t,
            isIrrefutable: n,
            guardExpr: a,
            suite: i
          }
        };
        s(o, i);
        t.parent = o;
        i.parent = o;
        if (a) {
          a.parent = o;
        }
        return o;
      };
    })(be || (exports.CaseNode = be = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = t.findIndex(e => e.d.orPatterns.length === 1 && e.d.orPatterns[0].nodeType === 69 && e.d.orPatterns[0].d.isStar);
        const a = {
          start: e.start,
          length: e.length,
          nodeType: 65,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            entries: t,
            starEntryIndex: n >= 0 ? n : undefined
          }
        };
        if (t.length > 0) {
          s(a, t[t.length - 1]);
        }
        t.forEach(e => {
          e.parent = a;
        });
        return a;
      };
    })(_e || (exports.PatternSequenceNode = _e = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e[0].start,
          length: e[0].length,
          nodeType: 66,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            orPatterns: e,
            target: t
          }
        };
        if (e.length > 1) {
          s(n, e[e.length - 1]);
        }
        e.forEach(e => {
          e.parent = n;
        });
        if (t) {
          s(n, t);
          t.parent = n;
        }
        return n;
      };
    })(Ce || (exports.PatternAsNode = Ce = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 67,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: e
          }
        };
        e.parent = t;
        return t;
      };
    })(Ie || (exports.PatternLiteralNode = Ie = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 68,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            className: e,
            args: t
          }
        };
        e.parent = n;
        t.forEach(e => {
          e.parent = n;
        });
        if (t.length > 0) {
          s(n, t[t.length - 1]);
        }
        return n;
      };
    })(ke || (exports.PatternClassNode = ke = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 74,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            pattern: e,
            name: t
          }
        };
        e.parent = n;
        if (t) {
          s(n, t);
          t.parent = n;
        }
        return n;
      };
    })(we || (exports.PatternClassArgumentNode = we = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 69,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            target: e,
            isStar: t !== undefined,
            isWildcard: e.d.value === '_'
          }
        };
        e.parent = n;
        if (t) {
          s(n, t);
        }
        return n;
      };
    })(Se || (exports.PatternCaptureNode = Se = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 70,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            entries: t
          }
        };
        if (t.length > 0) {
          s(n, t[t.length - 1]);
        }
        t.forEach(e => {
          e.parent = n;
        });
        return n;
      };
    })(Ae || (exports.PatternMappingNode = Ae = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 71,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            keyPattern: e,
            valuePattern: t
          }
        };
        e.parent = n;
        t.parent = n;
        s(n, t);
        return n;
      };
    })(xe || (exports.PatternMappingKeyEntryNode = xe = {}));
    (function (e) {
      e.create = function (e, t) {
        const n = {
          start: e.start,
          length: e.length,
          nodeType: 72,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            target: t
          }
        };
        t.parent = n;
        s(n, t);
        return n;
      };
    })(Pe || (exports.PatternMappingExpandEntryNode = Pe = {}));
    (function (e) {
      e.create = function (e) {
        const t = {
          start: e.start,
          length: e.length,
          nodeType: 73,
          id: r++,
          parent: undefined,
          a: undefined,
          d: {
            expr: e
          }
        };
        e.parent = t;
        return t;
      };
    })(De || (exports.PatternValueNode = De = {}));
  },
  96941: function (module, exports, require) {
    var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function () {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function (o, v) {
      o["default"] = v;
    });
    var __importStar = this && this.__importStar || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Parser = exports.ParseOptions = undefined;
    const i = require(53266);
    const o = require(58147);
    const l = require(48281);
    const p = require(11479);
    const d = require(36316);
    const c = require(56814);
    const u = require(63808);
    const m = require(88754);
    const y = require(71582);
    const g = require(67703);
    const h = require(85114);
    const f = __importStar(require(23981));
    const T = require(49969);
    const v = require(92600);
    class b {
      constructor() {
        this.isStubFile = false;
        this.pythonVersion = u.latestStablePythonVersion;
        this.reportInvalidStringEscapeSequence = false;
        this.skipFunctionAndClassBody = false;
        this.ipythonMode = i.IPythonMode.None;
        this.reportErrorsForParsedStringContents = false;
      }
    }
    exports.ParseOptions = b;
    const _ = 256;
    class C {
      constructor() {
        this._tokenIndex = 0;
        this._areErrorsSuppressed = false;
        this._parseOptions = new b();
        this._diagSink = new d.DiagnosticSink();
        this._isInLoop = false;
        this._isInFunction = false;
        this._isInExceptionGroup = false;
        this._isParsingTypeAnnotation = false;
        this._isParsingIndexTrailer = false;
        this._isParsingQuotedText = false;
        this._futureImports = new Set();
        this._importedModules = [];
        this._containsWildcardImport = false;
        this._assignmentExpressionsAllowed = true;
        this._typingImportAliases = [];
        this._typingSymbolAliases = new Map();
        this._maxChildDepthMap = new Map();
      }
      parseSourceFile(e, t, n) {
        y.timingStats.tokenizeFileTime.timeOperation(() => {
          this._startNewParse(e, 0, e.length, t, n);
        });
        const a = h.ModuleNode.create({
          start: 0,
          length: e.length
        });
        y.timingStats.parseFileTime.timeOperation(() => {
          while (!this._atEof()) {
            if (!this._consumeTokenIfType(2)) {
              const e = this._peekToken();
              if (e.type === 3) {
                this._getNextToken();
                const t = e;
                if (t.isIndentAmbiguous) {
                  this._addSyntaxError(g.LocMessage.inconsistentTabs(), t);
                } else {
                  this._addSyntaxError(g.LocMessage.unexpectedIndent(), e);
                }
              }
              const t = this._parseStatement();
              if (t) {
                t.parent = a;
                a.d.statements.push(t);
              } else {
                this._consumeTokensUntilType([2]);
              }
            }
          }
        });
        l.assert(this._tokenizerOutput !== undefined);
        return {
          text: e,
          parserOutput: {
            parseTree: a,
            importedModules: this._importedModules,
            futureImports: this._futureImports,
            containsWildcardImport: this._containsWildcardImport,
            typingSymbolAliases: this._typingSymbolAliases
          },
          tokenizerOutput: this._tokenizerOutput
        };
      }
      parseTextExpression(e, t, n, a, r = 0, s = 0, i) {
        const o = new d.DiagnosticSink();
        let l;
        this._startNewParse(e, t, n, a, o, s);
        if (i) {
          this._typingSymbolAliases = new Map(i);
        }
        if (r === 1) {
          this._isParsingQuotedText = true;
          l = this._parseTypeAnnotation();
        } else {
          if (r === 2) {
            this._isParsingQuotedText = true;
            l = this._parseFunctionTypeAnnotation();
          } else {
            const e = this._parseTestOrStarExpressionList(false, true);
            if (e.parseError) {
              l = e.parseError;
            } else {
              if (e.list.length === 0) {
                this._addSyntaxError(g.LocMessage.expectedExpr(), this._peekToken());
              }
              l = this._makeExpressionOrTuple(e, false);
            }
          }
        }
        if (this._peekTokenType() === 2) {
          this._getNextToken();
        }
        if (!this._atEof()) {
          this._addSyntaxError(g.LocMessage.unexpectedExprToken(), this._peekToken());
        }
        return {
          parseTree: l,
          lines: this._tokenizerOutput.lines,
          diagnostics: o.fetchAndClear()
        };
      }
      _startNewParse(e, t, n, a, r, s = 0) {
        this._fileContents = e;
        this._parseOptions = a;
        this._diagSink = r;
        const i = new T.Tokenizer();
        this._tokenizerOutput = i.tokenize(e, t, n, s, this._parseOptions.ipythonMode);
        this._tokenIndex = 0;
      }
      _parseStatement() {
        if (this._consumeTokenIfType(4)) {
          this._addSyntaxError(g.LocMessage.unexpectedUnindent(), this._peekToken());
        }
        switch (this._peekKeywordType()) {
          case 20:
            return this._parseIfStatement();
          case 36:
            return this._parseWhileStatement();
          case 17:
            return this._parseForStatement();
          case 34:
            return this._parseTryStatement();
          case 37:
            return this._parseWithStatement();
          case 10:
            return this._parseFunctionDef();
          case 7:
            return this._parseClassDef();
          case 3:
            return this._parseAsyncStatement();
          case 25:
            {
              const e = this._peekToken(1);
              let t = false;
              if (e.type === 10 || e.type === 11 || e.type === 12 || e.type === 20 || e.type === 2 || e.type === 1) {
                t = true;
              } else {
                if (e.type === 9) {
                  const n = e;
                  if (n.operatorType !== 26 && n.operatorType !== 0 && n.operatorType !== 5 && n.operatorType !== 33) {
                    t = true;
                  }
                }
              }
              if (!t) {
                const e = this._parseMatchStatement();
                if (e) {
                  return e;
                }
              }
              break;
            }
        }
        if (this._peekOperatorType() === 22) {
          return this._parseDecorated();
        } else {
          return this._parseSimpleStatement();
        }
      }
      _parseAsyncStatement() {
        const e = this._getKeywordToken(3);
        switch (this._peekKeywordType()) {
          case 10:
            return this._parseFunctionDef(e);
          case 37:
            return this._parseWithStatement(e);
          case 17:
            return this._parseForStatement(e);
        }
        this._addSyntaxError(g.LocMessage.unexpectedAsyncToken(), e);
      }
      _parseTypeAliasStatement() {
        const e = this._getKeywordToken(35);
        if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_12)) {
          this._addSyntaxError(g.LocMessage.typeAliasStatementIllegal(), e);
        }
        const t = this._getTokenIfIdentifier();
        l.assert(t !== undefined);
        const n = h.NameNode.create(t);
        let a;
        if (this._peekToken().type === 15) {
          a = this._parseTypeParameterList();
        }
        const r = this._peekToken();
        if (r.type !== 9 || r.operatorType !== 2) {
          this._addSyntaxError(g.LocMessage.expectedEquals(), r);
        } else {
          this._getNextToken();
        }
        const s = this._isParsingTypeAnnotation;
        this._isParsingTypeAnnotation = true;
        const i = this._parseTestExpression(false);
        this._isParsingTypeAnnotation = s;
        return h.TypeAliasNode.create(e, n, i, a);
      }
      _parseTypeParameterList() {
        const e = [];
        const t = this._getNextToken();
        for (l.assert(t.type === 15);;) {
          if (this._peekToken().type === 16) {
            if (e.length === 0) {
              this._addSyntaxError(g.LocMessage.typeParametersMissing(), this._peekToken());
            }
            break;
          }
          const t = this._parseTypeParameter();
          if (!t) {
            break;
          }
          e.push(t);
          if (!this._consumeTokenIfType(12)) {
            break;
          }
        }
        const n = this._peekToken();
        if (n.type !== 16) {
          this._addSyntaxError(g.LocMessage.expectedCloseBracket(), this._peekToken());
          this._consumeTokensUntilType([2, 16, 10]);
        } else {
          this._getNextToken();
        }
        return h.TypeParameterListNode.create(t, n, e);
      }
      _parseTypeParameter() {
        let e = h.TypeParamKind.TypeVar;
        if (this._consumeTokenIfOperator(26)) {
          e = h.TypeParamKind.TypeVarTuple;
        } else {
          if (this._consumeTokenIfOperator(29)) {
            e = h.TypeParamKind.ParamSpec;
          }
        }
        const t = this._getTokenIfIdentifier();
        if (!t) {
          this._addSyntaxError(g.LocMessage.expectedTypeParameterName(), this._peekToken());
          return;
        }
        const n = h.NameNode.create(t);
        let a;
        let r;
        if (this._consumeTokenIfType(10)) {
          a = this._parseExpression(false);
          if (e !== h.TypeParamKind.TypeVar) {
            this._addSyntaxError(g.LocMessage.typeParameterBoundNotAllowed(), a);
          }
        }
        if (this._consumeTokenIfOperator(2)) {
          r = this._parseExpression(e === h.TypeParamKind.TypeVarTuple);
          if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_13)) {
            this._addSyntaxError(g.LocMessage.typeVarDefaultIllegal(), r);
          }
        }
        return h.TypeParameterNode.create(n, e, a, r);
      }
      _parseMatchStatement() {
        let e = false;
        this._suppressErrors(() => {
          const t = this._tokenIndex;
          this._getKeywordToken(25);
          const n = this._parseTestOrStarListAsExpression(true, true, 12, () => g.LocMessage.expectedReturnExpr());
          e = n.nodeType !== 0 && this._peekToken().type === 10;
          this._tokenIndex = t;
        });
        if (!e) {
          return;
        }
        const t = this._getKeywordToken(25);
        const n = this._parseTestOrStarListAsExpression(true, true, 12, () => g.LocMessage.expectedReturnExpr());
        const a = h.MatchNode.create(t, n);
        const r = this._peekToken();
        if (this._consumeTokenIfType(10)) {
          h.extendRange(a, r);
          if (this._consumeTokenIfType(2)) {
            const e = this._peekToken();
            if (this._consumeTokenIfType(3)) {
              const t = e;
              if (t.isIndentAmbiguous) {
                this._addSyntaxError(g.LocMessage.inconsistentTabs(), t);
              }
            } else {
              this._addSyntaxError(g.LocMessage.expectedIndentedBlock(), this._peekToken());
            }
            while (true) {
              const e = this._peekToken();
              if (e.type === 3) {
                this._getNextToken();
                const t = e;
                if (t.isIndentAmbiguous) {
                  this._addSyntaxError(g.LocMessage.inconsistentTabs(), t);
                } else {
                  this._addSyntaxError(g.LocMessage.unexpectedIndent(), e);
                }
              }
              const t = this._parseCaseStatement();
              if (t) {
                t.parent = a;
                a.d.cases.push(t);
              } else {
                if (this._consumeTokensUntilType([2, 10])) {
                  this._getNextToken();
                }
              }
              const n = this._peekToken();
              if (this._consumeTokenIfType(4)) {
                if (!n.matchesIndent) {
                  this._addSyntaxError(g.LocMessage.inconsistentIndent(), n);
                }
                if (n.isDedentAmbiguous) {
                  this._addSyntaxError(g.LocMessage.inconsistentTabs(), n);
                }
                break;
              }
              if (this._peekTokenType() === 1) {
                break;
              }
            }
          } else {
            this._addSyntaxError(g.LocMessage.expectedNewline(), r);
          }
          if (a.d.cases.length > 0) {
            h.extendRange(a, a.d.cases[a.d.cases.length - 1]);
          } else {
            this._addSyntaxError(g.LocMessage.zeroCaseStatementsFound(), t);
          }
        } else {
          this._addSyntaxError(g.LocMessage.expectedColon(), r);
          if (this._consumeTokensUntilType([2, 10])) {
            this._getNextToken();
          }
        }
        if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_10)) {
          this._addSyntaxError(g.LocMessage.matchIncompatible(), t);
        }
        for (let e = 0; e < a.d.cases.length - 1; e++) {
          const t = a.d.cases[e];
          if (!t.d.guardExpr && t.d.isIrrefutable) {
            this._addSyntaxError(g.LocMessage.casePatternIsIrrefutable(), t.d.pattern);
          }
        }
        return a;
      }
      _parseCaseStatement() {
        const e = this._peekToken();
        if (!this._consumeTokenIfKeyword(6)) {
          this._addSyntaxError(g.LocMessage.expectedCase(), e);
          return;
        }
        const t = this._parsePatternSequence();
        let n;
        let a;
        if (t.parseError) {
          n = t.parseError;
        } else {
          if (t.list.length === 0) {
            this._addSyntaxError(g.LocMessage.expectedPatternExpr(), this._peekToken());
            n = h.ErrorNode.create(e, 11);
          } else {
            if (t.list.length !== 1 || t.trailingComma) {
              n = h.PatternSequenceNode.create(t.list[0], t.list);
            } else {
              const e = t.list[0].d.orPatterns[0];
              n = e.nodeType === 69 && e.d.isStar ? h.PatternSequenceNode.create(t.list[0], t.list) : t.list[0];
            }
          }
        }
        if (n.nodeType !== 0) {
          const e = new Map();
          const t = new Map();
          this._reportDuplicatePatternCaptureTargets(n, e, t);
        }
        if (this._consumeTokenIfKeyword(20)) {
          a = this._parseTestExpression(true);
        }
        const r = this._parseSuite(this._isInFunction);
        return h.CaseNode.create(e, n, this._isPatternIrrefutable(n), a, r);
      }
      _isPatternIrrefutable(e) {
        return e.nodeType === 69 || e.nodeType === 66 && e.d.orPatterns.some(e => this._isPatternIrrefutable(e));
      }
      _reportDuplicatePatternCaptureTargets(e, t, n) {
        const a = e => {
          if (t.has(e.d.value) || n.has(e.d.value)) {
            this._addSyntaxError(g.LocMessage.duplicateCapturePatternTarget().format({
              name: e.d.value
            }), e);
          } else {
            n.set(e.d.value, e);
          }
        };
        switch (e.nodeType) {
          case 65:
            e.d.entries.forEach(e => {
              this._reportDuplicatePatternCaptureTargets(e, t, n);
            });
            break;
          case 68:
            e.d.args.forEach(e => {
              this._reportDuplicatePatternCaptureTargets(e.d.pattern, t, n);
            });
            break;
          case 66:
            {
              if (e.d.target) {
                a(e.d.target);
              }
              const t = e.d.orPatterns.map(e => {
                const t = new Map();
                this._reportDuplicatePatternCaptureTargets(e, n, t);
                return t;
              });
              const r = new Map();
              t.forEach(e => {
                e.forEach(e => {
                  if (!r.has(e.d.value)) {
                    r.set(e.d.value, e);
                    a(e);
                  }
                });
              });
              break;
            }
          case 69:
            if (!e.d.isWildcard) {
              a(e.d.target);
            }
            break;
          case 70:
            e.d.entries.forEach(e => {
              if (e.nodeType === 72) {
                a(e.d.target);
              } else {
                this._reportDuplicatePatternCaptureTargets(e.d.keyPattern, t, n);
                this._reportDuplicatePatternCaptureTargets(e.d.valuePattern, t, n);
              }
            });
        }
      }
      _getPatternTargetNames(e, t) {
        switch (e.nodeType) {
          case 65:
            e.d.entries.forEach(e => {
              this._getPatternTargetNames(e, t);
            });
            break;
          case 68:
            e.d.args.forEach(e => {
              this._getPatternTargetNames(e.d.pattern, t);
            });
            break;
          case 66:
            if (e.d.target) {
              t.add(e.d.target.d.value);
            }
            e.d.orPatterns.forEach(e => {
              this._getPatternTargetNames(e, t);
            });
            break;
          case 69:
            if (!e.d.isWildcard) {
              t.add(e.d.target.d.value);
            }
            break;
          case 70:
            e.d.entries.forEach(e => {
              if (e.nodeType === 72) {
                t.add(e.d.target.d.value);
              } else {
                this._getPatternTargetNames(e.d.keyPattern, t);
                this._getPatternTargetNames(e.d.valuePattern, t);
              }
            });
        }
      }
      _parsePatternSequence() {
        const e = this._parseExpressionListGeneric(() => this._parsePatternAs());
        const t = e.list.filter(e => e.d.orPatterns.length === 1 && e.d.orPatterns[0].nodeType === 69 && e.d.orPatterns[0].d.isStar);
        if (t.length > 1) {
          this._addSyntaxError(g.LocMessage.duplicateStarPattern(), t[1].d.orPatterns[0]);
        }
        return e;
      }
      _parsePatternAs() {
        const e = [];
        while (true) {
          const t = this._parsePatternAtom();
          e.push(t);
          if (!this._consumeTokenIfOperator(6)) {
            break;
          }
        }
        let t;
        if (e.length > 1) {
          e.forEach(e => {
            if (e.nodeType === 69 && e.d.isStar) {
              this._addSyntaxError(g.LocMessage.starPatternInOrPattern(), e);
            }
          });
        }
        if (this._consumeTokenIfKeyword(1)) {
          const e = this._getTokenIfIdentifier();
          if (e) {
            t = h.NameNode.create(e);
          } else {
            this._addSyntaxError(g.LocMessage.expectedNameAfterAs(), this._peekToken());
          }
        }
        if (t && e.length === 1 && e[0].nodeType === 69 && e[0].d.isStar) {
          this._addSyntaxError(g.LocMessage.starPatternInAsPattern(), e[0]);
        }
        e.forEach((t, n) => {
          if (n < e.length - 1 && this._isPatternIrrefutable(t)) {
            this._addSyntaxError(g.LocMessage.orPatternIrrefutable(), t);
          }
        });
        const n = new Set();
        e.forEach(e => {
          this._getPatternTargetNames(e, n);
        });
        e.forEach(e => {
          const t = new Set();
          this._getPatternTargetNames(e, t);
          if (t.size < n.size) {
            const a = Array.from(n.keys()).filter(e => !t.has(e));
            const r = new p.DiagnosticAddendum();
            r.addMessage(g.LocAddendum.orPatternMissingName().format({
              name: a.map(e => `"${e}"`).join(', ')
            }));
            this._addSyntaxError(g.LocMessage.orPatternMissingName() + r.getString(), e);
          }
        });
        return h.PatternAsNode.create(e, t);
      }
      _parsePatternAtom() {
        const e = this._parsePatternLiteral();
        if (e) {
          return e;
        }
        const t = this._parsePatternCaptureOrValue();
        if (t) {
          const e = this._peekToken();
          if (t.nodeType === 0 || !this._consumeTokenIfType(13)) {
            return t;
          }
          const n = this._parseClassPatternArgList();
          const a = t.nodeType === 69 ? t.d.target : t.d.expr;
          const r = h.PatternClassNode.create(a, n);
          if (!this._consumeTokenIfType(14)) {
            this._addSyntaxError(g.LocMessage.expectedCloseParen(), e);
            this._consumeTokensUntilType([2]);
            h.extendRange(r, this._peekToken());
          }
          return r;
        }
        const n = this._peekToken();
        if (this._peekOperatorType() === 26) {
          const e = this._getNextToken();
          const t = this._getTokenIfIdentifier();
          if (t) {
            return h.PatternCaptureNode.create(h.NameNode.create(t), e);
          } else {
            this._addSyntaxError(g.LocMessage.expectedIdentifier(), this._peekToken());
            return h.ErrorNode.create(e, 2);
          }
        }
        if (n.type === 13 || n.type === 15) {
          const e = this._getNextToken();
          const t = this._parsePatternSequence();
          let a;
          if (t.parseError) {
            a = t.parseError;
          } else {
            if (t.list.length !== 1 || t.trailingComma || e.type !== 13) {
              a = h.PatternSequenceNode.create(e, t.list);
            } else {
              const r = t.list[0].d.orPatterns[0];
              a = r.nodeType === 69 && r.d.isStar ? h.PatternSequenceNode.create(e, t.list) : t.list[0];
              h.extendRange(a, n);
            }
          }
          const r = this._peekToken();
          if (this._consumeTokenIfType(n.type === 13 ? 14 : 16)) {
            h.extendRange(a, r);
          } else {
            this._addSyntaxError(n.type === 13 ? g.LocMessage.expectedCloseParen() : g.LocMessage.expectedCloseBracket(), n);
            this._consumeTokensUntilType([10, n.type === 13 ? 14 : 16]);
          }
          return a;
        }
        if (n.type === 17) {
          const e = this._getNextToken();
          const t = this._parsePatternMapping(e);
          const a = this._peekToken();
          if (this._consumeTokenIfType(18)) {
            h.extendRange(t, a);
          } else {
            this._addSyntaxError(g.LocMessage.expectedCloseBrace(), n);
            this._consumeTokensUntilType([10, 18]);
          }
          return t;
        }
        return this._handleExpressionParseError(11, g.LocMessage.expectedPatternExpr());
      }
      _parseClassPatternArgList() {
        const e = [];
        let t = false;
        while (true) {
          const n = this._peekTokenType();
          if (n === 14 || n === 2 || n === 1) {
            break;
          }
          const a = this._parseClassPatternArgument();
          if (a.d.name) {
            t = true;
          } else {
            if (t && !a.d.name) {
              this._addSyntaxError(g.LocMessage.positionArgAfterNamedArg(), a);
            }
          }
          e.push(a);
          if (!this._consumeTokenIfType(12)) {
            break;
          }
        }
        return e;
      }
      _parseClassPatternArgument() {
        const e = this._peekToken();
        const t = this._peekToken(1);
        let n;
        if ((e.type === 7 || e.type === 8) && t.type === 9 && t.operatorType === 2) {
          const e = this._getTokenIfIdentifier();
          if (e !== undefined) {
            n = h.NameNode.create(e);
            this._getNextToken();
          }
        }
        const a = this._parsePatternAs();
        return h.PatternClassArgumentNode.create(a, n);
      }
      _parsePatternLiteral() {
        const e = this._peekToken();
        const t = this._peekOperatorType();
        if (e.type === 6 || t === 33) {
          return this._parsePatternLiteralNumber();
        }
        if (e.type === 5) {
          const e = this._parseAtom();
          l.assert(e.nodeType === 48);
          e.d.strings.forEach(e => {
            if (e.nodeType === 30) {
              this._addSyntaxError(g.LocMessage.formatStringInPattern(), e);
            }
          });
          return h.PatternLiteralNode.create(e);
        }
        if (e.type === 8) {
          const t = e;
          if (t.keywordType === 15 || t.keywordType === 33 || t.keywordType === 26) {
            return h.PatternLiteralNode.create(this._parseAtom());
          }
        }
      }
      _parsePatternLiteralNumber() {
        const e = this._parseArithmeticExpression();
        let t;
        let n;
        if (e.nodeType === 7) {
          if (e.d.operator === 33 || e.d.operator === 0) {
            t = e.d.leftExpr;
            n = e.d.rightExpr;
          }
        } else {
          t = e;
        }
        if (t) {
          if (t.nodeType === 55 && t.d.operator === 33) {
            t = t.d.expr;
          }
          if (t.nodeType !== 40 || n !== undefined && t.d.isImaginary) {
            this._addSyntaxError(g.LocMessage.expectedComplexNumberLiteral(), e);
            n = undefined;
          }
        }
        if (n) {
          if (n.nodeType === 55 && n.d.operator === 33) {
            n = n.d.expr;
          }
          if (n.nodeType !== 40 || !n.d.isImaginary) {
            this._addSyntaxError(g.LocMessage.expectedComplexNumberLiteral(), e);
          }
        }
        return h.PatternLiteralNode.create(e);
      }
      _parsePatternMapping(e) {
        const t = this._parseExpressionListGeneric(() => this._parsePatternMappingItem());
        if (t.list.length > 0) {
          const n = t.list.filter(e => e.nodeType === 72);
          if (n.length > 1) {
            this._addSyntaxError(g.LocMessage.duplicateStarStarPattern(), n[1]);
          }
          return h.PatternMappingNode.create(e, t.list);
        }
        return t.parseError || h.ErrorNode.create(this._peekToken(), 11);
      }
      _parsePatternMappingItem() {
        let e;
        const t = this._peekToken();
        if (this._consumeTokenIfOperator(29)) {
          const e = this._getTokenIfIdentifier();
          if (!e) {
            this._addSyntaxError(g.LocMessage.expectedIdentifier(), this._peekToken());
            return h.ErrorNode.create(this._peekToken(), 11);
          }
          const n = h.NameNode.create(e);
          if (e.value === '_') {
            this._addSyntaxError(g.LocMessage.starStarWildcardNotAllowed(), n);
          }
          return h.PatternMappingExpandEntryNode.create(t, n);
        }
        const n = this._parsePatternLiteral();
        if (n) {
          e = n;
        } else {
          const t = this._parsePatternCaptureOrValue();
          if (t) {
            if (t.nodeType === 73) {
              e = t;
            } else {
              this._addSyntaxError(g.LocMessage.expectedPatternValue(), t);
              e = h.ErrorNode.create(this._peekToken(), 11);
            }
          }
        }
        let a;
        if (!e) {
          this._addSyntaxError(g.LocMessage.expectedPatternExpr(), this._peekToken());
          e = h.ErrorNode.create(this._peekToken(), 11);
        }
        if (this._consumeTokenIfType(10)) {
          a = this._parsePatternAs();
        } else {
          this._addSyntaxError(g.LocMessage.expectedColon(), this._peekToken());
          a = h.ErrorNode.create(this._peekToken(), 11);
        }
        return h.PatternMappingKeyEntryNode.create(e, a);
      }
      _parsePatternCaptureOrValue() {
        const e = this._peekToken();
        if (e.type === 7 || e.type === 8) {
          let e;
          while (true) {
            const t = this._getTokenIfIdentifier();
            if (!t) {
              this._addSyntaxError(g.LocMessage.expectedIdentifier(), this._peekToken());
              break;
            }
            {
              const n = h.NameNode.create(t);
              e = e ? h.MemberAccessNode.create(e, n) : n;
            }
            if (!this._consumeTokenIfType(20)) {
              break;
            }
          }
          if (e) {
            if (e.nodeType === 35) {
              return h.PatternValueNode.create(e);
            } else {
              return h.PatternCaptureNode.create(e);
            }
          } else {
            this._addSyntaxError(g.LocMessage.expectedIdentifier(), this._peekToken());
            return h.ErrorNode.create(this._peekToken(), 11);
          }
        }
      }
      _parseIfStatement(e = 20) {
        const t = this._getKeywordToken(e);
        const n = this._parseTestExpression(true);
        const a = this._parseSuite(this._isInFunction);
        const r = h.IfNode.create(t, n, a);
        if (this._consumeTokenIfKeyword(13)) {
          r.d.elseSuite = this._parseSuite(this._isInFunction);
          r.d.elseSuite.parent = r;
          h.extendRange(r, r.d.elseSuite);
        } else {
          if (this._peekKeywordType() === 12) {
            r.d.elseSuite = this._parseIfStatement(12);
            r.d.elseSuite.parent = r;
            h.extendRange(r, r.d.elseSuite);
          }
        }
        return r;
      }
      _parseExceptSuite(e, t) {
        const n = this._isInExceptionGroup;
        if (e) {
          this._isInExceptionGroup = true;
        }
        const a = t();
        this._isInExceptionGroup = n;
        return a;
      }
      _parseLoopSuite() {
        const e = this._isInLoop;
        let t;
        this._isInLoop = true;
        const n = this._parseSuite(this._isInFunction, false, () => {
          const e = this._getTypeAnnotationCommentText();
          if (e) {
            t = e;
          }
        });
        this._isInLoop = e;
        if (t) {
          n.d.typeComment = t;
        }
        return n;
      }
      _parseSuite(e = false, t = false, n) {
        const a = this._peekToken();
        const r = h.SuiteNode.create(a);
        if (!this._consumeTokenIfType(10) && (this._addSyntaxError(g.LocMessage.expectedColon(), a), this._consumeTokensUntilType([2, 10]))) {
          if (this._peekTokenType() === 10) {
            this._getNextToken();
          } else {
            if (this._peekToken(1).type !== 3) {
              this._getNextToken();
              return r;
            }
          }
        }
        if (t) {
          if (this._consumeTokenIfType(2)) {
            let e = 0;
            while (true) {
              const t = this._getNextToken();
              if (t.type === 3) {
                e++;
              }
              if (t.type === 4 && (t.isDedentAmbiguous && this._addSyntaxError(g.LocMessage.inconsistentTabs(), t), e--, e === 0)) {
                break;
              }
              if (t.type === 1) {
                break;
              }
            }
          } else {
            this._parseSimpleStatement();
          }
          if (this._tokenIndex > 0) {
            h.extendRange(r, this._tokenizerOutput.tokens.getItemAt(this._tokenIndex - 1));
          }
          return r;
        }
        if (n) {
          n();
        }
        const s = this._isInFunction;
        this._isInFunction = e;
        if (this._consumeTokenIfType(2)) {
          if (n) {
            n();
          }
          const e = this._peekToken();
          if (!this._consumeTokenIfType(3)) {
            this._addSyntaxError(g.LocMessage.expectedIndentedBlock(), this._peekToken());
            return r;
          }
          const t = e;
          for (t.isIndentAmbiguous && this._addSyntaxError(g.LocMessage.inconsistentTabs(), t);;) {
            const e = this._peekToken();
            if (e.type === 3) {
              this._getNextToken();
              const t = e;
              if (t.isIndentAmbiguous) {
                this._addSyntaxError(g.LocMessage.inconsistentTabs(), t);
              } else {
                this._addSyntaxError(g.LocMessage.unexpectedIndent(), e);
              }
            } else {
              if (e.type === 4) {
                const n = e;
                if (!n.matchesIndent) {
                  this._addSyntaxError(g.LocMessage.inconsistentIndent(), n);
                }
                if (n.isDedentAmbiguous) {
                  this._addSyntaxError(g.LocMessage.inconsistentTabs(), n);
                }
                if (r.d.statements.length > 0) {
                  this._consumeTokenIfType(4);
                } else {
                  h.extendRange(r, n);
                }
                if (!t || n.indentAmount < t.indentAmount) {
                  break;
                }
                if (n.indentAmount === t.indentAmount) {
                  const e = this._peekToken();
                  if (this._consumeTokenIfType(4)) {
                    h.extendRange(r, e);
                    break;
                  }
                }
              }
            }
            const n = this._parseStatement();
            if (n) {
              n.parent = r;
              r.d.statements.push(n);
            } else {
              this._consumeTokensUntilType([2]);
            }
            if (this._peekTokenType() === 1) {
              break;
            }
          }
        } else {
          const e = this._parseSimpleStatement();
          r.d.statements.push(e);
          e.parent = r;
        }
        if (r.d.statements.length > 0) {
          h.extendRange(r, r.d.statements[r.d.statements.length - 1]);
        }
        this._isInFunction = s;
        return r;
      }
      _parseForStatement(e) {
        const t = this._getKeywordToken(17);
        const n = this._parseExpressionListAsPossibleTuple(2, () => g.LocMessage.expectedExpr(), t);
        let a;
        let r;
        let s;
        if (this._consumeTokenIfKeyword(22)) {
          a = this._parseTestOrStarListAsExpression(false, true, 2, () => g.LocMessage.expectedInExpr());
          r = this._parseLoopSuite();
          if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_9) && !this._parseOptions.isStubFile && a.nodeType === 52 && !a.d.hasParens) {
            let e = false;
            a.d.items.forEach(t => {
              if (t.nodeType === 56 && !e) {
                this._addSyntaxError(g.LocMessage.unpackOperatorNotAllowed(), t);
                e = true;
              }
            });
          }
          if (this._consumeTokenIfKeyword(13)) {
            s = this._parseSuite(this._isInFunction);
          }
        } else {
          a = this._handleExpressionParseError(0, g.LocMessage.expectedIn());
          r = h.SuiteNode.create(this._peekToken());
        }
        const i = h.ForNode.create(t, n, a, r);
        i.d.elseSuite = s;
        if (s) {
          h.extendRange(i, s);
          s.parent = i;
        }
        if (e) {
          i.d.isAsync = true;
          i.d.asyncToken = e;
          h.extendRange(i, e);
        }
        if (r.d.typeComment) {
          i.d.typeComment = r.d.typeComment;
        }
        return i;
      }
      _tryParseComprehension(e, t) {
        const n = this._tryParseCompForStatement();
        if (!n) {
          return;
        }
        if (e.nodeType === 56) {
          this._addSyntaxError(g.LocMessage.unpackIllegalInComprehension(), e);
        } else {
          if (e.nodeType === 19) {
            this._addSyntaxError(g.LocMessage.dictExpandIllegalInComprehension(), e);
          }
        }
        const a = h.ComprehensionNode.create(e, t);
        const r = [n];
        while (true) {
          const e = this._tryParseCompForStatement() || this._tryParseCompIfStatement();
          if (!e) {
            break;
          }
          e.parent = a;
          r.push(e);
        }
        a.d.forIfNodes = r;
        if (r.length > 0) {
          r.forEach(e => {
            e.parent = a;
          });
          h.extendRange(a, r[r.length - 1]);
        }
        return a;
      }
      _tryParseCompForStatement() {
        const e = this._peekKeywordType();
        if (e === 3) {
          const e = this._peekToken(1);
          if (e.type !== 8 || e.keywordType !== 17) {
            return;
          }
        } else {
          if (e !== 17) {
            return;
          }
        }
        let t;
        if (this._peekKeywordType() === 3) {
          t = this._getKeywordToken(3);
        }
        const n = this._getKeywordToken(17);
        const a = this._parseExpressionListAsPossibleTuple(2, () => g.LocMessage.expectedExpr(), n);
        let r;
        if (this._consumeTokenIfKeyword(22)) {
          this._disallowAssignmentExpression(() => {
            r = this._parseOrTest();
          });
        } else {
          r = this._handleExpressionParseError(0, g.LocMessage.expectedIn());
        }
        const s = h.ComprehensionForNode.create(t || n, a, r);
        if (t) {
          s.d.isAsync = true;
          s.d.asyncToken = t;
        }
        return s;
      }
      _tryParseCompIfStatement() {
        if (this._peekKeywordType() !== 20) {
          return;
        }
        const e = this._getKeywordToken(20);
        const t = this._tryParseLambdaExpression() || this._parseAssignmentExpression(true);
        return h.ComprehensionIfNode.create(e, t);
      }
      _parseWhileStatement() {
        const e = this._getKeywordToken(36);
        const t = h.WhileNode.create(e, this._parseTestExpression(true), this._parseLoopSuite());
        if (this._consumeTokenIfKeyword(13)) {
          t.d.elseSuite = this._parseSuite(this._isInFunction);
          t.d.elseSuite.parent = t;
          h.extendRange(t, t.d.elseSuite);
        }
        return t;
      }
      _parseTryStatement() {
        const e = this._getKeywordToken(34);
        const t = this._parseSuite(this._isInFunction);
        const n = h.TryNode.create(e, t);
        let a = false;
        let r = false;
        while (true) {
          const e = this._peekToken();
          if (!this._consumeTokenIfKeyword(14)) {
            break;
          }
          const t = this._peekToken();
          let s;
          let i;
          let o = false;
          if (this._consumeTokenIfOperator(26)) {
            if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_11) && !this._parseOptions.isStubFile) {
              this._addSyntaxError(g.LocMessage.exceptionGroupIncompatible(), t);
            }
            o = true;
            if (!r && n.d.exceptClauses.some(e => !e.d.isExceptGroup)) {
              this._addSyntaxError(g.LocMessage.exceptGroupMismatch(), t);
              r = true;
            }
          } else {
            if (!r && n.d.exceptClauses.some(e => e.d.isExceptGroup)) {
              this._addSyntaxError(g.LocMessage.exceptGroupMismatch(), t);
              r = true;
            }
          }
          if (this._peekTokenType() !== 10) {
            s = this._parseTestExpression(true);
            if (this._consumeTokenIfKeyword(1)) {
              i = this._getTokenIfIdentifier();
              if (!i) {
                this._addSyntaxError(g.LocMessage.expectedNameAfterAs(), this._peekToken());
              }
            } else {
              const e = this._peekToken();
              if (this._consumeTokenIfType(12)) {
                this._addSyntaxError(g.LocMessage.expectedAsAfterException(), e);
                this._parseTestExpression(false);
              }
            }
          } else {
            if (o) {
              this._addSyntaxError(g.LocMessage.exceptGroupRequiresType(), this._peekToken());
            }
          }
          if (s) {
            if (a) {
              this._addSyntaxError(g.LocMessage.namedExceptAfterCatchAll(), s);
            }
          } else {
            if (a) {
              this._addSyntaxError(g.LocMessage.duplicateCatchAll(), e);
            }
            a = true;
          }
          const l = this._parseExceptSuite(o, () => this._parseSuite(this._isInFunction));
          const p = h.ExceptNode.create(e, l, o);
          if (s) {
            p.d.typeExpr = s;
            p.d.typeExpr.parent = p;
          }
          if (i) {
            p.d.name = h.NameNode.create(i);
            p.d.name.parent = p;
          }
          n.d.exceptClauses.push(p);
          p.parent = n;
        }
        if (n.d.exceptClauses.length > 0) {
          h.extendRange(n, n.d.exceptClauses[n.d.exceptClauses.length - 1]);
          if (this._consumeTokenIfKeyword(13)) {
            n.d.elseSuite = this._parseSuite(this._isInFunction);
            n.d.elseSuite.parent = n;
            h.extendRange(n, n.d.elseSuite);
          }
        }
        if (this._consumeTokenIfKeyword(16)) {
          n.d.finallySuite = this._parseSuite(this._isInFunction);
          n.d.finallySuite.parent = n;
          h.extendRange(n, n.d.finallySuite);
        }
        if (!n.d.finallySuite && n.d.exceptClauses.length === 0) {
          this._addSyntaxError(g.LocMessage.tryWithoutExcept(), e);
        }
        return n;
      }
      _parseFunctionDef(e, t) {
        const n = this._getKeywordToken(10);
        const a = this._getTokenIfIdentifier();
        if (!a) {
          this._addSyntaxError(g.LocMessage.expectedFunctionName(), n);
          return h.ErrorNode.create(n, 10, undefined, t);
        }
        let r;
        if (this._peekToken().type === 15) {
          r = this._parseTypeParameterList();
          if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_12)) {
            this._addSyntaxError(g.LocMessage.functionTypeParametersIllegal(), r);
          }
        }
        const s = this._peekToken();
        if (!this._consumeTokenIfType(13)) {
          this._addSyntaxError(g.LocMessage.expectedOpenParen(), this._peekToken());
          return h.ErrorNode.create(a, 10, h.NameNode.create(a), t);
        }
        const i = this._parseVarArgsList(14, true);
        let o;
        let l;
        if (!this._consumeTokenIfType(14)) {
          this._addSyntaxError(g.LocMessage.expectedCloseParen(), s);
          this._consumeTokensUntilType([10]);
        }
        if (this._consumeTokenIfType(21)) {
          o = this._parseTypeAnnotation();
        }
        const p = this._isInExceptionGroup;
        this._isInExceptionGroup = false;
        const d = this._parseSuite(true, this._parseOptions.skipFunctionAndClassBody, () => {
          if (!l) {
            l = this._getTypeAnnotationCommentText();
          }
        });
        this._isInExceptionGroup = p;
        const c = h.FunctionNode.create(n, h.NameNode.create(a), d, r);
        if (e) {
          c.d.isAsync = true;
          h.extendRange(c, e);
        }
        c.d.params = i;
        i.forEach(e => {
          e.parent = c;
        });
        if (t) {
          c.d.decorators = t;
          t.forEach(e => {
            e.parent = c;
          });
          if (t.length > 0) {
            h.extendRange(c, t[0]);
          }
        }
        if (o) {
          c.d.returnAnnotation = o;
          c.d.returnAnnotation.parent = c;
          h.extendRange(c, o);
        }
        if (l) {
          this._parseFunctionTypeAnnotationComment(l, c);
        }
        return c;
      }
      _parseVarArgsList(e, t) {
        const n = new Map();
        const a = [];
        let r = false;
        let s = false;
        let i = false;
        let o = false;
        let l = false;
        let p = false;
        let d = false;
        while (this._peekTokenType() !== e) {
          const c = this._parseParameter(t);
          if (!c) {
            this._consumeTokensUntilType([e]);
            break;
          }
          if (c.d.name) {
            const e = c.d.name.d.value;
            if (n.has(e)) {
              this._addSyntaxError(g.LocMessage.duplicateParam().format({
                name: e
              }), c.d.name);
            } else {
              n.set(e, e);
            }
          } else {
            if (c.d.category === 0 && a.length === 0) {
              this._addSyntaxError(g.LocMessage.positionOnlyFirstParam(), c);
            }
          }
          if (c.d.category === 0) {
            if (c.d.name) {
              if (i) {
                l = true;
              }
              if (c.d.defaultValue) {
                r = true;
              } else {
                if (!!r && !i && !p && !s) {
                  this._addSyntaxError(g.LocMessage.nonDefaultAfterDefault(), c);
                  s = true;
                }
              }
            } else {
              if (o) {
                this._addSyntaxError(g.LocMessage.duplicatePositionOnly(), c);
              } else {
                if (i) {
                  this._addSyntaxError(g.LocMessage.positionOnlyAfterKeywordOnly(), c);
                } else {
                  if (p) {
                    this._addSyntaxError(g.LocMessage.positionOnlyAfterArgs(), c);
                  }
                }
              }
              o = true;
            }
          }
          a.push(c);
          if (c.d.category === 1) {
            if (c.d.name) {
              if (i || p) {
                this._addSyntaxError(g.LocMessage.duplicateArgsParam(), c);
              }
              p = true;
            } else {
              if (i) {
                this._addSyntaxError(g.LocMessage.duplicateKeywordOnly(), c);
              } else {
                if (p) {
                  this._addSyntaxError(g.LocMessage.keywordOnlyAfterArgs(), c);
                }
              }
              i = true;
            }
          }
          if (c.d.category === 2) {
            if (d) {
              this._addSyntaxError(g.LocMessage.duplicateKwargsParam(), c);
            }
            d = true;
            if (i && !l) {
              this._addSyntaxError(g.LocMessage.keywordParameterMissing(), c);
            }
          } else {
            if (d) {
              this._addSyntaxError(g.LocMessage.paramAfterKwargsParam(), c);
            }
          }
          const u = this._consumeTokenIfType(12);
          if (t && !c.d.annotation) {
            const e = this._parseVariableTypeAnnotationComment();
            if (e) {
              c.d.annotationComment = e;
              c.d.annotationComment.parent = c;
              h.extendRange(c, c.d.annotationComment);
            }
          }
          if (!u) {
            break;
          }
        }
        if (a.length > 0) {
          const e = a[a.length - 1];
          if (e.d.category === 1 && !e.d.name) {
            this._addSyntaxError(g.LocMessage.expectedNamedParameter(), e);
          }
        }
        return a;
      }
      _parseParameter(e) {
        let t = 0;
        let n = 0;
        const a = this._peekToken();
        if (this._consumeTokenIfOperator(26)) {
          t = 1;
        } else {
          if (this._consumeTokenIfOperator(29)) {
            t = 2;
          } else {
            if (this._consumeTokenIfOperator(10)) {
              if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_8) && !this._parseOptions.isStubFile) {
                this._addSyntaxError(g.LocMessage.positionOnlyIncompatible(), a);
              }
              n = 1;
            }
          }
        }
        const r = this._getTokenIfIdentifier();
        if (!r) {
          if (t === 1) {
            return h.ParameterNode.create(a, 1);
          }
          if (n === 1) {
            return h.ParameterNode.create(a, 0);
          }
          if (this._peekTokenType() === 13) {
            const e = this._getNextToken();
            if (this._consumeTokensUntilType([14])) {
              this._getNextToken();
            }
            this._addSyntaxError(g.LocMessage.sublistParamsIncompatible(), e);
          } else {
            this._addSyntaxError(g.LocMessage.expectedParamName(), this._peekToken());
          }
        }
        let s = 0;
        if (t === 1) {
          s = 1;
        } else {
          if (t === 2) {
            s = 2;
          }
        }
        const i = h.ParameterNode.create(a, s);
        if (r) {
          i.d.name = h.NameNode.create(r);
          i.d.name.parent = i;
          h.extendRange(i, r);
        }
        if (e && this._consumeTokenIfType(10)) {
          i.d.annotation = this._parseTypeAnnotation(s === 1);
          i.d.annotation.parent = i;
          h.extendRange(i, i.d.annotation);
        }
        if (this._consumeTokenIfOperator(2)) {
          i.d.defaultValue = this._parseTestExpression(false);
          i.d.defaultValue.parent = i;
          h.extendRange(i, i.d.defaultValue);
          if (t > 0) {
            this._addSyntaxError(g.LocMessage.defaultValueNotAllowed(), i.d.defaultValue);
          }
        }
        return i;
      }
      _parseWithStatement(e) {
        const t = this._getKeywordToken(37);
        let n = [];
        const a = this._peekToken();
        let r;
        let s = false;
        if (a.type === 13) {
          const e = this._tokenIndex;
          this._suppressErrors(() => {
            for (this._getNextToken(); n.push(this._parseWithItem()), this._consumeTokenIfType(12) && this._peekToken().type !== 14;);
            if (this._peekToken().type === 14 && this._peekToken(1).type === 10) {
              s = n.length !== 1 || n[0].d.target !== undefined;
            }
            this._tokenIndex = e;
            n = [];
          });
        }
        for (s && (this._consumeTokenIfType(13), u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_9) && this._addSyntaxError(g.LocMessage.parenthesizedContextManagerIllegal(), a)); n.push(this._parseWithItem()), this._consumeTokenIfType(12) && this._peekToken().type !== 14;);
        if (s) {
          if (!this._consumeTokenIfType(14)) {
            this._addSyntaxError(g.LocMessage.expectedCloseParen(), a);
          }
        }
        const i = this._parseSuite(this._isInFunction, false, () => {
          const e = this._getTypeAnnotationCommentText();
          if (e) {
            r = e;
          }
        });
        const o = h.WithNode.create(t, i);
        if (e) {
          o.d.isAsync = true;
          o.d.asyncToken = e;
          h.extendRange(o, e);
        }
        if (r) {
          o.d.typeComment = r;
        }
        o.d.withItems = n;
        n.forEach(e => {
          e.parent = o;
        });
        return o;
      }
      _parseWithItem() {
        const e = this._parseTestExpression(true);
        const t = h.WithItemNode.create(e);
        if (this._consumeTokenIfKeyword(1)) {
          t.d.target = this._parseExpression(false);
          t.d.target.parent = t;
          h.extendRange(t, t.d.target);
        }
        return t;
      }
      _parseDecorated() {
        const e = [];
        while (this._peekOperatorType() === 22) {
          e.push(this._parseDecorator());
        }
        const t = this._peekToken();
        if (t.type === 8) {
          if (t.keywordType === 3) {
            this._getNextToken();
            if (this._peekKeywordType() === 10) {
              return this._parseFunctionDef(t, e);
            }
            this._addSyntaxError(g.LocMessage.expectedFunctionAfterAsync(), this._peekToken());
          } else {
            if (t.keywordType === 10) {
              return this._parseFunctionDef(undefined, e);
            }
            if (t.keywordType === 7) {
              return this._parseClassDef(e);
            }
          }
        }
        this._addSyntaxError(g.LocMessage.expectedAfterDecorator(), this._peekToken());
        return h.ClassNode.createDummyForDecorators(e);
      }
      _parseDecorator() {
        const e = this._getNextToken();
        l.assert(e.operatorType === 22);
        const t = this._parseTestExpression(true);
        if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_9)) {
          let e = false;
          if (this._isNameOrMemberAccessExpression(t) || t.nodeType === 9 && this._isNameOrMemberAccessExpression(t.d.leftExpr)) {
            e = true;
          }
          if (!e) {
            this._addSyntaxError(g.LocMessage.expectedDecoratorExpr(), t);
          }
        }
        const n = h.DecoratorNode.create(e, t);
        if (!this._consumeTokenIfType(2)) {
          this._addSyntaxError(g.LocMessage.expectedDecoratorNewline(), this._peekToken());
          this._consumeTokensUntilType([2]);
        }
        return n;
      }
      _isNameOrMemberAccessExpression(e) {
        return e.nodeType === 38 || e.nodeType === 35 && this._isNameOrMemberAccessExpression(e.d.leftExpr);
      }
      _parseClassDef(e) {
        const t = this._getKeywordToken(7);
        let n;
        let a = this._getTokenIfIdentifier();
        if (!a) {
          this._addSyntaxError(g.LocMessage.expectedClassName(), this._peekToken());
          a = v.IdentifierToken.create(0, 0, '', undefined);
        }
        if (this._peekToken().type === 15) {
          n = this._parseTypeParameterList();
          if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_12)) {
            this._addSyntaxError(g.LocMessage.classTypeParametersIllegal(), n);
          }
        }
        let r = [];
        const s = this._peekToken();
        if (this._consumeTokenIfType(13)) {
          r = this._parseArgList().args;
          if (!this._consumeTokenIfType(14)) {
            this._addSyntaxError(g.LocMessage.expectedCloseParen(), s);
          }
        }
        const i = this._parseSuite(false, this._parseOptions.skipFunctionAndClassBody);
        const o = h.ClassNode.create(t, h.NameNode.create(a), i, n);
        o.d.arguments = r;
        r.forEach(e => {
          e.parent = o;
        });
        if (e) {
          o.d.decorators = e;
          if (e.length > 0) {
            e.forEach(e => {
              e.parent = o;
            });
            h.extendRange(o, e[0]);
          }
        }
        return o;
      }
      _parsePassStatement() {
        return h.PassNode.create(this._getKeywordToken(30));
      }
      _parseBreakStatement() {
        const e = this._getKeywordToken(5);
        if (this._isInLoop) {
          if (this._isInExceptionGroup) {
            this._addSyntaxError(g.LocMessage.breakInExceptionGroup(), e);
          }
        } else {
          this._addSyntaxError(g.LocMessage.breakOutsideLoop(), e);
        }
        return h.BreakNode.create(e);
      }
      _parseContinueStatement() {
        const e = this._getKeywordToken(8);
        if (this._isInLoop) {
          if (this._isInExceptionGroup) {
            this._addSyntaxError(g.LocMessage.continueInExceptionGroup(), e);
          }
        } else {
          this._addSyntaxError(g.LocMessage.continueOutsideLoop(), e);
        }
        return h.ContinueNode.create(e);
      }
      _parseReturnStatement() {
        const e = this._getKeywordToken(32);
        const t = h.ReturnNode.create(e);
        if (this._isInFunction) {
          if (this._isInExceptionGroup) {
            this._addSyntaxError(g.LocMessage.returnInExceptionGroup(), e);
          }
        } else {
          this._addSyntaxError(g.LocMessage.returnOutsideFunction(), e);
        }
        if (!this._isNextTokenNeverExpression()) {
          const e = this._parseTestOrStarListAsExpression(true, true, 2, () => g.LocMessage.expectedReturnExpr());
          this._reportConditionalErrorForStarTupleElement(e);
          t.d.expr = e;
          t.d.expr.parent = t;
          h.extendRange(t, e);
        }
        return t;
      }
      _parseFromStatement() {
        const e = this._getKeywordToken(18);
        const t = this._parseDottedModuleName(true);
        const n = h.ImportFromNode.create(e, t);
        const a = t.d.leadingDots === 0 && t.d.nameParts.length === 1 && t.d.nameParts[0].d.value === '__future__';
        const r = this._peekToken();
        if (this._consumeTokenIfKeyword(21)) {
          h.extendRange(n, r);
          const e = this._peekToken();
          if (this._consumeTokenIfOperator(26)) {
            h.extendRange(n, e);
            n.d.isWildcardImport = true;
            n.d.wildcardToken = e;
            this._containsWildcardImport = true;
          } else {
            const e = this._peekToken();
            const t = this._consumeTokenIfType(13);
            let r;
            while (true) {
              const e = this._getTokenIfIdentifier();
              if (!e) {
                break;
              }
              r = undefined;
              const t = h.ImportFromAsNode.create(h.NameNode.create(e));
              if (this._consumeTokenIfKeyword(1)) {
                const e = this._getTokenIfIdentifier();
                if (e) {
                  t.d.alias = h.NameNode.create(e);
                  t.d.alias.parent = t;
                  h.extendRange(t, e);
                } else {
                  this._addSyntaxError(g.LocMessage.expectedImportAlias(), this._peekToken());
                }
              }
              n.d.imports.push(t);
              t.parent = n;
              h.extendRange(n, t);
              if (a) {
                this._futureImports.add(e.value);
              }
              const s = this._peekToken();
              if (!this._consumeTokenIfType(12)) {
                break;
              }
              r = s;
            }
            if (n.d.imports.length === 0) {
              this._addSyntaxError(g.LocMessage.expectedImportSymbols(), this._peekToken());
            }
            if (t) {
              n.d.usesParens = true;
              const t = this._peekToken();
              if (this._consumeTokenIfType(14)) {
                h.extendRange(n, t);
              } else {
                this._addSyntaxError(g.LocMessage.expectedCloseParen(), e);
              }
            } else {
              if (r) {
                this._addSyntaxError(g.LocMessage.trailingCommaInFromImport(), r);
              }
            }
          }
        } else {
          this._addSyntaxError(g.LocMessage.expectedImport(), this._peekToken());
          if (!t.d.hasTrailingDot) {
            n.d.missingImport = true;
          }
        }
        this._importedModules.push({
          nameNode: n.d.module,
          leadingDots: n.d.module.d.leadingDots,
          nameParts: n.d.module.d.nameParts.map(e => e.d.value),
          importedSymbols: new Set(n.d.imports.map(e => e.d.name.d.value))
        });
        let s = false;
        if (n.d.module.d.nameParts.length === 1) {
          const e = n.d.module.d.nameParts[0].d.value;
          if (e === 'typing' || e === 'typing_extensions') {
            s = true;
          }
        }
        if (s) {
          const e = ['Literal', 'TypeAlias', 'Annotated'];
          if (n.d.isWildcardImport) {
            e.forEach(e => {
              this._typingSymbolAliases.set(e, e);
            });
          } else {
            n.d.imports.forEach(t => {
              var n;
              if (e.some(e => e === t.d.name.d.value)) {
                this._typingSymbolAliases.set(((n = t.d.alias) === null || n === undefined ? undefined : n.d.value) || t.d.name.d.value, t.d.name.d.value);
              }
            });
          }
        }
        return n;
      }
      _parseImportStatement() {
        var e;
        const t = this._getKeywordToken(21);
        const n = h.ImportNode.create(t);
        while (true) {
          const t = this._parseDottedModuleName();
          const a = h.ImportAsNode.create(t);
          if (this._consumeTokenIfKeyword(1)) {
            const e = this._getTokenIfIdentifier();
            if (e) {
              a.d.alias = h.NameNode.create(e);
              a.d.alias.parent = a;
              h.extendRange(a, a.d.alias);
            } else {
              this._addSyntaxError(g.LocMessage.expectedImportAlias(), this._peekToken());
            }
          }
          if (a.d.module.d.leadingDots > 0) {
            this._addSyntaxError(g.LocMessage.relativeImportNotAllowed(), a.d.module);
          }
          n.d.list.push(a);
          a.parent = n;
          const r = a.d.module.d.nameParts.map(e => e.d.value);
          if (a.d.alias || a.d.module.d.leadingDots > 0 || a.d.module.d.nameParts.length === 0) {
            this._importedModules.push({
              nameNode: a.d.module,
              leadingDots: a.d.module.d.leadingDots,
              nameParts: r,
              importedSymbols: undefined
            });
          } else {
            a.d.module.d.nameParts.forEach((e, t) => {
              this._importedModules.push({
                nameNode: a.d.module,
                leadingDots: a.d.module.d.leadingDots,
                nameParts: r.slice(0, t + 1),
                importedSymbols: undefined
              });
            });
          }
          if (t.d.nameParts.length === 1) {
            const n = t.d.nameParts[0].d.value;
            if (n === 'typing' || n === 'typing_extensions') {
              this._typingImportAliases.push(((e = a.d.alias) === null || e === undefined ? undefined : e.d.value) || n);
            }
          }
          if (!this._consumeTokenIfType(12)) {
            break;
          }
        }
        if (n.d.list.length > 0) {
          h.extendRange(n, n.d.list[n.d.list.length - 1]);
        }
        return n;
      }
      _parseDottedModuleName(e = false) {
        var t;
        const n = h.ModuleNameNode.create(this._peekToken());
        while (true) {
          const e = (t = this._getTokenIfType(19)) !== null && t !== undefined ? t : this._getTokenIfType(20);
          if (!e) {
            break;
          }
          if (e.type === 19) {
            n.d.leadingDots += 3;
          } else {
            n.d.leadingDots++;
          }
          h.extendRange(n, e);
        }
        while (true) {
          const t = this._getTokenIfIdentifier();
          if (!t) {
            if (!e || n.d.leadingDots === 0 || n.d.nameParts.length > 0) {
              this._addSyntaxError(g.LocMessage.expectedModuleName(), this._peekToken());
              n.d.hasTrailingDot = true;
            }
            break;
          }
          const a = h.NameNode.create(t);
          n.d.nameParts.push(a);
          a.parent = n;
          h.extendRange(n, a);
          const r = this._peekToken();
          if (!this._consumeTokenIfType(20)) {
            break;
          }
          h.extendRange(n, r);
        }
        return n;
      }
      _parseGlobalStatement() {
        const e = this._getKeywordToken(19);
        const t = h.GlobalNode.create(e);
        t.d.targets = this._parseNameList();
        if (t.d.targets.length > 0) {
          t.d.targets.forEach(e => {
            e.parent = t;
          });
          h.extendRange(t, t.d.targets[t.d.targets.length - 1]);
        }
        return t;
      }
      _parseNonlocalStatement() {
        const e = this._getKeywordToken(27);
        const t = h.NonlocalNode.create(e);
        t.d.targets = this._parseNameList();
        if (t.d.targets.length > 0) {
          t.d.targets.forEach(e => {
            e.parent = t;
          });
          h.extendRange(t, t.d.targets[t.d.targets.length - 1]);
        }
        return t;
      }
      _parseNameList() {
        const e = [];
        while (true) {
          const t = this._getTokenIfIdentifier();
          if (!t) {
            this._addSyntaxError(g.LocMessage.expectedIdentifier(), this._peekToken());
            break;
          }
          e.push(h.NameNode.create(t));
          if (!this._consumeTokenIfType(12)) {
            break;
          }
        }
        return e;
      }
      _parseRaiseStatement() {
        const e = this._getKeywordToken(31);
        const t = h.RaiseNode.create(e);
        if (!this._isNextTokenNeverExpression()) {
          t.d.expr = this._parseTestExpression(true);
          t.d.expr.parent = t;
          h.extendRange(t, t.d.expr);
          if (this._consumeTokenIfKeyword(18)) {
            t.d.fromExpr = this._parseTestExpression(true);
            t.d.fromExpr.parent = t;
            h.extendRange(t, t.d.fromExpr);
          }
        }
        return t;
      }
      _parseAssertStatement() {
        const e = this._getKeywordToken(2);
        const t = this._parseTestExpression(false);
        const n = h.AssertNode.create(e, t);
        if (this._consumeTokenIfType(12)) {
          const e = this._parseTestExpression(false);
          n.d.exceptionExpr = e;
          n.d.exceptionExpr.parent = n;
          h.extendRange(n, e);
        }
        return n;
      }
      _parseDelStatement() {
        const e = this._getKeywordToken(11);
        const t = this._parseExpressionList(true);
        if (!t.parseError && t.list.length === 0) {
          this._addSyntaxError(g.LocMessage.expectedDelExpr(), this._peekToken());
        }
        const n = h.DelNode.create(e);
        n.d.targets = t.list;
        if (n.d.targets.length > 0) {
          n.d.targets.forEach(e => {
            e.parent = n;
          });
          h.extendRange(n, n.d.targets[n.d.targets.length - 1]);
        }
        return n;
      }
      _parseYieldExpression() {
        const e = this._getKeywordToken(38);
        const t = this._peekToken();
        if (this._consumeTokenIfKeyword(18)) {
          if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_3)) {
            this._addSyntaxError(g.LocMessage.yieldFromIllegal(), t);
          }
          return h.YieldFromNode.create(e, this._parseTestExpression(false));
        }
        let n;
        if (!this._isNextTokenNeverExpression()) {
          n = this._parseTestOrStarListAsExpression(false, true, 2, () => g.LocMessage.expectedYieldExpr());
          this._reportConditionalErrorForStarTupleElement(n);
        }
        return h.YieldNode.create(e, n);
      }
      _tryParseYieldExpression() {
        if (this._peekKeywordType() === 38) {
          return this._parseYieldExpression();
        }
      }
      _parseSimpleStatement() {
        const e = h.StatementListNode.create(this._peekToken());
        while (true) {
          if (this._peekTokenType() === 0) {
            const e = this._getNextToken();
            const t = this._fileContents.substr(e.start, e.length).charCodeAt(0);
            this._addSyntaxError(g.LocMessage.invalidTokenChars().format({
              text: `\\u${t.toString(16)}`
            }), e);
            this._consumeTokensUntilType([2]);
            break;
          }
          const t = this._parseSmallStatement();
          e.d.statements.push(t);
          t.parent = e;
          h.extendRange(e, t);
          if (t.nodeType === 0) {
            break;
          }
          if (!this._consumeTokenIfType(11)) {
            break;
          }
          const n = this._peekTokenType();
          if (n === 2 || n === 1) {
            break;
          }
        }
        if (!this._consumeTokenIfType(2)) {
          this._addSyntaxError(g.LocMessage.expectedNewlineOrSemicolon(), this._peekToken());
        }
        return e;
      }
      _parseSmallStatement() {
        switch (this._peekKeywordType()) {
          case 30:
            return this._parsePassStatement();
          case 5:
            return this._parseBreakStatement();
          case 8:
            return this._parseContinueStatement();
          case 32:
            return this._parseReturnStatement();
          case 18:
            return this._parseFromStatement();
          case 21:
            return this._parseImportStatement();
          case 19:
            return this._parseGlobalStatement();
          case 27:
            return this._parseNonlocalStatement();
          case 31:
            return this._parseRaiseStatement();
          case 2:
            return this._parseAssertStatement();
          case 11:
            return this._parseDelStatement();
          case 38:
            return this._parseYieldExpression();
          case 35:
            {
              const e = this._peekToken(1);
              const t = this._peekToken(2);
              let n = true;
              if ((e.type === 7 || e.type === 8 && v.KeywordToken.isSoftKeyword(e)) && (t.type === 15 || t.type === 9 && t.operatorType === 2)) {
                n = false;
              }
              if (!n) {
                return this._parseTypeAliasStatement();
              }
              break;
            }
        }
        return this._parseExpressionStatement();
      }
      _makeExpressionOrTuple(e, t) {
        if (e.list.length === 1 && !e.trailingComma) {
          if (e.list[0].nodeType === 56) {
            this._addSyntaxError(g.LocMessage.unpackOperatorNotAllowed(), e.list[0]);
          }
          return e.list[0];
        }
        const n = e.list.length > 0 ? e.list[0] : this._peekToken(-1);
        const a = h.TupleNode.create(n, t);
        a.d.items = e.list;
        if (e.list.length > 0) {
          e.list.forEach(e => {
            e.parent = a;
          });
          h.extendRange(a, e.list[e.list.length - 1]);
        }
        return a;
      }
      _parseExpressionListAsPossibleTuple(e, t, n) {
        if (this._isNextTokenNeverExpression()) {
          this._addSyntaxError(t(), n);
          return h.ErrorNode.create(n, e);
        }
        const a = this._parseExpressionList(true);
        if (a.parseError) {
          return a.parseError;
        } else {
          return this._makeExpressionOrTuple(a, false);
        }
      }
      _parseTestListAsExpression(e, t) {
        if (this._isNextTokenNeverExpression()) {
          return this._handleExpressionParseError(e, t());
        }
        const n = this._parseTestExpressionList();
        if (n.parseError) {
          return n.parseError;
        } else {
          return this._makeExpressionOrTuple(n, false);
        }
      }
      _parseTestOrStarListAsExpression(e, t, n, a) {
        if (this._isNextTokenNeverExpression()) {
          return this._handleExpressionParseError(n, a());
        }
        const r = this._parseTestOrStarExpressionList(e, t);
        if (r.parseError) {
          return r.parseError;
        } else {
          return this._makeExpressionOrTuple(r, false);
        }
      }
      _parseExpressionList(e) {
        return this._parseExpressionListGeneric(() => this._parseExpression(e));
      }
      _parseTestExpressionList() {
        return this._parseExpressionListGeneric(() => this._parseTestExpression(false));
      }
      _parseTestOrStarExpressionList(e, t) {
        const n = this._parseExpressionListGeneric(() => this._parseTestOrStarExpression(e));
        if (!t && !n.parseError) {
          let e = false;
          for (const t of n.list) {
            if (t.nodeType === 56) {
              if (e) {
                this._addSyntaxError(g.LocMessage.duplicateUnpack(), t);
                break;
              }
              e = true;
            }
          }
        }
        return n;
      }
      _parseExpression(e) {
        const t = this._peekToken();
        if (e && this._consumeTokenIfOperator(26)) {
          return h.UnpackNode.create(t, this._parseExpression(false));
        } else {
          return this._parseBitwiseOrExpression();
        }
      }
      _parseTestOrStarExpression(e) {
        if (this._peekOperatorType() === 26) {
          return this._parseExpression(true);
        } else {
          return this._parseTestExpression(e);
        }
      }
      _parseTestExpression(e) {
        if (this._peekKeywordType() === 24) {
          return this._parseLambdaExpression();
        }
        const t = this._parseAssignmentExpression(!e);
        if (t.nodeType === 0) {
          return t;
        }
        if (!this._consumeTokenIfKeyword(20)) {
          return t;
        }
        const n = this._parseOrTest();
        if (n.nodeType === 0) {
          return n;
        }
        if (!this._consumeTokenIfKeyword(13)) {
          return h.TernaryNode.create(t, n, this._handleExpressionParseError(1, g.LocMessage.expectedElse()));
        }
        const a = this._parseTestExpression(true);
        return h.TernaryNode.create(t, n, a);
      }
      _parseAssignmentExpression(e = false) {
        const t = this._parseOrTest();
        if (t.nodeType === 0) {
          return t;
        }
        if (t.nodeType !== 38) {
          return t;
        }
        const n = this._peekToken();
        if (!this._consumeTokenIfOperator(35)) {
          return t;
        }
        if (!this._assignmentExpressionsAllowed || !!e) {
          this._addSyntaxError(g.LocMessage.walrusNotAllowed(), n);
        }
        if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_8)) {
          this._addSyntaxError(g.LocMessage.walrusIllegal(), n);
        }
        const a = this._parseTestExpression(false);
        return h.AssignmentExpressionNode.create(t, n, a);
      }
      _parseOrTest() {
        let e = this._parseAndTest();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          const t = this._peekToken();
          if (!this._consumeTokenIfKeyword(29)) {
            break;
          }
          const n = this._parseAndTest();
          e = this._createBinaryOperationNode(e, n, t, 37);
        }
        return e;
      }
      _parseAndTest() {
        let e = this._parseNotTest();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          const t = this._peekToken();
          if (!this._consumeTokenIfKeyword(0)) {
            break;
          }
          const n = this._parseNotTest();
          e = this._createBinaryOperationNode(e, n, t, 36);
        }
        return e;
      }
      _parseNotTest() {
        const e = this._peekToken();
        if (this._consumeTokenIfKeyword(28)) {
          const t = this._parseNotTest();
          return this._createUnaryOperationNode(e, t, 38);
        }
        return this._parseComparison();
      }
      _parseComparison() {
        let e = this._parseBitwiseOrExpression();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          let t;
          const n = this._peekToken();
          if (T.Tokenizer.isOperatorComparison(this._peekOperatorType())) {
            t = this._peekOperatorType();
            if (t === 19) {
              this._addSyntaxError(g.LocMessage.operatorLessOrGreaterDeprecated(), n);
              t = 28;
            }
            this._getNextToken();
          } else {
            if (this._consumeTokenIfKeyword(22)) {
              t = 41;
            } else {
              if (this._consumeTokenIfKeyword(23)) {
                t = this._consumeTokenIfKeyword(28) ? 40 : 39;
              } else {
                if (this._peekKeywordType() === 28) {
                  const e = this._peekToken(1);
                  if (e.type === 8 && e.keywordType === 22) {
                    this._getNextToken();
                    this._getNextToken();
                    t = 42;
                  }
                }
              }
            }
          }
          if (t === undefined) {
            break;
          }
          const a = this._parseComparison();
          e = this._createBinaryOperationNode(e, a, n, t);
        }
        return e;
      }
      _parseBitwiseOrExpression() {
        let e = this._parseBitwiseXorExpression();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          const t = this._peekToken();
          if (!this._consumeTokenIfOperator(6)) {
            break;
          }
          const n = this._parseBitwiseXorExpression();
          e = this._createBinaryOperationNode(e, n, t, 6);
        }
        return e;
      }
      _parseBitwiseXorExpression() {
        let e = this._parseBitwiseAndExpression();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          const t = this._peekToken();
          if (!this._consumeTokenIfOperator(8)) {
            break;
          }
          const n = this._parseBitwiseAndExpression();
          e = this._createBinaryOperationNode(e, n, t, 8);
        }
        return e;
      }
      _parseBitwiseAndExpression() {
        let e = this._parseShiftExpression();
        if (e.nodeType === 0) {
          return e;
        }
        while (true) {
          const t = this._peekToken();
          if (!this._consumeTokenIfOperator(3)) {
            break;
          }
          const n = this._parseShiftExpression();
          e = this._createBinaryOperationNode(e, n, t, 3);
        }
        return e;
      }
      _parseShiftExpression() {
        let e = this._parseArithmeticExpression();
        if (e.nodeType === 0) {
          return e;
        }
        let t = this._peekToken();
        let n = this._peekOperatorType();
        while (n === 17 || n === 31) {
          this._getNextToken();
          const a = this._parseArithmeticExpression();
          e = this._createBinaryOperationNode(e, a, t, n);
          t = this._peekToken();
          n = this._peekOperatorType();
        }
        return e;
      }
      _parseArithmeticExpression() {
        let e = this._parseArithmeticTerm();
        if (e.nodeType === 0) {
          return e;
        }
        let t = this._peekToken();
        let n = this._peekOperatorType();
        while (n === 0 || n === 33) {
          this._getNextToken();
          const a = this._parseArithmeticTerm();
          if (a.nodeType === 0) {
            return a;
          }
          e = this._createBinaryOperationNode(e, a, t, n);
          t = this._peekToken();
          n = this._peekOperatorType();
        }
        return e;
      }
      _parseArithmeticTerm() {
        let e = this._parseArithmeticFactor();
        if (e.nodeType === 0) {
          return e;
        }
        let t = this._peekToken();
        let n = this._peekOperatorType();
        while (n === 26 || n === 22 || n === 10 || n === 24 || n === 13) {
          this._getNextToken();
          const a = this._parseArithmeticFactor();
          e = this._createBinaryOperationNode(e, a, t, n);
          t = this._peekToken();
          n = this._peekOperatorType();
        }
        return e;
      }
      _parseArithmeticFactor() {
        const e = this._peekToken();
        const t = this._peekOperatorType();
        if (t === 0 || t === 33 || t === 5) {
          this._getNextToken();
          const n = this._parseArithmeticFactor();
          return this._createUnaryOperationNode(e, n, t);
        }
        const n = this._parseAtomExpression();
        if (n.nodeType === 0) {
          return n;
        }
        const a = this._peekToken();
        if (this._consumeTokenIfOperator(29)) {
          const e = this._parseArithmeticFactor();
          return this._createBinaryOperationNode(n, e, a, 29);
        }
        return n;
      }
      _isTypingAnnotation(e, t) {
        if (e.nodeType === 38) {
          if (this._typingSymbolAliases.get(e.d.value) === t) {
            return true;
          }
        } else {
          if (e.nodeType === 35 && e.d.leftExpr.nodeType === 38 && e.d.member.d.value === t) {
            const t = e.d.leftExpr.d.value;
            return this._typingImportAliases.some(e => e === t);
          }
        }
        return false;
      }
      _parseAtomExpression() {
        var e;
        var t;
        var n;
        let a;
        if (this._peekKeywordType() === 4) {
          a = this._getKeywordToken(4);
          if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_5)) {
            this._addSyntaxError(g.LocMessage.awaitIllegal(), a);
          }
        }
        let r = this._parseAtom();
        if (r.nodeType === 0) {
          return r;
        }
        while (true) {
          const a = this._peekToken();
          if (this._consumeTokenIfType(13)) {
            const t = this._isParsingTypeAnnotation;
            this._isParsingTypeAnnotation = false;
            const n = this._parseArgList();
            const s = h.CallNode.create(r, n.args, n.trailingComma);
            if (n.args.length > 1 || n.trailingComma) {
              n.args.forEach(e => {
                if (e.d.valueExpr.nodeType === 11) {
                  if (!e.d.valueExpr.d.hasParens) {
                    this._addSyntaxError(g.LocMessage.generatorNotParenthesized(), e.d.valueExpr);
                  }
                }
              });
            }
            const i = this._peekToken();
            let o = false;
            if (this._consumeTokenIfType(14)) {
              h.extendRange(s, i);
              o = true;
            } else {
              this._addSyntaxError(g.LocMessage.expectedCloseParen(), a);
              this._consumeTokensUntilType([2]);
              h.extendRange(s, this._peekToken());
            }
            this._isParsingTypeAnnotation = t;
            const l = (e = this._maxChildDepthMap.get(r.id)) !== null && e !== undefined ? e : 0;
            if (l >= _) {
              r = h.ErrorNode.create(s, 15);
              this._addSyntaxError(g.LocMessage.maxParseDepthExceeded(), r);
            } else {
              r = s;
              this._maxChildDepthMap.set(s.id, l + 1);
            }
            if (!o) {
              break;
            }
          } else {
            if (this._consumeTokenIfType(15)) {
              const e = this._isParsingIndexTrailer;
              const n = this._isParsingTypeAnnotation;
              if (this._isTypingAnnotation(r, 'Literal') || this._isTypingAnnotation(r, 'Annotated')) {
                this._isParsingTypeAnnotation = false;
              }
              this._isParsingIndexTrailer = true;
              const s = this._parseSubscriptList();
              this._isParsingTypeAnnotation = n;
              this._isParsingIndexTrailer = e;
              const i = this._peekToken();
              const o = h.IndexNode.create(r, s.list, s.trailingComma, i);
              h.extendRange(o, o);
              if (!this._consumeTokenIfType(16)) {
                this._handleExpressionParseError(6, g.LocMessage.expectedCloseBracket(), a, o);
              }
              const l = (t = this._maxChildDepthMap.get(r.id)) !== null && t !== undefined ? t : 0;
              if (l >= _) {
                r = h.ErrorNode.create(o, 15);
                this._addSyntaxError(g.LocMessage.maxParseDepthExceeded(), r);
              } else {
                r = o;
                this._maxChildDepthMap.set(o.id, l + 1);
              }
            } else {
              if (!this._consumeTokenIfType(20)) {
                break;
              }
              {
                const e = this._getTokenIfIdentifier();
                if (!e) {
                  return this._handleExpressionParseError(7, g.LocMessage.expectedMemberName(), a, r, [8]);
                }
                const t = h.MemberAccessNode.create(r, h.NameNode.create(e));
                const s = (n = this._maxChildDepthMap.get(r.id)) !== null && n !== undefined ? n : 0;
                if (s >= _) {
                  r = h.ErrorNode.create(t, 15);
                  this._addSyntaxError(g.LocMessage.maxParseDepthExceeded(), r);
                } else {
                  r = t;
                  this._maxChildDepthMap.set(t.id, s + 1);
                }
              }
            }
          }
        }
        if (a) {
          return h.AwaitNode.create(a, r);
        } else {
          return r;
        }
      }
      _parseSubscriptList() {
        const e = [];
        let t = false;
        let n = false;
        while (true) {
          const a = this._peekToken();
          if (a.type !== 10 && this._isNextTokenNeverExpression()) {
            break;
          }
          let r = 0;
          if (this._consumeTokenIfOperator(26)) {
            r = 1;
          } else {
            if (this._consumeTokenIfOperator(29)) {
              r = 2;
            }
          }
          const s = this._tokenIndex;
          let i;
          let o = this._parsePossibleSlice();
          if (r === 0) {
            if (this._consumeTokenIfOperator(2)) {
              const e = o;
              o = this._parsePossibleSlice();
              if (e.nodeType === 38) {
                i = e.d.token;
              } else {
                this._addSyntaxError(g.LocMessage.expectedParamName(), e);
              }
            } else {
              if (o.nodeType === 38 && this._peekOperatorType() === 35) {
                this._tokenIndex = s;
                o = this._parseTestExpression(true);
                if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_10)) {
                  this._addSyntaxError(g.LocMessage.assignmentExprInSubscript(), o);
                }
              }
            }
          }
          const l = h.ArgumentNode.create(a, o, r);
          if (i) {
            l.d.name = h.NameNode.create(i);
            l.d.name.parent = l;
          }
          if (l.d.name) {
            t = true;
          } else {
            if (t && l.d.argCategory === 0) {
              this._addSyntaxError(g.LocMessage.positionArgAfterNamedArg(), l);
            }
          }
          e.push(l);
          if (l.d.name) {
            this._addSyntaxError(g.LocMessage.keywordSubscriptIllegal(), l.d.name);
          }
          if (r !== 0) {
            const e = this._parseOptions.isStubFile || this._isParsingQuotedText || u.PythonVersion.isGreaterOrEqualTo(this._getLanguageVersion(), u.pythonVersion3_11);
            if (r === 1 && !e) {
              this._addSyntaxError(g.LocMessage.unpackedSubscriptIllegal(), l);
            }
            if (r === 2) {
              this._addSyntaxError(g.LocMessage.unpackedDictSubscriptIllegal(), l);
            }
          }
          if (!this._consumeTokenIfType(12)) {
            n = false;
            break;
          }
          n = true;
        }
        if (e.length === 0) {
          const t = this._handleExpressionParseError(3, g.LocMessage.expectedSliceIndex(), undefined, undefined, [16]);
          e.push(h.ArgumentNode.create(this._peekToken(), t, 0));
        }
        return {
          list: e,
          trailingComma: n
        };
      }
      _parsePossibleSlice() {
        const e = this._peekToken();
        const t = [undefined, undefined, undefined];
        let n = 0;
        let a = false;
        while (true) {
          const e = this._peekTokenType();
          if (e === 16 || e === 12) {
            break;
          }
          if (e !== 10) {
            const e = this._parseOptions.isStubFile || u.PythonVersion.isGreaterOrEqualTo(this._getLanguageVersion(), u.pythonVersion3_10);
            t[n] = this._parseTestExpression(e);
          }
          n++;
          if (n >= 3 || !this._consumeTokenIfType(10)) {
            break;
          }
          a = true;
        }
        if (!a) {
          if (t[0]) {
            return t[0];
          } else {
            return h.ErrorNode.create(this._peekToken(), 3);
          }
        }
        const r = h.SliceNode.create(e);
        r.d.startValue = t[0];
        if (r.d.startValue) {
          r.d.startValue.parent = r;
        }
        r.d.endValue = t[1];
        if (r.d.endValue) {
          r.d.endValue.parent = r;
        }
        r.d.stepValue = t[2];
        if (r.d.stepValue) {
          r.d.stepValue.parent = r;
        }
        const s = t[2] || t[1] || t[0];
        if (s) {
          h.extendRange(r, s);
        }
        return r;
      }
      _parseArgList() {
        const e = [];
        let t = false;
        let n = false;
        while (true) {
          const a = this._peekTokenType();
          if (a === 14 || a === 2 || a === 1) {
            break;
          }
          n = false;
          const r = this._parseArgument();
          if (r.d.name) {
            t = true;
          } else {
            if (t && r.d.argCategory === 0) {
              this._addSyntaxError(g.LocMessage.positionArgAfterNamedArg(), r);
            }
          }
          e.push(r);
          if (!this._consumeTokenIfType(12)) {
            break;
          }
          n = true;
        }
        return {
          args: e,
          trailingComma: n
        };
      }
      _parseArgument() {
        const e = this._peekToken();
        let t = 0;
        if (this._consumeTokenIfOperator(26)) {
          t = 1;
        } else {
          if (this._consumeTokenIfOperator(29)) {
            t = 2;
          }
        }
        let n;
        let a;
        let r = this._parseTestExpression(true);
        let s = false;
        if (t === 0) {
          const e = this._peekToken();
          if (this._consumeTokenIfOperator(2)) {
            a = e;
            const t = r;
            if (t.nodeType !== 38 || this._peekTokenType() !== 12 && this._peekTokenType() !== 14) {
              r = this._parseTestExpression(false);
              if (t.nodeType === 38) {
                n = h.NameNode.create(t.d.token);
              } else {
                this._addSyntaxError(g.LocMessage.expectedParamName(), t);
              }
            } else {
              n = h.NameNode.create(t.d.token);
              if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_14)) {
                this._addSyntaxError(g.LocMessage.keywordArgShortcutIllegal(), a);
                r = h.ErrorNode.create(a, 14);
              } else {
                r = h.NameNode.create(t.d.token);
                s = true;
              }
            }
          } else {
            const e = this._tryParseComprehension(r, true);
            if (e) {
              r = e;
            }
          }
        }
        const i = h.ArgumentNode.create(e, r, t);
        if (n) {
          i.d.name = n;
          i.d.isNameSameAsValue = s;
          i.d.name.parent = i;
          if (a) {
            h.extendRange(i, a);
          }
        }
        return i;
      }
      _parseAtom() {
        const e = this._peekToken();
        if (e.type === 19) {
          return h.EllipsisNode.create(this._getNextToken());
        }
        if (e.type === 6) {
          return h.NumberNode.create(this._getNextToken());
        }
        if (e.type === 7) {
          return h.NameNode.create(this._getNextToken());
        }
        if (e.type === 5 || e.type === 24) {
          return this._parseStringList();
        }
        if (e.type === 22) {
          this._getNextToken();
          this._addSyntaxError(g.LocMessage.backticksIllegal(), e);
          const t = this._parseTestListAsExpression(2, () => g.LocMessage.expectedExpr());
          this._consumeTokenIfType(22);
          return t;
        }
        if (e.type === 13) {
          const e = this._parseTupleAtom();
          if (e.nodeType === 55 || e.nodeType === 6 || e.nodeType === 7) {
            e.d.hasParens = true;
          }
          if (e.nodeType === 48 || e.nodeType === 11 || e.nodeType === 4) {
            e.d.hasParens = true;
          }
          return e;
        }
        if (e.type === 15) {
          return this._parseListAtom();
        }
        if (e.type === 17) {
          return this._parseDictionaryOrSetAtom();
        }
        if (e.type === 8) {
          const t = e;
          if (t.keywordType === 15 || t.keywordType === 33 || t.keywordType === 9 || t.keywordType === 26) {
            return h.ConstantNode.create(this._getNextToken());
          }
          const n = this._getTokenIfIdentifier();
          if (n) {
            return h.NameNode.create(n);
          }
        }
        return this._handleExpressionParseError(2, g.LocMessage.expectedExpr());
      }
      _handleExpressionParseError(e, t, n, a, r) {
        var s;
        this._addSyntaxError(t, n ?? this._peekToken());
        const i = [2];
        if (r) {
          o.appendArray(i, r);
        }
        const l = this._peekToken();
        const p = i.some(e => l.type === e) ? (s = n ?? a) !== null && s !== undefined ? s : m.TextRange.create(l.start, 0) : l;
        const d = h.ErrorNode.create(p, e, a);
        this._consumeTokensUntilType(i);
        return d;
      }
      _parseLambdaExpression(e = true) {
        const t = this._getKeywordToken(24);
        const n = this._parseVarArgsList(10, false);
        let a;
        if (!this._consumeTokenIfType(10)) {
          this._addSyntaxError(g.LocMessage.expectedColon(), this._peekToken());
        }
        a = e ? this._parseTestExpression(false) : this._tryParseLambdaExpression(false) || this._parseOrTest();
        const r = h.LambdaNode.create(t, a);
        r.d.params = n;
        n.forEach(e => {
          e.parent = r;
        });
        return r;
      }
      _tryParseLambdaExpression(e = true) {
        if (this._peekKeywordType() === 24) {
          return this._parseLambdaExpression(e);
        }
      }
      _parseTupleAtom() {
        var e;
        const t = this._getNextToken();
        l.assert(t.type === 13);
        const n = this._tryParseYieldExpression();
        if (n) {
          if (this._peekTokenType() !== 14) {
            return this._handleExpressionParseError(8, g.LocMessage.expectedCloseParen(), t, n);
          } else {
            h.extendRange(n, this._getNextToken());
            return n;
          }
        }
        const a = this._parseTestListWithComprehension(true);
        const r = this._makeExpressionOrTuple(a, true);
        h.extendRange(r, t);
        if (this._peekTokenType() !== 14) {
          return this._handleExpressionParseError(8, g.LocMessage.expectedCloseParen(), t, (e = a.parseError) !== null && e !== undefined ? e : r);
        } else {
          h.extendRange(r, this._getNextToken());
          return r;
        }
      }
      _parseListAtom() {
        var e;
        const t = this._getNextToken();
        l.assert(t.type === 15);
        const n = this._parseTestListWithComprehension(false);
        const a = this._peekToken();
        if (this._consumeTokenIfType(16)) {
          return r();
        } else {
          return this._handleExpressionParseError(9, g.LocMessage.expectedCloseBracket(), t, (e = n.parseError) !== null && e !== undefined ? e : r());
        }
        function r() {
          const e = h.ListNode.create(t);
          if (a) {
            h.extendRange(e, a);
          }
          if (n.list.length > 0) {
            n.list.forEach(t => {
              t.parent = e;
            });
            h.extendRange(e, n.list[n.list.length - 1]);
          }
          e.d.items = n.list;
          return e;
        }
      }
      _parseTestListWithComprehension(e) {
        let t = false;
        return this._parseExpressionListGeneric(() => {
          let n = this._parseTestOrStarExpression(true);
          const a = this._tryParseComprehension(n, e);
          if (a) {
            n = a;
            t = true;
          }
          return n;
        }, () => this._isNextTokenNeverExpression(), () => t);
      }
      _parseDictionaryOrSetAtom() {
        const e = this._getNextToken();
        l.assert(e.type === 17);
        const t = [];
        const n = [];
        let a;
        let r = false;
        let s = false;
        let i = false;
        let o = true;
        while (this._peekTokenType() !== 18) {
          let e;
          let p;
          let d;
          a = undefined;
          const c = this._peekToken();
          if (this._consumeTokenIfOperator(29)) {
            e = this._parseExpression(false);
          } else {
            p = this._parseTestOrStarExpression(true);
            let e = u.PythonVersion.isGreaterOrEqualTo(this._getLanguageVersion(), u.pythonVersion3_10);
            if (this._consumeTokenIfType(10)) {
              d = this._parseTestExpression(false);
              e = false;
            }
            if (!e && p.nodeType === 4 && !p.d.hasParens) {
              this._addSyntaxError(g.LocMessage.walrusNotAllowed(), p.d.walrusToken);
            }
          }
          if (p && d) {
            if (p.nodeType === 56) {
              this._addSyntaxError(g.LocMessage.unpackInDict(), p);
            }
            if (s) {
              this._addSyntaxError(g.LocMessage.keyValueInSet(), d);
            } else {
              const e = h.DictionaryKeyEntryNode.create(p, d);
              let n = e;
              const a = this._tryParseComprehension(e, false);
              if (a) {
                n = a;
                i = true;
                if (!o) {
                  this._addSyntaxError(g.LocMessage.comprehensionInDict(), n);
                }
              }
              t.push(n);
              r = true;
            }
          } else {
            if (e) {
              if (s) {
                this._addSyntaxError(g.LocMessage.unpackInSet(), e);
              } else {
                const n = h.DictionaryExpandEntryNode.create(e);
                h.extendRange(n, c);
                let a = n;
                const s = this._tryParseComprehension(n, false);
                if (s) {
                  a = s;
                  i = true;
                  if (!o) {
                    this._addSyntaxError(g.LocMessage.comprehensionInDict(), e);
                  }
                }
                t.push(a);
                r = true;
              }
            } else {
              l.assert(p !== undefined);
              if (p) {
                if (r) {
                  const e = h.ErrorNode.create(this._peekToken(), 13);
                  const n = h.DictionaryKeyEntryNode.create(p, e);
                  t.push(n);
                  this._addSyntaxError(g.LocMessage.dictKeyValuePairs(), p);
                } else {
                  const e = this._tryParseComprehension(p, false);
                  if (e) {
                    p = e;
                    i = true;
                    if (!o) {
                      this._addSyntaxError(g.LocMessage.comprehensionInSet(), p);
                    }
                  }
                  n.push(p);
                  s = true;
                }
              }
            }
          }
          if (i) {
            break;
          }
          if (this._peekTokenType() !== 12) {
            break;
          }
          a = this._getNextToken();
          o = false;
        }
        let p = this._peekToken();
        if (!this._consumeTokenIfType(18)) {
          this._addSyntaxError(g.LocMessage.expectedCloseBrace(), e);
          p = undefined;
        }
        if (s) {
          const t = h.SetNode.create(e);
          if (p) {
            h.extendRange(t, p);
          }
          if (n.length > 0) {
            h.extendRange(t, n[n.length - 1]);
          }
          n.forEach(e => {
            e.parent = t;
          });
          t.d.items = n;
          return t;
        }
        const d = h.DictionaryNode.create(e);
        if (a) {
          d.d.trailingCommaToken = a;
          h.extendRange(d, a);
        }
        if (p) {
          h.extendRange(d, p);
        }
        if (t.length > 0) {
          t.forEach(e => {
            e.parent = d;
          });
          h.extendRange(d, t[t.length - 1]);
        }
        d.d.items = t;
        return d;
      }
      _parseExpressionListGeneric(e, t = () => this._isNextTokenNeverExpression(), n = () => false) {
        let a = false;
        const r = [];
        let s;
        while (!t()) {
          const t = e();
          if (t.nodeType === 0) {
            s = t;
            break;
          }
          r.push(t);
          if (n()) {
            break;
          }
          if (!this._consumeTokenIfType(12)) {
            a = false;
            break;
          }
          a = true;
        }
        return {
          trailingComma: a,
          list: r,
          parseError: s
        };
      }
      _parseExpressionStatement() {
        var e;
        var t;
        let n;
        let a = this._parseTestOrStarListAsExpression(false, false, 2, () => g.LocMessage.expectedExpr());
        if (a.nodeType === 0) {
          return a;
        }
        if (this._consumeTokenIfType(10)) {
          n = this._parseTypeAnnotation();
          a = h.TypeAnnotationNode.create(a, n);
          if (!this._parseOptions.isStubFile && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_6)) {
            this._addSyntaxError(g.LocMessage.varAnnotationIllegal(), n);
          }
          if (!this._consumeTokenIfOperator(2)) {
            return a;
          }
          const t = this._isTypingAnnotation(n, 'TypeAlias');
          const r = this._isParsingTypeAnnotation;
          if (t) {
            this._isParsingTypeAnnotation = true;
          }
          const s = (e = this._tryParseYieldExpression()) !== null && e !== undefined ? e : this._parseTestOrStarListAsExpression(false, true, 2, () => g.LocMessage.expectedAssignRightHandExpr());
          this._isParsingTypeAnnotation = r;
          return h.AssignmentNode.create(a, s);
        }
        if (this._consumeTokenIfOperator(2)) {
          return this._parseChainAssignments(a);
        }
        if (T.Tokenizer.isOperatorAssignment(this._peekOperatorType())) {
          const e = this._getNextToken();
          const n = (t = this._tryParseYieldExpression()) !== null && t !== undefined ? t : this._parseTestOrStarListAsExpression(false, true, 2, () => g.LocMessage.expectedBinaryRightHandExpr());
          this._reportConditionalErrorForStarTupleElement(n, u.pythonVersion3_9);
          const r = Object.assign({}, a);
          r.id = h.getNextNodeId();
          return h.AugmentedAssignmentNode.create(a, n, e.operatorType, r);
        }
        return a;
      }
      _parseChainAssignments(e) {
        var t;
        const n = [e];
        let a;
        while (a = (t = this._tryParseYieldExpression()) !== null && t !== undefined ? t : this._parseTestOrStarListAsExpression(false, true, 2, () => g.LocMessage.expectedAssignRightHandExpr()), a.nodeType !== 0 && this._consumeTokenIfOperator(2)) {
          n.push(a);
        }
        let r = h.AssignmentNode.create(n[0], a);
        const s = this._parseVariableTypeAnnotationComment();
        if (s) {
          if (n.length > 1) {
            r.d.chainedAnnotationComment = s;
          } else {
            r.d.annotationComment = s;
            r.d.annotationComment.parent = r;
            h.extendRange(r, r.d.annotationComment);
          }
        }
        n.forEach((e, t) => {
          if (t > 0) {
            r = h.AssignmentNode.create(e, r);
          }
        });
        return r;
      }
      _parseFunctionTypeAnnotation() {
        const e = this._peekToken();
        if (!this._consumeTokenIfType(13)) {
          this._addSyntaxError(g.LocMessage.expectedOpenParen(), this._peekToken());
          return;
        }
        let t = [];
        while (true) {
          const e = this._peekTokenType();
          if (e === 14 || e === 2 || e === 1) {
            break;
          }
          if (!this._consumeTokenIfOperator(26)) {
            this._consumeTokenIfOperator(29);
          }
          const n = this._parseTypeAnnotation();
          t.push(n);
          if (!this._consumeTokenIfType(12)) {
            break;
          }
        }
        if (!this._consumeTokenIfType(14)) {
          this._addSyntaxError(g.LocMessage.expectedCloseParen(), e);
          this._consumeTokensUntilType([10]);
        }
        if (!this._consumeTokenIfType(21)) {
          this._addSyntaxError(g.LocMessage.expectedArrow(), this._peekToken());
          return;
        }
        const n = this._parseTypeAnnotation();
        let a = false;
        if (t.length === 1 && t[0].nodeType === 21) {
          t = [];
          a = true;
        }
        return h.FunctionAnnotationNode.create(e, a, t, n);
      }
      _parseTypeAnnotation(e = false) {
        const t = this._isParsingTypeAnnotation;
        this._isParsingTypeAnnotation = true;
        const n = this._peekToken();
        const a = this._consumeTokenIfOperator(26);
        if (a && e && !this._parseOptions.isStubFile && !this._isParsingQuotedText && u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_11)) {
          this._addSyntaxError(g.LocMessage.unpackedSubscriptIllegal(), n);
        }
        let r = this._parseTestExpression(false);
        if (a) {
          r = h.UnpackNode.create(n, r);
        }
        this._isParsingTypeAnnotation = t;
        return r;
      }
      _reportStringTokenErrors(e, t) {
        if (e.flags & 65536) {
          this._addSyntaxError(g.LocMessage.stringUnterminated(), e);
        }
        if (t == null ? undefined : t.nonAsciiInBytes) {
          this._addSyntaxError(g.LocMessage.stringNonAsciiBytes(), e);
        }
        if (e.flags & 64) {
          if (u.PythonVersion.isLessThan(this._getLanguageVersion(), u.pythonVersion3_6)) {
            this._addSyntaxError(g.LocMessage.formatStringIllegal(), e);
          }
          if (e.flags & 32) {
            this._addSyntaxError(g.LocMessage.formatStringBytes(), e);
          }
          if (e.flags & 16) {
            this._addSyntaxError(g.LocMessage.formatStringUnicode(), e);
          }
        }
      }
      _makeStringNode(e) {
        const t = f.getUnescapedString(e);
        this._reportStringTokenErrors(e, t);
        return h.StringNode.create(e, t.value);
      }
      _getTypeAnnotationCommentText() {
        if (this._tokenIndex === 0) {
          return;
        }
        const e = this._tokenizerOutput.tokens.getItemAt(this._tokenIndex - 1);
        const t = this._tokenizerOutput.tokens.getItemAt(this._tokenIndex);
        if (e.start + e.length === t.start) {
          return;
        }
        const n = this._fileContents.slice(e.start + e.length, t.start).match(/^(\s*#\s*type:\s*)([^\r\n]*)/);
        if (!n) {
          return;
        }
        const a = n[2];
        if (a.trim().match(/^ignore(\s|\[|$)/)) {
          return;
        }
        const r = e.start + e.length + n[1].length;
        return v.StringToken.create(r, a.length, 0, a, 0, undefined);
      }
      _parseVariableTypeAnnotationComment() {
        const e = this._getTypeAnnotationCommentText();
        if (!e) {
          return;
        }
        const t = this._makeStringNode(e);
        const n = h.StringListNode.create([t]);
        const a = new C().parseTextExpression(this._fileContents, e.start, e.length, this._parseOptions, 1, undefined, this._typingSymbolAliases);
        a.diagnostics.forEach(e => {
          this._addSyntaxError(e.message, n);
        });
        if (a.parseTree) {
          return a.parseTree;
        } else {
          return undefined;
        }
      }
      _parseFunctionTypeAnnotationComment(e, t) {
        const n = this._makeStringNode(e);
        const a = h.StringListNode.create([n]);
        const r = new C().parseTextExpression(this._fileContents, e.start, e.length, this._parseOptions, 2, undefined, this._typingSymbolAliases);
        r.diagnostics.forEach(e => {
          this._addSyntaxError(e.message, a);
        });
        if (!r.parseTree) {
          return;
        }
        const s = r.parseTree;
        t.d.funcAnnotationComment = s;
        s.parent = t;
        h.extendRange(t, s);
      }
      _parseFStringReplacementField(e, t, n, a = 0) {
        var r;
        let s = this._getNextToken();
        l.assert(s.type === 17);
        const i = (r = this._tryParseYieldExpression()) !== null && r !== undefined ? r : this._parseTestOrStarListAsExpression(true, true, 2, () => g.LocMessage.expectedExpr());
        e.push(i);
        return i.nodeType !== 0 && (s = this._peekToken(), s.type === 9 && s.operatorType === 2 && (u.PythonVersion.isLessThan(this._parseOptions.pythonVersion, u.pythonVersion3_8) && this._addSyntaxError(g.LocMessage.formatStringDebuggingIllegal(), s), this._getNextToken(), s = this._peekToken()), s.type === 23 && (this._getNextToken(), s = this._peekToken(), s.type !== 7 ? this._addSyntaxError(g.LocMessage.formatStringExpectedConversion(), s) : (this._getNextToken(), s = this._peekToken())), s.type === 10 && (this._getNextToken(), this._parseFStringFormatString(e, t, n, a), s = this._peekToken()), s.type !== 18 ? (this._addSyntaxError(g.LocMessage.formatStringUnterminated(), s), false) : (this._getNextToken(), true));
      }
      _parseFStringFormatString(e, t, n, a) {
        while (true) {
          const r = this._peekToken();
          if (r.type === 18 || r.type === 26) {
            break;
          }
          if (r.type !== 25) {
            if (r.type !== 17) {
              break;
            }
            if (a === 2) {
              this._addSyntaxError(g.LocMessage.formatStringNestedFormatSpecifier(), r);
            }
            this._parseFStringReplacementField(e, t, n, a + 1);
          } else {
            this._getNextToken();
          }
        }
      }
      _parseFormatString(e) {
        const t = [];
        const n = [];
        const a = [];
        let r;
        while (true) {
          const s = this._peekToken();
          if (s.type === 26) {
            r = s;
            if (r.flags & 65536) {
              this._addSyntaxError(g.LocMessage.stringUnterminated(), e);
            }
            this._getNextToken();
            break;
          }
          if (s.type !== 25) {
            if (s.type !== 17) {
              if (this._consumeTokensUntilType([26])) {
                this._getNextToken();
              }
              this._addSyntaxError(s.type === 18 ? g.LocMessage.formatStringBrace() : g.LocMessage.stringUnterminated(), s);
              break;
            }
            if (!this._parseFStringReplacementField(n, t, a)) {
              if (this._consumeTokensUntilType([26, 2]) && this._peekToken().type === 26) {
                this._getNextToken();
              }
              break;
            }
          } else {
            t.push(s);
            this._getNextToken();
          }
        }
        this._reportStringTokenErrors(e);
        return h.FormatStringNode.create(e, r, t, n, a);
      }
      _createBinaryOperationNode(e, t, n, a) {
        var r;
        var s;
        const i = h.BinaryOperationNode.create(e, t, n, a);
        const o = (r = this._maxChildDepthMap.get(e.id)) !== null && r !== undefined ? r : 0;
        const l = (s = this._maxChildDepthMap.get(t.id)) !== null && s !== undefined ? s : 0;
        if (o >= _ || l >= _) {
          this._addSyntaxError(g.LocMessage.maxParseDepthExceeded(), i);
          return h.ErrorNode.create(i, 15);
        } else {
          this._maxChildDepthMap.set(i.id, Math.max(o, l) + 1);
          return i;
        }
      }
      _createUnaryOperationNode(e, t, n) {
        var a;
        const r = h.UnaryOperationNode.create(e, t, n);
        const s = (a = this._maxChildDepthMap.get(t.id)) !== null && a !== undefined ? a : 0;
        if (s >= _) {
          this._addSyntaxError(g.LocMessage.maxParseDepthExceeded(), r);
          return h.ErrorNode.create(r, 15);
        } else {
          this._maxChildDepthMap.set(r.id, s + 1);
          return r;
        }
      }
      _parseStringList() {
        const e = [];
        while (true) {
          const t = this._peekToken();
          if (t.type === 5) {
            e.push(this._makeStringNode(this._getNextToken()));
          } else {
            if (t.type !== 24) {
              break;
            }
            e.push(this._parseFormatString(this._getNextToken()));
          }
        }
        const t = h.StringListNode.create(e);
        if (this._isParsingTypeAnnotation) {
          if (t.d.strings.length > 1) {
            if (this._isParsingQuotedText) {
              this._addSyntaxError(g.LocMessage.annotationSpansStrings(), t);
            }
          } else {
            if (t.d.strings[0].nodeType === 30) {
              if (this._isParsingQuotedText) {
                this._addSyntaxError(g.LocMessage.annotationFormatString(), t);
              }
            } else {
              const e = t.d.strings[0].d.token;
              const n = f.getUnescapedString(t.d.strings[0].d.token).value;
              const a = e.start;
              const r = e.prefixLength + e.quoteMarkLength;
              if (n.length !== e.length - r - e.quoteMarkLength) {
                if (this._isParsingQuotedText) {
                  this._addSyntaxError(g.LocMessage.annotationStringEscape(), t);
                }
              } else {
                if (!(e.flags & 104)) {
                  const e = new C().parseTextExpression(this._fileContents, a + r, n.length, this._parseOptions, 1, t.d.strings[0].d.token.flags & 4 ? 1 : 0, this._typingSymbolAliases);
                  if (e.diagnostics.length === 0 || this._parseOptions.reportErrorsForParsedStringContents) {
                    e.diagnostics.forEach(e => {
                      this._addSyntaxError(e.message, t);
                    });
                    if (e.parseTree) {
                      t.d.annotation = e.parseTree;
                      t.d.annotation.parent = t;
                    }
                  }
                }
              }
            }
          }
        }
        return t;
      }
      _reportConditionalErrorForStarTupleElement(e, t = u.pythonVersion3_8) {
        if (e.nodeType === 52 && !e.d.hasParens && !u.PythonVersion.isGreaterOrEqualTo(this._parseOptions.pythonVersion, t)) {
          for (const t of e.d.items) {
            if (t.nodeType === 56) {
              this._addSyntaxError(g.LocMessage.unpackTuplesIllegal(), t);
              return;
            }
          }
        }
      }
      _isNextTokenNeverExpression() {
        switch (this._peekToken().type) {
          case 8:
            switch (this._peekKeywordType()) {
              case 17:
              case 22:
              case 20:
                return true;
            }
            break;
          case 9:
            switch (this._peekOperatorType()) {
              case 1:
              case 34:
              case 27:
              case 11:
              case 25:
              case 4:
              case 7:
              case 9:
              case 18:
              case 32:
              case 30:
              case 14:
              case 2:
                return true;
            }
            break;
          case 3:
          case 4:
          case 2:
          case 1:
          case 11:
          case 14:
          case 16:
          case 18:
          case 12:
          case 10:
          case 23:
          case 25:
          case 26:
            return true;
        }
        return false;
      }
      _disallowAssignmentExpression(e) {
        const t = this._assignmentExpressionsAllowed;
        this._assignmentExpressionsAllowed = false;
        e();
        this._assignmentExpressionsAllowed = t;
      }
      _getNextToken() {
        const e = this._tokenizerOutput.tokens.getItemAt(this._tokenIndex);
        if (!this._atEof()) {
          this._tokenIndex++;
        }
        return e;
      }
      _atEof() {
        return this._tokenIndex >= this._tokenizerOutput.tokens.count - 1;
      }
      _peekToken(e = 0) {
        if (this._tokenIndex + e < 0) {
          return this._tokenizerOutput.tokens.getItemAt(0);
        } else {
          if (this._tokenIndex + e >= this._tokenizerOutput.tokens.count) {
            return this._tokenizerOutput.tokens.getItemAt(this._tokenizerOutput.tokens.count - 1);
          } else {
            return this._tokenizerOutput.tokens.getItemAt(this._tokenIndex + e);
          }
        }
      }
      _peekTokenType() {
        return this._peekToken().type;
      }
      _peekKeywordType() {
        const e = this._peekToken();
        if (e.type === 8) {
          return e.keywordType;
        }
      }
      _peekOperatorType() {
        const e = this._peekToken();
        if (e.type === 9) {
          return e.operatorType;
        }
      }
      _getTokenIfIdentifier() {
        const e = this._peekToken();
        if (e.type === 7) {
          return this._getNextToken();
        }
        if (e.type === 0) {
          this._getNextToken();
          this._addSyntaxError(g.LocMessage.invalidIdentifierChar(), e);
          return v.IdentifierToken.create(e.start, e.length, '', e.comments);
        }
        if (e.type === 8) {
          const t = e;
          if (v.KeywordToken.isSoftKeyword(t)) {
            const t = this._fileContents.substr(e.start, e.length);
            this._getNextToken();
            return v.IdentifierToken.create(e.start, e.length, t, e.comments);
          }
        }
      }
      _consumeTokensUntilType(e) {
        while (true) {
          const t = this._peekToken();
          if (e.some(e => e === t.type)) {
            return true;
          }
          if (t.type === 1) {
            return false;
          }
          this._getNextToken();
        }
      }
      _getTokenIfType(e) {
        if (this._peekTokenType() === e) {
          return this._getNextToken();
        }
      }
      _consumeTokenIfType(e) {
        return !!this._getTokenIfType(e);
      }
      _consumeTokenIfKeyword(e) {
        return this._peekKeywordType() === e && (this._getNextToken(), true);
      }
      _consumeTokenIfOperator(e) {
        return this._peekOperatorType() === e && (this._getNextToken(), true);
      }
      _getKeywordToken(e) {
        const t = this._getNextToken();
        l.assert(t.type === 8);
        l.assert(t.keywordType === e);
        return t;
      }
      _getLanguageVersion() {
        return this._parseOptions.pythonVersion;
      }
      _suppressErrors(e) {
        const t = this._areErrorsSuppressed;
        try {
          this._areErrorsSuppressed = true;
          e();
        } finally {
          this._areErrorsSuppressed = t;
        }
      }
      _addSyntaxError(e, t) {
        l.assert(t !== undefined);
        if (!this._areErrorsSuppressed) {
          this._diagSink.addError(e, c.convertOffsetsToRange(t.start, t.start + t.length, this._tokenizerOutput.lines));
        }
      }
    }
    exports.Parser = C;
  },
  23981: (module, exports) => {
    function n(e, t) {
      const n = e.valueParts.join('');
      const a = t !== n ? n : t;
      return {
        ...e,
        value: a
      };
    }
    function a(e) {
      return e >= 48 && e <= 57 || e >= 97 && e <= 122 || e >= 65 && e <= 90;
    }
    function r(e) {
      return e >= 48 && e <= 55;
    }
    function s(e) {
      return e >= 48 && e <= 57 || e >= 97 && e <= 102 || e >= 65 && e <= 70;
    }
    function i(e) {
      if (e >= 48 && e <= 57) {
        return e - 48;
      } else {
        if (e >= 97 && e <= 102) {
          return e - 97 + 10;
        } else {
          if (e >= 65 && e <= 70) {
            return e - 65 + 10;
          } else {
            return 0;
          }
        }
      }
    }
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.getUnescapedString = function (e) {
      const t = e.escapedValue;
      const o = !!(e.flags & 8);
      if (o) {
        return {
          value: t,
          unescapeErrors: [],
          nonAsciiInBytes: false
        };
      }
      const l = [];
      for (let e = 0; e < t.length; e++) {
        l.push(t.charCodeAt(e));
      }
      const p = !!(e.flags & 32);
      if (!l.some(e => e === 13 || e === 10 || e === 92)) {
        return {
          value: t,
          unescapeErrors: [],
          nonAsciiInBytes: p && l.some(e => e >= 128)
        };
      }
      let d = 0;
      const c = {
        valueParts: [],
        unescapeErrors: [],
        nonAsciiInBytes: false
      };
      const u = () => {
        if (!o) {
          c.unescapeErrors.push({
            offset: d - 1,
            length: 2,
            errorType: 0
          });
        }
      };
      const m = (e = 0) => d + e >= l.length ? 3 : l[d + e];
      const y = e => {
        let t = false;
        let n = 0;
        let a = '';
        for (let a = 0; a < e; a++) {
          const e = m(1 + a);
          if (!s(e)) {
            t = true;
            break;
          }
          n = n * 16 + i(e);
        }
        if (t) {
          u();
          a = `\\${String.fromCharCode(m())}`;
          d++;
        } else {
          a = String.fromCharCode(n);
          d += 1 + e;
        }
        return a;
      };
      const g = e => {
        const t = String.fromCharCode(e);
        c.valueParts.push(t);
      };
      while (true) {
        let e = m();
        if (e === 3) {
          return n(c, t);
        }
        if (e === 92) {
          d++;
          if (o) {
            g(e);
            continue;
          }
          e = m();
          let t = '';
          if (e === 13 || e === 10) {
            if (e === 13 && m(1) === 10) {
              if (o) {
                t += String.fromCharCode(e);
              }
              d++;
              e = m();
            }
            if (o) {
              t = `\\${t}${String.fromCharCode(e)}`;
            }
            d++;
          } else {
            if (o) {
              t = `\\${String.fromCharCode(e)}`;
              d++;
            } else {
              switch (e) {
                case 92:
                case 39:
                case 34:
                  t = String.fromCharCode(e);
                  d++;
                  break;
                case 97:
                  t = '';
                  d++;
                  break;
                case 98:
                  t = '\b';
                  d++;
                  break;
                case 102:
                  t = '\f';
                  d++;
                  break;
                case 110:
                  t = '\n';
                  d++;
                  break;
                case 114:
                  t = '\r';
                  d++;
                  break;
                case 116:
                  t = '\t';
                  d++;
                  break;
                case 118:
                  t = '';
                  d++;
                  break;
                case 120:
                  t = y(2);
                  break;
                case 78:
                  {
                    let n = false;
                    let r = 1;
                    if (m(r) !== 123) {
                      n = true;
                    } else {
                      for (r++;;) {
                        const e = m(r);
                        if (e === 125) {
                          break;
                        }
                        if (!a(e) && e !== 45 && (h = e) !== 32 && h !== 9) {
                          n = true;
                          break;
                        }
                        r++;
                      }
                    }
                    if (n) {
                      u();
                      t = `\\${String.fromCharCode(e)}`;
                      d++;
                    } else {
                      t = '-';
                      d += 1 + r;
                    }
                    break;
                  }
                case 117:
                  t = y(4);
                  break;
                case 85:
                  t = y(8);
                  break;
                default:
                  if (r(e)) {
                    let n = e - 48;
                    d++;
                    e = m();
                    if (r(e)) {
                      n = n * 8 + e - 48;
                      d++;
                      e = m();
                      if (r(e)) {
                        n = n * 8 + e - 48;
                        d++;
                      }
                    }
                    t = String.fromCharCode(n);
                  } else {
                    t = '\\';
                    u();
                  }
              }
            }
          }
          c.valueParts.push(t);
        } else {
          if (e === 10 || e === 13) {
            if (e === 13 && m(1) === 10) {
              g(e);
              d++;
              e = m();
            }
            g(e);
            d++;
          } else {
            if (p && e >= 128) {
              c.nonAsciiInBytes = true;
            }
            g(e);
            d++;
          }
        }
      }
      var h;
    };
  },
  49969: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.Tokenizer = undefined;
    const a = require(41557);
    const r = require(53266);
    const s = require(95418);
    const i = require(4794);
    const o = require(51651);
    const l = require(92600);
    const p = new Map([['and', 0], ['as', 1], ['assert', 2], ['async', 3], ['await', 4], ['break', 5], ['case', 6], ['class', 7], ['continue', 8], ['__debug__', 9], ['def', 10], ['del', 11], ['elif', 12], ['else', 13], ['except', 14], ['finally', 16], ['for', 17], ['from', 18], ['global', 19], ['if', 20], ['import', 21], ['in', 22], ['is', 23], ['lambda', 24], ['match', 25], ['nonlocal', 27], ['not', 28], ['or', 29], ['pass', 30], ['raise', 31], ['return', 32], ['try', 34], ['type', 35], ['while', 36], ['with', 37], ['yield', 38], ['False', 15], ['None', 26], ['True', 33]]);
    const d = new Set(['match', 'case', 'type']);
    const c = {
      0: 3,
      1: 4,
      2: 4,
      3: 2,
      4: 4,
      5: 1,
      6: 2,
      7: 4,
      8: 2,
      9: 4,
      10: 2,
      11: 4,
      12: 10,
      13: 2,
      14: 4,
      15: 10,
      16: 10,
      17: 2,
      18: 4,
      19: 26,
      20: 10,
      21: 10,
      22: 2,
      23: 4,
      24: 2,
      25: 4,
      26: 2,
      27: 4,
      28: 10,
      29: 2,
      30: 4,
      31: 2,
      32: 4,
      33: 2,
      34: 4,
      36: 2,
      37: 2,
      38: 1,
      39: 2,
      40: 2,
      41: 2,
      42: 2
    };
    exports.Tokenizer = class {
      constructor() {
        this._cs = new o.CharacterStream('');
        this._tokens = [];
        this._prevLineStart = 0;
        this._parenDepth = 0;
        this._lineRanges = [];
        this._indentAmounts = [];
        this._typeIgnoreLines = new Map();
        this._pyrightIgnoreLines = new Map();
        this._fStringStack = [];
        this._crCount = 0;
        this._crLfCount = 0;
        this._lfCount = 0;
        this._indentCount = 0;
        this._indentTabCount = 0;
        this._indentSpacesTotal = 0;
        this._singleQuoteCount = 0;
        this._doubleQuoteCount = 0;
        this._ipythonMode = r.IPythonMode.None;
      }
      tokenize(e, t = 0, n = e.length, a = 0, i = r.IPythonMode.None) {
        this._cs = new o.CharacterStream(e);
        this._cs.position = t;
        this._tokens = [];
        this._prevLineStart = 0;
        this._parenDepth = a;
        this._lineRanges = [];
        this._indentAmounts = [];
        this._ipythonMode = i;
        const p = t + n;
        for (t === 0 && this._readIndentationAfterNewLine(); !this._cs.isEndOfStream() && !(this._addNextToken(), this._cs.position >= p););
        while (this._activeFString) {
          this._tokens.push(l.FStringEndToken.create(this._cs.position, 0, this._activeFString.startToken.flags | 65536));
          this._activeFString = this._fStringStack.pop();
        }
        if (this._tokens.length === 0 || this._tokens[this._tokens.length - 1].type !== 2) {
          if (this._parenDepth === 0) {
            this._tokens.push(l.NewLineToken.create(this._cs.position, 0, 3, this._getComments()));
          }
        }
        this._setIndent(this._cs.position, 0, 0, false, false);
        this._tokens.push(l.Token.create(1, this._cs.position, 0, this._getComments()));
        this._addLineRange();
        if (this._lineRanges.length > 0) {
          const t = this._lineRanges[this._lineRanges.length - 1];
          const n = e.charCodeAt(t.start + t.length - 1);
          if (n === 13 || n === 10) {
            this._lineRanges.push({
              start: this._cs.position,
              length: 0
            });
          }
        }
        let d = '\n';
        if (this._crCount > this._crLfCount && this._crCount > this._lfCount) {
          d = '\r';
        } else {
          if (this._crLfCount > this._crCount && this._crLfCount > this._lfCount) {
            d = '\r\n';
          }
        }
        let c = '    ';
        let u = false;
        if (this._indentTabCount > this._indentCount / 2) {
          u = true;
          c = '\t';
        } else {
          if (this._indentCount > 0) {
            u = true;
            let e = Math.round(this._indentSpacesTotal / this._indentCount);
            if (e < 1) {
              e = 1;
            } else {
              if (e > 8) {
                e = 8;
              }
            }
            c = '';
            for (let t = 0; t < e; t++) {
              c += ' ';
            }
          }
        }
        return {
          tokens: new s.TextRangeCollection(this._tokens),
          lines: new s.TextRangeCollection(this._lineRanges),
          typeIgnoreLines: this._typeIgnoreLines,
          typeIgnoreAll: this._typeIgnoreAll,
          pyrightIgnoreLines: this._pyrightIgnoreLines,
          predominantEndOfLineSequence: d,
          hasPredominantTabSequence: u,
          predominantTabSequence: c,
          predominantSingleQuoteCharacter: this._singleQuoteCount >= this._doubleQuoteCount ? '\'' : '"'
        };
      }
      static getOperatorInfo(e) {
        return c[e];
      }
      static isPythonKeyword(e, t = false) {
        return !!p.get(e) && (!!t || !d.has(e));
      }
      static isPythonIdentifier(e) {
        for (let t = 0; t < e.length; t++) {
          if (t === 0 ? !i.isIdentifierStartChar(e.charCodeAt(t)) : !i.isIdentifierChar(e.charCodeAt(t))) {
            return false;
          }
        }
        return true;
      }
      static isOperatorAssignment(e) {
        return e !== undefined && c[e] !== undefined && !!(c[e] & 4);
      }
      static isOperatorComparison(e) {
        return e !== undefined && c[e] !== undefined && !!(c[e] & 8);
      }
      _addNextToken() {
        if (!this._activeFString || this._activeFString.activeReplacementField && !this._activeFString.activeReplacementField.inFormatSpecifier) {
          this._cs.skipWhitespace();
        } else {
          this._handleFStringMiddle();
        }
        if (!this._cs.isEndOfStream() && !this._handleCharacter()) {
          this._cs.moveNext();
        }
      }
      _handleCharacter() {
        var e;
        var t;
        const n = this._getStringPrefixLength();
        if (n >= 0) {
          let e = '';
          if (n > 0) {
            e = this._cs.getText().slice(this._cs.position, this._cs.position + n);
            this._cs.advance(n);
          }
          const t = this._getQuoteTypeFlags(e);
          if (t !== 0) {
            this._handleString(t, n);
            return true;
          }
        }
        if (this._cs.currentChar === 35) {
          this._handleComment();
          return true;
        }
        if (this._ipythonMode) {
          const e = this._getIPythonMagicsKind();
          if (e === 'line') {
            this._handleIPythonMagics(this._cs.currentChar === 37 ? 1 : 2);
            return true;
          }
          if (e === 'cell') {
            this._handleIPythonMagics(this._cs.currentChar === 37 ? 3 : 4);
            return true;
          }
        }
        switch (this._cs.currentChar) {
          case 65279:
            return this._cs.position !== 0 && this._handleInvalid();
          case 13:
            {
              const e = this._cs.nextChar === 10 ? 2 : 1;
              const t = e === 2 ? 2 : 0;
              this._handleNewLine(e, t);
              return true;
            }
          case 10:
            this._handleNewLine(1, 1);
            return true;
          case 92:
            if (this._cs.nextChar === 13) {
              if (this._cs.lookAhead(2) === 10) {
                this._cs.advance(3);
              } else {
                this._cs.advance(2);
              }
              this._addLineRange();
              if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].type === 2) {
                this._readIndentationAfterNewLine();
              }
              return true;
            } else {
              if (this._cs.nextChar === 10) {
                this._cs.advance(2);
                this._addLineRange();
                if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].type === 2) {
                  this._readIndentationAfterNewLine();
                }
                return true;
              } else {
                return this._handleInvalid();
              }
            }
          case 40:
            this._parenDepth++;
            this._tokens.push(l.Token.create(13, this._cs.position, 1, this._getComments()));
            break;
          case 41:
            if (this._parenDepth > 0) {
              this._parenDepth--;
            }
            this._tokens.push(l.Token.create(14, this._cs.position, 1, this._getComments()));
            break;
          case 91:
            this._parenDepth++;
            this._tokens.push(l.Token.create(15, this._cs.position, 1, this._getComments()));
            break;
          case 93:
            if (this._parenDepth > 0) {
              this._parenDepth--;
            }
            this._tokens.push(l.Token.create(16, this._cs.position, 1, this._getComments()));
            break;
          case 123:
            this._parenDepth++;
            this._tokens.push(l.Token.create(17, this._cs.position, 1, this._getComments()));
            if (this._activeFString) {
              if (!this._activeFString.activeReplacementField || !!this._activeFString.activeReplacementField.inFormatSpecifier) {
                if (this._activeFString.activeReplacementField) {
                  this._activeFString.replacementFieldStack.push(this._activeFString.activeReplacementField);
                }
                this._activeFString.activeReplacementField = {
                  inFormatSpecifier: false,
                  parenDepth: this._parenDepth
                };
              }
            }
            break;
          case 125:
            if (this._activeFString && ((e = this._activeFString.activeReplacementField) === null || e === undefined ? undefined : e.parenDepth) === this._parenDepth) {
              this._activeFString.activeReplacementField = this._activeFString.replacementFieldStack.pop();
            }
            if (this._parenDepth > 0) {
              this._parenDepth--;
            }
            this._tokens.push(l.Token.create(18, this._cs.position, 1, this._getComments()));
            break;
          case 44:
            this._tokens.push(l.Token.create(12, this._cs.position, 1, this._getComments()));
            break;
          case 96:
            this._tokens.push(l.Token.create(22, this._cs.position, 1, this._getComments()));
            break;
          case 59:
            this._tokens.push(l.Token.create(11, this._cs.position, 1, this._getComments()));
            break;
          case 58:
            if (this._cs.nextChar === 61 && (!this._activeFString || !this._activeFString.activeReplacementField || this._activeFString.activeReplacementField.parenDepth !== this._parenDepth)) {
              this._tokens.push(l.OperatorToken.create(this._cs.position, 2, 35, this._getComments()));
              this._cs.advance(1);
              break;
            }
            this._tokens.push(l.Token.create(10, this._cs.position, 1, this._getComments()));
            if (((t = this._activeFString) === null || t === undefined ? undefined : t.activeReplacementField) && this._parenDepth === this._activeFString.activeReplacementField.parenDepth) {
              this._activeFString.activeReplacementField.inFormatSpecifier = true;
            }
            break;
          default:
            if (this._isPossibleNumber() && this._tryNumber()) {
              return true;
            }
            if (this._cs.currentChar === 46) {
              if (this._cs.nextChar === 46 && this._cs.lookAhead(2) === 46) {
                this._tokens.push(l.Token.create(19, this._cs.position, 3, this._getComments()));
                this._cs.advance(3);
                return true;
              }
              this._tokens.push(l.Token.create(20, this._cs.position, 1, this._getComments()));
              break;
            }
            return !!this._tryIdentifier() || !!this._tryOperator() || this._handleInvalid();
        }
        return false;
      }
      _addLineRange() {
        const e = this._cs.position - this._prevLineStart;
        if (e > 0) {
          this._lineRanges.push({
            start: this._prevLineStart,
            length: e
          });
        }
        this._prevLineStart = this._cs.position;
      }
      _handleNewLine(e, t) {
        if (this._parenDepth === 0 && t !== 3) {
          if (this._tokens.length === 0 || this._tokens[this._tokens.length - 1].type !== 2) {
            this._tokens.push(l.NewLineToken.create(this._cs.position, e, t, this._getComments()));
          }
        }
        if (t === 0) {
          this._crCount++;
        } else {
          if (t === 2) {
            this._crLfCount++;
          } else {
            this._lfCount++;
          }
        }
        this._cs.advance(e);
        this._addLineRange();
        this._readIndentationAfterNewLine();
      }
      _readIndentationAfterNewLine() {
        let e = 0;
        let t = 0;
        let n = false;
        let a = false;
        const r = this._cs.position;
        while (!this._cs.isEndOfStream()) {
          switch (this._cs.currentChar) {
            case 32:
              e++;
              t++;
              a = true;
              this._cs.moveNext();
              break;
            case 9:
              e++;
              t += 8 - t % 8;
              n = true;
              this._cs.moveNext();
              break;
            case 12:
              e = 0;
              t = 0;
              n = false;
              a = false;
              this._cs.moveNext();
              break;
            default:
              this._setIndent(r, e, t, a, n);
              return;
            case 35:
            case 10:
            case 13:
              return;
          }
        }
      }
      _setIndent(e, t, n, a, r) {
        if (!(this._parenDepth > 0)) {
          if (this._indentAmounts.length === 0) {
            if (n > 0) {
              this._indentCount++;
              if (r) {
                this._indentTabCount++;
              }
              this._indentSpacesTotal += n;
              this._indentAmounts.push({
                tab1Spaces: t,
                tab8Spaces: n,
                isSpacePresent: a,
                isTabPresent: r
              });
              this._tokens.push(l.IndentToken.create(e, t, n, false, this._getComments()));
            }
          } else {
            const s = this._indentAmounts[this._indentAmounts.length - 1];
            if (s.tab8Spaces < n) {
              const i = (s.isSpacePresent && r || s.isTabPresent && a) && s.tab1Spaces >= t;
              this._indentCount++;
              if (r) {
                this._indentTabCount++;
              }
              this._indentSpacesTotal += n - this._indentAmounts[this._indentAmounts.length - 1].tab8Spaces;
              this._indentAmounts.push({
                tab1Spaces: t,
                tab8Spaces: n,
                isSpacePresent: a,
                isTabPresent: r
              });
              this._tokens.push(l.IndentToken.create(e, t, n, i, this._getComments()));
            } else {
              if (s.tab8Spaces === n) {
                if (s.isSpacePresent && r || s.isTabPresent && a) {
                  this._tokens.push(l.IndentToken.create(e, t, n, true, this._getComments()));
                }
              } else {
                let e = s.isSpacePresent && r || s.isTabPresent && a;
                const t = [];
                while (this._indentAmounts.length > 0 && this._indentAmounts[this._indentAmounts.length - 1].tab8Spaces > n) {
                  t.push(this._indentAmounts.length > 1 ? this._indentAmounts[this._indentAmounts.length - 2].tab8Spaces : 0);
                  this._indentAmounts.pop();
                }
                t.forEach((a, r) => {
                  const s = r < t.length - 1 || a === n;
                  const i = r < t.length - 1 ? a : n;
                  this._tokens.push(l.DedentToken.create(this._cs.position, 0, i, s, e, this._getComments()));
                  e = false;
                });
              }
            }
          }
        }
      }
      _tryIdentifier() {
        const e = () => {
          while (true) {
            if (i.isIdentifierChar(this._cs.currentChar)) {
              this._cs.moveNext();
            } else {
              if (!i.isIdentifierChar(this._cs.currentChar, this._cs.nextChar)) {
                break;
              }
              this._cs.moveNext();
              this._cs.moveNext();
            }
          }
        };
        const t = this._cs.position;
        if (i.isIdentifierStartChar(this._cs.currentChar)) {
          this._cs.moveNext();
          e();
        } else {
          if (i.isIdentifierStartChar(this._cs.currentChar, this._cs.nextChar)) {
            this._cs.moveNext();
            this._cs.moveNext();
            e();
          }
        }
        if (this._cs.position > t) {
          const e = this._cs.getText().slice(t, this._cs.position);
          if (p.has(e)) {
            this._tokens.push(l.KeywordToken.create(t, this._cs.position - t, p.get(e), this._getComments()));
          } else {
            this._tokens.push(l.IdentifierToken.create(t, this._cs.position - t, e, this._getComments()));
          }
          return true;
        }
        return false;
      }
      _isPossibleNumber() {
        return !!i.isDecimal(this._cs.currentChar) || this._cs.currentChar === 46 && !!i.isDecimal(this._cs.nextChar);
      }
      _tryNumber() {
        const e = this._cs.position;
        if (this._cs.currentChar === 48) {
          let t = 0;
          let n = 0;
          if (this._cs.nextChar !== 120 && this._cs.nextChar !== 88 || !i.isHex(this._cs.lookAhead(2))) {
            if (this._cs.nextChar !== 98 && this._cs.nextChar !== 66 || !i.isBinary(this._cs.lookAhead(2))) {
              if ((this._cs.nextChar === 111 || this._cs.nextChar === 79) && i.isOctal(this._cs.lookAhead(2))) {
                this._cs.advance(2);
                n = 2;
                while (i.isOctal(this._cs.currentChar)) {
                  this._cs.moveNext();
                }
                t = 8;
              }
            } else {
              this._cs.advance(2);
              n = 2;
              while (i.isBinary(this._cs.currentChar)) {
                this._cs.moveNext();
              }
              t = 2;
            }
          } else {
            this._cs.advance(2);
            n = 2;
            while (i.isHex(this._cs.currentChar)) {
              this._cs.moveNext();
            }
            t = 16;
          }
          if (t > 0) {
            const a = this._cs.getText().slice(e, this._cs.position);
            const r = a.replace(/_/g, '');
            let s = parseInt(r.slice(n), t);
            if (!isNaN(s)) {
              const t = BigInt(r);
              if (!isFinite(s) || s < Number.MIN_SAFE_INTEGER || s > Number.MAX_SAFE_INTEGER) {
                s = t;
              }
              this._tokens.push(l.NumberToken.create(e, a.length, s, true, false, this._getComments()));
              return true;
            }
          }
        }
        let t = false;
        let n = false;
        if (this._cs.currentChar >= 49 && this._cs.currentChar <= 57) {
          while (i.isDecimal(this._cs.currentChar)) {
            n = true;
            this._cs.moveNext();
          }
          t = this._cs.currentChar !== 46 && this._cs.currentChar !== 101 && this._cs.currentChar !== 69;
        }
        if (this._cs.currentChar === 48) {
          for (n = true; this._cs.currentChar === 48 || this._cs.currentChar === 95;) {
            this._cs.moveNext();
          }
          t = this._cs.currentChar !== 46 && this._cs.currentChar !== 101 && this._cs.currentChar !== 69 && (this._cs.currentChar < 49 || this._cs.currentChar > 57);
        }
        if (t) {
          let t = this._cs.getText().slice(e, this._cs.position);
          const n = t.replace(/_/g, '');
          let a = parseInt(n, 10);
          if (!isNaN(a)) {
            let r = false;
            const s = BigInt(n);
            if (!isFinite(a) || s < Number.MIN_SAFE_INTEGER || s > Number.MAX_SAFE_INTEGER) {
              a = s;
            }
            if (this._cs.currentChar === 106 || this._cs.currentChar === 74) {
              r = true;
              t += String.fromCharCode(this._cs.currentChar);
              this._cs.moveNext();
            }
            this._tokens.push(l.NumberToken.create(e, t.length, a, true, r, this._getComments()));
            return true;
          }
        }
        this._cs.position = e;
        if ((n || this._cs.currentChar === 46 && this._cs.nextChar >= 48 && this._cs.nextChar <= 57) && this._skipFloatingPointCandidate()) {
          let t = this._cs.getText().slice(e, this._cs.position);
          const n = parseFloat(t);
          if (!isNaN(n)) {
            let a = false;
            if (this._cs.currentChar === 106 || this._cs.currentChar === 74) {
              a = true;
              t += String.fromCharCode(this._cs.currentChar);
              this._cs.moveNext();
            }
            this._tokens.push(l.NumberToken.create(e, this._cs.position - e, n, false, a, this._getComments()));
            return true;
          }
        }
        this._cs.position = e;
        return false;
      }
      _tryOperator() {
        var e;
        var t;
        let n = 0;
        const a = this._cs.nextChar;
        let r;
        switch (this._cs.currentChar) {
          case 43:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 1 : 0;
            break;
          case 38:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 4 : 3;
            break;
          case 124:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 7 : 6;
            break;
          case 94:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 9 : 8;
            break;
          case 61:
            if (((e = this._activeFString) === null || e === undefined ? undefined : e.activeReplacementField) && ((t = this._activeFString) === null || t === undefined ? undefined : t.activeReplacementField.parenDepth) === this._parenDepth && !this._activeFString.activeReplacementField.inFormatSpecifier && a !== 61) {
              n = 1;
              r = 2;
              break;
            }
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 12 : 2;
            break;
          case 33:
            if (a !== 61) {
              return !!this._activeFString && (this._tokens.push(l.Token.create(23, this._cs.position, 1, this._getComments())), this._cs.advance(1), true);
            }
            n = 2;
            r = 28;
            break;
          case 37:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 25 : 24;
            break;
          case 126:
            n = 1;
            r = 5;
            break;
          case 45:
            if (a === 62) {
              this._tokens.push(l.Token.create(21, this._cs.position, 2, this._getComments()));
              this._cs.advance(2);
              return true;
            }
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 34 : 33;
            break;
          case 42:
            if (a === 42) {
              n = this._cs.lookAhead(2) === 61 ? 3 : 2;
              r = n === 3 ? 30 : 29;
            } else {
              n = a === 61 ? 2 : 1;
              r = n === 2 ? 27 : 26;
            }
            break;
          case 47:
            if (a === 47) {
              n = this._cs.lookAhead(2) === 61 ? 3 : 2;
              r = n === 3 ? 14 : 13;
            } else {
              n = a === 61 ? 2 : 1;
              r = n === 2 ? 11 : 10;
            }
            break;
          case 60:
            if (a === 60) {
              n = this._cs.lookAhead(2) === 61 ? 3 : 2;
              r = n === 3 ? 18 : 17;
            } else {
              if (a === 62) {
                n = 2;
                r = 19;
              } else {
                n = a === 61 ? 2 : 1;
                r = n === 2 ? 21 : 20;
              }
            }
            break;
          case 62:
            if (a === 62) {
              n = this._cs.lookAhead(2) === 61 ? 3 : 2;
              r = n === 3 ? 32 : 31;
            } else {
              n = a === 61 ? 2 : 1;
              r = n === 2 ? 16 : 15;
            }
            break;
          case 64:
            n = a === 61 ? 2 : 1;
            r = n === 2 ? 23 : 22;
            break;
          default:
            return false;
        }
        this._tokens.push(l.OperatorToken.create(this._cs.position, n, r, this._getComments()));
        this._cs.advance(n);
        return n > 0;
      }
      _handleInvalid() {
        const e = this._cs.position;
        while (this._cs.currentChar !== 10 && this._cs.currentChar !== 13 && !this._cs.isAtWhiteSpace() && !this._cs.isEndOfStream()) {
          if (i.isSurrogateChar(this._cs.currentChar)) {
            this._cs.moveNext();
            this._cs.moveNext();
          } else {
            this._cs.moveNext();
          }
        }
        const t = this._cs.position - e;
        return t > 0 && (this._tokens.push(l.Token.create(0, e, t, this._getComments())), true);
      }
      _getComments() {
        const e = this._comments;
        this._comments = undefined;
        return e;
      }
      _getIPythonMagicsKind() {
        if ((e = this._cs.currentChar) !== 37 && e !== 33) {
          return;
        }
        var e;
        const t = this._tokens.length > 0 ? this._tokens[this._tokens.length - 1] : undefined;
        if (t === undefined || a.isWhitespace(t)) {
          if (this._cs.nextChar === this._cs.currentChar) {
            this._cs.moveNext();
            return 'cell';
          } else {
            return 'line';
          }
        }
      }
      _handleIPythonMagics(e) {
        const t = this._cs.position + 1;
        let n = t;
        do {
          this._cs.skipToEol();
          if (e === 1 || e === 2) {
            const e = this._cs.position - n;
            if (!this._cs.getText().slice(n, n + e).match(/\\\s*$/)) {
              break;
            }
          }
          this._cs.moveNext();
          n = this._cs.position + 1;
        } while (!this._cs.isEndOfStream());
        const a = this._cs.position - t;
        const r = l.Comment.create(t, a, this._cs.getText().slice(t, t + a), e);
        this._addComments(r);
      }
      _handleComment() {
        var e;
        var t;
        const n = this._cs.position + 1;
        this._cs.skipToEol();
        const a = this._cs.position - n;
        const r = l.Comment.create(n, a, this._cs.getText().slice(n, n + a));
        const s = r.value.match(/((^|#)\s*)type:\s*ignore(\s*\[([\s\w-,]*)\]|\s|$)/);
        if (s) {
          const t = n + ((e = s.index) !== null && e !== undefined ? e : 0);
          const a = {
            range: {
              start: t + s[1].length,
              length: s[0].length - s[1].length
            },
            rulesList: this._getIgnoreCommentRulesList(t, s)
          };
          if (this._tokens.findIndex(e => e.type !== 2 && e && e.type !== 3) < 0) {
            this._typeIgnoreAll = a;
          } else {
            this._typeIgnoreLines.set(this._lineRanges.length, a);
          }
        }
        const i = r.value.match(/((^|#)\s*)pyright:\s*ignore(\s*\[([\s\w-,]*)\]|\s|$)/);
        if (i) {
          const e = n + ((t = i.index) !== null && t !== undefined ? t : 0);
          const a = {
            range: {
              start: e + i[1].length,
              length: i[0].length - i[1].length
            },
            rulesList: this._getIgnoreCommentRulesList(e, i)
          };
          this._pyrightIgnoreLines.set(this._lineRanges.length, a);
        }
        this._addComments(r);
      }
      _getIgnoreCommentRulesList(e, t) {
        if (t.length < 5 || t[4] === undefined) {
          return;
        }
        const n = t[4].split(',');
        const a = [];
        let r = e + t[0].indexOf('[') + 1;
        for (const e of n) {
          const t = e.trimStart();
          r += e.length - t.length;
          const n = t.trimEnd();
          if (n.length > 0) {
            a.push({
              range: {
                start: r,
                length: n.length
              },
              text: n
            });
          }
          r += t.length + 1;
        }
        return a;
      }
      _addComments(e) {
        if (this._comments) {
          this._comments.push(e);
        } else {
          this._comments = [e];
        }
      }
      _getStringPrefixLength() {
        if (this._cs.currentChar === 39 || this._cs.currentChar === 34) {
          return 0;
        }
        if (this._cs.nextChar === 39 || this._cs.nextChar === 34) {
          switch (this._cs.currentChar) {
            case 102:
            case 70:
            case 114:
            case 82:
            case 98:
            case 66:
            case 117:
            case 85:
              return 1;
          }
        }
        if (this._cs.lookAhead(2) === 39 || this._cs.lookAhead(2) === 34) {
          switch (this._cs.getText().slice(this._cs.position, this._cs.position + 2).toLowerCase()) {
            case 'rf':
            case 'fr':
            case 'ur':
            case 'ru':
            case 'br':
            case 'rb':
              return 2;
          }
        }
        return -1;
      }
      _getQuoteTypeFlags(e) {
        let t = 0;
        e = e.toLowerCase();
        for (let n = 0; n < e.length; n++) {
          switch (e[n]) {
            case 'u':
              t |= 16;
              break;
            case 'b':
              t |= 32;
              break;
            case 'r':
              t |= 8;
              break;
            case 'f':
              t |= 64;
          }
        }
        if (this._cs.currentChar === 39) {
          t |= 1;
          if (this._cs.nextChar === 39 && this._cs.lookAhead(2) === 39) {
            t |= 4;
          }
        } else {
          if (this._cs.currentChar === 34) {
            t |= 2;
            if (this._cs.nextChar === 34 && this._cs.lookAhead(2) === 34) {
              t |= 4;
            }
          }
        }
        return t;
      }
      _handleString(e, t) {
        var n;
        const a = this._cs.position - t;
        if (e & 64) {
          if (e & 4) {
            this._cs.advance(3);
          } else {
            this._cs.moveNext();
          }
          const n = this._cs.position;
          const r = l.FStringStartToken.create(a, n - a, e, t, this._getComments());
          const s = {
            startToken: r,
            replacementFieldStack: []
          };
          if (this._activeFString) {
            this._fStringStack.push(this._activeFString);
          }
          this._activeFString = s;
          this._tokens.push(r);
        } else {
          if (e & 4) {
            this._cs.advance(3);
          } else {
            this._cs.moveNext();
            if (e & 1) {
              this._singleQuoteCount++;
            } else {
              this._doubleQuoteCount++;
            }
          }
          const r = this._skipToEndOfStringLiteral(e);
          const s = this._cs.position;
          if (r.flags & 65536 && ((n = this._activeFString) === null || n === undefined ? undefined : n.activeReplacementField) && !(e & 120)) {
            const t = 7;
            if ((this._activeFString.startToken.flags & t) == (e & t)) {
              for (this._cs.position = a; this._activeFString.replacementFieldStack.length > 0;) {
                this._activeFString.activeReplacementField = this._activeFString.replacementFieldStack.pop();
              }
              this._parenDepth = this._activeFString.activeReplacementField.parenDepth - 1;
              this._activeFString.activeReplacementField = undefined;
              return;
            }
          }
          this._tokens.push(l.StringToken.create(a, s - a, r.flags, r.escapedValue, t, this._getComments()));
        }
      }
      _handleFStringMiddle() {
        var e;
        const t = this._activeFString;
        const n = !!((e = this._activeFString.activeReplacementField) === null || e === undefined ? undefined : e.inFormatSpecifier);
        const a = this._cs.position;
        const r = t.startToken.flags;
        const s = this._skipToEndOfStringLiteral(r, n);
        const i = this._cs.position;
        const o = !!(s.flags & 65536);
        const p = !!(s.flags & 128);
        const d = !!(s.flags & 256);
        const c = !o && !p && !d;
        let u = i - a;
        if (c) {
          u -= t.startToken.quoteMarkLength;
        }
        if (u > 0 || o) {
          this._tokens.push(l.FStringMiddleToken.create(a, u, s.flags, s.escapedValue));
        }
        if (c) {
          this._tokens.push(l.FStringEndToken.create(a + u, t.startToken.quoteMarkLength, s.flags));
          this._activeFString = this._fStringStack.pop();
        } else {
          if (o) {
            this._activeFString = this._fStringStack.pop();
          }
        }
      }
      _skipToEndOfStringLiteral(e, t = false) {
        const n = e & 1 ? 39 : 34;
        const a = !!(e & 4);
        const r = !!(e & 64);
        let s = false;
        const i = this._cs.position;
        let o = 0;
        const l = () => this._cs.getText().slice(i, i + o);
        while (true) {
          if (this._cs.isEndOfStream()) {
            e |= 65536;
            return {
              escapedValue: l(),
              flags: e
            };
          }
          if (this._cs.currentChar === 92) {
            o++;
            this._cs.moveNext();
            if (s || this._cs.getCurrentChar() !== 78 || this._cs.nextChar !== 123) {
              const e = this._cs.getCurrentChar() === 39 || this._cs.getCurrentChar() === 34;
              const t = this._cs.getCurrentChar() === 13 || this._cs.getCurrentChar() === 10;
              const n = this._cs.getCurrentChar() === 92;
              if (!r || n || e || t) {
                if (t) {
                  if (this._cs.getCurrentChar() === 13 && this._cs.nextChar === 10) {
                    o++;
                    this._cs.moveNext();
                  }
                  o++;
                  this._cs.moveNext();
                  this._addLineRange();
                } else {
                  o++;
                  this._cs.moveNext();
                }
              }
            } else {
              e |= 512;
              s = true;
            }
          } else {
            if (this._cs.currentChar === 10 || this._cs.currentChar === 13) {
              if (!a && !r) {
                e |= 65536;
                return {
                  escapedValue: l(),
                  flags: e
                };
              }
              if (this._cs.currentChar === 13 && this._cs.nextChar === 10) {
                o++;
                this._cs.moveNext();
              }
              o++;
              this._cs.moveNext();
              this._addLineRange();
            } else {
              if (!a && this._cs.currentChar === n) {
                this._cs.moveNext();
                break;
              }
              if (a && this._cs.currentChar === n && this._cs.nextChar === n && this._cs.lookAhead(2) === n) {
                this._cs.advance(3);
                break;
              }
              if (!s && r && this._cs.currentChar === 123) {
                if (t || this._cs.nextChar !== 123) {
                  e |= 128;
                  break;
                }
                o++;
                this._cs.moveNext();
                o++;
                this._cs.moveNext();
              } else {
                if (s && this._cs.currentChar === 125) {
                  s = false;
                  o++;
                  this._cs.moveNext();
                } else {
                  if (r && this._cs.currentChar === 125) {
                    if (t || this._cs.nextChar !== 125) {
                      e |= 256;
                      break;
                    }
                    o++;
                    this._cs.moveNext();
                    o++;
                    this._cs.moveNext();
                  } else {
                    o++;
                    this._cs.moveNext();
                  }
                }
              }
            }
          }
        }
        return {
          escapedValue: l(),
          flags: e
        };
      }
      _skipFloatingPointCandidate() {
        const e = this._cs.position;
        this._skipFractionalNumber();
        if (this._cs.position > e) {
          if (this._cs.currentChar === 101 || this._cs.currentChar === 69) {
            this._cs.moveNext();
            this._skipDecimalNumber(true);
          }
        }
        return this._cs.position > e;
      }
      _skipFractionalNumber() {
        this._skipDecimalNumber(false);
        if (this._cs.currentChar === 46) {
          this._cs.moveNext();
        }
        this._skipDecimalNumber(false);
      }
      _skipDecimalNumber(e) {
        for (!e || this._cs.currentChar !== 45 && this._cs.currentChar !== 43 || this._cs.moveNext(); i.isDecimal(this._cs.currentChar);) {
          this._cs.moveNext();
        }
      }
    };
  },
  92600: (module, exports) => {
    var n;
    var a;
    var r;
    var s;
    var i;
    var o;
    var l;
    var p;
    var d;
    var c;
    var u;
    var m;
    var y;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.IdentifierToken = exports.OperatorToken = exports.NumberToken = exports.FStringEndToken = exports.FStringMiddleToken = exports.FStringStartToken = exports.StringToken = exports.KeywordToken = exports.NewLineToken = exports.DedentToken = exports.IndentToken = exports.Token = exports.Comment = exports.softKeywords = undefined;
    exports.softKeywords = [9, 25, 6, 35];
    (function (e) {
      e.create = function (e, t, n, a = 0) {
        return {
          type: a,
          start: e,
          length: t,
          value: n
        };
      };
    })(n || (exports.Comment = n = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: t,
          length: n,
          type: e,
          comments: a
        };
      };
    })(a || (exports.Token = a = {}));
    (function (e) {
      e.create = function (e, t, n, a, r) {
        return {
          start: e,
          length: t,
          type: 3,
          isIndentAmbiguous: a,
          comments: r,
          indentAmount: n
        };
      };
    })(r || (exports.IndentToken = r = {}));
    (function (e) {
      e.create = function (e, t, n, a, r, s) {
        return {
          start: e,
          length: t,
          type: 4,
          comments: s,
          indentAmount: n,
          matchesIndent: a,
          isDedentAmbiguous: r
        };
      };
    })(s || (exports.DedentToken = s = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: e,
          length: t,
          type: 2,
          comments: a,
          newLineType: n
        };
      };
    })(i || (exports.NewLineToken = i = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: e,
          length: t,
          type: 8,
          comments: a,
          keywordType: n
        };
      };
      e.isSoftKeyword = function (e) {
        return exports.softKeywords.some(t => e.keywordType === t);
      };
    })(o || (exports.KeywordToken = o = {}));
    (function (e) {
      e.create = function (e, t, n, a, r, s) {
        return {
          start: e,
          length: t,
          type: 5,
          flags: n,
          escapedValue: a,
          prefixLength: r,
          quoteMarkLength: n & 4 ? 3 : 1,
          comments: s
        };
      };
    })(l || (exports.StringToken = l = {}));
    (function (e) {
      e.create = function (e, t, n, a, r) {
        return {
          start: e,
          length: t,
          type: 24,
          flags: n,
          prefixLength: a,
          quoteMarkLength: n & 4 ? 3 : 1,
          comments: r
        };
      };
    })(p || (exports.FStringStartToken = p = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: e,
          length: t,
          type: 25,
          flags: n,
          escapedValue: a
        };
      };
    })(d || (exports.FStringMiddleToken = d = {}));
    (function (e) {
      e.create = function (e, t, n) {
        return {
          start: e,
          length: t,
          type: 26,
          flags: n
        };
      };
    })(c || (exports.FStringEndToken = c = {}));
    (function (e) {
      e.create = function (e, t, n, a, r, s) {
        return {
          start: e,
          length: t,
          type: 6,
          isInteger: a,
          isImaginary: r,
          value: n,
          comments: s
        };
      };
    })(u || (exports.NumberToken = u = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: e,
          length: t,
          type: 9,
          operatorType: n,
          comments: a
        };
      };
    })(m || (exports.OperatorToken = m = {}));
    (function (e) {
      e.create = function (e, t, n, a) {
        return {
          start: e,
          length: t,
          type: 7,
          value: n.normalize('NFKC'),
          comments: a
        };
      };
    })(y || (exports.IdentifierToken = y = {}));
  },
  14911: (module, exports) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.unicodePc = exports.unicodeNdSurrogate = exports.unicodeNd = exports.unicodeMcSurrogate = exports.unicodeMc = exports.unicodeMnSurrogate = exports.unicodeMn = exports.unicodeNlSurrogate = exports.unicodeNl = exports.unicodeLmSurrogate = exports.unicodeLm = exports.unicodeLoSurrogate = exports.unicodeLo = exports.unicodeLt = exports.unicodeLlSurrogate = exports.unicodeLl = exports.unicodeLuSurrogate = exports.unicodeLu = undefined;
    exports.unicodeLu = [[65, 90], [192, 214], [216, 222], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 313, 315, 317, 319, 321, 323, 325, 327, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, 452, 455, 458, 461, 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, 497, 500, [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, 880, 882, 886, 895, 902, [904, 906], 908, [910, 911], [913, 929], [931, 939], 975, [978, 980], 984, 986, 988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006, 1012, 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], [4256, 4293], 4295, 4301, [5024, 5109], 7305, [7312, 7354], [7357, 7359], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], [8120, 8123], [8136, 8139], [8152, 8155], [8168, 8172], [8184, 8187], 8450, 8455, [8459, 8461], [8464, 8466], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8496, 8499], [8510, 8511], 8517, 8579, [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11390, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, [42955, 42956], 42960, 42966, 42968, 42970, 42972, 42997, [65313, 65338], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [68736, 68786], [68944, 68965], [71840, 71871], [93760, 93791], [119808, 119833], [119860, 119885], [119912, 119937], 119964, [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119989], [120016, 120041], [120068, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120120, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120172, 120197], [120224, 120249], [120276, 120301], [120328, 120353], [120380, 120405], [120432, 120457], [120488, 120512], [120546, 120570], [120604, 120628], [120662, 120686], [120720, 120744], 120778, [125184, 125217]];
    exports.unicodeLuSurrogate = {
      55297: [[56320, 56359], [56496, 56531], [56688, 56698], [56700, 56714], [56716, 56722], [56724, 56725]],
      55299: [[56448, 56498], [56656, 56677]],
      55302: [[56480, 56511]],
      55323: [[56896, 56927]],
      55349: [[56320, 56345], [56372, 56397], [56424, 56449], 56476, [56478, 56479], 56482, [56485, 56486], [56489, 56492], [56494, 56501], [56528, 56553], [56580, 56581], [56583, 56586], [56589, 56596], [56598, 56604], [56632, 56633], [56635, 56638], [56640, 56644], 56646, [56650, 56656], [56684, 56709], [56736, 56761], [56788, 56813], [56840, 56865], [56892, 56917], [56944, 56969], [57000, 57024], [57058, 57082], [57116, 57140], [57174, 57198], [57232, 57256], 57290],
      55354: [[56576, 56609]]
    };
    exports.unicodeLl = [[97, 122], 181, [223, 246], [248, 255], 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, [311, 312], 314, 316, 318, 320, 322, 324, 326, [328, 329], 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, [382, 384], 387, 389, 392, [396, 397], 402, 405, [409, 411], 414, 417, 419, 421, 424, [426, 427], 429, 432, 436, 438, [441, 442], [445, 447], 454, 457, 460, 462, 464, 466, 468, 470, 472, 474, [476, 477], 479, 481, 483, 485, 487, 489, 491, 493, [495, 496], 499, 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 545, 547, 549, 551, 553, 555, 557, 559, 561, [563, 569], 572, [575, 576], 578, 583, 585, 587, 589, [591, 659], [661, 687], 881, 883, 887, [891, 893], 912, [940, 974], [976, 977], [981, 983], 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, [1007, 1011], 1013, 1016, [1019, 1020], [1072, 1119], 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, [1230, 1231], 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, [1376, 1416], [4304, 4346], [4349, 4351], [5112, 5117], [7296, 7304], 7306, [7424, 7467], [7531, 7543], [7545, 7578], 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, [7829, 7837], 7839, 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8000, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8071], [8080, 8087], [8096, 8103], [8112, 8116], [8118, 8119], 8126, [8130, 8132], [8134, 8135], [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], 8458, [8462, 8463], 8467, 8495, 8500, 8505, [8508, 8509], [8518, 8521], 8526, 8580, [11312, 11359], 11361, [11365, 11366], 11368, 11370, 11372, 11377, [11379, 11380], [11382, 11387], 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, [11491, 11492], 11500, 11502, 11507, [11520, 11557], 11559, 11565, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, 42651, 42787, 42789, 42791, 42793, 42795, 42797, [42799, 42801], 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, 42863, [42865, 42872], 42874, 42876, 42879, 42881, 42883, 42885, 42887, 42892, 42894, 42897, [42899, 42901], 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42927, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42957, 42961, 42963, 42965, 42967, 42969, 42971, 42998, 43002, [43824, 43866], [43872, 43880], [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370], [66600, 66639], [66776, 66811], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68800, 68850], [68976, 68997], [71872, 71903], [93792, 93823], [119834, 119859], [119886, 119892], [119894, 119911], [119938, 119963], [119990, 119993], 119995, [119997, 120003], [120005, 120015], [120042, 120067], [120094, 120119], [120146, 120171], [120198, 120223], [120250, 120275], [120302, 120327], [120354, 120379], [120406, 120431], [120458, 120485], [120514, 120538], [120540, 120545], [120572, 120596], [120598, 120603], [120630, 120654], [120656, 120661], [120688, 120712], [120714, 120719], [120746, 120770], [120772, 120777], 120779, [122624, 122633], [122635, 122654], [122661, 122666], [125218, 125251]];
    exports.unicodeLlSurrogate = {
      55297: [[56360, 56399], [56536, 56571], [56727, 56737], [56739, 56753], [56755, 56761], [56763, 56764]],
      55299: [[56512, 56562], [56688, 56709]],
      55302: [[56512, 56543]],
      55323: [[56928, 56959]],
      55349: [[56346, 56371], [56398, 56404], [56406, 56423], [56450, 56475], [56502, 56505], 56507, [56509, 56515], [56517, 56527], [56554, 56579], [56606, 56631], [56658, 56683], [56710, 56735], [56762, 56787], [56814, 56839], [56866, 56891], [56918, 56943], [56970, 56997], [57026, 57050], [57052, 57057], [57084, 57108], [57110, 57115], [57142, 57166], [57168, 57173], [57200, 57224], [57226, 57231], [57258, 57282], [57284, 57289], 57291],
      55351: [[57088, 57097], [57099, 57118], [57125, 57130]],
      55354: [[56610, 56643]]
    };
    exports.unicodeLt = [453, 456, 459, 498, [8072, 8079], [8088, 8095], [8104, 8111], 8124, 8140, 8188];
    exports.unicodeLo = [170, 186, 443, [448, 451], 660, [1488, 1514], [1519, 1522], [1568, 1599], [1601, 1610], [1646, 1647], [1649, 1747], 1749, [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2048, 2069], [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2248], [2308, 2361], 2365, 2384, [2392, 2401], [2418, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3585, 3632], [3634, 3635], [3648, 3653], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], 4159, [4176, 4181], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4352, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5873, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6000], [6016, 6067], 6108, [6176, 6210], [6212, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7287], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [8501, 8504], [11568, 11623], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], 12294, 12348, [12353, 12438], 12447, [12449, 12538], 12543, [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 40980], [40982, 42124], [42192, 42231], [42240, 42507], [42512, 42527], [42538, 42539], 42606, [42656, 42725], 42895, 42999, [43003, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], [43488, 43492], [43495, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43631], [43633, 43638], 43642, [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43740], [43744, 43754], 43762, [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43968, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65382, 65391], [65393, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66368], [66370, 66377], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66640, 66717], [66816, 66855], [66864, 66915], [67008, 67059], [67072, 67382], [67392, 67413], [67424, 67431], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68864, 68899], [68938, 68941], 68943, [69248, 69289], [69296, 69297], [69314, 69316], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70528, 70537], 70539, 70542, [70544, 70581], 70583, 70609, 70611, [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71424, 71450], [71488, 71494], [71680, 71723], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72640, 72672], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [78944, 82938], [82944, 83526], [90368, 90397], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [93027, 93047], [93053, 93071], [93507, 93546], [93952, 94026], 94032, [94208, 100343], [100352, 101589], [101631, 101640], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 122634, [123136, 123180], 123214, [123536, 123565], [123584, 123627], [124112, 124138], [124368, 124397], 124400, [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [191472, 192093], [194560, 195101], [196608, 201546], [201552, 205743]];
    exports.unicodeLoSurrogate = {
      55296: [[56320, 56331], [56333, 56358], [56360, 56378], [56380, 56381], [56383, 56397], [56400, 56413], [56448, 56570], [56960, 56988], [56992, 57040], [57088, 57119], [57133, 57152], [57154, 57161], [57168, 57205], [57216, 57245], [57248, 57283], [57288, 57295]],
      55297: [[56400, 56477], [56576, 56615], [56624, 56675], [56768, 56819], [56832, 57142], [57152, 57173], [57184, 57191]],
      55298: [[56320, 56325], 56328, [56330, 56373], [56375, 56376], 56380, [56383, 56405], [56416, 56438], [56448, 56478], [56544, 56562], [56564, 56565], [56576, 56597], [56608, 56633], [56704, 56759], [56766, 56767], 56832, [56848, 56851], [56853, 56855], [56857, 56885], [56928, 56956], [56960, 56988], [57024, 57031], [57033, 57060], [57088, 57141], [57152, 57173], [57184, 57202], [57216, 57233]],
      55299: [[56320, 56392], [56576, 56611], [56650, 56653], 56655, [56960, 57001], [57008, 57009], [57026, 57028], [57088, 57116], 57127, [57136, 57157], [57200, 57217], [57264, 57284], [57312, 57334]],
      55300: [[56323, 56375], [56433, 56434], 56437, [56451, 56495], [56528, 56552], [56579, 56614], 56644, 56647, [56656, 56690], 56694, [56707, 56754], [56769, 56772], 56794, 56796, [56832, 56849], [56851, 56875], [56895, 56896], [56960, 56966], 56968, [56970, 56973], [56975, 56989], [56991, 57000], [57008, 57054], [57093, 57100], [57103, 57104], [57107, 57128], [57130, 57136], [57138, 57139], [57141, 57145], 57149, 57168, [57181, 57185], [57216, 57225], 57227, 57230, [57232, 57269], 57271, 57297, 57299],
      55301: [[56320, 56372], [56391, 56394], [56415, 56417], [56448, 56495], [56516, 56517], 56519, [56704, 56750], [56792, 56795], [56832, 56879], 56900, [56960, 57002], 57016, [57088, 57114], [57152, 57158]],
      55302: [[56320, 56363], [56575, 56582], 56585, [56588, 56595], [56597, 56598], [56600, 56623], 56639, 56641, [56736, 56743], [56746, 56784], 56801, 56803, 56832, [56843, 56882], 56890, 56912, [56924, 56969], 56989, [57008, 57080], [57280, 57312]],
      55303: [[56320, 56328], [56330, 56366], 56384, [56434, 56463], [56576, 56582], [56584, 56585], [56587, 56624], 56646, [56672, 56677], [56679, 56680], [56682, 56713], 56728, [57056, 57074], 57090, [57092, 57104], [57106, 57139], 57264],
      55304: [[56320, 57241]],
      55305: [[56448, 56643]],
      55307: [[57232, 57328]],
      55308: [[56320, 57343]],
      55309: [[56320, 56367], [56385, 56390], [56416, 57343]],
      55310: [[56320, 57343]],
      55311: [[56320, 57343]],
      55312: [[56320, 57338]],
      55313: [[56320, 56902]],
      55320: [[56576, 56605]],
      55322: [[56320, 56888], [56896, 56926], [56944, 57022], [57040, 57069], [57088, 57135], [57187, 57207], [57213, 57231]],
      55323: [[56643, 56682], [57088, 57162], 57168],
      55324: [[56320, 57343]],
      55325: [[56320, 57343]],
      55326: [[56320, 57343]],
      55327: [[56320, 57343]],
      55328: [[56320, 57343]],
      55329: [[56320, 57335]],
      55330: [[56320, 57343]],
      55331: [[56320, 56533], [56575, 56584]],
      55340: [[56320, 56610], 56626, [56656, 56658], 56661, [56676, 56679], [56688, 57083]],
      55343: [[56320, 56426], [56432, 56444], [56448, 56456], [56464, 56473]],
      55351: [57098],
      55352: [[56576, 56620], 56654, [56976, 57005], [57024, 57067]],
      55353: [[56528, 56554], [56784, 56813], 56816, [57312, 57318], [57320, 57323], [57325, 57326], [57328, 57342]],
      55354: [[56320, 56516]],
      55355: [[56832, 56835], [56837, 56863], [56865, 56866], 56868, 56871, [56873, 56882], [56884, 56887], 56889, 56891, 56898, 56903, 56905, 56907, [56909, 56911], [56913, 56914], 56916, 56919, 56921, 56923, 56925, 56927, [56929, 56930], 56932, [56935, 56938], [56940, 56946], [56948, 56951], [56953, 56956], 56958, [56960, 56969], [56971, 56987], [56993, 56995], [56997, 57001], [57003, 57019]],
      55360: [[56320, 57343]],
      55361: [[56320, 57343]],
      55362: [[56320, 57343]],
      55363: [[56320, 57343]],
      55364: [[56320, 57343]],
      55365: [[56320, 57343]],
      55366: [[56320, 57343]],
      55367: [[56320, 57343]],
      55368: [[56320, 57343]],
      55369: [[56320, 57343]],
      55370: [[56320, 57343]],
      55371: [[56320, 57343]],
      55372: [[56320, 57343]],
      55373: [[56320, 57343]],
      55374: [[56320, 57343]],
      55375: [[56320, 57343]],
      55376: [[56320, 57343]],
      55377: [[56320, 57343]],
      55378: [[56320, 57343]],
      55379: [[56320, 57343]],
      55380: [[56320, 57343]],
      55381: [[56320, 57343]],
      55382: [[56320, 57343]],
      55383: [[56320, 57343]],
      55384: [[56320, 57343]],
      55385: [[56320, 57343]],
      55386: [[56320, 57343]],
      55387: [[56320, 57343]],
      55388: [[56320, 57343]],
      55389: [[56320, 57343]],
      55390: [[56320, 57343]],
      55391: [[56320, 57343]],
      55392: [[56320, 57343]],
      55393: [[56320, 57343]],
      55394: [[56320, 57343]],
      55395: [[56320, 57343]],
      55396: [[56320, 57343]],
      55397: [[56320, 57343]],
      55398: [[56320, 57343]],
      55399: [[56320, 57343]],
      55400: [[56320, 57343]],
      55401: [[56320, 57055], [57088, 57343]],
      55402: [[56320, 57343]],
      55403: [[56320, 57343]],
      55404: [[56320, 57343]],
      55405: [[56320, 57145], [57152, 57343]],
      55406: [[56320, 56349], [56352, 57343]],
      55407: [[56320, 57343]],
      55408: [[56320, 57343]],
      55409: [[56320, 57343]],
      55410: [[56320, 57343]],
      55411: [[56320, 56993], [57008, 57343]],
      55412: [[56320, 57343]],
      55413: [[56320, 57343]],
      55414: [[56320, 57343]],
      55415: [[56320, 57343]],
      55416: [[56320, 57343]],
      55417: [[56320, 57343]],
      55418: [[56320, 57312], [57328, 57343]],
      55419: [[56320, 56925]],
      55422: [[56320, 56861]],
      55424: [[56320, 57343]],
      55425: [[56320, 57343]],
      55426: [[56320, 57343]],
      55427: [[56320, 57343]],
      55428: [[56320, 57162], [57168, 57343]],
      55429: [[56320, 57343]],
      55430: [[56320, 57343]],
      55431: [[56320, 57343]],
      55432: [[56320, 57263]]
    };
    exports.unicodeLm = [[688, 705], [710, 721], [736, 740], 748, 750, 884, 890, 1369, 1600, [1765, 1766], [2036, 2037], 2042, 2074, 2084, 2088, 2249, 2417, 3654, 3782, 4348, 6103, 6211, 6823, [7288, 7293], [7468, 7530], 7544, [7579, 7615], 8305, 8319, [8336, 8348], [11388, 11389], 11631, 11823, 12293, [12337, 12341], 12347, [12445, 12446], [12540, 12542], 40981, [42232, 42237], 42508, 42623, [42652, 42653], [42775, 42783], 42864, 42888, [42994, 42996], [43000, 43001], 43471, 43494, 43632, 43741, [43763, 43764], [43868, 43871], 43881, 65392, [65438, 65439], [67456, 67461], [67463, 67504], [67506, 67514], 68942, 68975, [92992, 92995], [93504, 93506], [93547, 93548], [94099, 94111], [94176, 94177], 94179, [110576, 110579], [110581, 110587], [110589, 110590], [122928, 122989], [123191, 123197], 124139, 125259];
    exports.unicodeLmSurrogate = {
      55297: [[57216, 57221], [57223, 57264], [57266, 57274]],
      55299: [56654, 56687],
      55322: [[57152, 57155]],
      55323: [[56640, 56642], [56683, 56684], [57235, 57247], [57312, 57313], 57315],
      55339: [[57328, 57331], [57333, 57339], [57341, 57342]],
      55352: [[56368, 56429], [56631, 56637]],
      55353: [56555],
      55354: [56651]
    };
    exports.unicodeNl = [[5870, 5872], [8544, 8578], [8581, 8584], 12295, [12321, 12329], [12344, 12346], [42726, 42735], [65856, 65908], 66369, 66378, [66513, 66517], [74752, 74862]];
    exports.unicodeNlSurrogate = {
      55296: [[56640, 56692], 57153, 57162, [57297, 57301]],
      55305: [[56320, 56430]]
    };
    exports.unicodeMn = [[768, 879], [1155, 1159], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2199, 2207], [2250, 2273], [2275, 2306], 2362, 2364, [2369, 2376], 2381, [2385, 2391], [2402, 2403], 2433, 2492, [2497, 2500], 2509, [2530, 2531], 2558, [2561, 2562], 2620, [2625, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2690], 2748, [2753, 2757], [2759, 2760], 2765, [2786, 2787], [2810, 2815], 2817, 2876, 2879, [2881, 2884], 2893, [2901, 2902], [2914, 2915], 2946, 3008, 3021, 3072, 3076, 3132, [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], 3201, 3260, 3263, 3270, [3276, 3277], [3298, 3299], [3328, 3329], [3387, 3388], [3393, 3396], 3405, [3426, 3427], 3457, 3530, [3538, 3540], 3542, 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], 4226, [4229, 4230], 4237, 4253, [4957, 4959], [5906, 5908], [5938, 5939], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], 6086, [6089, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6434], [6439, 6440], 6450, [6457, 6459], [6679, 6680], 6683, 6742, [6744, 6750], 6752, 6754, [6757, 6764], [6771, 6780], 6783, [6832, 6845], [6847, 6862], [6912, 6915], 6964, [6966, 6970], 6972, 6978, [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], 7142, [7144, 7145], 7149, [7151, 7153], [7212, 7219], [7222, 7223], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7616, 7679], [8400, 8412], 8417, [8421, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12333], [12441, 12442], 42607, [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43045, 43046], 43052, [43204, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43345], [43392, 43394], 43443, [43446, 43449], [43452, 43453], 43493, [43561, 43566], [43569, 43570], [43573, 43574], 43587, 43596, 43644, 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43756, 43757], 43766, 44005, 44008, 44013, 64286, [65024, 65039], [65056, 65071], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [68969, 68973], [69291, 69292], [69372, 69375], [69446, 69456], [69506, 69509], 69633, [69688, 69702], 69744, [69747, 69748], [69759, 69761], [69811, 69814], [69817, 69818], 69826, [69888, 69890], [69927, 69931], [69933, 69940], 70003, [70016, 70017], [70070, 70078], [70089, 70092], 70095, [70191, 70193], 70196, [70198, 70199], 70206, 70209, 70367, [70371, 70378], [70400, 70401], [70459, 70460], 70464, [70502, 70508], [70512, 70516], [70587, 70592], 70606, 70608, 70610, [70625, 70626], [70712, 70719], [70722, 70724], 70726, 70750, [70835, 70840], 70842, [70847, 70848], [70850, 70851], [71090, 71093], [71100, 71101], [71103, 71104], [71132, 71133], [71219, 71226], 71229, [71231, 71232], 71339, 71341, [71344, 71349], 71351, 71453, 71455, [71458, 71461], [71463, 71467], [71727, 71735], [71737, 71738], [71995, 71996], 71998, 72003, [72148, 72151], [72154, 72155], 72160, [72193, 72202], [72243, 72248], [72251, 72254], 72263, [72273, 72278], [72281, 72283], [72330, 72342], [72344, 72345], [72752, 72758], [72760, 72765], 72767, [72850, 72871], [72874, 72880], [72882, 72883], [72885, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73104, 73105], 73109, 73111, [73459, 73460], [73472, 73473], [73526, 73530], 73536, 73538, 73562, 78912, [78919, 78933], [90398, 90409], [90413, 90415], [92912, 92916], [92976, 92982], 94031, [94095, 94098], 94180, [113821, 113822], [118528, 118573], [118576, 118598], [119143, 119145], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [124398, 124399], [125136, 125142], [125252, 125258], [917760, 917999]];
    exports.unicodeMnSurrogate = {
      55296: [56829, 57056, [57206, 57210]],
      55298: [[56833, 56835], [56837, 56838], [56844, 56847], [56888, 56890], 56895, [57061, 57062]],
      55299: [[56612, 56615], [56681, 56685], [57003, 57004], [57084, 57087], [57158, 57168], [57218, 57221]],
      55300: [56321, [56376, 56390], 56432, [56435, 56436], [56447, 56449], [56499, 56502], [56505, 56506], 56514, [56576, 56578], [56615, 56619], [56621, 56628], 56691, [56704, 56705], [56758, 56766], [56777, 56780], 56783, [56879, 56881], 56884, [56886, 56887], 56894, 56897, 57055, [57059, 57066], [57088, 57089], [57147, 57148], 57152, [57190, 57196], [57200, 57204], [57275, 57280], 57294, 57296, 57298, [57313, 57314]],
      55301: [[56376, 56383], [56386, 56388], 56390, 56414, [56499, 56504], 56506, [56511, 56512], [56514, 56515], [56754, 56757], [56764, 56765], [56767, 56768], [56796, 56797], [56883, 56890], 56893, [56895, 56896], 57003, 57005, [57008, 57013], 57015, 57117, 57119, [57122, 57125], [57127, 57131]],
      55302: [[56367, 56375], [56377, 56378], [56635, 56636], 56638, 56643, [56788, 56791], [56794, 56795], 56800, [56833, 56842], [56883, 56888], [56891, 56894], 56903, [56913, 56918], [56921, 56923], [56970, 56982], [56984, 56985]],
      55303: [[56368, 56374], [56376, 56381], 56383, [56466, 56487], [56490, 56496], [56498, 56499], [56501, 56502], [56625, 56630], 56634, [56636, 56637], [56639, 56645], 56647, [56720, 56721], 56725, 56727, [57075, 57076], [57088, 57089], [57142, 57146], 57152, 57154, 57178],
      55309: [56384, [56391, 56405]],
      55320: [[56606, 56617], [56621, 56623]],
      55322: [[57072, 57076], [57136, 57142]],
      55323: [57167, [57231, 57234], 57316],
      55343: [[56477, 56478]],
      55347: [[57088, 57133], [57136, 57158]],
      55348: [[56679, 56681], [56699, 56706], [56709, 56715], [56746, 56749], [56898, 56900]],
      55350: [[56832, 56886], [56891, 56940], 56949, 56964, [56987, 56991], [56993, 57007]],
      55352: [[56320, 56326], [56328, 56344], [56347, 56353], [56355, 56356], [56358, 56362], 56463, [56624, 56630], 57006, [57068, 57071]],
      55353: [[56556, 56559], [56814, 56815]],
      55354: [[56528, 56534], [56644, 56650]],
      56128: [[56576, 56815]]
    };
    exports.unicodeMc = [2307, 2363, [2366, 2368], [2377, 2380], [2382, 2383], [2434, 2435], [2494, 2496], [2503, 2504], [2507, 2508], 2519, 2563, [2622, 2624], 2691, [2750, 2752], 2761, [2763, 2764], [2818, 2819], 2878, 2880, [2887, 2888], [2891, 2892], 2903, [3006, 3007], [3009, 3010], [3014, 3016], [3018, 3020], 3031, [3073, 3075], [3137, 3140], [3202, 3203], 3262, [3264, 3268], [3271, 3272], [3274, 3275], [3285, 3286], 3315, [3330, 3331], [3390, 3392], [3398, 3400], [3402, 3404], 3415, [3458, 3459], [3535, 3537], [3544, 3551], [3570, 3571], [3902, 3903], 3967, [4139, 4140], 4145, 4152, [4155, 4156], [4182, 4183], [4194, 4196], [4199, 4205], [4227, 4228], [4231, 4236], 4239, [4250, 4252], 5909, 5940, 6070, [6078, 6085], [6087, 6088], [6435, 6438], [6441, 6443], [6448, 6449], [6451, 6456], [6681, 6682], 6741, 6743, 6753, [6755, 6756], [6765, 6770], 6916, 6965, 6971, [6973, 6977], [6979, 6980], 7042, 7073, [7078, 7079], 7082, 7143, [7146, 7148], 7150, [7154, 7155], [7204, 7211], [7220, 7221], 7393, 7415, [12334, 12335], [43043, 43044], 43047, [43136, 43137], [43188, 43203], [43346, 43347], 43395, [43444, 43445], [43450, 43451], [43454, 43456], [43567, 43568], [43571, 43572], 43597, 43643, 43645, 43755, [43758, 43759], 43765, [44003, 44004], [44006, 44007], [44009, 44010], 44012, 69632, 69634, 69762, [69808, 69810], [69815, 69816], 69932, [69957, 69958], 70018, [70067, 70069], [70079, 70080], 70094, [70188, 70190], [70194, 70195], 70197, [70368, 70370], [70402, 70403], [70462, 70463], [70465, 70468], [70471, 70472], [70475, 70477], 70487, [70498, 70499], [70584, 70586], 70594, 70597, [70599, 70602], [70604, 70605], 70607, [70709, 70711], [70720, 70721], 70725, [70832, 70834], 70841, [70843, 70846], 70849, [71087, 71089], [71096, 71099], 71102, [71216, 71218], [71227, 71228], 71230, 71340, [71342, 71343], 71350, 71454, [71456, 71457], 71462, [71724, 71726], 71736, [71984, 71989], [71991, 71992], 71997, 72000, 72002, [72145, 72147], [72156, 72159], 72164, 72249, [72279, 72280], 72343, 72751, 72766, 72873, 72881, 72884, [73098, 73102], [73107, 73108], 73110, [73461, 73462], 73475, [73524, 73525], [73534, 73535], 73537, [90410, 90412], [94033, 94087], [94192, 94193], [119141, 119142], [119149, 119154]];
    exports.unicodeMcSurrogate = {
      55300: [56320, 56322, 56450, [56496, 56498], [56503, 56504], 56620, [56645, 56646], 56706, [56755, 56757], [56767, 56768], 56782, [56876, 56878], [56882, 56883], 56885, [57056, 57058], [57090, 57091], [57150, 57151], [57153, 57156], [57159, 57160], [57163, 57165], 57175, [57186, 57187], [57272, 57274], 57282, 57285, [57287, 57290], [57292, 57293], 57295],
      55301: [[56373, 56375], [56384, 56385], 56389, [56496, 56498], 56505, [56507, 56510], 56513, [56751, 56753], [56760, 56763], 56766, [56880, 56882], [56891, 56892], 56894, 57004, [57006, 57007], 57014, 57118, [57120, 57121], 57126],
      55302: [[56364, 56366], 56376, [56624, 56629], [56631, 56632], 56637, 56640, 56642, [56785, 56787], [56796, 56799], 56804, 56889, [56919, 56920], 56983],
      55303: [56367, 56382, 56489, 56497, 56500, [56714, 56718], [56723, 56724], 56726, [57077, 57078], 57091, [57140, 57141], [57150, 57151], 57153],
      55320: [[56618, 56620]],
      55323: [[57169, 57223], [57328, 57329]],
      55348: [[56677, 56678], [56685, 56690]]
    };
    exports.unicodeNd = [[48, 57], [1632, 1641], [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2662, 2671], [2790, 2799], [2918, 2927], [3046, 3055], [3174, 3183], [3302, 3311], [3430, 3439], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3881], [4160, 4169], [4240, 4249], [6112, 6121], [6160, 6169], [6470, 6479], [6608, 6617], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], [42528, 42537], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [65296, 65305], [66720, 66729], [68912, 68921], [68928, 68937], [69734, 69743], [69872, 69881], [69942, 69951], [70096, 70105], [70384, 70393], [70736, 70745], [70864, 70873], [71248, 71257], [71360, 71369], [71376, 71395], [71472, 71481], [71904, 71913], [72016, 72025], [72688, 72697], [72784, 72793], [73040, 73049], [73120, 73129], [73552, 73561], [90416, 90425], [92768, 92777], [92864, 92873], [93008, 93017], [93552, 93561], [118000, 118009], [120782, 120831], [123200, 123209], [123632, 123641], [124144, 124153], [124401, 124410], [125264, 125273], [130032, 130041]];
    exports.unicodeNdSurrogate = {
      55297: [[56480, 56489]],
      55299: [[56624, 56633], [56640, 56649]],
      55300: [[56422, 56431], [56560, 56569], [56630, 56639], [56784, 56793], [57072, 57081]],
      55301: [[56400, 56409], [56528, 56537], [56912, 56921], [57024, 57033], [57040, 57059], [57136, 57145]],
      55302: [[56544, 56553], [56656, 56665], [57328, 57337]],
      55303: [[56400, 56409], [56656, 56665], [56736, 56745], [57168, 57177]],
      55320: [[56624, 56633]],
      55322: [[56928, 56937], [57024, 57033], [57168, 57177]],
      55323: [[56688, 56697]],
      55347: [[56560, 56569]],
      55349: [[57294, 57343]],
      55352: [[56640, 56649], [57072, 57081]],
      55353: [[56560, 56569], [56817, 56826]],
      55354: [[56656, 56665]],
      55358: [[57328, 57337]]
    };
    exports.unicodePc = [95, [8255, 8256], 8276, [65075, 65076], [65101, 65103], 65343];
  },
  62226: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.PyrightFileSystem = exports.SupportPartialStubs = undefined;
    const a = require(92031);
    const r = require(4883);
    const s = require(5884);
    const i = require(86789);
    var o;
    (function (e) {
      e.is = function (e) {
        return e.isPartialStubPackagesScanned && e.isPathScanned && e.processPartialStubPackages && e.clearPartialStubs;
      };
    })(o || (exports.SupportPartialStubs = o = {}));
    class l extends i.ReadOnlyAugmentedFileSystem {
      constructor(e) {
        super(e);
        this._rootSearched = new Set();
        this._partialStubPackagePaths = new Set();
      }
      mkdirSync(e, t) {
        this.realFS.mkdirSync(e, t);
      }
      chdir(e) {
        this.realFS.chdir(e);
      }
      writeFileSync(e, t, n) {
        this.realFS.writeFileSync(this.getOriginalPath(e), t, n);
      }
      rmdirSync(e) {
        this.realFS.rmdirSync(this.getOriginalPath(e));
      }
      unlinkSync(e) {
        this.realFS.unlinkSync(this.getOriginalPath(e));
      }
      createWriteStream(e) {
        return this.realFS.createWriteStream(this.getOriginalPath(e));
      }
      copyFileSync(e, t) {
        this.realFS.copyFileSync(this.getOriginalPath(e), this.getOriginalPath(t));
      }
      isPartialStubPackagesScanned(e) {
        return !!e.root && this.isPathScanned(e.root);
      }
      isPathScanned(e) {
        return this._rootSearched.has(e.key);
      }
      processPartialStubPackages(e, t, n, i) {
        var o;
        const l = i ?? this._allowMoving.bind(this);
        for (const i of e) {
          this._rootSearched.add(i.key);
          if (!this.realFS.existsSync(i) || !s.isDirectory(this.realFS, i)) {
            continue;
          }
          let e = [];
          try {
            e = this.realFS.readdirEntriesSync(i);
          } catch {}
          const p = i.equals(n);
          for (const n of e) {
            const e = i.combinePaths(n.name);
            if (!(n.isSymbolicLink() ? !!((o = s.tryStat(this.realFS, e)) === null || o === undefined ? undefined : o.isDirectory()) : n.isDirectory()) || !n.name.endsWith(r.stubsSuffix)) {
              continue;
            }
            const d = a.getPyTypedInfo(this.realFS, e);
            if (!d || !d.isPartiallyTyped) {
              continue;
            }
            let c;
            this._partialStubPackagePaths.add(e.key);
            const u = n.name.substr(0, n.name.length - r.stubsSuffix.length);
            for (const n of t) {
              const t = n.combinePaths(u);
              try {
                const n = s.tryStat(this.realFS, t);
                if (!(n == null ? undefined : n.isDirectory())) {
                  continue;
                }
                if (!l(p, a.getPyTypedInfo(this.realFS, t), d)) {
                  continue;
                }
                c = c ?? this._getRelativePathPartialStubs(e);
                for (const n of c) {
                  const a = e.resolvePaths(n);
                  const r = t.resolvePaths(n);
                  this.recordMovedEntry(r, a, t);
                }
              } catch {}
            }
          }
        }
      }
      clearPartialStubs() {
        super.clear();
        this._rootSearched.clear();
        this._partialStubPackagePaths.clear();
      }
      isMovedEntry(e) {
        return this._partialStubPackagePaths.has(e.key) || super.isMovedEntry(e);
      }
      _allowMoving(e, t, n) {
        return !e || !t || t.isPartiallyTyped;
      }
      _getRelativePathPartialStubs(e) {
        const t = [];
        const n = a => {
          for (const r of this.realFS.readdirEntriesSync(a)) {
            const i = a.combinePaths(r.name);
            let o = r.isDirectory();
            let l = r.isFile();
            if (r.isSymbolicLink()) {
              const e = s.tryStat(this.realFS, i);
              if (e) {
                o = e.isDirectory();
                l = e.isFile();
              }
            }
            if (o) {
              n(i);
            }
            if (l && r.name.endsWith('.pyi')) {
              const n = e.getRelativePathComponents(i).join('/');
              if (n) {
                t.push(n);
              }
            }
          }
        };
        n(e);
        return t;
      }
    }
    exports.PyrightFileSystem = l;
  },
  86789: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.ReadOnlyAugmentedFileSystem = undefined;
    const a = require(58147);
    const r = require(66643);
    exports.ReadOnlyAugmentedFileSystem = class {
      constructor(e) {
        this.realFS = e;
        this._entryMap = new Map();
        this._reverseEntryMap = new Map();
        this._folderMap = new Map();
      }
      existsSync(e) {
        return !this.isMovedEntry(e) && this.realFS.existsSync(this.getOriginalPath(e));
      }
      mkdirSync(e, t) {
        throw new Error('Operation is not allowed.');
      }
      chdir(e) {
        throw new Error('Operation is not allowed.');
      }
      readdirEntriesSync(e) {
        const t = [];
        const n = this._folderMap.get(e.key);
        if (!n || !!this.realFS.existsSync(e)) {
          a.appendArray(t, this.realFS.readdirEntriesSync(e).filter(t => !this.isMovedEntry(e.combinePaths(t.name)) && !(n == null ? undefined : n.some(e => e.name === t.name))));
        }
        if (!n) {
          return t;
        }
        const s = e.getFilePath();
        return t.concat(n.map(e => new r.VirtualDirent(e.name, e.isFile, s)));
      }
      readdirSync(e) {
        return this.readdirEntriesSync(e).map(e => e.name);
      }
      readFileSync(e, t) {
        return this.realFS.readFileSync(this.getOriginalPath(e), t);
      }
      writeFileSync(e, t, n) {
        throw new Error('Operation is not allowed.');
      }
      statSync(e) {
        return this.realFS.statSync(this.getOriginalPath(e));
      }
      rmdirSync(e) {
        throw new Error('Operation is not allowed.');
      }
      unlinkSync(e) {
        throw new Error('Operation is not allowed.');
      }
      realpathSync(e) {
        if (this._entryMap.has(e.key)) {
          return e;
        } else {
          return this.realFS.realpathSync(e);
        }
      }
      getModulePath() {
        return this.realFS.getModulePath();
      }
      createFileSystemWatcher(e, t) {
        return this.realFS.createFileSystemWatcher(e, t);
      }
      createReadStream(e) {
        return this.realFS.createReadStream(this.getOriginalPath(e));
      }
      createWriteStream(e) {
        throw new Error('Operation is not allowed.');
      }
      copyFileSync(e, t) {
        throw new Error('Operation is not allowed.');
      }
      readFile(e) {
        return this.realFS.readFile(this.getOriginalPath(e));
      }
      readFileText(e, t) {
        return this.realFS.readFileText(this.getOriginalPath(e), t);
      }
      realCasePath(e) {
        return this.realFS.realCasePath(e);
      }
      isMappedUri(e) {
        return this._entryMap.has(e.key) || this.realFS.isMappedUri(e);
      }
      getOriginalUri(e) {
        return this.realFS.getOriginalUri(this.getOriginalPath(e));
      }
      getMappedUri(e) {
        var t;
        const n = this.realFS.getMappedUri(e);
        if ((t = this._reverseEntryMap.get(n.key)) !== null && t !== undefined) {
          return t;
        } else {
          return n;
        }
      }
      isInZip(e) {
        return this.realFS.isInZip(e);
      }
      recordMovedEntry(e, t, n) {
        this._entryMap.set(e.key, t);
        this._reverseEntryMap.set(t.key, e);
        const r = e.getDirectory();
        const s = a.getOrAdd(this._folderMap, r.key, () => []);
        const i = e.fileName;
        if (!s.some(e => e.name === i)) {
          s.push({
            name: i,
            isFile: true
          });
        }
        const o = n.getRelativePathComponents(r);
        for (let e = 0; e < o.length; e++) {
          const t = n.combinePaths(...o.slice(0, e + 1));
          const r = t.getDirectory().key;
          const s = a.getOrAdd(this._folderMap, r, () => []);
          const i = t.fileName;
          if (!s.some(e => e.name === i)) {
            s.push({
              name: i,
              isFile: false
            });
          }
        }
      }
      getOriginalPath(e) {
        var t;
        if ((t = this._entryMap.get(e.key)) !== null && t !== undefined) {
          return t;
        } else {
          return e;
        }
      }
      isMovedEntry(e) {
        return this._reverseEntryMap.has(e.key);
      }
      clear() {
        this._entryMap.clear();
        this._reverseEntryMap.clear();
        this._folderMap.clear();
      }
    };
  },
  30741: (module, exports, require) => {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.WorkspaceFactory = exports.WellKnownWorkspaceKinds = undefined;
    exports.createInitStatus = o;
    exports.renameWorkspace = l;
    const a = require(51507);
    const r = require(27113);
    let s = 0;
    var i;
    function o() {
      let e = false;
      const t = a.createDeferred();
      const n = {
        promise: t.promise,
        resolve: () => {
          e = true;
          t.resolve();
        },
        markCalled: () => {
          e = true;
        },
        reset: () => e ? o() : n,
        resolved: () => t.resolved
      };
      return n;
    }
    function l(e, t) {
      e.workspaceName = t;
      e.service.setServiceName(t);
    }
    (function (e) {
      e.Default = 'default';
      e.Regular = 'regular';
      e.Limited = 'limited';
      e.Cloned = 'cloned';
      e.Test = 'test';
    })(i || (exports.WellKnownWorkspaceKinds = i = {}));
    function p(e) {
      return !!e.rootUri;
    }
    exports.WorkspaceFactory = class {
      constructor(e, t, n, a, r) {
        this._console = e;
        this._createService = t;
        this._onWorkspaceCreated = n;
        this._onWorkspaceRemoved = a;
        this._serviceProvider = r;
        this._defaultWorkspacePath = '<default>';
        this._map = new Map();
        this._id = s++;
        this._console.log(`WorkspaceFactory ${this._id} created`);
      }
      handleInitialize(e) {
        if (e.workspaceFolders) {
          e.workspaceFolders.forEach(e => {
            this._add(r.Uri.parse(e.uri, this._serviceProvider), e.name, [i.Regular]);
          });
        } else {
          if (e.rootPath) {
            this._add(r.Uri.file(e.rootPath, this._serviceProvider), '', [i.Regular]);
          }
        }
      }
      handleWorkspaceFoldersChanged(e, t) {
        var n;
        e.removed.forEach(e => {
          const t = r.Uri.parse(e.uri, this._serviceProvider);
          this.getNonDefaultWorkspaces().filter(e => e.rootUri.equals(t)).forEach(e => {
            this._remove(e);
          });
        });
        e.added.forEach(e => {
          const t = r.Uri.parse(e.uri, this._serviceProvider);
          this._add(t, e.name, [i.Regular]);
        });
        ((n = t == null ? undefined : t.filter(t => !e.added.some(e => e.uri === t.uri) && !e.removed.some(e => e.uri === t.uri))) !== null && n !== undefined ? n : []).forEach(e => {
          const t = r.Uri.parse(e.uri, this._serviceProvider);
          this.getNonDefaultWorkspaces().filter(n => n.rootUri.equals(t) && n.workspaceName !== e.name).forEach(t => l(t, e.name));
        });
      }
      items() {
        return Array.from(this._map.values());
      }
      clear() {
        this._map.forEach(e => {
          e.isInitialized.resolve();
          e.service.dispose();
        });
        this._map.clear();
        this._console.log(`WorkspaceFactory ${this._id} clear`);
      }
      hasMultipleWorkspaces(e) {
        if (this._map.size === 0 || this._map.size === 1) {
          return false;
        }
        let t = 0;
        for (const n of this._map) {
          if (!e || !!n[1].kinds.some(t => t === e)) {
            t++;
          }
          if (t > 1) {
            return true;
          }
        }
        return false;
      }
      getContainingWorkspace(e, t) {
        return this._getBestRegularWorkspace(this.getNonDefaultWorkspaces(i.Regular).filter(t => e.startsWith(t.rootUri)));
      }
      getNonDefaultWorkspaces(e) {
        const t = [];
        this._map.forEach(n => {
          if (n.rootUri) {
            if (!e || !!n.kinds.some(t => t === e)) {
              t.push(n);
            }
          }
        });
        return t;
      }
      async getWorkspaceForFile(e, t) {
        await Promise.all(this.items().map(e => e.isInitialized.promise));
        const n = await this._getOrCreateBestWorkspaceForFile(e);
        await n.isInitialized.promise;
        return n;
      }
      async getContainingWorkspacesForFile(e) {
        await Promise.all(this.items().map(e => e.isInitialized.promise));
        const t = this.items().filter(t => t.service.isTracked(e));
        if (t.length === 0) {
          t.push(this._getBestWorkspaceForFile(e));
        }
        await Promise.all(t.map(e => e.isInitialized.promise));
        return t;
      }
      _add(e, t, n) {
        const a = e ?? r.Uri.empty();
        if (!n.includes(i.Default) && !a.isLocal()) {
          n = [...n, i.Limited];
        }
        const s = {
          workspaceName: t,
          rootUri: e,
          kinds: n,
          service: this._createService(t, a, n),
          disableLanguageServices: false,
          disableTaggedHints: false,
          disableOrganizeImports: false,
          disableWorkspaceSymbol: false,
          isInitialized: o(),
          searchPathsToWatch: []
        };
        const l = this._getWorkspaceKey(s);
        this._remove(s);
        this._console.log(`WorkspaceFactory ${this._id} add ${l}`);
        this._map.set(l, s);
        this._onWorkspaceCreated(s);
        return s;
      }
      _remove(e) {
        const t = this._getWorkspaceKey(e);
        const n = this._map.get(t);
        if (n) {
          n.isInitialized.resolve();
          this._onWorkspaceRemoved(n);
          n.service.dispose();
          this._console.log(`WorkspaceFactory ${this._id} remove ${t}`);
          this._map.delete(t);
        }
      }
      _getDefaultWorkspaceKey() {
        return this._defaultWorkspacePath;
      }
      _getWorkspaceKey(e) {
        if (e.kinds.includes(i.Default)) {
          return this._getDefaultWorkspaceKey();
        } else {
          return `${e.rootUri}`;
        }
      }
      async _getOrCreateBestWorkspaceForFile(e) {
        const t = this._getBestWorkspaceForFile(e);
        await t.isInitialized.promise;
        return t;
      }
      _getBestWorkspaceForFile(e) {
        let t;
        const n = this.items().filter(t => t.service.isTracked(e)).filter(p);
        t = this._getBestRegularWorkspace(n);
        const a = this.getNonDefaultWorkspaces(i.Regular);
        if (t === undefined && a.every(t => t.rootUri.scheme === a[0].rootUri.scheme && (t.rootUri.scheme === e.scheme || e.isUntitled()) && t.rootUri.equals(a[0].rootUri))) {
          t = this._getBestRegularWorkspace(a);
        }
        if (t === undefined) {
          t = this._getBestRegularWorkspace(a.filter(t => t.service.hasSourceFile(e) && t.rootUri.scheme === e.scheme)) || t;
        }
        if (t === undefined) {
          t = this._getOrCreateDefaultWorkspace();
        }
        return t;
      }
      _getOrCreateDefaultWorkspace() {
        let e = this._map.get(this._getDefaultWorkspaceKey());
        if (!e) {
          e = this._add(undefined, this._defaultWorkspacePath, [i.Default]);
        }
        return e;
      }
      _getLongestPathWorkspace(e) {
        const t = e.reduce((e, t) => e ? t.rootUri.getPathLength() > e.getPathLength() ? t.rootUri : e : t.rootUri, r.Uri.empty());
        return e.find(e => e.rootUri.equals(t));
      }
      _getBestRegularWorkspace(e) {
        if (e.length !== 0) {
          if (e.length === 1) {
            return e[0];
          } else {
            return this._getLongestPathWorkspace(e);
          }
        }
      }
    };
  },
  73068: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Vytvoit zstupnou proceduru (Stub) typu',
        createTypeStubFor: 'Vytvoit zstupnou proceduru typu (Stub) pro modul {moduleName}',
        executingCommand: 'Spout se pkaz',
        filesToAnalyzeCount: 'Poet soubor k analze: {count}',
        filesToAnalyzeOne: '1 soubor k analze',
        findingReferences: 'Hledaj se odkazy',
        organizeImports: 'Uspodat direktivy Import',
        renameShadowedFile: 'Pejmenovat {oldFile} na {newFile}'
      },
      Completion: {
        autoImportDetail: 'Automatick import',
        indexValueDetail: 'Hodnota indexu'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Metodu {method} nelze volat, protoe je abstraktn a neimplementovan.',
        annotatedMetadataInconsistent: 'Typ metadat s poznmkami {metadataType} nen kompatibiln s typem {type}.',
        annotatedParamCountMismatch: 'Poet poznmek parametr se neshoduje: oekval(o/y) se {expected}, ale pijal(o/y) se {received}.',
        annotatedTypeArgMissing: 'Byl oekvn jeden argument typu a jedna nebo vce poznmek pro Annotated',
        annotationBytesString: 'Vrazy typu nemou pouvat etzcov literly bajt.',
        annotationFormatString: 'Vrazy typu nemou pouvat formtovac etzcov literly (f-strings).',
        annotationNotSupported: 'Poznmka typu nen pro tento pkaz podporovna',
        annotationRawString: 'Vrazy typu nemou pouvat literly nezpracovanho etzce.',
        annotationSpansStrings: 'Vrazy typu nemou zahrnovat vce etzcovch literl.',
        annotationStringEscape: 'Vrazy typu nemou obsahovat dic znaky.',
        argAssignment: 'Argument typu {argType} nen mon piadit k parametru typu {paramType}',
        argAssignmentFunction: 'Argument typu {argType} nen mon piadit k parametru typu {paramType} ve funkci {functionName}',
        argAssignmentParam: 'Argument typu {argType} nen mon piadit k parametru {paramName} typu {paramType}',
        argAssignmentParamFunction: 'Argument typu {argType} nen mon piadit k parametru {paramName} typu {paramType} ve funkci {functionName}',
        argMissingForParam: 'Chyb argument pro parametr {name}',
        argMissingForParams: 'Chyb argumenty pro parametry {names}',
        argMorePositionalExpectedCount: 'Oekval se tento poet dalch pozinch argument: {expected}',
        argMorePositionalExpectedOne: 'Oekval se 1 dal pozin argument',
        argPositional: 'Oekvan pozin argument',
        argPositionalExpectedCount: 'Oekvan poet pozinch argument: {expected}',
        argPositionalExpectedOne: 'Oekval se 1 pozin argument',
        argTypePartiallyUnknown: 'Typ argumentu je sten neznm',
        argTypeUnknown: 'Typ argumentu je neznm',
        assertAlwaysTrue: 'Vraz Assert se vdy vyhodnot jako true',
        assertTypeArgs: 'assert_type oekv dva pozin argumenty',
        assertTypeTypeMismatch: 'Neshoda assert_type: oekvalo se {expected}, ale pijalo se {received}',
        assignmentExprComprehension: 'Cl vrazu piazen {name} neme pouvat stejn nzev jako porozumn cli',
        assignmentExprContext: 'Vraz piazen mus bt uvnit modulu, funkce nebo vrazu lambda',
        assignmentExprInSubscript: 'Vrazy piazen v dolnm indexu se podporuj jenom v Pythonu 3.10 a novjm',
        assignmentInProtocol: 'Promnn instance nebo tdy v rmci tdy Protocol mus bt explicitn deklarovny v tle tdy',
        assignmentTargetExpr: 'Vraz neme bt clem piazen',
        asyncNotInAsyncFunction: 'Pouit async nen povolen mimo funkci async',
        awaitIllegal: 'Pouit opertoru await vyaduje Python 3.5 nebo novj',
        awaitNotAllowed: 'Vrazy typu nemou pouvat vraz await.',
        awaitNotInAsync: 'Opertor await je povolen jenom v rmci asynchronn funkce',
        backticksIllegal: 'V Pythonu 3.x nejsou podporovny vrazy obklopen zptnmi tekami; msto toho pouijte repr',
        baseClassCircular: 'Tda se neme odvozovat od sebe sama',
        baseClassFinal: 'Zkladn tda {type} je oznaen jako final a neme bt podtdou',
        baseClassIncompatible: 'Zkladn tdy typu {type} jsou vzjemn nekompatibiln',
        baseClassInvalid: 'Argument tdy mus bt zkladn tda',
        baseClassMethodTypeIncompatible: 'Zkladn tdy pro tdu {classType} definuj metodu {name} nekompatibilnm zpsobem',
        baseClassUnknown: 'Typ zkladn tdy je neznm, co zakrv typ odvozen tdy',
        baseClassVariableTypeIncompatible: 'Zkladn tdy pro tdu {classType} definuj promnnou {name} nekompatibilnm zpsobem',
        binaryOperationNotAllowed: 'Ve vrazu typu nen povolen binrn opertor.',
        bindTypeMismatch: 'Nepovedlo se vytvoit vazbu metody {methodName}, protoe {type} nejde piadit k parametru {paramName}',
        breakInExceptionGroup: 'V bloku except* nen povolen monost break.',
        breakOutsideLoop: 'break se d pout jenom ve smyce',
        callableExtraArgs: 'Pro Callable se oekvaly pouze dva argumenty typu',
        callableFirstArg: 'Oekval se seznam typ parametr nebo ...',
        callableNotInstantiable: 'Nen mon vytvoit instanci typu {type}',
        callableSecondArg: 'Oekval se nvratov typ jako druh argument typu pro Callable',
        casePatternIsIrrefutable: 'Nevyvratiteln vzorec je povolen jenom pro posledn vraz velikosti psmen',
        classAlreadySpecialized: 'Typ {type} je u specializovan',
        classDecoratorTypeUnknown: 'Dekoratr netypov tdy pekrv typ tdy. dekoratr se ignoruje',
        classDefinitionCycle: 'Definice tdy pro {name} zvis sama na sob',
        classGetItemClsParam: 'Pepsn __class_getitem__ by mlo mt parametr cls',
        classMethodClsParam: 'Metody tdy by mly mt parametr cls',
        classNotRuntimeSubscriptable: 'Doln index pro tdu {name} vygeneruje vjimku modulu runtime; vraz typu uzavete do uvozovek.',
        classPatternBuiltInArgPositional: 'Vzor tdy pijm pouze pozin dl vzor',
        classPatternPositionalArgCount: 'Pli mnoho pozinch vzor pro tdu "{type}"; oekvalo se {expected}, ale pijalo se {received}',
        classPatternTypeAlias: 'Typ {type} nelze pout ve vzorci tdy, protoe se jedn o specializovan alias typu',
        classPropertyDeprecated: 'Vlastnosti tdy jsou v Pythonu 3.11 zastaral a v Pythonu 3.13 se nebudou podporovat.',
        classTypeParametersIllegal: 'Syntaxe parametru typu tdy vyaduje Python 312 nebo novj',
        classVarFirstArgMissing: 'Za ClassVar byl oekvn argument typu',
        classVarNotAllowed: 'ClassVar se v tomto kontextu nepovoluje',
        classVarOverridesInstanceVar: 'Promnn tdy {name} pepe promnnou instance se stejnm nzvem ve td {className}',
        classVarTooManyArgs: 'Za ClassVar byl oekvn pouze jeden argument typu',
        classVarWithTypeVar: 'Typ ClassVar neme obsahovat promnn typu',
        clsSelfParamTypeMismatch: 'Typ parametru {name} mus bt nadtyp tdy {classType}',
        codeTooComplexToAnalyze: 'Kd je pli sloit na analzu; snite sloitost refaktorizac do podprogram nebo redukc podmnnch cest kdu',
        collectionAliasInstantiation: 'Nelze vytvoit instanci typu {type}. Pouijte msto toho {alias}',
        comparisonAlwaysFalse: 'Podmnka se vdy vyhodnot jako False, protoe typy {leftType} a {rightType} se nepekrvaj',
        comparisonAlwaysTrue: 'Podmnka se vdy vyhodnot jako True, protoe typy {leftType} a {rightType} se nepekrvaj',
        comprehensionInDict: 'Porozumn nen mon pout s jinmi polokami slovnku',
        comprehensionInSet: 'Porozumn nelze pout s jinmi polokami sady (set).',
        concatenateContext: 'Monost Concatenate nen v tomto kontextu povolen.',
        concatenateParamSpecMissing: 'Posledn argument typu pro Concatenate mus bt ParamSpec nebo ...',
        concatenateTypeArgsMissing: 'Monost Concatenate vyaduje alespo dva argumenty typu',
        conditionalOperandInvalid: 'Neplatn podmnn operand typu {type}',
        constantRedefinition: '{name} je konstanta (protoe je velkmi psmeny) a ned se pedefinovat',
        constructorParametersMismatch: 'Neshoda mezi signaturou __new__ a __init__ ve td {classType}',
        containmentAlwaysFalse: 'Vraz se vdy vyhodnot jako False, protoe typy {leftType} a {rightType} se nepekrvaj',
        containmentAlwaysTrue: 'Vraz se vdy vyhodnot jako True, protoe typy {leftType} a {rightType} se nepekrvaj.',
        continueInExceptionGroup: 'V bloku except* nen povolen monost continue.',
        continueOutsideLoop: 'continue se d pout jenom ve smyce',
        coroutineInConditionalExpression: 'Podmnn vraz odkazuje na korutinu, kter se vdy vyhodnot jako True.',
        dataClassBaseClassFrozen: 'Nezablokovan tda neme ddit z zmrazen tdy',
        dataClassBaseClassNotFrozen: 'Zablokovan tda neme ddit z tdy, kter nen zablokovan',
        dataClassConverterFunction: 'Argument typu {argType} nen platn pevad pro pole {fieldName} typu {fieldType}',
        dataClassConverterOverloads: 'dn peten {funcName} nejsou platn pevade pro pole {fieldName} typu {fieldType}',
        dataClassFieldInheritedDefault: '{fieldName} pepe pole se stejnm nzvem, ale chyb mu vchoz hodnota.',
        dataClassFieldWithDefault: 'Pole bez vchozch hodnot se nemou zobrazit po polch s vchozmi hodnotami',
        dataClassFieldWithPrivateName: 'Pole datov tdy neme pouvat privtn nzev',
        dataClassFieldWithoutAnnotation: 'Pole dataclass bez poznmky typu zpsob vjimku modulu runtime',
        dataClassPostInitParamCount: 'Datov tda __post_init__ m nesprvn poet parametr; poet pol InitVar je {expected}',
        dataClassPostInitType: 'Neshoda typu parametru metody __post_init__ datov tdy pro pole {fieldName}',
        dataClassSlotsOverwrite: '__slots__ je u ve td definovan',
        dataClassTransformExpectedBoolLiteral: 'Oekval se vraz, kter se staticky vyhodnot jako True nebo False',
        dataClassTransformFieldSpecifier: 'Oekvala se azen kolekce len (tuple) td nebo funkc, ale byl pijat typ {type}.',
        dataClassTransformPositionalParam: 'Vechny argumenty dataclass_transform mus bt argumenty klovch slov',
        dataClassTransformUnknownArgument: 'Argument {name} nen v dataclass_transform podporovn',
        dataProtocolInSubclassCheck: 'Datov protokoly (kter zahrnuj atributy bez metody) nejsou ve volnch issubclass povolen.',
        declaredReturnTypePartiallyUnknown: 'Deklarovan nvratov typ {returnType} je sten neznm',
        declaredReturnTypeUnknown: 'Deklarovan nvratov typ je neznm',
        defaultValueContainsCall: 'Voln funkc a mniteln objekty nejsou povoleny ve vrazu vchoz hodnoty parametru',
        defaultValueNotAllowed: 'Parametr s * nebo ** neme mt vchoz hodnotu',
        delTargetExpr: 'Vraz se ned odstranit',
        deprecatedClass: 'Tda {name} je zastaral',
        deprecatedConstructor: 'Konstruktor pro tdu {name} je zastaral',
        deprecatedDescriptorDeleter: 'Metoda __delete__ pro popisova {name} je zastaral',
        deprecatedDescriptorGetter: 'Metoda __get__ pro popisova {name} je zastaral',
        deprecatedDescriptorSetter: 'Metoda __set__ pro popisova {name} je zastaral',
        deprecatedFunction: 'Funkce {name} je zastaral.',
        deprecatedMethod: 'Metoda {name} ve td {className} je zastaral.',
        deprecatedPropertyDeleter: 'Metoda deleter pro property {name} je zastaral.',
        deprecatedPropertyGetter: 'Metoda getter pro property {name} je zastaral.',
        deprecatedPropertySetter: 'Metoda setter pro property {name} je zastaral.',
        deprecatedType: 'Tento typ je zastaral jako Python {version}; msto toho pouijte {replacement}',
        dictExpandIllegalInComprehension: 'Rozen slovnku nen v porozumn povoleno',
        dictInAnnotation: 'Vraz slovnku nen ve vrazu typu povolen.',
        dictKeyValuePairs: 'Poloky slovnku mus obsahovat pry kl/hodnota',
        dictUnpackIsNotMapping: 'Oekvalo se mapovn pro opertor rozbalen slovnku',
        dunderAllSymbolNotPresent: '{name} je zadno v __all__, ale v modulu se nenachz',
        duplicateArgsParam: 'Je povolen jenom jeden parametr *',
        duplicateBaseClass: 'Duplicitn zkladn tda nen povolena',
        duplicateCapturePatternTarget: 'Cl zachytvn {name} se v rmci stejnho vzoru neme vyskytovat vce ne jednou',
        duplicateCatchAll: 'Je povolena pouze jedna klauzule catch-all except',
        duplicateEnumMember: 'len Enum {name} je u deklarovan.',
        duplicateGenericAndProtocolBase: 'Je povolena pouze jedna zkladn tda Generic[...] nebo Protocol[...].',
        duplicateImport: 'Import {importName} je importovn vce ne jednou',
        duplicateKeywordOnly: 'Je povolen jenom jeden oddlova *',
        duplicateKwargsParam: 'Je povolen jenom jeden parametr **',
        duplicateParam: 'duplicitn parametr {name}',
        duplicatePositionOnly: 'Je povolen jenom jeden parametr /',
        duplicateStarPattern: 'V sekvenci vzor je povolen jenom jeden vzor *',
        duplicateStarStarPattern: 'Je povolena pouze jedna poloka **',
        duplicateUnpack: 'V seznamu (list) je povolena pouze jedna operace rozbalen.',
        ellipsisAfterUnpacked: ' nelze pout s rozbalenou kolekc TypeVarTuple nebo tuple.',
        ellipsisContext: '... se v tomto kontextu nepovoluje',
        ellipsisSecondArg: '... je povoleno pouze jako druh ze dvou argument',
        enumClassOverride: 'Tda Enum {name} je final a neme bt podtdou.',
        enumMemberDelete: 'len Enum {name} se ned odstranit.',
        enumMemberSet: 'len Enum {name} se ned piadit.',
        enumMemberTypeAnnotation: 'Poznmky typu nejsou pro leny enum povolen.',
        exceptGroupMismatch: 'Pkaz Try neme obsahovat jak except, tak i except*.',
        exceptGroupRequiresType: 'Syntaxe skupiny vjimek ("except*") vyaduje typ vjimky.',
        exceptionGroupIncompatible: 'Syntaxe skupiny vjimek ("except*") vyaduje Python 3.11 nebo novj',
        exceptionGroupTypeIncorrect: 'Typ vjimky v except* se ned odvodit z BaseGroupException.',
        exceptionTypeIncorrect: '{type} se neodvozuje od BaseException',
        exceptionTypeNotClass: '{type} nen platn tda vjimky',
        exceptionTypeNotInstantiable: 'Konstruktor pro vjimku typu {type} vyaduje jeden nebo vce argument',
        expectedAfterDecorator: 'Oekvan deklarace funkce nebo tdy po dekoratru',
        expectedArrow: 'Byl oekvn znak -> nsledovan anotac nvratovho typu',
        expectedAsAfterException: 'Za typem vjimky byl oekvn znak as',
        expectedAssignRightHandExpr: 'Byl oekvn vraz napravo od znaku =',
        expectedBinaryRightHandExpr: 'Oekval se vraz napravo od opertoru',
        expectedBoolLiteral: 'Oekvala se hodnota True nebo False',
        expectedCase: 'Oekval se pkaz case',
        expectedClassName: 'Oekval se nzev tdy',
        expectedCloseBrace: '{ nebyla uzavena',
        expectedCloseBracket: '[ nebyla uzavena',
        expectedCloseParen: '( nebyla uzavena',
        expectedColon: 'Oekval se znak :',
        expectedComplexNumberLiteral: 'Oekval se komplexn seln literl pro porovnvn vzor',
        expectedDecoratorExpr: 'Forma vrazu nen podporovna pro dekortor ped verz Python 3.9',
        expectedDecoratorName: 'Oekval se nzev dekoratru',
        expectedDecoratorNewline: 'Na konci dekoratru byl oekvn nov dek',
        expectedDelExpr: 'Za del se oekval vraz',
        expectedElse: 'Oekvalo se else',
        expectedEquals: 'Oekval se znak =',
        expectedExceptionClass: 'Neplatn tda nebo objekt vjimky',
        expectedExceptionObj: 'Byl oekvn objekt vjimky, tda vjimky nebo None',
        expectedExpr: 'Oekvan vraz',
        expectedFunctionAfterAsync: 'Oekvan definice funkce po async',
        expectedFunctionName: 'Za def se oekval nzev funkce',
        expectedIdentifier: 'Oekvan identifiktor',
        expectedImport: 'Oekval se import',
        expectedImportAlias: 'Za as byl oekvn symbol',
        expectedImportSymbols: 'Po monosti import se oekval jeden nebo vce nzv symbol.',
        expectedIn: 'Oekvalo se in',
        expectedInExpr: 'Za in byl oekvn vraz',
        expectedIndentedBlock: 'Oekval se odsazen blok',
        expectedMemberName: 'Za tekou (.) byl oekvn nzev atributu.',
        expectedModuleName: 'Oekvan nzev modulu',
        expectedNameAfterAs: 'Za as se oekval nzev symbolu',
        expectedNamedParameter: 'Parametr klovho slova mus nsledovat za znakem *',
        expectedNewline: 'Oekval se nov dek',
        expectedNewlineOrSemicolon: 'Pkazy mus bt oddlen novmi dky nebo stednky',
        expectedOpenParen: 'Oekval se znak (',
        expectedParamName: 'Oekval se nzev parametru',
        expectedPatternExpr: 'Oekvan vraz vzoru',
        expectedPatternSubjectExpr: 'Oekvan vraz pedmtu vzoru',
        expectedPatternValue: 'Oekvan vraz hodnoty vzoru ve formtu a.b',
        expectedReturnExpr: 'Za return se oekval vraz',
        expectedSliceIndex: 'Oekvan vraz indexu nebo ezu',
        expectedTypeNotString: 'Oekval se typ, ale pijal se etzcov literl',
        expectedTypeParameterName: 'Oekvan nzev parametru typu',
        expectedYieldExpr: 'Oekvan vraz v pkazu yield',
        finalClassIsAbstract: 'Tda {type} je oznaena jako final a mus implementovat vechny abstraktn symboly.',
        finalContext: 'Final se v tomto kontextu nepovoluje',
        finalInLoop: 'Promnnou Final nelze piadit ve smyce.',
        finalMethodOverride: 'Metoda {name} neme pepsat metodu final definovanou ve td {className}.',
        finalNonMethod: 'Funkci {name} nelze oznait @final, protoe se nejedn o metodu.',
        finalReassigned: '{name} se deklaruje jako Final a ned se znovu piadit',
        finalRedeclaration: '{name} se dve deklarovalo jako Final',
        finalRedeclarationBySubclass: '{name} se ned deklarovat znovu, protoe nadazen tda {className} ji deklaruje jako Final.',
        finalTooManyArgs: 'Za Final byl oekvn jeden argument typu',
        finalUnassigned: '{name} se deklaruje jako Final, ale hodnota nen piazen.',
        formatStringBrace: 'Jednoduch prav sloen zvorka nen v literlu f-string povolena. pouijte dvojitou pravou sloenou zvorku',
        formatStringBytes: 'Formtovac etzcov literly (f-strings) nemou bt binrn',
        formatStringDebuggingIllegal: 'Specifiktor ladn F-string = vyaduje Python 3.8 nebo novj',
        formatStringEscape: 'dic sekvence (zptn lomtko) nen povolen v sti vrazu f-string ped Python 3.12',
        formatStringExpectedConversion: 'V etzci f-string byl za znakem ! oekvn specifiktor pevodu',
        formatStringIllegal: 'Formtovac etzcov literly (f-string) vyaduj Python 3.6 nebo novj',
        formatStringInPattern: 'Formtovac etzec nen ve vzoru povolen',
        formatStringNestedFormatSpecifier: 'Pli hluboko vnoen vrazy v rmci specifiktoru formtovacho etzce',
        formatStringNestedQuote: 'etzce vnoen v etzci f-string nemou pouvat stejn znak uvozovek jako etzec f-string ped Python 3.12',
        formatStringUnicode: 'Formtovac etzcov literly (f-strings) nemou bt unicode',
        formatStringUnterminated: 'Neukonen vraz v f-string; oekv se }',
        functionDecoratorTypeUnknown: 'Dekortor netypov funkce pekrv typ funkce; ignoruje se dekoratr',
        functionInConditionalExpression: 'Podmnn vraz odkazuje na funkci, kter se vdy vyhodnot jako True',
        functionTypeParametersIllegal: 'Syntaxe parametru typu funkce vyaduje Python 3.12 nebo novj',
        futureImportLocationNotAllowed: 'Importy z __future__ mus bt na zatku souboru',
        generatorAsyncReturnType: 'Nvratov typ funkce asynchronnho genertoru mus bt kompatibiln s typem AsyncGenerator[{yieldType}, Any]',
        generatorNotParenthesized: 'Vrazy genertoru mus bt v zvorkch, pokud nejsou jedinm argumentem',
        generatorSyncReturnType: 'Nvratov typ funkce genertoru mus bt kompatibiln s Generator[{yieldType}, Any, Any]',
        genericBaseClassNotAllowed: 'Zkladn tdu Generic nejde pout se syntax parametru typu',
        genericClassAssigned: 'Obecn typ tdy nen mon piadit',
        genericClassDeleted: 'Obecn typ tdy nelze odstranit',
        genericInstanceVariableAccess: 'Pstup k obecn promnn instance prostednictvm tdy je nejednoznan.',
        genericNotAllowed: 'Generic nen v tomto kontextu platn',
        genericTypeAliasBoundTypeVar: 'Alias obecnho typu v rmci tdy neme pouvat promnn vzanho typu {names}',
        genericTypeArgMissing: 'Generic vyaduje alespo jeden argument typu',
        genericTypeArgTypeVar: 'Argument typu pro Generic mus bt promnn typu',
        genericTypeArgUnique: 'Argumenty typu pro Generic mus bt jedinen',
        globalReassignment: '{name} je piazen ped deklarac global.',
        globalRedefinition: 'Nzev {name} u je deklarovn jako global.',
        implicitStringConcat: 'Implicitn zetzen etzc nen povolen',
        importCycleDetected: 'V etzci importu byl zjitn cyklus',
        importDepthExceeded: 'Hloubka etzu importu pekroila {depth}',
        importResolveFailure: 'Import {importName} se nepovedlo vyeit',
        importSourceResolveFailure: 'Import {importName} se nepovedlo peloit ze zdroje',
        importSymbolUnknown: '{name} je neznm symbol importu',
        incompatibleMethodOverride: 'Metoda {name} pepisuje tdu {className} nekompatibilnm zpsobem',
        inconsistentIndent: 'Mnostv zruenho odsazen neodpovd pedchozmu odsazen',
        inconsistentTabs: 'Nekonzistentn pouit tabultor a mezer v odsazen',
        initMethodSelfParamTypeVar: 'Anotace typu pro parametr self metody __init__ neme obsahovat promnn typu s oborem tdy.',
        initMustReturnNone: 'Nvratov typ __init__ mus bt None',
        initSubclassCallFailed: 'Nesprvn argumenty klovho slova pro metodu __init_subclass__',
        initSubclassClsParam: 'Pepsn __init_subclass__ by mlo mt parametr cls',
        initVarNotAllowed: 'InitVar se v tomto kontextu nepovoluje.',
        instanceMethodSelfParam: 'Metody instance by mly mt parametr self',
        instanceVarOverridesClassVar: 'Promnn instance {name} pepe promnnou tdy se stejnm nzvem ve td {className}',
        instantiateAbstract: 'Nelze vytvoit instanci abstraktn tdy {type}',
        instantiateProtocol: 'Nelze vytvoit instanci tdy Protocol {type}.',
        internalBindError: 'Pi vytven vazby souboru {file} dolo k vnitn chyb: {message}',
        internalParseError: 'Pi analze souboru {file} dolo k vnitn chyb: {message}',
        internalTypeCheckingError: 'Pi kontrole typu souboru {file} dolo k vnitn chyb: {message}',
        invalidIdentifierChar: 'Neplatn znak v identifiktoru',
        invalidStubStatement: 'Pkaz je v souboru zstupn procedury (stub) typu bezvznamn.',
        invalidTokenChars: 'Neplatn znak {text} v tokenu',
        isInstanceInvalidType: 'Druh argument pro isinstance mus bt tda nebo azen kolekce len (tuple) td.',
        isSubclassInvalidType: 'Druh argument pro issubclass mus bt tda nebo azen kolekce len (tuple) td.',
        keyValueInSet: 'Pry kl-hodnota nejsou v rmci sady (set) povoleny.',
        keywordArgInTypeArgument: 'Argumenty klovch slov nelze pout v seznamech argument typu',
        keywordArgShortcutIllegal: 'Zstupce argumentu klovho slova vyaduje Python 3.14 nebo novj.',
        keywordOnlyAfterArgs: 'Oddlova argument jen pro klov slova nen povolen za parametrem *',
        keywordParameterMissing: 'Jeden nebo vce parametr klovho slova mus nsledovat za parametrem *',
        keywordSubscriptIllegal: 'Argumenty klovch slov v dolnch indexech nejsou podporovny',
        lambdaReturnTypePartiallyUnknown: 'Nvratov typ lambda {returnType} je sten neznm',
        lambdaReturnTypeUnknown: 'Nvratov typ vrazu lambda je neznm',
        listAssignmentMismatch: 'Vraz s typem {type} se ned piadit k clovmu seznamu',
        listInAnnotation: 'Vraz List nen ve vrazu typu povolen.',
        literalEmptyArgs: 'Za literlem (Literal) se oekval jeden nebo vce argument typu.',
        literalNamedUnicodeEscape: 'Pojmenovan dic sekvence Unicode nejsou v poznmkch etzc Literal podporovny.',
        literalNotAllowed: 'Literal nejde v tomto kontextu pout bez argumentu typu.',
        literalNotCallable: 'Nen mon vytvoit instanci typu Literal.',
        literalUnsupportedType: 'Argumenty typu pro Literal mus bt None, hodnota literlu (int, bool, str nebo bytes) nebo hodnota enum.',
        matchIncompatible: 'Pkazy match vyaduj Python 3.10 nebo novj',
        matchIsNotExhaustive: 'Ppady v rmci pkazu match nezpracovvaj kompletn vechny hodnoty',
        maxParseDepthExceeded: 'Byla pekroena maximln hloubka analzy; rozdlte vraz na dl vrazy',
        memberAccess: 'Nelze zskat pstup k atributu {name} pro tdu {type}.',
        memberDelete: 'Nelze odstranit atribut {name} pro tdu {type}.',
        memberSet: 'Nelze piadit k atributu {name} pro tdu {type}.',
        metaclassConflict: 'Metatda odvozen tdy mus bt podtdou metatd vech jejch zkladnch td',
        metaclassDuplicate: 'Je mon zadat pouze jednu metatdu',
        metaclassIsGeneric: 'Metatda neme bt obecn',
        methodNotDefined: 'Metoda {name} nen definovna',
        methodNotDefinedOnType: 'Metoda {name} nen u typu {type} definovna',
        methodOrdering: 'Nen mon vytvoit konzistentn azen metod',
        methodOverridden: '{name} pepisuje metodu se stejnm nzvem ve td {className} s nekompatibilnm typem {type}',
        methodReturnsNonObject: 'Metoda {name} nevrac objekt',
        missingSuperCall: 'Metoda {methodName} nevol metodu se stejnm nzvem v nadazen td',
        mixingBytesAndStr: 'Hodnoty bytes a str nelze zetzit.',
        moduleAsType: 'Modul nejde pout jako typ',
        moduleNotCallable: 'Modul nen volateln',
        moduleUnknownMember: '{memberName} nen znm atribut modulu {moduleName}.',
        namedExceptAfterCatchAll: 'Za klauzul catch-all except se neme objevit pojmenovan klauzule except',
        namedParamAfterParamSpecArgs: 'Parametr klovho slova {name} se neme objevit v signatue za parametrem ParamSpec args.',
        namedTupleEmptyName: 'Nzvy v pojmenovan azen kolekci len (tuple) nemou bt przdn.',
        namedTupleEntryRedeclared: '{name} nejde pepsat, protoe nadazen tda {className} je pojmenovan azen kolekce len (tuple).',
        namedTupleFirstArg: 'Jako prvn argument byl oekvn nzev pojmenovan tdy azen kolekce len (tuple).',
        namedTupleMultipleInheritance: 'Vcensobn ddinost s NamedTuple se nepodporuje',
        namedTupleNameKeyword: 'Nzvy pol nemou bt klov slovo.',
        namedTupleNameType: 'Oekvala se azen kolekce len (tuple) se dvma polokami urujc nzev a typ poloky.',
        namedTupleNameUnique: 'Nzvy v pojmenovan azen kolekci len (tuple) mus bt jedinen.',
        namedTupleNoTypes: 'namedtuple neposkytuje dn typy pro poloky azen kolekce len; msto toho pouijte NamedTuple',
        namedTupleSecondArg: 'Jako druh argument byl oekvn pojmenovan seznam (list) azen kolekce len (tuple).',
        newClsParam: 'Pepsn __new__ by mlo mt parametr cls',
        newTypeAnyOrUnknown: 'Druh argument pro NewType mus bt znm tda, nikoli Any nebo Unknown.',
        newTypeBadName: 'Prvnm argumentem pro NewType mus bt etzcov literl',
        newTypeLiteral: 'Typ NewType nen mon pout s typem Literal',
        newTypeNameMismatch: 'Typ NewType mus bt piazen promnn se stejnm nzvem.',
        newTypeNotAClass: 'Oekvan tda jako druh argument pro NewType',
        newTypeParamCount: 'NewType vyaduje dva pozin argumenty',
        newTypeProtocolClass: 'NewType nelze pout se strukturlnm typem (tda Protocol nebo TypedDict).',
        noOverload: 'Zadanm argumentm neodpovdaj dn peten pro {name}',
        noReturnContainsReturn: 'Funkce s deklarovanm nvratovm typem return type NoReturn neme obsahovat pkaz return.',
        noReturnContainsYield: 'Funkce s deklarovanm nvratovm typem NoReturn neme obsahovat pkaz yield',
        noReturnReturnsNone: 'Funkce s deklarovanm nvratovm typem NoReturn neme vrtit None.',
        nonDefaultAfterDefault: 'Nevchoz argument nsleduje za vchozm argumentem',
        nonLocalInModule: 'Deklarace Nonlocal nen povolen na rovni modulu.',
        nonLocalNoBinding: 'Nenala se dn vazba pro nonlocal {name}.',
        nonLocalReassignment: '{name} je piazeno ped deklarac nonlocal.',
        nonLocalRedefinition: '{name} ji bylo deklarovno jako nonlocal.',
        noneNotCallable: 'Objekt typu None nelze volat.',
        noneNotIterable: 'Objekt typu None nen mon pout jako iterovatelnou hodnotu',
        noneNotSubscriptable: 'Objekt typu None nelze zadat jako doln index',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Opertor {operator} se pro None nepodporuje',
        noneUnknownMember: '{name} nen znm atribut None.',
        notRequiredArgCount: 'Za NotRequired byl oekvn jeden argument typu',
        notRequiredNotInTypedDict: 'NotRequired nen v tomto kontextu povolen',
        objectNotCallable: 'Objekt typu {type} nen mon volat',
        obscuredClassDeclaration: 'Deklarace tdy {name} je zakryt deklarac stejnho jmna',
        obscuredFunctionDeclaration: 'Deklarace funkce {name} je zakryt deklarac stejnho nzvu',
        obscuredMethodDeclaration: 'Deklarace metody {name} je zakryt deklarac stejnho nzvu',
        obscuredParameterDeclaration: 'Deklarace parametru {name} je zakryt deklarac stejnho nzvu',
        obscuredTypeAliasDeclaration: 'Deklarace aliasu typu {name} je zakryt deklarac stejnho nzvu',
        obscuredVariableDeclaration: 'Deklarace {name} je zakryt deklarac stejnho nzvu',
        operatorLessOrGreaterDeprecated: 'Opertor <> se v Pythonu 3 nepodporuje; msto toho pouijte !=',
        optionalExtraArgs: 'Za nepovinnou hodnotou (Optional) se oekval jeden argument typu.',
        orPatternIrrefutable: 'Nevratn vzor je povolen jenom jako posledn dl vzorec ve vzorci or',
        orPatternMissingName: 'Vechny dl vzory v rmci vzoru or mus clit na stejn nzvy',
        overlappingKeywordArgs: 'Slovnk silnho typu se pekrv s parametrem klovho slova: {names}',
        overlappingOverload: 'Peten {obscured} pro {name} se nikdy nepouije, protoe jeho parametry se pekrvaj s petenm {obscuredBy}',
        overloadAbstractImplMismatch: 'Peten mus odpovdat abstraktnmu stavu implementace.',
        overloadAbstractMismatch: 'Bu mus bt vechna peten abstraktn, nebo naopak nesm bt dn z nich abstraktn.',
        overloadClassMethodInconsistent: 'Peten pro {name} pouvaj @classmethod nekonzistentn.',
        overloadFinalInconsistencyImpl: 'Peten pro {name} je oznaen @final ale implementace nen',
        overloadFinalInconsistencyNoImpl: 'Peten {index} pro {name} je oznaen @final ale peten 1 nen',
        overloadImplementationMismatch: 'Peten implementace nen konzistentn se signaturou peten {index}',
        overloadReturnTypeMismatch: 'Peten {prevIndex} pro {name} se pekrv s petenm {newIndex} a vrac nekompatibiln typ',
        overloadStaticMethodInconsistent: 'Peten pro {name} pouvaj @staticmethod nekonzistentn.',
        overloadWithoutImplementation: '{name} je oznaen jako peten (overload), ale nen zadan dn implementace.',
        overriddenMethodNotFound: 'Metoda {name} je oznaen jako pepsn (override), ale neexistuje dn zkladn metoda se stejnm nzvem.',
        overrideDecoratorMissing: 'Metoda {name} nen oznaen jako pepsn (override), ale pepisuje metodu ve td {className}.',
        paramAfterKwargsParam: 'Parametr neme nsledovat za parametrem **',
        paramAlreadyAssigned: 'Parametr {name} je u piazen',
        paramAnnotationMissing: 'Chyb poznmka typu pro parametr {name}',
        paramAssignmentMismatch: 'Vraz typu {sourceType} nelze piadit k parametru typu {paramType}',
        paramNameMissing: 'dn parametr s nzvem {name}',
        paramSpecArgsKwargsDuplicate: 'Argumenty pro ParamSpec {type} ji byly zadny.',
        paramSpecArgsKwargsUsage: 'Atributy args a kwargs ParamSpec se mus vyskytovat v signatue funkce.',
        paramSpecArgsMissing: 'Chyb argumenty pro parametr ParamSpec {type}',
        paramSpecArgsUsage: 'Atribut args ParamSpec je platn jenom v ppad, e se pouv s parametrem *args.',
        paramSpecAssignedName: 'Parametr ParamSpec mus bt piazen promnn s nzvem {name}',
        paramSpecContext: 'ParamSpec se v tomto kontextu nepovoluje',
        paramSpecDefaultNotTuple: 'Oekvaly se ti teky, vraz azen kolekce len (tuple) nebo ParamSpec pro vchoz hodnotu ParamSpec.',
        paramSpecFirstArg: 'Oekval se nzev parametru ParamSpec jako prvn argument',
        paramSpecKwargsUsage: 'Atribut kwargs ParamSpec je platn jenom v ppad, e se pouv s parametrem **kwargs.',
        paramSpecNotUsedByOuterScope: 'Parametr ParamSpec {name} nem v tomto kontextu dn vznam',
        paramSpecUnknownArg: 'Parametr ParamSpec nepodporuje vce ne jeden argument',
        paramSpecUnknownMember: '{name} nen znm atribut ParamSpec.',
        paramSpecUnknownParam: '{name} je neznm parametr parametru ParamSpec',
        paramTypeCovariant: 'Promnnou kovariantn typu nen mon pout v typu parametru',
        paramTypePartiallyUnknown: 'Typ parametru {paramName} je sten neznm',
        paramTypeUnknown: 'Typ parametru {paramName} je neznm',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Vzor se nikdy nebude shodovat s typem pedmtu {type}',
        positionArgAfterNamedArg: 'Pozin argument se neme objevit za argumenty klovho slova',
        positionOnlyAfterArgs: 'Oddlova parametr jen pro pozici nen povolen za parametrem *.',
        positionOnlyAfterKeywordOnly: 'Parametr / se mus zobrazit ped parametrem *',
        positionOnlyAfterNon: 'Parametr jen pro pozici nen povolen za parametrem, kter nen jen pro pozici.',
        positionOnlyFirstParam: 'Oddlova parametr jen pro pozici nen povolen jako prvn parametr.',
        positionOnlyIncompatible: 'Oddlova parametr jen pro pozici vyaduje Python 3.8 nebo novj.',
        privateImportFromPyTypedModule: '{name} se neexportuje z modulu {module}',
        privateUsedOutsideOfClass: '{name} je privtn a pouv se mimo tdu, ve kter je deklarovan',
        privateUsedOutsideOfModule: '{name} je privtn a pouv se mimo modul, ve kterm je deklarovn',
        propertyOverridden: '{name} nesprvn pepe vlastnost (property) se stejnm nzvem ve td {className}.',
        propertyStaticMethod: 'Statick metody nejsou povoleny pro metodu getter, setter nebo deleter vlastnosti (property).',
        protectedUsedOutsideOfClass: '{name} je chrnn(/o/) a pouv se mimo tdu, ve kter je deklarovan',
        protocolBaseClass: 'Tda Protocol {classType} se neme odvozovat od tdy, kter nen tdou Protocol {baseType}.',
        protocolBaseClassWithTypeArgs: 'Argumenty typu nejsou u tdy Protocol povoleny pi pouit syntaxe parametru typu',
        protocolIllegal: 'Pouit tdy Protocol vyaduje Python 3.7 nebo novj.',
        protocolNotAllowed: 'Protocol nejde v tomto kontextu pout.',
        protocolTypeArgMustBeTypeParam: 'Argument typu pro Protocol mus bt parametr typu.',
        protocolUnsafeOverlap: 'Tda se nebezpen pekrv s nzvem {name} a me vytvoit shodu pi sputn.',
        protocolVarianceContravariant: 'Promnn typu {variable} pouit v obecn td Protocol {class} by mla bt kontravariantn.',
        protocolVarianceCovariant: 'Promnn typu {variable} pouit v obecn td Protocol {class} by mla bt kovariantn.',
        protocolVarianceInvariant: 'Promnn typu {variable} pouit v obecn td Protocol {class} by mla bt invariantn.',
        pyrightCommentInvalidDiagnosticBoolValue: 'Za direktivou koment Pyright mus nsledovat znak =a hodnota true nebo false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Za direktivou koment Pyright mus nsledovat = a hodnota true, false, error, warning, information nebo none',
        pyrightCommentMissingDirective: 'Za komentem Pyright mus nsledovat direktiva (basic nebo strict) nebo diagnostick pravidlo.',
        pyrightCommentNotOnOwnLine: 'Komente Pyright pouvan k zen nastaven na rovni soubor se mus zobrazovat na vlastnm dku',
        pyrightCommentUnknownDiagnosticRule: '{rule} je neznm diagnostick pravidlo pro koment pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: '{value} je neplatn hodnota pro koment pyright; oekvalo se true, false, error, warning, information nebo none',
        pyrightCommentUnknownDirective: 'Direktiva {directive} je neznm direktiva pro koment pyright; oekvalo se strict nebo basic',
        readOnlyArgCount: 'Za ReadOnly se oekval jeden argument typu',
        readOnlyNotInTypedDict: 'ReadOnly nen v tomto kontextu povolen',
        recursiveDefinition: 'Typ {name} nelze urit, protoe odkazuje sm na sebe',
        relativeImportNotAllowed: 'Relativn importy se nedaj pout s formulem import .a; msto toho pouijte from . import a.',
        requiredArgCount: 'Za povinnm argumentem (Required) se oekval jeden argument typu.',
        requiredNotInTypedDict: 'Required nen v tomto kontextu povoleno',
        returnInAsyncGenerator: 'Pkaz Return s hodnotou nen v asynchronnm genertoru povolen',
        returnInExceptionGroup: 'V bloku except* nen povolen monost return.',
        returnMissing: 'Funkce s deklarovanm nvratovm typem {returnType} mus vracet hodnotu na vech cestch kdu',
        returnOutsideFunction: 'return se d pout jenom v rmci funkce',
        returnTypeContravariant: 'Kontravariantn promnnou typu nejde pout v nvratovm typu',
        returnTypeMismatch: 'Typ {exprType} se ned piadit k nvratovmu typu {returnType}.',
        returnTypePartiallyUnknown: 'Nvratov typ {returnType} je sten neznm',
        returnTypeUnknown: 'Nvratov typ je neznm',
        revealLocalsArgs: 'Pro voln reveal_locals se neoekvaly dn argumenty',
        revealLocalsNone: 'V tomto oboru nejsou dn mstn hodnoty (locals).',
        revealTypeArgs: 'Pro voln reveal_type byl oekvn jeden pozin argument',
        revealTypeExpectedTextArg: 'Argument expected_text pro funkci reveal_type mus bt hodnota literlu str',
        revealTypeExpectedTextMismatch: 'Neshoda typu textu; oekvan poet: {expected}, poet, kter byl pijat: {received}',
        revealTypeExpectedTypeMismatch: 'Neshoda typ; Oekval(o/y) se {expected}, ale pijal(o/y) se {received}',
        selfTypeContext: 'Self nen v tomto kontextu platn',
        selfTypeMetaclass: 'Self nelze pout v rmci metatdy (podtdy type).',
        selfTypeWithTypedSelfOrCls: 'Self nen mon pout ve funkci s parametrem self nebo cls, kter m jinou poznmku typu ne Self',
        setterGetterTypeMismatch: 'Typ hodnoty metody setter vlastnosti (property) nen mon piadit nvratovmu typu getter.',
        singleOverload: '{name} je oznaen jako peten, ale chyb dal peten',
        slotsAttributeError: '{name} nen zadan v __slots__',
        slotsClassVarConflict: '{name} je v konfliktu s promnnou instance deklarovanou v __slots__',
        starPatternInAsPattern: 'Vzor hvzdy se ned pout s clem as',
        starPatternInOrPattern: 'Vzor hvzdy neme bt ORed v jinch vzorech',
        starStarWildcardNotAllowed: '** nen mon pout se zstupnm znakem _',
        staticClsSelfParam: 'Statick metody by nemly pijmat parametr self nebo cls',
        stdlibModuleOverridden: '{path} pepisuje modul stdlib {name}',
        stringNonAsciiBytes: 'Znak jin ne ASCII nen povolen v bajtech etzcovho literlu',
        stringNotSubscriptable: 'etzcov vraz nen mon ve vrazu typu zadat jako doln index. Uzavete cel vraz do uvozovek.',
        stringUnsupportedEscape: 'Nepodporovan dic sekvence v etzcovm literlu',
        stringUnterminated: 'etzcov literl je neukonen',
        stubFileMissing: 'Soubor zstupn procedury (stub) pro {importName} se nenael.',
        stubUsesGetAttr: 'Soubor zstupn procedury (stub) typu je nepln; __getattr__ zakrv typov chyby pro modul.',
        sublistParamsIncompatible: 'Parametry sublist nejsou v Pythonu 3.x podporovan.',
        superCallArgCount: 'Pro voln super se oekvaly maximln dva argumenty',
        superCallFirstArg: 'Jako prvn argument pro voln super se oekval typ tdy, ale pijal se {type}',
        superCallSecondArg: 'Druh argument voln super mus bt objekt nebo tda odvozen z typu {type}',
        superCallZeroArgForm: 'Forma nulovho argumentu super voln je platn pouze v rmci metody.',
        superCallZeroArgFormStaticMethod: 'Forma nulovho argumentu super voln nen platn v rmci statick metody.',
        symbolIsPossiblyUnbound: '{name} je pravdpodobn nevzan',
        symbolIsUnbound: 'Nzev {name} je nevzan',
        symbolIsUndefined: '{name} nen definovan',
        symbolOverridden: '{name} pepe symbol stejnho nzvu ve td {className}',
        ternaryNotAllowed: 'Vraz ternary nen ve vrazu typu povolen.',
        totalOrderingMissingMethod: 'Tda mus definovat jednu z __lt__, __le__, __gt__ nebo __ge__, aby bylo mon pouvat total_ordering',
        trailingCommaInFromImport: 'Koncov rka nen povolena bez okolnch zvorek',
        tryWithoutExcept: 'Pkaz Try mus mt alespo jednu klauzuli except nebo finally',
        tupleAssignmentMismatch: 'Vraz s typem {type} se ned piadit clov azen kolekci len (tuple).',
        tupleInAnnotation: 'Vraz azen kolekce len (tuple) nen ve vrazu typu povolen.',
        tupleIndexOutOfRange: 'Index {index} je pro typ {type} mimo rozsah',
        typeAliasIllegalExpressionForm: 'Neplatn formul vrazu pro definici aliasu typu',
        typeAliasIsRecursiveDirect: 'Alias typu {name} neme ve sv definici pouvat sm sebe',
        typeAliasNotInModuleOrClass: 'Typ TypeAlias je mon definovat pouze v rmci oboru modulu nebo tdy',
        typeAliasRedeclared: '{name} se deklaruje jako TypeAlias a d se piadit jenom jednou.',
        typeAliasStatementBadScope: 'Pkaz type se d pout jenom v rmci oboru modulu nebo tdy.',
        typeAliasStatementIllegal: 'Pkaz alias typu vyaduje Python 3.12 nebo novj',
        typeAliasTypeBaseClass: 'Alias typu definovan v pkazu "type" nejde pout jako zkladn tdu.',
        typeAliasTypeMustBeAssigned: 'Typ TypeAliasType mus bt piazen promnn se stejnm nzvem jako alias typu',
        typeAliasTypeNameArg: 'Prvn argument TypeAliasType mus bt etzcov literl pedstavujc nzev aliasu typu.',
        typeAliasTypeNameMismatch: 'Nzev aliasu typu se mus shodovat s nzvem promnn, ke kter je piazen',
        typeAliasTypeParamInvalid: 'Seznam parametr typu mus bt azen kolekce len (tuple) obsahujc pouze TypeVar, TypeVarTuple nebo ParamSpec.',
        typeAnnotationCall: 'Vraz voln nen ve vrazu typu povolen',
        typeAnnotationVariable: 'Promnn nen ve vrazu typu povolen',
        typeAnnotationWithCallable: 'Argument typu pro type mus bt tda; volateln objekty se nepodporuj.',
        typeArgListExpected: 'Oekval se parametr ParamSpec, ti teky nebo seznam (list) typ.',
        typeArgListNotAllowed: 'Vraz seznamu (list) nen pro tento argument typu povolen.',
        typeArgsExpectingNone: 'Pro tdu {name} se neoekvaly dn argumenty typu',
        typeArgsMismatchOne: 'Oekval se jeden argument typu, ale bylo pijato {received}',
        typeArgsMissingForAlias: 'Pro alias obecnho typu {name} se oekvaly argumenty typu',
        typeArgsMissingForClass: 'Oekvan argumenty typu pro obecnou tdu {name}',
        typeArgsTooFew: 'Pro {name} se zadalo pli mlo argument typu. Oekvalo se {expected}, ale pijalo se {received}',
        typeArgsTooMany: 'Pro {name} se zadalo pli mnoho argument typu. Oekval(o/y) se {expected}, ale pijal(o/y) se {received}',
        typeAssignmentMismatch: 'Typ {sourceType} se ned piadit k deklarovanmu typu {destType}.',
        typeAssignmentMismatchWildcard: 'Symbol importu {name} m typ {sourceType}, kter se ned piadit k deklarovanmu typu {destType}.',
        typeCallNotAllowed: 'Voln type() by se nemlo pouvat ve vrazu typu.',
        typeCheckOnly: 'Nzev {name} je oznaen jako @type_check_only a d se pout jenom v poznmkch typu',
        typeCommentDeprecated: 'Pouit koment type je zastaral msto toho pout anotaci type.',
        typeExpectedClass: 'Oekvala se tda, ale byl pijat typ {type}.',
        typeFormArgs: 'TypeForm pijm jeden pozin argument.',
        typeGuardArgCount: 'Za TypeGuard nebo TypeIs byl oekvn jeden argument typu.',
        typeGuardParamCount: 'Funkce a metody ochrany typ definovan uivatelem mus mt alespo jeden vstupn parametr',
        typeIsReturnType: 'Nvratov typ TypeIs ({returnType}) nen konzistentn s typem parametru hodnoty ({type}).',
        typeNotAwaitable: '{type} nen awaitable.',
        typeNotIntantiable: 'Nen mon vytvoit instanci {type}',
        typeNotIterable: '{type} nen mon iterovat',
        typeNotSpecializable: 'Nepovedlo se specializovat typ {type}',
        typeNotSubscriptable: 'Objekt typu {type} nen mon zadat jako doln index',
        typeNotSupportBinaryOperator: 'Opertor {operator} se pro typy {leftType} a {rightType} nepodporuje',
        typeNotSupportBinaryOperatorBidirectional: 'Opertor {operator} nen podporovn pro typy {leftType} a {rightType}, pokud se oekv typ {expectedType}',
        typeNotSupportUnaryOperator: 'Opertor {operator} se pro typ {type} nepodporuje',
        typeNotSupportUnaryOperatorBidirectional: 'Opertor {operator} nen podporovn pro typ {type}, kdy oekvan typ je {expectedType}',
        typeNotUsableWith: 'Objekt typu {type} nen mon pout s typem with, protoe neimplementuje metodu {method}',
        typeParameterBoundNotAllowed: 'Vazbu nebo omezen nelze pout s parametrem variadickho typu ani s parametrem ParamSpec',
        typeParameterConstraintTuple: 'Omezen parametru typu mus bt azen kolekce len dvou nebo vce typ',
        typeParameterExistingTypeParameter: 'Parametr typu {name} se u pouv',
        typeParameterNotDeclared: 'Parametr typu {name} nen zahrnut v seznamu parametr typu pro kontejner {container}',
        typeParametersMissing: 'Mus bt zadn alespo jeden parametr typu',
        typePartiallyUnknown: 'Typ {name} je sten neznm',
        typeUnknown: 'Typ {name} je neznm',
        typeVarAssignedName: 'Typ TypeVar mus bt piazen promnn s nzvem {name}',
        typeVarAssignmentMismatch: 'Typ {type} se ned piadit promnn typu {name}',
        typeVarBoundAndConstrained: 'TypeVar neme bt souasn vzan i omezen',
        typeVarBoundGeneric: 'Vzan typ TypeVar neme bt obecn',
        typeVarConstraintGeneric: 'Typ omezen TypeVar neme bt obecn',
        typeVarDefaultBoundMismatch: 'Vchoz typ TypeVar mus bt podtyp vzanho typu',
        typeVarDefaultConstraintMismatch: 'Vchoz typ TypeVar mus bt jeden z omezench typ',
        typeVarDefaultIllegal: 'Vchoz typy promnnch typ vyaduj Python 3.13 nebo novj',
        typeVarDefaultInvalidTypeVar: 'Parametr typu {name} m vchoz typ, kter odkazuje na jednu nebo vce promnnch typu, kter jsou mimo obor',
        typeVarFirstArg: 'Oekval se nzev TypeVar jako prvn argument',
        typeVarInvalidForMemberVariable: 'Typ atributu neme pouvat promnnou typu {name} vymezenou na mstn metodu.',
        typeVarNoMember: 'TypeVar {type} nem dn atribut {name}.',
        typeVarNotSubscriptable: 'TypeVar {type} nen mon zadat jako doln index',
        typeVarNotUsedByOuterScope: 'Promnn typu {name} nem v tomto kontextu dn vznam',
        typeVarPossiblyUnsolvable: 'Promnn typu {name} me bt nevyeen, pokud volajc nezad dn argument pro parametr {param}',
        typeVarSingleConstraint: 'TypeVar mus mt alespo dva omezen typy',
        typeVarTupleConstraints: 'TypeVarTuple neme mt omezen hodnoty',
        typeVarTupleContext: 'TypeVarTuple se v tomto kontextu nepovoluje',
        typeVarTupleDefaultNotUnpacked: 'Vchoz typ TypeVarTuple mus bt rozbalen azen kolekce len (tuple) nebo TypeVarTuple.',
        typeVarTupleMustBeUnpacked: 'Pro hodnotu TypeVarTuple se vyaduje opertor rozbalen',
        typeVarTupleUnknownParam: '{name} je neznm parametr pro TypeVarTuple',
        typeVarUnknownParam: '{name} je neznm parametr pro TypeVar',
        typeVarUsedByOuterScope: 'TypeVar {name} se u pouv ve vnjm oboru',
        typeVarUsedOnlyOnce: 'TypeVar {name} se v signatue obecn funkce zobrazuje jenom jednou',
        typeVarVariance: 'TypeVar neme bt kovariantn i kontravariantn',
        typeVarWithDefaultFollowsVariadic: 'TypeVar {typeVarName} m vchoz hodnotu a neme nsledovat po TypeVarTuple {variadicName}.',
        typeVarWithoutDefault: '{name} se v seznamu parametr typu neme zobrazit za {other} , protoe nem dn vchoz typ',
        typeVarsNotInGenericOrProtocol: 'Generic[] nebo Protocol[] mus obsahovat vechny promnn typu',
        typedDictAccess: 'Nepovedlo se zskat pstup k poloce v TypedDict',
        typedDictAssignedName: 'TypedDict se mus piadit promnn s nzvem {name}.',
        typedDictBadVar: 'Tdy TypedDict mou obsahovat jenom poznmky typu',
        typedDictBaseClass: 'Vechny zkladn tdy pro tdy TypedDict mus bt tak tdami TypedDict',
        typedDictBoolParam: 'Oekvalo se, e parametr {name} bude mt hodnotu True nebo False',
        typedDictClosedExtras: 'Zkladn tda {name} je closed TypedDict; dal poloky mus bt typu {type}.',
        typedDictClosedNoExtras: 'Zkladn tda {name} je closed TypedDict; poloky navc nejsou povolen.',
        typedDictDelete: 'Nepovedlo se odstranit poloku v TypedDict',
        typedDictEmptyName: 'Nzvy v rmci TypedDict nemou bt przdn',
        typedDictEntryName: 'Oekval se etzcov literl pro nzev poloky slovnku',
        typedDictEntryUnique: 'Nzvy ve slovnku mus bt jedinen',
        typedDictExtraArgs: 'Nadbyten argumenty TypedDict nejsou podporovny',
        typedDictExtraItemsClosed: 'Objekt TypedDict nelze closed, pokud podporuje dal poloky.',
        typedDictFieldNotRequiredRedefinition: 'Poloka TypedDict {name} nejde pedefinovat jako NotRequired.',
        typedDictFieldReadOnlyRedefinition: 'Poloka TypedDict {name} nejde pedefinovat jako ReadOnly.',
        typedDictFieldRequiredRedefinition: 'Poloka TypedDict {name} nejde pedefinovat jako Required.',
        typedDictFirstArg: 'Jako prvn argument byl oekvn nzev tdy TypedDict',
        typedDictInClassPattern: 'Tda TypedDict nen ve vzoru tdy povolena.',
        typedDictInitsubclassParameter: 'TypedDict nepodporuje parametr __init_subclass__ {name}.',
        typedDictNotAllowed: 'TypedDict se v tomto kontextu ned pout.',
        typedDictSecondArgDict: 'Jako druh parametr se oekval parametr dict nebo keyword.',
        typedDictSecondArgDictEntry: 'Oekvan jednoduch poloka slovnku',
        typedDictSet: 'Nelze piadit poloku v TypedDict',
        unaccessedClass: 'Tda {name} nen pstupn',
        unaccessedFunction: 'Funkce {name} nen pstupn',
        unaccessedImport: 'Import {name} nen pstupn',
        unaccessedSymbol: '{name} nen pstupn',
        unaccessedVariable: 'Promnn {name} nen pstupn',
        unannotatedFunctionSkipped: 'Analza funkce {name} se peskoila, protoe nen oznaen',
        unaryOperationNotAllowed: 'Ve vrazu typu nen povolen unrn opertor.',
        unexpectedAsyncToken: 'Oekvalo se, e za async bude nsledovat def, with nebo for',
        unexpectedExprToken: 'Neoekvan token na konci vrazu',
        unexpectedIndent: 'Neoekvan odsazen',
        unexpectedUnindent: 'Neoekv se unindent',
        unhashableDictKey: 'Kl slovnku mus bt hashovateln',
        unhashableSetEntry: 'Poloka set mus bt hashovateln.',
        uninitializedAbstractVariables: 'Promnn definovan v abstraktn zkladn td nejsou inicializovny ve td final {classType}.',
        uninitializedInstanceVariable: 'Promnn instance {name} nen inicializovna v tle tdy nebo v metod __init__',
        unionForwardReferenceNotAllowed: 'Syntaxi Union nen mon pout s operandem etzce; pouijte uvozovky kolem celho vrazu.',
        unionSyntaxIllegal: 'Alternativn syntaxe pro sjednocen vyaduje Python 3.10 nebo novj',
        unionTypeArgCount: 'Union vyaduje dva nebo vce argument typu.',
        unionUnpackedTuple: 'Union neme obsahovat rozbalenou azenou kolekci len (tuple).',
        unionUnpackedTypeVarTuple: 'Union neme obsahovat rozbalen typ TypeVarTuple.',
        unnecessaryCast: 'Nepotebn voln cast; typ u je {type}.',
        unnecessaryIsInstanceAlways: 'Zbyten voln isinstance; {testType} je vdy instanc tdy {classType}',
        unnecessaryIsInstanceNever: 'Zbyten voln isinstance; {testType} nen nikdy instanc tdy {classType}',
        unnecessaryIsSubclassAlways: 'Nepotebn voln issubclass; {testType} je vdy podtdou tdy {classType}',
        unnecessaryIsSubclassNever: 'Zbyten voln issubclass; {testType} nen nikdy podtdou tdy {classType}',
        unnecessaryPyrightIgnore: 'Nepotebn koment # pyright: ignore',
        unnecessaryPyrightIgnoreRule: 'Nepotebn pravidlo # pyright: ignore: {name}',
        unnecessaryTypeIgnore: 'Nepotebn koment # type: ignore',
        unpackArgCount: 'Po rozbalen Unpack se oekval jeden argument typu',
        unpackExpectedTypeVarTuple: 'Jako argument typu pro Unpack byl oekvn typ TypeVarTuple nebo tuple.',
        unpackExpectedTypedDict: 'Byl oekvn argument typu TypedDict pro rozbalen Unpack',
        unpackIllegalInComprehension: 'Operace rozbalen nen v porozumn povolen',
        unpackInAnnotation: 'Ve vrazu typu nen povolen opertor rozbalen.',
        unpackInDict: 'Operace rozbalen nen ve slovncch povolena',
        unpackInSet: 'Opertor rozbalen nen v sad (set) povolen.',
        unpackNotAllowed: 'Unpack se v tomto kontextu nepovoluje.',
        unpackOperatorNotAllowed: 'Operace rozbalen nen v tomto kontextu povolen',
        unpackTuplesIllegal: 'Operace rozbalen nen povolen v azench kolekcch len ped Pythonem 3.8',
        unpackedArgInTypeArgument: 'V tomto kontextu nelze pout rozbalen argumenty.',
        unpackedArgWithVariadicParam: 'Pro parametr TypeVarTuple nejde pout rozbalen argument',
        unpackedDictArgumentNotMapping: 'Vraz argumentu za ** mus bt mapovn s typem kle str',
        unpackedDictSubscriptIllegal: 'Opertor rozbalen slovnku v dolnm indexu nen povolen',
        unpackedSubscriptIllegal: 'Opertor rozbalen v dolnm indexu vyaduje Python 3.11 nebo novj',
        unpackedTypeVarTupleExpected: 'Byl oekvn rozbalen typ TypeVarTuple; pouijte Unpack[{name1}] nebo *{name2}',
        unpackedTypedDictArgument: 'Nepovedlo se sprovat nebalen argument TypedDict s parametry',
        unreachableCode: 'Kd je nedostupn',
        unreachableCodeType: 'Analza typ indikuje, e kd nen dostupn.',
        unreachableExcept: 'Klauzule Except je nedosaiteln, protoe vjimka je ji zpracovna',
        unsupportedDunderAllOperation: 'Operace s __all__ se nepodporuje, take exportovan seznam symbol nemus bt sprvn',
        unusedCallResult: 'Vsledek vrazu voln je typu {type} a nepouv se. piadit promnn _, pokud je to zmrn',
        unusedCoroutine: 'Vsledek voln asynchronn funkce se nepouv; pouijte opertor await nebo piate vsledek promnn',
        unusedExpression: 'Hodnota vrazu se nepouv',
        varAnnotationIllegal: 'Poznmky type pro promnn vyaduj Python 3.6 nebo novj; pro kompatibilitu s pedchozmi verzemi pouijte komente type.',
        variableFinalOverride: 'Promnn {name} je oznaen jako Final a pepe promnnou non-Final se stejnm nzvem ve td {className}.',
        variadicTypeArgsTooMany: 'Seznam argument typ me mt maximln jeden rozbalen typ TypeVarTuple nebo tuple.',
        variadicTypeParamTooManyAlias: 'Alias typu me mt maximln jeden parametr typu TypeVarTuple, ale pijal nkolik ({names})',
        variadicTypeParamTooManyClass: 'Obecn tda me mt maximln jeden parametr typu TypeVarTuple, ale pijala vce ({names})',
        walrusIllegal: 'Opertor := vyaduje Python 3.8 nebo novj',
        walrusNotAllowed: 'Opertor := nen v tomto kontextu povolen bez okolnch zvorek',
        wildcardInFunction: 'V rmci tdy nebo funkce nen povolen import se zstupnmi znaky.',
        wildcardLibraryImport: 'Nen povolen import se zstupnmi znaky z knihovny.',
        wildcardPatternTypePartiallyUnknown: 'Typ zachycen vzorem se zstupnmi znaky je sten neznm',
        wildcardPatternTypeUnknown: 'Typ zachycen vzorem se zstupnmi znaky je neznm',
        yieldFromIllegal: 'Pouit pkazu yield from vyaduje Python 3.3 nebo novj',
        yieldFromOutsideAsync: 'yield from nen v asynchronn funkci povoleno',
        yieldOutsideFunction: 'yield nen povoleno mimo funkci nebo lambdu',
        yieldWithinComprehension: 'yield nen povolen uvnit porozumn',
        zeroCaseStatementsFound: 'Vraz shody (match) obsahovat alespo jeden vraz velikosti psmen (case).',
        zeroLengthTupleNotAllowed: 'azen kolekce len (tuple) s nulovou dlkou nen v tomto kontextu povolen.'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Speciln formul Annotated nejde pout s kontrolami instanc a td.',
        argParam: 'Argument odpovd parametru {paramName}',
        argParamFunction: 'Argument odpovd parametru {paramName} ve funkci {functionName}',
        argsParamMissing: 'Parametr *{paramName} nem dn odpovdajc parametr',
        argsPositionOnly: 'Neshoda parametr pouze s pozic; Oekval(o/y) se {expected}, ale pijal(o/y) se {received}',
        argumentType: 'Typ argumentu je {type}',
        argumentTypes: 'Typy argument: ({types})',
        assignToNone: 'Typ se ned piadit k None.',
        asyncHelp: 'Mli jste na mysli async with?',
        baseClassIncompatible: 'Zkladn tda {baseClass} nen kompatibiln s typem {type}',
        baseClassIncompatibleSubclass: 'Zkladn tda {baseClass} je odvozen od tdy {subclass}, kter nen kompatibiln s typem {type}',
        baseClassOverriddenType: 'Zkladn tda {baseClass} poskytuje typ {type}, kter je pepsn',
        baseClassOverridesType: 'Zkladn tda {baseClass} pepisuje typ {type}',
        bytesTypePromotions: 'Pokud chcete povolit chovn poven typu pro bytearray a memoryview, nastavte disableBytesTypePromotions na false',
        conditionalRequiresBool: 'Metoda __bool__ pro typ {operandType} vrac typ {boolReturnType} msto bool',
        dataClassFieldLocation: 'Deklarace pole',
        dataClassFrozen: '{name} je zablokovan',
        dataProtocolUnsupported: '{name} je datov protokol.',
        descriptorAccessBindingFailed: 'Nepovedlo se vytvoit vazbu metody {name} pro tdu popisovae {className}.',
        descriptorAccessCallFailed: 'Nepovedlo se volat metodu {name} pro tdu popisovae {className}.',
        finalMethod: 'Metoda Final',
        functionParamDefaultMissing: 'V parametru {name} chyb vchoz argument',
        functionParamName: 'Neshoda nzvu parametru: {destName} a {srcName}',
        functionParamPositionOnly: 'Neshoda parametr pouze s pozic; Parametr {name} nen jen pro pozici.',
        functionReturnTypeMismatch: 'Nvratov typ funkce {sourceType} nen kompatibiln s typem {destType}',
        functionTooFewParams: 'Funkce pijm pli mlo pozinch parametr; oekvan poet: {expected}, poet, kter byl pijat: {received}',
        functionTooManyParams: 'Funkce pijm pli mnoho pozinch parametr; oekvan poet: {expected}, poet, kter byl pijat: {received}',
        genericClassNotAllowed: 'Obecn typ s argumenty obecnho typu se pro kontroly instanc nebo td nepovoluje.',
        incompatibleDeleter: 'Metoda deleter vlastnosti (property) je nekompatibiln.',
        incompatibleGetter: 'Metoda getter vlastnosti (property) je nekompatibiln.',
        incompatibleSetter: 'Metoda setter vlastnosti (property) je nekompatibiln.',
        initMethodLocation: 'Metoda __init__ je definovna ve td {type}',
        initMethodSignature: 'Podpis __init__ je {type}',
        initSubclassLocation: 'Metoda __init_subclass__ je definovna ve td {name}.',
        invariantSuggestionDict: 'Zvate pepnut z monosti dict na monost Mapping, kter je v typu hodnoty kovariantn.',
        invariantSuggestionList: 'Zvate pepnut z monosti list na monost Sequence, kter je kovariantn.',
        invariantSuggestionSet: 'Zvate pepnut z monosti set na monost Container, kter je kovariantn.',
        isinstanceClassNotSupported: '{type} se pro kontroly instanc a td nepodporuje.',
        keyNotRequired: '{name}! nen v typu {type} povinn kl, take pstup me vst k vjimce modulu runtime',
        keyReadOnly: '{name} je kl jen pro ten v {type}',
        keyRequiredDeleted: '{name} je povinn kl a ned se odstranit',
        keyUndefined: '{name} nen definovan kl v typu {type}',
        kwargsParamMissing: 'Parametr **{paramName} nem dn odpovdajc parametr',
        listAssignmentMismatch: 'Typ {type} nen kompatibiln s clovm seznamem',
        literalAssignmentMismatch: '{sourceType} se ned piadit k typu {destType}.',
        matchIsNotExhaustiveHint: 'Pokud nen zamleno vyerpvajc zpracovn, pidejte case _: pass',
        matchIsNotExhaustiveType: 'Nezpracovan typ: {type}',
        memberAssignment: 'Vraz typu {type} nelze piadit k atributu {name} tdy {classType}.',
        memberIsAbstract: '{type}.{name} nen implementovno.',
        memberIsAbstractMore: 'a tento poet dalch: {count}...',
        memberIsClassVarInProtocol: '{name} je v protokolu definovn jako ClassVar.',
        memberIsInitVar: '{name} je pole init-only.',
        memberIsInvariant: '{name} je invariantn, protoe je promnliv',
        memberIsNotClassVarInClass: '{name} mus bt definovno jako ClassVar, aby bylo kompatibiln s protokolem.',
        memberIsNotClassVarInProtocol: '{name} nen v protokolu definovn jako ClassVar.',
        memberIsNotReadOnlyInProtocol: '{name} nen v protokolu jen pro ten.',
        memberIsReadOnlyInProtocol: '{name} je v protokolu jen pro ten.',
        memberIsWritableInProtocol: '{name} se d zapisovat do protokolu.',
        memberSetClassVar: 'Atribut {name} nelze piadit prostednictvm instance tdy, protoe jde o ClassVar.',
        memberTypeMismatch: '{name} je nekompatibiln typ',
        memberUnknown: 'Atribut {name} je neznm.',
        metaclassConflict: 'Metatda {metaclass1} je v konfliktu s metatdou {metaclass2}.',
        missingDeleter: 'Chyb metoda deleter vlastnosti (property).',
        missingGetter: 'Chyb metoda getter vlastnosti (property).',
        missingSetter: 'Chyb metoda setter vlastnosti (property).',
        namedParamMissingInDest: 'Dal parametr {name}',
        namedParamMissingInSource: 'Chyb parametr klovho slova {name}.',
        namedParamTypeMismatch: 'Parametr klovho slova {name} typu {sourceType} nen kompatibiln s typem {destType}.',
        namedTupleNotAllowed: 'NamedTuple se ned pout pro kontroly instanc nebo td.',
        newMethodLocation: 'Metoda __new__ je definovna ve td {type}',
        newMethodSignature: 'Podpis __new__ je {type}',
        newTypeClassNotAllowed: 'Tdu vytvoenou pomoc NewType nelze pout s kontrolami instanc a td.',
        noOverloadAssignable: 'Typ {type} neodpovd dn peten funkci',
        noneNotAllowed: 'Monost None se ned pout pro kontroly instanc nebo td.',
        orPatternMissingName: 'Chybjc nzvy: {name}',
        overloadIndex: 'Peten {index} je nejbli shoda.',
        overloadNotAssignable: 'Nejmn jedno peten {name} nen mon piadit',
        overloadSignature: 'Tady je definovn podpis peten',
        overriddenMethod: 'Pepsan metoda',
        overriddenSymbol: 'Pepsan symbol',
        overrideInvariantMismatch: 'Typ pepsn {overrideType}nen stejn jako zkladn typ {baseType}',
        overrideIsInvariant: 'Promnn je promnliv, take jej typ je invariantn',
        overrideNoOverloadMatches: 'Signatura peten v pepsn nen kompatibiln se zkladn metodou',
        overrideNotClassMethod: 'Zkladn metoda je deklarovna jako metoda classmethod, ale pepsn nen',
        overrideNotInstanceMethod: 'Zkladn metoda je deklarovna jako instann metoda, ale pepsn nen',
        overrideNotStaticMethod: 'Zkladn metoda je deklarovna jako staticmethod, ale pepsn nen',
        overrideOverloadNoMatch: 'Pepsn nezahrnuje vechna peten metody zkladn tdy',
        overrideOverloadOrder: 'Peten pepisovan metody mus bt ve stejnm poad jako zkladn metoda',
        overrideParamKeywordNoDefault: 'Neshoda parametru klovho slova {name}: zkladn parametr m vchoz hodnotu argumentu, parametr pro pepsn ne',
        overrideParamKeywordType: 'Neshoda typu parametru klovho slova {name}: zkladn parametr je typu {baseType}, parametr pepsn je typu {overrideType}',
        overrideParamName: 'Neshoda nzvu parametru {index}: zkladn parametr m nzev {baseName}, parametr pepsn m nzev {overrideName}',
        overrideParamNameExtra: 'V zkladu chyb parametr {name}',
        overrideParamNameMissing: 'V pepsn chyb parametr {name}',
        overrideParamNamePositionOnly: 'Neshoda parametru {index}: zkladn parametr {baseName} je parametr klovho slova, pepisujc parametr je pouze pozice',
        overrideParamNoDefault: 'Neshoda parametru {index}: Zkladn parametr m vchoz hodnotu argumentu, parametr pepsn se neshoduje.',
        overrideParamType: 'Neshoda typu parametru {index}: Zkladn parametr je typu {baseType}, parametr pepsn je typu {overrideType}.',
        overridePositionalParamCount: 'Neshoda potu pozinch parametr; Zkladn metoda m {baseCount}, ale pepsn m {overrideCount}',
        overrideReturnType: 'Neshoda nvratovho typu: Zkladn metoda vrac typ {baseType}, pepsn vrac typ {overrideType}',
        overrideType: 'Zkladn tda definuje typ jako {type}',
        paramAssignment: 'Parametr {index}: typ {sourceType} nen kompatibiln s typem {destType}.',
        paramSpecMissingInOverride: 'V metod pepsn chyb parametry ParamSpec',
        paramType: 'Typ parametru je {paramType}',
        privateImportFromPyTypedSource: 'Msto toho importovat z modulu {module}',
        propertyAccessFromProtocolClass: 'Vlastnost definovan v rmci tdy protokolu nen pstupn jako promnn tdy',
        propertyMethodIncompatible: 'Metoda vlastnosti (property) {name} nen kompatibiln.',
        propertyMethodMissing: 'V pepsn (override) chyb metoda vlastnosti (property) {name}.',
        propertyMissingDeleter: 'Vlastnost (property) {name} nem definovanou metodu deleter.',
        propertyMissingSetter: 'Vlastnost (property) {name} nem definovanou metodu setter.',
        protocolIncompatible: '{sourceType} nen kompatibiln s protokolem {destType}',
        protocolMemberMissing: '{name} nen k dispozici',
        protocolRequiresRuntimeCheckable: 'Tda Protocol mus bt @runtime_checkable, aby se pouila pi kontrolch instanc a td.',
        protocolSourceIsNotConcrete: '{sourceType} nen konkrtn typ tdy a ned se piadit k typu {destType}',
        protocolUnsafeOverlap: 'Atributy {name} maj stejn nzvy jako protokol.',
        pyrightCommentIgnoreTip: 'Pokud chcete potlait diagnostiku pro jeden dek, pouijte # pyright: ignore[<diagnostic rules>]',
        readOnlyAttribute: 'Atribut {name} je jen pro ten',
        seeClassDeclaration: 'Viz deklarace tdy',
        seeDeclaration: 'Viz deklarace',
        seeFunctionDeclaration: 'Viz deklarace funkce',
        seeMethodDeclaration: 'Viz deklarace metody',
        seeParameterDeclaration: 'Viz deklarace parametru',
        seeTypeAliasDeclaration: 'Zobrazit deklaraci aliasu typu',
        seeVariableDeclaration: 'Zobrazit deklaraci promnn',
        tupleAssignmentMismatch: 'Typ {type} nen kompatibiln s clovou azenou kolekc len (tuple).',
        tupleEntryTypeMismatch: 'Poloka azen kolekce len (tuple) {entry} je nesprvnho typu.',
        tupleSizeIndeterminateSrc: 'Neshoda velikosti azen kolekce len (tuple); oekvalo se {expected}, ale pijalo se neurit.',
        tupleSizeIndeterminateSrcDest: 'Neshoda velikosti azen kolekce len (tuple); oekvalo se min. {expected}, ale pijalo se neurit.',
        tupleSizeMismatch: 'Neshoda velikosti azen kolekce len (tuple); oekvalo se {expected}, ale pijalo se {received}.',
        tupleSizeMismatchIndeterminateDest: 'Neshoda velikosti azen kolekce len (tuple); Oekvalo se {expected}, ale pijalo se {received}.',
        typeAliasInstanceCheck: 'Alias typu vytvoen pomoc pkazu type se ned pout s kontrolami instanc a td.',
        typeAssignmentMismatch: 'Typ {sourceType} se ned piadit k typu {destType}.',
        typeBound: 'Typ {sourceType} se ned piadit k horn hranici {destType} pro promnnou typu {name}.',
        typeConstrainedTypeVar: 'Typ {type} se ned piadit k promnn omezenho typu {name}.',
        typeIncompatible: '{sourceType} se ned piadit k {destType}.',
        typeNotClass: '{type} nen tda',
        typeNotStringLiteral: '{type} nen etzcov literl',
        typeOfSymbol: 'Typ {name} je {type}',
        typeParamSpec: 'Typ {type} nen kompatibiln s parametrem ParamSpec {name}',
        typeUnsupported: 'Typ {type} nen podporovn',
        typeVarDefaultOutOfScope: 'Promnn typu {name} nen v oboru',
        typeVarIsContravariant: 'Parametr typu {name} je kontravariantn, ale {sourceType} nen nadtyp {destType}.',
        typeVarIsCovariant: 'Parametr typu {name} je kovariantn, ale {sourceType} nen podtyp {destType}.',
        typeVarIsInvariant: 'Parametr typu {name} je invariantn, ale {sourceType} nen stejn jako {destType}.',
        typeVarNotAllowed: 'TypeVar se pro kontroly instanc nebo td nepovoluje.',
        typeVarTupleRequiresKnownLength: 'Typ TypeVarTuple neme bt vzan na azenou kolekci len (tuple) neznm dlky.',
        typeVarUnnecessarySuggestion: 'Msto toho pouijte {type}.',
        typeVarUnsolvableRemedy: 'Zadejte peten, kter uruje nvratov typ, pokud argument nen zadn',
        typeVarsMissing: 'Chybjc promnn typu: {names}',
        typedDictBaseClass: 'Tda {type} nen TypedDict.',
        typedDictClassNotAllowed: 'Tda TypedDict nen povolen pro kontroly instanc nebo td.',
        typedDictClosedExtraNotAllowed: 'Do {name} nejde pidat poloku.',
        typedDictClosedExtraTypeMismatch: 'Nelze pidat poloku {name} s typem {type}.',
        typedDictClosedFieldNotRequired: 'Nelze pidat poloku {name}, protoe mus bt NotRequired.',
        typedDictExtraFieldNotAllowed: '{name} nen k dispozici v {type}',
        typedDictExtraFieldTypeMismatch: 'Typ {name} nen kompatibiln s typem extra_items v typu {type}.',
        typedDictFieldMissing: 'V {type} chyb {name}',
        typedDictFieldNotReadOnly: '{name} nen v {type} jen pro ten',
        typedDictFieldNotRequired: '{name} se v typu {type} nevyaduje',
        typedDictFieldRequired: '{name} se vyaduje v {type}',
        typedDictFieldTypeMismatch: 'Typ {type} se ned piadit k poloce {name}',
        typedDictFieldUndefined: '{name} je nedefinovan poloka v typu {type}',
        typedDictFinalMismatch: '{sourceType} nen kompatibiln s {destType} z dvodu neshody @final',
        typedDictKeyAccess: 'Pout ["{name}"] k odkazovn na poloku v TypedDict',
        typedDictNotAllowed: 'TypedDict se ned pout pro kontroly instanc nebo td.',
        unhashableType: 'Typ {type} nejde zatiovat',
        uninitializedAbstractVariable: 'Promnn instance {name} je definovan v abstraktn zkladn td {classType}, ale neinicializovala se',
        unreachableExcept: '{exceptionType} je podtdou {parentType}',
        useDictInstead: 'Oznate typ slovnku pomoc Dict[T1, T2]',
        useListInstead: 'Pouijte List[T] k oznaen typu seznamu (list) nebo Union[T1, T2] k oznaen typu sjednocen (union).',
        useTupleInstead: 'Pouijte tuple[T1, ..., Tn] k oznaen typu azen kolekce len (tuple) nebo Union[T1, T2] k oznaen typu sjednocen (union).',
        useTypeInstead: 'Msto toho pout Type[T]',
        varianceMismatchForClass: 'Odchylka argumentu typu {typeVarName} nen kompatibiln se zkladn tdou {className}',
        varianceMismatchForTypeAlias: 'Rozptyl argumentu typu {typeVarName} nen kompatibiln s typem {typeAliasParam}'
      },
      Service: {
        longOperation: 'Vet zdrojovch soubor pracovnho prostoru trv dlouho. Zvate radji oteven podsloky. [Dal informace](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  94397: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Type Stub erstellen',
        createTypeStubFor: 'Type Stub fr "{moduleName}" erstellen',
        executingCommand: 'Der Befehl wird ausgefhrt.',
        filesToAnalyzeCount: '{count} Dateien zu analysieren',
        filesToAnalyzeOne: '1 zu analysierende Datei',
        findingReferences: 'Verweise werden gesucht',
        organizeImports: 'Import-Direktiven organisieren',
        renameShadowedFile: '"{oldFile}" in "{newFile}" umbenennen'
      },
      Completion: {
        autoImportDetail: 'Autoimport',
        indexValueDetail: 'Indexwert'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Die Methode {method} kann nicht aufgerufen werden, da sie abstrakt und nicht implementiert ist.',
        annotatedMetadataInconsistent: 'Der mit Anmerkungen versehene Metadatentyp {metadataType} ist nicht mit dem Typ {type} kompatibel.',
        annotatedParamCountMismatch: 'Nicht bereinstimmende Parameteranmerkungsanzahl: {expected} erwartet, aber {received} empfangen',
        annotatedTypeArgMissing: 'Es wurde ein Typargument und mindestens eine Anmerkung fr "Annotated" erwartet.',
        annotationBytesString: 'In Typausdrcken drfen keine Bytes-Zeichenfolgenliterale verwendet werden',
        annotationFormatString: 'Typausdrcke drfen keine Formatzeichenfolgenliterale (f-strings) enthalten',
        annotationNotSupported: 'Typanmerkung wird fr diese Anweisung nicht untersttzt.',
        annotationRawString: 'Typausdrcke drfen keine unformatierten Zeichenfolgenliterale enthalten',
        annotationSpansStrings: 'Typausdrcke drfen nicht mehrere Zeichenfolgenliterale umfassen.',
        annotationStringEscape: 'Typausdrcke drfen keine Escapezeichen enthalten',
        argAssignment: 'Ein Argument vom Typ "{argType}" kann dem Parameter vom Typ "{paramType}" nicht zugewiesen werden.',
        argAssignmentFunction: 'Ein Argument vom Typ "{argType}" kann dem Parameter vom Typ "{paramType}" in der Funktion "{functionName}" nicht zugewiesen werden.',
        argAssignmentParam: 'Ein Argument vom Typ "{argType}" kann dem Parameter "{paramName}" vom Typ "{paramType}" nicht zugewiesen werden.',
        argAssignmentParamFunction: 'Ein Argument vom Typ "{argType}" kann dem Parameter "{paramName}" vom Typ "{paramType}" in der Funktion "{functionName}" nicht zugewiesen werden.',
        argMissingForParam: 'Fr Parameter {name} fehlt ein Argument.',
        argMissingForParams: 'Fehlende Argumente fr die Parameter {names}',
        argMorePositionalExpectedCount: 'Es wurden {expected} weitere Positionsargumente erwartet.',
        argMorePositionalExpectedOne: 'Es wurde 1 weiteres Positionsargument erwartet.',
        argPositional: 'Positionsargument erwartet',
        argPositionalExpectedCount: 'Es wurden {expected} Positionsargumente erwartet.',
        argPositionalExpectedOne: 'Es wurde 1 Positionsargument erwartet.',
        argTypePartiallyUnknown: 'Der Argumenttyp ist teilweise unbekannt',
        argTypeUnknown: 'Argumenttyp ist unbekannt',
        assertAlwaysTrue: 'Assertausdruck wird immer als true ausgewertet.',
        assertTypeArgs: '"assert_type" erwartet zwei Positionsargumente.',
        assertTypeTypeMismatch: '"assert_type" Konflikt: "{expected}" erwartet, aber "{received}" empfangen',
        assignmentExprComprehension: 'Ziel des Zuweisungsausdrucks "{name}" kann nicht denselben Namen wie das Verstndnis fr das Ziel verwenden.',
        assignmentExprContext: 'Der Zuweisungsausdruck muss sich innerhalb des Moduls, der Funktion oder der Lambdafunktion befinden.',
        assignmentExprInSubscript: 'Zuweisungsausdrcke innerhalb eines Tiefgestellten werden nur in Python 3.10 und hher untersttzt.',
        assignmentInProtocol: 'Instanzen- oder Klassenvariablen innerhalb einer Protocol Klasse mssen explizit innerhalb des Klassentexts deklariert werden.',
        assignmentTargetExpr: 'Der Ausdruck kann kein Zuweisungsziel sein.',
        asyncNotInAsyncFunction: 'Die Verwendung von "async" ist auerhalb einer asynchronen Funktion nicht zulssig.',
        awaitIllegal: 'Die Verwendung von "await" erfordert Python 3.5 oder hher.',
        awaitNotAllowed: 'In Typausdrcken darf await nicht verwendet werden',
        awaitNotInAsync: '"await" ist nur innerhalb einer asynchronen Funktion zulssig.',
        backticksIllegal: 'Ausdrcke, die von Backticks umgeben sind, werden in Python 3.x nicht untersttzt; verwenden Sie stattdessen repr',
        baseClassCircular: 'Die Klasse kann nicht von sich selbst abgeleitet werden.',
        baseClassFinal: 'Die Basisklasse "{type}" ist als final gekennzeichnet und kann nicht als Unterklasse verwendet werden.',
        baseClassIncompatible: 'Basisklassen von {type} sind gegenseitig inkompatibel.',
        baseClassInvalid: 'Das Argument fr die Klasse muss eine Basisklasse sein.',
        baseClassMethodTypeIncompatible: 'Basisklassen fr die Klasse "{classType}" definieren die Methode "{name}" auf inkompatible Weise.',
        baseClassUnknown: 'Der Basisklassentyp ist unbekannt, sodass der Typ der abgeleiteten Klasse verdeckt wird.',
        baseClassVariableTypeIncompatible: 'Basisklassen fr die Klasse "{classType}" definieren die Variable "{name}" auf inkompatible Weise.',
        binaryOperationNotAllowed: 'Der binrer Operator ist im Typausdruck nicht zulssig',
        bindTypeMismatch: 'Die Methode "{methodName}" konnte nicht gebunden werden, da "{type}" dem Parameter "{paramName}" nicht zugewiesen werden kann.',
        breakInExceptionGroup: 'break ist in einem except* Block nicht zulssig.',
        breakOutsideLoop: '"break" kann nur innerhalb einer Schleife verwendet werden.',
        callableExtraArgs: 'Es wurden nur zwei Typargumente fr "Callable" erwartet.',
        callableFirstArg: 'Parametertypliste oder "..." erwartet.',
        callableNotInstantiable: 'Der Typ "{type}" kann nicht instanziiert werden.',
        callableSecondArg: 'Rckgabetyp als zweites Typargument fr "Callable" erwartet',
        casePatternIsIrrefutable: 'Ein unwiderlegbares Muster ist nur fr die letzte case-Anweisung zulssig.',
        classAlreadySpecialized: 'Der Typ "{type}" ist bereits spezialisiert.',
        classDecoratorTypeUnknown: 'Der nicht typisierte Klassendekorator verdeckt den Typ der Klasse; Decorator wird ignoriert.',
        classDefinitionCycle: 'Die Klassendefinition fr "{name}" hngt von sich selbst ab.',
        classGetItemClsParam: '__class_getitem__ Auerkraftsetzung sollte einen "cls"-Parameter annehmen.',
        classMethodClsParam: 'Klassenmethoden sollten einen "cls"-Parameter verwenden.',
        classNotRuntimeSubscriptable: 'Tiefgestellte Zeichen fr die Klasse {name} generieren eine Laufzeitausnahme; schlieen Sie den Typausdruck in Anfhrungszeichen ein',
        classPatternBuiltInArgPositional: 'Das Klassenmuster akzeptiert nur positionsbezogenes Untermuster.',
        classPatternPositionalArgCount: 'Zu viele Positionsmuster fr Klasse "{type}". Erwartet: {expected}, empfangen: {received}.',
        classPatternTypeAlias: '"{type}" kann nicht in einem Klassenmuster verwendet werden, da es sich um einen spezialisierten Typalias handelt.',
        classPropertyDeprecated: 'Klasseneigenschaften sind in Python3.11 veraltet und werden in Python3.13 nicht untersttzt.',
        classTypeParametersIllegal: 'Die Syntax des Klassentypparameters erfordert Python 3.12 oder hher.',
        classVarFirstArgMissing: 'Nach "ClassVar" wurde ein Typargument erwartet.',
        classVarNotAllowed: '"ClassVar" ist in diesem Kontext nicht zulssig.',
        classVarOverridesInstanceVar: 'Die Klassenvariable "{name}" berschreibt die Instanzvariable desselben Namens in der Klasse "{className}"',
        classVarTooManyArgs: 'Nach "ClassVar" wird ein Typargument erwartet.',
        classVarWithTypeVar: 'Der Typ "ClassVar" darf keine Typvariablen enthalten.',
        clsSelfParamTypeMismatch: 'Der Typ des Parameters "{name}" muss ein Obertyp seiner Klasse "{classType}" sein',
        codeTooComplexToAnalyze: 'Der Code ist zu komplex fr die Analyse; verringern Sie die Komplexitt durch Refactoring in Unterroutinen oder durch Reduzieren bedingter Codepfade',
        collectionAliasInstantiation: 'Der Typ "{type}" kann nicht instanziiert werden, verwenden Sie stattdessen "{alias}".',
        comparisonAlwaysFalse: 'Die Bedingung wird immer als False ausgewertet, da die Typen "{leftType}" und "{rightType}" keine berlappung aufweisen.',
        comparisonAlwaysTrue: 'Die Bedingung wird immer als True ausgewertet, da die Typen "{leftType}" und "{rightType}" keine berlappung aufweisen.',
        comprehensionInDict: 'Verstndnis kann nicht mit anderen Wrterbucheintrgen verwendet werden.',
        comprehensionInSet: 'Verstndnis kann nicht mit anderen set Eintrgen verwendet werden.',
        concatenateContext: 'Concatenate ist in diesem Kontext nicht zulssig.',
        concatenateParamSpecMissing: 'Das letzte Typargument fr "Concatenate" muss ein ParamSpec oder "..." sein.',
        concatenateTypeArgsMissing: 'Concatenate erfordert mindestens zwei Typargumente.',
        conditionalOperandInvalid: 'Ungltiger bedingter Operand vom Typ "{type}"',
        constantRedefinition: '"{name}" ist konstant (da es sich um Grobuchstaben handelt) und kann nicht neu definiert werden.',
        constructorParametersMismatch: 'Keine bereinstimmung zwischen der Signatur von __new__ und __init__ in der Klasse "{classType}"',
        containmentAlwaysFalse: 'Der Ausdruck wird immer als False ausgewertet, da die Typen "{leftType}" und "{rightType}" keine berlappung aufweisen.',
        containmentAlwaysTrue: 'Der Ausdruck wird immer als True ausgewertet, da die Typen "{leftType}" und "{rightType}" keine berlappung aufweisen.',
        continueInExceptionGroup: 'continue ist in einem except* Block nicht zulssig.',
        continueOutsideLoop: '"continue" kann nur innerhalb einer Schleife verwendet werden.',
        coroutineInConditionalExpression: 'Bedingter Ausdruck verweist auf eine Coroutine, die immer zu "True" ausgewertet wird.',
        dataClassBaseClassFrozen: 'Eine nicht fixierte Klasse kann nicht von einer fixierten Klasse erben.',
        dataClassBaseClassNotFrozen: 'Eine fixierte Klasse kann nicht von einer nicht fixierten Klasse erben.',
        dataClassConverterFunction: 'Das Argument vom Typ "{argType}" ist kein gltiger Konverter fr das Feld "{fieldName}" vom Typ "{fieldType}"',
        dataClassConverterOverloads: 'Keine berladungen von "{funcName}" sind gltige Konverter fr das Feld "{fieldName}" vom Typ "{fieldType}"',
        dataClassFieldInheritedDefault: '{fieldName} berschreibt ein Feld mit demselben Namen, aber es fehlt ein Standardwert',
        dataClassFieldWithDefault: 'Felder ohne Standardwerte drfen nicht nach Feldern mit Standardwerten angezeigt werden.',
        dataClassFieldWithPrivateName: 'Das Feld "Dataclass" kann keinen privaten Namen verwenden.',
        dataClassFieldWithoutAnnotation: 'Datenklassenfeld ohne Typanmerkung verursacht eine Laufzeitausnahme',
        dataClassPostInitParamCount: 'Dataclass __post_init__ falsche Parameteranzahl; Anzahl von InitVar-Feldern ist {expected}',
        dataClassPostInitType: 'Dataclass __post_init__ Methodenparametertypkonflikt fr Feld "{fieldName}"',
        dataClassSlotsOverwrite: '__slots__ ist bereits in der Klasse definiert.',
        dataClassTransformExpectedBoolLiteral: 'Es wurde ein Ausdruck erwartet, der statisch als True oder False ausgewertet wird.',
        dataClassTransformFieldSpecifier: 'Es wurde tuple von Klassen oder Funktionen erwartet, es wurde jedoch der Typ "{type}" empfangen',
        dataClassTransformPositionalParam: 'Alle Argumente fr "dataclass_transform" mssen Schlsselwortargumente sein.',
        dataClassTransformUnknownArgument: 'Argument "{name}" wird von dataclass_transform nicht untersttzt.',
        dataProtocolInSubclassCheck: 'Datenprotokolle (die Nicht-Methodenattribute enthalten) sind in issubclass-Aufrufen nicht zulssig.',
        declaredReturnTypePartiallyUnknown: 'Der deklarierte Rckgabetyp "{returnType}" ist teilweise unbekannt.',
        declaredReturnTypeUnknown: 'Unbekannter Rckgabetyp deklariert',
        defaultValueContainsCall: 'Funktionsaufrufe und nderbare Objekte sind innerhalb des Parameterstandardwertausdrucks nicht zulssig.',
        defaultValueNotAllowed: 'Ein Parameter mit "*" oder "**" darf keinen Standardwert aufweisen.',
        delTargetExpr: 'Der Ausdruck kann nicht gelscht werden',
        deprecatedClass: 'Die Klasse "{name}" ist veraltet.',
        deprecatedConstructor: 'Der Konstruktor fr die Klasse "{name}" ist veraltet.',
        deprecatedDescriptorDeleter: 'Die Methode "__delete__" fr den Deskriptor "{name}" ist veraltet.',
        deprecatedDescriptorGetter: 'Die Methode "__get__" fr den Deskriptor "{name}" ist veraltet.',
        deprecatedDescriptorSetter: 'Die Methode "__set__" fr den Deskriptor "{name}" ist veraltet.',
        deprecatedFunction: 'Die Funktion "{name}" ist veraltet.',
        deprecatedMethod: 'Die Methode "{name}" in der Klasse "{className}" ist veraltet.',
        deprecatedPropertyDeleter: 'Der deleter fr property "{name}" ist veraltet.',
        deprecatedPropertyGetter: 'Der getter fr property "{name}" ist veraltet.',
        deprecatedPropertySetter: 'Der setter fr property "{name}" ist veraltet.',
        deprecatedType: 'Dieser Typ ist ab python-{version} veraltet; verwenden Sie stattdessen "{replacement}"',
        dictExpandIllegalInComprehension: 'Wrterbucherweiterung ist im Verstndnis nicht zulssig.',
        dictInAnnotation: 'Der Wrterbuchausdruck ist im Typausdruck nicht zulssig',
        dictKeyValuePairs: 'Wrterbucheintrge mssen Schlssel-Wert-Paare enthalten.',
        dictUnpackIsNotMapping: 'Es wird eine Zuordnung fr den Operator zum Entpacken des Wrterbuchs erwartet.',
        dunderAllSymbolNotPresent: '"{name}" ist in __all__ angegeben, aber nicht im Modul vorhanden.',
        duplicateArgsParam: 'Es ist nur ein "*"-Parameter zulssig.',
        duplicateBaseClass: 'Doppelte Basisklasse nicht zulssig',
        duplicateCapturePatternTarget: '"{name}" des Erfassungsziels darf nicht mehrmals innerhalb desselben Musters vorkommen.',
        duplicateCatchAll: 'Es ist nur eine catch-all except-Klausel zulssig.',
        duplicateEnumMember: 'Der Enumerationsmember "{name}" wurde bereits deklariert.',
        duplicateGenericAndProtocolBase: 'Es ist nur eine Generic[...]- oder ein Protocol[...]-Basisklasse zulssig.',
        duplicateImport: '"{importName}" wurde mehrmals importiert.',
        duplicateKeywordOnly: 'Es ist nur ein "*"-Trennzeichen zulssig.',
        duplicateKwargsParam: 'Es ist nur ein "**"-Parameter zulssig.',
        duplicateParam: 'Doppelter Parameter "{name}"',
        duplicatePositionOnly: 'Es ist nur ein "/"-Parameter zulssig.',
        duplicateStarPattern: 'In einer Mustersequenz ist nur ein "*"-Muster zulssig.',
        duplicateStarStarPattern: 'Es ist nur ein "**"-Eintrag zulssig.',
        duplicateUnpack: 'In list ist nur ein Vorgang zum Entpacken zulssig.',
        ellipsisAfterUnpacked: '... kann nicht mit einem entpackten TypeVarTuple oder tuple verwendet werden.',
        ellipsisContext: '"..." ist in diesem Kontext nicht zulssig.',
        ellipsisSecondArg: '"..." ist nur als zweites von zwei Argumenten zulssig.',
        enumClassOverride: 'Die Enumerationsklasse "{name}" ist final und kann nicht in eine Unterklasse aufgenommen werden.',
        enumMemberDelete: 'Das Enumerationselement "{name}" kann nicht gelscht werden.',
        enumMemberSet: 'Das Enumerationselement "{name}" kann nicht zugewiesen werden.',
        enumMemberTypeAnnotation: 'Typanmerkungen sind fr enum Member nicht zulssig',
        exceptGroupMismatch: 'Die try-Anweisung darf nicht sowohl except als auch except* enthalten.',
        exceptGroupRequiresType: 'Die Ausnahmegruppensyntax (except*) erfordert einen Ausnahmetyp.',
        exceptionGroupIncompatible: 'Die Ausnahmegruppensyntax ("except*") erfordert Python 3.11 oder hher.',
        exceptionGroupTypeIncorrect: 'Der Ausnahmetyp in except* kann nicht von BaseGroupException abgeleitet werden.',
        exceptionTypeIncorrect: '"{type}" ist nicht von BaseException abgeleitet.',
        exceptionTypeNotClass: '"{type}" ist keine gltige Ausnahmeklasse.',
        exceptionTypeNotInstantiable: 'Der Konstruktor fr den Ausnahmetyp "{type}" erfordert mindestens ein Argument.',
        expectedAfterDecorator: 'Es wurde eine Funktions- oder Klassendeklaration nach dem Decorator erwartet.',
        expectedArrow: '"->" gefolgt von Rckgabetypanmerkung erwartet',
        expectedAsAfterException: '"as" nach Ausnahmetyp erwartet',
        expectedAssignRightHandExpr: 'Ausdruck rechts von "=" erwartet',
        expectedBinaryRightHandExpr: 'Ausdruck rechts vom Operator',
        expectedBoolLiteral: '"True" oder "False" erwartet',
        expectedCase: '"case"-Anweisung erwartet',
        expectedClassName: 'Klassenname erwartet',
        expectedCloseBrace: '"{" wurde nicht geschlossen.',
        expectedCloseBracket: '"[" wurde nicht geschlossen.',
        expectedCloseParen: '"(" wurde nicht geschlossen.',
        expectedColon: '":" erwartet',
        expectedComplexNumberLiteral: 'Fr den Musterabgleich wurde ein komplexes Zahlenliteral erwartet.',
        expectedDecoratorExpr: 'Das Ausdrucksformular wird fr den Decorator vor Python 3.9 nicht untersttzt.',
        expectedDecoratorName: 'Decoratorname erwartet',
        expectedDecoratorNewline: 'Am Ende des Decorators wurde eine neue Zeile erwartet.',
        expectedDelExpr: 'Ausdruck nach "del" erwartet',
        expectedElse: 'Unerwartetes "else"',
        expectedEquals: '"=" erwartet',
        expectedExceptionClass: 'Ungltige Ausnahmeklasse oder ungltiges Objekt.',
        expectedExceptionObj: 'Ausnahmeobjekt, Ausnahmeklasse oder None erwartet',
        expectedExpr: 'Ausdruck erwartet.',
        expectedFunctionAfterAsync: 'Funktionsdefinition nach "async" erwartet',
        expectedFunctionName: 'Funktionsname nach "def" erwartet',
        expectedIdentifier: 'Bezeichner erwartet',
        expectedImport: '"import" erwartet',
        expectedImportAlias: 'Symbol nach "as" erwartet',
        expectedImportSymbols: 'Nach dem "import" wurde mindestens ein Symbolname erwartet.',
        expectedIn: '"in" wurde erwartet.',
        expectedInExpr: 'Ausdruck nach "in" erwartet',
        expectedIndentedBlock: 'Eingerckter Block erwartet',
        expectedMemberName: 'Attributname nach . erwartet',
        expectedModuleName: 'Modulname erwartet',
        expectedNameAfterAs: 'Symbolname nach "as" erwartet',
        expectedNamedParameter: 'Der Schlsselwortparameter muss auf "*" folgen.',
        expectedNewline: 'Zeilenumbruch erwartet',
        expectedNewlineOrSemicolon: 'Anweisungen mssen durch Zeilenumbrche oder Semikolons getrennt werden.',
        expectedOpenParen: '"(" erwartet',
        expectedParamName: 'Parametername erwartet',
        expectedPatternExpr: 'Musterausdruck erwartet',
        expectedPatternSubjectExpr: 'Musterbetreffausdruck erwartet',
        expectedPatternValue: 'Es wurde ein Musterwertausdruck im Format "a.b" erwartet.',
        expectedReturnExpr: 'Ausdruck nach "return" erwartet',
        expectedSliceIndex: 'Index- oder Sliceausdruck erwartet',
        expectedTypeNotString: 'Typ erwartet, aber Zeichenfolgenliteral empfangen',
        expectedTypeParameterName: 'Name fr Typparameter erwartet',
        expectedYieldExpr: 'Ausdruck in yield-Anweisung erwartet',
        finalClassIsAbstract: 'Die Klasse {type} ist als final markiert und muss alle abstrakten Symbole implementieren.',
        finalContext: '"Final" ist in diesem Kontext nicht zulssig.',
        finalInLoop: 'Eine "Final"-Variable kann nicht innerhalb einer Schleife zugewiesen werden.',
        finalMethodOverride: 'Die Methode "{name}" kann die in der Klasse definierte final Methode "{className}" nicht berschreiben.',
        finalNonMethod: 'Die Funktion {name} kann nicht @final markiert werden, da sie keine Methode ist.',
        finalReassigned: '"{name}" ist als "Final" deklariert und kann nicht neu zugewiesen werden.',
        finalRedeclaration: '"{name}" wurde zuvor als "Final" deklariert.',
        finalRedeclarationBySubclass: '"{name}" kann nicht neu deklariert werden, da die bergeordnete Klasse "{className}" es als Final deklariert.',
        finalTooManyArgs: 'Nach "Final" wurde ein einzelnes Typargument erwartet.',
        finalUnassigned: '"{name}" ist als Final deklariert, aber der Wert ist nicht zugewiesen.',
        formatStringBrace: 'Eine einzelne schlieende geschweifte Klammer ist innerhalb des f-string-Literals nicht zulssig; verwenden Sie doppelte schlieende geschweifte Klammern.',
        formatStringBytes: 'Formatzeichenfolgenliterale (f-strings) drfen nicht binr sein.',
        formatStringDebuggingIllegal: 'Der F-String-Debugspezifizierer "=" erfordert Python 3.8 oder hher.',
        formatStringEscape: 'Escapesequenz (umgekehrter Schrgstrich) ist im Ausdrucksteil der f-Zeichenfolge vor Python 3.12 nicht zulssig.',
        formatStringExpectedConversion: 'Nach "!" in f-string wurde ein Konvertierungsspezifizierer erwartet.',
        formatStringIllegal: 'Formatzeichenfolgenliterale (f-strings) erfordern Python 3.6 oder hher.',
        formatStringInPattern: 'Die Formatzeichenfolge ist im Muster nicht zulssig.',
        formatStringNestedFormatSpecifier: 'Ausdrcke sind zu tief im Formatzeichenfolgenspezifizierer geschachtelt.',
        formatStringNestedQuote: 'Zeichenfolgen, die in einer f-Zeichenfolge geschachtelt sind, drfen nicht dasselbe Anfhrungszeichen wie die f-Zeichenfolge vor Python 3.12 verwenden.',
        formatStringUnicode: 'Formatzeichenfolgenliterale (f-strings) drfen nicht Unicode sein.',
        formatStringUnterminated: 'Nicht abgeschlossener Ausdruck in f-string; "}" wird erwartet.',
        functionDecoratorTypeUnknown: 'Ein nicht typisierter Funktionsdekorator verdeckt den Funktionstyp; Decorator wird ignoriert.',
        functionInConditionalExpression: 'Bedingter Ausdruck verweist auf eine Funktion, die immer zu "True" ausgewertet wird.',
        functionTypeParametersIllegal: 'Die Syntax des Funktionstypparameters erfordert Python 3.12 oder hher.',
        futureImportLocationNotAllowed: 'Importe von __future__ mssen am Anfang der Datei auftreten',
        generatorAsyncReturnType: 'Der Rckgabetyp der asynchronen Generatorfunktion muss mit "AsyncGenerator[{yieldType}, Any]" kompatibel sein.',
        generatorNotParenthesized: 'Generatorausdrcke mssen in Klammern gesetzt werden, wenn sie nicht das einzige Argument sind.',
        generatorSyncReturnType: 'Der Rckgabetyp der Generatorfunktion muss mit "Generator[{yieldType}, Any, Any]" kompatibel sein.',
        genericBaseClassNotAllowed: 'Die Basisklasse "Generic" kann nicht mit der Typparametersyntax verwendet werden.',
        genericClassAssigned: 'Der generische Klassentyp kann nicht zugewiesen werden.',
        genericClassDeleted: 'Der generische Klassentyp kann nicht gelscht werden.',
        genericInstanceVariableAccess: 'Der Zugriff auf die generische Instanzvariable ber die Klasse ist mehrdeutig.',
        genericNotAllowed: '"Generic" ist in diesem Kontext nicht gltig.',
        genericTypeAliasBoundTypeVar: 'Der generische Typalias innerhalb der Klasse kann keine gebundenen Typvariablen {names} verwenden.',
        genericTypeArgMissing: '"Generic" erfordert mindestens ein Typargument.',
        genericTypeArgTypeVar: 'Das Typargument fr "Generic" muss eine Typvariable sein.',
        genericTypeArgUnique: 'Typargumente fr "Generic" mssen eindeutig sein.',
        globalReassignment: '"{name}" wird vor einer globalen Deklaration zugewiesen.',
        globalRedefinition: '"{name}" wurde bereits als global deklariert.',
        implicitStringConcat: 'Implizite Zeichenfolgenverkettung nicht zulssig',
        importCycleDetected: 'Zyklus in Importkette erkannt',
        importDepthExceeded: 'Importkettentiefe berschritten {depth}',
        importResolveFailure: 'Import "{importName}" konnte nicht aufgelst werden.',
        importSourceResolveFailure: 'Import "{importName}" konnte aus der Quelle nicht aufgelst werden.',
        importSymbolUnknown: '"{name}" ist ein unbekanntes Importsymbol.',
        incompatibleMethodOverride: 'Die Methode "{name}" berschreibt die Klasse "{className}" auf inkompatible Weise.',
        inconsistentIndent: 'Der Betrag fr Nichteinzug stimmt nicht mit dem vorherigen Einzug berein.',
        inconsistentTabs: 'Inkonsistente Verwendung von Tabulatoren und Leerzeichen im Einzug.',
        initMethodSelfParamTypeVar: 'Typ-Anmerkung fr "self"-Parameter der "__init__"-Methode kann keine klassenbergreifenden Typvariablen enthalten',
        initMustReturnNone: 'Der Rckgabetyp von "__init__" muss "None" sein.',
        initSubclassCallFailed: 'Falsche Schlsselwortargumente fr __init_subclass__ Methode.',
        initSubclassClsParam: '__init_subclass__ Auerkraftsetzung sollte einen "cls"-Parameter annehmen.',
        initVarNotAllowed: 'InitVar ist in diesem Kontext nicht zulssig.',
        instanceMethodSelfParam: 'Instanzmethoden sollten einen "self"-Parameter verwenden.',
        instanceVarOverridesClassVar: 'Die Instanzvariable "{name}" berschreibt die Klassenvariable desselben Namens in der Klasse "{className}"',
        instantiateAbstract: 'Abstrakte Klasse "{type}" kann nicht erstellt werden.',
        instantiateProtocol: 'Die Protocol-Klasse "{type}" kann nicht instanziiert werden.',
        internalBindError: 'Interner Fehler beim Binden der Datei "{file}": {message}',
        internalParseError: 'Interner Fehler beim Parsen der Datei "{file}": {message}',
        internalTypeCheckingError: 'Interner Fehler bei der Typberprfung der Datei "{file}": {message}',
        invalidIdentifierChar: 'Ungltiges Zeichen in Bezeichner',
        invalidStubStatement: 'Die Anweisung ist innerhalb einer Typstubdatei bedeutungslos.',
        invalidTokenChars: 'Ungltiges Zeichen "{text}" im Token',
        isInstanceInvalidType: 'Das zweite Argument fr "isinstance" muss eine Klasse oder tuple von Klassen sein.',
        isSubclassInvalidType: 'Das zweite Argument fr "issubclass" muss eine Klasse oder tuple von Klassen sein.',
        keyValueInSet: 'Schlssel-Wert-Paare sind innerhalb einer Menge set nicht zulssig.',
        keywordArgInTypeArgument: 'Schlsselwortargumente knnen nicht in Typargumentlisten verwendet werden.',
        keywordArgShortcutIllegal: 'Die Tastenkombination fr Schlsselwortargumente erfordert Python3.14 oder hher.',
        keywordOnlyAfterArgs: 'Schlsselworttrennzeichen ist nach dem Parameter "*" nicht zulssig.',
        keywordParameterMissing: 'Mindestens ein Schlsselwortparameter muss dem Parameter "*" folgen.',
        keywordSubscriptIllegal: 'Schlsselwortargumente innerhalb von Tiefskripts werden nicht untersttzt.',
        lambdaReturnTypePartiallyUnknown: 'Der Rckgabetyp des Lambdaausdrucks "{returnType}" ist teilweise unbekannt.',
        lambdaReturnTypeUnknown: 'Der Rckgabetyp der Lambdafunktion ist unbekannt.',
        listAssignmentMismatch: 'Ein Ausdruck vom Typ "{type}" kann der Zielliste nicht zugewiesen werden.',
        listInAnnotation: 'Der Listenausdruck ist im Typausdruck nicht zulssig',
        literalEmptyArgs: 'Nach "Literal" wurde mindestens ein Typargument erwartet.',
        literalNamedUnicodeEscape: 'Benannte Escapesequenz fr Unicodezeichen werden in Zeichenfolgenanmerkungen vom Typ Literal nicht untersttzt.',
        literalNotAllowed: '"Literal" kann in diesem Kontext nicht ohne Typargument verwendet werden.',
        literalNotCallable: 'Der Literaltyp kann nicht instanziiert werden.',
        literalUnsupportedType: 'Typargumente fr "Literal" mssen None, ein Literalwert (int, bool, str oder bytes) oder ein enum Wert sein.',
        matchIncompatible: 'Match Anweisungen erfordern Python 3.10 oder hher',
        matchIsNotExhaustive: 'Flle innerhalb der match-Anweisung behandeln nicht umfassend alle Werte.',
        maxParseDepthExceeded: 'Maximale Analysetiefe berschritten; brechen Sie den Ausdruck in kleinere Unterausdrcke um',
        memberAccess: 'Auf das Attribut {name} fr die Klasse {type} kann nicht zugegriffen werden',
        memberDelete: 'Das Attribut {name} fr die Klasse {type} kann nicht gelscht werden',
        memberSet: 'Zum Attribut {name} fr die Klasse {type} kann nicht zugewiesen werden',
        metaclassConflict: 'Die Metaklasse einer abgeleiteten Klasse muss eine Unterklasse der Metaklassen aller ihrer Basisklassen sein.',
        metaclassDuplicate: 'Es kann nur eine Metaklasse angegeben werden.',
        metaclassIsGeneric: 'Metaklasse kann nicht generisch sein.',
        methodNotDefined: '"{name}" Methode nicht definiert',
        methodNotDefinedOnType: 'Die Methode "{name}" ist fr den Typ "{type}" nicht definiert.',
        methodOrdering: 'Es kann keine konsistente Methodenreihenfolge erstellt werden.',
        methodOverridden: '"{name}" berschreibt die Methode mit demselben Namen in der Klasse "{className}" mit inkompatiblem Typ "{type}"',
        methodReturnsNonObject: 'Die Methode "{name}" gibt kein Objekt zurck.',
        missingSuperCall: 'Die Methode "{methodName}" ruft nicht die Methode mit demselben Namen in der bergeordneten Klasse auf.',
        mixingBytesAndStr: 'Bytes- und str-Werte knnen nicht verkettet werden',
        moduleAsType: 'Das Modul kann nicht als Typ verwendet werden.',
        moduleNotCallable: 'Das Modul kann nicht aufgerufen werden.',
        moduleUnknownMember: '{memberName} ist kein bekanntes Attribut des Moduls {moduleName}',
        namedExceptAfterCatchAll: 'Eine benannte except-Klausel darf nicht nach catch-all except-Klausel auftreten.',
        namedParamAfterParamSpecArgs: 'Der Schlsselwortparameter "{name}" kann nicht in der Signatur nach dem Parameter "ParamSpec args" verwendet werden.',
        namedTupleEmptyName: 'Namen innerhalb benannten tuple drfen nicht leer sein.',
        namedTupleEntryRedeclared: '"{name}" kann nicht berschrieben werden, da die bergeordnete benannte tuple Klasse "{className}" ist.',
        namedTupleFirstArg: 'Es wird ein benannter tuple Klassenname als erstes Argument erwartet.',
        namedTupleMultipleInheritance: 'Mehrfachvererbung mit NamedTuple wird nicht untersttzt.',
        namedTupleNameKeyword: 'Feldnamen drfen kein Schlsselwort sein.',
        namedTupleNameType: 'Es wurde tuple mit zwei Eintrgen unter Angabe von Eintragsname und -typ erwartet.',
        namedTupleNameUnique: 'Namen innerhalb benannten tuple mssen eindeutig sein.',
        namedTupleNoTypes: '"namedtuple" stellt keine Typen fr Tupeleintrge bereit; verwenden Sie stattdessen "NamedTuple".',
        namedTupleSecondArg: 'Benannte tuple Eintragsliste als zweites Argument erwartet',
        newClsParam: '__new__ Auerkraftsetzung sollte einen "cls"-Parameter annehmen.',
        newTypeAnyOrUnknown: 'Das zweite Argument fr NewType muss eine bekannte Klasse sein, nicht Any oder Unknown.',
        newTypeBadName: 'Das erste Argument fr NewType muss ein Zeichenfolgenliteral sein.',
        newTypeLiteral: '"NewType" kann nicht mit dem Literaltyp verwendet werden.',
        newTypeNameMismatch: 'NewType muss einer Variablen mit demselben Namen zugewiesen werden.',
        newTypeNotAClass: 'Klasse als zweites Argument fr NewType erwartet',
        newTypeParamCount: 'NewType erfordert zwei Positionsargumente.',
        newTypeProtocolClass: 'NewType kann nicht mit strukturellem Typ (Protocol- oder TypedDict-Klasse) verwendet werden.',
        noOverload: 'Keine berladungen fr "{name}" stimmen mit den angegebenen Argumenten berein.',
        noReturnContainsReturn: 'Eine Funktion mit dem deklarierten return Typ "NoReturn" kann keine return-Anweisung enthalten.',
        noReturnContainsYield: 'Eine Funktion mit dem deklarierten Rckgabetyp "NoReturn" kann keine yield-Anweisung enthalten.',
        noReturnReturnsNone: 'Eine Funktion mit dem deklarierten Rckgabetyp "NoReturn" kann nicht "None" zurckgeben.',
        nonDefaultAfterDefault: 'Das nicht standardmige Argument folgt dem Standardargument.',
        nonLocalInModule: 'Nonlocal Deklaration auf Modulebene nicht zulssig',
        nonLocalNoBinding: 'Es wurde keine Bindung fr nonlocal "{name}" gefunden.',
        nonLocalReassignment: '"{name}" wird vor einer nonlocal Deklaration zugewiesen.',
        nonLocalRedefinition: '"{name}" wurde bereits als nonlocal deklariert.',
        noneNotCallable: 'Ein Objekt vom Typ "None" kann nicht aufgerufen werden.',
        noneNotIterable: 'Ein Objekt vom Typ "None" kann nicht als iterierbarer Wert verwendet werden.',
        noneNotSubscriptable: 'Das Objekt vom Typ "None" kann nicht tiefgestellt werden.',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Der Operator "{operator}" wird fr den "{None}" nicht untersttzt.',
        noneUnknownMember: '{name} ist kein bekanntes Attribut von None',
        notRequiredArgCount: 'Nach "NotRequired" wurde ein einzelnes Typargument erwartet.',
        notRequiredNotInTypedDict: '"NotRequired" ist in diesem Kontext nicht zulssig.',
        objectNotCallable: 'Das Objekt vom Typ "{type}" kann nicht aufgerufen werden.',
        obscuredClassDeclaration: 'Die Klassendeklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        obscuredFunctionDeclaration: 'Die Funktionsdeklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        obscuredMethodDeclaration: 'Die Methodendeklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        obscuredParameterDeclaration: 'Die Parameterdeklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        obscuredTypeAliasDeclaration: 'Die Typaliasdeklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        obscuredVariableDeclaration: 'Die Deklaration "{name}" wird durch eine Deklaration desselben Namens verdeckt.',
        operatorLessOrGreaterDeprecated: 'Der Operator "<>" wird in Python 3 nicht untersttzt; verwenden Sie stattdessen "!=".',
        optionalExtraArgs: 'Nach "Optional" wurde ein Typargument erwartet.',
        orPatternIrrefutable: 'Ein irrefutables Muster ist nur als letztes Unterpattern in einem "or"-Muster zulssig.',
        orPatternMissingName: 'Alle Teilmuster innerhalb eines "or"-Musters mssen auf dieselben Namen zielen.',
        overlappingKeywordArgs: 'Typisierte Wrterbuchberlappungen mit Schlsselwortparameter: {names}',
        overlappingOverload: 'berladung {obscured} fr "{name}" wird nie verwendet, da sich die Parameter berlappen, {obscuredBy}',
        overloadAbstractImplMismatch: 'berladungen mssen dem abstrakten Status der Implementierung entsprechen.',
        overloadAbstractMismatch: 'berladungen mssen alle abstrakt sein oder nicht.',
        overloadClassMethodInconsistent: 'berladungen fr "{name}" verwenden @classmethod inkonsistent',
        overloadFinalInconsistencyImpl: 'Die berladung fr {name} ist @final markiert, die Implementierung ist es jedoch nicht.',
        overloadFinalInconsistencyNoImpl: 'berladung {index} fr {name} ist als @final markiert, berladung 1 ist es jedoch nicht.',
        overloadImplementationMismatch: 'Die berladene Implementierung ist nicht konsistent mit der Signatur der berladung {index}',
        overloadReturnTypeMismatch: 'berladung {prevIndex} fr "{name}" berlappt {newIndex} und gibt einen inkompatiblen Typ zurck.',
        overloadStaticMethodInconsistent: 'berladungen fr "{name}" verwenden @staticmethod inkonsistent',
        overloadWithoutImplementation: '"{name}" ist als overload markiert, es wurde jedoch keine Implementierung bereitgestellt.',
        overriddenMethodNotFound: 'Die Methode "{name}" ist als override markiert, aber es ist keine Basismethode mit demselben Namen vorhanden.',
        overrideDecoratorMissing: 'Die Methode "{name}" ist nicht als override markiert, berschreibt jedoch eine Methode in der Klasse "{className}"',
        paramAfterKwargsParam: 'Der Parameter kann nicht auf den Parameter "**" folgen.',
        paramAlreadyAssigned: 'Der Parameter "{name}" ist bereits zugewiesen.',
        paramAnnotationMissing: 'Typanmerkung fehlt fr Parameter "{name}"',
        paramAssignmentMismatch: 'Ein Ausdruck vom Typ "{sourceType}" kann keinem Parameter vom Typ "{paramType}" zugewiesen werden.',
        paramNameMissing: 'Kein Parameter mit dem Namen "{name}"',
        paramSpecArgsKwargsDuplicate: 'Es wurden bereits Argumente fr ParamSpec "{type}" bereitgestellt',
        paramSpecArgsKwargsUsage: 'Die Attribute args und kwargs von ParamSpec mssen beide innerhalb einer Funktionssignatur auftreten',
        paramSpecArgsMissing: 'Argumente fr ParamSpec "{type}" fehlen.',
        paramSpecArgsUsage: 'Das Attribut args von ParamSpec ist nur gltig, wenn es mit dem Parameter *args verwendet wird',
        paramSpecAssignedName: 'ParamSpec muss einer Variablen mit dem Namen "{name}" zugewiesen werden.',
        paramSpecContext: 'ParamSpec ist in diesem Kontext nicht zulssig.',
        paramSpecDefaultNotTuple: 'Es wurde ein Auslassungszeichen, ein tuple Ausdruck oder ParamSpec fr den Standardwert von ParamSpec erwartet.',
        paramSpecFirstArg: 'Der Name von ParamSpec wurde als erstes Argument erwartet.',
        paramSpecKwargsUsage: 'Das Attribut kwargs von ParamSpec ist nur gltig, wenn es mit dem Parameter **kwargs verwendet wird',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" hat in diesem Kontext keine Bedeutung.',
        paramSpecUnknownArg: 'ParamSpec untersttzt nur ein Argument.',
        paramSpecUnknownMember: '{name} ist kein bekanntes Attribut von ParamSpec',
        paramSpecUnknownParam: '"{name}" ist ein unbekannter Parameter fr ParamSpec.',
        paramTypeCovariant: 'Eine Variable vom Typ "Covariant" kann nicht im Parametertyp verwendet werden.',
        paramTypePartiallyUnknown: 'Der Typ des Parameters "{paramName}" ist teilweise unbekannt.',
        paramTypeUnknown: 'Der Typ des Parameters "{paramName}" ist unbekannt.',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Das Muster wird fr den Antragstellertyp "{type}" nie abgeglichen',
        positionArgAfterNamedArg: 'Ein Positionsargument darf nicht nach Schlsselwortargumenten stehen.',
        positionOnlyAfterArgs: 'Das Parametertrennzeichen "Nur Position" ist nach dem Parameter "*" nicht zulssig.',
        positionOnlyAfterKeywordOnly: 'Der Parameter "/" muss vor dem Parameter "*" stehen.',
        positionOnlyAfterNon: 'Der Parameter "Nur Position" ist nach einem Parameter, der nicht vom Typ "Nur Position" ist, nicht zulssig.',
        positionOnlyFirstParam: 'Das Parametertrennzeichen "Nur Position" ist als erster Parameter nicht zulssig.',
        positionOnlyIncompatible: 'Fr das Parametertrennzeichen "Nur Position" ist Python3.8 oder hher erforderlich.',
        privateImportFromPyTypedModule: '"{name}" wird nicht aus dem Modul "{module}" exportiert.',
        privateUsedOutsideOfClass: '"{name}" ist privat und wird auerhalb der Klasse verwendet, in dem es deklariert ist.',
        privateUsedOutsideOfModule: '"{name}" ist privat und wird auerhalb des Moduls verwendet, in dem es deklariert ist.',
        propertyOverridden: '"{name}" berschreibt property desselben Namens in der Klasse "{className}" nicht ordnungsgem',
        propertyStaticMethod: 'Statische Methoden sind fr property getter, setter oder deleter nicht zulssig.',
        protectedUsedOutsideOfClass: '"{name}" ist geschtzt und wird auerhalb der Klasse verwendet, in der es deklariert ist.',
        protocolBaseClass: 'Die Protocol-Klasse "{classType}" kann nicht von einer non-Protocol-Klasse "{baseType}" abgeleitet werden',
        protocolBaseClassWithTypeArgs: 'Typargumente sind mit der Protocol Klasse nicht zulssig, wenn die Typparametersyntax verwendet wird.',
        protocolIllegal: 'Die Verwendung von "Protocol" erfordert Python 3.7 oder hher.',
        protocolNotAllowed: '"Protocol" kann in diesem Kontext nicht verwendet werden.',
        protocolTypeArgMustBeTypeParam: 'Das Typargument fr Protocol muss ein Typparameter sein.',
        protocolUnsafeOverlap: 'Die Klasse berlappt unsicher mit {name} und knnte zur Laufzeit eine bereinstimmung erzeugen.',
        protocolVarianceContravariant: 'Die Typvariable "{variable}", die im generischen Protocol "{class}" verwendet wird, muss "contravariant" sein.',
        protocolVarianceCovariant: 'Die Typvariable "{variable}", die im generischen Protocol "{class}" verwendet wird, muss "covariant" sein.',
        protocolVarianceInvariant: 'Die Typvariable "{variable}", die im generischen Protocol "{class}" verwendet wird, muss "invariant" sein.',
        pyrightCommentInvalidDiagnosticBoolValue: 'Auf die Pyright-Kommentardirektive muss "=" und der Wert "true" oder "false" folgen.',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Auf die Pyright-Kommentardirektive muss "=" und der Wert "true", "false", "error", "warning", "information" oder "none" folgen.',
        pyrightCommentMissingDirective: 'Auf einen Pyright-Kommentar muss eine Direktive (basic oder strict) oder eine Diagnoseregel folgen.',
        pyrightCommentNotOnOwnLine: 'Pyright-Kommentare, die zum Steuern von Einstellungen auf Dateiebene verwendet werden, mssen in ihrer eigenen Zeile angezeigt werden.',
        pyrightCommentUnknownDiagnosticRule: '"{rule}" ist eine unbekannte Diagnoseregel fr pyright-Kommentar.',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" ist ein ungltiger Wert fr den pyright-Kommentar; "true", "false", "error", "warning", "information" oder "none" erwartet.',
        pyrightCommentUnknownDirective: '"{directive}" ist eine unbekannte Direktive fr pyright-Kommentar; "strict" oder "basic" erwartet',
        readOnlyArgCount: 'Nach "ReadOnly" wurde ein einzelnes Typargument erwartet.',
        readOnlyNotInTypedDict: '"ReadOnly" ist in diesem Kontext nicht zulssig.',
        recursiveDefinition: 'Der Typ von "{name}" konnte nicht bestimmt werden, da er sich auf selbst bezieht.',
        relativeImportNotAllowed: 'Relative Importe knnen nicht mit dem Formular "import .a" verwendet werden; verwenden Sie stattdessen "from . import a"',
        requiredArgCount: 'Nach "Required" wurde ein einzelnes Typargument erwartet.',
        requiredNotInTypedDict: '"Required" ist in diesem Kontext nicht zulssig.',
        returnInAsyncGenerator: 'Eine Return-Anweisung mit einem Wert ist im asynchronen Generator nicht zulssig.',
        returnInExceptionGroup: 'return ist in einem except* Block nicht zulssig.',
        returnMissing: 'Die Funktion mit dem deklarierten Rckgabetyp "{returnType}" muss einen Wert fr alle Codepfade zurckgeben.',
        returnOutsideFunction: '"return" kann nur innerhalb einer Funktion verwendet werden.',
        returnTypeContravariant: 'Die Variable vom Typ "contravariant" kann nicht im Rckgabetyp verwendet werden.',
        returnTypeMismatch: 'Der Typ {exprType} kann dem Rckgabetyp {returnType} nicht zugewiesen werden',
        returnTypePartiallyUnknown: 'Der Rckgabetyp "{returnType}" ist teilweise unbekannt.',
        returnTypeUnknown: 'Unbekannter Rckgabetyp',
        revealLocalsArgs: 'Es wurden keine Argumente fr den Aufruf "reveal_locals" erwartet.',
        revealLocalsNone: 'Keine locals Elemente in diesem Bereich',
        revealTypeArgs: 'Fr den Aufruf "reveal_type" wurde ein einzelnes Positionsargument erwartet.',
        revealTypeExpectedTextArg: 'Das Argument "expected_text" fr die Funktion "reveal_type" muss ein str-Literalwert sein.',
        revealTypeExpectedTextMismatch: 'Typentextkonflikt; "{expected}" erwartet, aber "{received}" empfangen',
        revealTypeExpectedTypeMismatch: 'Typenkonflikt; "{expected}" erwartet, aber "{received}" empfangen',
        selfTypeContext: '"Self" ist in diesem Kontext ungltig.',
        selfTypeMetaclass: 'Self kann nicht innerhalb einer Metaklasse (einer Unterklasse von type) verwendet werden.',
        selfTypeWithTypedSelfOrCls: '"Self" kann nicht in einer Funktion mit einem Parameter "self" oder "cls" verwendet werden, der eine andere Typanmerkung als "Self" aufweist.',
        setterGetterTypeMismatch: 'Der Property setter Werttyp kann dem getter Rckgabetyp nicht zugewiesen werden.',
        singleOverload: '"{name}" ist als berladung markiert, aber es fehlen weitere berladungen.',
        slotsAttributeError: '"{name}" ist in __slots__ nicht angegeben.',
        slotsClassVarConflict: '"{name}" steht in Konflikt mit Instanzvariablen, die in __slots__ deklariert sind.',
        starPatternInAsPattern: 'Das Sternmuster kann nicht mit dem Ziel "as" verwendet werden.',
        starPatternInOrPattern: 'Das Sternmuster kann in anderen Mustern nicht ORed sein.',
        starStarWildcardNotAllowed: '** kann nicht zusammen mit Platzhalter "_" verwendet werden',
        staticClsSelfParam: 'Statische Methoden drfen keinen "self"- oder "cls"-Parameter annehmen.',
        stdlibModuleOverridden: '"{path}" berschreibt das stdlib-Modul "{name}"',
        stringNonAsciiBytes: 'Ein Nicht-ASCII-Zeichen ist im Zeichenfolgenliteral in Bytes nicht zulssig.',
        stringNotSubscriptable: 'Der Zeichenfolgenausdruck kann im Typausdruck nicht tiefgestellt werden; schlieen Sie den samten Ausdruck in Anfhrungszeichen ein',
        stringUnsupportedEscape: 'Nicht untersttzte Escapesequenz im Zeichenfolgenliteral.',
        stringUnterminated: 'Das Zeichenfolgenliteral ist nicht beendet.',
        stubFileMissing: 'Die Stubdatei wurde fr "{importName}" nicht gefunden.',
        stubUsesGetAttr: 'Die Typ-Stub-Datei ist unvollstndig; "__getattr__" verdeckt Typfehler fr Modul',
        sublistParamsIncompatible: 'Sublist Parameter werden in Python 3.x nicht untersttzt.',
        superCallArgCount: 'Es werden nicht mehr als zwei Argumente fr den super Aufruf erwartet.',
        superCallFirstArg: 'Klassentyp als erstes Argument fr super-Aufruf erwartet, aber "{type}" empfangen',
        superCallSecondArg: 'Das zweite Argument fr den "super"-Aufruf muss ein Objekt oder eine Klasse sein, das bzw. die von "{type}" abgeleitet wird.',
        superCallZeroArgForm: 'Die Nullargumentform des super Aufrufs ist nur innerhalb einer Methode gltig.',
        superCallZeroArgFormStaticMethod: 'Die Nullargumentform des super Aufrufs ist nicht innerhalb einer statischen Methode gltig.',
        symbolIsPossiblyUnbound: '"{name}" ist mglicherweise ungebunden.',
        symbolIsUnbound: '"{name}" ist ungebunden.',
        symbolIsUndefined: '"{name}" ist nicht definiert.',
        symbolOverridden: '"{name}" berschreibt das Symbol desselben Namens in der Klasse "{className}"',
        ternaryNotAllowed: 'Der ternre Ausdruck ist im Typausdruck nicht zulssig',
        totalOrderingMissingMethod: 'Die Klasse muss "__lt__", "__le__", "__gt__" oder "__ge__" definieren, um total_ordering zu verwenden.',
        trailingCommaInFromImport: 'Nachgestelltes Komma ist ohne umgebende Klammern nicht zulssig.',
        tryWithoutExcept: 'Die try-Anweisung muss mindestens eine except- oder finally-Klausel aufweisen.',
        tupleAssignmentMismatch: 'Ein Ausdruck vom Typ "{type}" kann dem Ziel-tuple nicht zugewiesen werden.',
        tupleInAnnotation: 'Der Tuple-ausdruck ist im Typausdruck nicht zulssig',
        tupleIndexOutOfRange: 'Der Index {index} liegt fr den Typ {type} auerhalb des gltigen Bereichs.',
        typeAliasIllegalExpressionForm: 'Ungltiges Ausdrucksformular fr Typaliasdefinition',
        typeAliasIsRecursiveDirect: 'Der Typalias "{name}" kann sich nicht selbst in seiner Definition verwenden.',
        typeAliasNotInModuleOrClass: 'TypeAlias kann nur innerhalb eines Moduls oder Klassenbereichs definiert werden.',
        typeAliasRedeclared: '"{name}" ist als TypeAlias deklariert und kann nur einmal zugewiesen werden.',
        typeAliasStatementBadScope: 'Eine type Anweisung kann nur innerhalb eines Moduls oder Klassenbereichs verwendet werden.',
        typeAliasStatementIllegal: 'Die Typaliasanweisung erfordert Python 3.12 oder hher.',
        typeAliasTypeBaseClass: 'Ein in einer "type"-Anweisung definierter type Alias kann nicht als Basisklasse verwendet werden.',
        typeAliasTypeMustBeAssigned: 'TypeAliasType muss einer Variablen mit dem gleichen Namen wie der Typalias zugewiesen werden.',
        typeAliasTypeNameArg: 'Das erste Argument fr TypeAliasType muss ein Zeichenfolgenliteral sein, das den Namen des Typalias darstellt.',
        typeAliasTypeNameMismatch: 'Der Name des Typalias muss mit dem Namen der Variablen bereinstimmen, der er zugewiesen ist.',
        typeAliasTypeParamInvalid: 'Die Typparameterliste muss tuple sein, das nur TypeVar, TypeVarTuple oder ParamSpec enthlt.',
        typeAnnotationCall: 'Der Aufrufausdruck ist im Typausdruck nicht zulssig',
        typeAnnotationVariable: 'Variable im Typausdruck nicht zulssig',
        typeAnnotationWithCallable: 'Das Typargument fr "type" muss eine Klasse sein. Aufrufbare Elemente werden nicht untersttzt.',
        typeArgListExpected: 'ParamSpec, Ellipse oder list der Typen erwartet',
        typeArgListNotAllowed: 'Der Listenausdruck ist fr dieses Typargument nicht zulssig.',
        typeArgsExpectingNone: 'Fr die Klasse "{name}" werden keine Typargumente erwartet.',
        typeArgsMismatchOne: 'Es wurde ein Typargument erwartet, es wurde jedoch {received} empfangen.',
        typeArgsMissingForAlias: 'Fr den generischen Typalias "{name}" werden Typargumente erwartet.',
        typeArgsMissingForClass: 'Fr die generische Klasse "{name}" werden Typargumente erwartet.',
        typeArgsTooFew: 'Fr "{name}" wurden zu wenige Typargumente angegeben; {expected} erwartet, aber {received} empfangen',
        typeArgsTooMany: 'Fr "{name}" wurden zu viele Typargumente angegeben; {expected} erwartet, aber {received} empfangen',
        typeAssignmentMismatch: 'Der Typ {sourceType} kann dem deklarierten Typ {destType} nicht zugewiesen werden',
        typeAssignmentMismatchWildcard: 'Das Importsymbol {name} weist den Typ {sourceType} auf, der dem deklarierten Typ {destType} nicht zugewiesen werden kann.',
        typeCallNotAllowed: 'Der type()-Aufruf darf nicht im Typausdruck verwendet werden',
        typeCheckOnly: '"{name}" ist als @type_check_only markiert und kann nur in Typanmerkungen verwendet werden.',
        typeCommentDeprecated: 'Die Verwendung von type Kommentaren ist veraltet; verwenden Sie stattdessen type Anmerkung',
        typeExpectedClass: 'Die Klasse wurde erwartet, aber {type} wurde empfangen.',
        typeFormArgs: 'TypeForm akzeptiert ein einzelnes positionelles Argument',
        typeGuardArgCount: 'Nach "TypeGuard" oder "TypeIs" wurde ein einzelnes Typargument erwartet.',
        typeGuardParamCount: 'Benutzerdefinierte Typenschutzfunktionen und -methoden mssen mindestens einen Eingabeparameter aufweisen.',
        typeIsReturnType: 'Der Rckgabetyp von TypeIs ("{returnType}") ist nicht konsistent mit dem Wertparametertyp ("{type}").',
        typeNotAwaitable: '"{type}" ist nicht awaitable.',
        typeNotIntantiable: '"{type}" kann nicht instanziiert werden.',
        typeNotIterable: '"{type}" ist nicht iterierbar.',
        typeNotSpecializable: 'Der Typ "{type}" konnte nicht spezialisiert werden',
        typeNotSubscriptable: 'Das Objekt vom Typ "{type}" kann nicht tiefgestellt werden.',
        typeNotSupportBinaryOperator: 'Der Operator "{operator}" wird fr Typen "{leftType}" und "{rightType}" nicht untersttzt.',
        typeNotSupportBinaryOperatorBidirectional: 'Der Operator "{operator}" wird fr die Typen "{leftType}" und "{rightType}" nicht untersttzt, wenn der erwartete Typ "{expectedType}" ist.',
        typeNotSupportUnaryOperator: 'Der Operator "{operator}" wird fr den Typ "{type}" nicht untersttzt.',
        typeNotSupportUnaryOperatorBidirectional: 'Der Operator "{operator}" wird fr den Typ "{type}" nicht untersttzt, wenn der erwartete Typ "{expectedType}" ist.',
        typeNotUsableWith: 'Ein Objekt vom Typ "{type}" kann nicht mit "with" verwendet werden, da es nicht {method} implementiert.',
        typeParameterBoundNotAllowed: '"Bound" oder "constraint" kann nicht mit einem variadic-Typparameter oder ParamSpec verwendet werden.',
        typeParameterConstraintTuple: 'Die Typparametereinschrnkung muss ein Tupel mit mindestens zwei Typen sein.',
        typeParameterExistingTypeParameter: 'Der Typparameter "{name}" wird bereits verwendet.',
        typeParameterNotDeclared: 'Der Typparameter "{name}" ist nicht in der Typparameterliste fr "{container}" enthalten.',
        typeParametersMissing: 'Es muss mindestens ein Typparameter angegeben werden.',
        typePartiallyUnknown: 'Der Typ von "{name}" ist teilweise unbekannt.',
        typeUnknown: 'Der Typ von "{name}" ist unbekannt.',
        typeVarAssignedName: 'TypeVar muss einer Variablen mit dem Namen "{name}" zugewiesen werden.',
        typeVarAssignmentMismatch: 'Der Typ "{type}" kann der Typvariablen "{name}" nicht zugewiesen werden.',
        typeVarBoundAndConstrained: 'TypeVar kann nicht gleichzeitig gebunden und eingeschrnkt sein.',
        typeVarBoundGeneric: 'Der gebundene Typ "TypeVar" darf nicht generisch sein.',
        typeVarConstraintGeneric: 'Der Typ der TypeVar-Einschrnkung darf nicht generisch sein.',
        typeVarDefaultBoundMismatch: 'Der Standardtyp "TypeVar" muss ein Untertyp des gebundenen Typs sein.',
        typeVarDefaultConstraintMismatch: 'Der Standardtyp "TypeVar" muss einer der eingeschrnkten Typen sein.',
        typeVarDefaultIllegal: 'Fr Standardtypen von Typvariablen ist Python 3.13 oder hher erforderlich.',
        typeVarDefaultInvalidTypeVar: 'Der Typparameter "{name}" weist einen Standardtyp auf, der auf eine oder mehrere Typvariablen verweist, die auerhalb des Gltigkeitsbereichs liegen.',
        typeVarFirstArg: 'Der Name von TypeVar wurde als erstes Argument erwartet.',
        typeVarInvalidForMemberVariable: 'Der Attributtyp kann keine Typvariable "{name}" verwenden, die auf die lokale Methode festgelegt ist.',
        typeVarNoMember: 'TypeVar {type} weist kein Attribut {name} auf',
        typeVarNotSubscriptable: 'TypeVar "{type}" kann nicht tiefgestellt werden.',
        typeVarNotUsedByOuterScope: 'Die Typvariable "{name}" hat in diesem Kontext keine Bedeutung.',
        typeVarPossiblyUnsolvable: 'Die Typvariable "{name}" wird mglicherweise nicht aufgelst, wenn der Aufrufer kein Argument fr Parameter "{param}" bereitstellt',
        typeVarSingleConstraint: 'TypeVar muss mindestens zwei eingeschrnkte Typen aufweisen.',
        typeVarTupleConstraints: 'TypeVarTuple darf keine Werteinschrnkungen aufweisen.',
        typeVarTupleContext: 'TypeVarTuple ist in diesem Kontext nicht zulssig.',
        typeVarTupleDefaultNotUnpacked: 'Der Standardtyp "TypeVarTuple" muss entpacktes tuple oder ein TypeVarTuple sein.',
        typeVarTupleMustBeUnpacked: 'Der Entpackungsoperator ist fr den TypeVarTuple-Wert erforderlich.',
        typeVarTupleUnknownParam: '"{name}" ist ein unbekannter Parameter fr TypeVarTuple.',
        typeVarUnknownParam: '"{name}" ist ein unbekannter Parameter fr TypeVar.',
        typeVarUsedByOuterScope: 'TypeVar "{name}" wird bereits von einem ueren Bereich verwendet.',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" wird in der generischen Funktionssignatur nur einmal angezeigt.',
        typeVarVariance: 'TypeVar darf nicht gleichzeitig "covariant" und "contravariant" sein.',
        typeVarWithDefaultFollowsVariadic: 'TypeVar {typeVarName} weist einen Standardwert auf und kann TypeVarTuple {variadicName} nicht folgen.',
        typeVarWithoutDefault: '"{name}" kann nicht nach "{other}" in der Typparameterliste angezeigt werden, da es keinen Standardtyp aufweist.',
        typeVarsNotInGenericOrProtocol: 'Generic[] oder Protocol[] mssen alle Typvariablen enthalten.',
        typedDictAccess: 'Auf das Element in TypedDict konnte nicht zugegriffen werden.',
        typedDictAssignedName: 'TypedDict muss einer Variablen mit dem Namen {name} zugewiesen werden.',
        typedDictBadVar: 'TypedDict-Klassen drfen nur Typanmerkungen enthalten.',
        typedDictBaseClass: 'Alle Basisklassen fr TypedDict-Klassen mssen auch TypedDict-Klassen sein.',
        typedDictBoolParam: 'Es wird erwartet, dass "{name}" Parameter den Wert "True" oder "False" aufweist.',
        typedDictClosedExtras: 'Die Basisklasse {name} ist ein closed TypedDict; zustzliche Elemente mssen vom Typ {type} sein.',
        typedDictClosedNoExtras: 'Die Basisklasse {name} ist ein closed TypedDict; zustzliche Elemente sind nicht zulssig.',
        typedDictDelete: 'Das Element in TypedDict konnte nicht gelscht werden.',
        typedDictEmptyName: 'Namen innerhalb eines TypedDict drfen nicht leer sein.',
        typedDictEntryName: 'Fr den Wrterbucheintragsnamen wurde ein Zeichenfolgenliteral erwartet.',
        typedDictEntryUnique: 'Namen innerhalb eines Wrterbuchs mssen eindeutig sein.',
        typedDictExtraArgs: 'Zustzliche TypedDict-Argumente werden nicht untersttzt.',
        typedDictExtraItemsClosed: 'Ein TypedDict kann nicht auf closed (geschlossen) gesetzt werden, wenn es zustzliche Elemente untersttzt.',
        typedDictFieldNotRequiredRedefinition: 'Das TypedDict-Element {name} kann nicht als NotRequired neu definiert werden.',
        typedDictFieldReadOnlyRedefinition: 'Das TypedDict-Element {name} kann nicht als ReadOnly neu definiert werden.',
        typedDictFieldRequiredRedefinition: 'Das TypedDict-Element {name} kann nicht als Required neu definiert werden.',
        typedDictFirstArg: 'Der Klassenname "TypedDict" wird als erstes Argument erwartet.',
        typedDictInClassPattern: 'Die TypedDict-Klasse ist im Klassenmuster nicht zulssig.',
        typedDictInitsubclassParameter: 'TypedDict untersttzt __init_subclass__ Parameter {name} nicht.',
        typedDictNotAllowed: '"TypedDict" kann in diesem Kontext nicht verwendet werden.',
        typedDictSecondArgDict: 'Es wird ein dict- oder Schlsselwortparameter als zweiter Parameter erwartet.',
        typedDictSecondArgDictEntry: 'Einfacher Wrterbucheintrag erwartet',
        typedDictSet: 'Element konnte in TypedDict nicht zugewiesen werden.',
        unaccessedClass: 'Auf die Klasse "{name}" kann nicht zugegriffen werden.',
        unaccessedFunction: 'Auf die Funktion "{name}" kann nicht zugegriffen werden.',
        unaccessedImport: 'Auf den Import "{name}" kann nicht zugegriffen werden.',
        unaccessedSymbol: 'Auf "{name}" kann nicht zugegriffen werden.',
        unaccessedVariable: 'Auf die Variable "{name}" kann nicht zugegriffen werden.',
        unannotatedFunctionSkipped: 'Die Analyse der Funktion "{name}" wird bersprungen, da sie nicht kommentiert wurde.',
        unaryOperationNotAllowed: 'Der unre Operator ist im Typausdruck nicht zulssig',
        unexpectedAsyncToken: 'Es wurde erwartet, dass "def", "with" oder "for" auf "async" folgt.',
        unexpectedExprToken: 'Unerwartetes Token am Ende des Ausdrucks.',
        unexpectedIndent: 'Unerwarteter Einzug',
        unexpectedUnindent: '"Unindent" nicht erwartet.',
        unhashableDictKey: 'Der Wrterbuchschlssel muss hashbar sein.',
        unhashableSetEntry: 'Der Eintrag "Set" muss hashbar sein.',
        uninitializedAbstractVariables: 'In der abstrakten Basisklasse definierte Variablen sind in der final Klasse "{classType}" nicht initialisiert',
        uninitializedInstanceVariable: 'Die Instanzvariable "{name}" ist im Klassentext oder in der __init__ Methode nicht initialisiert.',
        unionForwardReferenceNotAllowed: 'Die Unionsyntax kann nicht mit einem Zeichenfolgenoperanden verwendet werden; verwenden Sie Anfhrungszeichen um den gesamten Ausdruck',
        unionSyntaxIllegal: 'Alternative Syntax fr Unions erfordert Python 3.10 oder hher.',
        unionTypeArgCount: 'Union erfordert mindestens zwei Typargumente.',
        unionUnpackedTuple: 'Union kann kein entpacktes tuple enthalten.',
        unionUnpackedTypeVarTuple: 'Die Union kann kein entpacktes TypeVarTuple enthalten.',
        unnecessaryCast: 'Nicht erforderlicher "cast"-Aufruf; der Typ ist bereits "{type}".',
        unnecessaryIsInstanceAlways: 'Nicht erforderlicher isinstance-Aufruf; "{testType}" ist immer eine Instanz von "{classType}"',
        unnecessaryIsInstanceNever: 'Nicht erforderlicher isinstance-Aufruf; "{testType}" ist nie eine Instanz von "{classType}"',
        unnecessaryIsSubclassAlways: 'Nicht erforderlicher issubclass-Aufruf; "{testType}" ist immer eine Unterklasse von "{classType}"',
        unnecessaryIsSubclassNever: 'Nicht erforderlicher issubclass-Aufruf; "{testType}" ist nie eine Unterklasse von "{classType}"',
        unnecessaryPyrightIgnore: 'Unntiger "# pyright: ignore"-Kommentar',
        unnecessaryPyrightIgnoreRule: 'Unntiger "# pyright: ignore"-Regel: "{name}"',
        unnecessaryTypeIgnore: 'Nicht erforderlicher "# type: ignore"-Kommentar',
        unpackArgCount: 'Nach "Unpack" wurde ein einzelnes Typargument erwartet.',
        unpackExpectedTypeVarTuple: 'TypeVarTuple oder tuple als Typargument fr Unpack erwartet',
        unpackExpectedTypedDict: 'TypedDict-Typargument fr Unpack erwartet',
        unpackIllegalInComprehension: 'Der Entpackvorgang ist in Verstndnis nicht zulssig.',
        unpackInAnnotation: 'Der Operator zum Entpacken ist im Typausdruck nicht zulssig',
        unpackInDict: 'Der Entpackvorgang ist in Wrterbchern nicht zulssig.',
        unpackInSet: 'Der Operator zum Entpacken ist innerhalb einer Menge set nicht zulssig.',
        unpackNotAllowed: '"Unpack" ist in diesem Kontext nicht zulssig.',
        unpackOperatorNotAllowed: 'Der Entpackvorgang ist in diesem Kontext nicht zulssig.',
        unpackTuplesIllegal: 'Der Entpackvorgang ist in Tupeln vor Python 3.8 nicht zulssig.',
        unpackedArgInTypeArgument: 'Nicht gepackte Argumente knnen in diesem Kontext nicht verwendet werden.',
        unpackedArgWithVariadicParam: 'Das nicht gepackte Argument kann nicht fr den Parameter "TypeVarTuple" verwendet werden.',
        unpackedDictArgumentNotMapping: 'Der Argumentausdruck nach ** muss eine Zuordnung mit dem Schlsseltyp "str" sein.',
        unpackedDictSubscriptIllegal: 'Der Operator zum Entpacken des Wrterbuchs in tiefgestellten Zeichen ist nicht zulssig.',
        unpackedSubscriptIllegal: 'Das Entpacken des Operators im Tiefstellungsskript erfordert Python 3.11 oder hher.',
        unpackedTypeVarTupleExpected: 'Nicht gepackter TypeVarTuple erwartet; verwenden Sie Unpack[{name1}] oder *{name2}',
        unpackedTypedDictArgument: 'Das entpackte TypedDict-Argument kann nicht mit Parametern abgelichen werden.',
        unreachableCode: 'Der Code ist nicht erreichbar.',
        unreachableCodeType: 'Typanalyse weist darauf hin, dass Code nicht erreichbar ist',
        unreachableExcept: 'Die except-Klausel ist nicht erreichbar, weil die Ausnahme bereits behandelt wird.',
        unsupportedDunderAllOperation: 'Der Vorgang fr "__all__" wird nicht untersttzt, daher ist die exportierte Symbolliste mglicherweise falsch.',
        unusedCallResult: 'Das Ergebnis des Aufrufausdrucks ist vom Typ "{type}" und wird nicht verwendet; der Variablen "_" zuweisen, wenn dies beabsichtigt ist',
        unusedCoroutine: 'Das Ergebnis eines asynchronen Funktionsaufrufs wird nicht verwendet; verwenden Sie "await", oder weisen Sie der Variablen ein Ergebnis zu.',
        unusedExpression: 'Der Ausdruckswert wird nicht verwendet.',
        varAnnotationIllegal: 'Type Anmerkungen fr Variablen erfordern Python 3.6 oder hher; verwenden Sie den type Kommentar fr Kompatibilitt mit frheren Versionen',
        variableFinalOverride: 'Die Variable "{name}" ist als "Final" gekennzeichnet und berschreibt die Nicht-Final-Variable desselben Namens in der Klasse "{className}"',
        variadicTypeArgsTooMany: 'Die Liste der Typargumente darf hchstens ein entpacktes TypeVarTuple oder tuple enthalten.',
        variadicTypeParamTooManyAlias: 'Der Typalias darf hchstens einen TypeVarTuple-Typparameter aufweisen, es wurden jedoch mehrere ({names}) empfangen.',
        variadicTypeParamTooManyClass: 'Die generische Klasse darf hchstens einen TypeVarTuple-Typparameter aufweisen, es wurden jedoch mehrere ({names}) empfangen.',
        walrusIllegal: 'Der Operator ":=" erfordert Python 3.8 oder hher.',
        walrusNotAllowed: 'Der Operator ":=" ist in diesem Kontext ohne umgebende Klammern nicht zulssig.',
        wildcardInFunction: 'Der Platzhalterimport ist innerhalb einer Klasse oder Funktion nicht zulssig.',
        wildcardLibraryImport: 'Der Platzhalterimport aus einer Bibliothek ist nicht zulssig.',
        wildcardPatternTypePartiallyUnknown: 'Der durch das Platzhaltermuster erfasste Typ ist teilweise unbekannt.',
        wildcardPatternTypeUnknown: 'Der durch das Platzhaltermuster erfasste Typ ist unbekannt.',
        yieldFromIllegal: 'Die Verwendung von "yield from" erfordert Python 3.3 oder hher.',
        yieldFromOutsideAsync: '"yield from" ist in einer asynchronen Funktion nicht zulssig.',
        yieldOutsideFunction: '"yield" ist auerhalb einer Funktion oder eines Lambdas nicht zulssig.',
        yieldWithinComprehension: 'yield ist innerhalb eines Verstndnisses nicht zulssig',
        zeroCaseStatementsFound: 'Die match-Anweisung muss mindestens eine case-Anweisung enthalten',
        zeroLengthTupleNotAllowed: 'Zero-length tuple is not allowed in this context'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Das Sonderformular Annotated kann nicht mit Instanz- und Klassenberprfungen verwendet werden.',
        argParam: 'Argument entspricht Parameter "{paramName}"',
        argParamFunction: 'Argument entspricht Parameter "{paramName}" in Funktion "{functionName}"',
        argsParamMissing: 'Der Parameter "*{paramName}" weist keinen entsprechenden Parameter auf.',
        argsPositionOnly: 'Nicht bereinstimmende Parameteranmerkungsanzahl: {expected} erwartet, aber {received} empfangen',
        argumentType: 'Argumenttyp ist "{type}"',
        argumentTypes: 'Argumenttypen: ({types})',
        assignToNone: 'Der Typ kann nicht None zugewiesen werden.',
        asyncHelp: 'Meinten Sie "async with"?',
        baseClassIncompatible: 'Die Basisklasse "{baseClass}" ist nicht mit dem Typ "{type}" kompatibel.',
        baseClassIncompatibleSubclass: 'Die Basisklasse "{baseClass}" wird von "{subclass}" abgeleitet, die mit dem Typ "{type}" nicht kompatibel ist.',
        baseClassOverriddenType: 'Die Basisklasse "{baseClass}" stellt einen Typ "{type}" bereit, der berschrieben wird.',
        baseClassOverridesType: 'Basisklasse "{baseClass}" berschreibt mit Typ "{type}"',
        bytesTypePromotions: 'Legen Sie disableBytesTypePromotions auf false fest, um das Typerweiterungsverhalten fr "bytearray" und "memoryview" zu aktivieren.',
        conditionalRequiresBool: 'Die Methode __bool__ fr den Typ "{operandType}" gibt den Typ "{boolReturnType}" anstelle von "bool" zurck',
        dataClassFieldLocation: 'Felddeklaration',
        dataClassFrozen: '"{name}" ist fixiert',
        dataProtocolUnsupported: '{name} ist ein Datenprotokoll.',
        descriptorAccessBindingFailed: 'Fehler beim Binden der Methode {name} fr die Deskriptorklasse {className}',
        descriptorAccessCallFailed: 'Fehler beim Aufrufen der Methode {name} fr die Deskriptorklasse {className}',
        finalMethod: 'Final Methode',
        functionParamDefaultMissing: 'Standardargument fr Parameter "{name}" fehlt.',
        functionParamName: 'Parameternamen stimmen nicht berein: "{destName}" und "{srcName}"',
        functionParamPositionOnly: 'Nicht bereinstimmender Parameter nur fr Position. Der Parameter {name} ist nicht nur fr Position.',
        functionReturnTypeMismatch: 'Der Funktionsrckgabetyp "{sourceType}" ist nicht mit dem Typ "{destType}" kompatibel.',
        functionTooFewParams: 'Die Funktion akzeptiert zu wenige Positionsparameter; {expected} erwartet, aber {received} empfangen',
        functionTooManyParams: 'Die Funktion akzeptiert zu viele Positionsparameter; {expected} erwartet, aber {received} empfangen',
        genericClassNotAllowed: 'Ein generischer Typ mit Typargumenten ist fr Instanz- oder Klassenprfungen nicht zulssig.',
        incompatibleDeleter: 'Die deleter Methode der Property ist nicht kompatibel.',
        incompatibleGetter: 'Die Property getter Methode ist nicht kompatibel.',
        incompatibleSetter: 'Die Property setter Methode ist nicht kompatibel.',
        initMethodLocation: 'Die __init__ Methode ist in der Klasse "{type}" definiert.',
        initMethodSignature: 'Die Signatur von __init__ ist "{type}".',
        initSubclassLocation: 'Die __init_subclass__ Methode ist in der Klasse "{name}" definiert.',
        invariantSuggestionDict: 'Erwgen Sie den Wechsel von "dict" zu "Mapping" (im Werttyp covariant).',
        invariantSuggestionList: 'Erwgen Sie den Wechsel von "list" zu "Sequence" (covariant).',
        invariantSuggestionSet: 'Erwgen Sie den Wechsel von set zu Container, der Kovariante ist.',
        isinstanceClassNotSupported: '{type} wird fr Instanz- und Klassenberprfungen nicht untersttzt.',
        keyNotRequired: '"{name}" ist kein erforderlicher Schlssel in "{type}". Der Zugriff kann daher zu einer Laufzeitausnahme fhren.',
        keyReadOnly: '"{name}" ist ein schreibgeschtzter Schlssel in "{type}"',
        keyRequiredDeleted: '"{name}" ist ein erforderlicher Schlssel und kann nicht gelscht werden.',
        keyUndefined: '"{name}" ist kein definierter Schlssel in "{type}"',
        kwargsParamMissing: 'Der Parameter "**{paramName}" weist keinen entsprechenden Parameter auf.',
        listAssignmentMismatch: 'Der Typ "{type}" ist nicht mit der Zielliste kompatibel.',
        literalAssignmentMismatch: '{sourceType} kann dem Typ {destType} nicht zugewiesen werden.',
        matchIsNotExhaustiveHint: 'Wenn keine ausfhrliche Behandlung beabsichtigt ist, fgen Sie "case _: pass" hinzu.',
        matchIsNotExhaustiveType: 'Unbehandelter Typ: "{type}"',
        memberAssignment: 'Ein Ausdruck vom Typ {type} kann dem Attribut {name} der Klasse {classType} nicht zugewiesen werden',
        memberIsAbstract: '{type}. {name} ist nicht implementiert.',
        memberIsAbstractMore: 'und {count} weitere...',
        memberIsClassVarInProtocol: '{name} ist als ClassVar im Protokoll definiert.',
        memberIsInitVar: '{name} ist ein init-only-Feld.',
        memberIsInvariant: '"{name}" ist invariant, da es nderbar ist.',
        memberIsNotClassVarInClass: '{name} muss als ClassVar definiert sein, um mit dem Protokoll kompatibel zu sein.',
        memberIsNotClassVarInProtocol: '{name} ist nicht als ClassVar im Protokoll definiert.',
        memberIsNotReadOnlyInProtocol: '"{name}" ist im Protokoll nicht schreibgeschtzt.',
        memberIsReadOnlyInProtocol: '"{name}" ist im Protokoll schreibgeschtzt.',
        memberIsWritableInProtocol: '"{name}" ist im Protokoll beschreibbar.',
        memberSetClassVar: 'Attribut {name} kann nicht ber eine Klasseninstanz zugewiesen werden, da es sich um eine ClassVar handelt',
        memberTypeMismatch: '"{name}" ist ein inkompatibler Typ.',
        memberUnknown: 'Das Attribut {name} ist unbekannt',
        metaclassConflict: 'Die Metaklasse "{metaclass1}" verursacht einen Konflikt mit "{metaclass2}"',
        missingDeleter: 'Die Property deleter Methode fehlt.',
        missingGetter: 'Die Property getter Methode fehlt.',
        missingSetter: 'Die Property setter Methode fehlt.',
        namedParamMissingInDest: 'Zustzlicher Parameter "{name}"',
        namedParamMissingInSource: 'Fehlender Schlsselwortparameter "{name}"',
        namedParamTypeMismatch: 'Der Schlsselwortparameter {name} vom Typ {sourceType} ist nicht mit dem Typ {destType} kompatibel',
        namedTupleNotAllowed: 'NamedTuple kann nicht fr Instanzen- oder Klassenberprfungen verwendet werden.',
        newMethodLocation: 'Die __new__ Methode ist in der Klasse "{type}" definiert.',
        newMethodSignature: 'Signatur von __new__ ist "{type}"',
        newTypeClassNotAllowed: 'Die mit NewType erstellte Klasse kann nicht mit Instanz- und Klassenberprfungen verwendet werden.',
        noOverloadAssignable: 'Keine berladene Funktion stimmt mit dem Typ "{type}" berein.',
        noneNotAllowed: '"None" kann nicht fr Instanz- oder Klassenprfungen verwendet werden.',
        orPatternMissingName: 'Fehlende Namen: {name}',
        overloadIndex: 'berladung "{index}" ist die nchste bereinstimmung.',
        overloadNotAssignable: 'Mindestens eine berladung von "{name}" kann nicht zugewiesen werden.',
        overloadSignature: 'Die berladungssignatur ist hier definiert.',
        overriddenMethod: 'berschriebene Methode',
        overriddenSymbol: 'Auer Kraft gesetztes Symbol',
        overrideInvariantMismatch: 'Der berschreibungstyp "{overrideType}" ist nicht identisch mit dem Basistyp "{baseType}".',
        overrideIsInvariant: 'Die Variable ist vernderlich, sodass ihr Typ unvernderlich ist.',
        overrideNoOverloadMatches: 'Keine berladungssignatur in berschreibung ist mit der Basismethode kompatibel.',
        overrideNotClassMethod: 'Die Basismethode ist als classmethod deklariert, die berschreibung jedoch nicht',
        overrideNotInstanceMethod: 'Die Basismethode ist als Instanz deklariert, die berschreibung jedoch nicht',
        overrideNotStaticMethod: 'Die Basismethode ist als staticmethod deklariert, die berschreibung jedoch nicht',
        overrideOverloadNoMatch: 'Auerkraftsetzung behandelt nicht alle berladungen der Basismethode.',
        overrideOverloadOrder: 'berladungen fr die berschreibungsmethode mssen in der gleichen Reihenfolge wie die Basismethode vorliegen.',
        overrideParamKeywordNoDefault: 'Konflikt mit Schlsselwortparameter "{name}": Der Basisparameter hat einen Standardargumentwert, der Auerkraftsetzungsparameter ist nicht identisch.',
        overrideParamKeywordType: 'Schlsselwortparameter "{name}" Typenkonflikt: Basisparameter ist Typ "{baseType}", berschreibungsparameter ist Typ "{overrideType}"',
        overrideParamName: 'Namenskonflikt mit Parameter {index}: Der Basisparameter hat den Namen "{baseName}", der Auerkraftsetzungsparameter ist "{overrideName}"',
        overrideParamNameExtra: 'Der Parameter "{name}" fehlt in der Basis.',
        overrideParamNameMissing: 'Der Parameter "{name}" fehlt in der Auerkraftsetzung.',
        overrideParamNamePositionOnly: 'Parameter {index} stimmt nicht berein: Basisparameter {baseName} ist Schlsselwortparameter, Auerkraftsetzungsparameter ist position-only.',
        overrideParamNoDefault: 'Konflikt mit Parameter {index}: Der Basisparameter hat einen Standardargumentwert, der Auerkraftsetzungsparameter ist nicht identisch.',
        overrideParamType: 'Parameter {index} Typenkonflikt: Basisparameter ist Typ "{baseType}", berschreibungsparameter ist Typ "{overrideType}"',
        overridePositionalParamCount: 'Anzahl der Positionsparameter stimmt nicht berein; die Basismethode hat {baseCount}, aber die berschreibung hat {overrideCount}',
        overrideReturnType: 'Rckgabetypkonflikt: Basismethode gibt Typ "{baseType}" zurck, berschreibung gibt Typ "{overrideType}" zurck',
        overrideType: 'Die Basisklasse definiert den Typ als "{type}"',
        paramAssignment: 'Parameter {index}: Typ {sourceType} ist nicht mit dem Typ {destType} kompatibel',
        paramSpecMissingInOverride: 'Parameter "ParamSpec" fehlen in der berschreibungsmethode.',
        paramType: 'Parametertyp ist "{paramType}"',
        privateImportFromPyTypedSource: 'Stattdessen aus "{module}" importieren',
        propertyAccessFromProtocolClass: 'Auf eine in einer Protokollklasse definierte Eigenschaft kann nicht als Klassenvariable zugegriffen werden.',
        propertyMethodIncompatible: 'Die Property-Methode "{name}" ist inkompatibel.',
        propertyMethodMissing: 'Die Property-Methode "{name}" fehlt in der berschreibung.',
        propertyMissingDeleter: 'Property "{name}" hat keinen definierten deleter.',
        propertyMissingSetter: 'Property "{name}" hat keinen definierten setter.',
        protocolIncompatible: '"{sourceType}" ist nicht mit dem Protokoll "{destType}" kompatibel.',
        protocolMemberMissing: '"{name}" ist nicht vorhanden.',
        protocolRequiresRuntimeCheckable: 'Die Protocol Klasse muss @runtime_checkable sein, damit sie mit Instanz- und Klassenprfungen verwendet werden kann.',
        protocolSourceIsNotConcrete: '"{sourceType}" ist kein konkreter Klassentyp und kann dem Typ "{destType}" nicht zugewiesen werden.',
        protocolUnsafeOverlap: 'Attribute von {name} weisen die gleichen Namen wie das Protokoll auf.',
        pyrightCommentIgnoreTip: 'Verwenden Sie "# pyright: ignore[<diagnostic rules>]", um die Diagnose fr eine einzelne Zeile zu unterdrcken.',
        readOnlyAttribute: 'Das Attribut "{name}" ist schreibgeschtzt.',
        seeClassDeclaration: 'Siehe Klassendeklaration',
        seeDeclaration: 'Siehe Deklaration',
        seeFunctionDeclaration: 'Siehe Funktionsdeklaration',
        seeMethodDeclaration: 'Siehe Methodendeklaration',
        seeParameterDeclaration: 'Siehe Parameterdeklaration',
        seeTypeAliasDeclaration: 'Siehe Typaliasdeklaration',
        seeVariableDeclaration: 'Siehe Variablendeklaration',
        tupleAssignmentMismatch: 'Der Typ "{type}" ist nicht mit dem Ziel-tuple kompatibel.',
        tupleEntryTypeMismatch: 'Der Tuple-eintrag {entry} ist ein falscher Typ.',
        tupleSizeIndeterminateSrc: 'Nicht bereinstimmende Tuple Gre; {expected} erwartet, aber unbestimmt empfangen',
        tupleSizeIndeterminateSrcDest: 'Nicht bereinstimmende Tuple Gre; {expected} oder mehr erwartet, aber unbestimmt empfangen',
        tupleSizeMismatch: 'Nicht bereinstimmende Tuple Gre; {expected} erwartet, aber {received} empfangen',
        tupleSizeMismatchIndeterminateDest: 'Nicht bereinstimmende Tuple Gre; {expected} oder mehr erwartet, aber {received} empfangen',
        typeAliasInstanceCheck: 'Der mit der type-Anweisung erstellte Typalias kann nicht mit Instanz- und Klassenberprfungen verwendet werden.',
        typeAssignmentMismatch: 'Der Typ {sourceType} kann dem Typ {destType} nicht zugewiesen werden.',
        typeBound: 'Der Typ {sourceType} kann der oberen Grenze {destType} fr die Typvariable {name} nicht zugewiesen werden.',
        typeConstrainedTypeVar: 'Der Typ {type} kann der eingeschrnkten Typvariablen {name} nicht zugewiesen werden',
        typeIncompatible: '{sourceType} kann {destType} nicht zugewiesen werden.',
        typeNotClass: '"{type}" ist keine Klasse.',
        typeNotStringLiteral: '"{type}" ist kein Zeichenfolgenliteral.',
        typeOfSymbol: 'Der Typ von "{name}" ist "{type}".',
        typeParamSpec: 'Typ "{type}" ist nicht mit ParamSpec "{name}" kompatibel.',
        typeUnsupported: 'Typ "{type}" wird nicht untersttzt.',
        typeVarDefaultOutOfScope: 'Die Typvariable "{name}" befindet sich nicht im Bereich.',
        typeVarIsContravariant: 'Der Typparameter "{name}" ist kontravariant, aber "{sourceType}" ist kein Supertyp von "{destType}"',
        typeVarIsCovariant: 'Der Typparameter "{name}" ist kovariant, aber "{sourceType}" ist kein Untertyp von "{destType}"',
        typeVarIsInvariant: 'Der Typparameter "{name}" ist invariant, "{sourceType}" ist jedoch nicht identisch mit "{destType}"',
        typeVarNotAllowed: 'TypeVar ist fr Instanz- oder Klassenprfungen nicht zulssig.',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple kann nicht an tuple unbekannter Lnge gebunden werden.',
        typeVarUnnecessarySuggestion: 'Stattdessen {type} verwenden',
        typeVarUnsolvableRemedy: 'Geben Sie eine berladung an, die den Rckgabetyp angibt, wenn das Argument nicht angegeben ist.',
        typeVarsMissing: 'Fehlende Typvariablen: {names}',
        typedDictBaseClass: 'Die Klasse "{type}" ist kein TypedDict.',
        typedDictClassNotAllowed: 'Die TypedDict-Klasse ist fr Instanz- oder Klassenberprfungen nicht zulssig.',
        typedDictClosedExtraNotAllowed: 'Das Element {name} kann nicht hinzugefgt werden.',
        typedDictClosedExtraTypeMismatch: 'Das Element {name} mit dem Typ {type} kann nicht hinzugefgt werden.',
        typedDictClosedFieldNotRequired: 'Das Element {name} kann nicht hinzugefgt werden, da es NotRequired sein muss.',
        typedDictExtraFieldNotAllowed: '{name} ist in {type} nicht vorhanden.',
        typedDictExtraFieldTypeMismatch: 'Der Typ von {name} ist nicht mit dem Typ extra_items in {type} kompatibel.',
        typedDictFieldMissing: '"{name}" fehlt in "{type}"',
        typedDictFieldNotReadOnly: '"{name}" ist in "{type}" nicht schreibgeschtzt.',
        typedDictFieldNotRequired: '"{name}" ist in "{type}" nicht erforderlich.',
        typedDictFieldRequired: '"{name}" ist in "{type}" erforderlich.',
        typedDictFieldTypeMismatch: 'Der Typ {type} kann dem Element {name} nicht zugewiesen werden.',
        typedDictFieldUndefined: '{name} ist ein nicht definiertes Element im Typ {type}.',
        typedDictFinalMismatch: '"{sourceType}" ist aufgrund eines @final-Konflikts nicht mit "{destType}" kompatibel.',
        typedDictKeyAccess: '["{name}"] verwenden, um in TypedDict auf ein Element zu verweisen',
        typedDictNotAllowed: 'TypedDict kann nicht fr Instanzen- oder Klassenberprfungen verwendet werden.',
        unhashableType: 'Der Typ "{type}" kann nicht mit einem Hash erstellt werden.',
        uninitializedAbstractVariable: 'Die Instanzvariable "{name}" ist in einer abstrakten Basisklasse "{classType}" definiert, aber nicht initialisiert.',
        unreachableExcept: '"{exceptionType}" ist eine Unterklasse von "{parentType}"',
        useDictInstead: 'Verwenden Sie Dict[T1, T2], um einen Wrterbuchtyp anzugeben.',
        useListInstead: 'Verwenden Sie List[T], um einen list Typ anzugeben, oder Union[T1, T2], um einen union-Typ anzugeben.',
        useTupleInstead: 'Verwenden Sie tuple[T1, ..., Tn], um einen tuple-Typ anzugeben, oder Union[T1, T2], um einen union-Typ anzugeben.',
        useTypeInstead: 'Stattdessen Type[T] verwenden',
        varianceMismatchForClass: 'Die Varianz des Typarguments "{typeVarName}" ist nicht mit der Basisklasse "{className}" kompatibel',
        varianceMismatchForTypeAlias: 'Die Varianz des Typarguments "{typeVarName}" ist nicht mit "{typeAliasParam}" kompatibel'
      },
      Service: {
        longOperation: 'Das Aufzhlen von Arbeitsbereichsquelldateien nimmt viel Zeit in Anspruch. Erwgen Sie stattdessen, einen Unterordner zu ffnen. [Weitere Informationen](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  84268: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: {
          message: 'Create Type Stub',
          comment: '{Locked=\'Stub\'}'
        },
        createTypeStubFor: {
          message: 'Create Type Stub For "{moduleName}"',
          comment: '{Locked=\'Stub\'}'
        },
        executingCommand: 'Executing command',
        filesToAnalyzeCount: '{count} files to analyze',
        filesToAnalyzeOne: '1 file to analyze',
        findingReferences: 'Finding references',
        organizeImports: 'Organize Imports',
        renameShadowedFile: 'Rename "{oldFile}" to "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Auto-import',
        indexValueDetail: 'Index value'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Method "{method}" cannot be called because it is abstract and unimplemented',
        annotatedMetadataInconsistent: 'Annotated metadata type "{metadataType}" is not compatible with type "{type}"',
        annotatedParamCountMismatch: 'Parameter annotation count mismatch: expected {expected} but received {received}',
        annotatedTypeArgMissing: {
          message: 'Expected one type argument and one or more annotations for "Annotated"',
          comment: '{Locked=\'Annotated\'}'
        },
        annotationBytesString: 'Type expressions cannot use bytes string literals',
        annotationFormatString: {
          message: 'Type expressions cannot use format string literals (f-strings)',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        annotationNotSupported: 'Type annotation not supported for this statement',
        annotationRawString: 'Type expressions cannot use raw string literals',
        annotationSpansStrings: 'Type expressions cannot span multiple string literals',
        annotationStringEscape: 'Type expressions cannot contain escape characters',
        argAssignment: 'Argument of type "{argType}" cannot be assigned to parameter of type "{paramType}"',
        argAssignmentFunction: 'Argument of type "{argType}" cannot be assigned to parameter of type "{paramType}" in function "{functionName}"',
        argAssignmentParam: 'Argument of type "{argType}" cannot be assigned to parameter "{paramName}" of type "{paramType}"',
        argAssignmentParamFunction: 'Argument of type "{argType}" cannot be assigned to parameter "{paramName}" of type "{paramType}" in function "{functionName}"',
        argMissingForParam: 'Argument missing for parameter {name}',
        argMissingForParams: 'Arguments missing for parameters {names}',
        argMorePositionalExpectedCount: 'Expected {expected} more positional arguments',
        argMorePositionalExpectedOne: 'Expected 1 more positional argument',
        argPositional: 'Expected positional argument',
        argPositionalExpectedCount: 'Expected {expected} positional arguments',
        argPositionalExpectedOne: 'Expected 1 positional argument',
        argTypePartiallyUnknown: 'Argument type is partially unknown',
        argTypeUnknown: 'Argument type is unknown',
        assertAlwaysTrue: {
          message: 'Assert expression always evaluates to true',
          comment: '{Locked=\'true\'}'
        },
        assertTypeArgs: {
          message: '"assert_type" expects two positional arguments',
          comment: '{Locked=\'assert_type\'}'
        },
        assertTypeTypeMismatch: {
          message: '"assert_type" mismatch: expected "{expected}" but received "{received}"',
          comment: '{Locked=\'assert_type\'}'
        },
        assignmentExprComprehension: {
          message: 'Assignment expression target "{name}" cannot use same name as comprehension for target',
          comment: 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable'
        },
        assignmentExprContext: 'Assignment expression must be within module, function or lambda',
        assignmentExprInSubscript: 'Assignment expressions within a subscript are supported only in Python 3.10 and newer',
        assignmentInProtocol: {
          message: 'Instance or class variables within a Protocol class must be explicitly declared within the class body',
          comment: '{Locked=\'Protocol\'}'
        },
        assignmentTargetExpr: 'Expression cannot be assignment target',
        asyncNotInAsyncFunction: {
          message: 'Use of "async" not allowed outside of async function',
          comment: '{Locked=\'async\'}'
        },
        awaitIllegal: {
          message: 'Use of "await" requires Python 3.5 or newer',
          comment: '{Locked=\'await\'}'
        },
        awaitNotAllowed: {
          message: 'Type expressions cannot use "await"',
          comment: '{Locked=\'await\'}'
        },
        awaitNotInAsync: {
          message: '"await" allowed only within async function',
          comment: '{Locked=\'await\',\'async\'}'
        },
        backticksIllegal: {
          message: 'Expressions surrounded by backticks are not supported in Python 3.x; use repr instead',
          comment: '{Locked=\'repr\'}'
        },
        baseClassCircular: 'Class cannot derive from itself',
        baseClassFinal: {
          message: 'Base class "{type}" is marked final and cannot be subclassed',
          comment: '{Locked=\'final\'}'
        },
        baseClassIncompatible: 'Base classes of {type} are mutually incompatible',
        baseClassInvalid: 'Argument to class must be a base class',
        baseClassMethodTypeIncompatible: 'Base classes for class "{classType}" define method "{name}" in incompatible way',
        baseClassUnknown: 'Base class type is unknown, obscuring type of derived class',
        baseClassVariableTypeIncompatible: 'Base classes for class "{classType}" define variable "{name}" in incompatible way',
        binaryOperationNotAllowed: 'Binary operator not allowed in type expression',
        bindTypeMismatch: {
          message: 'Could not bind method "{methodName}" because "{type}" is not assignable to parameter "{paramName}"',
          comment: 'Binding is the process through which Pyright determines what object a name refers to'
        },
        breakInExceptionGroup: {
          message: '"break" is not allowed in an "except*" block',
          comment: '{Locked=\'break\',\'except*\'}'
        },
        breakOutsideLoop: {
          message: '"break" can be used only within a loop',
          comment: '{Locked=\'break\'}'
        },
        callableExtraArgs: {
          message: 'Expected only two type arguments to "Callable"',
          comment: '{Locked=\'Callable\'}'
        },
        callableFirstArg: 'Expected parameter type list or "..."',
        callableNotInstantiable: 'Cannot instantiate type "{type}"',
        callableSecondArg: {
          message: 'Expected return type as second type argument for "Callable"',
          comment: '{Locked=\'Callable\'}'
        },
        casePatternIsIrrefutable: 'Irrefutable pattern is allowed only for the last case statement',
        classAlreadySpecialized: 'Type "{type}" is already specialized',
        classDecoratorTypeUnknown: 'Untyped class decorator obscures type of class; ignoring decorator',
        classDefinitionCycle: 'Class definition for "{name}" depends on itself',
        classGetItemClsParam: {
          message: '__class_getitem__ override should take a "cls" parameter',
          comment: '{Locked=\'__class_getitem__\',\'cls\'}'
        },
        classMethodClsParam: {
          message: 'Class methods should take a "cls" parameter',
          comment: '{Locked=\'cls\'}'
        },
        classNotRuntimeSubscriptable: 'Subscript for class "{name}" will generate runtime exception; enclose type expression in quotes',
        classPatternBuiltInArgPositional: 'Class pattern accepts only positional sub-pattern',
        classPatternPositionalArgCount: 'Too many positional patterns for class "{type}"; expected {expected} but received {received}',
        classPatternTypeAlias: '"{type}" cannot be used in a class pattern because it is a specialized type alias',
        classPropertyDeprecated: 'Class properties are deprecated in Python 3.11 and will not be supported in Python 3.13',
        classTypeParametersIllegal: 'Class type parameter syntax requires Python 3.12 or newer',
        classVarFirstArgMissing: {
          message: 'Expected a type argument after "ClassVar"',
          comment: '{Locked=\'ClassVar\'}'
        },
        classVarNotAllowed: {
          message: '"ClassVar" is not allowed in this context',
          comment: '{Locked=\'ClassVar\'}'
        },
        classVarOverridesInstanceVar: 'Class variable "{name}" overrides instance variable of same name in class "{className}"',
        classVarTooManyArgs: {
          message: 'Expected only one type argument after "ClassVar"',
          comment: '{Locked=\'ClassVar\'}'
        },
        classVarWithTypeVar: {
          message: '"ClassVar" type cannot include type variables',
          comment: '{Locked=\'ClassVar\'}'
        },
        clsSelfParamTypeMismatch: 'Type of parameter "{name}" must be a supertype of its class "{classType}"',
        codeTooComplexToAnalyze: 'Code is too complex to analyze; reduce complexity by refactoring into subroutines or reducing conditional code paths',
        collectionAliasInstantiation: 'Type "{type}" cannot be instantiated, use "{alias}" instead',
        comparisonAlwaysFalse: {
          message: 'Condition will always evaluate to False since the types "{leftType}" and "{rightType}" have no overlap',
          comment: '{Locked=\'False\'}'
        },
        comparisonAlwaysTrue: {
          message: 'Condition will always evaluate to True since the types "{leftType}" and "{rightType}" have no overlap',
          comment: '{Locked=\'True\'}'
        },
        comprehensionInDict: {
          message: 'Comprehension cannot be used with other dictionary entries',
          comment: 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable'
        },
        comprehensionInSet: {
          message: 'Comprehension cannot be used with other set entries',
          comment: ['{Locked=\'set\'}', 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable']
        },
        concatenateContext: {
          message: '"Concatenate" is not allowed in this context',
          comment: '{Locked=\'Concatenate\'}'
        },
        concatenateParamSpecMissing: {
          message: 'Last type argument for "Concatenate" must be a ParamSpec or "..."',
          comment: '{Locked=\'Concatenate\',\'ParamSpec\',\'...\'}'
        },
        concatenateTypeArgsMissing: {
          message: '"Concatenate" requires at least two type arguments',
          comment: '{Locked=\'Concatenate\'}'
        },
        conditionalOperandInvalid: 'Invalid conditional operand of type "{type}"',
        constantRedefinition: '"{name}" is constant (because it is uppercase) and cannot be redefined',
        constructorParametersMismatch: {
          message: 'Mismatch between signature of __new__ and __init__ in class "{classType}"',
          comment: '{Locked=\'__new__\',\'__init__\'}'
        },
        containmentAlwaysFalse: {
          message: 'Expression will always evaluate to False since the types "{leftType}" and "{rightType}" have no overlap',
          comment: '{Locked=\'False\'}'
        },
        containmentAlwaysTrue: {
          message: 'Expression will always evaluate to True since the types "{leftType}" and "{rightType}" have no overlap',
          comment: '{Locked=\'True\'}'
        },
        continueInExceptionGroup: {
          message: '"continue" is not allowed in an "except*" block',
          comment: '{Locked=\'continue\',\'except*\'}'
        },
        continueOutsideLoop: {
          message: '"continue" can be used only within a loop',
          comment: '{Locked=\'continue\'}'
        },
        coroutineInConditionalExpression: {
          message: 'Conditional expression references coroutine which always evaluates to True',
          comment: '{Locked=\'True\'}'
        },
        dataClassBaseClassFrozen: 'A non-frozen class cannot inherit from a class that is frozen',
        dataClassBaseClassNotFrozen: 'A frozen class cannot inherit from a class that is not frozen',
        dataClassConverterFunction: 'Argument of type "{argType}" is not a valid converter for field "{fieldName}" of type "{fieldType}"',
        dataClassConverterOverloads: 'No overloads of "{funcName}" are valid converters for field "{fieldName}" of type "{fieldType}"',
        dataClassFieldInheritedDefault: '"{fieldName}" overrides a field of the same name but is missing a default value',
        dataClassFieldWithDefault: 'Fields without default values cannot appear after fields with default values',
        dataClassFieldWithPrivateName: 'Dataclass field cannot use private name',
        dataClassFieldWithoutAnnotation: 'Dataclass field without type annotation will cause runtime exception',
        dataClassPostInitParamCount: {
          message: 'Dataclass __post_init__ incorrect parameter count; number of InitVar fields is {expected}',
          comment: '{Locked=\'__post_init__\',\'InitVar\'}'
        },
        dataClassPostInitType: {
          message: 'Dataclass __post_init__ method parameter type mismatch for field "{fieldName}"',
          comment: '{Locked=\'__post_init__\'}'
        },
        dataClassSlotsOverwrite: {
          message: '__slots__ is already defined in class',
          comment: '{Locked=\'__slots__\'}'
        },
        dataClassTransformExpectedBoolLiteral: {
          message: 'Expected expression that statically evaluates to True or False',
          comment: '{Locked=\'True\',\'False\'}'
        },
        dataClassTransformFieldSpecifier: {
          message: 'Expected tuple of classes or functions but received type "{type}"',
          comment: '{Locked=\'tuple\'}'
        },
        dataClassTransformPositionalParam: {
          message: 'All arguments to "dataclass_transform" must be keyword arguments',
          comment: '{Locked=\'dataclass_transform\'}'
        },
        dataClassTransformUnknownArgument: {
          message: 'Argument "{name}" is not supported by dataclass_transform',
          comment: '{Locked=\'dataclass_transform\'}'
        },
        dataProtocolInSubclassCheck: {
          message: 'Data protocols (which include non-method attributes) are not allowed in issubclass calls',
          comment: '{Locked=\'issubclass\'}'
        },
        declaredReturnTypePartiallyUnknown: 'Declared return type, "{returnType}", is partially unknown',
        declaredReturnTypeUnknown: 'Declared return type is unknown',
        defaultValueContainsCall: 'Function calls and mutable objects not allowed within parameter default value expression',
        defaultValueNotAllowed: 'Parameter with "*" or "**" cannot have default value',
        delTargetExpr: 'Expression cannot be deleted',
        deprecatedClass: 'The class "{name}" is deprecated',
        deprecatedConstructor: 'The constructor for class "{name}" is deprecated',
        deprecatedDescriptorDeleter: 'The "__delete__" method for descriptor "{name}" is deprecated',
        deprecatedDescriptorGetter: 'The "__get__" method  for descriptor "{name}" is deprecated',
        deprecatedDescriptorSetter: 'The "__set__" method  for descriptor "{name}" is deprecated',
        deprecatedFunction: 'The function "{name}" is deprecated',
        deprecatedMethod: 'The method "{name}" in class "{className}" is deprecated',
        deprecatedPropertyDeleter: {
          message: 'The deleter for property "{name}" is deprecated',
          comment: '{Locked=\'deleter\',\'property\'}'
        },
        deprecatedPropertyGetter: {
          message: 'The getter for property "{name}" is deprecated',
          comment: '{Locked=\'getter\',\'property\'}'
        },
        deprecatedPropertySetter: {
          message: 'The setter for property "{name}" is deprecated',
          comment: '{Locked=\'setter\',\'property\'}'
        },
        deprecatedType: 'This type is deprecated as of Python {version}; use "{replacement}" instead',
        dictExpandIllegalInComprehension: {
          message: 'Dictionary expansion not allowed in comprehension',
          comment: 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable'
        },
        dictInAnnotation: 'Dictionary expression not allowed in type expression',
        dictKeyValuePairs: 'Dictionary entries must contain key/value pairs',
        dictUnpackIsNotMapping: 'Expected mapping for dictionary unpack operator',
        dunderAllSymbolNotPresent: {
          message: '"{name}" is specified in __all__ but is not present in module',
          comment: '{Locked=\'__all__\'}'
        },
        duplicateArgsParam: 'Only one "*" parameter allowed',
        duplicateBaseClass: 'Duplicate base class not allowed',
        duplicateCapturePatternTarget: 'Capture target "{name}" cannot appear more than once within the same pattern',
        duplicateCatchAll: {
          message: 'Only one catch-all except clause allowed',
          comment: '{Locked=\'except\'}'
        },
        duplicateEnumMember: {
          message: 'Enum member "{name}" is already declared',
          comment: '{Locked=\'Enum\'}'
        },
        duplicateGenericAndProtocolBase: {
          message: 'Only one Generic[...] or Protocol[...] base class allowed',
          comment: '{Locked=\'Generic[...]\',\'Protocol[...]\'}'
        },
        duplicateImport: '"{importName}" is imported more than once',
        duplicateKeywordOnly: 'Only one "*" separator allowed',
        duplicateKwargsParam: 'Only one "**" parameter allowed',
        duplicateParam: 'Duplicate parameter "{name}"',
        duplicatePositionOnly: 'Only one "/" parameter allowed',
        duplicateStarPattern: 'Only one "*" pattern allowed in a pattern sequence',
        duplicateStarStarPattern: 'Only one "**" entry allowed',
        duplicateUnpack: {
          message: 'Only one unpack operation allowed in list',
          comment: '{Locked=\'list\'}'
        },
        ellipsisAfterUnpacked: {
          message: '"..." cannot be used with an unpacked TypeVarTuple or tuple',
          comment: '{Locked=\'TypeVarTuple\',\'tuple\'}'
        },
        ellipsisContext: '"..." is not allowed in this context',
        ellipsisSecondArg: '"..." is allowed only as the second of two arguments',
        enumClassOverride: {
          message: 'Enum class "{name}" is final and cannot be subclassed',
          comment: '{Locked=\'Enum\',\'final\'}'
        },
        enumMemberDelete: {
          message: 'Enum member "{name}" cannot be deleted',
          comment: '{Locked=\'Enum\'}'
        },
        enumMemberSet: {
          message: 'Enum member "{name}" cannot be assigned',
          comment: '{Locked=\'Enum\'}'
        },
        enumMemberTypeAnnotation: {
          message: 'Type annotations are not allowed for enum members',
          comment: '{Locked=\'enum\'}'
        },
        exceptionGroupIncompatible: {
          message: 'Exception group syntax ("except*") requires Python 3.11 or newer',
          comment: '{Locked=\'except*\'}'
        },
        exceptGroupMismatch: {
          message: 'Try statement cannot include both "except" and "except*"',
          comment: '{Locked=\'except\',\'except*\'}'
        },
        exceptGroupRequiresType: {
          message: 'Exception group syntax ("except*") requires an exception type',
          comment: '{Locked=\'except*\'}'
        },
        exceptionGroupTypeIncorrect: {
          message: 'Exception type in except* cannot derive from BaseGroupException',
          comment: '{Locked=\'except*\',\'BaseGroupException\'}'
        },
        exceptionTypeIncorrect: {
          message: '"{type}" does not derive from BaseException',
          comment: '{Locked=\'BaseException\'}'
        },
        exceptionTypeNotClass: '"{type}" is not a valid exception class',
        exceptionTypeNotInstantiable: 'Constructor for exception type "{type}" requires one or more arguments',
        expectedAfterDecorator: 'Expected function or class declaration after decorator',
        expectedArrow: 'Expected "->" followed by return type annotation',
        expectedAsAfterException: {
          message: 'Expected "as" after exception type',
          comment: '{Locked=\'as\'}'
        },
        expectedAssignRightHandExpr: 'Expected expression to the right of "="',
        expectedBinaryRightHandExpr: 'Expected expression to the right of operator',
        expectedBoolLiteral: {
          message: 'Expected True or False',
          comment: '{Locked=\'True\',\'False\'}'
        },
        expectedCase: {
          message: 'Expected "case" statement',
          comment: '{Locked=\'case\'}'
        },
        expectedClassName: 'Expected class name',
        expectedCloseBrace: '"{" was not closed',
        expectedCloseBracket: '"[" was not closed',
        expectedCloseParen: '"(" was not closed',
        expectedColon: 'Expected ":"',
        expectedComplexNumberLiteral: {
          message: 'Expected complex number literal for pattern matching',
          comment: 'Complex numbers are a mathematical concept consisting of a real number and an imaginary number'
        },
        expectedDecoratorExpr: 'Expression form not supported for decorator prior to Python 3.9',
        expectedDecoratorName: 'Expected decorator name',
        expectedDecoratorNewline: 'Expected new line at end of decorator',
        expectedDelExpr: {
          message: 'Expected expression after "del"',
          comment: '{Locked=\'del\'}'
        },
        expectedElse: {
          message: 'Expected "else"',
          comment: '{Locked=\'else\'}'
        },
        expectedEquals: 'Expected "="',
        expectedExceptionClass: 'Invalid exception class or object',
        expectedExceptionObj: {
          message: 'Expected exception object, exception class or None',
          comment: '{Locked=\'None\'}'
        },
        expectedExpr: 'Expected expression',
        expectedFunctionAfterAsync: {
          message: 'Expected function definition after "async"',
          comment: '{Locked=\'async\'}'
        },
        expectedFunctionName: {
          message: 'Expected function name after "def"',
          comment: '{Locked=\'def\'}'
        },
        expectedIdentifier: 'Expected identifier',
        expectedImport: {
          message: 'Expected "import"',
          comment: '{Locked=\'import\'}'
        },
        expectedImportAlias: {
          message: 'Expected symbol after "as"',
          comment: '{Locked=\'as\'}'
        },
        expectedImportSymbols: {
          message: 'Expected one or more symbol names after "import"',
          comment: '{Locked=\'import\'}'
        },
        expectedIn: {
          message: 'Expected "in"',
          comment: '{Locked=\'in\'}'
        },
        expectedInExpr: {
          message: 'Expected expression after "in"',
          comment: '{Locked=\'in\'}'
        },
        expectedIndentedBlock: 'Expected indented block',
        expectedMemberName: 'Expected attribute name after "."',
        expectedModuleName: 'Expected module name',
        expectedNameAfterAs: {
          message: 'Expected symbol name after "as"',
          comment: '{Locked=\'as\'}'
        },
        expectedNamedParameter: 'Keyword parameter must follow "*"',
        expectedNewline: 'Expected newline',
        expectedNewlineOrSemicolon: 'Statements must be separated by newlines or semicolons',
        expectedOpenParen: 'Expected "("',
        expectedParamName: 'Expected parameter name',
        expectedPatternExpr: 'Expected pattern expression',
        expectedPatternSubjectExpr: 'Expected pattern subject expression',
        expectedPatternValue: {
          message: 'Expected pattern value expression of the form "a.b"',
          comment: '{Locked=\'a.b\'}'
        },
        expectedReturnExpr: {
          message: 'Expected expression after "return"',
          comment: '{Locked=\'return\'}'
        },
        expectedSliceIndex: 'Expected index or slice expression',
        expectedTypeNotString: 'Expected type but received a string literal',
        expectedTypeParameterName: 'Expected type parameter name',
        expectedYieldExpr: {
          message: 'Expected expression in yield statement',
          comment: '{Locked=\'yield\'}'
        },
        finalClassIsAbstract: {
          message: 'Class "{type}" is marked final and must implement all abstract symbols',
          comment: '{Locked=\'final\'}'
        },
        finalContext: {
          message: '"Final" is not allowed in this context',
          comment: '{Locked=\'Final\'}'
        },
        finalInLoop: {
          message: 'A "Final" variable cannot be assigned within a loop',
          comment: '{Locked=\'Final\'}'
        },
        finalMethodOverride: {
          message: 'Method "{name}" cannot override final method defined in class "{className}"',
          comment: '{Locked=\'final\'}'
        },
        finalNonMethod: {
          message: 'Function "{name}" cannot be marked @final because it is not a method',
          comment: '{Locked=\'@final\'}'
        },
        finalReassigned: {
          message: '"{name}" is declared as Final and cannot be reassigned',
          comment: '{Locked=\'Final\'}'
        },
        finalRedeclaration: {
          message: '"{name}" was previously declared as Final',
          comment: '{Locked=\'Final\'}'
        },
        finalRedeclarationBySubclass: {
          message: '"{name}" cannot be redeclared because parent class "{className}" declares it as Final',
          comment: '{Locked=\'Final\'}'
        },
        finalTooManyArgs: {
          message: 'Expected a single type argument after "Final"',
          comment: '{Locked=\'Final\'}'
        },
        finalUnassigned: {
          message: '"{name}" is declared Final, but value is not assigned',
          comment: '{Locked=\'Final\'}'
        },
        formatStringBrace: {
          message: 'Single close brace not allowed within f-string literal; use double close brace',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringBytes: {
          message: 'Format string literals (f-strings) cannot be binary',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringDebuggingIllegal: {
          message: 'F-string debugging specifier "=" requires Python 3.8 or newer',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringEscape: {
          message: 'Escape sequence (backslash) not allowed in expression portion of f-string prior to Python 3.12',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringExpectedConversion: {
          message: 'Expected a conversion specifier after "!" in f-string',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringIllegal: {
          message: 'Format string literals (f-strings) require Python 3.6 or newer',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringInPattern: 'Format string not allowed in pattern',
        formatStringNestedFormatSpecifier: 'Expressions nested too deeply within format string specifier',
        formatStringNestedQuote: {
          message: 'Strings nested within an f-string cannot use the same quote character as the f-string prior to Python 3.12',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringUnicode: {
          message: 'Format string literals (f-strings) cannot be unicode',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        formatStringUnterminated: {
          message: 'Unterminated expression in f-string; expecting "}"',
          comment: '\'f-string\' is the common English slang for a Python format string'
        },
        functionDecoratorTypeUnknown: 'Untyped function decorator obscures type of function; ignoring decorator',
        functionInConditionalExpression: {
          message: 'Conditional expression references function which always evaluates to True',
          comment: '{Locked=\'True\'}'
        },
        functionTypeParametersIllegal: 'Function type parameter syntax requires Python 3.12 or newer',
        futureImportLocationNotAllowed: {
          message: 'Imports from __future__ must be at the beginning of the file',
          comment: '{Locked=\'__future__\'}'
        },
        generatorAsyncReturnType: {
          message: 'Return type of async generator function must be compatible with "AsyncGenerator[{yieldType}, Any]"',
          comment: '{Locked=\'async\',\'AsyncGenerator[{yieldType}, Any]\'}'
        },
        generatorNotParenthesized: 'Generator expressions must be parenthesized if not sole argument',
        generatorSyncReturnType: {
          message: 'Return type of generator function must be compatible with "Generator[{yieldType}, Any, Any]"',
          comment: '{Locked=\'Generator[{yieldType}, Any, Any]\'}'
        },
        genericBaseClassNotAllowed: {
          message: '"Generic" base class cannot be used with type parameter syntax',
          comment: '{Locked=\'Generic\'}'
        },
        genericClassAssigned: {
          message: 'Generic class type cannot be assigned',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        genericClassDeleted: {
          message: 'Generic class type cannot be deleted',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        genericInstanceVariableAccess: {
          message: 'Access to generic instance variable through class is ambiguous',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        genericNotAllowed: {
          message: '"Generic" is not valid in this context',
          comment: '{Locked=\'Generic\'}'
        },
        genericTypeAliasBoundTypeVar: {
          message: 'Generic type alias within class cannot use bound type variables {names}',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        genericTypeArgMissing: {
          message: '"Generic" requires at least one type argument',
          comment: '{Locked=\'Generic\'}'
        },
        genericTypeArgTypeVar: {
          message: 'Type argument for "Generic" must be a type variable',
          comment: '{Locked=\'Generic\'}'
        },
        genericTypeArgUnique: {
          message: 'Type arguments for "Generic" must be unique',
          comment: '{Locked=\'Generic\'}'
        },
        globalReassignment: {
          message: '"{name}" is assigned before global declaration',
          comment: '{Locked=\'global\'}'
        },
        globalRedefinition: {
          message: '"{name}" was already declared global',
          comment: '{Locked=\'global\'}'
        },
        implicitStringConcat: 'Implicit string concatenation not allowed',
        importCycleDetected: 'Cycle detected in import chain',
        importDepthExceeded: 'Import chain depth exceeded {depth}',
        importResolveFailure: 'Import "{importName}" could not be resolved',
        importSourceResolveFailure: 'Import "{importName}" could not be resolved from source',
        importSymbolUnknown: '"{name}" is unknown import symbol',
        incompatibleMethodOverride: 'Method "{name}" overrides class "{className}" in an incompatible manner',
        inconsistentIndent: 'Unindent amount does not match previous indent',
        inconsistentTabs: 'Inconsistent use of tabs and spaces in indentation',
        initMethodSelfParamTypeVar: {
          message: 'Type annotation for "self" parameter of "__init__" method cannot contain class-scoped type variables',
          comment: '{Locked=\'self\',\'__init__\'}'
        },
        initMustReturnNone: {
          message: 'Return type of "__init__" must be None',
          comment: '{Locked=\'__init__\',\'None\'}'
        },
        initSubclassCallFailed: {
          message: 'Incorrect keyword arguments for __init_subclass__ method',
          comment: '{Locked=\'__init_subclass__\'}'
        },
        initSubclassClsParam: {
          message: '__init_subclass__ override should take a "cls" parameter',
          comment: '{Locked=\'__init_subclass__\',\'cls\'}'
        },
        initVarNotAllowed: {
          message: '"InitVar" is not allowed in this context',
          comment: '{Locked=\'InitVar\'}'
        },
        instanceMethodSelfParam: {
          message: 'Instance methods should take a "self" parameter',
          comment: '{Locked=\'self\'}'
        },
        instanceVarOverridesClassVar: 'Instance variable "{name}" overrides class variable of same name in class "{className}"',
        instantiateAbstract: 'Cannot instantiate abstract class "{type}"',
        instantiateProtocol: {
          message: 'Cannot instantiate Protocol class "{type}"',
          comment: '{Locked=\'Protocol\'}'
        },
        internalBindError: {
          message: 'An internal error occurred while binding file "{file}": {message}',
          comment: 'Binding is the process through which Pyright determines what object a name refers to'
        },
        internalParseError: 'An internal error occurred while parsing file "{file}": {message}',
        internalTypeCheckingError: 'An internal error occurred while type checking file "{file}": {message}',
        invalidIdentifierChar: 'Invalid character in identifier',
        invalidStubStatement: {
          message: 'Statement is meaningless within a type stub file',
          comment: '{StrContains=i\'stub\'}'
        },
        invalidTokenChars: 'Invalid character "{text}" in token',
        isInstanceInvalidType: {
          message: 'Second argument to "isinstance" must be a class or tuple of classes',
          comment: '{Locked=\'isinstance\',\'tuple\'}'
        },
        isSubclassInvalidType: {
          message: 'Second argument to "issubclass" must be a class or tuple of classes',
          comment: '{Locked=\'issubclass\',\'tuple\'}'
        },
        keyValueInSet: {
          message: 'Key/value pairs are not allowed within a set',
          comment: '{Locked=\'set\'}'
        },
        keywordArgInTypeArgument: 'Keyword arguments cannot be used in type argument lists',
        keywordArgShortcutIllegal: 'Keyword argument shortcut requires Python 3.14 or newer',
        keywordOnlyAfterArgs: 'Keyword-only argument separator not allowed after "*" parameter',
        keywordParameterMissing: 'One or more keyword parameters must follow "*" parameter',
        keywordSubscriptIllegal: 'Keyword arguments within subscripts are not supported',
        lambdaReturnTypePartiallyUnknown: 'Return type of lambda, "{returnType}", is partially unknown',
        lambdaReturnTypeUnknown: 'Return type of lambda is unknown',
        listAssignmentMismatch: 'Expression with type "{type}" cannot be assigned to target list',
        listInAnnotation: {
          message: 'List expression not allowed in type expression',
          comment: '{Locked=\'List\'}'
        },
        literalEmptyArgs: {
          message: 'Expected one or more type arguments after "Literal"',
          comment: '{Locked=\'Literal\'}'
        },
        literalNamedUnicodeEscape: {
          message: 'Named unicode escape sequences are not supported in "Literal" string annotations',
          comment: '{Locked=\'Literal\'}'
        },
        literalNotAllowed: {
          message: '"Literal" cannot be used in this context without a type argument',
          comment: '{Locked=\'Literal\'}'
        },
        literalNotCallable: {
          message: 'Literal type cannot be instantiated',
          comment: '{Locked=\'Literal\'}'
        },
        literalUnsupportedType: {
          message: 'Type arguments for "Literal" must be None, a literal value (int, bool, str, or bytes), or an enum value',
          comment: '{Locked=\'Literal\',\'None\',\'int\',\'bool\',\'str\',\'bytes\',\'enum\'}'
        },
        matchIncompatible: {
          message: 'Match statements require Python 3.10 or newer',
          comment: ['{StrContains=i\'match\'}', '\'match\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        matchIsNotExhaustive: {
          message: 'Cases within match statement do not exhaustively handle all values',
          comment: ['{Locked=\'match\'}', 'Case statements are children of match statements where \'case\' is a keyword. It may be best to keep \'case\' in English']
        },
        maxParseDepthExceeded: 'Maximum parse depth exceeded; break expression into smaller sub-expressions',
        memberAccess: 'Cannot access attribute "{name}" for class "{type}"',
        memberDelete: 'Cannot delete attribute "{name}" for class "{type}"',
        memberSet: 'Cannot assign to attribute "{name}" for class "{type}"',
        metaclassConflict: {
          message: 'The metaclass of a derived class must be a subclass of the metaclasses of all its base classes',
          comment: 'Metaclasses are a complex concept and it may be best to not localize the term'
        },
        metaclassDuplicate: {
          message: 'Only one metaclass can be provided',
          comment: 'Metaclasses are a complex concept and it may be best to not localize the term'
        },
        metaclassIsGeneric: {
          message: 'Metaclass cannot be generic',
          comment: ['Metaclasses are a complex concept and it may be best to not localize the term', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        methodNotDefined: '"{name}" method not defined',
        methodNotDefinedOnType: '"{name}" method not defined on type "{type}"',
        methodOrdering: 'Cannot create consistent method ordering',
        methodOverridden: '"{name}" overrides method of same name in class "{className}" with incompatible type "{type}"',
        methodReturnsNonObject: '"{name}" method does not return an object',
        missingSuperCall: 'Method "{methodName}" does not call the method of the same name in parent class',
        mixingBytesAndStr: {
          message: 'Bytes and str values cannot be concatenated',
          comment: ['{Locked=\'str\'}', '{StrContains=i\'bytes\'}', '\'bytes\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        moduleAsType: 'Module cannot be used as a type',
        moduleNotCallable: 'Module is not callable',
        moduleUnknownMember: '"{memberName}" is not a known attribute of module "{moduleName}"',
        namedExceptAfterCatchAll: {
          message: 'A named except clause cannot appear after catch-all except clause',
          comment: '{Locked=\'except\'}'
        },
        namedParamAfterParamSpecArgs: {
          message: 'Keyword parameter "{name}" cannot appear in signature after ParamSpec args parameter',
          comment: '{Locked=\'ParamSpec\',\'args\'}'
        },
        namedTupleEmptyName: {
          message: 'Names within a named tuple cannot be empty',
          comment: '{Locked=\'tuple\'}'
        },
        namedTupleEntryRedeclared: {
          message: 'Cannot override "{name}" because parent class "{className}" is a named tuple',
          comment: '{Locked=\'tuple\'}'
        },
        namedTupleFirstArg: {
          message: 'Expected named tuple class name as first argument',
          comment: '{Locked=\'tuple\'}'
        },
        namedTupleMultipleInheritance: {
          message: 'Multiple inheritance with NamedTuple is not supported',
          comment: '{Locked=\'NamedTuple\'}'
        },
        namedTupleNameKeyword: 'Field names cannot be a keyword',
        namedTupleNameType: {
          message: 'Expected two-entry tuple specifying entry name and type',
          comment: '{Locked=\'tuple\'}'
        },
        namedTupleNameUnique: {
          message: 'Names within a named tuple must be unique',
          comment: '{Locked=\'tuple\'}'
        },
        namedTupleNoTypes: {
          message: '"namedtuple" provides no types for tuple entries; use "NamedTuple" instead',
          comment: '{Locked=\'namedtuple";\'tuple\',\'NamedTuple\'}'
        },
        namedTupleSecondArg: {
          message: 'Expected named tuple entry list as second argument',
          comment: '{Locked=\'tuple\',\'list\'}'
        },
        newClsParam: {
          message: '__new__ override should take a "cls" parameter',
          comment: '{Locked=\'__new__\',\'cls\'}'
        },
        newTypeAnyOrUnknown: {
          message: 'The second argument to NewType must be a known class, not Any or Unknown',
          comment: '{Locked=\'NewType\',\'Any\',\'Unknown\'}'
        },
        newTypeBadName: {
          message: 'The first argument to NewType must be a string literal',
          comment: '{Locked=\'NewType\'}'
        },
        newTypeLiteral: {
          message: 'NewType cannot be used with Literal type',
          comment: '{Locked=\'NewType\',\'Literal\'}'
        },
        newTypeNameMismatch: {
          message: 'NewType must be assigned to a variable with the same name',
          comment: '{Locked=\'NewType\'}'
        },
        newTypeNotAClass: {
          message: 'Expected class as second argument to NewType',
          comment: '{Locked=\'NewType\'}'
        },
        newTypeParamCount: {
          message: 'NewType requires two positional arguments',
          comment: '{Locked=\'NewType\'}'
        },
        newTypeProtocolClass: {
          message: 'NewType cannot be used with structural type (a Protocol or TypedDict class)',
          comment: '{Locked=\'NewType\',\'Protocol\',\'TypedDict\'}'
        },
        noOverload: 'No overloads for "{name}" match the provided arguments',
        noReturnContainsReturn: {
          message: 'Function with declared return type "NoReturn" cannot include a return statement',
          comment: '{Locked=\'NoReturn\',\'return\'}'
        },
        noReturnContainsYield: {
          message: 'Function with declared return type "NoReturn" cannot include a yield statement',
          comment: '{Locked=\'NoReturn\',\'yield\'}'
        },
        noReturnReturnsNone: {
          message: 'Function with declared return type "NoReturn" cannot return "None"',
          comment: '{Locked=\'NoReturn\',\'None\'}'
        },
        nonDefaultAfterDefault: 'Non-default argument follows default argument',
        nonLocalInModule: {
          message: 'Nonlocal declaration not allowed at module level',
          comment: ['{StrContains=i\'nonlocal\'}', '\'nonlocal\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        nonLocalNoBinding: {
          message: 'No binding for nonlocal "{name}" found',
          comment: ['{Locked=\'nonlocal\'}', '\'No binding found\' means that Pyright couldn\'t resolve the variable name to an object']
        },
        nonLocalReassignment: {
          message: '"{name}" is assigned before nonlocal declaration',
          comment: '{Locked=\'nonlocal\'}'
        },
        nonLocalRedefinition: {
          message: '"{name}" was already declared nonlocal',
          comment: '{Locked=\'nonlocal\'}'
        },
        noneNotCallable: {
          message: 'Object of type "None" cannot be called',
          comment: '{Locked=\'None\'}'
        },
        noneNotIterable: {
          message: 'Object of type "None" cannot be used as iterable value',
          comment: '{Locked=\'None\'}'
        },
        noneNotSubscriptable: {
          message: 'Object of type "None" is not subscriptable',
          comment: '{Locked=\'None\'}'
        },
        noneNotUsableWith: {
          message: 'Object of type "None" cannot be used with "with"',
          comment: '{Locked=\'None\',\'with\'}'
        },
        noneOperator: {
          message: 'Operator "{operator}" not supported for "None"',
          comment: '{Locked=\'None\'}'
        },
        noneUnknownMember: {
          message: '"{name}" is not a known attribute of "None"',
          comment: '{Locked=\'None\'}'
        },
        notRequiredArgCount: {
          message: 'Expected a single type argument after "NotRequired"',
          comment: '{Locked=\'NotRequired\'}'
        },
        notRequiredNotInTypedDict: {
          message: '"NotRequired" is not allowed in this context',
          comment: '{Locked=\'NotRequired\'}'
        },
        objectNotCallable: 'Object of type "{type}" is not callable',
        obscuredClassDeclaration: 'Class declaration "{name}" is obscured by a declaration of the same name',
        obscuredFunctionDeclaration: 'Function declaration "{name}" is obscured by a declaration of the same name',
        obscuredMethodDeclaration: 'Method declaration "{name}" is obscured by a declaration of the same name',
        obscuredParameterDeclaration: 'Parameter declaration "{name}" is obscured by a declaration of the same name',
        obscuredTypeAliasDeclaration: 'Type alias declaration "{name}" is obscured by a declaration of the same name',
        obscuredVariableDeclaration: 'Declaration "{name}" is obscured by a declaration of the same name',
        operatorLessOrGreaterDeprecated: 'Operator "<>" is not supported in Python 3; use "!=" instead',
        optionalExtraArgs: {
          message: 'Expected one type argument after "Optional"',
          comment: '{Locked=\'Optional\'}'
        },
        orPatternIrrefutable: {
          message: 'Irrefutable pattern allowed only as the last subpattern in an "or" pattern',
          comment: '{Locked=\'or\'}'
        },
        orPatternMissingName: {
          message: 'All subpatterns within an "or" pattern must target the same names',
          comment: '{Locked=\'or\'}'
        },
        overlappingKeywordArgs: 'Typed dictionary overlaps with keyword parameter: {names}',
        overlappingOverload: 'Overload {obscured} for "{name}" will never be used because its parameters overlap overload {obscuredBy}',
        overloadAbstractImplMismatch: 'Overloads must match abstract status of implementation',
        overloadAbstractMismatch: 'Overloads must all be abstract or not',
        overloadClassMethodInconsistent: {
          message: 'Overloads for "{name}" use @classmethod inconsistently',
          comment: '{Locked=\'@classmethod\'}'
        },
        overloadFinalInconsistencyImpl: {
          message: 'Overload for "{name}" is marked @final but implementation is not',
          comment: '{Locked=\'@final\'}'
        },
        overloadFinalInconsistencyNoImpl: {
          message: 'Overload {index} for "{name}" is marked @final but overload 1 is not',
          comment: '{Locked=\'@final\'}'
        },
        overloadImplementationMismatch: 'Overloaded implementation is not consistent with signature of overload {index}',
        overloadReturnTypeMismatch: 'Overload {prevIndex} for "{name}" overlaps overload {newIndex} and returns an incompatible type',
        overloadStaticMethodInconsistent: {
          message: 'Overloads for "{name}" use @staticmethod inconsistently',
          comment: '{Locked=\'@staticmethod\'}'
        },
        overloadWithoutImplementation: {
          message: '"{name}" is marked as overload, but no implementation is provided',
          comment: '{Locked=\'overload\'}'
        },
        overriddenMethodNotFound: {
          message: 'Method "{name}" is marked as override, but no base method of same name is present',
          comment: '{Locked=\'override\'}'
        },
        overrideDecoratorMissing: {
          message: 'Method "{name}" is not marked as override but is overriding a method in class "{className}"',
          comment: '{Locked=\'override\'}'
        },
        paramAfterKwargsParam: 'Parameter cannot follow "**" parameter',
        paramAlreadyAssigned: 'Parameter "{name}" is already assigned',
        paramAnnotationMissing: 'Type annotation is missing for parameter "{name}"',
        paramAssignmentMismatch: 'Expression of type "{sourceType}" cannot be assigned to parameter of type "{paramType}"',
        paramNameMissing: 'No parameter named "{name}"',
        paramSpecArgsKwargsDuplicate: {
          message: 'Arguments for ParamSpec "{type}" have already been provided',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecArgsKwargsUsage: {
          message: '"args" and "kwargs" attributes of ParamSpec must both appear within a function signature',
          comment: '{Locked=\'args\',\'kwargs\',\'ParamSpec\'}'
        },
        paramSpecArgsMissing: {
          message: 'Arguments for ParamSpec "{type}" are missing',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecArgsUsage: {
          message: '"args" attribute of ParamSpec is valid only when used with *args parameter',
          comment: '{Locked=\'args\',\'ParamSpec\',\'*args\'}'
        },
        paramSpecAssignedName: {
          message: 'ParamSpec must be assigned to a variable named "{name}"',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecContext: {
          message: 'ParamSpec is not allowed in this context',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecDefaultNotTuple: {
          message: 'Expected ellipsis, a tuple expression, or ParamSpec for default value of ParamSpec',
          comment: '{Locked=\'tuple\',\'ParamSpec\'}'
        },
        paramSpecFirstArg: {
          message: 'Expected name of ParamSpec as first argument',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecKwargsUsage: {
          message: '"kwargs" attribute of ParamSpec is valid only when used with **kwargs parameter',
          comment: '{Locked=\'kwargs\',\'ParamSpec\',\'**kwargs\'}'
        },
        paramSpecNotUsedByOuterScope: {
          message: 'ParamSpec "{name}" has no meaning in this context',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecUnknownArg: {
          message: 'ParamSpec does not support more than one argument',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecUnknownMember: {
          message: '"{name}" is not a known attribute of ParamSpec',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramSpecUnknownParam: {
          message: '"{name}" is unknown parameter to ParamSpec',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramTypeCovariant: 'Covariant type variable cannot be used in parameter type',
        paramTypePartiallyUnknown: 'Type of parameter "{paramName}" is partially unknown',
        paramTypeUnknown: 'Type of parameter "{paramName}" is unknown',
        parenthesizedContextManagerIllegal: {
          message: 'Parentheses within "with" statement requires Python 3.9 or newer',
          comment: '{Locked=\'with\'}'
        },
        patternNeverMatches: 'Pattern will never be matched for subject type "{type}"',
        positionArgAfterNamedArg: 'Positional argument cannot appear after keyword arguments',
        positionOnlyAfterArgs: 'Position-only parameter separator not allowed after "*" parameter',
        positionOnlyAfterKeywordOnly: '"/" parameter must appear before "*" parameter',
        positionOnlyAfterNon: 'Position-only parameter not allowed after parameter that is not position-only',
        positionOnlyFirstParam: 'Position-only parameter separator not allowed as first parameter',
        positionOnlyIncompatible: 'Position-only parameter separator requires Python 3.8 or newer',
        privateImportFromPyTypedModule: '"{name}" is not exported from module "{module}"',
        privateUsedOutsideOfClass: '"{name}" is private and used outside of the class in which it is declared',
        privateUsedOutsideOfModule: '"{name}" is private and used outside of the module in which it is declared',
        propertyOverridden: {
          message: '"{name}" incorrectly overrides property of same name in class "{className}"',
          comment: '{Locked=\'property\'}'
        },
        propertyStaticMethod: {
          message: 'Static methods not allowed for property getter, setter or deleter',
          comment: '{Locked=\'property\',\'getter\',\'setter\',\'deleter\'}'
        },
        protectedUsedOutsideOfClass: '"{name}" is protected and used outside of the class in which it is declared',
        protocolBaseClass: {
          message: 'Protocol class "{classType}" cannot derive from non-Protocol class "{baseType}"',
          comment: '{Locked=\'Protocol\'}'
        },
        protocolBaseClassWithTypeArgs: {
          message: 'Type arguments are not allowed with Protocol class when using type parameter syntax',
          comment: '{Locked=\'Protocol\'}'
        },
        protocolIllegal: {
          message: 'Use of "Protocol" requires Python 3.7 or newer',
          comment: '{Locked=\'Protocol\'}'
        },
        protocolNotAllowed: {
          message: '"Protocol" cannot be used in this context',
          comment: '{Locked=\'Protocol\'}'
        },
        protocolTypeArgMustBeTypeParam: {
          message: 'Type argument for "Protocol" must be a type parameter',
          comment: '{Locked=\'Protocol\'}'
        },
        protocolUnsafeOverlap: 'Class overlaps "{name}" unsafely and could produce a match at runtime',
        protocolVarianceContravariant: {
          message: 'Type variable "{variable}" used in generic Protocol "{class}" should be contravariant',
          comment: ['{Locked=\'Protocol\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        protocolVarianceCovariant: {
          message: 'Type variable "{variable}" used in generic Protocol "{class}" should be covariant',
          comment: ['{Locked=\'Protocol\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        protocolVarianceInvariant: {
          message: 'Type variable "{variable}" used in generic Protocol "{class}" should be invariant',
          comment: ['{Locked=\'Protocol\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        pyrightCommentInvalidDiagnosticBoolValue: {
          message: 'Pyright comment directive must be followed by "=" and a value of true or false',
          comment: '{Locked=\'Pyright\',\'true\',\'false\'}'
        },
        pyrightCommentInvalidDiagnosticSeverityValue: {
          message: 'Pyright comment directive must be followed by "=" and a value of true, false, error, warning, information, or none',
          comment: '{Locked=\'Pyright\',\'true\',\'false\',\'error\',\'warning\',\'information\',\'none\'}'
        },
        pyrightCommentMissingDirective: {
          message: 'Pyright comment must be followed by a directive (basic or strict) or a diagnostic rule',
          comment: '{Locked=\'Pyright\',\'basic\',\'strict\'}'
        },
        pyrightCommentNotOnOwnLine: {
          message: 'Pyright comments used to control file-level settings must appear on their own line',
          comment: '{Locked=\'Pyright\'}'
        },
        pyrightCommentUnknownDiagnosticRule: {
          message: '"{rule}" is an unknown diagnostic rule for pyright comment',
          comment: '{Locked=\'pyright\'}'
        },
        pyrightCommentUnknownDiagnosticSeverityValue: {
          message: '"{value}" is invalid value for pyright comment; expected true, false, error, warning, information, or none',
          comment: '{Locked=\'pyright\',\'true\',\'false\',\'error\',\'warning\',\'information\',\'none\'}'
        },
        pyrightCommentUnknownDirective: {
          message: '"{directive}" is an unknown directive for pyright comment; expected "strict" or "basic"',
          comment: '{Locked=\'pyright\',\'strict\',\'basic\'}'
        },
        readOnlyArgCount: {
          message: 'Expected a single type argument after "ReadOnly"',
          comment: '{Locked=\'ReadOnly\'}'
        },
        readOnlyNotInTypedDict: {
          message: '"ReadOnly" is not allowed in this context',
          comment: '{Locked=\'ReadOnly\'}'
        },
        recursiveDefinition: 'Type of "{name}" could not be determined because it refers to itself',
        relativeImportNotAllowed: {
          message: 'Relative imports cannot be used with "import .a" form; use "from . import a" instead',
          comment: '{Locked=\'import .a\',\'from . import a\'}'
        },
        requiredArgCount: {
          message: 'Expected a single type argument after "Required"',
          comment: '{Locked=\'Required\'}'
        },
        requiredNotInTypedDict: {
          message: '"Required" is not allowed in this context',
          comment: '{Locked=\'Required\'}'
        },
        returnInAsyncGenerator: {
          message: 'Return statement with value is not allowed in async generator',
          comment: '{Locked=\'async\'}'
        },
        returnMissing: 'Function with declared return type "{returnType}" must return value on all code paths',
        returnInExceptionGroup: {
          message: '"return" is not allowed in an "except*" block',
          comment: '{Locked=\'return\',\'except*\'}'
        },
        returnOutsideFunction: {
          message: '"return" can be used only within a function',
          comment: '{Locked=\'return\'}'
        },
        returnTypeContravariant: 'Contravariant type variable cannot be used in return type',
        returnTypeMismatch: 'Type "{exprType}" is not assignable to return type "{returnType}"',
        returnTypePartiallyUnknown: 'Return type, "{returnType}", is partially unknown',
        returnTypeUnknown: 'Return type is unknown',
        revealLocalsArgs: {
          message: 'Expected no arguments for "reveal_locals" call',
          comment: '{Locked=\'reveal_locals\'}'
        },
        revealLocalsNone: {
          message: 'No locals in this scope',
          comment: '{Locked=\'locals\'}'
        },
        revealTypeArgs: {
          message: 'Expected a single positional argument for "reveal_type" call',
          comment: '{Locked=\'reveal_type\'}'
        },
        revealTypeExpectedTextArg: {
          message: 'The "expected_text" argument for function "reveal_type" must be a str literal value',
          comment: '{Locked=\'expected_text\',\'reveal_type\',\'str\'}'
        },
        revealTypeExpectedTextMismatch: 'Type text mismatch; expected "{expected}" but received "{received}"',
        revealTypeExpectedTypeMismatch: 'Type mismatch; expected "{expected}" but received "{received}"',
        selfTypeContext: {
          message: '"Self" is not valid in this context',
          comment: '{Locked=\'Self\'}'
        },
        selfTypeMetaclass: {
          message: '"Self" cannot be used within a metaclass (a subclass of "type")',
          comment: ['{Locked=\'Self\'}', 'Metaclasses are a complex concept and it may be best to not localize the term']
        },
        selfTypeWithTypedSelfOrCls: {
          message: '"Self" cannot be used in a function with a `self` or `cls` parameter that has a type annotation other than "Self"',
          comment: '{Locked=\'Self\',\'self\',\'cls\'}'
        },
        setterGetterTypeMismatch: {
          message: 'Property setter value type is not assignable to the getter return type',
          comment: ['{Locked=\'setter\',\'getter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        singleOverload: '"{name}" is marked as overload, but additional overloads are missing',
        slotsAttributeError: {
          message: '"{name}" is not specified in __slots__',
          comment: '{Locked=\'__slots__\'}'
        },
        slotsClassVarConflict: {
          message: '"{name}" conflicts with instance variable declared in __slots__',
          comment: '{Locked=\'__slots__\'}'
        },
        starPatternInAsPattern: {
          message: 'Star pattern cannot be used with "as" target',
          comment: ['{Locked=\'as\'}', 'Star pattern refers to the use of the * (star) character to represent a variable length pattern match']
        },
        starPatternInOrPattern: {
          message: 'Star pattern cannot be ORed within other patterns',
          comment: ['Star pattern refers to the use of the * (star) character to represent a variable length pattern match', '\'ORed\' means joined together with a binary \'or\' operation']
        },
        starStarWildcardNotAllowed: '** cannot be used with wildcard "_"',
        staticClsSelfParam: {
          message: 'Static methods should not take a "self" or "cls" parameter',
          comment: '{Locked=\'self\',\'cls\'}'
        },
        stdlibModuleOverridden: {
          message: '"{path}" is overriding the stdlib module "{name}"',
          comment: '{Locked=\'stdlib\'}'
        },
        stringNonAsciiBytes: {
          message: 'Non-ASCII character not allowed in bytes string literal',
          comment: '{Locked=\'ASCII\'}'
        },
        stringNotSubscriptable: 'String expression cannot be subscripted in type expression; enclose entire expression in quotes',
        stringUnsupportedEscape: 'Unsupported escape sequence in string literal',
        stringUnterminated: 'String literal is unterminated',
        stubFileMissing: {
          message: 'Stub file not found for "{importName}"',
          comment: '{StrContains=i\'stub\'}'
        },
        stubUsesGetAttr: {
          message: 'Type stub file is incomplete; "__getattr__" obscures type errors for module',
          comment: ['{Locked=\'__getattr__\'}', '{StrContains=i\'stub\'}']
        },
        sublistParamsIncompatible: {
          message: 'Sublist parameters are not supported in Python 3.x',
          comment: '{StrContains=i\'sublist\'}'
        },
        superCallArgCount: {
          message: 'Expected no more than two arguments to "super" call',
          comment: '{Locked=\'super\'}'
        },
        superCallFirstArg: {
          message: 'Expected class type as first argument to "super" call but received "{type}"',
          comment: '{Locked=\'super\'}'
        },
        superCallSecondArg: {
          message: 'Second argument to "super" call must be object or class that derives from "{type}"',
          comment: '{Locked=\'super\'}'
        },
        superCallZeroArgForm: {
          message: 'Zero-argument form of "super" call is valid only within a method',
          comment: '{Locked=\'super\'}'
        },
        superCallZeroArgFormStaticMethod: {
          message: 'Zero-argument form of "super" call is not valid within a static method',
          comment: '{Locked=\'super\'}'
        },
        symbolIsPossiblyUnbound: '"{name}" is possibly unbound',
        symbolIsUnbound: '"{name}" is unbound',
        symbolIsUndefined: '"{name}" is not defined',
        symbolOverridden: '"{name}" overrides symbol of same name in class "{className}"',
        ternaryNotAllowed: 'Ternary expression not allowed in type expression',
        totalOrderingMissingMethod: {
          message: 'Class must define one of "__lt__", "__le__", "__gt__", or "__ge__" to use total_ordering',
          comment: '{Locked=\'__lt__\',\'__le__\',\'__gt__\',\'__ge__\',\'total_ordering\'}'
        },
        trailingCommaInFromImport: 'Trailing comma not allowed without surrounding parentheses',
        tryWithoutExcept: {
          message: 'Try statement must have at least one except or finally clause',
          comment: ['{Locked=\'except\',\'finally\'}', '{StrContains=i\'try\'}', '\'try\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleAssignmentMismatch: {
          message: 'Expression with type "{type}" cannot be assigned to target tuple',
          comment: '{Locked=\'tuple\'}'
        },
        tupleInAnnotation: {
          message: 'Tuple expression not allowed in type expression',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleIndexOutOfRange: 'Index {index} is out of range for type {type}',
        typeAliasIllegalExpressionForm: 'Invalid expression form for type alias definition',
        typeAliasIsRecursiveDirect: 'Type alias "{name}" cannot use itself in its definition',
        typeAliasNotInModuleOrClass: {
          message: 'A TypeAlias can be defined only within a module or class scope',
          comment: '{Locked=\'TypeAlias\'}'
        },
        typeAliasRedeclared: {
          message: '"{name}" is declared as a TypeAlias and can be assigned only once',
          comment: '{Locked=\'TypeAlias\'}'
        },
        typeAliasStatementBadScope: {
          message: 'A type statement can be used only within a module or class scope',
          comment: '{Locked=\'type\'}'
        },
        typeAliasStatementIllegal: 'Type alias statement requires Python 3.12 or newer',
        typeAliasTypeBaseClass: {
          message: 'A type alias defined in a "type" statement cannot be used as a base class',
          comment: '{Locked=\'"type"\'}'
        },
        typeAliasTypeMustBeAssigned: {
          message: 'TypeAliasType must be assigned to a variable with the same name as the type alias',
          comment: '{Locked=\'TypeAliasType\'}'
        },
        typeAliasTypeNameArg: {
          message: 'First argument to TypeAliasType must be a string literal representing the name of the type alias',
          comment: '{Locked=\'TypeAliasType\'}'
        },
        typeAliasTypeNameMismatch: 'Name of type alias must match the name of the variable to which it is assigned',
        typeAliasTypeParamInvalid: {
          message: 'Type parameter list must be a tuple containing only TypeVar, TypeVarTuple, or ParamSpec',
          comment: '{Locked=\'tuple\',\'TypeVar\',\'TypeVarTuple\',\'ParamSpec\'}'
        },
        typeAnnotationCall: 'Call expression not allowed in type expression',
        typeAnnotationVariable: 'Variable not allowed in type expression',
        typeAnnotationWithCallable: {
          message: 'Type argument for "type" must be a class; callables are not supported',
          comment: ['{Locked=\'type\'}', '\'callables\' are objects that can be called like a function']
        },
        typeArgListExpected: {
          message: 'Expected ParamSpec, ellipsis, or list of types',
          comment: '{Locked=\'ParamSpec\',\'list\'}'
        },
        typeArgListNotAllowed: {
          message: 'List expression not allowed for this type argument',
          comment: ['{StrContains=i\'list\'}', '\'list\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        typeArgsExpectingNone: 'Expected no type arguments for class "{name}"',
        typeArgsMismatchOne: 'Expected one type argument but received {received}',
        typeArgsMissingForAlias: {
          message: 'Expected type arguments for generic type alias "{name}"',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        typeArgsMissingForClass: {
          message: 'Expected type arguments for generic class "{name}"',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        typeArgsTooFew: 'Too few type arguments provided for "{name}"; expected {expected} but received {received}',
        typeArgsTooMany: 'Too many type arguments provided for "{name}"; expected {expected} but received {received}',
        typeAssignmentMismatch: 'Type "{sourceType}" is not assignable to declared type "{destType}"',
        typeAssignmentMismatchWildcard: 'Import symbol "{name}" has type "{sourceType}", which is not assignable to declared type "{destType}"',
        typeCallNotAllowed: {
          message: 'type() call should not be used in type expression',
          comment: '{Locked=\'type()\'}'
        },
        typeCheckOnly: {
          message: '"{name}" is marked as @type_check_only and can be used only in type annotations',
          comment: '{Locked=\'@type_check_only\'}'
        },
        typeCommentDeprecated: {
          message: 'Use of type comments is deprecated; use type annotation instead',
          comment: '{Locked=\'type\'}'
        },
        typeExpectedClass: 'Expected class but received "{type}"',
        typeFormArgs: {
          message: '"TypeForm" accepts a single positional argument',
          comment: '{Locked=\'TypeForm\'}'
        },
        typeGuardArgCount: {
          message: 'Expected a single type argument after "TypeGuard" or "TypeIs"',
          comment: '{Locked=\'TypeGuard\',\'TypeIs\'}'
        },
        typeGuardParamCount: 'User-defined type guard functions and methods must have at least one input parameter',
        typeIsReturnType: {
          message: 'Return type of TypeIs ("{returnType}") is not consistent with value parameter type ("{type}")',
          comment: '{Locked=\'TypeIs\'}'
        },
        typeNotAwaitable: {
          message: '"{type}" is not awaitable',
          comment: '{Locked=\'awaitable\'}'
        },
        typeNotIntantiable: '"{type}" cannot be instantiated',
        typeNotIterable: '"{type}" is not iterable',
        typeNotSpecializable: 'Could not specialize type "{type}"',
        typeNotSubscriptable: 'Object of type "{type}" is not subscriptable',
        typeNotSupportBinaryOperator: 'Operator "{operator}" not supported for types "{leftType}" and "{rightType}"',
        typeNotSupportBinaryOperatorBidirectional: 'Operator "{operator}" not supported for types "{leftType}" and "{rightType}" when expected type is "{expectedType}"',
        typeNotSupportUnaryOperator: 'Operator "{operator}" not supported for type "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'Operator "{operator}" not supported for type "{type}" when expected type is "{expectedType}"',
        typeNotUsableWith: 'Object of type "{type}" cannot be used with "with" because it does not implement {method}',
        typeParameterBoundNotAllowed: {
          message: 'Bound or constraint cannot be used with a variadic type parameter or ParamSpec',
          comment: ['{Locked=\'ParamSpec\'}', '\'variadic\' means that it accepts a variable number of arguments']
        },
        typeParameterConstraintTuple: 'Type parameter constraint must be a tuple of two or more types',
        typeParameterExistingTypeParameter: 'Type parameter "{name}" is already in use',
        typeParameterNotDeclared: 'Type parameter "{name}" is not included in the type parameter list for "{container}"',
        typeParametersMissing: 'At least one type parameter must be specified',
        typePartiallyUnknown: 'Type of "{name}" is partially unknown',
        typeUnknown: 'Type of "{name}" is unknown',
        typeVarAssignedName: {
          message: 'TypeVar must be assigned to a variable named "{name}"',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarAssignmentMismatch: 'Type "{type}" cannot be assigned to type variable "{name}"',
        typeVarBoundAndConstrained: {
          message: 'TypeVar cannot be both bound and constrained',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarBoundGeneric: {
          message: 'TypeVar bound type cannot be generic',
          comment: ['{Locked=\'TypeVar\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        typeVarConstraintGeneric: {
          message: 'TypeVar constraint type cannot be generic',
          comment: ['{Locked=\'TypeVar\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        typeVarDefaultBoundMismatch: {
          message: 'TypeVar default type must be a subtype of the bound type',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarDefaultConstraintMismatch: {
          message: 'TypeVar default type must be one of the constrained types',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarDefaultIllegal: 'Type variable default types require Python 3.13 or newer',
        typeVarDefaultInvalidTypeVar: 'Type parameter "{name}" has a default type that refers to one or more type variables that are out of scope',
        typeVarFirstArg: {
          message: 'Expected name of TypeVar as first argument',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarInvalidForMemberVariable: 'Attribute type cannot use type variable "{name}" scoped to local method',
        typeVarNoMember: {
          message: 'TypeVar "{type}" has no attribute "{name}"',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarNotSubscriptable: {
          message: 'TypeVar "{type}" is not subscriptable',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarNotUsedByOuterScope: 'Type variable "{name}" has no meaning in this context',
        typeVarPossiblyUnsolvable: 'Type variable "{name}" may go unsolved if caller supplies no argument for parameter "{param}"',
        typeVarSingleConstraint: {
          message: 'TypeVar must have at least two constrained types',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarTupleConstraints: {
          message: 'TypeVarTuple cannot have value constraints',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        typeVarTupleContext: {
          message: 'TypeVarTuple is not allowed in this context',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        typeVarTupleDefaultNotUnpacked: {
          message: 'TypeVarTuple default type must be an unpacked tuple or TypeVarTuple',
          comment: '{Locked=\'TypeVarTuple\',\'tuple\'}'
        },
        typeVarTupleMustBeUnpacked: {
          message: 'Unpack operator is required for TypeVarTuple value',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        typeVarTupleUnknownParam: {
          message: '"{name}" is unknown parameter to TypeVarTuple',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        typeVarUnknownParam: {
          message: '"{name}" is unknown parameter to TypeVar',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarUsedByOuterScope: {
          message: 'TypeVar "{name}" is already in use by an outer scope',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarUsedOnlyOnce: {
          message: 'TypeVar "{name}" appears only once in generic function signature',
          comment: ['{Locked=\'TypeVar\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        typeVarVariance: {
          message: 'TypeVar cannot be both covariant and contravariant',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarWithDefaultFollowsVariadic: {
          message: 'TypeVar "{typeVarName}" has a default value and cannot follow TypeVarTuple "{variadicName}"',
          comment: '{Locked=\'TypeVar\',\'TypeVarTuple\'}'
        },
        typeVarWithoutDefault: '"{name}" cannot appear after "{other}" in type parameter list because it has no default type',
        typeVarsNotInGenericOrProtocol: {
          message: 'Generic[] or Protocol[] must include all type variables',
          comment: '{Locked=\'Generic[]\',\'Protocol[]\'}'
        },
        typedDictAccess: {
          message: 'Could not access item in TypedDict',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictAssignedName: {
          message: 'TypedDict must be assigned to a variable named "{name}"',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictBadVar: {
          message: 'TypedDict classes can contain only type annotations',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictBaseClass: {
          message: 'All base classes for TypedDict classes must also be TypedDict classes',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictBoolParam: {
          message: 'Expected "{name}" parameter to have a value of True or False',
          comment: '{Locked=\'True\',\'False\'}'
        },
        typedDictClosedExtras: {
          message: 'Base class "{name}" is a closed TypedDict; extra items must be type "{type}"',
          comment: '{Locked=\'closed\',\'TypedDict\'}'
        },
        typedDictClosedNoExtras: {
          message: 'Base class "{name}" is a closed TypedDict; extra items are not allowed',
          comment: '{Locked=\'closed\',\'TypedDict\'}'
        },
        typedDictDelete: {
          message: 'Could not delete item in TypedDict',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictEmptyName: {
          message: 'Names within a TypedDict cannot be empty',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictEntryName: 'Expected string literal for dictionary entry name',
        typedDictEntryUnique: 'Names within a dictionary must be unique',
        typedDictExtraArgs: {
          message: 'Extra TypedDict arguments not supported',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictExtraItemsClosed: {
          message: 'A TypedDict cannot be closed if it supports extra items',
          comment: '{Locked=\'TypedDict\',\'closed\'}'
        },
        typedDictFieldNotRequiredRedefinition: {
          message: 'TypedDict item "{name}" cannot be redefined as NotRequired',
          comment: '{Locked=\'TypedDict\',\'NotRequired\'}'
        },
        typedDictFieldReadOnlyRedefinition: {
          message: 'TypedDict item "{name}" cannot be redefined as ReadOnly',
          comment: '{Locked=\'TypedDict\',\'ReadOnly\'}'
        },
        typedDictFieldRequiredRedefinition: {
          message: 'TypedDict item "{name}" cannot be redefined as Required',
          comment: '{Locked=\'TypedDict\',\'Required\'}'
        },
        typedDictFirstArg: {
          message: 'Expected TypedDict class name as first argument',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictInClassPattern: {
          message: 'TypedDict class not allowed in class pattern',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictInitsubclassParameter: {
          message: 'TypedDict does not support __init_subclass__ parameter "{name}"',
          comment: '{Locked=\'TypedDict\',\'__init_subclass__\'}'
        },
        typedDictNotAllowed: {
          message: '"TypedDict" cannot be used in this context',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictSecondArgDict: {
          message: 'Expected dict or keyword parameter as second parameter',
          comment: '{Locked=\'dict\'}'
        },
        typedDictSecondArgDictEntry: 'Expected simple dictionary entry',
        typedDictSet: {
          message: 'Could not assign item in TypedDict',
          comment: '{Locked=\'TypedDict\'}'
        },
        unaccessedClass: 'Class "{name}" is not accessed',
        unaccessedFunction: 'Function "{name}" is not accessed',
        unaccessedImport: 'Import "{name}" is not accessed',
        unaccessedSymbol: '"{name}" is not accessed',
        unaccessedVariable: 'Variable "{name}" is not accessed',
        unannotatedFunctionSkipped: 'Analysis of function "{name}" is skipped because it is unannotated',
        unaryOperationNotAllowed: 'Unary operator not allowed in type expression',
        unexpectedAsyncToken: {
          message: 'Expected "def", "with" or "for" to follow "async"',
          comment: '{Locked=\'def\',\'with\',\'for\',\'async\'}'
        },
        unexpectedExprToken: 'Unexpected token at end of expression',
        unexpectedIndent: 'Unexpected indentation',
        unexpectedUnindent: 'Unindent not expected',
        unhashableDictKey: 'Dictionary key must be hashable',
        unhashableSetEntry: {
          message: 'Set entry must be hashable',
          comment: ['{StrContains=i\'set\'}', '\'set\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        uninitializedAbstractVariables: {
          message: 'Variables defined in abstract base class are not initialized in final class "{classType}"',
          comment: '{Locked=\'final\'}'
        },
        uninitializedInstanceVariable: {
          message: 'Instance variable "{name}" is not initialized in the class body or __init__ method',
          comment: '{Locked=\'__init__\'}'
        },
        unionForwardReferenceNotAllowed: {
          message: 'Union syntax cannot be used with string operand; use quotes around entire expression',
          comment: '{Locked=\'Union\'}'
        },
        unionSyntaxIllegal: {
          message: 'Alternative syntax for unions requires Python 3.10 or newer',
          comment: '\'unions\' as in the mathematical set theory term'
        },
        unionTypeArgCount: {
          message: 'Union requires two or more type arguments',
          comment: '{Locked=\'Union\'}'
        },
        unionUnpackedTuple: {
          message: 'Union cannot include an unpacked tuple',
          comment: '{Locked=\'Union\',\'tuple\'}'
        },
        unionUnpackedTypeVarTuple: {
          message: 'Union cannot include an unpacked TypeVarTuple',
          comment: '{Locked=\'Union\',\'TypeVarTuple\'}'
        },
        unnecessaryCast: {
          message: 'Unnecessary "cast" call; type is already "{type}"',
          comment: '{Locked=\'cast\'}'
        },
        unnecessaryIsInstanceAlways: {
          message: 'Unnecessary isinstance call; "{testType}" is always an instance of "{classType}"',
          comment: '{Locked=\'isinstance\'}'
        },
        unnecessaryIsSubclassAlways: {
          message: 'Unnecessary issubclass call; "{testType}" is always a subclass of "{classType}"',
          comment: '{Locked=\'issubclass\'}'
        },
        unnecessaryIsInstanceNever: {
          message: 'Unnecessary isinstance call; "{testType}" is never an instance of "{classType}"',
          comment: '{Locked=\'isinstance\'}'
        },
        unnecessaryIsSubclassNever: {
          message: 'Unnecessary issubclass call; "{testType}" is never a subclass of "{classType}"',
          comment: '{Locked=\'issubclass\'}'
        },
        unnecessaryPyrightIgnore: {
          message: 'Unnecessary "# pyright: ignore" comment',
          comment: '{Locked=\'# pyright: ignore\'}'
        },
        unnecessaryPyrightIgnoreRule: {
          message: 'Unnecessary "# pyright: ignore" rule: "{name}"',
          comment: '{Locked=\'# pyright: ignore\'}'
        },
        unnecessaryTypeIgnore: {
          message: 'Unnecessary "# type: ignore" comment',
          comment: '{Locked=\'# type: ignore\'}'
        },
        unpackArgCount: {
          message: 'Expected a single type argument after "Unpack"',
          comment: '{Locked=\'Unpack\'}'
        },
        unpackExpectedTypeVarTuple: {
          message: 'Expected TypeVarTuple or tuple as type argument for Unpack',
          comment: '{Locked=\'TypeVarTuple\',\'tuple\',\'Unpack\'}'
        },
        unpackExpectedTypedDict: {
          message: 'Expected TypedDict type argument for Unpack',
          comment: '{Locked=\'TypedDict\',\'Unpack\'}'
        },
        unpackIllegalInComprehension: {
          message: 'Unpack operation not allowed in comprehension',
          comment: 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable'
        },
        unpackInAnnotation: 'Unpack operator not allowed in type expression',
        unpackInDict: 'Unpack operation not allowed in dictionaries',
        unpackInSet: {
          message: 'Unpack operator not allowed within a set',
          comment: '{Locked=\'set\'}'
        },
        unpackNotAllowed: {
          message: 'Unpack is not allowed in this context',
          comment: '{Locked=\'Unpack\'}'
        },
        unpackOperatorNotAllowed: 'Unpack operation is not allowed in this context',
        unpackTuplesIllegal: {
          message: 'Unpack operation not allowed in tuples prior to Python 3.8',
          comment: '\'tuple\' is a keyword and should not be localized, but here it is pluralized'
        },
        unpackedArgInTypeArgument: 'Unpacked arguments cannot be used in this context',
        unpackedArgWithVariadicParam: {
          message: 'Unpacked argument cannot be used for TypeVarTuple parameter',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        unpackedDictArgumentNotMapping: {
          message: 'Argument expression after ** must be a mapping with a "str" key type',
          comment: '{Locked=\'str\'}'
        },
        unpackedDictSubscriptIllegal: 'Dictionary unpack operator in subscript is not allowed',
        unpackedSubscriptIllegal: 'Unpack operator in subscript requires Python 3.11 or newer',
        unpackedTypeVarTupleExpected: {
          message: 'Expected unpacked TypeVarTuple; use Unpack[{name1}] or *{name2}',
          comment: '{Locked=\'TypeVarTuple\',\'Unpack[{name1}]\',\'*{name2}\'}'
        },
        unpackedTypedDictArgument: {
          message: 'Unable to match unpacked TypedDict argument to parameters',
          comment: '{Locked=\'TypedDict\'}'
        },
        unreachableCode: 'Code is unreachable',
        unreachableCodeType: 'Type analysis indicates code is unreachable',
        unreachableExcept: {
          message: 'Except clause is unreachable because exception is already handled',
          comment: ['{StrContains=i\'except\'}', '\'except\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        unsupportedDunderAllOperation: {
          message: 'Operation on "__all__" is not supported, so exported symbol list may be incorrect',
          comment: '{Locked=\'__all__\'}'
        },
        unusedCallResult: 'Result of call expression is of type "{type}" and is not used; assign to variable "_" if this is intentional',
        unusedCoroutine: {
          message: 'Result of async function call is not used; use "await" or assign result to variable',
          comment: '{Locked=\'async\'}'
        },
        unusedExpression: 'Expression value is unused',
        varAnnotationIllegal: {
          message: 'Type annotations for variables requires Python 3.6 or newer; use type comment for compatibility with previous versions',
          comment: '{Locked=\'type\'}'
        },
        variableFinalOverride: {
          message: 'Variable "{name}" is marked Final and overrides non-Final variable of same name in class "{className}"',
          comment: '{Locked=\'Final\'}'
        },
        variadicTypeArgsTooMany: {
          message: 'Type argument list can have at most one unpacked TypeVarTuple or tuple',
          comment: '{Locked=\'TypeVarTuple\',\'tuple\'}'
        },
        variadicTypeParamTooManyAlias: {
          message: 'Type alias can have at most one TypeVarTuple type parameter but received multiple ({names})',
          comment: '{Locked=\'TypeVarTuple\'}'
        },
        variadicTypeParamTooManyClass: {
          message: 'Generic class can have at most one TypeVarTuple type parameter but received multiple ({names})',
          comment: ['{Locked=\'TypeVarTuple\'}', 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container']
        },
        walrusIllegal: 'Operator ":=" requires Python 3.8 or newer',
        walrusNotAllowed: 'Operator ":=" is not allowed in this context without surrounding parentheses',
        wildcardInFunction: {
          message: 'Wildcard import not allowed within a class or function',
          comment: '{Locked=\'import\'}'
        },
        wildcardLibraryImport: {
          message: 'Wildcard import from a library not allowed',
          comment: '{Locked=\'import\'}'
        },
        wildcardPatternTypePartiallyUnknown: 'Type captured by wildcard pattern is partially unknown',
        wildcardPatternTypeUnknown: 'Type captured by wildcard pattern is unknown',
        yieldFromIllegal: {
          message: 'Use of "yield from" requires Python 3.3 or newer',
          comment: '{Locked=\'yield from\'}'
        },
        yieldFromOutsideAsync: {
          message: '"yield from" not allowed in an async function',
          comment: '{Locked=\'yield from\',\'async\'}'
        },
        yieldOutsideFunction: {
          message: '"yield" not allowed outside of a function or lambda',
          comment: '{Locked=\'yield\'}'
        },
        yieldWithinComprehension: {
          message: '"yield" not allowed inside a comprehension',
          comment: ['{Locked=\'yield\'}', 'A comprehension is a \'set of looping and filtering instructions\' applied to a collection to generate a new collection; the word may not be translatable']
        },
        zeroCaseStatementsFound: {
          message: 'Match statement must include at least one case statement',
          comment: ['{Locked=\'case\'}', '{StrContains=i\'match\'}', '\'match\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        zeroLengthTupleNotAllowed: {
          message: 'Zero-length tuple is not allowed in this context',
          comment: '{Locked=\'tuple\'}'
        }
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: {
          message: '"Annotated" special form cannot be used with instance and class checks',
          comment: '{Locked=\'Annotated\'}'
        },
        argParam: 'Argument corresponds to parameter "{paramName}"',
        argParamFunction: 'Argument corresponds to parameter "{paramName}" in function "{functionName}"',
        argsParamMissing: 'Parameter "*{paramName}" has no corresponding parameter',
        argsPositionOnly: 'Position-only parameter mismatch; expected {expected} but received {received}',
        argumentType: 'Argument type is "{type}"',
        argumentTypes: 'Argument types: ({types})',
        assignToNone: {
          message: 'Type is not assignable to "None"',
          comment: '{Locked=\'None\'}'
        },
        asyncHelp: {
          message: 'Did you mean "async with"?',
          comment: '{Locked=\'async with\'}'
        },
        baseClassIncompatible: 'Base class "{baseClass}" is incompatible with type "{type}"',
        baseClassIncompatibleSubclass: 'Base class "{baseClass}" derives from "{subclass}" which is incompatible with type "{type}"',
        baseClassOverriddenType: 'Base class "{baseClass}" provides type "{type}", which is overridden',
        baseClassOverridesType: 'Base class "{baseClass}" overrides with type "{type}"',
        bytesTypePromotions: {
          message: 'Set disableBytesTypePromotions to false to enable type promotion behavior for "bytearray" and "memoryview"',
          comment: '{Locked=\'disableBytesTypePromotions\',\'false\',\'bytearray\',\'memoryview\'}'
        },
        conditionalRequiresBool: {
          message: 'Method __bool__ for type "{operandType}" returns type "{boolReturnType}" rather than "bool"',
          comment: '{Locked=\'__bool__\'}'
        },
        dataClassFieldLocation: 'Field declaration',
        dataClassFrozen: '"{name}" is frozen',
        dataProtocolUnsupported: '"{name}" is a data protocol',
        descriptorAccessBindingFailed: {
          message: 'Failed to bind method "{name}" for descriptor class "{className}"',
          comment: 'Binding is the process through which Pyright determines what object a name refers to'
        },
        descriptorAccessCallFailed: 'Failed to call method "{name}" for descriptor class "{className}"',
        finalMethod: {
          message: 'Final method',
          comment: '{Locked=\'Final\'}'
        },
        functionParamDefaultMissing: 'Parameter "{name}" is missing default argument',
        functionParamName: 'Parameter name mismatch: "{destName}" versus "{srcName}"',
        functionParamPositionOnly: 'Position-only parameter mismatch; parameter "{name}" is not position-only',
        functionReturnTypeMismatch: 'Function return type "{sourceType}" is incompatible with type "{destType}"',
        functionTooFewParams: 'Function accepts too few positional parameters; expected {expected} but received {received}',
        functionTooManyParams: 'Function accepts too many positional parameters; expected {expected} but received {received}',
        genericClassNotAllowed: {
          message: 'Generic type with type arguments not allowed for instance or class checks',
          comment: 'A generic type is a parameterized type, for example a container where the generic type parameter specifies the type of elements in the container'
        },
        incompatibleDeleter: {
          message: 'Property deleter method is incompatible',
          comment: ['{Locked=\'deleter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        incompatibleGetter: {
          message: 'Property getter method is incompatible',
          comment: ['{Locked=\'getter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        incompatibleSetter: {
          message: 'Property setter method is incompatible',
          comment: ['{Locked=\'setter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        initMethodLocation: {
          message: 'The __init__ method is defined in class "{type}"',
          comment: '{Locked=\'__init__\'}'
        },
        initMethodSignature: {
          message: 'Signature of __init__ is "{type}"',
          comment: '{Locked=\'__init__\'}'
        },
        initSubclassLocation: {
          message: 'The __init_subclass__ method is defined in class "{name}"',
          comment: '{Locked=\'__init_subclass__\'}'
        },
        invariantSuggestionDict: {
          message: 'Consider switching from "dict" to "Mapping" which is covariant in the value type',
          comment: '{Locked=\'dict\',\'Mapping\'}'
        },
        invariantSuggestionList: {
          message: 'Consider switching from "list" to "Sequence" which is covariant',
          comment: '{Locked=\'list\',\'Sequence\'}'
        },
        invariantSuggestionSet: {
          message: 'Consider switching from "set" to "Container" which is covariant',
          comment: '{Locked=\'set\',\'Container\'}'
        },
        isinstanceClassNotSupported: '"{type}" is not supported for instance and class checks',
        keyNotRequired: '"{name}" is not a required key in "{type}", so access may result in runtime exception',
        keyReadOnly: '"{name}" is a read-only key in "{type}"',
        keyRequiredDeleted: '"{name}" is a required key and cannot be deleted',
        keyUndefined: '"{name}" is not a defined key in "{type}"',
        kwargsParamMissing: 'Parameter "**{paramName}" has no corresponding parameter',
        listAssignmentMismatch: 'Type "{type}" is incompatible with target list',
        literalAssignmentMismatch: '"{sourceType}" is not assignable to type "{destType}"',
        matchIsNotExhaustiveHint: {
          message: 'If exhaustive handling is not intended, add "case _: pass"',
          comment: '{Locked=\'case _: pass\'}'
        },
        matchIsNotExhaustiveType: 'Unhandled type: "{type}"',
        memberAssignment: 'Expression of type "{type}" cannot be assigned to attribute "{name}" of class "{classType}"',
        memberIsAbstract: '"{type}.{name}" is not implemented',
        memberIsAbstractMore: {
          message: 'and {count} more...',
          comment: '{StrEnds=\'...\'}'
        },
        memberIsClassVarInProtocol: {
          message: '"{name}" is defined as a ClassVar in protocol',
          comment: '{Locked=\'ClassVar\'}'
        },
        memberIsInitVar: {
          message: '"{name}" is an init-only field',
          comment: '{Locked=\'init-only\'}'
        },
        memberIsInvariant: '"{name}" is invariant because it is mutable',
        memberIsNotClassVarInClass: {
          message: '"{name}" must be defined as a ClassVar to be compatible with protocol',
          comment: '{Locked=\'ClassVar\'}'
        },
        memberIsNotClassVarInProtocol: {
          message: '"{name}" is not defined as a ClassVar in protocol',
          comment: '{Locked=\'ClassVar\'}'
        },
        memberIsNotReadOnlyInProtocol: '"{name}" is not read-only in protocol',
        memberIsReadOnlyInProtocol: '"{name}" is read-only in protocol',
        memberIsWritableInProtocol: '"{name}" is writable in protocol',
        memberSetClassVar: {
          message: 'Attribute "{name}" cannot be assigned through a class instance because it is a ClassVar',
          comment: '{Locked=\'ClassVar\'}'
        },
        memberTypeMismatch: '"{name}" is an incompatible type',
        memberUnknown: 'Attribute "{name}" is unknown',
        metaclassConflict: {
          message: 'Metaclass "{metaclass1}" conflicts with "{metaclass2}"',
          comment: 'Metaclasses are a complex concept and it may be best to not localize the term'
        },
        missingDeleter: {
          message: 'Property deleter method is missing',
          comment: ['{Locked=\'deleter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        missingGetter: {
          message: 'Property getter method is missing',
          comment: ['{Locked=\'getter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        missingSetter: {
          message: 'Property setter method is missing',
          comment: ['{Locked=\'setter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        namedParamMissingInDest: 'Extra parameter "{name}"',
        namedParamMissingInSource: 'Missing keyword parameter "{name}"',
        namedParamTypeMismatch: 'Keyword parameter "{name}" of type "{sourceType}" is incompatible with type "{destType}"',
        namedTupleNotAllowed: {
          message: 'NamedTuple cannot be used for instance or class checks',
          comment: '{Locked=\'NamedTuple\'}'
        },
        newMethodLocation: {
          message: 'The __new__ method is defined in class "{type}"',
          comment: '{Locked=\'__new__\'}'
        },
        newMethodSignature: {
          message: 'Signature of __new__ is "{type}"',
          comment: '{Locked=\'__new__\'}'
        },
        newTypeClassNotAllowed: {
          message: 'Class created with NewType cannot be used with instance and class checks',
          comment: '{Locked=\'NewType\'}'
        },
        noOverloadAssignable: 'No overloaded function matches type "{type}"',
        noneNotAllowed: {
          message: 'None cannot be used for instance or class checks',
          comment: '{Locked=\'None\'}'
        },
        orPatternMissingName: 'Missing names: {name}',
        overloadIndex: 'Overload {index} is the closest match',
        overloadNotAssignable: 'One or more overloads of "{name}" is not assignable',
        overloadSignature: 'Overload signature is defined here',
        overriddenMethod: 'Overridden method',
        overriddenSymbol: 'Overridden symbol',
        overrideInvariantMismatch: 'Override type "{overrideType}" is not the same as base type "{baseType}"',
        overrideIsInvariant: 'Variable is mutable so its type is invariant',
        overrideNoOverloadMatches: 'No overload signature in override is compatible with base method',
        overrideNotClassMethod: {
          message: 'Base method is declared as a classmethod but override is not',
          comment: '{Locked=\'classmethod\'}'
        },
        overrideNotInstanceMethod: 'Base method is declared as an instance method but override is not',
        overrideNotStaticMethod: {
          message: 'Base method is declared as a staticmethod but override is not',
          comment: '{Locked=\'staticmethod\'}'
        },
        overrideOverloadNoMatch: 'Override does not handle all overloads of base method',
        overrideOverloadOrder: 'Overloads for override method must be in the same order as the base method',
        overrideParamKeywordNoDefault: 'Keyword parameter "{name}" mismatch: base parameter has default argument value, override parameter does not',
        overrideParamKeywordType: 'Keyword parameter "{name}" type mismatch: base parameter is type "{baseType}", override parameter is type "{overrideType}"',
        overrideParamName: 'Parameter {index} name mismatch: base parameter is named "{baseName}", override parameter is named "{overrideName}"',
        overrideParamNameExtra: 'Parameter "{name}" is missing in base',
        overrideParamNameMissing: 'Parameter "{name}" is missing in override',
        overrideParamNamePositionOnly: 'Parameter {index} mismatch: base parameter "{baseName}" is keyword parameter, override parameter is position-only',
        overrideParamNoDefault: 'Parameter {index} mismatch: base parameter has default argument value, override parameter does not',
        overrideParamType: 'Parameter {index} type mismatch: base parameter is type "{baseType}", override parameter is type "{overrideType}"',
        overridePositionalParamCount: 'Positional parameter count mismatch; base method has {baseCount}, but override has {overrideCount}',
        overrideReturnType: 'Return type mismatch: base method returns type "{baseType}", override returns type "{overrideType}"',
        overrideType: 'Base class defines type as "{type}"',
        paramAssignment: 'Parameter {index}: type "{sourceType}" is incompatible with type "{destType}"',
        paramSpecMissingInOverride: {
          message: 'ParamSpec parameters are missing in override method',
          comment: '{Locked=\'ParamSpec\'}'
        },
        paramType: 'Parameter type is "{paramType}"',
        privateImportFromPyTypedSource: 'Import from "{module}" instead',
        propertyAccessFromProtocolClass: 'A property defined within a protocol class cannot be accessed as a class variable',
        propertyMethodIncompatible: {
          message: 'Property method "{name}" is incompatible',
          comment: ['{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        propertyMethodMissing: {
          message: 'Property method "{name}" is missing in override',
          comment: ['{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        propertyMissingDeleter: {
          message: 'Property "{name}" has no defined deleter',
          comment: ['{Locked=\'deleter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        propertyMissingSetter: {
          message: 'Property "{name}" has no defined setter',
          comment: ['{Locked=\'setter\'}', '{StrContains=i\'property\'}', '\'property\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        protocolIncompatible: '"{sourceType}" is incompatible with protocol "{destType}"',
        protocolMemberMissing: '"{name}" is not present',
        protocolRequiresRuntimeCheckable: {
          message: 'Protocol class must be @runtime_checkable to be used with instance and class checks',
          comment: '{Locked=\'Protocol\',\'@runtime_checkable\'}'
        },
        protocolSourceIsNotConcrete: '"{sourceType}" is not a concrete class type and cannot be assigned to type "{destType}"',
        protocolUnsafeOverlap: 'Attributes of "{name}" have the same names as the protocol',
        pyrightCommentIgnoreTip: {
          message: 'Use "# pyright: ignore[<diagnostic rules>]" to suppress diagnostics for a single line',
          comment: '{Locked=\'# pyright: ignore[<diagnostic rules>]\'}'
        },
        readOnlyAttribute: 'Attribute "{name}" is read-only',
        seeClassDeclaration: 'See class declaration',
        seeDeclaration: 'See declaration',
        seeFunctionDeclaration: 'See function declaration',
        seeMethodDeclaration: 'See method declaration',
        seeParameterDeclaration: 'See parameter declaration',
        seeTypeAliasDeclaration: 'See type alias declaration',
        seeVariableDeclaration: 'See variable declaration',
        tupleAssignmentMismatch: {
          message: 'Type "{type}" is incompatible with target tuple',
          comment: '{Locked=\'tuple\'}'
        },
        tupleEntryTypeMismatch: {
          message: 'Tuple entry {entry} is incorrect type',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleSizeIndeterminateSrc: {
          message: 'Tuple size mismatch; expected {expected} but received indeterminate',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleSizeIndeterminateSrcDest: {
          message: 'Tuple size mismatch; expected {expected} or more but received indeterminate',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleSizeMismatch: {
          message: 'Tuple size mismatch; expected {expected} but received {received}',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        tupleSizeMismatchIndeterminateDest: {
          message: 'Tuple size mismatch; expected {expected} or more but received {received}',
          comment: ['{StrContains=i\'tuple\'}', '\'tuple\' is a keyword and should not be localized. It is only capitalized here because it is the first word in the sentence']
        },
        typeAliasInstanceCheck: {
          message: 'Type alias created with "type" statement cannot be used with instance and class checks',
          comment: '{Locked=\'type\'}'
        },
        typeAssignmentMismatch: 'Type "{sourceType}" is not assignable to type "{destType}"',
        typeBound: 'Type "{sourceType}" is not assignable to upper bound "{destType}" for type variable "{name}"',
        typeConstrainedTypeVar: 'Type "{type}" is not assignable to constrained type variable "{name}"',
        typeIncompatible: '"{sourceType}" is not assignable to "{destType}"',
        typeNotClass: '"{type}" is not a class',
        typeNotStringLiteral: '"{type}" is not a string literal',
        typeOfSymbol: 'Type of "{name}" is "{type}"',
        typeParamSpec: {
          message: 'Type "{type}" is incompatible with ParamSpec "{name}"',
          comment: '{Locked=\'ParamSpec\'}'
        },
        typeUnsupported: 'Type "{type}" is unsupported',
        typeVarDefaultOutOfScope: 'Type variable "{name}" is not in scope',
        typeVarIsContravariant: 'Type parameter "{name}" is contravariant, but "{sourceType}" is not a supertype of "{destType}"',
        typeVarIsCovariant: 'Type parameter "{name}" is covariant, but "{sourceType}" is not a subtype of "{destType}"',
        typeVarIsInvariant: 'Type parameter "{name}" is invariant, but "{sourceType}" is not the same as "{destType}"',
        typeVarNotAllowed: {
          message: 'TypeVar not allowed for instance or class checks',
          comment: '{Locked=\'TypeVar\'}'
        },
        typeVarTupleRequiresKnownLength: {
          message: 'TypeVarTuple cannot be bound to a tuple of unknown length',
          comment: '{Locked=\'TypeVarTuple\',\'tuple\'}'
        },
        typeVarUnnecessarySuggestion: 'Use {type} instead',
        typeVarUnsolvableRemedy: 'Provide an overload that specifies the return type when the argument is not supplied',
        typeVarsMissing: 'Missing type variables: {names}',
        typedDictBaseClass: {
          message: 'Class "{type}" is not a TypedDict',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictClassNotAllowed: {
          message: 'TypedDict class not allowed for instance or class checks',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictClosedExtraNotAllowed: 'Cannot add item "{name}"',
        typedDictClosedExtraTypeMismatch: 'Cannot add item "{name}" with type "{type}"',
        typedDictClosedFieldNotRequired: {
          message: 'Cannot add item "{name}" because it must be NotRequired',
          comment: '{Locked=\'NotRequired\'}'
        },
        typedDictExtraFieldNotAllowed: '"{name}" is not present in "{type}"',
        typedDictExtraFieldTypeMismatch: {
          message: 'Type of "{name}" is incompatible with type of "extra_items" in "{type}"',
          comment: '{Locked=\'extra_items\'}'
        },
        typedDictFieldMissing: '"{name}" is missing from "{type}"',
        typedDictFieldNotReadOnly: '"{name}" is not read-only in "{type}"',
        typedDictFieldNotRequired: '"{name}" is not required in "{type}"',
        typedDictFieldRequired: '"{name}" is required in "{type}"',
        typedDictFieldTypeMismatch: 'Type "{type}" is not assignable to item "{name}"',
        typedDictFieldUndefined: '"{name}" is an undefined item in type "{type}"',
        typedDictFinalMismatch: {
          message: '"{sourceType}" is incompatible with "{destType}" because of a @final mismatch',
          comment: '{Locked=\'@final\'}'
        },
        typedDictKeyAccess: {
          message: 'Use ["{name}"] to reference item in TypedDict',
          comment: '{Locked=\'TypedDict\'}'
        },
        typedDictNotAllowed: {
          message: 'TypedDict cannot be used for instance or class checks',
          comment: '{Locked=\'TypedDict\'}'
        },
        unhashableType: 'Type "{type}" is not hashable',
        uninitializedAbstractVariable: 'Instance variable "{name}" is defined in abstract base class "{classType}" but not initialized',
        unreachableExcept: '"{exceptionType}" is a subclass of "{parentType}"',
        useDictInstead: {
          message: 'Use Dict[T1, T2] to indicate a dictionary type',
          comment: '{Locked=\'Dict[T1, T2]\'}'
        },
        useListInstead: {
          message: 'Use List[T] to indicate a list type or Union[T1, T2] to indicate a union type',
          comment: '{Locked=\'List[T]\',\'list\',\'Union[T1, T2]\',\'union\'}'
        },
        useTupleInstead: {
          message: 'Use tuple[T1, ..., Tn] to indicate a tuple type or Union[T1, T2] to indicate a union type',
          comment: '{Locked=\'tuple[T1, ..., Tn]\',\'tuple\',\'Union[T1, T2]\',\'union\'}'
        },
        useTypeInstead: {
          message: 'Use Type[T] instead',
          comment: '{Locked=\'Type[T]\'}'
        },
        varianceMismatchForClass: 'Variance of type argument "{typeVarName}" is incompatible with base class "{className}"',
        varianceMismatchForTypeAlias: 'Variance of type argument "{typeVarName}" is incompatible with "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'Enumeration of workspace source files is taking a long time. Consider opening a sub-folder instead. [Learn more](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  45458: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Crear Tipo Stub',
        createTypeStubFor: 'Crear Tipo Stub Para "{moduleName}"',
        executingCommand: 'Ejecutando el comando',
        filesToAnalyzeCount: '{count} archivos para analizar',
        filesToAnalyzeOne: '1 archivo para analizar',
        findingReferences: 'Buscando referencias',
        organizeImports: 'Organizar Importaciones',
        renameShadowedFile: 'Cambie el nombre de "{oldFile}" a "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Importacin automtica',
        indexValueDetail: 'Valor de ndice'
      },
      Diagnostic: {
        abstractMethodInvocation: 'No se puede llamar al mtodo "{method}" porque es abstracto y no se ha implementado.',
        annotatedMetadataInconsistent: 'El tipo de metadatos anotados "{metadataType}" no es compatible con el tipo "{type}"',
        annotatedParamCountMismatch: 'El recuento de anotaciones del parmetro no coincide: se esperaba {expected}, pero se recibi {received}',
        annotatedTypeArgMissing: 'Se espera un argumento de tipo y una o ms anotaciones para "Annotated".',
        annotationBytesString: 'Las expresiones de tipo no pueden usar literales de cadena de bytes',
        annotationFormatString: 'Las expresiones de tipo no pueden usar literales de cadena de formato (f-strings)',
        annotationNotSupported: 'No se admite la anotacin de tipo para esta declaracin',
        annotationRawString: 'Las expresiones de tipo no pueden usar literales de cadena sin formato',
        annotationSpansStrings: 'Las expresiones de tipo no pueden abarcar varios literales de cadena',
        annotationStringEscape: 'Las expresiones de tipo no pueden contener caracteres de escape',
        argAssignment: 'Argumento de tipo "{argType}" no puede ser asignado a parmetro de tipo "{paramType}"',
        argAssignmentFunction: 'El argumento de tipo "{argType}" no puede ser asignado a parmetro de tipo "{paramType}" en funcin "{functionName}"',
        argAssignmentParam: 'Argumento de tipo "{argType}" no puede ser asignado a parmetro "{paramName}" de tipo "{paramType}"',
        argAssignmentParamFunction: 'Argumento de tipo "{argType}" no puede ser asignado a parmetro "{paramName}" de tipo "{paramType}" en funcin "{functionName}"',
        argMissingForParam: 'Falta el argumento para el parmetro {name}',
        argMissingForParams: 'Faltan argumentos para los parmetros {names}',
        argMorePositionalExpectedCount: 'Ms argumentos posicionales {expected} esperados',
        argMorePositionalExpectedOne: 'Se espera 1 argumento posicional ms',
        argPositional: 'Argumento posicional esperado',
        argPositionalExpectedCount: 'Argumentos posicionales esperados {expected}',
        argPositionalExpectedOne: 'Se espera 1 argumento posicional',
        argTypePartiallyUnknown: 'El tipo de argumento es parcialmente desconocido',
        argTypeUnknown: 'Tipo de argumento desconocido',
        assertAlwaysTrue: 'La expresin Assert siempre se evala como true',
        assertTypeArgs: '"assert_type" espera dos argumentos posicionales',
        assertTypeTypeMismatch: 'Error de coincidencia "assert_type": se esperaba "{expected}" pero se ha recibido "{received}"',
        assignmentExprComprehension: 'El destino de la expresin de asignacin "{name}" no puede usar el mismo nombre que la comprensin para el destino',
        assignmentExprContext: 'La expresin de asignacin debe estar dentro de un mdulo, funcin o lambda',
        assignmentExprInSubscript: 'Las expresiones de asignacin dentro de un subndice solo se admiten en Python 3.10 y versiones posteriores.',
        assignmentInProtocol: 'Las variables de instancia o clase dentro de una clase Protocol deben declararse explcitamente en el cuerpo de la clase.',
        assignmentTargetExpr: 'La expresin no puede ser objetivo de asignacin',
        asyncNotInAsyncFunction: 'No se permite el uso de "async" fuera de la funcin async',
        awaitIllegal: 'El uso de "await" requiere Python 3.5 o posterior.',
        awaitNotAllowed: 'Las expresiones de tipo no pueden usar "await"',
        awaitNotInAsync: '"await" solo se permite dentro de una funcin async',
        backticksIllegal: 'En Python 3.x no se admiten expresiones rodeadas de puntos suspensivos; utilice repr en su lugar.',
        baseClassCircular: 'La clase no se puede derivar de s misma',
        baseClassFinal: 'La clase base "{type}" est marcada como final y no puede ser subclasificada',
        baseClassIncompatible: 'Las clases base de {type} son mutuamente incompatibles',
        baseClassInvalid: 'El argumento de la clase debe ser una clase base',
        baseClassMethodTypeIncompatible: 'Las clases base para la clase "{classType}" definen el mtodo "{name}" de forma incompatible',
        baseClassUnknown: 'Se desconoce el tipo de la clase base, lo que oculta el tipo de la clase derivada.',
        baseClassVariableTypeIncompatible: 'Las clases base para la clase "{classType}" definen la variable "{name}" de forma incompatible',
        binaryOperationNotAllowed: 'Operador binario no permitido en la expresin de tipo',
        bindTypeMismatch: 'No se pudo enlazar el mtodo "{methodName}" porque "{type}" no se puede asignar al parmetro "{paramName}"',
        breakInExceptionGroup: 'No se permite "break" en un bloque "except*"',
        breakOutsideLoop: '"break" solo se puede usar dentro de un bucle',
        callableExtraArgs: 'Se esperaban solo dos argumentos de tipo para "Callable".',
        callableFirstArg: 'Lista de tipos de parmetros esperados o "..."',
        callableNotInstantiable: 'No se puede instanciar el tipo "{type}"',
        callableSecondArg: 'Tipo de retorno esperado como segundo argumento de tipo para "Callable"',
        casePatternIsIrrefutable: 'El patrn irrefutable solo se permite para la ltima instruccin case',
        classAlreadySpecialized: 'El tipo "{type}" ya est especializado',
        classDecoratorTypeUnknown: 'El decorador de clase sin tipo oculta el tipo de clase; omitiendo el elemento Decorator',
        classDefinitionCycle: 'La definicin de clase para "{name}" depende de s misma.',
        classGetItemClsParam: '__class_getitem__ debe tomar un parmetro "cls"',
        classMethodClsParam: 'Los mtodos de clase deben tomar un parmetro "cls"',
        classNotRuntimeSubscriptable: 'El subndice para la clase "{name}" generar una excepcin en tiempo de ejecucin; encierre la expresin de tipo entre comillas',
        classPatternBuiltInArgPositional: 'El patrn de clase solo acepta subpatrones posicionales',
        classPatternPositionalArgCount: 'Demasiados patrones posicionales para la clase "{type}"; esperado {expected} pero recibido {received}',
        classPatternTypeAlias: '"{type}" no se puede usar en un patrn de clase porque es un alias de tipo especializado',
        classPropertyDeprecated: 'Las propiedades de clase estn en desuso en Python 3.11 y no se admitirn en Python 3.13.',
        classTypeParametersIllegal: 'La sintaxis de los parmetros de tipo de clase requiere Python 3.12 o posterior.',
        classVarFirstArgMissing: 'Se esperaba un argumento de tipo despus de "ClassVar"',
        classVarNotAllowed: '"ClassVar" no est permitido en este contexto',
        classVarOverridesInstanceVar: 'La variable de clase "{name}" anula la variable de instancia del mismo nombre en la clase "{className}"',
        classVarTooManyArgs: 'Solo se esperaba un argumento de tipo despus de "ClassVar"',
        classVarWithTypeVar: 'El tipo "ClassVar" no puede incluir variables de tipo',
        clsSelfParamTypeMismatch: 'El tipo de parmetro "{name}" debe ser un supertipo de su clase "{classType}"',
        codeTooComplexToAnalyze: 'El cdigo es demasiado complejo para analizarlo; reduzca la complejidad refactorizndolo en subrutinas o reduciendo las rutas de cdigo condicional.',
        collectionAliasInstantiation: 'No se puede crear una instancia del tipo "{type}"; use "{alias}" en su lugar.',
        comparisonAlwaysFalse: 'La condicin siempre se evaluar como False, ya que los tipos "{leftType}" y "{rightType}" no se superponen.',
        comparisonAlwaysTrue: 'La condicin siempre se evaluar como True, ya que los tipos "{leftType}" y "{rightType}" no se superponen.',
        comprehensionInDict: 'La comprensin no puede utilizarse con otras entradas del diccionario',
        comprehensionInSet: 'La comprensin no se puede usar con otras entradas de set',
        concatenateContext: '"Concatenate" no se permite en este contexto',
        concatenateParamSpecMissing: 'El ltimo argumento de tipo para "Concatenate" debe ser un ParamSpec o "..."',
        concatenateTypeArgsMissing: '"Concatenate" requiere al menos dos argumentos de tipo',
        conditionalOperandInvalid: 'Operando condicional no vlido de tipo "{type}"',
        constantRedefinition: '"{name}" es constante (porque est en maysculas) y no se puede volver a definir',
        constructorParametersMismatch: 'Error de coincidencia entre la firma de __new__ y __init__ en la clase "{classType}"',
        containmentAlwaysFalse: 'La expresin siempre se evaluar como False, ya que los tipos "{leftType}" y "{rightType}" no tienen superposicin',
        containmentAlwaysTrue: 'La expresin siempre se evaluar como True, ya que los tipos "{leftType}" y "{rightType}" no tienen superposicin',
        continueInExceptionGroup: 'No se permite "continue" en un bloque "except*"',
        continueOutsideLoop: '"continue" solo puede utilizarse dentro de un bucle',
        coroutineInConditionalExpression: 'La expresin condicional hace referencia a una corrutina que siempre se evala como True',
        dataClassBaseClassFrozen: 'Una clase no inmovilizada no puede heredar de una clase inmovilizada',
        dataClassBaseClassNotFrozen: 'Una clase congelada no puede heredar de una clase que no est congelada',
        dataClassConverterFunction: 'Argumento de tipo "{argType}" no es un convertidor vlido para el campo "{fieldName}" de tipo "{fieldType}"',
        dataClassConverterOverloads: 'No hay sobrecargas de "{funcName}" que sean convertidores vlidos para el campo "{fieldName}" de tipo "{fieldType}"',
        dataClassFieldInheritedDefault: '"{fieldName}" invalida un campo con el mismo nombre, pero falta un valor predeterminado',
        dataClassFieldWithDefault: 'Los campos sin valores predeterminados no pueden aparecer despus de los campos con valores predeterminados',
        dataClassFieldWithPrivateName: 'El campo Dataclass no puede utilizar un nombre privado',
        dataClassFieldWithoutAnnotation: 'El campo Dataclass sin anotacin de tipo provocar una excepcin en tiempo de ejecucin',
        dataClassPostInitParamCount: 'Dataclass __post_init__ recuento de parmetros incorrecto; el nmero de campos InitVar es {expected}.',
        dataClassPostInitType: 'El tipo de parmetro del mtodo __post_init__ de la clase de datos no coincide con el del campo "{fieldName}".',
        dataClassSlotsOverwrite: '__slots__ ya est definido en la clase',
        dataClassTransformExpectedBoolLiteral: 'Expresin esperada que se evala estticamente como True o False',
        dataClassTransformFieldSpecifier: 'Se esperaba una tuple de clases o funciones, pero se recibi el tipo "{type}"',
        dataClassTransformPositionalParam: 'Todos los argumentos de "dataclass_transform" deben ser argumentos de palabra clave',
        dataClassTransformUnknownArgument: 'El argumento "{name}" no es compatible con dataclass_transform',
        dataProtocolInSubclassCheck: 'No se permiten protocolos de datos (que incluyen atributos que no son de mtodo) en llamadas issubclass',
        declaredReturnTypePartiallyUnknown: 'El tipo de retorno declarado, "{returnType}", es parcialmente desconocido',
        declaredReturnTypeUnknown: 'El tipo de retorno declarado es desconocido',
        defaultValueContainsCall: 'No se permiten llamadas de funcin y objetos mutables dentro de la expresin de valor predeterminado del parmetro',
        defaultValueNotAllowed: 'Los parmetros con "*" o "**" no pueden tener valor por defecto',
        delTargetExpr: 'No se puede eliminar la expresin',
        deprecatedClass: 'La clase "{name}" est en desuso',
        deprecatedConstructor: 'El constructor de la clase "{name}" est obsoleto',
        deprecatedDescriptorDeleter: 'El mtodo "__delete__" para el "{name}" de descriptor est en desuso',
        deprecatedDescriptorGetter: 'El mtodo "__get__" para el "{name}" de descriptor est en desuso',
        deprecatedDescriptorSetter: 'El mtodo "__set__" para el "{name}" de descriptor est en desuso',
        deprecatedFunction: 'La funcin "{name}" est obsoleta',
        deprecatedMethod: 'El mtodo "{name}" en la clase "{className}" est en desuso',
        deprecatedPropertyDeleter: 'El deleter de la property "{name}" est en desuso',
        deprecatedPropertyGetter: 'El getter de la property "{name}" est en desuso',
        deprecatedPropertySetter: 'El setter de la property "{name}" est en desuso',
        deprecatedType: 'Este tipo est obsoleto a partir de la {version} de Python; utilice en su lugar "{replacement}".',
        dictExpandIllegalInComprehension: 'No se permite la ampliacin del diccionario en la comprensin',
        dictInAnnotation: 'Expresin de diccionario no permitida en expresin de tipo',
        dictKeyValuePairs: 'Las entradas del diccionario deben contener pares clave/valor',
        dictUnpackIsNotMapping: 'Asignacin esperada para el operador de desempaquetado del diccionario',
        dunderAllSymbolNotPresent: '"{name}" se especifica en __all__ pero no est presente en el mdulo',
        duplicateArgsParam: 'Solo se permite un parmetro "*".',
        duplicateBaseClass: 'Clase base duplicada no permitida',
        duplicateCapturePatternTarget: 'El destino de captura "{name}" no puede aparecer ms de una vez dentro del mismo patrn',
        duplicateCatchAll: 'Solo se permite una clusula de except',
        duplicateEnumMember: 'El miembro Enum "{name}" ya est declarado',
        duplicateGenericAndProtocolBase: 'Solo se permite una clase base Generic[...] o Protocol[...].',
        duplicateImport: '"{importName}" se importa ms de una vez',
        duplicateKeywordOnly: 'Solo se permite un separador "*".',
        duplicateKwargsParam: 'Solo se permite un parmetro "**".',
        duplicateParam: 'Parmetro duplicado "{name}"',
        duplicatePositionOnly: 'Solo se permite un parmetro "/"',
        duplicateStarPattern: 'Solo se permite un patrn "*" en una secuencia de patrones',
        duplicateStarStarPattern: 'Solo se permite una entrada "**"',
        duplicateUnpack: 'Solo se permite una operacin de desempaquetado en la lista',
        ellipsisAfterUnpacked: '"..." no se puede usar con una TypeVarTuple o tuple sin empaquetar',
        ellipsisContext: '"..." no est permitido en este contexto',
        ellipsisSecondArg: '"..." est permitido slo como el segundo de dos argumentos',
        enumClassOverride: 'La clase Enum "{name}" es final y no puede ser subclasificada',
        enumMemberDelete: 'No se puede eliminar el miembro de Enum "{name}"',
        enumMemberSet: 'No se puede asignar el miembro de Enum "{name}"',
        enumMemberTypeAnnotation: 'No se permiten anotaciones de tipo para miembros de enumeracin',
        exceptGroupMismatch: 'La instruccin Try no puede incluir "except" y "except*"',
        exceptGroupRequiresType: 'La sintaxis del grupo de excepciones ("except*") requiere un tipo de excepcin',
        exceptionGroupIncompatible: 'La sintaxis de grupo de excepciones ("except*") requiere Python 3.11 o posterior.',
        exceptionGroupTypeIncorrect: 'El tipo de excepcin en except* no puede derivarse de BaseGroupException',
        exceptionTypeIncorrect: '"{type}" no se deriva de BaseException',
        exceptionTypeNotClass: '"{type}" no es una clase de excepcin vlida',
        exceptionTypeNotInstantiable: 'El constructor para el tipo de excepcin "{type}" requiere uno o ms argumentos',
        expectedAfterDecorator: 'Se esperaba una declaracin de funcin o clase despus del decorador',
        expectedArrow: 'Se esperaba "->" seguido de una anotacin de tipo de retorno',
        expectedAsAfterException: 'Se esperaba "as" despus del tipo de excepcin',
        expectedAssignRightHandExpr: 'Expresin esperada a la derecha de "="',
        expectedBinaryRightHandExpr: 'Expresin esperada a la derecha del operador',
        expectedBoolLiteral: 'Se esperaba True o False',
        expectedCase: 'Declaracin "case" esperada',
        expectedClassName: 'Nombre de clase esperado',
        expectedCloseBrace: '"{" no estaba cerrado',
        expectedCloseBracket: '"[" no estaba cerrado',
        expectedCloseParen: '"(" no estaba cerrado',
        expectedColon: 'Se esperaba ":"',
        expectedComplexNumberLiteral: 'Nmero complejo literal esperado para la concordancia de patrones',
        expectedDecoratorExpr: 'Forma de expresin no compatible con Decorator anterior a Python 3.9',
        expectedDecoratorName: 'Nombre esperado del Decorator',
        expectedDecoratorNewline: 'Nueva lnea esperada al final de Decorator',
        expectedDelExpr: 'Expresin esperada despus de "del"',
        expectedElse: 'Se espera "else"',
        expectedEquals: 'Se esperaba "="',
        expectedExceptionClass: 'Clase o objeto de excepcin no vlido',
        expectedExceptionObj: 'Objeto de excepcin esperado, clase de excepcin o None',
        expectedExpr: 'Se esperaba una expresin',
        expectedFunctionAfterAsync: 'Definicin de funcin esperada despus de "async"',
        expectedFunctionName: 'Se esperaba nombre de la funcin luego de "def"',
        expectedIdentifier: 'Identificador esperado',
        expectedImport: 'Se espera "import"',
        expectedImportAlias: 'Smbolo esperado despus de "as"',
        expectedImportSymbols: 'Se esperan uno o ms nombres de smbolos tras la importacin',
        expectedIn: 'Se esperaba "in"',
        expectedInExpr: 'Expresin esperada despus de "in"',
        expectedIndentedBlock: 'Bloque con sangra previsto',
        expectedMemberName: 'Se esperaba un nombre de atributo despus de "."',
        expectedModuleName: 'Nombre de mdulo esperado',
        expectedNameAfterAs: 'Se esperaba un nombre de smbolo despus de "as"',
        expectedNamedParameter: 'El parmetro de palabra clave debe ir despus de "*".',
        expectedNewline: 'Nueva lnea esperada',
        expectedNewlineOrSemicolon: 'Las declaraciones deben ir separadas por nuevas lneas o punto y coma',
        expectedOpenParen: 'Se espera "("',
        expectedParamName: 'Nombre esperado del parmetro',
        expectedPatternExpr: 'Expresin del patrn esperado',
        expectedPatternSubjectExpr: 'Expresin de asunto de patrn esperada',
        expectedPatternValue: 'Expresin de valor de patrn esperada de la forma "a.b"',
        expectedReturnExpr: 'Expresin esperada despus de "return"',
        expectedSliceIndex: 'Expresin de ndice o segmento esperada',
        expectedTypeNotString: 'Se esperaba un tipo pero se ha recibido una cadena literal',
        expectedTypeParameterName: 'Nombre de parmetro de tipo esperado',
        expectedYieldExpr: 'Expresin esperada en la instruccin yield',
        finalClassIsAbstract: 'La clase "{type}" est marcada como final y debe implementar todos los smbolos abstractos',
        finalContext: '"Final" no est permitido en este contexto',
        finalInLoop: 'No se puede asignar una variable "Final" dentro de un bucle',
        finalMethodOverride: 'El mtodo "{name}" no puede anular el mtodo final definido en la clase " {className}"',
        finalNonMethod: 'La funcin "{name}" no se puede marcar @final porque no es un mtodo',
        finalReassigned: '"{name}" se declara como Final y no se puede reasignar',
        finalRedeclaration: '"{name}" se declar anteriormente como Final',
        finalRedeclarationBySubclass: '"{name}" no puede ser redeclarado porque la clase padre "{className}" lo declara como Final',
        finalTooManyArgs: 'Se esperaba un nico argumento de tipo despus de "Final".',
        finalUnassigned: '"{name}" se declara Final, pero no se asigna valor',
        formatStringBrace: 'No se permite una llave de cierre nica dentro del literal de cadena f; usar llave de cierre doble',
        formatStringBytes: 'Los literales de cadena de formato (f-strings) no pueden ser binarios',
        formatStringDebuggingIllegal: 'El especificador de depuracin de cadena F "=" requiere Python 3.8 o posterior',
        formatStringEscape: 'Secuencia de escape (barra diagonal inversa) no permitida en la parte de expresin de f-string anterior a Python 3.12',
        formatStringExpectedConversion: 'Se esperaba un especificador de conversin despus de "!" en f-string',
        formatStringIllegal: 'Los literales de cadena de formato (f-strings) requieren Python 3.6 o posterior',
        formatStringInPattern: 'Cadena de formato no permitida en el patrn',
        formatStringNestedFormatSpecifier: 'Expresiones anidadas demasiado profundamente dentro del especificador de cadena de formato',
        formatStringNestedQuote: 'Las cadenas anidadas dentro de una cadena f no pueden usar el mismo carcter de comillas que la cadena f anterior a Python 3.12',
        formatStringUnicode: 'Los literales de cadena de formato (cadenas f) no pueden ser unicode',
        formatStringUnterminated: 'Expresin sin terminar en f-string; se esperaba "}"',
        functionDecoratorTypeUnknown: 'Un decorator de funcin no tipificado oculta el tipo de funcin; ignorar el decorator',
        functionInConditionalExpression: 'La expresin condicional hace referencia a una funcin que siempre se evala como True',
        functionTypeParametersIllegal: 'La sintaxis del parmetro de tipo de funcin requiere Python 3.12 o posterior',
        futureImportLocationNotAllowed: 'Las importaciones desde __future__ deben estar al principio del fichero',
        generatorAsyncReturnType: 'El tipo de retorno de la funcin generadora async debe ser compatible con "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: 'Las expresiones del generador deben ir entre parntesis si no son el nico argumento',
        generatorSyncReturnType: 'El tipo de retorno de la funcin generadora debe ser compatible con "Generator[{yieldType}, Any, Any]"',
        genericBaseClassNotAllowed: 'La clase base "Generic" no se puede usar con la sintaxis de parmetro de tipo',
        genericClassAssigned: 'No se puede asignar un tipo de clase genrico',
        genericClassDeleted: 'No se puede eliminar el tipo de clase genrica',
        genericInstanceVariableAccess: 'El acceso a la variable de instancia genrica a travs de la clase es ambiguo',
        genericNotAllowed: '"Generic" no es vlido en este contexto',
        genericTypeAliasBoundTypeVar: 'Los alias de tipo genrico dentro de una clase no pueden utilizar variables de tipo vinculadas {names}.',
        genericTypeArgMissing: '"Generic" requiere al menos un argumento de tipo',
        genericTypeArgTypeVar: 'El argumento de tipo para "Generic" debe ser una variable de tipo',
        genericTypeArgUnique: 'Los argumentos de tipo para "Generic" deben ser nicos',
        globalReassignment: '"{name}" se asigna antes de la declaracin global',
        globalRedefinition: '"{name}" ya ha sido declarado global',
        implicitStringConcat: 'No se permite la concatenacin implcita de cadenas',
        importCycleDetected: 'Ciclo detectado en la cadena de importacin',
        importDepthExceeded: 'La profundidad de la cadena de importacin super {depth}',
        importResolveFailure: 'No se ha podido resolver la importacin "{importName}".',
        importSourceResolveFailure: 'La importacin "{importName}" no se ha podido resolver desde el origen',
        importSymbolUnknown: '"{name}" es un smbolo de importacin desconocido',
        incompatibleMethodOverride: 'El mtodo "{name}" sobrescribe la clase "{className}" de forma incompatible',
        inconsistentIndent: 'La cantidad sin sangra no coincide con la sangra anterior',
        inconsistentTabs: 'Uso incoherente de tabuladores y espacios en la sangra',
        initMethodSelfParamTypeVar: 'La anotacin de tipo para el parmetro "self" del mtodo "__init__" no puede contener variables de tipo con mbito de clase',
        initMustReturnNone: 'El tipo de retorno de "__init__" debe ser None',
        initSubclassCallFailed: 'Argumentos de palabra clave incorrectos para el mtodo __init_subclass__',
        initSubclassClsParam: '__init_subclass__ debe tomar un parmetro "cls"',
        initVarNotAllowed: '"InitVar" no se permite en este contexto',
        instanceMethodSelfParam: 'Los mtodos de instancia deben tomar un parmetro "self"',
        instanceVarOverridesClassVar: 'La variable de instancia "{name}" invalida la variable de clase del mismo nombre en la clase "{className}"',
        instantiateAbstract: 'No se puede instanciar la clase abstracta "{type}"',
        instantiateProtocol: 'No se puede crear una instancia de la clase Protocol "{type}"',
        internalBindError: 'Se ha producido un error interno al vincular el archivo "{file}": {message}',
        internalParseError: 'Se ha producido un error interno al procesar el archivo "{file}": {message}',
        internalTypeCheckingError: 'Se ha producido un error interno al comprobar el tipo de archivo "{file}":{message}',
        invalidIdentifierChar: 'Carcter no vlido en el identificador',
        invalidStubStatement: 'La declaracin no tiene sentido dentro de un archivo de tipo stub',
        invalidTokenChars: 'Carcter "{text}" no vlido en el token',
        isInstanceInvalidType: 'El segundo argumento de "isinstance" debe ser una clase o tuple de clases',
        isSubclassInvalidType: 'El segundo argumento de "issubclass" debe ser una clase o tuple de clases',
        keyValueInSet: 'No se permiten pares de clave/valor dentro de un set',
        keywordArgInTypeArgument: 'No se pueden usar argumentos de palabra clave en listas de argumentos de tipo',
        keywordArgShortcutIllegal: 'El acceso directo del argumento de palabra clave requiere Python3.14 o posterior',
        keywordOnlyAfterArgs: 'No se permite el separador de argumentos por palabra clave despus del parmetro "*".',
        keywordParameterMissing: 'Uno o varios parmetros de palabra clave deben seguir el parmetro "*"',
        keywordSubscriptIllegal: 'No se admiten argumentos de palabra clave dentro de subndices',
        lambdaReturnTypePartiallyUnknown: 'El tipo de retorno de la lambda "{returnType}" es parcialmente desconocido.',
        lambdaReturnTypeUnknown: 'Se desconoce el tipo de retorno de la lambda',
        listAssignmentMismatch: 'La expresin con el tipo "{type}" no puede asignarse a la lista de destino',
        listInAnnotation: 'No se permite la expresin de List en la expresin de tipo',
        literalEmptyArgs: 'Se esperaban uno o varios argumentos de tipo despus de "Literal"',
        literalNamedUnicodeEscape: 'No se admiten secuencias de escape Unicode con nombre en las anotaciones de cadena de "Literales".',
        literalNotAllowed: '"Literal" no se puede usar en este contexto sin un argumento de tipo',
        literalNotCallable: 'El tipo Literal no puede instanciarse',
        literalUnsupportedType: 'Los argumentos de tipo para "Literal" deben ser None, un valor literal (int, bool, str, o bytes), o un valor enum',
        matchIncompatible: 'Las declaraciones de Match requieren Python 3.10 o posterior',
        matchIsNotExhaustive: 'Los casos dentro de la declaracin de match no tratan exhaustivamente todos los valores',
        maxParseDepthExceeded: 'Se ha superado la profundidad mxima de anlisis; divida la expresin en subexpresiones ms pequeas.',
        memberAccess: 'No se puede tener acceso al atributo "{name}" para la clase "{type}"',
        memberDelete: 'No se puede eliminar el atributo "{name}" de la clase "{type}"',
        memberSet: 'No se puede asignar al atributo "{name}" para la clase "{type}"',
        metaclassConflict: 'La metaclase de una clase derivada debe ser una subclase de las metaclases de todas sus clases base',
        metaclassDuplicate: 'Solo se puede proporcionar una metaclase',
        metaclassIsGeneric: 'La metaclase no puede ser genrica',
        methodNotDefined: 'Mtodo "{name}" no definido',
        methodNotDefinedOnType: 'Mtodo "{name}" no definido en el tipo "{type}"',
        methodOrdering: 'No se puede crear una ordenacin coherente de los mtodos',
        methodOverridden: '"{name}" invalida el mtodo del mismo nombre en la clase "{className}" con el tipo incompatible "{type}"',
        methodReturnsNonObject: 'El mtodo "{name}" no devuelve un objeto',
        missingSuperCall: 'El mtodo "{methodName}" no llama al mtodo del mismo nombre en la clase principal.',
        mixingBytesAndStr: 'No se pueden concatenar los valores de bytes y str',
        moduleAsType: 'El mdulo no se puede usar como tipo.',
        moduleNotCallable: 'No se puede llamar al mdulo',
        moduleUnknownMember: '"{memberName}" no es un atributo conocido del mdulo "{moduleName}"',
        namedExceptAfterCatchAll: 'Una clusula except con nombre no puede aparecer despus de la clusula catch-all except',
        namedParamAfterParamSpecArgs: 'El parmetro de palabra clave "{name}" no puede aparecer en la firma despus del parmetro ParamSpec args',
        namedTupleEmptyName: 'Los nombres de una tuple con nombre no pueden estar vacos',
        namedTupleEntryRedeclared: 'No se puede invalidar "{name}" porque la clase primaria "{className}" es una tuple con nombre',
        namedTupleFirstArg: 'Nombre de clase de tuple como primer argumento',
        namedTupleMultipleInheritance: 'No se admite la herencia mltiple con NamedTuple',
        namedTupleNameKeyword: 'Los nombres de campo no pueden ser una palabra clave',
        namedTupleNameType: 'tuple de dos entradas esperada que especifica el nombre y el tipo de entrada',
        namedTupleNameUnique: 'Los nombres dentro de una tuple con nombre deben ser nicos',
        namedTupleNoTypes: '"namedtuple" no proporciona tipos para las entradas de tupla; utilice en su lugar "NamedTuple".',
        namedTupleSecondArg: 'list de entradas de tuple con nombre esperada como segundo argumento',
        newClsParam: '__new__ debe tomar un parmetro "cls"',
        newTypeAnyOrUnknown: 'El segundo argumento de NewType debe ser una clase conocida, no Any ni Unknown',
        newTypeBadName: 'El primer argumento de NewType debe ser una cadena literal',
        newTypeLiteral: 'NewType no se puede usar con el tipo Literal',
        newTypeNameMismatch: 'NewType debe asignarse a una variable con el mismo nombre',
        newTypeNotAClass: 'Clase esperada como segundo argumento de NewType',
        newTypeParamCount: 'NewType requiere dos argumentos posicionales',
        newTypeProtocolClass: 'NewType no se puede usar con un tipo estructural (Protocol o clase TypedDict)',
        noOverload: 'Ninguna sobrecarga para "{name}" coincide con los argumentos proporcionados',
        noReturnContainsReturn: 'La funcin con tipo de return declarado "NoReturn" no puede incluir una sentencia return',
        noReturnContainsYield: 'La funcin con tipo de retorno declarado "NoReturn" no puede incluir una instruccin yield',
        noReturnReturnsNone: 'La funcin con el tipo de valor devuelto declarado "NoReturn" no puede devolver "None"',
        nonDefaultAfterDefault: 'El argumento no predeterminado sigue al argumento predeterminado',
        nonLocalInModule: 'Declaracin Nonlocal no permitida a nivel de mdulo',
        nonLocalNoBinding: 'No se ha encontrado ningn enlace para "{name}" nonlocal.',
        nonLocalReassignment: '"{name}" se asigna antes de la declaracin nonlocal',
        nonLocalRedefinition: '"{name}" ya fue declarado nonlocal',
        noneNotCallable: 'No se puede llamar al objeto de tipo "None"',
        noneNotIterable: 'No se puede utilizar un objeto de tipo "None" como valor iterable',
        noneNotSubscriptable: 'El objeto de tipo "None" no se puede suscribir',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'El operador "{operator}" no es compatible con "None".',
        noneUnknownMember: '"{name}" no es un atributo conocido de "None"',
        notRequiredArgCount: 'Se esperaba un nico argumento de tipo despus de "NotRequired".',
        notRequiredNotInTypedDict: '"NotRequired" no est permitido en este contexto',
        objectNotCallable: 'El objeto de tipo "{type}" no es invocable',
        obscuredClassDeclaration: 'La declaracin de clase "{name}" queda oculta por una declaracin del mismo nombre',
        obscuredFunctionDeclaration: 'La declaracin de funcin "{name}" queda oculta por una declaracin del mismo nombre',
        obscuredMethodDeclaration: 'La declaracin de mtodo "{name}" queda oculta por una declaracin del mismo nombre',
        obscuredParameterDeclaration: 'La declaracin de parmetro "{name}" queda oculta por una declaracin del mismo nombre',
        obscuredTypeAliasDeclaration: 'La declaracin de alias de tipo "{name}" queda oculta por una declaracin del mismo nombre',
        obscuredVariableDeclaration: 'La declaracin "{name}" est oculta por una declaracin del mismo nombre',
        operatorLessOrGreaterDeprecated: 'El operador "<>" no es admitido en Python 3; utilice en su lugar "!=".',
        optionalExtraArgs: 'Se esperaba un argumento de tipo despus de "Optional"',
        orPatternIrrefutable: 'El patrn irrefutable solo se permite como el ltimo subpatrn en un patrn "or".',
        orPatternMissingName: 'Todos los subpatrones de un patrn "or" deben tener los mismos nombres',
        overlappingKeywordArgs: 'El diccionario escrito se superpone con el parmetro de palabra clave: {names}',
        overlappingOverload: 'La sobrecarga {obscured} para "{name}" nunca se utilizar porque sus parmetros se superpone con la sobrecarga {obscuredBy}.',
        overloadAbstractImplMismatch: 'Las sobrecargas deben coincidir con el estado abstracto de la implementacin',
        overloadAbstractMismatch: 'Todos los mtodos sobrecargados deben ser abstractos o no',
        overloadClassMethodInconsistent: 'Las sobrecargas de "{name}" usan @classmethod de forma incoherente',
        overloadFinalInconsistencyImpl: 'La sobrecarga de "{name}" est marcada @final pero la implementacin no',
        overloadFinalInconsistencyNoImpl: 'La sobrecarga {index} para "{name}" est marcada @final pero la sobrecarga 1 no lo est.',
        overloadImplementationMismatch: 'La implementacin de la sobrecarga no es consistente con la firma de la sobrecarga {index}',
        overloadReturnTypeMismatch: 'La sobrecarga {prevIndex} para " {name}" se superpone con la sobrecarga {newIndex} y devuelve un tipo incompatible',
        overloadStaticMethodInconsistent: 'Las sobrecargas de "{name}" usan @staticmethod de forma incoherente',
        overloadWithoutImplementation: '"{name}" est marcado como overload, pero no se proporciona ninguna implementacin.',
        overriddenMethodNotFound: 'El mtodo "{name}" est marcado como override, pero no existe ningn mtodo base con el mismo nombre',
        overrideDecoratorMissing: 'El mtodo "{name}" no est marcado como override, pero est reemplazando un mtodo de la clase "{className}"',
        paramAfterKwargsParam: 'El parmetro no puede seguir el parmetro "**"',
        paramAlreadyAssigned: 'El parmetro "{name}" ya est asignado',
        paramAnnotationMissing: 'Falta la anotacin de tipo para el parmetro "{name}"',
        paramAssignmentMismatch: 'La expresin de tipo "{sourceType}" no se puede asignar al parmetro de tipo "{paramType}"',
        paramNameMissing: 'Ningn parmetro llamado "{name}"',
        paramSpecArgsKwargsDuplicate: 'Ya se han proporcionado los argumentos para ParamSpec "{type}".',
        paramSpecArgsKwargsUsage: 'Los atributos "args" y "kwargs" de ParamSpec deben aparecer ambos dentro de una firma de funcin',
        paramSpecArgsMissing: 'Faltan argumentos para ParamSpec "{type}".',
        paramSpecArgsUsage: 'El atributo "args" de ParamSpec solo es vlido cuando se usa con el parmetro *args.',
        paramSpecAssignedName: 'ParamSpec debe asignarse a una variable llamada "{name} "',
        paramSpecContext: 'ParamSpec no est permitido en este contexto',
        paramSpecDefaultNotTuple: 'Se esperaban puntos suspensivos, una expresin de tuple o ParamSpec para el valor predeterminado de ParamSpec',
        paramSpecFirstArg: 'Se esperaba el nombre de ParamSpec como primer argumento',
        paramSpecKwargsUsage: 'El miembro "kwargs" de ParamSpec solo es vlido cuando se utiliza con el parmetro **kwargs',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" no tiene significado en este contexto',
        paramSpecUnknownArg: 'ParamSpec no admite ms de un argumento',
        paramSpecUnknownMember: '"{name}" no es un atributo conocido de ParamSpec',
        paramSpecUnknownParam: '"{name}" es un parmetro desconocido para ParamSpec',
        paramTypeCovariant: 'La variable de tipo covariante no puede utilizarse en el tipo de parmetro',
        paramTypePartiallyUnknown: 'El tipo de parmetro "{paramName}" es parcialmente desconocido',
        paramTypeUnknown: 'Se desconoce el tipo del parmetro "{paramName}".',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'El patrn nunca coincidir para el tipo de asunto "{type}"',
        positionArgAfterNamedArg: 'El argumento posicional no puede aparecer despus de los argumentos de palabra clave',
        positionOnlyAfterArgs: 'No se permite el separador de parmetros de un solo puesto despus del parmetro "*".',
        positionOnlyAfterKeywordOnly: 'El parmetro "/" debe aparecer antes del parmetro "*".',
        positionOnlyAfterNon: 'Parmetro de un solo puesto no permitido despus del parmetro que no es de solo posicin',
        positionOnlyFirstParam: 'Separador parmetros de solo un puesto no permitido como primer parmetro',
        positionOnlyIncompatible: 'El separador de parmetros de un solo puesto requiere Python 3.8 o posterior',
        privateImportFromPyTypedModule: '"{name}" no se exporta desde el mdulo "{module}"',
        privateUsedOutsideOfClass: '"{name}" es privado y se utiliza fuera de la clase en la que se declara',
        privateUsedOutsideOfModule: '"{name}" es privado y se utiliza fuera del mdulo en el que se declara',
        propertyOverridden: '"{name}" invalida incorrectamente la property del mismo nombre en la clase "{className}"',
        propertyStaticMethod: 'Mtodos estticos no permitidos para los valores de property getter, setter o deleter',
        protectedUsedOutsideOfClass: '"{name}" est protegido y se usa fuera de la clase en la que se declara',
        protocolBaseClass: 'La clase de Protocol "{classType}" no se puede derivar de la clase que no es Protocol "{baseType}"',
        protocolBaseClassWithTypeArgs: 'No se permiten argumentos de tipo con la clase Protocol cuando se usa la sintaxis de parmetro de tipo',
        protocolIllegal: 'El uso de "Protocolo" requiere Python 3.7 o posterior.',
        protocolNotAllowed: '"Protocolo" no puede utilizarse en este contexto',
        protocolTypeArgMustBeTypeParam: 'El argumento de tipo para "Protocol" debe ser un parmetro de tipo',
        protocolUnsafeOverlap: 'La clase se superpone "{name}" de forma no segura y podra producir una coincidencia en tiempo de ejecucin',
        protocolVarianceContravariant: 'La variable de tipo "{variable}" usada en Protocol genrico "{class}" debe ser contravariante',
        protocolVarianceCovariant: 'La variable de tipo "{variable}" usada en Protocol genrico "{class}" debe ser covariante',
        protocolVarianceInvariant: 'La variable de tipo "{variable}" usada en Protocol genrico "{class}" debe ser invariable',
        pyrightCommentInvalidDiagnosticBoolValue: 'La directiva de comentario Pyright debe ir seguida de "=" y un valor de true o false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'La directiva de comentario Pyright debe ir seguida de "=" y un valor de true, false, error, warning, information o none.',
        pyrightCommentMissingDirective: 'El comentario de Pyright debe ir seguido de una directiva (basic o estricta) o de una regla de diagnstico',
        pyrightCommentNotOnOwnLine: 'Los comentarios de Pyright utilizados para controlar los ajustes a nivel de archivo deben aparecer en su propia lnea',
        pyrightCommentUnknownDiagnosticRule: '"{rule}" es una regla de diagnstico desconocida para el comentario pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" es un valor no vlido para el comentario pyright; se espera true, false, error, warning, information o none.',
        pyrightCommentUnknownDirective: '"{directive}" es una directiva desconocida para el comentario pyright; se esperaba "strict" o "basic".',
        readOnlyArgCount: 'Se esperaba un nico argumento de tipo despus de "ReadOnly"',
        readOnlyNotInTypedDict: '"ReadOnly" no est permitido en este contexto',
        recursiveDefinition: 'No se pudo determinar el tipo de "{name}" porque hace referencia a s mismo.',
        relativeImportNotAllowed: 'Las importaciones relativas no pueden utilizarse con la forma "import .a"; utilice en su lugar "from . import a"',
        requiredArgCount: 'Se esperaba un nico argumento de tipo despus de "Required"',
        requiredNotInTypedDict: '"Required" no est permitido en este contexto',
        returnInAsyncGenerator: 'No se permite la instruccin Return con valor en el generador async',
        returnInExceptionGroup: 'No se permite "return" en un bloque "except*"',
        returnMissing: 'La funcin con el tipo de valor devuelto declarado "{returnType}" debe devolver un valor en todas las rutas de acceso del cdigo.',
        returnOutsideFunction: '"return" solo se puede usar dentro de una funcin',
        returnTypeContravariant: 'La variable de tipo contravariante no se puede usar en el tipo de valor devuelto',
        returnTypeMismatch: 'El tipo "{exprType}" no se puede asignar al tipo de valor devuelto "{returnType}"',
        returnTypePartiallyUnknown: 'El tipo de retorno, "{returnType}", es parcialmente desconocido',
        returnTypeUnknown: 'Tipo de retorno desconocido',
        revealLocalsArgs: 'No se esperaba ningn argumento para la llamada "reveal_locals"',
        revealLocalsNone: 'No hay locals en este mbito',
        revealTypeArgs: 'Se esperaba un nico argumento posicional para la llamada "reveal_type"',
        revealTypeExpectedTextArg: 'El argumento "expected_text" de la funcin "reveal_type" debe ser un valor literal str.',
        revealTypeExpectedTextMismatch: 'El tipo de texto no coincide; se esperaba "{expected}" pero se ha recibido "{received}".',
        revealTypeExpectedTypeMismatch: 'Error de coincidencia de tipos; se esperaba "{expected}", pero se recibi "{received}"',
        selfTypeContext: '"Self" no es vlido en este contexto',
        selfTypeMetaclass: '"Self" no se puede usar dentro de una metaclase (una subclase de "type")',
        selfTypeWithTypedSelfOrCls: '"Self" no puede utilizarse en una funcin con un parmetro `self` o `cls` que tenga una anotacin de tipo distinta de "Self".',
        setterGetterTypeMismatch: 'El tipo de valor setter de Property no se puede asignar al tipo devuelto por el valor getter',
        singleOverload: '"{name}" est marcado como sobrecarga, pero faltan sobrecargas adicionales',
        slotsAttributeError: '"{name}" no se especific en __slots__',
        slotsClassVarConflict: '"{name}" entra en conflicto con la variable de instancia declarada en __slots__',
        starPatternInAsPattern: 'El patrn estrella no puede utilizarse con el objetivo "as"',
        starPatternInOrPattern: 'El patrn de estrella no puede unirse a otros patrones',
        starStarWildcardNotAllowed: '** no puede utilizarse con el comodn "_".',
        staticClsSelfParam: 'Los mtodos estticos no deben tomar un parmetro "self" o "cls".',
        stdlibModuleOverridden: '"{path}" est reemplazando el mdulo stdlib "{name}"',
        stringNonAsciiBytes: 'Carcter no ASCII no permitido en el literal de cadena de bytes',
        stringNotSubscriptable: 'La expresin de cadena no puede ir entre comillas en la expresin de tipo; encierre toda la expresin entre comillas.',
        stringUnsupportedEscape: 'Secuencia de escape no admitida en el literal de cadena',
        stringUnterminated: 'La cadena literal no est terminada',
        stubFileMissing: 'Archivo Stub no encontrado para "{importName}"',
        stubUsesGetAttr: 'El archivo stub de tipo est incompleto; "__getattr__" oculta errores de tipo para el mdulo',
        sublistParamsIncompatible: 'Los parmetros de sublista no estn soportados en Python 3.x',
        superCallArgCount: 'No se esperaban ms de dos argumentos para la llamada "super"',
        superCallFirstArg: 'Se esperaba el tipo de clase como primer argumento de la llamada a "super" pero se recibi "{type}"',
        superCallSecondArg: 'El segundo argumento de la llamada a "super" debe ser un objeto o clase que derive de "{type}"',
        superCallZeroArgForm: 'La forma sin argumentos de la llamada "super" slo es vlida dentro de un mtodo',
        superCallZeroArgFormStaticMethod: 'La forma sin argumentos de la llamada "super" no es vlida en un mtodo esttico',
        symbolIsPossiblyUnbound: '"{name}" est posiblemente desvinculado',
        symbolIsUnbound: '"{name}" est sin consolidar',
        symbolIsUndefined: '"{name}" no est definido',
        symbolOverridden: '"{name}" anula el smbolo del mismo nombre en la clase "{className}"',
        ternaryNotAllowed: 'No se permite la expresin de ternario en la expresin de tipo',
        totalOrderingMissingMethod: 'La clase debe definir uno de "__lt__", "__le__", "__gt__", o "__ge__" para utilizar total_ordering',
        trailingCommaInFromImport: 'No se permite la coma final sin parntesis alrededor',
        tryWithoutExcept: 'La instruccin Try debe tener al menos una clusula except o finally',
        tupleAssignmentMismatch: 'La expresin con el tipo "{type}" no se puede asignar a la tuple de destino',
        tupleInAnnotation: 'No se permite la expresin de tuple en la expresin de tipo',
        tupleIndexOutOfRange: 'El ndice {index} est fuera de rango para el tipo {type}.',
        typeAliasIllegalExpressionForm: 'Forma de expresin no vlida para la definicin de alias de tipo',
        typeAliasIsRecursiveDirect: 'El alias de tipo "{name}" no puede usarse a s mismo en su definicin',
        typeAliasNotInModuleOrClass: 'Un TypeAlias solo puede definirse en el mbito de un mdulo o de una clase',
        typeAliasRedeclared: '"{name}" se declara como TypeAlias y solo puede asignarse una vez',
        typeAliasStatementBadScope: 'Una instruccin de type solo se puede usar en el mbito de un mdulo o de una clase',
        typeAliasStatementIllegal: 'La sentencia Type alias requiere Python 3.12 o posterior',
        typeAliasTypeBaseClass: 'Un alias de tipo definido en una instruccin "type" no se puede usar como clase base',
        typeAliasTypeMustBeAssigned: 'TypeAliasType debe asignarse a una variable con el mismo nombre que el alias de tipo',
        typeAliasTypeNameArg: 'El primer argumento de TypeAliasType debe ser un literal de cadena que represente el nombre del alias de tipo',
        typeAliasTypeNameMismatch: 'El nombre del alias de tipo debe coincidir con el nombre de la variable a la que se asigna',
        typeAliasTypeParamInvalid: 'La lista de parmetros de tipo debe ser una tuple que contenga solo TypeVar, TypeVarTuple o ParamSpec.',
        typeAnnotationCall: 'No se permite la expresin de llamada en la expresin de tipo',
        typeAnnotationVariable: 'Variable no permitida en la expresin de tipo',
        typeAnnotationWithCallable: 'El argumento de tipo para "type" debe ser una clase; no se admiten invocables',
        typeArgListExpected: 'ParamSpec esperado, elipsis o lista de tipos',
        typeArgListNotAllowed: 'Expresin de lista no permitida para este argumento de tipo',
        typeArgsExpectingNone: 'No se esperaban argumentos de tipo para la clase "{name}"',
        typeArgsMismatchOne: 'Se esperaba un argumento de tipo pero ha recibido {received}',
        typeArgsMissingForAlias: 'Argumentos de tipo esperados para el alias de tipo genrico "{name}"',
        typeArgsMissingForClass: 'Se esperaban argumentos de tipo para la clase genrica "{name}"',
        typeArgsTooFew: 'Se han proporcionado muy pocos argumentos de tipo para "{name}"; se esperaba {expected} pero se ha recibido {received}.',
        typeArgsTooMany: 'Se proporcionaron demasiados argumentos de tipo para "{name}"; se esperaba {expected}, pero se recibieron {received}',
        typeAssignmentMismatch: 'El tipo "{sourceType}" no se puede asignar al tipo declarado "{destType}"',
        typeAssignmentMismatchWildcard: 'El smbolo de importacin "{name}" tiene el tipo "{sourceType}", que no se puede asignar al tipo declarado "{destType}"',
        typeCallNotAllowed: 'La llamada a type() no debe utilizarse en la expresin de tipo',
        typeCheckOnly: '"{name}" est marcado como @type_check_only y solo se puede usar en anotaciones de tipo',
        typeCommentDeprecated: 'El uso de comentarios de type est obsoleto; utilice en su lugar anotaciones de type.',
        typeExpectedClass: 'Se esperaba la clase pero se recibi "{type}"',
        typeFormArgs: '"TypeForm" acepta un nico argumento posicional',
        typeGuardArgCount: 'Se esperaba un nico argumento de tipo despus de "TypeGuard" o "TypeIs"',
        typeGuardParamCount: 'Las funciones y mtodos de proteccin de tipo definidos por el usuario deben tener al menos un parmetro de entrada',
        typeIsReturnType: 'El tipo de valor devuelto de TypeIs ("{returnType}") no es coherente con el tipo de parmetro de valor ("{type}")',
        typeNotAwaitable: '"{type}" no se awaitable',
        typeNotIntantiable: '"{type}" no puede crear instancias',
        typeNotIterable: '"{type}" no es iterable',
        typeNotSpecializable: 'No se pudo especializar el tipo "{type}"',
        typeNotSubscriptable: 'Objeto de tipo "{type}" no es subscriptible',
        typeNotSupportBinaryOperator: 'El operador "{operator}" no se admite para los tipos "{leftType}" y "{rightType}"',
        typeNotSupportBinaryOperatorBidirectional: 'No se admite el operador "{operator}" para los tipos "{leftType}" y "{rightType}" cuando el tipo esperado es "{expectedType}"',
        typeNotSupportUnaryOperator: 'El operador "{operator}" no se admite para el tipo "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'Operador "{operator}" no admitido para el tipo "{type}" cuando el tipo esperado es "{expectedType}"',
        typeNotUsableWith: 'El objeto de tipo "{type}" no puede utilizarse con "con" porque no implementa {method}.',
        typeParameterBoundNotAllowed: 'No se pueden usar lmites o restricciones con un parmetro de tipo varidico o ParamSpec',
        typeParameterConstraintTuple: 'La restriccin del parmetro de tipo debe ser una tupla de dos o ms tipos',
        typeParameterExistingTypeParameter: 'El parmetro de tipo "{name}" ya est en uso',
        typeParameterNotDeclared: 'El parmetro de tipo "{name}" no est incluido en la lista de parmetros de tipo para "{container}"',
        typeParametersMissing: 'Debe especificarse al menos un parmetro de tipo',
        typePartiallyUnknown: 'El tipo de "{name}" es parcialmente desconocido',
        typeUnknown: 'El tipo de "{name} " es desconocido',
        typeVarAssignedName: 'TypeVar debe asignarse a una variable llamada "{name}"',
        typeVarAssignmentMismatch: 'No se puede asignar el tipo "{type}" a la variable de tipo "{name}"',
        typeVarBoundAndConstrained: 'TypeVar no puede estar ligado y restringido a la vez',
        typeVarBoundGeneric: 'El tipo vinculado TypeVar no puede ser genrico',
        typeVarConstraintGeneric: 'El tipo de restriccin TypeVar no puede ser genrico',
        typeVarDefaultBoundMismatch: 'El tipo predeterminado TypeVar debe ser un subtipo del tipo enlazado.',
        typeVarDefaultConstraintMismatch: 'El tipo predeterminado TypeVar debe ser uno de los tipos restringidos.',
        typeVarDefaultIllegal: 'Los tipos predeterminados de variable de tipo requieren Python 3.13 o posterior',
        typeVarDefaultInvalidTypeVar: 'El parmetro de tipo "{name}" tiene un tipo por defecto que hace referencia a una o ms variables de tipo que estn fuera de mbito.',
        typeVarFirstArg: 'Nombre esperado de TypeVar como primer argumento',
        typeVarInvalidForMemberVariable: 'El tipo de atributo no puede usar una variable de tipo "{name}" con mbito de mtodo local',
        typeVarNoMember: 'TypeVar "{type}" no tiene ningn atributo "{name}"',
        typeVarNotSubscriptable: 'TypeVar "{type}" no es subscribible',
        typeVarNotUsedByOuterScope: 'La variable de tipo "{name}" no tiene ningn significado en este contexto',
        typeVarPossiblyUnsolvable: 'La variable de tipo "{name}" puede quedar sin resolver si el autor de la llamada no proporciona ningn argumento para el parmetro "{param}"',
        typeVarSingleConstraint: 'TypeVar debe tener al menos dos tipos restringidos',
        typeVarTupleConstraints: 'TypeVarTuple no puede tener restricciones de valor',
        typeVarTupleContext: 'TypeVarTuple no est permitido en este contexto',
        typeVarTupleDefaultNotUnpacked: 'El tipo predeterminado TypeVarTuple debe ser una tuple desempaquetada o TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'Se requiere el operador Unpack para el valor TypeVarTuple.',
        typeVarTupleUnknownParam: '"{name}" es un parmetro desconocido para TypeVarTuple',
        typeVarUnknownParam: '"{name}" es un parmetro desconocido para TypeVar',
        typeVarUsedByOuterScope: 'TypeVar "{name}" ya est en uso por un mbito externo',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" solo aparece una vez en la firma de la funcin genrica',
        typeVarVariance: 'TypeVar no puede ser covariante y contravariante',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}" tiene un valor predeterminado y no puede seguir a TypeVarTuple "{variadicName}"',
        typeVarWithoutDefault: '"{name}" no puede aparecer despus de "{other}" en la lista de parmetros de tipo porque no tiene ningn tipo predeterminado',
        typeVarsNotInGenericOrProtocol: 'Generic[] o Protocol[] deben incluir todas las variables de tipo',
        typedDictAccess: 'No se ha podido acceder al elemento en TypedDict',
        typedDictAssignedName: 'TypedDict debe asignarse a una variable denominada "{name}"',
        typedDictBadVar: 'Las clases TypedDict solo pueden contener anotaciones de tipo',
        typedDictBaseClass: 'Todas las clases base de las clases TypedDict deben ser tambin clases TypedDict',
        typedDictBoolParam: 'Se esperaba que el parmetro "{name}" tuviera un valor de True o False.',
        typedDictClosedExtras: 'La clase base "{name}" es un TypedDict closed; los elementos adicionales deben ser de tipo "{type}"',
        typedDictClosedNoExtras: 'La clase base "{name}" es un TypedDict closed; no se permiten elementos adicionales',
        typedDictDelete: 'No se puede eliminar un elemento en TypedDict',
        typedDictEmptyName: 'Los nombres de un TypedDict no pueden estar vacos',
        typedDictEntryName: 'Cadena literal esperada para el nombre de la entrada del diccionario',
        typedDictEntryUnique: 'Los nombres dentro de un diccionario deben ser nicos',
        typedDictExtraArgs: 'No se admiten argumentos TypedDict adicionales',
        typedDictExtraItemsClosed: 'Un TypedDict no puede tener el estado closed si admite elementos adicionales',
        typedDictFieldNotRequiredRedefinition: 'El elemento TypedDict "{name}" no se puede redefinir como NotRequired',
        typedDictFieldReadOnlyRedefinition: 'El elemento TypedDict "{name}" no se puede redefinir como ReadOnly',
        typedDictFieldRequiredRedefinition: 'El elemento TypedDict "{name}" no se puede redefinir como Required',
        typedDictFirstArg: 'Nombre de clase TypedDict esperado como primer argumento',
        typedDictInClassPattern: 'No se permite la clase TypedDict en el patrn de clase',
        typedDictInitsubclassParameter: 'TypedDict no admite __init_subclass__ parmetro "{name}"',
        typedDictNotAllowed: '"TypedDict" no puede utilizarse en este contexto',
        typedDictSecondArgDict: 'Parmetro dict o palabra clave esperado como segundo parmetro',
        typedDictSecondArgDictEntry: 'Entrada de diccionario simple esperada',
        typedDictSet: 'No se pudo asignar el elemento en TypedDict',
        unaccessedClass: 'No se accede a la clase "{name}"',
        unaccessedFunction: 'No se accede a la funcin "{name}',
        unaccessedImport: 'No se accede a la importacin "{name}',
        unaccessedSymbol: 'No se accede a "{name}"',
        unaccessedVariable: 'No se accede a la variable "{name} ".',
        unannotatedFunctionSkipped: 'Se omite el anlisis de la funcin "{name}" porque no est anotada',
        unaryOperationNotAllowed: 'Operador unario no permitido en la expresin de tipo',
        unexpectedAsyncToken: 'Se esperaba que "def", "with" o "for" siguieran a "async".',
        unexpectedExprToken: 'Token inesperado al final de la expresin',
        unexpectedIndent: 'sangSangra inesperadara inesperada',
        unexpectedUnindent: 'No se espera sangra',
        unhashableDictKey: 'La clave del diccionario debe ser hash',
        unhashableSetEntry: 'La entrada del set debe ser hashable',
        uninitializedAbstractVariables: 'Las variables definidas en la clase base abstracta no se inicializan en la clase final "{classType}"',
        uninitializedInstanceVariable: 'La variable de instancia "{name}" no est inicializada en el cuerpo de la clase o en el mtodo __init__.',
        unionForwardReferenceNotAllowed: 'Union syntax cannot be used with string operand; use quotes around entire expression',
        unionSyntaxIllegal: 'La sintaxis alternativa para las uniones requiere Python 3.10 o posterior.',
        unionTypeArgCount: 'Union requiere dos o ms argumentos de tipo',
        unionUnpackedTuple: 'La Union no puede incluir una tuple desempaquetada',
        unionUnpackedTypeVarTuple: 'La Union no puede incluir un TypeVarTuple desempaquetado',
        unnecessaryCast: 'Llamada "cast" innecesaria; el tipo ya es "{type}"',
        unnecessaryIsInstanceAlways: 'Llamada isinstance innecesaria; "{testType}" es siempre una instancia de "{classType}"',
        unnecessaryIsInstanceNever: 'Llamada isinstance innecesaria; "{testType}" es nunca una instancia de "{classType}"',
        unnecessaryIsSubclassAlways: 'Llamada de issubclass innecesaria; "{testType}" siempre es una subclase de "{classType}"',
        unnecessaryIsSubclassNever: 'Llamada de issubclass innecesaria; "{testType}" nunca es una subclase de "{classType}"',
        unnecessaryPyrightIgnore: 'Comentario "# pyright: ignore" innecesario',
        unnecessaryPyrightIgnoreRule: 'Regla innecesaria "# pyright: ignore": "{name}"',
        unnecessaryTypeIgnore: 'Comentario "# type: ignore" innecesario',
        unpackArgCount: 'Se esperaba un nico argumento de tipo despus de "Unpack"',
        unpackExpectedTypeVarTuple: 'Se esperaba TypeVarTuple o tuple como argumento de tipo para Unpack',
        unpackExpectedTypedDict: 'Se esperaba un argumento de tipo TypedDict para Unpack',
        unpackIllegalInComprehension: 'Operacin de desempaquetado no permitida en la comprensin',
        unpackInAnnotation: 'No se permite el operador desempaquetado en la expresin de tipo',
        unpackInDict: 'Operacin de desempaquetado no permitida en diccionarios',
        unpackInSet: 'No se permite el operador Unpack dentro de un set',
        unpackNotAllowed: 'Unpack no est permitido en este contexto',
        unpackOperatorNotAllowed: 'La operacin de desempaquetado no est permitida en este contexto',
        unpackTuplesIllegal: 'Operacin de desempaquetado no permitida en tuplas anteriores a Python 3.8',
        unpackedArgInTypeArgument: 'No se pueden usar argumentos sin empaquetar en este contexto',
        unpackedArgWithVariadicParam: 'No se puede usar un argumento desempaquetado para el parmetro TypeVarTuple',
        unpackedDictArgumentNotMapping: 'La expresin del argumento despus de ** debe ser un mapeo con un tipo de clave "str".',
        unpackedDictSubscriptIllegal: 'El operador de desempaquetado del diccionario en el subndice no est permitido',
        unpackedSubscriptIllegal: 'El operador de desempaquetado en el subndice requiere Python 3.11 o posterior.',
        unpackedTypeVarTupleExpected: 'Se espera un TypeVarTuple desempaquetado; use Unpack[{name1}] o *{name2}',
        unpackedTypedDictArgument: 'No se puede emparejar el argumento TypedDict desempaquetado con los parmetros',
        unreachableCode: 'El cdigo es inalcanzable',
        unreachableCodeType: 'El anlisis de tipos indica que no se puede acceder al cdigo',
        unreachableExcept: 'La clusula Excepto es inalcanzable porque la excepcin ya est administrada',
        unsupportedDunderAllOperation: 'No se admite la operacin en "__all__", por lo que la lista de smbolos exportada puede ser incorrecta.',
        unusedCallResult: 'El resultado de la expresin de llamada es de tipo "{type}" y no se usa; asignar a la variable "_" si esto es intencionado',
        unusedCoroutine: 'El resultado de la llamada a una funcin async no se utiliza; utilice "await" o asigne el resultado a una variable.',
        unusedExpression: 'El valor de expresin no se usa',
        varAnnotationIllegal: 'Las anotaciones de type para variables requieren Python 3.6 o posterior; utilice el comentario de tipo para la compatibilidad con versiones anteriores.',
        variableFinalOverride: 'La variable "{name}" est marcada como Final y anula la variable no Final del mismo nombre en la clase "{className}".',
        variadicTypeArgsTooMany: 'La lista de argumentos de tipo puede tener como mximo una TypeVarTuple o tuple desempaquetada',
        variadicTypeParamTooManyAlias: 'Los alias de tipo pueden tener como mximo un parmetro de tipo TypeVarTuple, pero reciben varios ({names})',
        variadicTypeParamTooManyClass: 'La clase genrica puede tener como mximo un parmetro de tipo TypeVarTuple pero recibi mltiples ({names})',
        walrusIllegal: 'El operador ":=" requiere Python 3.8 o posterior',
        walrusNotAllowed: 'El operador ":=" no est permitido en este contexto sin parntesis alrededor',
        wildcardInFunction: 'No se permite la importacin de comodines dentro de una clase o funcin',
        wildcardLibraryImport: 'No se permite la importacin de caracteres comodn desde una biblioteca',
        wildcardPatternTypePartiallyUnknown: 'El tipo capturado por el patrn comodn es parcialmente desconocido',
        wildcardPatternTypeUnknown: 'Se desconoce el tipo capturado por el patrn de caracteres comodn',
        yieldFromIllegal: 'El uso de "yield from" requiere Python 3.3 o posterior.',
        yieldFromOutsideAsync: '"yield from" no permitido en una funcin async',
        yieldOutsideFunction: '"yield" no se permite fuera de una funcin o lambda',
        yieldWithinComprehension: '"yield" no est permitido dentro de una comprensin de lista',
        zeroCaseStatementsFound: 'La instruccin Match debe incluir al menos una instruccin case',
        zeroLengthTupleNotAllowed: 'La tuple de longitud cero no est permitida en este contexto'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'El formulario especial "Annotated" no se puede usar con comprobaciones de instancia y clase',
        argParam: 'El argumento corresponde al parmetro "{paramName}"',
        argParamFunction: 'El argumento corresponde al parmetro "{paramName}" en la funcin "{functionName}"',
        argsParamMissing: 'El parmetro "*{paramName}" no tiene ningn parmetro correspondiente',
        argsPositionOnly: 'Error de coincidencia del parmetro de solo posicin; se esperaba {expected}, pero se recibieron {received}',
        argumentType: 'El tipo de argumento es "{type}"',
        argumentTypes: 'Tipos de argumento: ({types})',
        assignToNone: 'El tipo no se puede asignar a "None"',
        asyncHelp: 'Quera decir "async with"?',
        baseClassIncompatible: 'La clase base "{baseClass}" no es compatible con el tipo "{type}"',
        baseClassIncompatibleSubclass: 'La clase base "{baseClass}" deriva de "{subclass}", que no es compatible con el tipo "{type}"',
        baseClassOverriddenType: 'La clase base "{baseClass}" proporciona el tipo "{type}", que se sobrescribe',
        baseClassOverridesType: 'Invalidaciones de clase base "{baseClass}" con el tipo "{type}"',
        bytesTypePromotions: 'Establezca disableBytesTypePromotions en false para activar el comportamiento de promocin de tipos para "bytearray" y "memoryview".',
        conditionalRequiresBool: 'El mtodo __bool__ para el tipo "{operandType}" devuelve el tipo "{boolReturnType}" en lugar de "bool"',
        dataClassFieldLocation: 'en declaracin de campo',
        dataClassFrozen: '"{name}" est congelado',
        dataProtocolUnsupported: '"{name}" es un protocolo de datos',
        descriptorAccessBindingFailed: 'No se pudo enlazar el mtodo "{name}" para la clase de descriptor "{className}"',
        descriptorAccessCallFailed: 'No se pudo llamar al mtodo "{name}" para la clase de descriptor "{className}"',
        finalMethod: 'Final method',
        functionParamDefaultMissing: 'Falta el argumento predeterminado en el parmetro "{name}"',
        functionParamName: 'Nombre de parmetro no coincidente: "{destName}" frente a "{srcName}"',
        functionParamPositionOnly: 'Error de coincidencia del parmetro de solo posicin; el parmetro "{name}" no es de solo posicin',
        functionReturnTypeMismatch: 'El tipo de valor devuelto de la funcin "{sourceType}" no es compatible con el tipo "{destType}"',
        functionTooFewParams: 'La funcin acepta muy pocos parmetros posicionales; esperado {expected} pero recibido {received}',
        functionTooManyParams: 'La funcin acepta demasiados parmetros posicionales; esperado {expected} pero recibido {received}',
        genericClassNotAllowed: 'Tipo genrico con argumentos de tipo no permitidos para comprobaciones de instancia o clase',
        incompatibleDeleter: 'El mtodo de deleter de property no es compatible',
        incompatibleGetter: 'El mtodo getter de property no es compatible',
        incompatibleSetter: 'El mtodo setter de la property no es compatible',
        initMethodLocation: 'El mtodo __init__ se define en la clase "{type}"',
        initMethodSignature: 'La firma de __init__ es "{type}"',
        initSubclassLocation: 'El mtodo __init_subclass__ se define en la clase "{name}"',
        invariantSuggestionDict: 'Considere cambiar de "dict" a " Mapping" que es covariante en el tipo de valor',
        invariantSuggestionList: 'Considere la posibilidad de cambiar de "lista" a "Sequence" que es covariante',
        invariantSuggestionSet: 'Considere la posibilidad de cambiar de "set" a "Container" que es covariante',
        isinstanceClassNotSupported: '"{type}" no se admite para las comprobaciones de instancia y clase',
        keyNotRequired: '"{name}" no es una clave necesaria en "{type}", por lo que el acceso puede dar lugar a una excepcin en tiempo de ejecucin',
        keyReadOnly: '"{name}" es una clave de solo lectura en "{type}"',
        keyRequiredDeleted: '"{name}" es una clave necesaria y no se puede eliminar',
        keyUndefined: '"{name}" no es una clave definida en "{type}"',
        kwargsParamMissing: 'El parmetro "**{paramName}" no tiene ningn parmetro correspondiente.',
        listAssignmentMismatch: 'El tipo "{type}" es incompatible con la lista de objetivos',
        literalAssignmentMismatch: '"{sourceType}" no se puede asignar al tipo "{destType}"',
        matchIsNotExhaustiveHint: 'Si no se pretende un tratamiento exhaustivo, agregue "case _: pass"',
        matchIsNotExhaustiveType: 'Tipo no manejado: "{type}"',
        memberAssignment: 'La expresin de tipo "{type}" no se puede asignar al atributo "{name}" de la clase "{classType}"',
        memberIsAbstract: '"{type}. {name}" no est implementado',
        memberIsAbstractMore: 'y {count} ms...',
        memberIsClassVarInProtocol: '"{name}" se define como ClassVar en el protocolo',
        memberIsInitVar: '"{name}" es un campo init-only',
        memberIsInvariant: '"{name}" es invariable porque es mutable',
        memberIsNotClassVarInClass: '"{name}" debe definirse como ClassVar para que sea compatible con el protocolo',
        memberIsNotClassVarInProtocol: '"{name}" no est definido como ClassVar en el protocolo',
        memberIsNotReadOnlyInProtocol: '"{name}" no es de solo lectura en el protocolo',
        memberIsReadOnlyInProtocol: '"{name}" es de solo lectura en el protocolo',
        memberIsWritableInProtocol: '"{name}" se puede escribir en el protocolo',
        memberSetClassVar: 'El atributo "{name}" no se puede asignar a travs de una instancia de clase porque es un ClassVar.',
        memberTypeMismatch: '"{name}" es un tipo incompatible',
        memberUnknown: 'Atributo "{name}" desconocido',
        metaclassConflict: 'La metaclase "{metaclass1}" entra en conflicto con "{metaclass2}"',
        missingDeleter: 'Falta el mtodo de deleter de property',
        missingGetter: 'Falta el mtodo getter de la property',
        missingSetter: 'Falta el mtodo setter de property',
        namedParamMissingInDest: 'Parmetro adicional "{name}"',
        namedParamMissingInSource: 'Falta el parmetro de palabra clave "{name}"',
        namedParamTypeMismatch: 'El parmetro de palabra clave "{name}" de tipo "{sourceType}" no es compatible con el tipo "{destType}"',
        namedTupleNotAllowed: 'No se puede usar NamedTuple para comprobaciones de instancia o clase',
        newMethodLocation: 'El mtodo __new__ est definido en la clase "{type}"',
        newMethodSignature: 'La firma de __new__ es "{type}"',
        newTypeClassNotAllowed: 'La clase creada con NewType no se puede usar con comprobaciones de instancia y clase',
        noOverloadAssignable: 'Ninguna funcin sobrecargada coincide con el tipo "{type}"',
        noneNotAllowed: 'No se puede usar None para comprobaciones de instancia o clase',
        orPatternMissingName: 'Nombres que faltan: {name}',
        overloadIndex: 'La sobrecarga {index} es la coincidencia ms cercana',
        overloadNotAssignable: 'Una o ms sobrecargas de "{name}" no es asignable',
        overloadSignature: 'Aqu se define la firma de la sobrecarga',
        overriddenMethod: 'Mtodo reemplazado',
        overriddenSymbol: 'Smbolo anulado',
        overrideInvariantMismatch: 'El tipo de invalidacin {overrideType} no es el mismo que el tipo bsico {baseType}',
        overrideIsInvariant: 'La variable es mutable, por lo que su tipo es invariable',
        overrideNoOverloadMatches: 'Ninguna firma de sobrecarga en anulacin es compatible con el mtodo base',
        overrideNotClassMethod: 'El mtodo base se declara como classmethod pero el Reemplazar no',
        overrideNotInstanceMethod: 'El mtodo base se declara como mtodo de instancia, pero la invalidacin no',
        overrideNotStaticMethod: 'El mtodo base se declara como staticmethod pero el reemplazo no',
        overrideOverloadNoMatch: 'La invalidacin no controla todas las sobrecargas del mtodo base',
        overrideOverloadOrder: 'Las sobrecargas para el mtodo de anulacin deben estar en el mismo orden que el mtodo base',
        overrideParamKeywordNoDefault: 'El parmetro de palabra clave "{name}" no coincide: el parmetro base tiene el valor de argumento predeterminado, el parmetro de invalidacin no',
        overrideParamKeywordType: 'El parmetro de palabra clave "{name}" no coincide: el parmetro base es de tipo "{baseType}", el parmetro de invalidacin es de tipo "{overrideType}"',
        overrideParamName: 'El nombre del parmetro {index} no coincide: el parmetro base se denomina "{baseName}", el parmetro de invalidacin se denomina "{overrideName}"',
        overrideParamNameExtra: 'Falta el parmetro "{name}" en la base',
        overrideParamNameMissing: 'Falta el parmetro "{name}" en la invalidacin',
        overrideParamNamePositionOnly: 'El parmetro {index} no coincide: el parmetro base "{baseName}" es un parmetro de palabra clave, el parmetro de invalidacin es de solo posicin',
        overrideParamNoDefault: 'El parmetro {index} no coincide: el parmetro base tiene un valor de argumento predeterminado, el parmetro de invalidacin no',
        overrideParamType: 'El parmetro {index} no coincide: el parmetro base es de tipo "{baseType}", el parmetro de invalidacin es de tipo "{overrideType}"',
        overridePositionalParamCount: 'El recuento de parmetros posicionales no coincide; el mtodo base tiene {baseCount}, pero la invalidacin tiene {overrideCount}',
        overrideReturnType: 'Error de tipo de retorno: el mtodo base devuelve el tipo "{baseType}", el reemplazo devuelve el tipo "{overrideType}".',
        overrideType: 'La clase base define el tipo como "{type}"',
        paramAssignment: 'El parmetro {index}: el tipo "{sourceType}" no es compatible con el tipo "{destType}"',
        paramSpecMissingInOverride: 'Faltan parmetros ParamSpec en el mtodo de invalidacin',
        paramType: 'El tipo de parmetro es "{paramType}"',
        privateImportFromPyTypedSource: 'Importar desde "{module}" en su lugar',
        propertyAccessFromProtocolClass: 'No se puede tener acceso a una propiedad definida dentro de una clase de protocolo como variable de clase',
        propertyMethodIncompatible: 'El mtodo de property "{name}" no es compatible',
        propertyMethodMissing: 'Falta el mtodo de property "{name}" en la invalidacin',
        propertyMissingDeleter: 'Property "{name}" no tiene un supresor deleter',
        propertyMissingSetter: 'Property "{name}" no tiene el valor setter definido',
        protocolIncompatible: '"{sourceType}" no es compatible con el protocolo "{destType}"',
        protocolMemberMissing: '"{name}" no est presente.',
        protocolRequiresRuntimeCheckable: 'La clase de Protocol debe ser @runtime_checkable para usarse con comprobaciones de instancia y clase',
        protocolSourceIsNotConcrete: '"{sourceType}" no es un tipo de clase concreto y no se puede asignar al tipo "{destType}"',
        protocolUnsafeOverlap: 'Los atributos de "{name}" tienen los mismos nombres que el protocolo',
        pyrightCommentIgnoreTip: 'Utilice "# pyright: ignore[<diagnostic rules>]" para suprimir el diagnstico de una sola lnea',
        readOnlyAttribute: 'El atributo "{name}" es de solo lectura',
        seeClassDeclaration: 'Ver declaracin de clase',
        seeDeclaration: 'Ver declaracin',
        seeFunctionDeclaration: 'Ver declaracin de funcin',
        seeMethodDeclaration: 'Consulte la declaracin del mtodoa',
        seeParameterDeclaration: 'Declaracin de parmetro',
        seeTypeAliasDeclaration: 'Vase la declaracin de alias de tipo',
        seeVariableDeclaration: 'declaracin de variable out',
        tupleAssignmentMismatch: 'El tipo "{type}" no es compatible con la tuple de destino',
        tupleEntryTypeMismatch: 'La entrada {entry} de la tuple es de tipo incorrecto',
        tupleSizeIndeterminateSrc: 'El tamao de la tuple no coincide; se esperaba {expected} pero se recibi uno indeterminado',
        tupleSizeIndeterminateSrcDest: 'El tamao de la tuple no coincide; se esperaba {expected} o ms, pero se recibi uno indeterminado',
        tupleSizeMismatch: 'El tamao de la tuple no coincide; se esperaba {expected} pero se recibi {received}',
        tupleSizeMismatchIndeterminateDest: 'El tamao de la tuple no coincide; se esperaba {expected} o ms, pero se recibi {received}',
        typeAliasInstanceCheck: 'El alias de tipo creado con la instruccin "type" no se puede usar con comprobaciones de instancia y clase',
        typeAssignmentMismatch: 'El tipo "{sourceType}" no se puede asignar al tipo "{destType}"',
        typeBound: 'El tipo "{sourceType}" no se puede asignar al lmite superior "{destType}" para la variable de tipo "{name}"',
        typeConstrainedTypeVar: 'El tipo "{type}" no se puede asignar a la variable de tipo restringido "{name}"',
        typeIncompatible: '"{sourceType}" no se puede asignar a "{destType}"',
        typeNotClass: '"{type}" no es una clase',
        typeNotStringLiteral: '"{type}" no es un literal de cadena',
        typeOfSymbol: 'El tipo de "{name}" es "{type}"',
        typeParamSpec: 'El tipo "{type}" no es compatible con ParamSpec "{name}"',
        typeUnsupported: 'El tipo "{type}" no es compatible',
        typeVarDefaultOutOfScope: 'La variable de tipo "{name} " no est en el mbito de aplicacin',
        typeVarIsContravariant: 'El parmetro de tipo "{name}" es contravariante, pero "{sourceType}" no es un supertipo de "{destType}"',
        typeVarIsCovariant: 'El parmetro de tipo "{name}" es covariante, pero "{sourceType}" no es un subtipo de "{destType}"',
        typeVarIsInvariant: 'El parmetro de tipo "{name}" es invariable, pero "{sourceType}" no es el mismo que "{destType}"',
        typeVarNotAllowed: 'TypeVar no se permite para comprobaciones de instancia o clase',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple no se puede enlazar a una tuple de longitud desconocida',
        typeVarUnnecessarySuggestion: 'Usar {type} en su lugar',
        typeVarUnsolvableRemedy: 'Proporciona una sobrecarga que especifica el tipo de retorno cuando no se proporciona el argumento',
        typeVarsMissing: 'Faltan variables de tipo: {names}',
        typedDictBaseClass: 'La clase {type} no es un TypedDict',
        typedDictClassNotAllowed: 'No se permite la clase TypedDict para comprobaciones de instancia o clase',
        typedDictClosedExtraNotAllowed: 'No se puede agregar el elemento "{name}"',
        typedDictClosedExtraTypeMismatch: 'No se puede agregar el elemento "{name}" con el tipo "{type}"',
        typedDictClosedFieldNotRequired: 'No se puede agregar el elemento "{name}" porque debe ser NotRequired.',
        typedDictExtraFieldNotAllowed: '"{name}" no est presente en "{type}"',
        typedDictExtraFieldTypeMismatch: 'El tipo de "{name}" no es compatible con el tipo de "extra_items" en "{type}"',
        typedDictFieldMissing: '"{name}" falta en "{type}"',
        typedDictFieldNotReadOnly: '"{name}" no es de solo lectura en "{type}"',
        typedDictFieldNotRequired: '"{name}" no es obligatorio en "{type}"',
        typedDictFieldRequired: '"{name}" es obligatorio en "{type}"',
        typedDictFieldTypeMismatch: 'El tipo "{type}" no se puede asignar al elemento "{name}"',
        typedDictFieldUndefined: '"{name}" es un elemento no definido en el tipo "{type}"',
        typedDictFinalMismatch: '"{sourceType}" no es compatible con "{destType}" debido a una discrepancia @final',
        typedDictKeyAccess: 'Utilizar ["{name}"] para hacer referencia al elemento en TypedDict',
        typedDictNotAllowed: 'No se puede usar TypedDict para comprobaciones de instancia o clase',
        unhashableType: 'El tipo "{type}" no admite hash',
        uninitializedAbstractVariable: 'La variable de instancia "{name}" est definida en la clase base abstracta "{classType} " pero no inicializada.',
        unreachableExcept: '"{exceptionType}" es una subclase de "{parentType}"',
        useDictInstead: 'Usar Dict[T1, T2] para indicar un tipo de diccionario',
        useListInstead: 'Usar List[T] para indicar un tipo de list o Union[T1, T2] para indicar un tipo de union',
        useTupleInstead: 'Utilice tuple[T1, ..., Tn] para indicar un tipo de tuple o Union[T1, T2] para indicar un tipo de union.',
        useTypeInstead: 'Utilice Type[T] en su lugar',
        varianceMismatchForClass: 'La varianza del argumento de tipo "{typeVarName}" no es compatible con la clase base "{className}"',
        varianceMismatchForTypeAlias: 'La varianza del argumento de tipo "{typeVarName}" no es compatible con "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'La enumeracin de los archivos de origen del rea de trabajo est tardando mucho tiempo. Considere la posibilidad de abrir una subcarpeta en su lugar. [Ms informacin](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  18154: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Crer un Stub de type',
        createTypeStubFor: 'Crer un Stub de type pour {moduleName}',
        executingCommand: 'Excution de la commande',
        filesToAnalyzeCount: '{count}fichiers  analyser',
        filesToAnalyzeOne: '1 fichier  analyser',
        findingReferences: 'Recherche de rfrences',
        organizeImports: 'Organiser les importations',
        renameShadowedFile: 'Renommez "{oldFile}" en "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Importation automatique',
        indexValueDetail: 'Valeur de l\'indice'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Dsol, nous navons pas pu appeler la mthode {method}, car elle est abstraite et non implmente',
        annotatedMetadataInconsistent: 'Le type de mtadonnes annot {metadataType} nest pas compatible avec le type {type}',
        annotatedParamCountMismatch: 'Non-concordance du nombre d\'annotations de paramtre: attendu {expected} mais reu {received}',
        annotatedTypeArgMissing: 'Un argument de type et une ou plusieurs annotations sont attendus pour  Annotated ',
        annotationBytesString: 'Les expressions de type ne peuvent pas utiliser de littraux de chane d\'octets',
        annotationFormatString: 'Les expressions de type ne peuvent pas utiliser de littraux de chane de format (chanes f)',
        annotationNotSupported: 'Annotation de type non prise en charge pour cette instruction',
        annotationRawString: 'Les expressions de type ne peuvent pas utiliser de littraux de chane bruts',
        annotationSpansStrings: 'Les expressions de type ne peuvent pas s\'tendre sur plusieurs littraux de chane',
        annotationStringEscape: 'Les expressions de type ne peuvent pas contenir de caractres d\'chappement',
        argAssignment: 'Impossible daffecter largument de type {argType} au paramtre de type {paramType}',
        argAssignmentFunction: 'Impossible daffecter largument de type {argType} au paramtre de type {paramType} dans la fonction {functionName}',
        argAssignmentParam: 'Impossible daffecter largument de type {argType} au paramtre {paramName} de type {paramType}',
        argAssignmentParamFunction: 'Impossible daffecter largument de type {argType} au paramtre {paramName} de type {paramType} dans la fonction {functionName}',
        argMissingForParam: 'Argument manquant pour le paramtre {name}',
        argMissingForParams: 'Arguments manquants pour les paramtres {names}',
        argMorePositionalExpectedCount: '{expected} arguments positionnels supplmentaires attendus',
        argMorePositionalExpectedOne: '1 argument positionnel supplmentaire attendu',
        argPositional: 'Argument positionnel attendu',
        argPositionalExpectedCount: 'Arguments positionnels {expected} attendus',
        argPositionalExpectedOne: '1 argument positionnel attendu',
        argTypePartiallyUnknown: 'Le type d\'argument est partiellement inconnu',
        argTypeUnknown: 'Le type dargument est inconnu',
        assertAlwaysTrue: 'Lexpression Assert prend toujours la valeur true',
        assertTypeArgs: ' assert_type  attend deux arguments positionnels',
        assertTypeTypeMismatch: 'Non-concordance de  assert_type  :  {expected}  attendu, mais  {received} ',
        assignmentExprComprehension: 'La cible d\'expression d\'affectation "{name}" ne peut pas utiliser le mme nom que la comprhension pour la cible',
        assignmentExprContext: 'Lexpression dassignation doit se trouver dans le module, la fonction ou lexpression lambda',
        assignmentExprInSubscript: 'Les expressions dassignation dans un indice sont prises en charge uniquement dans Python 3.10 et versions ultrieures',
        assignmentInProtocol: 'Les variables d\'instance ou de classe au sein d\'une classe Protocol doivent tre explicitement dclares dans le corps de la classe',
        assignmentTargetExpr: 'Lexpression ne peut pas tre une cible dassignation',
        asyncNotInAsyncFunction: 'L\'utilisation de "async" n\'est pas autorise en dehors de la fonction async',
        awaitIllegal: 'Lutilisation de  await  ncessite Python 3.5 ou version ultrieure',
        awaitNotAllowed: 'Les expressions de type ne peuvent pas utiliser await',
        awaitNotInAsync: ' await  autoris uniquement dans la fonction asynchrone',
        backticksIllegal: 'Les expressions entoures de accents inverses ne sont pas prises en charge dans Python 3.x; utiliser repr  la place',
        baseClassCircular: 'La classe ne peut pas driver d\'elle-mme',
        baseClassFinal: 'La classe de base {type} est marque comme finale et ne peut pas tre sous-classe',
        baseClassIncompatible: 'Les classes de base de {type} sont mutuellement incompatibles',
        baseClassInvalid: 'Largument pour la classe doit tre une classe de base',
        baseClassMethodTypeIncompatible: 'Les classes de base de la classe {classType} dfinissent la mthode {name} de manire incompatible',
        baseClassUnknown: 'Le type de classe de base est inconnu, ce qui masque le type de classe drive',
        baseClassVariableTypeIncompatible: 'Les classes de base de la classe {classType} dfinissent la variable {name} de manire incompatible',
        binaryOperationNotAllowed: 'Oprateur binaire non autoris dans l\'expression de type',
        bindTypeMismatch: 'Impossible de lier la mthode "{methodName}" car "{type}" n\'est pas attribuable au paramtre "{paramName}"',
        breakInExceptionGroup: 'break nest pas autoris dans un bloc except*',
        breakOutsideLoop: '"break" ne peut tre utilis qu\' l\'intrieur d\'une boucle',
        callableExtraArgs: 'Seuls deux arguments de type sont attendus pour Callable',
        callableFirstArg: 'Liste de types de paramtres attendue ou  ... ',
        callableNotInstantiable: 'Impossible dinstancier le type {type}',
        callableSecondArg: 'Type de retour attendu en tant que deuxime argument de type pour Callable',
        casePatternIsIrrefutable: 'Le motif irrfutable n\'est autoris que pour la dernire instruction case',
        classAlreadySpecialized: 'Le type {type} est dj spcialis',
        classDecoratorTypeUnknown: 'Le dcorateur de classe non typ masque le type de classe; dcorateur ignorant',
        classDefinitionCycle: 'La dfinition de classe pour "{name}" dpend d\'elle-mme',
        classGetItemClsParam: '__class_getitem__ remplacement doit prendre un paramtre  cls ',
        classMethodClsParam: 'Les mthodes de classe doivent prendre un paramtre "cls"',
        classNotRuntimeSubscriptable: 'L\'indice pour la classe {name} gnrera une exception d\'excution; placez l\'expression de type entre guillemets',
        classPatternBuiltInArgPositional: 'Le modle de classe accepte uniquement le sous-modle positionnel',
        classPatternPositionalArgCount: 'Trop de modles positionnels pour les "{type}" de classe ; {expected} attendue mais {received} reues',
        classPatternTypeAlias: '"{type}" ne peut pas tre utilis dans un modle de classe car il s\'agit d\'un alias de type spcialis',
        classPropertyDeprecated: 'Les proprits de classe sont obsoltes dans Python 3.11 et ne seront pas prises en charge dans Python 3.13',
        classTypeParametersIllegal: 'La syntaxe du paramtre de type de classe ncessite Python 3.12 ou version ultrieure',
        classVarFirstArgMissing: 'Attendu un argument de type aprs "ClassVar"',
        classVarNotAllowed: ' ClassVar  nest pas autoris dans ce contexte',
        classVarOverridesInstanceVar: 'La variable de classe {name} remplace la variable dinstance du mme nom dans la classe {className}',
        classVarTooManyArgs: 'Attendu un seul argument de type aprs "ClassVar"',
        classVarWithTypeVar: 'Le type "ClassVar" ne peut pas inclure de variables de type',
        clsSelfParamTypeMismatch: 'Le type de paramtre "{name}" doit tre un supertype de sa classe "{classType}"',
        codeTooComplexToAnalyze: 'Le code est trop complexe  analyser ; rduire la complexit en refactorisant en sous-routines ou en rduisant les chemins de code conditionnels',
        collectionAliasInstantiation: 'Le type "{type}" ne peut pas tre instanci, utilisez "{alias}"  la place',
        comparisonAlwaysFalse: 'La condition prend toujours la valeur False, car les types {leftType} et {rightType} ne se chevauchent pas',
        comparisonAlwaysTrue: 'La condition prend toujours la valeur True, car les types {leftType} et {rightType} ne se chevauchent pas',
        comprehensionInDict: 'La comprhension ne peut pas tre utilise avec dautres entres de dictionnaire',
        comprehensionInSet: 'La comprhension ne peut pas tre utilise avec dautres entres set',
        concatenateContext: 'Concatenate nest pas autoris dans ce contexte',
        concatenateParamSpecMissing: 'Le dernier argument de type pour Concatenate doit tre un ParamSpec ou bien ...',
        concatenateTypeArgsMissing: 'Concatenate ncessite au moins deux arguments de type',
        conditionalOperandInvalid: 'Oprande conditionnel non valide de type "{type}"',
        constantRedefinition: '"{name}" est constant (car il est en majuscule) et ne peut pas tre redfini',
        constructorParametersMismatch: 'Non-concordance entre la signature de __new__ et __init__ dans la classe "{classType}"',
        containmentAlwaysFalse: 'L\'expression sera toujours value  False car les types "{leftType}" et "{rightType}" ne se chevauchent pas',
        containmentAlwaysTrue: 'L\'expression sera toujours value  True puisque les types "{leftType}" et "{rightType}" ne se chevauchent pas',
        continueInExceptionGroup: 'continue nest pas autoris dans un bloc except*',
        continueOutsideLoop: ' continuer  ne peut tre utilis quau sein dune boucle',
        coroutineInConditionalExpression: 'L\'expression conditionnelle fait rfrence  une coroutine qui est toujours value  True',
        dataClassBaseClassFrozen: 'Une classe non gele ne peut pas hriter d\'une classe gele',
        dataClassBaseClassNotFrozen: 'Une classe fige ne peut pas hriter dune classe qui nest pas fige',
        dataClassConverterFunction: 'Largument de type {argType} nest pas un convertisseur valide pour le champ {fieldName} de type {fieldType}',
        dataClassConverterOverloads: 'Aucune surcharge de {funcName} nest valide pour le champ {fieldName} de type {fieldType}',
        dataClassFieldInheritedDefault: '{fieldName} remplace un champ du mme nom mais na pas de valeur par dfaut',
        dataClassFieldWithDefault: 'Les champs sans valeurs par dfaut ne peuvent pas apparatre aprs les champs avec des valeurs par dfaut',
        dataClassFieldWithPrivateName: 'Le champ Dataclass ne peut pas utiliser de nom priv',
        dataClassFieldWithoutAnnotation: 'Le champ Dataclass sans annotation de type provoquera une exception d\'excution',
        dataClassPostInitParamCount: 'La classe de donnes __post_init__ nombre de paramtres incorrect ; le nombre de champs InitVar est {expected}',
        dataClassPostInitType: 'Incompatibilit du type de paramtre de mthode __post_init__ Dataclass pour le champ  {fieldName} ',
        dataClassSlotsOverwrite: '__slots__ est dj dfini dans la classe',
        dataClassTransformExpectedBoolLiteral: 'Expression attendue qui prend statiquement la valeur True ou False',
        dataClassTransformFieldSpecifier: 'Expected tuple of classes or functions but received type "{type}"',
        dataClassTransformPositionalParam: 'Tous les arguments de  dataclass_transform  doivent tre des arguments de mot cl',
        dataClassTransformUnknownArgument: 'Largument  {name}  nest pas pris en charge par dataclass_transform',
        dataProtocolInSubclassCheck: 'Les protocoles de donnes (qui incluent des attributs non mthode) ne sont pas autoriss dans les appels de issubclass',
        declaredReturnTypePartiallyUnknown: 'Le type de retour dclar  {returnType}  est partiellement inconnu',
        declaredReturnTypeUnknown: 'Le type de retour dclar est inconnu',
        defaultValueContainsCall: 'Les appels de fonction et les objets mutables ne sont pas autoriss dans l\'expression de la valeur par dfaut du paramtre',
        defaultValueNotAllowed: 'Le paramtre avec  *  ou  **  ne peut pas avoir de valeur par dfaut',
        delTargetExpr: 'L\'expression ne peut pas tre supprime',
        deprecatedClass: 'La classe "{name}" est obsolte',
        deprecatedConstructor: 'Le constructeur de la classe {name} est dconseill',
        deprecatedDescriptorDeleter: 'La mthode __delete__ du descripteur {name} est dconseille',
        deprecatedDescriptorGetter: 'La mthode __get__ du descripteur {name} est dconseille',
        deprecatedDescriptorSetter: 'La mthode __set__ du descripteur {name} est dconseille',
        deprecatedFunction: 'La fonction "{name}" est obsolte',
        deprecatedMethod: 'La mthode "{name}" dans la classe "{className}" est obsolte',
        deprecatedPropertyDeleter: 'Le deleter de la property {name} est dconseill',
        deprecatedPropertyGetter: 'Le getter de la property {name} est dconseill',
        deprecatedPropertySetter: 'Le setter de la property {name} est dconseill',
        deprecatedType: 'Ce type est dconseill  compter de Python {version}; utiliser  {replacement}   la place',
        dictExpandIllegalInComprehension: 'Expansion du dictionnaire non autorise dans la comprhension',
        dictInAnnotation: 'Expression de dictionnaire non autorise dans l\'expression de type',
        dictKeyValuePairs: 'Les entres de dictionnaire doivent contenir des paires cl/valeur',
        dictUnpackIsNotMapping: 'Mappage attendu pour loprateur de dcompression de dictionnaire',
        dunderAllSymbolNotPresent: '{name} est spcifi dans __all__ mais nest pas prsent dans le module',
        duplicateArgsParam: 'Un seul paramtre  *  est autoris',
        duplicateBaseClass: 'Classe de base en double non autorise',
        duplicateCapturePatternTarget: 'La cible Capture "{name}" ne peut pas apparatre plus d\'une fois dans le mme modle',
        duplicateCatchAll: 'Une seule clause catch-all except autorise',
        duplicateEnumMember: 'Le membre Enum {name} est dj dclar',
        duplicateGenericAndProtocolBase: 'Une seule classe de base Generic[...] ou Protocol[...] autorise',
        duplicateImport: ' {importName}  est import plusieurs fois',
        duplicateKeywordOnly: 'Un seul sparateur  *  autoris',
        duplicateKwargsParam: 'Un seul paramtre  **  est autoris',
        duplicateParam: 'Dupliquer le paramtre  {name} ',
        duplicatePositionOnly: 'Un seul paramtre "/" autoris',
        duplicateStarPattern: 'Un seul motif "*" autoris dans une squence de motifs',
        duplicateStarStarPattern: 'Une seule entre "**" autorise',
        duplicateUnpack: 'Une seule opration de dcompression autorise dans la liste',
        ellipsisAfterUnpacked: '"..." ne peut pas tre utilis avec un TypeVarTuple ou un tuple dcompress',
        ellipsisContext: '... nest pas autoris dans ce contexte',
        ellipsisSecondArg: '... nest autoris quen tant que second des deux arguments',
        enumClassOverride: 'La classe Enum {name} est finale et ne peut pas tre sous-classe',
        enumMemberDelete: 'Le membre Enum  {name}  ne peut pas tre supprim',
        enumMemberSet: 'Le membre Enum  {name}  ne peut pas tre affect',
        enumMemberTypeAnnotation: 'Les annotations de type ne sont pas autorises pour les membres enum',
        exceptGroupMismatch: 'Linstruction Try ne peut pas inclure  la fois except et except*',
        exceptGroupRequiresType: 'La syntaxe du groupe dexceptions (except*) ncessite un type dexception',
        exceptionGroupIncompatible: 'La syntaxe du groupe dexceptions ( except* ) ncessite Python 3.11 ou version ultrieure',
        exceptionGroupTypeIncorrect: 'Le type dexception dans except* ne peut pas driver de BaseGroupException',
        exceptionTypeIncorrect: '"{type}" ne drive pas de BaseException',
        exceptionTypeNotClass: '{type} nest pas une classe dexception valide',
        exceptionTypeNotInstantiable: 'Le constructeur pour le type dexception {type} requiert un ou plusieurs arguments',
        expectedAfterDecorator: 'Fonction attendue ou dclaration de classe aprs le dcorateur',
        expectedArrow: '-> attendu suivi dune annotation de type de retour',
        expectedAsAfterException: 'as attendu aprs le type dexception',
        expectedAssignRightHandExpr: 'Expression attendue  droite de  = ',
        expectedBinaryRightHandExpr: 'Expression attendue  droite de loprateur',
        expectedBoolLiteral: 'Attendu True ou False',
        expectedCase: 'Instruction case attendue',
        expectedClassName: 'Nom de classe attendu',
        expectedCloseBrace: '{ na pas t ferm',
        expectedCloseBracket: ' [ na pas t ferm',
        expectedCloseParen: '( na pas t ferm',
        expectedColon: ' :  attendu',
        expectedComplexNumberLiteral: 'Littral de nombre complexe attendu pour la correspondance de modle',
        expectedDecoratorExpr: 'Formulaire dexpression non pris en charge pour llment dcoratif antrieur  Python 3.9',
        expectedDecoratorName: 'Nom de llment dcoratif attendu',
        expectedDecoratorNewline: 'Nouvelle ligne attendue  la fin de llment dcoratif',
        expectedDelExpr: 'Expression attendue aprs  del ',
        expectedElse: ' else  attendu',
        expectedEquals: '= attendu',
        expectedExceptionClass: 'Classe ou objet d\'exception non valide',
        expectedExceptionObj: 'Objet dexception attendu, classe dexception ou None',
        expectedExpr: 'Expression attendue',
        expectedFunctionAfterAsync: 'Dfinition de fonction attendue aprs "async"',
        expectedFunctionName: 'Nom de fonction attendu aprs def',
        expectedIdentifier: 'Identifiant attendu',
        expectedImport: ' importation  attendue',
        expectedImportAlias: 'Symbole attendu aprs  as ',
        expectedImportSymbols: 'Un ou plusieurs noms de symboles attendus aprs limportation',
        expectedIn: ' in  attendu',
        expectedInExpr: 'Expression attendue aprs  in ',
        expectedIndentedBlock: 'Bloc en retrait attendu',
        expectedMemberName: 'Nom dattribut attendu aprs .',
        expectedModuleName: 'Nom de module attendu',
        expectedNameAfterAs: 'Nom de symbole attendu aprs "as"',
        expectedNamedParameter: 'Le paramtre de mot cl doit suivre  * ',
        expectedNewline: 'Nouvelle ligne attendue',
        expectedNewlineOrSemicolon: 'Les instructions doivent tre spares par des nouvelles lignes ou des points-virgules',
        expectedOpenParen: 'Attendu "("',
        expectedParamName: 'Nom du paramtre attendu',
        expectedPatternExpr: 'Expression de modle attendue',
        expectedPatternSubjectExpr: 'Expression du sujet du modle attendu',
        expectedPatternValue: 'Expression de valeur de modle attendue sous la forme a.b',
        expectedReturnExpr: 'Expression attendue aprs  return ',
        expectedSliceIndex: 'Expression d\'index ou de tranche attendue',
        expectedTypeNotString: 'Type attendu mais rception dun littral de chane',
        expectedTypeParameterName: 'Nom de paramtre de type attendu',
        expectedYieldExpr: 'Expression attendue dans l\'instruction yield',
        finalClassIsAbstract: 'La classe {type} est marque comme finale et doit implmenter toutes les symboles abstraits',
        finalContext: ' Final  nest pas autoris dans ce contexte',
        finalInLoop: 'Impossible dassigner une variable Final dans une boucle',
        finalMethodOverride: 'La mthode {name} ne peut pas remplacer la mthode finale dfinie dans la classe {className}',
        finalNonMethod: 'La fonction {name} ne peut pas tre marque @final, car il ne sagit pas dune mthode',
        finalReassigned: '{name} est dclar Final et ne peut pas tre raffect',
        finalRedeclaration: '{name} a t dclar comme Final',
        finalRedeclarationBySubclass: '{name} ne peut pas tre redclar, car la classe parente {className} la dclare Final',
        finalTooManyArgs: 'Argument de type unique attendu aprs  Final ',
        finalUnassigned: '{name} est dclar Final, mais la valeur nest pas affecte',
        formatStringBrace: 'Accolade fermante unique non autorise dans le littral f-string; utiliser une double accolade ferme',
        formatStringBytes: 'Les littraux de chane de format (chanes f) ne peuvent pas tre binaires',
        formatStringDebuggingIllegal: 'Le spcificateur de dbogage de chane F "=" ncessite Python 3.8 ou une version plus rcente',
        formatStringEscape: 'Squence d\'chappement (barre oblique inverse) non autorise dans la partie expression de la chane f avant Python 3.12',
        formatStringExpectedConversion: 'Spcificateur de conversion attendu aprs  !  dans f-string',
        formatStringIllegal: 'Les littraux de chane de format (chanes f) ncessitent Python 3.6 ou une version plus rcente',
        formatStringInPattern: 'Chane de format non autorise dans le modle',
        formatStringNestedFormatSpecifier: 'Expressions imbriqus trop profondment dans le spcificateur de chane de format',
        formatStringNestedQuote: 'Les chanes imbriques dans une chane f ne peuvent pas utiliser le mme guillemet que la chane f avant Python 3.12',
        formatStringUnicode: 'Les littraux de chane de format (f-strings) ne peuvent pas tre unicode',
        formatStringUnterminated: 'Expression non termine dans f-string; attendant "}"',
        functionDecoratorTypeUnknown: 'Le dcorateur de fonction non typ masque le type de fonction ; lment dcoratif ignor',
        functionInConditionalExpression: 'Lexpression conditionnelle fait rfrence  une fonction qui prend toujours la valeur True',
        functionTypeParametersIllegal: 'La syntaxe des paramtres de type de fonction ncessite Python 3.12 ou une version plus rcente',
        futureImportLocationNotAllowed: 'Les importations  partir de __future__ doivent se trouver au dbut du fichier',
        generatorAsyncReturnType: 'Le type de retour de la fonction de gnrateur asynchrone doit tre compatible avec  AsyncGenerator[{yieldType}, Any] ',
        generatorNotParenthesized: 'Les expressions de gnrateur doivent tre entre parenthses si elles ne sont pas uniquement des arguments',
        generatorSyncReturnType: 'Le type de retour de la fonction de gnrateur doit tre compatible avec  Generator[{yieldType}, Any, Any] ',
        genericBaseClassNotAllowed: 'La classe de base Generic ne peut pas tre utilise avec la syntaxe de paramtre de type',
        genericClassAssigned: 'Impossible dattribuer le type de classe gnrique',
        genericClassDeleted: 'Le type de classe gnrique ne peut pas tre supprim',
        genericInstanceVariableAccess: 'Laccs  une variable dinstance gnrique via une classe est ambigu',
        genericNotAllowed: 'Generic nest pas valide dans ce contexte',
        genericTypeAliasBoundTypeVar: 'Lalias de type gnrique dans la classe ne peut pas utiliser les variables de type li {names}',
        genericTypeArgMissing: 'Generic ncessite au moins un argument de type',
        genericTypeArgTypeVar: 'Largument de type pour  Generic  doit tre une variable de type',
        genericTypeArgUnique: 'Les arguments de type pour Generic doivent tre uniques',
        globalReassignment: '{name} est attribu avant la dclaration globale',
        globalRedefinition: ' {name}  a dj t dclar global',
        implicitStringConcat: 'Concatnation implicite de chanes non autorise',
        importCycleDetected: 'Cycle dtect dans la chane d\'importation',
        importDepthExceeded: 'La profondeur de la chane d\'importation a dpass {depth}',
        importResolveFailure: 'Impossible de rsoudre limportation {importName}',
        importSourceResolveFailure: 'Impossible de rsoudre limportation {importName}  partir de la source',
        importSymbolUnknown: '{name} est un symbole dimportation inconnu',
        incompatibleMethodOverride: 'La mthode {name} remplace la classe {className} de manire incompatible',
        inconsistentIndent: 'Le montant du retrait ne correspond pas au retrait prcdent',
        inconsistentTabs: 'Utilisation incohrente des onglets et des espaces dans la mise en retrait',
        initMethodSelfParamTypeVar: 'Lannotation de type pour le paramtre  self  de la mthode  __init__  ne peut pas contenir de variables de type de porte de classe',
        initMustReturnNone: 'Le type de retour de  __init__  doit tre None',
        initSubclassCallFailed: 'Arguments de mot cl incorrects pour la mthode __init_subclass__',
        initSubclassClsParam: '__init_subclass__ remplacement doit prendre un paramtre  cls ',
        initVarNotAllowed: 'InitVar nest pas autoris dans ce contexte',
        instanceMethodSelfParam: 'Les mthodes dinstance doivent prendre un paramtre self',
        instanceVarOverridesClassVar: 'La variable d\'instance "{name}" remplace la variable de classe du mme nom dans la classe "{className}"',
        instantiateAbstract: 'Impossible d\'instancier la classe abstraite "{type}"',
        instantiateProtocol: 'Impossible dinstancier la classe de Protocol "{type}"',
        internalBindError: 'Une erreur interne sest produite lors de la liaison du fichier {file} : {message}',
        internalParseError: 'Une erreur interne sest produite lors de lanalyse du fichier {file} : {message}',
        internalTypeCheckingError: 'Une erreur interne sest produite lors de la vrification de type du fichier {file} : {message}',
        invalidIdentifierChar: 'Caractre invalide dans l\'identifiant',
        invalidStubStatement: 'Linstruction na aucun sens dans un fichier stub de type',
        invalidTokenChars: 'Caractre non valide "{text}" dans le jeton',
        isInstanceInvalidType: 'Le deuxime argument de "isinstance" doit tre une classe ou un tuple de classes',
        isSubclassInvalidType: 'Le deuxime argument de  issubclass  doit tre une classe ou un tuple de classes',
        keyValueInSet: 'Les paires cl/valeur ne sont pas autorises dans un set',
        keywordArgInTypeArgument: 'Les arguments de mot-cl ne peuvent pas tre utiliss dans les listes d\'arguments de type',
        keywordArgShortcutIllegal: 'Le raccourci dargument de mot cl ncessite Python3.14 ou une version plus rcente',
        keywordOnlyAfterArgs: 'Sparateur darguments mot cl uniquement non autoris aprs le paramtre  * ',
        keywordParameterMissing: 'Un ou plusieurs paramtres de mot-cl doivent suivre le paramtre "*"',
        keywordSubscriptIllegal: 'Les arguments de mot-cl dans les indices ne sont pas pris en charge',
        lambdaReturnTypePartiallyUnknown: 'Le type de retour de lambda, {returnType}, est partiellement inconnu',
        lambdaReturnTypeUnknown: 'Le type de retour de lambda est inconnu',
        listAssignmentMismatch: 'Impossible daffecter lexpression de type {type}  la liste cible',
        listInAnnotation: 'Expression de List non autorise dans lexpression de type',
        literalEmptyArgs: 'Attendu un ou plusieurs arguments de type aprs "Literal"',
        literalNamedUnicodeEscape: 'Les squences dchappement Unicode nommes ne sont pas prises en charge dans les annotations de chane Literal',
        literalNotAllowed: 'Literal ne peut pas tre utilis dans ce contexte sans argument de type',
        literalNotCallable: 'Impossible dinstancier le type Literal',
        literalUnsupportedType: 'Les arguments de type pour Literal doivent tre None, une valeur littrale (int, bool, str ou bytes) ou une valeur enum',
        matchIncompatible: 'Les instructions de Match ncessitent Python 3.10 ou version ultrieure',
        matchIsNotExhaustive: 'Les cas dans linstruction match ne grent pas toutes les valeurs de manire exhaustive',
        maxParseDepthExceeded: 'Profondeur danalyse maximale dpasse ; scinder lexpression en sous-expressions plus petites',
        memberAccess: 'Dsol... Nous ne pouvons pas accder  lattribut {name} pour la classe {type}',
        memberDelete: 'Dsol... Nous ne pouvons pas supprimer lattribut {name} pour la classe {type}',
        memberSet: 'Dsol... Nous ne pouvons pas affecter lattribut {name} pour la classe {type}',
        metaclassConflict: 'La mtaclasse dune classe drive doit tre une sous-classe des mtaclasses de toutes ses classes de base',
        metaclassDuplicate: 'Une seule mtaclasse peut tre fournie',
        metaclassIsGeneric: 'La mtaclasse ne peut pas tre gnrique',
        methodNotDefined: 'Mthode {name} non dfinie',
        methodNotDefinedOnType: 'Mthode {name} non dfinie sur le type {type}',
        methodOrdering: 'Impossible de crer un classement de mthode cohrent',
        methodOverridden: '"{name}" remplace la mthode du mme nom dans la classe "{className}" avec un type incompatible "{type}"',
        methodReturnsNonObject: 'La mthode {name} ne retourne pas dobjet',
        missingSuperCall: 'La mthode {methodName} nappelle pas la mthode du mme nom dans la classe parente',
        mixingBytesAndStr: 'Les valeurs Bytes et str ne peuvent pas tre concatnes',
        moduleAsType: 'Le module ne peut pas tre utilis comme type',
        moduleNotCallable: 'Le module ne peut pas tre appel',
        moduleUnknownMember: '{memberName} nest pas un attribut connu du module {moduleName}',
        namedExceptAfterCatchAll: 'Une clause except nomme ne peut pas apparatre aprs une clause except fourre-tout',
        namedParamAfterParamSpecArgs: 'Le paramtre de mot cl {name} ne peut pas apparatre dans la signature aprs le paramtre ParamSpec args',
        namedTupleEmptyName: 'Les noms dans un tuple nomm ne peuvent pas tre vides',
        namedTupleEntryRedeclared: 'Impossible de remplacer {name}, car la classe parente {className} est un tuple nomm',
        namedTupleFirstArg: 'Nom de classe de tuple nomm attendu en tant que premier argument',
        namedTupleMultipleInheritance: 'Lhritage multiple avec NamedTuple nest pas pris en charge',
        namedTupleNameKeyword: 'Les noms de champs ne peuvent pas tre un mot-cl',
        namedTupleNameType: 'Expected two-entry tuple specifying entry name and type',
        namedTupleNameUnique: 'Les noms dans un tuple nomm doivent tre uniques',
        namedTupleNoTypes: ' namedtuple  ne fournit aucun type pour les entres de tuple ; utilisez  NamedTuple   la place',
        namedTupleSecondArg: 'Expected named tuple entry list as second argument',
        newClsParam: '__new__ remplacement doit prendre un paramtre  cls ',
        newTypeAnyOrUnknown: 'Le deuxime argument de NewType doit tre une classe connue, et non Any ou Unknown',
        newTypeBadName: 'Le premier argument de NewType doit tre un littral de chane',
        newTypeLiteral: 'Impossible dutiliser NewType avec le type Literal',
        newTypeNameMismatch: 'NewType doit tre affect  une variable portant le mme nom',
        newTypeNotAClass: 'Classe attendue comme deuxime argument de NewType',
        newTypeParamCount: 'NewType requiert deux arguments positionnels',
        newTypeProtocolClass: 'Dsol, nous navons pas pu utiliser NewType avec un type structurelle (un Protocol ou une classe TypedDict)',
        noOverload: 'Aucune surcharge pour  {name}  ne correspond aux arguments fournis',
        noReturnContainsReturn: 'La fonction avec le type de return dclar NoReturn ne peut pas inclure dinstruction de return',
        noReturnContainsYield: 'La fonction avec le type de retour dclar NoReturn ne peut pas inclure dinstruction yield',
        noReturnReturnsNone: 'La fonction avec le type de retour dclar "NoReturn" ne peut pas renvoyer "None"',
        nonDefaultAfterDefault: 'Largument autre que largument par dfaut suit largument par dfaut',
        nonLocalInModule: 'Dclaration nonlocal non autorise au niveau du module',
        nonLocalNoBinding: 'Aucune liaison pour le {name} nonlocal trouv',
        nonLocalReassignment: '{name} est attribu avant la dclaration nonlocal',
        nonLocalRedefinition: '{name} a dj t dclar nonlocal',
        noneNotCallable: 'Lobjet de type None ne peut pas tre appel',
        noneNotIterable: 'Lobjet de type None ne peut pas tre utilis en tant que valeur itrable',
        noneNotSubscriptable: 'Lobjet de type None nest pas inscriptible',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Loprateur {operator} nest pas pris en charge pour None',
        noneUnknownMember: '{name} nest pas un attribut connu de None',
        notRequiredArgCount: 'Argument de type unique attendu aprs  NotRequired ',
        notRequiredNotInTypedDict: ' NotRequired  nest pas autoris dans ce contexte',
        objectNotCallable: 'Lobjet de type {type} nest pas appelant',
        obscuredClassDeclaration: 'La dclaration de classe {name} est masque par une dclaration du mme nom',
        obscuredFunctionDeclaration: 'La dclaration de fonction {name} est masque par une dclaration du mme nom',
        obscuredMethodDeclaration: 'La dclaration de mthode {name} est masque par une dclaration du mme nom',
        obscuredParameterDeclaration: 'La dclaration de paramtre {name} est masque par une dclaration du mme nom',
        obscuredTypeAliasDeclaration: 'La dclaration dalias de type {name} est masque par une dclaration du mme nom',
        obscuredVariableDeclaration: 'La dclaration {name} est masque par une dclaration du mme nom',
        operatorLessOrGreaterDeprecated: 'Loprateur  <>  nest pas pris en charge dans Python 3 ; utilisez !=  la place',
        optionalExtraArgs: 'Attendu un argument de type aprs Optional',
        orPatternIrrefutable: 'Modle irrfutable autoris uniquement en tant que dernier sous-modle dans un modle "ou"',
        orPatternMissingName: 'Tous les sous-modles dun modle or doivent cibler les mmes noms',
        overlappingKeywordArgs: 'Le dictionnaire tap chevauche avec le mot cl paramtre: {names}',
        overlappingOverload: 'La surcharge {obscured} pour {name} ne sera jamais utilise, car ses paramtres chevauchent la surcharge {obscuredBy}',
        overloadAbstractImplMismatch: 'Les surcharges doivent correspondre  ltat abstrait de limplmentation',
        overloadAbstractMismatch: 'Les surcharges doivent toutes tre abstraites ou non',
        overloadClassMethodInconsistent: 'Les surcharges pour  {name}  utilisent @classmethod de manire incohrente',
        overloadFinalInconsistencyImpl: 'La surcharge pour {name} est marque @final, mais limplmentation ne lest pas',
        overloadFinalInconsistencyNoImpl: 'La surcharge {index} pour {name} est marque @final mais la surcharge 1 nest pas',
        overloadImplementationMismatch: 'Limplmentation surcharge nest pas cohrente avec la signature de la surcharge {index}',
        overloadReturnTypeMismatch: 'La surcharge {prevIndex} pour {name} chevauche la surcharge {newIndex} et retourne un type incompatible',
        overloadStaticMethodInconsistent: 'Les surcharges pour  {name}  utilisent @staticmethod de manire incohrente',
        overloadWithoutImplementation: '{name} est marqu comme overload, mais aucune implmentation nest fournie',
        overriddenMethodNotFound: 'La mthode {name} est marque comme override, mais aucune mthode de base du mme nom nest prsente',
        overrideDecoratorMissing: 'La mthode "{name}" n\'est pas marque comme override mais remplace une mthode dans la classe "{className}"',
        paramAfterKwargsParam: 'Le paramtre ne peut pas suivre le paramtre "**"',
        paramAlreadyAssigned: 'Le paramtre {name} est dj affect',
        paramAnnotationMissing: 'L\'annotation de type est manquante pour le paramtre "{name}"',
        paramAssignmentMismatch: 'L\'expression de type "{sourceType}" ne peut pas tre affecte au paramtre de type "{paramType}"',
        paramNameMissing: 'Aucun paramtre nomm  {name} ',
        paramSpecArgsKwargsDuplicate: 'Des arguments pour ParamSpec {type} ont dj t fournis',
        paramSpecArgsKwargsUsage: 'Les attributs args et kwargs de ParamSpec doivent apparatre tous les deux dans une signature de fonction',
        paramSpecArgsMissing: 'Les arguments pour ParamSpec {type} sont manquants',
        paramSpecArgsUsage: 'Lattribut args de ParamSpec nest valide que lorsquil est utilis avec le paramtre *args',
        paramSpecAssignedName: 'ParamSpec doit tre affect  une variable nomme  {name} ',
        paramSpecContext: 'ParamSpec nest pas autoris dans ce contexte',
        paramSpecDefaultNotTuple: 'Points de suspension attendus, expression de tuple ou ParamSpec pour la valeur par dfaut de ParamSpec',
        paramSpecFirstArg: 'Nom attendu de ParamSpec comme premier argument',
        paramSpecKwargsUsage: 'Lattribut kwargs de ParamSpec nest valide que lorsquil est utilis avec le paramtre **kwargs',
        paramSpecNotUsedByOuterScope: 'ParamSpec {name} na aucune signification dans ce contexte',
        paramSpecUnknownArg: 'ParamSpec ne prend pas en charge plus d\'un argument',
        paramSpecUnknownMember: '{name} nest pas un attribut connu de ParamSpec',
        paramSpecUnknownParam: '"{name}" est un paramtre inconnu pour ParamSpec',
        paramTypeCovariant: 'Impossible dutiliser la variable de type Covariant dans le type de paramtre',
        paramTypePartiallyUnknown: 'Le type du paramtre {paramName} est partiellement inconnu',
        paramTypeUnknown: 'Le type de paramtre {paramName} est inconnu',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Le modle ne sera jamais mis en correspondance pour le type dobjet {type}',
        positionArgAfterNamedArg: 'Largument positionnel ne peut pas apparatre aprs les arguments de mot cl',
        positionOnlyAfterArgs: 'Sparateur de paramtres de position seule non autoris aprs le paramtre  * ',
        positionOnlyAfterKeywordOnly: 'Le paramtre  /  doit apparatre avant le paramtre  * ',
        positionOnlyAfterNon: 'Paramtre de position seule non autoris aprs un paramtre qui nest pas en position seule',
        positionOnlyFirstParam: 'Sparateur de paramtres de position seule non autoris en tant que premier paramtre',
        positionOnlyIncompatible: 'Le sparateur de paramtres de position seule requiert Python 3.8 ou version ultrieure',
        privateImportFromPyTypedModule: '{name} nest pas export  partir du module {module}',
        privateUsedOutsideOfClass: '{name} est priv et utilis en dehors de la classe dans laquelle il est dclar',
        privateUsedOutsideOfModule: ' {name}  est priv et utilis en dehors du module dans lequel il est dclar',
        propertyOverridden: '{name} remplace  tort la property du mme nom dans la classe {className}',
        propertyStaticMethod: 'Mthodes statiques non autorises pour la property getter, setter ou deleter',
        protectedUsedOutsideOfClass: '"{name}" est protg et utilis en dehors de la classe dans laquelle il est dclar',
        protocolBaseClass: 'La classe de Protocol "{classType}" ne peut pas driver de la classe non Protocol "{baseType}"',
        protocolBaseClassWithTypeArgs: 'Les arguments de type ne sont pas autoriss avec la classe Protocol lors de l\'utilisation de la syntaxe des paramtres de type',
        protocolIllegal: 'Lutilisation de  Protocole  ncessite Python 3.7 ou une version plus rcente',
        protocolNotAllowed: '"Protocole" ne peut pas tre utilis dans ce contexte',
        protocolTypeArgMustBeTypeParam: 'Largument de type pour Protocol doit tre un paramtre de type',
        protocolUnsafeOverlap: 'La classe chevauche {name} de manire non scurise et peut produire une correspondance au moment de lexcution',
        protocolVarianceContravariant: 'La variable de type "{variable}" utilise dans le Protocol gnrique "{class}" doit tre contravariante',
        protocolVarianceCovariant: 'La variable de type "{variable}" utilise dans le Protocol gnrique "{class}" doit tre covariante',
        protocolVarianceInvariant: 'La variable de type "{variable}" utilise dans le Protocol gnrique "{class}" doit tre invariante',
        pyrightCommentInvalidDiagnosticBoolValue: 'La directive de commentaire Pyright doit tre suivie de = et dune valeur true ou false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'La directive de commentaire Pyright doit tre suivie de = et avoir la valeur true, false, error, warning, information ou none',
        pyrightCommentMissingDirective: 'Le commentaire Pyright doit tre suivi dune directive (basic ou strict) ou dune rgle de diagnostic',
        pyrightCommentNotOnOwnLine: 'Les commentaires Pyright utiliss pour contrler les paramtres au niveau du fichier doivent apparatre sur leur propre ligne',
        pyrightCommentUnknownDiagnosticRule: '{rule} est une rgle de diagnostic inconnue pour le commentaire pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: '{value} nest pas valide pour le commentaire pyright ; true, false, error, warning, information ou none attendu',
        pyrightCommentUnknownDirective: '{directive} est une directive inconnue pour le commentaire pyright; strict ou basic attendu',
        readOnlyArgCount: 'Attendu un seul argument de type aprs "ReadOnly"',
        readOnlyNotInTypedDict: ' ReadOnly  nest pas autoris dans ce contexte',
        recursiveDefinition: 'Le type de "{name}" n\'a pas pu tre dtermin car il fait rfrence  lui-mme',
        relativeImportNotAllowed: 'Les importations relatives ne peuvent pas tre utilises avec le formulaire import .a ; utiliser from . import a  la place',
        requiredArgCount: 'Attendu un argument de type unique aprs "Required"',
        requiredNotInTypedDict: 'Required nest pas autoris dans ce contexte',
        returnInAsyncGenerator: 'L\'instruction de retour avec valeur n\'est pas autorise dans le gnrateur asynchrone',
        returnInExceptionGroup: 'return nest pas autoris dans un bloc except*',
        returnMissing: 'La fonction avec le type de retour dclar "{returnType}" doit renvoyer une valeur sur tous les chemins de code',
        returnOutsideFunction: '"return" ne peut tre utilis que dans une fonction',
        returnTypeContravariant: 'La variable de type contravariant ne peut pas tre utilise dans le type de retour',
        returnTypeMismatch: 'Le type {exprType} nest pas assignable au type de retour {returnType}',
        returnTypePartiallyUnknown: 'Le type de retour  {returnType}  est partiellement inconnu',
        returnTypeUnknown: 'Le type de retour est inconnu',
        revealLocalsArgs: 'Aucun argument attendu pour l\'appel "reveal_locals"',
        revealLocalsNone: 'Aucun lment locals dans cette tendue',
        revealTypeArgs: 'Argument positionnel unique attendu pour lappel  reveal_type ',
        revealTypeExpectedTextArg: 'L\'argument "expected_text" pour la fonction "reveal_type" doit tre une valeur littrale str',
        revealTypeExpectedTextMismatch: 'Incompatibilit de texte de type ; {expected} attendu, mais a reu {received}',
        revealTypeExpectedTypeMismatch: 'Incompatibilit de type; attendu "{expected}" mais reu "{received}"',
        selfTypeContext: ' Self  nest pas valide dans ce contexte',
        selfTypeMetaclass: 'Self ne peut pas tre utilis dans une mtaclasse (une sous-classe de type)',
        selfTypeWithTypedSelfOrCls: ' Self  ne peut pas tre utilis dans une fonction avec un paramtre  self  ou  cls  qui a une annotation de type autre que  Self ',
        setterGetterTypeMismatch: 'Le type valeur setter de property nest pas assignable au type de retour getter',
        singleOverload: ' {name}  est marqu comme surcharge, mais des surcharges supplmentaires sont manquantes',
        slotsAttributeError: '"{name}" n\'est pas spcifi dans __slots__',
        slotsClassVarConflict: '"{name}" est en conflit avec la variable d\'instance dclare dans __slots__',
        starPatternInAsPattern: 'Le modle dtoile ne peut pas tre utilis avec la cible  as ',
        starPatternInOrPattern: 'Le modle dtoile ne peut pas tre supprim dans dautres modles',
        starStarWildcardNotAllowed: '** ne peut pas tre utilis avec le caractre gnrique _',
        staticClsSelfParam: 'Les mthodes statiques ne doivent pas prendre de paramtre  self  ou  cls ',
        stdlibModuleOverridden: '"{path}" remplace le module stdlib "{name}"',
        stringNonAsciiBytes: 'Caractre non-ASCII non autoris dans le littral de chane d\'octets',
        stringNotSubscriptable: 'L\'expression de chane ne peut pas tre indexe dans une expression de type; placez l\'expression entire entre guillemets',
        stringUnsupportedEscape: 'Squence d\'chappement non prise en charge dans le littral de chane',
        stringUnterminated: 'Le littral de chane nest pas spcifi',
        stubFileMissing: 'Fichier stub introuvable pour  {importName} ',
        stubUsesGetAttr: 'Le fichier stub de type est incomplet ;  __getattr__  masque les erreurs de type pour le module',
        sublistParamsIncompatible: 'Les paramtres de Sublist ne sont pas pris en charge dans Python 3.x',
        superCallArgCount: 'Pas plus de deux arguments attendus pour l\'appel "super"',
        superCallFirstArg: 'Type de classe attendu en tant que premier argument de lappel  super , mais  {type}  reu',
        superCallSecondArg: 'Le deuxime argument de lappel  super  doit tre un objet ou une classe driv de  {type} ',
        superCallZeroArgForm: 'La forme sans argument d\'appel "super" n\'est valide que dans une mthode',
        superCallZeroArgFormStaticMethod: 'La forme  zro argument de lappel super nest pas valide dans une mthode statique',
        symbolIsPossiblyUnbound: '{name} est peut-tre indpendant',
        symbolIsUnbound: ' {name}  est indpendant',
        symbolIsUndefined: '{name} nest pas dfini',
        symbolOverridden: '{name} remplace le symbole du mme nom dans la classe {className}',
        ternaryNotAllowed: 'Expression ternaire non autorise dans l\'expression de type',
        totalOrderingMissingMethod: 'La classe doit dfinir  __lt__ ,  __le__ ,  __gt__  ou  __ge__  pour utiliser total_ordering',
        trailingCommaInFromImport: 'Virgule de fin non autorise sans parenthses adjacentes',
        tryWithoutExcept: 'L\'instruction try doit avoir au moins une clause except ou finally',
        tupleAssignmentMismatch: 'L\'expression avec le type "{type}" ne peut pas tre assigne au tuple cible',
        tupleInAnnotation: 'Expression de tuple non autorise dans l\'expression de type',
        tupleIndexOutOfRange: 'Lindex {index} est hors limites pour le type {type}',
        typeAliasIllegalExpressionForm: 'Formulaire dexpression non valide pour la dfinition dalias de type',
        typeAliasIsRecursiveDirect: 'L\'alias de type "{name}" ne peut pas s\'utiliser lui-mme dans sa dfinition',
        typeAliasNotInModuleOrClass: 'Un TypeAlias ne peut tre dfini quau sein dun module ou dune tendue de classe',
        typeAliasRedeclared: ' {name}  est dclar en tant que TypeAlias et ne peut tre attribu quune seule fois',
        typeAliasStatementBadScope: 'Une instruction de type ne peut tre utilise que dans une tendue de module ou de classe',
        typeAliasStatementIllegal: 'Linstruction dalias de type ncessite Python 3.12 ou version ultrieure',
        typeAliasTypeBaseClass: 'A type alias defined in a "type" statement cannot be used as a base class',
        typeAliasTypeMustBeAssigned: 'TypeAliasType doit tre affect  une variable portant le mme nom que l\'alias de type',
        typeAliasTypeNameArg: 'Le premier argument de TypeAliasType doit tre un littral de chane reprsentant le nom de l\'alias de type',
        typeAliasTypeNameMismatch: 'Le nom de lalias de type doit correspondre au nom de la variable  laquelle il est affect',
        typeAliasTypeParamInvalid: 'La liste de paramtres de type doit tre un tuple contenant uniquement TypeVar, TypeVarTuple ou ParamSpec',
        typeAnnotationCall: 'Expression d\'appel non autorise dans l\'expression de type',
        typeAnnotationVariable: 'Variable non autorise dans l\'expression de type',
        typeAnnotationWithCallable: 'L\'argument de type pour "type" doit tre une classe; les callables ne sont pas pris en charge',
        typeArgListExpected: 'ParamSpec, ellipse ou liste de types attendue',
        typeArgListNotAllowed: 'Expression de liste non autorise pour cet argument de type',
        typeArgsExpectingNone: 'Aucun argument de type attendu pour la classe {name}',
        typeArgsMismatchOne: 'Argument de type attendu mais {received} reu',
        typeArgsMissingForAlias: 'Arguments de type attendus pour lalias de type gnrique {name}',
        typeArgsMissingForClass: 'Arguments de type attendus pour la classe gnrique "{name}"',
        typeArgsTooFew: 'Trop peu darguments de type fournis pour  {name}  ; {expected} attendu, mais {received} reu',
        typeArgsTooMany: 'Trop d\'arguments de type fournis pour "{name}"; attendu {expected} mais reu {received}',
        typeAssignmentMismatch: 'Le type {sourceType} nest pas assignable au type dclar {destType}',
        typeAssignmentMismatchWildcard: 'Le symbole dimportation {name} a le type {sourceType}, qui nest pas assignable au type dclar {destType}',
        typeCallNotAllowed: 'l\'appel type() ne doit pas tre utilis dans une expression de type',
        typeCheckOnly: '"{name}" est marqu comme @type_check_only et ne peut tre utilis que dans les annotations de type',
        typeCommentDeprecated: 'Lutilisation de commentaires de type est dconseille ; utiliser lannotation de type  la place',
        typeExpectedClass: 'Classe attendue mais {type} reu',
        typeFormArgs: 'TypeForm accepte un seul argument positionnel',
        typeGuardArgCount: 'Argument de type unique attendu aprs TypeGuard ou TypeIs',
        typeGuardParamCount: 'Les mthodes et fonctions de protection de type dfinies par lutilisateur doivent avoir au moins un paramtre dentre',
        typeIsReturnType: 'Le type de retour des TypeIs ({returnType}) nest pas cohrent avec le type de paramtre de valeur ({type})',
        typeNotAwaitable: '{type} nest pas awaitable',
        typeNotIntantiable: '{type} ne peut pas tre instanci',
        typeNotIterable: '{type} nest pas itrable',
        typeNotSpecializable: 'Impossible de spcialiser le type "{type}"',
        typeNotSubscriptable: 'Lobjet de type {type} nest pas sous-scriptible',
        typeNotSupportBinaryOperator: 'Oprateur "{operator}" non pris en charge pour les types "{leftType}" et "{rightType}"',
        typeNotSupportBinaryOperatorBidirectional: 'L\'oprateur "{operator}" n\'est pas pris en charge pour les types "{leftType}" et "{rightType}" lorsque le type attendu est "{expectedType}"',
        typeNotSupportUnaryOperator: 'L\'oprateur "{operator}" n\'est pas pris en charge pour le type "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'Loprateur {operator} nest pas pris en charge pour le type {type} quand le type attendu est {expectedType}',
        typeNotUsableWith: 'Lobjet de type "{type}" ne peut pas tre utilis avec with, car il nimplmente pas {method}',
        typeParameterBoundNotAllowed: 'La limite ou la contrainte ne peut pas tre utilise avec un paramtre de type variadique ou ParamSpec',
        typeParameterConstraintTuple: 'La contrainte de paramtre de type doit tre un tuple de plusieurs types',
        typeParameterExistingTypeParameter: 'Le paramtre de type {name} est dj utilis',
        typeParameterNotDeclared: 'Le paramtre de type {name} nest pas inclus dans la liste des paramtres de type pour {container}',
        typeParametersMissing: 'Au moins un paramtre de type doit tre spcifi',
        typePartiallyUnknown: 'Le type de  {name}  est partiellement inconnu',
        typeUnknown: 'Le type de  {name}  est inconnu',
        typeVarAssignedName: 'TypeVar doit tre affect  une variable nomme  {name} ',
        typeVarAssignmentMismatch: 'Le type "{type}" ne peut pas tre affect  la variable de type "{name}"',
        typeVarBoundAndConstrained: 'TypeVar ne peut pas tre  la fois li et contraint',
        typeVarBoundGeneric: 'Le type li TypeVar ne peut pas tre gnrique',
        typeVarConstraintGeneric: 'Le type de contrainte TypeVar ne peut pas tre gnrique',
        typeVarDefaultBoundMismatch: 'Le type par dfaut TypeVar doit tre un sous-type du type li',
        typeVarDefaultConstraintMismatch: 'Le type par dfaut TypeVar doit tre l\'un des types contraints',
        typeVarDefaultIllegal: 'Les types de variables de type par dfaut ncessitent Python 3.13 ou une version plus rcente',
        typeVarDefaultInvalidTypeVar: 'Le paramtre de type {name} a un type par dfaut qui fait rfrence  une ou plusieurs variables de type hors de porte',
        typeVarFirstArg: 'Nom attendu de TypeVar comme premier argument',
        typeVarInvalidForMemberVariable: 'Le type dattribut ne peut pas utiliser de variable de type {name} tendue  une mthode locale',
        typeVarNoMember: 'TypeVar {type} na aucun attribut {name}',
        typeVarNotSubscriptable: 'TypeVar {type} nest pas subscriptible',
        typeVarNotUsedByOuterScope: 'La variable de type {name} na aucune signification dans ce contexte',
        typeVarPossiblyUnsolvable: 'La variable de type "{name}" peut rester non rsolue si l\'appelant ne fournit aucun argument pour le paramtre "{param}"',
        typeVarSingleConstraint: 'TypeVar doit avoir au moins deux types contraints',
        typeVarTupleConstraints: 'TypeVarTuple ne peut pas avoir de contraintes de valeur',
        typeVarTupleContext: 'TypeVarTuple nest pas autoris dans ce contexte',
        typeVarTupleDefaultNotUnpacked: 'Le type par dfaut TypeVarTuple doit tre un tuple dcompress ou TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'L\'oprateur Unpack est requis pour la valeur TypeVarTuple',
        typeVarTupleUnknownParam: '{name} est un paramtre inconnu de TypeVarTuple',
        typeVarUnknownParam: '"{name}" est un paramtre inconnu pour TypeVar',
        typeVarUsedByOuterScope: 'TypeVar "{name}" est dj utilis par une porte externe',
        typeVarUsedOnlyOnce: 'TypeVar {name} napparat quune seule fois dans la signature de fonction gnrique',
        typeVarVariance: 'TypeVar ne peut pas tre  la fois covariant et contravariant',
        typeVarWithDefaultFollowsVariadic: 'TypeVar {typeVarName} a une valeur par dfaut et ne peut pas suivre TypeVarTuple {variadicName}',
        typeVarWithoutDefault: '"{name}" ne peut pas apparatre aprs "{other}" dans la liste des paramtres de type car il n\'a pas de type par dfaut',
        typeVarsNotInGenericOrProtocol: 'Generic[] ou Protocol[] doit inclure toutes les variables de type',
        typedDictAccess: 'Impossible daccder  llment dans TypedDict',
        typedDictAssignedName: 'TypedDict doit tre affect  une variable nomme {name}',
        typedDictBadVar: 'Les classes TypedDict ne peuvent contenir que des annotations de type',
        typedDictBaseClass: 'Toutes les classes de base pour les classes TypedDict doivent galement tre des classes TypedDict',
        typedDictBoolParam: 'Paramtre {name} attendu avec la valeur True ou False',
        typedDictClosedExtras: 'La classe de base {name} est un TypedDict closed, les lments supplmentaires doivent tre de type {type}',
        typedDictClosedNoExtras: 'La classe de base {name} est un TypedDict closed, les lments supplmentaires ne sont pas autoriss',
        typedDictDelete: 'Impossible de supprimer llment dans TypedDict',
        typedDictEmptyName: 'Les noms dans un TypedDict ne peuvent pas tre vides',
        typedDictEntryName: 'Littral de chane attendu pour le nom dentre du dictionnaire',
        typedDictEntryUnique: 'Les noms dans un dictionnaire doivent tre uniques',
        typedDictExtraArgs: 'Arguments TypedDict supplmentaires non pris en charge',
        typedDictExtraItemsClosed: 'Un TypedDict ne peut pas tre closed sil prend en charge les lments supplmentaires',
        typedDictFieldNotRequiredRedefinition: 'Llment TypedDict {name} ne peut pas tre redfini comme tant NotRequired',
        typedDictFieldReadOnlyRedefinition: 'Llment TypedDict {name} ne peut pas tre redfini comme tat En ReadOnly',
        typedDictFieldRequiredRedefinition: 'Llment TypedDict {name} ne peut pas tre redfini comme tant Required',
        typedDictFirstArg: 'Nom de classe TypedDict attendu comme premier argument',
        typedDictInClassPattern: 'La classe TypedDict n\'est pas autorise dans le modle de classe',
        typedDictInitsubclassParameter: 'TypedDict ne prend pas en charge __init_subclass__ paramtre {name}',
        typedDictNotAllowed: '"TypedDict" ne peut pas tre utilis dans ce contexte',
        typedDictSecondArgDict: 'Paramtre de mot cl ou de dict attendu en tant que deuxime paramtre',
        typedDictSecondArgDictEntry: 'Entre de dictionnaire simple attendue',
        typedDictSet: 'Impossible d\'attribuer l\'lment dans TypedDict',
        unaccessedClass: 'La classe "{name}" n\'est pas accessible',
        unaccessedFunction: 'La fonction {name} nest pas accessible',
        unaccessedImport: 'Limportation  {name}  nest pas accessible',
        unaccessedSymbol: '{name} nest pas accessible',
        unaccessedVariable: 'La variable {name} nest pas accessible',
        unannotatedFunctionSkipped: 'L\'analyse de la fonction "{name}" est ignore car elle n\'est pas annote',
        unaryOperationNotAllowed: 'L\'oprateur unaire n\'est pas autoris dans l\'expression de type',
        unexpectedAsyncToken: 'def, with ou for attendu pour suivre async',
        unexpectedExprToken: 'Jeton inattendu  la fin de lexpression',
        unexpectedIndent: 'Retrait inattendu',
        unexpectedUnindent: 'Unindent non attendu',
        unhashableDictKey: 'La cl du dictionnaire doit tre hachable',
        unhashableSetEntry: 'Lentre set doit tre hachable',
        uninitializedAbstractVariables: 'Les variables dfinies dans la classe de base abstraite ne sont pas initialises dans la classe finale {classType}',
        uninitializedInstanceVariable: 'La variable dinstance {name} nest pas initialise dans le corps de la classe ou dans la mthode __init__',
        unionForwardReferenceNotAllowed: 'La syntaxe Union ne peut pas tre utilise avec loprande de chane ; utiliser des guillemets autour de lexpression entire',
        unionSyntaxIllegal: 'Une autre syntaxe pour les unions ncessite Python 3.10 ou une version plus rcente',
        unionTypeArgCount: 'LUnion requiert au moins deux arguments de type',
        unionUnpackedTuple: 'Union ne peut pas inclure un tuple dcompress',
        unionUnpackedTypeVarTuple: 'Union ne peut pas inclure un TypeVarTuple dcompress',
        unnecessaryCast: 'Appel "cast" inutile; le type est dj "{type}"',
        unnecessaryIsInstanceAlways: 'Appel disinstance inutile ; {testType} est toujours une instance de {classType}',
        unnecessaryIsInstanceNever: 'Appel disinstance inutile; {testType} n est jamais une instance de {classType}',
        unnecessaryIsSubclassAlways: 'Appel issubclass inutile; "{testType}" est toujours une sous-classe de "{classType}"',
        unnecessaryIsSubclassNever: 'Appel issubclass inutile; {testType} est toujours une sous-classe de {classType}',
        unnecessaryPyrightIgnore: 'Commentaire "# pyright: ignore" inutile',
        unnecessaryPyrightIgnoreRule: 'Rgle inutile # pyright: ignore: {name}',
        unnecessaryTypeIgnore: 'Commentaire "# type: ignore" inutile',
        unpackArgCount: 'Attendu un seul argument de type aprs "Unpack"',
        unpackExpectedTypeVarTuple: 'TypeVarTuple ou tuple attendu en tant quargument de type pour Unpack',
        unpackExpectedTypedDict: 'Argument de type TypedDict attendu pour Unpack',
        unpackIllegalInComprehension: 'Opration de dcompression non autorise dans la comprhension',
        unpackInAnnotation: 'L\'oprateur de dballage n\'est pas autoris dans l\'expression de type',
        unpackInDict: 'Opration de dcompression non autorise dans les dictionnaires',
        unpackInSet: 'Oprateur de dballage non autoris dans un set',
        unpackNotAllowed: 'Le Unpack nest pas autoris dans ce contexte',
        unpackOperatorNotAllowed: 'Lopration de dcompression nest pas autorise dans ce contexte',
        unpackTuplesIllegal: 'Opration de dcompression non autorise dans les tuples avant Python 3.8',
        unpackedArgInTypeArgument: 'Les arguments dcompresss ne peuvent pas tre utiliss dans ce contexte',
        unpackedArgWithVariadicParam: 'L\'argument dcompress ne peut pas tre utilis pour le paramtre TypeVarTuple',
        unpackedDictArgumentNotMapping: 'Lexpression dargument aprs ** doit tre un mappage avec un type de cl str',
        unpackedDictSubscriptIllegal: 'Loprateur de dcompression de dictionnaire dans lindice nest pas autoris',
        unpackedSubscriptIllegal: 'Loprateur de dcompression en indice requiert Python 3.11 ou version ultrieure',
        unpackedTypeVarTupleExpected: 'TypeVarTuple dcompress attendu ; utiliser Unpack[{name1}] ou *{name2}',
        unpackedTypedDictArgument: 'Impossible de faire correspondre largument TypedDict dcompress aux paramtres',
        unreachableCode: 'Le code est inaccessible',
        unreachableCodeType: 'Lanalyse de type indique que le code est inaccessible',
        unreachableExcept: 'La clause Except est inaccessible, car lexception est dj gre',
        unsupportedDunderAllOperation: 'Lopration sur  __all__  nest pas prise en charge. Par consquent, la liste de symboles exporte peut tre incorrecte',
        unusedCallResult: 'Le rsultat de l\'expression d\'appel est de type "{type}" et n\'est pas utilis; affecter  la variable "_" si c\'est intentionnel',
        unusedCoroutine: 'Le rsultat de lappel de fonction asynchrone nest pas utilis ; utiliser  await  ou affecter le rsultat  la variable',
        unusedExpression: 'La valeur de l\'expression n\'est pas utilise',
        varAnnotationIllegal: 'Les annotations de type pour les variables ncessitent Python 3.6 ou une version ultrieure ; utiliser le commentaire de type pour la compatibilit avec les versions prcdentes',
        variableFinalOverride: 'La variable {name} est marque comme Final et remplace la variable non-Final du mme nom dans la classe {className}',
        variadicTypeArgsTooMany: 'La liste darguments de type peut avoir au plus un TypeVarTuple ou tuple dcompress',
        variadicTypeParamTooManyAlias: 'Lalias de type peut avoir au plus un paramtre de type TypeVarTuple, mais a reu plusieurs ({names})',
        variadicTypeParamTooManyClass: 'La classe gnrique peut avoir au plus un paramtre de type TypeVarTuple, mais en a reu plusieurs ({names})',
        walrusIllegal: 'Loprateur := ncessite Python 3.8 ou version ultrieure',
        walrusNotAllowed: 'Loprateur := nest pas autoris dans ce contexte sans parenthses adjacentes',
        wildcardInFunction: 'import de caractres gnriques non autorise dans une classe ou une fonction',
        wildcardLibraryImport: 'import de caractres gnriques  partir dune bibliothque non autorise',
        wildcardPatternTypePartiallyUnknown: 'Le type captur par le modle gnrique est partiellement inconnu',
        wildcardPatternTypeUnknown: 'Le type captur par le modle gnrique est inconnu',
        yieldFromIllegal: 'Lutilisation de  yield from  ncessite Python 3.3 ou version ultrieure',
        yieldFromOutsideAsync: ' yield from  non autoris dans une fonction asynchrone',
        yieldOutsideFunction: 'yield non autoris en dehors dune fonction ou dun lambda',
        yieldWithinComprehension: 'yield nest pas autoris dans une comprhension de liste',
        zeroCaseStatementsFound: 'Linstruction de Match doit inclure au moins une instruction case',
        zeroLengthTupleNotAllowed: 'Le tuple de longueur nulle nest pas autoris dans ce contexte'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Impossible dutiliser le formulaire spcial Annotated avec les vrifications dinstance et de classe',
        argParam: 'Largument correspond au paramtre {paramName}',
        argParamFunction: 'Largument correspond au paramtre {paramName} dans la fonction {functionName}',
        argsParamMissing: 'Le paramtre "*{paramName}" n\'a pas de paramtre correspondant',
        argsPositionOnly: 'Non-concordance des paramtres de position uniquement; attendu {expected} mais reu {received}',
        argumentType: 'Le type dargument est {type}',
        argumentTypes: 'Types d\'argument: ({types})',
        assignToNone: 'Le type nest pas assignable   None ',
        asyncHelp: 'Vouliez-vous dire async with?',
        baseClassIncompatible: 'La classe de base {baseClass} nest pas compatible avec le type {type}',
        baseClassIncompatibleSubclass: 'La classe de base {baseClass} drive de {subclass} qui est incompatible avec le type {type}',
        baseClassOverriddenType: 'La classe de base {baseClass} fournit le type {type}, qui est remplac',
        baseClassOverridesType: 'La classe de base "{baseClass}" remplace le type "{type}"',
        bytesTypePromotions: 'Dfinir disableBytesTypePromotions sur false pour activer le comportement de promotion de type pour  bytearray  et  memoryview ',
        conditionalRequiresBool: 'La mthode __bool__ pour le type {operandType} retourne le type {boolReturnType} plutt que bool',
        dataClassFieldLocation: 'Dclaration de champ',
        dataClassFrozen: '{name} est fig',
        dataProtocolUnsupported: '{name} est un protocole de donnes',
        descriptorAccessBindingFailed: 'chec de la liaison du {name} de mthode pour la classe de descripteur {className}',
        descriptorAccessCallFailed: 'chec de lappel du {name} de mthode pour la classe de descripteur {className}',
        finalMethod: 'Mthode Final',
        functionParamDefaultMissing: 'Le paramtre "{name}" n\'a pas d\'argument par dfaut',
        functionParamName: 'Incompatibilit de nom de paramtre :  {destName}  et  {srcName} ',
        functionParamPositionOnly: 'Non-correspondance des paramtres position uniquement ; le paramtre {name} nest pas en position seule',
        functionReturnTypeMismatch: 'Le type de retour de fonction "{sourceType}" est incompatible avec le type "{destType}"',
        functionTooFewParams: 'La fonction accepte trop peu de paramtres positionnels ; {expected} attendu, mais {received} reu',
        functionTooManyParams: 'La fonction accepte trop de paramtres positionnels ; {expected} attendu, mais {received} reu',
        genericClassNotAllowed: 'Type gnrique avec des arguments de type non autoris pour les vrifications dinstance ou de classe',
        incompatibleDeleter: 'La mthode du deleter de property nest pas compatible',
        incompatibleGetter: 'La mthode de getter de property est incompatible',
        incompatibleSetter: 'La mthode setter de property nest pas compatible',
        initMethodLocation: 'La mthode __init__ est dfinie dans la classe {type}',
        initMethodSignature: 'La signature de __init__ est  {type} ',
        initSubclassLocation: 'La mthode __init_subclass__ est dfinie dans la classe {name}',
        invariantSuggestionDict: 'Envisagez de passer de  dict    Mapping , qui est covariant dans le type valeur',
        invariantSuggestionList: 'Envisagez de passer de  list    Sequence  qui est covariant',
        invariantSuggestionSet: 'Pensez  passer de "set"  "Container" qui est covariant',
        isinstanceClassNotSupported: '{type} nest pas pris en charge pour les vrifications dinstance et de classe',
        keyNotRequired: '"{name}" n\'est pas une cl requise dans "{type}", donc l\'accs peut entraner une exception d\'excution',
        keyReadOnly: '{name} est une cl en lecture seule dans {type}',
        keyRequiredDeleted: '{name} est une cl obligatoire et ne peut pas tre supprime',
        keyUndefined: '{name} nest pas une cl dfinie dans {type}',
        kwargsParamMissing: 'Le paramtre "**{paramName}" n\'a pas de paramtre correspondant',
        listAssignmentMismatch: 'Le type {type} nest pas compatible avec la liste cible',
        literalAssignmentMismatch: '{sourceType} nest pas assignable au type {destType}',
        matchIsNotExhaustiveHint: 'Si la gestion exhaustive nest pas prvue, ajoutez  case _: pass ',
        matchIsNotExhaustiveType: 'Type non gr : {type}',
        memberAssignment: 'L\'expression de type {type} ne peut pas tre attribue  lattribut {name} de la classe {classType}',
        memberIsAbstract: '{type}.{name} nest pas implment',
        memberIsAbstractMore: 'et {count} autres...',
        memberIsClassVarInProtocol: '{name} est dfini en tant que ClassVar dans le protocole',
        memberIsInitVar: '{name} est un champ init-only',
        memberIsInvariant: ' {name}  est invariant, car il est mutable',
        memberIsNotClassVarInClass: '{name} doit tre dfini en tant que ClassVar pour tre compatible avec le protocole',
        memberIsNotClassVarInProtocol: '{name} nest pas dfini en tant que ClassVar dans le protocole',
        memberIsNotReadOnlyInProtocol: '{name} nest pas en lecture seule dans le protocole',
        memberIsReadOnlyInProtocol: '{name} est en lecture seule dans le protocole',
        memberIsWritableInProtocol: '{name} est accessible en criture dans le protocole',
        memberSetClassVar: 'Lattribut {name} ne peut pas tre attribu via une instance de classe car il sagit dune ClassVar',
        memberTypeMismatch: ' {name}  est un type incompatible',
        memberUnknown: 'Lattribut {name} est inconnu',
        metaclassConflict: 'La mtaclasse {metaclass1} est en conflit avec {metaclass2}',
        missingDeleter: 'La mthode de deleter de property est manquante',
        missingGetter: 'La mthode getter de property est manquante',
        missingSetter: 'setter de dfinition de property est manquante',
        namedParamMissingInDest: 'Paramtre supplmentaire {name}',
        namedParamMissingInSource: 'Paramtre de mot cl manquant {name}',
        namedParamTypeMismatch: 'Le paramtre de mot cl {name} de type {sourceType} est incompatible avec le type {destType}',
        namedTupleNotAllowed: 'NamedTuple ne peut pas tre utilis pour les vrifications dinstance ou de classe',
        newMethodLocation: 'La mthode __new__ est dfinie dans la classe {type}',
        newMethodSignature: 'La signature de __new__ est  {type} ',
        newTypeClassNotAllowed: 'La classe cre avec NewType ne peut pas tre utilise avec des vrifications de instance et de classe',
        noOverloadAssignable: 'Aucune fonction surcharge ne correspond au type {type}',
        noneNotAllowed: 'None ne peut tre utilis pour les vrifications de instance ou de classe',
        orPatternMissingName: 'Noms manquants : {name}',
        overloadIndex: 'La surcharge {index} est la correspondance la plus proche',
        overloadNotAssignable: 'Une ou plusieurs surcharges de  {name}  ne sont pas assignables',
        overloadSignature: 'La signature de surcharge est dfinie ici',
        overriddenMethod: 'Mthode substitue',
        overriddenSymbol: 'Symbole substitu',
        overrideInvariantMismatch: 'Le type de remplacement "{overrideType}" n\'est pas le mme que le type de base "{baseType}"',
        overrideIsInvariant: 'La variable est mutable donc son type est invariant',
        overrideNoOverloadMatches: 'Aucune signature de surcharge dans le remplacement nest compatible avec la mthode de base',
        overrideNotClassMethod: 'La mthode de base est dclare en tant que classmethod, mais la substitution nest pas',
        overrideNotInstanceMethod: 'La mthode de base est dclare en tant que mthode d\'instance mais la substitution n\'est pas',
        overrideNotStaticMethod: 'La mthode de base est dclare comme staticmethod, mais la substitution nest pas',
        overrideOverloadNoMatch: 'Le remplacement ne gre pas toutes les surcharges de la mthode de base',
        overrideOverloadOrder: 'Les surcharges pour la mthode de remplacement doivent tre dans le mme ordre que la mthode de base',
        overrideParamKeywordNoDefault: 'Non-concordance du paramtre de mot-cl "{name}": le paramtre de base a une valeur d\'argument par dfaut, le paramtre de remplacement n\'en a pas',
        overrideParamKeywordType: 'Incompatibilit de type du paramtre de mot cl "{name}": le paramtre de base est de type "{baseType}", le paramtre de remplacement est de type "{overrideType}"',
        overrideParamName: 'Incompatibilit de nom de paramtre {index}: le paramtre de base est nomm "{baseName}", le paramtre de remplacement est nomm "{overrideName}"',
        overrideParamNameExtra: 'Le paramtre {name} est manquant dans la base',
        overrideParamNameMissing: 'Le paramtre "{name}" est manquant dans le remplacement',
        overrideParamNamePositionOnly: 'Incompatibilit du paramtre {index}: le paramtre de base "{baseName}" est un paramtre de mot-cl, le paramtre de remplacement est uniquement de position',
        overrideParamNoDefault: 'Non-concordance du paramtre {index}: le paramtre de base a une valeur d\'argument par dfaut, le paramtre de remplacement n\'en a pas',
        overrideParamType: 'Incompatibilit de type de paramtre {index}: le paramtre de base est de type "{baseType}", le paramtre de remplacement est de type "{overrideType}"',
        overridePositionalParamCount: 'Non-concordance du nombre de paramtres positionnels; la mthode de base a {baseCount}, mais la substitution a {overrideCount}',
        overrideReturnType: 'Incompatibilit de type de retour : la mthode de base retourne le type {baseType}, la substitution retourne le type {overrideType}',
        overrideType: 'La classe de base dfinit le type comme  {type} ',
        paramAssignment: 'Paramtre {index}: le type {sourceType} est incompatible avec le type {destType}',
        paramSpecMissingInOverride: 'Les paramtres ParamSpec sont manquants dans la mthode de remplacement',
        paramType: 'Le type de paramtre est  {paramType} ',
        privateImportFromPyTypedSource: 'Importer  partir de  {module}   la place',
        propertyAccessFromProtocolClass: 'Une proprit dfinie dans une classe de protocole n\'est pas accessible en tant que variable de classe',
        propertyMethodIncompatible: 'La mthode de property {name} nest pas compatible',
        propertyMethodMissing: 'La mthode de property {name} est manquante dans le remplacement',
        propertyMissingDeleter: 'La property {name} na pas de deleter dfini',
        propertyMissingSetter: 'La property {name} na pas de mthode setter dfinie',
        protocolIncompatible: '"{sourceType}" est incompatible avec le protocole "{destType}"',
        protocolMemberMissing: '{name} nest pas prsent',
        protocolRequiresRuntimeCheckable: 'La classe de Protocol doit tre @runtime_checkable  utiliser avec des vrifications dinstance et de classe',
        protocolSourceIsNotConcrete: '"{sourceType}" n\'est pas un type de classe concret et ne peut pas tre affect au type "{destType}"',
        protocolUnsafeOverlap: 'Les attributs de {name} ont les mmes noms que le protocole',
        pyrightCommentIgnoreTip: 'Utilisez # pyright: ignore[<diagnostic rules>] pour supprimer les diagnostics pour une seule ligne',
        readOnlyAttribute: 'Lattribut {name} est en lecture seule',
        seeClassDeclaration: 'Voir la dclaration de classe',
        seeDeclaration: 'Voir la dclaration',
        seeFunctionDeclaration: 'Voir la dclaration de fonction',
        seeMethodDeclaration: 'Voir la dclaration de mthode',
        seeParameterDeclaration: 'Voir la dclaration des paramtres',
        seeTypeAliasDeclaration: 'Voir la dclaration dalias de type',
        seeVariableDeclaration: 'Voir dclaration de variable',
        tupleAssignmentMismatch: 'Le type "{type}" est incompatible avec le tuple cible',
        tupleEntryTypeMismatch: 'Le type de lentre de tuple {entry} est incorrect',
        tupleSizeIndeterminateSrc: 'Incompatibilit de taille de tuple; attendu {expected} mais reu pour une dure indtermine',
        tupleSizeIndeterminateSrcDest: 'Incompatibilit de taille de tuple: attente de {expected} ou plus, mais rception indtermine',
        tupleSizeMismatch: 'Incompatibilit de taille de tuple; attendu {expected} mais reu {received}',
        tupleSizeMismatchIndeterminateDest: 'Incompatibilit de taille de tuple: attente de {expected} ou plus, mais rception de {received}',
        typeAliasInstanceCheck: 'Lalias de type cr avec linstruction type ne peut pas tre utilis avec des vrifications dinstance et de classe',
        typeAssignmentMismatch: 'Le type {sourceType} nest pas assignable au type {destType}',
        typeBound: 'Le type {sourceType} nest pas assignable  la limite suprieure {destType} pour la variable de type {name}',
        typeConstrainedTypeVar: 'Le type {type} nest pas assignable  la variable de type contrainte {name}',
        typeIncompatible: '{sourceType} nest pas assignable  {destType}',
        typeNotClass: '{type} nest pas une classe',
        typeNotStringLiteral: '"{type}" n\'est pas un littral de chane',
        typeOfSymbol: 'Le type de "{name}" est "{type}"',
        typeParamSpec: 'Le type {type} nest pas compatible avec ParamSpec {name}',
        typeUnsupported: 'Le type {type} nest pas pris en charge',
        typeVarDefaultOutOfScope: 'La variable de type {name} nest pas dans ltendue',
        typeVarIsContravariant: 'Le paramtre de type "{name}" est contravariant, mais "{sourceType}" n\'est pas un supertype de "{destType}"',
        typeVarIsCovariant: 'Le paramtre de type "{name}" est covariant, mais "{sourceType}" n\'est pas un sous-type de "{destType}"',
        typeVarIsInvariant: 'Le paramtre de type "{name}" est invariant, mais "{sourceType}" n\'est pas le mme que "{destType}"',
        typeVarNotAllowed: 'TypeVar non autoris pour les vrifications dinstance ou de classe',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple ne peut pas tre li  un tuple de longueur inconnue',
        typeVarUnnecessarySuggestion: 'Utilisez plutt {type}',
        typeVarUnsolvableRemedy: 'Fournir une surcharge qui spcifie le type de retour lorsque largument nest pas fourni',
        typeVarsMissing: 'Variables de type manquantes : {names}',
        typedDictBaseClass: 'La classe "{type}" n\'est pas un TypedDict',
        typedDictClassNotAllowed: 'Classe TypedDict non autorise pour les vrifications dinstance ou de classe',
        typedDictClosedExtraNotAllowed: 'Impossible dajouter llment {name}',
        typedDictClosedExtraTypeMismatch: 'Impossible dajouter llment {name} avec le type {type}',
        typedDictClosedFieldNotRequired: 'Impossible dajouter llment {name}, car il doit tre NotRequired',
        typedDictExtraFieldNotAllowed: '{name} nest pas prsent dans {type}',
        typedDictExtraFieldTypeMismatch: 'Le type de {name} est incompatible avec le type extra_items dans {type}',
        typedDictFieldMissing: '{name} est manquant dans {type}',
        typedDictFieldNotReadOnly: '{name} nest pas en lecture seule dans {type}',
        typedDictFieldNotRequired: '{name} nest pas obligatoire dans {type}',
        typedDictFieldRequired: '{name} est obligatoire dans {type}',
        typedDictFieldTypeMismatch: 'Le type {type} n\'est pas attribuable  llment {name}',
        typedDictFieldUndefined: '{name} est un lment non dfini dans le type {type}',
        typedDictFinalMismatch: ' {sourceType}  nest pas compatible avec  {destType}  en raison dune incompatibilit de @final',
        typedDictKeyAccess: 'Utilisez [ {name} ] pour rfrencer llment dans TypedDict',
        typedDictNotAllowed: 'TypedDict ne peut pas tre utilis pour les vrifications dinstance ou de classe',
        unhashableType: 'Le type "{type}" n\'est pas hachable',
        uninitializedAbstractVariable: 'La variable dinstance {name} est dfinie dans la classe de base abstraite {classType} mais nest pas initialise',
        unreachableExcept: '{exceptionType} est une sous-classe de {parentType}',
        useDictInstead: 'Utilisez Dict[T1, T2] pour indiquer un type de dictionnaire',
        useListInstead: 'Utilisez List[T] pour indiquer un type de liste ou Union[T1, T2] pour indiquer un type d\'union',
        useTupleInstead: 'Utiliser tuple[T1, ..., Tn] pour indiquer un type de tuple ou Union[T1, T2] pour indiquer un type dunion',
        useTypeInstead: 'Utiliser le Type[T]  la place',
        varianceMismatchForClass: 'La variance de l\'argument de type "{typeVarName}" est incompatible avec la classe de base "{className}"',
        varianceMismatchForTypeAlias: 'La variance de l\'argument de type "{typeVarName}" est incompatible avec "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'Lnumration des fichiers sources de lespace de travail prend beaucoup de temps. Envisagez plutt douvrir un sous-dossier. [En savoir plus](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  51667: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Crea Stub di tipo',
        createTypeStubFor: 'Crea Stub di tipo per "{moduleName}"',
        executingCommand: 'Esecuzione del comando',
        filesToAnalyzeCount: '{count} file da analizzare',
        filesToAnalyzeOne: '1 file da analizzare',
        findingReferences: 'Ricerca dei riferimenti in corso',
        organizeImports: 'Organizza importazioni',
        renameShadowedFile: 'Rinomina "{oldFile}" in "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Importazione automatica',
        indexValueDetail: 'Valore dellindice'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Impossibile chiamare il metodo "{method}" perch  astratto e non implementato',
        annotatedMetadataInconsistent: 'Il tipo di metadati annotati "{metadataType}" non  compatibile con il tipo "{type}"',
        annotatedParamCountMismatch: 'Numero di annotazioni dei parametro non corrispondente: previsto {expected} ma ricevuto {received}',
        annotatedTypeArgMissing: 'Previsto un argomento di tipo e una o pi annotazioni per "Annotated"',
        annotationBytesString: 'Le espressioni di tipo non possono usare valori letterali stringa byte',
        annotationFormatString: 'Le espressioni di tipo non possono usare valori letterali stringa di formato (stringhe f)',
        annotationNotSupported: 'Annotazione di tipo non supportata per questa istruzione',
        annotationRawString: 'Le espressioni di tipo non possono usare valori letterali stringa non elaborata',
        annotationSpansStrings: 'Le espressioni di tipo non possono estendersi su pi valori letterali stringa',
        annotationStringEscape: 'Le espressioni di tipo non possono contenere caratteri di escape',
        argAssignment: 'Non  possibile assegnare l\'argomento di tipo "{argType}" al parametro di tipo "{paramType}"',
        argAssignmentFunction: 'Non  possibile assegnare l\'argomento di tipo "{argType}" al parametro di tipo "{paramType}" nella funzione "{functionName}"',
        argAssignmentParam: 'Non  possibile assegnare l\'argomento di tipo "{argType}" al parametro "{paramName}" di tipo "{paramType}"',
        argAssignmentParamFunction: 'Non  possibile assegnare l\'argomento di tipo "{argType}" al parametro "{paramName}" di tipo "{paramType}" nella funzione "{functionName}"',
        argMissingForParam: 'Manca l\'argomento per il parametro {name}',
        argMissingForParams: 'Argomenti mancanti per i parametri {names}',
        argMorePositionalExpectedCount: 'Sono previsti {expected} altri argomenti posizionali',
        argMorePositionalExpectedOne: 'Previsto 1 altro argomento posizionale',
        argPositional: 'Argomento posizionale previsto',
        argPositionalExpectedCount: 'Sono previsti {expected} argomenti posizionali',
        argPositionalExpectedOne: 'Previsto 1 argomento posizionale',
        argTypePartiallyUnknown: 'Tipo di argomento parzialmente sconosciuto',
        argTypeUnknown: 'Il tipo di argomento  sconosciuto',
        assertAlwaysTrue: 'L\'espressione assert restituisce sempre true',
        assertTypeArgs: '"assert_type" prevede due argomenti posizionali',
        assertTypeTypeMismatch: '"assert_type" non corrispondente: previsto "{expected}" ma ricevuto "{received}"',
        assignmentExprComprehension: 'La destinazione dell\'espressione di assegnazione "{name}" non pu usare lo stesso nome della comprensione per la destinazione',
        assignmentExprContext: 'L\'espressione di assegnazione deve essere all\'interno di modulo, funzione o lambda',
        assignmentExprInSubscript: 'Le espressioni di assegnazione all\'interno di un pedice sono supportate solo in Python 3.10 e versioni successive',
        assignmentInProtocol: 'Le variabili di istanza o di classe all\'interno di una classe Protocollo devono essere dichiarate esplicitamente nel corpo della classe',
        assignmentTargetExpr: 'L\'espressione non pu essere una destinazione di assegnazione',
        asyncNotInAsyncFunction: 'L\'uso di "async" non  consentito al di fuori della funzione async',
        awaitIllegal: 'L\'uso di "await" richiede Python 3.5 o versione successiva',
        awaitNotAllowed: 'Le espressioni di tipo non possono usare "await"',
        awaitNotInAsync: '"await" consentito solo all\'interno della funzione async',
        backticksIllegal: 'Le espressioni racchiuse tra backticks non sono supportate in Python 3.x; usare repr invece',
        baseClassCircular: 'La classe non pu derivare da se stessa',
        baseClassFinal: 'La classe di base "{type}"  contrassegnata come finale e non pu essere sottoclassata',
        baseClassIncompatible: 'Le classi di base di {type} sono incompatibili tra di loro',
        baseClassInvalid: 'L\'argomento della classe deve essere una classe base',
        baseClassMethodTypeIncompatible: 'Le classi di base per la classe "{classType}" definiscono il metodo "{name}" in modo incompatibile',
        baseClassUnknown: 'Il tipo della classe di base  sconosciuto.  in corso il tentativo di determinare il tipo della classe derivata',
        baseClassVariableTypeIncompatible: 'Le classi di base per la classe "{classType}" definiscono la variabile "{name}" in modo incompatibile',
        binaryOperationNotAllowed: 'Operatore binario non consentito nell\'espressione di tipo',
        bindTypeMismatch: 'Non  stato possibile associare il metodo "{methodName}" perch non  possibile assegnare"{type}" al parametro "{paramName}"',
        breakInExceptionGroup: '"break" non consentito in un blocco "except*"',
        breakOutsideLoop: '"break" pu essere usato solo all\'interno di un ciclo',
        callableExtraArgs: 'Sono previsti solo due argomenti di tipo per "Callable"',
        callableFirstArg: 'Previsto elenco dei tipi di parametro o "..."',
        callableNotInstantiable: 'Non  possibile creare un\'istanza del tipo "{type}"',
        callableSecondArg: ' previsto un tipo restituito come secondo argomento di tipo per "Callable"',
        casePatternIsIrrefutable: 'Il criterio inconfutabile  consentito solo per l\'ultima istruzione case',
        classAlreadySpecialized: 'Il tipo "{type}"  gi specializzato',
        classDecoratorTypeUnknown: 'L\'elemento Decorator di classe non tipizzato nasconde il tipo di classe. l\'elemento Decorator verr ignorato',
        classDefinitionCycle: 'La definizione della classe per "{name}" dipende da se stessa',
        classGetItemClsParam: '__class_getitem__ override deve accettare un parametro "cls"',
        classMethodClsParam: 'I metodi di classe devono accettare un parametro "cls"',
        classNotRuntimeSubscriptable: 'Il pedice per la classe "{name}" generer un\'eccezione di runtime; racchiudere l\'espressione di tipo tra virgolette',
        classPatternBuiltInArgPositional: 'Il modello di classe accetta solo un sotto pattern posizionale',
        classPatternPositionalArgCount: 'Troppi modelli posizionale per la classe "{type}"; previsto {expected} ma ottenuto {received}',
        classPatternTypeAlias: '"{type}" non pu essere usato in uno schema di classe, perch  un alias di tipo specializzato',
        classPropertyDeprecated: 'Le propriet della classe sono deprecate in Python 3.11 e non saranno supportate in Python 3.13',
        classTypeParametersIllegal: 'La sintassi del parametro del tipo di classe richiede Python 3.12 o versione successiva',
        classVarFirstArgMissing: ' previsto un argomento tipo dopo "ClassVar"',
        classVarNotAllowed: '"ClassVar" non consentito in questo contesto',
        classVarOverridesInstanceVar: 'La variabile di classe "{name}" esegue l\'override della variabile di istanza con lo stesso nome nella classe "{className}"',
        classVarTooManyArgs: 'Previsto un solo argomento tipo dopo "ClassVar"',
        classVarWithTypeVar: 'Il tipo "ClassVar" non pu includere variabili di tipo',
        clsSelfParamTypeMismatch: 'Il tipo di parametro "{name}" deve essere un supertipo della relativa classe "{classType}"',
        codeTooComplexToAnalyze: 'Il codice  troppo complesso per l\'analisi. ridurre la complessit eseguendo il refactoring in subroutine o riducendo i percorsi del codice condizionale',
        collectionAliasInstantiation: 'Non  possibile creare un\'istanza del tipo "{type}". In alternativa, usare "{alias}"',
        comparisonAlwaysFalse: 'La condizione restituisce sempre False perch i tipi "{leftType}" e "{rightType}" non si sovrappongono',
        comparisonAlwaysTrue: 'La condizione restituisce sempre True perch i tipi "{leftType}" e "{rightType}" non si sovrappongono',
        comprehensionInDict: 'Non  possibile usare la comprensione con altre voci del dizionario',
        comprehensionInSet: 'Non  possibile usare la comprensione con altre voci del set',
        concatenateContext: 'Concatenate non  consentito in questo contesto',
        concatenateParamSpecMissing: 'L\'ultimo argomento di tipo per "Concatenate" deve essere un ParamSpec o "..."',
        concatenateTypeArgsMissing: '"Concatenate" richiede almeno due argomenti di tipo',
        conditionalOperandInvalid: 'Operando condizionale non valido di tipo "{type}"',
        constantRedefinition: '"{name}"  costante (perch  in maiuscolo) e non pu essere ridefinita',
        constructorParametersMismatch: 'Mancata corrispondenza tra firma di __new__ e __init__ nella classe "{classType}"',
        containmentAlwaysFalse: 'L\'espressione restituisce sempre False perch i tipi "{leftType}" e "{rightType}" non si sovrappongono',
        containmentAlwaysTrue: 'L\'espressione restituisce sempre True perch i tipi "{leftType}" e "{rightType}" non si sovrappongono',
        continueInExceptionGroup: '"continue" non consentito in un blocco "except*"',
        continueOutsideLoop: '"continue" pu essere usato solo all\'interno di un ciclo',
        coroutineInConditionalExpression: 'L\'espressione condizionale fa riferimento a una coroutine che restituisce sempre True',
        dataClassBaseClassFrozen: 'Una classe non bloccata non pu ereditare da una classe bloccata',
        dataClassBaseClassNotFrozen: 'Una classe bloccata non pu ereditare da una classe non bloccata',
        dataClassConverterFunction: 'L\'argomento di tipo "{argType}" non  un convertitore valido per il campo "{fieldName}" di tipo "{fieldType}"',
        dataClassConverterOverloads: 'Nessun overload di "{funcName}"  un convertitore valido per il campo "{fieldName}" di tipo "{fieldType}"',
        dataClassFieldInheritedDefault: '"{fieldName}" esegue l\'override di un campo con lo stesso nome, ma manca un valore predefinito',
        dataClassFieldWithDefault: 'I campi senza valori predefiniti non possono essere visualizzati dopo i campi con valori predefiniti',
        dataClassFieldWithPrivateName: 'Il campo dataclass non pu usare un nome privato',
        dataClassFieldWithoutAnnotation: 'Il campo dataclass senza annotazione del tipo causer un\'eccezione di runtime',
        dataClassPostInitParamCount: 'Dataclass __post_init__ conteggio dei parametri non corretto; il numero di campi InitVar  {expected}',
        dataClassPostInitType: 'Dataclass __post_init__ tipo di parametro del metodo non corrispondente per il campo "{fieldName}"',
        dataClassSlotsOverwrite: '__slots__  gi definito nella classe',
        dataClassTransformExpectedBoolLiteral: 'Espressione prevista che restituisce in modo statico True o False',
        dataClassTransformFieldSpecifier: ' prevista una tuple di classi o funzioni ma  stato ricevuto il tipo "{type}"',
        dataClassTransformPositionalParam: 'Tutti gli argomenti di "dataclass_transform" devono essere argomenti di parole chiave',
        dataClassTransformUnknownArgument: 'Argomento "{name}" non supportato da dataclass_transform',
        dataProtocolInSubclassCheck: 'I protocolli dati (che includono attributi non di metodo) non sono consentiti nelle chiamate issubclass',
        declaredReturnTypePartiallyUnknown: 'Il tipo restituito dichiarato "{returnType}"  parzialmente sconosciuto',
        declaredReturnTypeUnknown: 'Il tipo restituito dichiarato  sconosciuto',
        defaultValueContainsCall: 'Chiamate di funzione e oggetti modificabili non consentiti all\'interno dell\'espressione del valore predefinito del parametro',
        defaultValueNotAllowed: 'Il parametro con "*" o "**" non pu avere un valore predefinito',
        delTargetExpr: 'Non  possibile eliminare l\'espressione',
        deprecatedClass: 'La classe "{name}"  deprecata',
        deprecatedConstructor: 'Il costruttore per la classe "{name}"  deprecato',
        deprecatedDescriptorDeleter: 'Il metodo "__delete__" per il descrittore "{name}"  deprecato',
        deprecatedDescriptorGetter: 'Il metodo "__get__" per il descrittore "{name}"  deprecato',
        deprecatedDescriptorSetter: 'Il metodo "__set__" per il descrittore "{name}"  deprecato',
        deprecatedFunction: 'La funzione "{name}"  deprecata',
        deprecatedMethod: 'Il metodo "{name}" nella classe "{className}"  deprecato',
        deprecatedPropertyDeleter: 'Il deleter per la property "{name}"  deprecato',
        deprecatedPropertyGetter: 'Il getter per la property "{name}"  deprecato',
        deprecatedPropertySetter: 'Il setter per la property "{name}"  deprecato',
        deprecatedType: 'Questo tipo  deprecato a partire da Python {version}; usa "{replacement}"',
        dictExpandIllegalInComprehension: 'Espansione del dizionario non consentita nella comprensione',
        dictInAnnotation: 'Espressione dizionario non consentita nell\'espressione di tipo',
        dictKeyValuePairs: 'Le voci del dizionario devono contenere coppie chiave-valore',
        dictUnpackIsNotMapping: 'Mapping previsto per l\'operatore di decompressione del dizionario',
        dunderAllSymbolNotPresent: '"{name}"  specificato in __all__ ma non  presente nel modulo',
        duplicateArgsParam: ' consentito un solo parametro "*"',
        duplicateBaseClass: 'Classe di base duplicata non consentita',
        duplicateCapturePatternTarget: 'La destinazione di acquisizione "{name}" non pu comparire pi di una volta all\'interno dello stesso schema',
        duplicateCatchAll: ' consentita una sola clausola catch-all except',
        duplicateEnumMember: 'Il membro di Enum "{name}"  gi dichiarato',
        duplicateGenericAndProtocolBase: ' consentita una sola classe di base Generic[...] o Protocol[...]',
        duplicateImport: '"{importName}"  stato importato pi di una volta',
        duplicateKeywordOnly: ' consentito un solo separatore "*"',
        duplicateKwargsParam: ' consentito un solo parametro "**"',
        duplicateParam: '{name}" parametro duplicato',
        duplicatePositionOnly: ' consentito un solo parametro "/"',
        duplicateStarPattern: 'In una sequenza di criteri  consentito un solo criterio "*"',
        duplicateStarStarPattern: ' consentita una sola voce "**"',
        duplicateUnpack: 'Nell list  consentita una sola operazione di decompressione',
        ellipsisAfterUnpacked: '"..." non pu essere usato con un argomento TypeVarTuple non compresso o tuple',
        ellipsisContext: '"..." non  consentito in questo contesto',
        ellipsisSecondArg: '"..."  consentito solo come secondo di due argomenti',
        enumClassOverride: 'La classe di Enum "{name}"  finale e non pu essere sottoclassificata',
        enumMemberDelete: 'Non  possibile eliminare il membro di Enum "{name}"',
        enumMemberSet: 'Non  possibile assegnare il membro di Enum "{name}"',
        enumMemberTypeAnnotation: 'Le annotazioni di tipo non sono consentite per i membri di enumerazione',
        exceptGroupMismatch: 'L\'istruzione Try non pu includere sia "except" che "except*"',
        exceptGroupRequiresType: 'La sintassi del gruppo di eccezioni ("except*") richiede un tipo di eccezione',
        exceptionGroupIncompatible: 'La sintassi del gruppo di eccezioni ("except*") richiede Python 3.11 o versione successiva',
        exceptionGroupTypeIncorrect: 'Il tipo di eccezione in except* non pu derivare da BaseGroupException',
        exceptionTypeIncorrect: '"{type}" non deriva da BaseException',
        exceptionTypeNotClass: '"{type}" non  una classe di eccezione valida',
        exceptionTypeNotInstantiable: 'Il costruttore per il tipo di eccezione "{type}" richiede uno o pi argomenti',
        expectedAfterDecorator: 'Dichiarazione di funzione o classe prevista dopo lelemento Decorator',
        expectedArrow: 'Previsto "->" seguito da un\'annotazione di tipo restituito',
        expectedAsAfterException: 'Previsto "as" dopo il tipo di eccezione',
        expectedAssignRightHandExpr: 'Espressione prevista a destra di "="',
        expectedBinaryRightHandExpr: 'Espressione prevista a destra dell\'operatore',
        expectedBoolLiteral: ' previsto True o False',
        expectedCase: 'Prevista istruzione "case"',
        expectedClassName: 'Nome classe previsto',
        expectedCloseBrace: '"{" non  stato chiuso',
        expectedCloseBracket: '"[" non  stato chiuso',
        expectedCloseParen: '"(" non  stato chiuso',
        expectedColon: 'Previsto ":"',
        expectedComplexNumberLiteral: ' previsto un valore letterale di numero complesso per i criteri di ricerca',
        expectedDecoratorExpr: 'Il modulo dell\'espressione non  supportato per l\'elemento Decorator precedente a Python 3.9',
        expectedDecoratorName: ' previsto un nome di elemento Decorator',
        expectedDecoratorNewline: 'Prevista nuova riga alla fine dell\'elemento Decorator',
        expectedDelExpr: 'Espressione prevista dopo "del"',
        expectedElse: 'Previsto "else"',
        expectedEquals: 'Previsto "="',
        expectedExceptionClass: 'Classe od oggetto di eccezione non valido',
        expectedExceptionObj: 'Previsto oggetto eccezione, classe eccezione o None',
        expectedExpr: 'Espressione prevista',
        expectedFunctionAfterAsync: 'Prevista definizione di funzione dopo "async"',
        expectedFunctionName: ' previsto un nome di funzione dopo "def"',
        expectedIdentifier: 'Identificatore previsto',
        expectedImport: 'Previsto "import"',
        expectedImportAlias: 'Simbolo previsto dopo "as"',
        expectedImportSymbols: 'Sono previsti uno o pi nomi di simboli dopo import',
        expectedIn: 'previsto \'in\'',
        expectedInExpr: 'Espressione prevista dopo "in"',
        expectedIndentedBlock: 'Previsto un blocco rientrato',
        expectedMemberName: 'Nome dell\'attributo previsto dopo "."',
        expectedModuleName: 'Nome del modulo previsto',
        expectedNameAfterAs: ' previsto il nome del simbolo dopo "as"',
        expectedNamedParameter: 'Il parametro della parola chiave deve seguire "*"',
        expectedNewline: 'Prevista nuova riga',
        expectedNewlineOrSemicolon: 'Le istruzioni devono essere separate da nuove righe o punti e virgola',
        expectedOpenParen: 'Previsto "("',
        expectedParamName: 'Nome del parametro previsto',
        expectedPatternExpr: 'Espressione del criterio prevista',
        expectedPatternSubjectExpr: 'Prevista espressione del soggetto del criterio',
        expectedPatternValue: 'Espressione del valore del criterio prevista nel formato "a.b"',
        expectedReturnExpr: 'Espressione prevista dopo "return"',
        expectedSliceIndex: 'Prevista espressione di indice o sezione',
        expectedTypeNotString: ' previsto un tipo ma  stato ricevuto un valore letterale stringa',
        expectedTypeParameterName: 'Nome del parametro del tipo previsto',
        expectedYieldExpr: 'Espressione prevista nell\'istruzione yield',
        finalClassIsAbstract: 'La classe "{type}"  contrassegnata come finale e deve implementare tutti i simboli astratti',
        finalContext: '"Finale" non  consentito in questo contesto',
        finalInLoop: 'Non  possibile assegnare una variabile "Final" all\'interno di un ciclo',
        finalMethodOverride: 'Il metodo "{name}" non pu eseguire l\'override del metodo finale definito nella classe "{className}"',
        finalNonMethod: 'Impossibile contrassegnare la funzione {name} @final perch non  un metodo',
        finalReassigned: '"{name}"  dichiarato come Finale e non pu essere riassegnato',
        finalRedeclaration: '"{name}"  stato dichiarato in precedenza come Finale',
        finalRedeclarationBySubclass: 'Non  possibile ridichiarare "{name}" perch la classe padre "{className}" la dichiara come Finale',
        finalTooManyArgs: 'Previsto un singolo argomento tipo dopo "Final"',
        finalUnassigned: '"{name}"  dichiarato Final, ma il valore non  assegnato',
        formatStringBrace: 'Parentesi graffa di chiusura singola non consentita all\'interno del valore letterale f-string; usa parentesi graffa chiusa doppia',
        formatStringBytes: 'I valori letterali stringa di formato (f-string) non possono essere binari',
        formatStringDebuggingIllegal: 'Lidentificatore di debug delle stringhe F "=" richiede Python 3.8 o versione successiva',
        formatStringEscape: 'Sequenza di escape (barra rovesciata) non consentita nella porzione di espressione di f-string prima di Python 3.12',
        formatStringExpectedConversion: ' previsto un identificatore di conversione dopo "!" in f-string',
        formatStringIllegal: 'I valori letterali stringa di formato (f-string) richiedono Python 3.6 o versione successiva',
        formatStringInPattern: 'Stringa di formato non consentita nel criterio',
        formatStringNestedFormatSpecifier: 'Espressioni annidate troppo in profondit nell\'identificatore di stringa di formato',
        formatStringNestedQuote: 'Le stringhe annidate all\'interno di una stringa f non possono usare lo stesso carattere virgolette della stringa f prima di Python 3.12',
        formatStringUnicode: 'I valori letterali stringa di formato (f-string) non possono essere unicode',
        formatStringUnterminated: 'Espressione senza terminazione in f-string; previsto "}".',
        functionDecoratorTypeUnknown: 'L\'elemento Decorator della funzione non tipizzato nasconde il tipo di funzione; l\'elemento Decorator verr ignorato',
        functionInConditionalExpression: 'L\'espressione condizionale fa riferimento a una funzione che restituisce sempre True',
        functionTypeParametersIllegal: 'La sintassi del parametro del tipo di funzione richiede Python 3.12 o versione successiva',
        futureImportLocationNotAllowed: 'Le importazioni da __future__ devono trovarsi all\'inizio del file',
        generatorAsyncReturnType: 'Il tipo restituito della funzione del generatore async deve essere compatibile con "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: 'Le espressioni del generatore devono essere racchiuse tra parentesi se non  l\'unico argomento',
        generatorSyncReturnType: 'Il tipo restituito della funzione del generatore deve essere compatibile con "Generator[{yieldType}, Any, Any]"',
        genericBaseClassNotAllowed: 'Non  possibile usare la classe di base "Generic" con la sintassi del parametro di tipo',
        genericClassAssigned: 'Non  possibile assegnare il tipo di classe generico',
        genericClassDeleted: 'Non  possibile eliminare il tipo di classe generico',
        genericInstanceVariableAccess: 'L\'accesso alla variabile di istanza generica tramite la classe  ambiguo',
        genericNotAllowed: '"Generic" non valido in questo contesto',
        genericTypeAliasBoundTypeVar: 'L\'alias di tipo generico all\'interno della classe non pu usare variabili di tipo associate {names}',
        genericTypeArgMissing: '"Generico" richiede almeno un argomento di tipo',
        genericTypeArgTypeVar: 'L\'argomento di tipo per "Generic" deve essere una variabile di tipo',
        genericTypeArgUnique: 'Gli argomenti di tipo per "Generic" devono essere univoci',
        globalReassignment: '"{name}"  assegnato prima della dichiarazione globale',
        globalRedefinition: '"{name}"  gi stato dichiarato globale',
        implicitStringConcat: 'Concatenazione implicita di stringhe non consentita',
        importCycleDetected: 'Ciclo rilevato nella catena di importazione',
        importDepthExceeded: 'La profondit della catena di importazione ha superato {depth}',
        importResolveFailure: 'Non  stato possibile risolvere l\'importazione "{importName}"',
        importSourceResolveFailure: 'Non  stato possibile risolvere l\'importazione "{importName}" dallorigine',
        importSymbolUnknown: '"{name}"  un simbolo di importazione sconosciuto',
        incompatibleMethodOverride: 'Il metodo "{name}" esegue l\'override della classe "{className}" in modo incompatibile',
        inconsistentIndent: 'Il valore dell\'annullamento del rientro non corrisponde al rientro precedente',
        inconsistentTabs: 'Uso incoerente di tabulazioni e spazi nel rientro',
        initMethodSelfParamTypeVar: 'L\'annotazione di tipo per il parametro "self" del metodo "__init__" non pu contenere variabili di tipo con ambito classe',
        initMustReturnNone: 'Il tipo restituito di "__init__" deve essere None',
        initSubclassCallFailed: 'Argomenti di parola chiave non corretti per il metodo __init_subclass__',
        initSubclassClsParam: '__init_subclass__ override deve accettare un parametro "cls"',
        initVarNotAllowed: '"InitVar" non consentito in questo contesto',
        instanceMethodSelfParam: 'I metodi di istanza devono accettare un parametro "self"',
        instanceVarOverridesClassVar: 'La variabile di istanza "{name}" esegue l\'override della variabile di classe con lo stesso nome nella classe "{className}"',
        instantiateAbstract: 'Non  possibile creare un\'istanza di classe astratta "{type}"',
        instantiateProtocol: 'Non  possibile creare un\'istanza della classe Protocol "{type}"',
        internalBindError: 'Errore interno durante l\'associazione del file "{file}": {message}',
        internalParseError: 'Si  verificato un errore interno durante l\'analisi del file "{file}": {message}',
        internalTypeCheckingError: 'Errore interno durante il controllo del tipo del file "{file}": {message}',
        invalidIdentifierChar: 'Carattere non valido nell\'identificatore',
        invalidStubStatement: 'L\'istruzione non ha significato all\'interno di un file stub di tipo',
        invalidTokenChars: 'Carattere non valido "{text}" nel token',
        isInstanceInvalidType: 'Il secondo argomento di "isinstance" deve essere una classe o una tuple di classi',
        isSubclassInvalidType: 'Il secondo argomento di "issubclass" deve essere una classe o una tuple di classi',
        keyValueInSet: 'Le coppie chiave-valore non sono consentite all\'interno di un set',
        keywordArgInTypeArgument: 'Gli argomenti delle parole chiave non possono essere usati negli elenchi di argomenti tipo',
        keywordArgShortcutIllegal: 'Il collegamento all\'argomento della parola chiave richiede Python 3.14 o versione successiva',
        keywordOnlyAfterArgs: 'Separatore di argomenti solo parola chiave non consentito dopo il parametro "*"',
        keywordParameterMissing: 'Uno o pi parametri di parole chiave devono seguire il parametro "*"',
        keywordSubscriptIllegal: 'Gli argomenti delle parole chiave all\'interno di pedici non sono supportati',
        lambdaReturnTypePartiallyUnknown: 'Il tipo restituito dell\'espressione lambda "{returnType}"  parzialmente sconosciuto',
        lambdaReturnTypeUnknown: 'Il tipo restituito di lambda  sconosciuto',
        listAssignmentMismatch: 'Non  possibile assegnare l\'espressione con tipo "{type}" all\'elenco di destinazione',
        listInAnnotation: 'Espressione List non consentita nell\'espressione type',
        literalEmptyArgs: 'Sono previsti uno o pi argomenti di tipo dopo "Literal"',
        literalNamedUnicodeEscape: 'Le sequenze di escape Unicode denominate non sono supportate nelle annotazioni stringa "Literal"',
        literalNotAllowed: 'Non  possibile usare "Literal" in questo contesto senza un argomento tipo',
        literalNotCallable: 'Non  possibile creare un\'istanza del tipo Literal',
        literalUnsupportedType: 'Gli argomenti di tipo per "Literal" devono essere None, un valore letterale (int, bool, str o bytes) o un valore di enumerazione',
        matchIncompatible: 'Le istruzioni match richiedono Python 3.10 o versione successiva',
        matchIsNotExhaustive: 'I case all\'interno dell\'istruzione match non gestiscono in modo completo tutti i valori',
        maxParseDepthExceeded: ' stata superata la profondit massima di analisi; suddividere l\'espressione in sottoespressioni pi piccole',
        memberAccess: 'Non  possibile accedere all\'attributo "{name}" per la classe "{type}"',
        memberDelete: 'Non  possibile eliminare l\'attributo "{name}" per la classe "{type}"',
        memberSet: 'Non  possibile assegnare all\'attributo "{name}" per la classe "{type}"',
        metaclassConflict: 'La metaclasse di una classe derivata deve essere una sottoclasse delle metaclassi di tutte le relative classi di base',
        metaclassDuplicate: ' possibile specificare una sola metaclasse',
        metaclassIsGeneric: 'La metaclasse non pu essere generica',
        methodNotDefined: 'Metodo "{name}" non definito',
        methodNotDefinedOnType: '"{name}" metodo non definito nel tipo "{type}"',
        methodOrdering: 'Non  possibile creare un ordinamento coerente del metodo',
        methodOverridden: '"{name}" esegue l\'override del metodo con lo stesso nome nella classe "{className}" con un tipo non compatibile "{type}".',
        methodReturnsNonObject: 'Il metodo "{name}" non restituisce un oggetto',
        missingSuperCall: 'Il metodo "{methodName}" non chiama il metodo con lo stesso nome nella classe padre',
        mixingBytesAndStr: 'Bytes e valori str non possono essere concatenati',
        moduleAsType: 'Il modulo non pu essere usato come tipo',
        moduleNotCallable: 'Modulo non chiamabile',
        moduleUnknownMember: '"{memberName}" non  un attributo noto del modulo "{moduleName}"',
        namedExceptAfterCatchAll: 'Una clausola except denominata non pu trovarsi dopo la clausola catch-all except',
        namedParamAfterParamSpecArgs: 'Il parametro della parola chiave "{name}" non pu essere visualizzato nella firma dopo il parametro ParamSpec args',
        namedTupleEmptyName: 'I nomi all\'interno di un tuple denominato non possono essere vuoti',
        namedTupleEntryRedeclared: 'Non  possibile eseguire l\'override di "{name}" perch la classe padre "{className}"  un tuple denominato',
        namedTupleFirstArg: ' previsto il nome della classe di tuple denominata come primo argomento',
        namedTupleMultipleInheritance: 'L\'ereditariet multipla con NamedTuple non  supportata',
        namedTupleNameKeyword: 'I nomi dei campi non possono essere una parola chiave',
        namedTupleNameType: ' prevista una tuple a due voci che specifica il nome e il tipo della voce',
        namedTupleNameUnique: 'I nomi all\'interno di una tuple denominata devono essere univoci',
        namedTupleNoTypes: '"namedtuple" non fornisce tipi per le voci di tupla; usare invece "NamedTuple"',
        namedTupleSecondArg: ' previsto un list di voci di tuple denominate come secondo argomento',
        newClsParam: '__new__ override deve accettare un parametro "cls"',
        newTypeAnyOrUnknown: 'Il secondo argomento di NewType deve essere una classe nota, non Any o Unknown',
        newTypeBadName: 'Il primo argomento di NewType deve essere un valore letterale stringa',
        newTypeLiteral: 'Non  possibile usare NewType con il tipo Literal',
        newTypeNameMismatch: 'NewType deve essere assegnato a una variabile con lo stesso nome',
        newTypeNotAClass: 'Classe prevista come secondo argomento di NewType',
        newTypeParamCount: 'NewType richiede due argomenti posizionali',
        newTypeProtocolClass: 'Non  possibile usare NewType con il tipo strutturale (una classe Protocol o TypedDict)',
        noOverload: 'Nessun overload per "{name}" corrisponde agli argomenti specificati',
        noReturnContainsReturn: 'La funzione con tipo return dichiarato "NoReturn" non pu includere un\'istruzione return',
        noReturnContainsYield: 'La funzione con il tipo restituito dichiarato "NoReturn" non pu includere un\'istruzione yield',
        noReturnReturnsNone: 'La funzione con tipo restituito dichiarato "NoReturn" non pu restituire "None"',
        nonDefaultAfterDefault: 'L\'argomento non predefinito segue l\'argomento predefinito',
        nonLocalInModule: 'Dichiarazione nonlocale non consentita a livello di modulo',
        nonLocalNoBinding: 'Non  stata trovata alcuna associazione per "{name}" nonlocal',
        nonLocalReassignment: '"{name}" viene assegnato prima della dichiarazione nonlocal',
        nonLocalRedefinition: '"{name}"  gi stato dichiarato nonlocal',
        noneNotCallable: 'Non  possibile chiamare l\'oggetto di tipo "None"',
        noneNotIterable: 'Impossibile utilizzare l\'oggetto di tipo "None" come valore iterabile',
        noneNotSubscriptable: 'L\'oggetto di tipo "None" non  sottoponibile a pedice',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Operatore "{operator}" non supportato per "None"',
        noneUnknownMember: '"{name}" non  un attributo noto di "None"',
        notRequiredArgCount: 'Previsto un singolo argomento tipo dopo "NotRequired"',
        notRequiredNotInTypedDict: '"NotRequired" non  consentito in questo contesto',
        objectNotCallable: 'L\'oggetto di tipo "{type}" non  chiamabile',
        obscuredClassDeclaration: 'La dichiarazione di classe "{name}"  oscurata da una dichiarazione con lo stesso nome',
        obscuredFunctionDeclaration: 'La dichiarazione della funzione "{name}"  oscurata da una dichiarazione con lo stesso nome',
        obscuredMethodDeclaration: 'La dichiarazione del metodo "{name}"  oscurata da una dichiarazione con lo stesso nome',
        obscuredParameterDeclaration: 'La dichiarazione del parametro "{name}"  oscurata da una dichiarazione con lo stesso nome',
        obscuredTypeAliasDeclaration: 'La dichiarazione dell\'alias di tipo "{name}"  nascosta da una dichiarazione con lo stesso nome',
        obscuredVariableDeclaration: 'La dichiarazione "{name}"  oscurata da una dichiarazione con lo stesso nome',
        operatorLessOrGreaterDeprecated: 'L\'operatore "<>" non  supportato in Python 3. Usare invece "!="',
        optionalExtraArgs: ' previsto un argomento di tipo dopo "Optional"',
        orPatternIrrefutable: 'Criterio inconfutabile consentito solo come ultimo criterio secondario in un criterio "or"',
        orPatternMissingName: 'Tutti i criteri secondari all\'interno di un criterio "or" devono avere come destinazione gli stessi nomi',
        overlappingKeywordArgs: 'Il dizionario tipizzato si sovrappone al parametro della parola chiave: {names}',
        overlappingOverload: 'L\'overload {obscured} per "{name}" non verr mai usato perch i parametri si sovrappongono all\'overload {obscuredBy}',
        overloadAbstractImplMismatch: 'Gli overload devono corrispondere allo stato astratto dell\'implementazione',
        overloadAbstractMismatch: 'Gli overload devono essere tutti astratti o no',
        overloadClassMethodInconsistent: 'Gli overload per "{name}" usano @classmethod in modo incoerente',
        overloadFinalInconsistencyImpl: 'L\'overload per {name}  contrassegnato @final ma l\'implementazione non lo ',
        overloadFinalInconsistencyNoImpl: 'L\'overload {index} per {name}  contrassegnato @final ma l\'overload 1 non lo ',
        overloadImplementationMismatch: 'L\'implementazione di overload non  coerente con la firma dell\'overload {index}',
        overloadReturnTypeMismatch: 'L\'overload {prevIndex} per "{name}" si sovrappone all\'overload {newIndex} e restituisce un tipo incompatibile',
        overloadStaticMethodInconsistent: 'Gli overload per "{name}" usano @staticmethod in modo incoerente',
        overloadWithoutImplementation: '"{name}"  contrassegnato come overload, ma non viene fornita alcuna implementazione',
        overriddenMethodNotFound: 'Il metodo "{name}"  contrassegnato come override, ma non  presente alcun metodo di base con lo stesso nome',
        overrideDecoratorMissing: 'Il metodo "{name}" non  contrassegnato come override, ma esegue l\'override di un metodo nella classe "{className}"',
        paramAfterKwargsParam: 'Il parametro non pu seguire il parametro "**"',
        paramAlreadyAssigned: 'Il parametro "{name}"  gi assegnato',
        paramAnnotationMissing: 'Annotazione di tipo mancante per il parametro "{name}"',
        paramAssignmentMismatch: 'Non  possibile assegnare l\'espressione di tipo "{sourceType}" al parametro di tipo "{paramType}"',
        paramNameMissing: 'Nessun parametro denominato "{name}"',
        paramSpecArgsKwargsDuplicate: 'Gli argomenti per ParamSpec "{type}" sono gi stati specificati',
        paramSpecArgsKwargsUsage: 'Gli attributi "args" e "kwargs" di ParamSpec devono essere entrambi visualizzati all\'interno di una firma di funzione',
        paramSpecArgsMissing: 'Gli argomenti per ParamSpec "{type}" sono mancanti',
        paramSpecArgsUsage: 'L\'attributo "args" di ParamSpec  valido solo se usato con il parametro *args',
        paramSpecAssignedName: 'ParamSpec deve essere assegnato a una variabile denominata "{name}"',
        paramSpecContext: 'ParamSpec non  consentito in questo contesto',
        paramSpecDefaultNotTuple: 'Sono previsti puntini di sospensione, un\'espressione di tuple o ParamSpec per il valore predefinito di ParamSpec',
        paramSpecFirstArg: 'Nome previsto di ParamSpec come primo argomento',
        paramSpecKwargsUsage: 'L\'attributo "kwargs" di ParamSpec  valido solo se usato con il parametro **kwargs',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" non ha significato in questo contesto',
        paramSpecUnknownArg: 'ParamSpec non supporta pi di un argomento',
        paramSpecUnknownMember: '"{name}" non  un attributo noto di ParamSpec',
        paramSpecUnknownParam: '"{name}"  un parametro sconosciuto per ParamSpec',
        paramTypeCovariant: 'Non  possibile usare la variabile di tipo covariante nel tipo di parametro',
        paramTypePartiallyUnknown: 'Tipo di parametro "{paramName}" parzialmente sconosciuto',
        paramTypeUnknown: 'Tipo di parametro "{paramName}" sconosciuto',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Il criterio non verr mai confrontato per il tipo di oggetto "{type}"',
        positionArgAfterNamedArg: 'L\'argomento posizionale non pu essere visualizzato dopo gli argomenti della parola chiave',
        positionOnlyAfterArgs: 'Separatore di parametri di sola posizione non consentito dopo il parametro "*"',
        positionOnlyAfterKeywordOnly: 'Il parametro "/" deve essere visualizzato prima del parametro "*"',
        positionOnlyAfterNon: 'Il parametro di sola posizione non  consentito dopo un parametro che non  di sola posizione',
        positionOnlyFirstParam: 'Separatore di argomenti di sola posizione non consentito come primo parametro',
        positionOnlyIncompatible: 'Il separatore di parametri di sola posizione richiede Python 3.8 o versione successiva',
        privateImportFromPyTypedModule: '"{name}" non  esportato dal modulo "{module}"',
        privateUsedOutsideOfClass: '"{name}"  privato e utilizzato all\'esterno del modulo in cui  dichiarato',
        privateUsedOutsideOfModule: '"{name}"  privato e utilizzato all\'esterno del modulo in cui  dichiarato',
        propertyOverridden: '"{name}" esegue erroneamente loverride di una property con lo stesso nome nella classe "{className}"',
        propertyStaticMethod: 'Metodi statici non consentiti per getter, setter o deleter di property',
        protectedUsedOutsideOfClass: '"{name}"  protetto e usato al di fuori della classe in cui  dichiarato',
        protocolBaseClass: 'La classe Protocol "{classType}" non pu derivare dalla classe non Protocol "{baseType}"',
        protocolBaseClassWithTypeArgs: 'Gli argomenti tipo non sono consentiti con la classe Protocollo quando si usa la sintassi dei parametri tipo',
        protocolIllegal: 'L\'uso di "Protocol" richiede Python 3.7 o versione successiva',
        protocolNotAllowed: '"Protocol" non pu essere usato in questo contesto',
        protocolTypeArgMustBeTypeParam: 'L\'argomento di tipo per "Protocol" deve essere un parametro di tipo',
        protocolUnsafeOverlap: 'La classe si sovrappone a "{name}" in modo non sicuro e pu produrre una corrispondenza in fase di esecuzione',
        protocolVarianceContravariant: 'La variabile di tipo "{variable}" usata in "{class}" Protocol generico deve essere controvariante',
        protocolVarianceCovariant: 'La variabile di tipo "{variable}" usata in "{class}" Protocol generico deve essere covariante',
        protocolVarianceInvariant: 'La variabile di tipo "{variable}" usata in "{class}" Protocol generico deve essere invariante',
        pyrightCommentInvalidDiagnosticBoolValue: 'La direttiva di commento Pyright deve essere seguita da "=" e da un valore true o false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'La direttiva di commento Pyright deve essere seguita da "=" e da un valore true, false, error, warning, information o none',
        pyrightCommentMissingDirective: 'Il commento Pyright deve essere seguito da una direttiva (basic o strict) o da una regola di diagnostica',
        pyrightCommentNotOnOwnLine: 'I commenti Pyright usati per controllare le impostazioni a livello di file devono essere visualizzati nella propria riga',
        pyrightCommentUnknownDiagnosticRule: '"{rule}"  una regola di diagnostica sconosciuta per il commento pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" non  un valore valido per il commento pyright; previsto true, false, error, warning, information o none',
        pyrightCommentUnknownDirective: '"{directive}"  una direttiva sconosciuta per il commento pyright; previsto "strict" o "basic"',
        readOnlyArgCount: 'Previsto un singolo argomento tipo dopo "ReadOnly"',
        readOnlyNotInTypedDict: '"ReadOnly" non consentito in questo contesto',
        recursiveDefinition: 'Non  stato possibile determinare il tipo di "{name}" perch fa riferimento a se stesso',
        relativeImportNotAllowed: 'Le importazioni relative non possono essere usate con il modulo "import .a". Usare invece "from . import a"',
        requiredArgCount: ' previsto un singolo argomento di tipo dopo "Required"',
        requiredNotInTypedDict: '"Required" non  consentito in questo contesto',
        returnInAsyncGenerator: 'Listruzione return con valore non  consentita nel generatore async',
        returnInExceptionGroup: '"return" non consentito in un blocco "except*"',
        returnMissing: 'La funzione con tipo restituito dichiarato "{returnType}" deve restituire un valore in tutti i percorsi di codice',
        returnOutsideFunction: '"return" pu essere usata solo all\'interno di una funzione.',
        returnTypeContravariant: 'Non  possibile usare la variabile di tipo controvariante nel tipo restituito',
        returnTypeMismatch: 'Il tipo "{exprType}" non  assegnabile al tipo restituito "{returnType}"',
        returnTypePartiallyUnknown: 'Il tipo restituito "{returnType}"  parzialmente sconosciuto',
        returnTypeUnknown: 'Il tipo restituito  sconosciuto',
        revealLocalsArgs: 'Non  previsto alcun argomento per la chiamata "reveal_locals"',
        revealLocalsNone: 'Non sono presenti variabili locals in questo ambito',
        revealTypeArgs: 'Previsto un singolo argomento posizionale per la chiamata "reveal_type"',
        revealTypeExpectedTextArg: 'L\'argomento "expected_text" per la funzione "reveal_type" deve essere un valore letterale str',
        revealTypeExpectedTextMismatch: 'Testo di tipo non corrispondente; previsto "{expected}" ma ricevuto "{received}"',
        revealTypeExpectedTypeMismatch: 'Tipo non corrispondente; previsto "{expected}" ma ricevuto "{received}"',
        selfTypeContext: '"Self" non  valido in questo contesto',
        selfTypeMetaclass: 'Impossibile utilizzare Self all\'interno di una metaclasse (una sottoclasse di type)',
        selfTypeWithTypedSelfOrCls: 'Non  possibile usare "Self" in una funzione con un parametro \'self\' o \'cls\' con un\'annotazione di tipo diversa da "Self"',
        setterGetterTypeMismatch: 'Il tipo di valore del setter di Property non  assegnabile al tipo restituito del getter',
        singleOverload: '"{name}"  contrassegnato come overload, ma mancano altri overload',
        slotsAttributeError: '"{name}" non  specificato in __slots__',
        slotsClassVarConflict: '"{name}"  in conflitto con la variabile di istanza dichiarata in __slots__',
        starPatternInAsPattern: 'Il modello a stella non pu essere usato con la destinazione "as"',
        starPatternInOrPattern: 'Il modello a stella non pu essere ORed all\'interno di altri modelli',
        starStarWildcardNotAllowed: '** non pu essere usato con il carattere jolly "_"',
        staticClsSelfParam: 'I metodi statici non devono accettare un parametro "self" o "cls"',
        stdlibModuleOverridden: '"{path}" sta eseguendo l\'override del modulo stdlib "{name}"',
        stringNonAsciiBytes: 'Carattere non ASCII non consentito nel valore letterale stringa dei byte',
        stringNotSubscriptable: 'L\'espressione stringa non pu essere in pedice nell\'espressione di tipo. Racchiudere l\'intera espressione tra virgolette',
        stringUnsupportedEscape: 'Sequenza di escape non supportata nel valore letterale stringa',
        stringUnterminated: 'Il valore letterale stringa non  terminato',
        stubFileMissing: 'File di stub non trovato per "{importName}"',
        stubUsesGetAttr: 'Il file dello stub di tipo  incompleto; "__getattr__" nasconde gli errori di tipo per il modulo',
        sublistParamsIncompatible: 'I parametri di sublist non sono supportati in Python 3.x',
        superCallArgCount: 'Non sono previsti pi di due argomenti per la chiamata "super".',
        superCallFirstArg: ' previsto un tipo di classe come primo argomento della chiamata "super", ma  stato ricevuto "{type}"',
        superCallSecondArg: 'Il secondo argomento della chiamata "super" deve essere un oggetto o una classe che deriva da "{type}"',
        superCallZeroArgForm: 'Il modulo zero-argument della chiamata "super"  valido solo all\'interno di un metodo',
        superCallZeroArgFormStaticMethod: 'Il modulo zero-argument della chiamata "super" non  valido all\'interno di un metodo statico',
        symbolIsPossiblyUnbound: '"{name}" potrebbe non essere associato',
        symbolIsUnbound: '"{name}" non associato',
        symbolIsUndefined: '"{name}" non  definito',
        symbolOverridden: '"{name}" esegue l\'override del simbolo con lo stesso nome nella classe "{className}"',
        ternaryNotAllowed: 'Espressione ternaria non consentita nell\'espressione di tipo',
        totalOrderingMissingMethod: 'La classe deve definire uno dei valori di "__lt__", "__le__", "__gt__" o "__ge__" per usare total_ordering',
        trailingCommaInFromImport: 'Virgola finale non consentita senza parentesi circostanti',
        tryWithoutExcept: 'L\'istruzione Try deve contenere almeno una clausola except or finally',
        tupleAssignmentMismatch: 'Non  possibile assegnare l\'espressione con tipo "{type}" al tuple di destinazione',
        tupleInAnnotation: 'Espressione di tuple non consentita nell\'espressione del tipo',
        tupleIndexOutOfRange: 'L\'indice {index} non  compreso nell\'intervallo per il tipo {type}',
        typeAliasIllegalExpressionForm: 'Modulo di espressione non valido per la definizione dell\'alias di tipo',
        typeAliasIsRecursiveDirect: 'L\'alias di tipo "{name}" non pu usare se stesso nella relativa definizione',
        typeAliasNotInModuleOrClass: 'TypeAlias pu essere definito solo all\'interno di un modulo o di una classe',
        typeAliasRedeclared: '"{name}"  dichiarato come TypeAlias e pu essere assegnato una sola volta',
        typeAliasStatementBadScope: 'Un\'istruzione type pu essere usata solo all\'interno di un modulo o di un ambito della classe',
        typeAliasStatementIllegal: 'L\'istruzione alias di tipo richiede Python 3.12 o versione successiva',
        typeAliasTypeBaseClass: 'Impossibile utilizzare come classe di base un alias di tipo definito in un\'istruzione "type"',
        typeAliasTypeMustBeAssigned: 'TypeAliasType deve essere assegnato a una variabile con lo stesso nome dell\'alias di tipo',
        typeAliasTypeNameArg: 'Il primo argomento di TypeAliasType deve essere un valore letterale stringa che rappresenta il nome dell\'alias di tipo',
        typeAliasTypeNameMismatch: 'Il nome dell\'alias di tipo deve corrispondere al nome della variabile a cui  assegnato',
        typeAliasTypeParamInvalid: 'L\'elenco dei parametri di tipo deve essere un tuple contenente solo TypeVar, TypeVarTuple o ParamSpec.',
        typeAnnotationCall: 'Espressione di chiamata non consentita nell\'espressione di tipo',
        typeAnnotationVariable: 'Variabile non consentita nell\'espressione di tipo',
        typeAnnotationWithCallable: 'L\'argomento di tipo per "type" deve essere una classe. I callable non sono supportati',
        typeArgListExpected: 'Sono previsti ParamSpec, puntini di sospensione o elenco di list',
        typeArgListNotAllowed: 'Espressione di List non consentita per questo argomento di tipo',
        typeArgsExpectingNone: 'Non sono previsti argomenti di tipo per la classe "{name}"',
        typeArgsMismatchOne: 'Previsto un argomento di tipo, ricevuto {received}',
        typeArgsMissingForAlias: 'Sono previsti argomenti di tipo per l\'alias di tipo generico "{name}"',
        typeArgsMissingForClass: 'Argomenti tipo previsti per la classe generica "{name}"',
        typeArgsTooFew: 'Troppo pochi argomenti tipo forniti per "{name}"; previsto {expected} ma ricevuto {received}',
        typeArgsTooMany: 'Troppi argomenti tipo forniti per "{name}"; previsto {expected} ma ricevuto {received}',
        typeAssignmentMismatch: 'Il tipo "{sourceType}" non  assegnabile al tipo dichiarato "{destType}"',
        typeAssignmentMismatchWildcard: 'Il simbolo di importazione "{name}" ha il tipo "{sourceType}", che non  assegnabile al tipo dichiarato "{destType}"',
        typeCallNotAllowed: 'la chiamata type() non deve essere usata nell\'espressione di tipo',
        typeCheckOnly: '"{name}"  contrassegnato come @type_check_only e pu essere utilizzato solo nelle annotazioni tipo',
        typeCommentDeprecated: 'L\'uso dei commenti di type  deprecato. Usare invece l\'annotazione type',
        typeExpectedClass: 'Classe prevista ma ricevuta "{type}"',
        typeFormArgs: '"TypeForm" accetta un singolo argomento posizionale',
        typeGuardArgCount: ' previsto un singolo argomento di tipo dopo "TypeGuard" o "TypeIs"',
        typeGuardParamCount: 'Le funzioni e i metodi di protezione dei tipi definiti dall\'utente devono avere almeno un parametro di input',
        typeIsReturnType: 'Il tipo restituito di TypeIs ("{returnType}") non  coerente con il tipo di parametro di valore ("{type}")',
        typeNotAwaitable: '"{type}" non  awaitable',
        typeNotIntantiable: 'Non  possibile creare un\'istanza di "{type}"',
        typeNotIterable: '"{type}" non  iterabile',
        typeNotSpecializable: 'Non  stato possibile specializzare il tipo "{type}"',
        typeNotSubscriptable: 'L\'oggetto di tipo "{type}" non  sottoponibile a script',
        typeNotSupportBinaryOperator: 'L\'operatore "{operator}" non  supportato per i tipi "{leftType}" e "{rightType}".',
        typeNotSupportBinaryOperatorBidirectional: 'L\'operatore "{operator}" non  supportato per i tipi "{leftType}" e "{rightType}" quando il tipo previsto  "{expectedType}"',
        typeNotSupportUnaryOperator: 'Operatore "{operator}" non supportato per il tipo "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'L\'operatore "{operator}" non  supportato per il tipo "{type}" quando il tipo previsto  "{expectedType}"',
        typeNotUsableWith: 'Impossibile utilizzare l\'oggetto di tipo "{type}" con "with" perch non implementa {method}',
        typeParameterBoundNotAllowed: 'Il vincolo o il binding non possono essere usati con un parametro di tipo variadic o ParamSpec',
        typeParameterConstraintTuple: 'Il vincolo del parametro di tipo deve essere una tupla di due o pi tipi',
        typeParameterExistingTypeParameter: 'Il parametro di tipo "{name}"  gi in uso',
        typeParameterNotDeclared: 'Il parametro di tipo "{name}" non  incluso nell\'elenco dei parametri di tipo per "{container}"',
        typeParametersMissing: ' necessario specificare almeno un parametro di tipo',
        typePartiallyUnknown: 'Tipo di "{name}" parzialmente sconosciuto',
        typeUnknown: 'Il tipo di "{name}"  sconosciuto',
        typeVarAssignedName: 'TypeVar deve essere assegnato a una variabile denominata "{name}"',
        typeVarAssignmentMismatch: 'Non  possibile assegnare il tipo "{type}" alla variabile di tipo "{name}"',
        typeVarBoundAndConstrained: 'TypeVar non pu essere contemporaneamente associato e vincolato',
        typeVarBoundGeneric: 'Il tipo associato a TypeVar non pu essere generico',
        typeVarConstraintGeneric: 'Il tipo di vincolo TypeVar non pu essere generico',
        typeVarDefaultBoundMismatch: 'Il tipo predefinito TypeVar deve essere un sottotipo del tipo associato',
        typeVarDefaultConstraintMismatch: 'Il tipo predefinito TypeVar deve essere uno dei tipi vincolati',
        typeVarDefaultIllegal: 'I tipi predefiniti delle variabili di tipo richiedono Python 3.13 o versione successiva',
        typeVarDefaultInvalidTypeVar: 'Il parametro di tipo "{name}" ha un tipo predefinito che fa riferimento a una o pi variabili di tipo non compreso nell\'ambito',
        typeVarFirstArg: 'Nome previsto di TypeVar come primo argomento',
        typeVarInvalidForMemberVariable: 'Il tipo di attributo non pu usare la variabile di tipo "{name}" con ambito del metodo locale',
        typeVarNoMember: 'TypeVar "{type}" non ha alcun attributo "{name}"',
        typeVarNotSubscriptable: 'TypeVar "{type}" non sottoponibile a script',
        typeVarNotUsedByOuterScope: 'La variabile di tipo "{name}" non ha significato in questo contesto',
        typeVarPossiblyUnsolvable: 'La variabile di tipo "{name}" potrebbe non essere risolta se il chiamante non fornisce alcun argomento per il parametro "{param}"',
        typeVarSingleConstraint: 'TypeVar deve contenere almeno due tipi vincolati',
        typeVarTupleConstraints: 'TypeVarTuple non pu avere vincoli di valore',
        typeVarTupleContext: 'TypeVarTuple non  consentito in questo contesto',
        typeVarTupleDefaultNotUnpacked: 'Il tipo predefinito TypeVarTuple deve essere un tuple non compresso o TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'L\'operatore Decomprimi  obbligatorio per il valore TypeVarTuple',
        typeVarTupleUnknownParam: '"{name}"  un parametro sconosciuto per TypeVarTuple',
        typeVarUnknownParam: '"{name}"  un parametro sconosciuto per TypeVar',
        typeVarUsedByOuterScope: 'TypeVar "{name}" gi in uso da un ambito esterno',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" viene visualizzato una sola volta nella firma della funzione generica',
        typeVarVariance: 'TypeVar non pu essere covariante e controvariante',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}" ha un valore predefinito e non pu seguire TypeVarTuple "{variadicName}"',
        typeVarWithoutDefault: '"{name}" non pu essere visualizzato dopo "{other}" nell\'elenco dei parametri del tipo, perch non ha un tipo predefinito',
        typeVarsNotInGenericOrProtocol: 'Generic[] o Protocol[] deve includere tutte le variabili di tipo',
        typedDictAccess: 'Non  stato possibile accedere all\'elemento in TypedDict',
        typedDictAssignedName: 'TypedDict deve essere assegnato a una variabile denominata "{name}"',
        typedDictBadVar: 'Le classi TypedDict possono contenere solo annotazioni di tipo',
        typedDictBaseClass: 'Anche tutte le classi di base per le classi TypedDict devono essere classi TypedDict',
        typedDictBoolParam: ' previsto che il parametro "{name}" abbia il valore True o False',
        typedDictClosedExtras: 'La classe di base "{name}"  un TypedDict closed; gli elementi aggiuntivi devono essere di tipo "{type}"',
        typedDictClosedNoExtras: 'La classe di base "{name}"  un TypedDict closed; elementi aggiuntivi non consentiti',
        typedDictDelete: 'Non  stato possibile eliminare l\'elemento in TypedDict',
        typedDictEmptyName: 'I nomi all\'interno di un TypedDict non possono essere vuoti',
        typedDictEntryName: 'Valore letterale stringa previsto per il nome della voce del dizionario',
        typedDictEntryUnique: 'I nomi all\'interno di un dizionario devono essere univoci',
        typedDictExtraArgs: 'Argomenti TypedDict aggiuntivi non supportati',
        typedDictExtraItemsClosed: 'TypedDict non pu avere il valore closed se supporta elementi aggiuntivi',
        typedDictFieldNotRequiredRedefinition: 'Non  possibile ridefinire il campo TypedDict "{name}" come NotRequired',
        typedDictFieldReadOnlyRedefinition: 'Non  possibile ridefinire lelemento TypedDict "{name}" come ReadOnly',
        typedDictFieldRequiredRedefinition: 'Non  possibile ridefinire il campo TypedDict "{name}" come Required',
        typedDictFirstArg: ' previsto il nome della classe TypedDict come primo argomento',
        typedDictInClassPattern: 'Classe TypedDict non consentita nel modello di classe',
        typedDictInitsubclassParameter: 'TypedDict non supporta __init_subclass__ parametro {name}',
        typedDictNotAllowed: '"TypedDict" non pu essere usato in questo contesto',
        typedDictSecondArgDict: 'Previsto parametro dict o keyword come secondo parametro',
        typedDictSecondArgDictEntry: 'Voce di dizionario semplice prevista',
        typedDictSet: 'Non  stato possibile assegnare l\'elemento in TypedDict',
        unaccessedClass: 'La classe "{name}" non  accessibile',
        unaccessedFunction: 'La classe "{name}" non  accessibile',
        unaccessedImport: 'Non  possibile accedere all\'importazione "{name}"',
        unaccessedSymbol: 'Non  possibile accedere a "{name}"',
        unaccessedVariable: 'La variabile "{name}" non  accessibile',
        unannotatedFunctionSkipped: 'L\'analisi della funzione "{name}"  stata ignorata perch non  annotata',
        unaryOperationNotAllowed: 'Operatore unario non consentito nell\'espressione di tipo',
        unexpectedAsyncToken: ' previsto che "def", "with" o "for" seguano "async"',
        unexpectedExprToken: 'Token imprevisto alla fine dell\'espressione',
        unexpectedIndent: 'Rientro imprevisto',
        unexpectedUnindent: 'Riduci rientro non previsto',
        unhashableDictKey: 'La chiave del dizionario deve essere hashable',
        unhashableSetEntry: 'La voce set deve essere hashable',
        uninitializedAbstractVariables: 'Le variabili definite nella classe di base astratta non vengono inizializzate nella classe finale "{classType}"',
        uninitializedInstanceVariable: 'La variabile di istanza "{name}" non  inizializzata nel corpo della classe o nel metodo __init__',
        unionForwardReferenceNotAllowed: 'Impossibile utilizzare la sintassi di Union con l\'operando stringa. Usare virgolette intorno all\'intera espressione',
        unionSyntaxIllegal: 'La sintassi alternativa per le unioni richiede Python 3.10 o versione successiva',
        unionTypeArgCount: 'Unione richiede due o pi argomenti di tipo',
        unionUnpackedTuple: 'Union non pu includere un tuple decompresso',
        unionUnpackedTypeVarTuple: 'Union non pu includere un TypeVarTuple non compresso',
        unnecessaryCast: 'Chiamata "cast" non necessaria; il tipo  gi "{type}"',
        unnecessaryIsInstanceAlways: 'Chiamata isinstance non necessaria; "{testType}"  sempre un\'istanza di "{classType}"',
        unnecessaryIsInstanceNever: 'Chiamata isinstance non necessaria; "{testType}" non  mai un\'istanza di "{classType}"',
        unnecessaryIsSubclassAlways: 'Chiamata issubclass non necessaria; "{testType}"  sempre una sottoclasse di "{classType}"',
        unnecessaryIsSubclassNever: 'Chiamata issubclass non necessaria; "{testType}" non  mai una sottoclasse di "{classType}"',
        unnecessaryPyrightIgnore: 'Commento "# pyright: ignore" non necessario',
        unnecessaryPyrightIgnoreRule: 'Regola "# pyright: ignore" non necessaria: "{name}"',
        unnecessaryTypeIgnore: 'Commento "# type: ignore" non necessario',
        unpackArgCount: 'Previsto un singolo argomento di tipo dopo "Unpack"',
        unpackExpectedTypeVarTuple: ' previsto TypeVarTuple o tuple come argomento di tipo per Unpack',
        unpackExpectedTypedDict: 'Previsto argomento di tipo TypedDict per Unpack',
        unpackIllegalInComprehension: 'Operazione di decompressione non consentita nella comprensione',
        unpackInAnnotation: 'Operatore di decompressione non consentito nell\'espressione di tipo',
        unpackInDict: 'Operazione di decompressione non consentita nei dizionari',
        unpackInSet: 'Operatore di decompressione non consentito allinterno di un set',
        unpackNotAllowed: 'Unpack non  consentito in questo contesto',
        unpackOperatorNotAllowed: 'Loperazione di decompressione non  consentita in questo contesto',
        unpackTuplesIllegal: 'L\'operazione di decompressione non  consentita nelle tuple precedenti a Python 3.8',
        unpackedArgInTypeArgument: 'Non  possibile usare argomenti decompressi in questo contesto',
        unpackedArgWithVariadicParam: 'Non  possibile usare l\'argomento decompresso per il parametro TypeVarTuple',
        unpackedDictArgumentNotMapping: 'L\'espressione dell\'argomento dopo ** deve essere un mapping con un tipo di chiave "str"',
        unpackedDictSubscriptIllegal: 'L\'operatore di decompressione del dizionario nel pedice non  consentito',
        unpackedSubscriptIllegal: 'L\'operatore di decompressione nel pedice richiede Python 3.11 o versione successiva',
        unpackedTypeVarTupleExpected: 'Previsto TypeVarTuple decompresso; usa Unpack[{name1}] o *{name2}',
        unpackedTypedDictArgument: 'Impossibile trovare una corrispondenza tra l\'argomento TypedDict non compresso e i parametri',
        unreachableCode: 'Il codice non  raggiungibile',
        unreachableCodeType: 'Lanalisi dei tipi indica che il codice non  raggiungibile.',
        unreachableExcept: 'La clausola Except non  raggiungibile perch l\'eccezione  gi gestita',
        unsupportedDunderAllOperation: 'L\'operazione su "__all__" non  supportata, di conseguenza l\'elenco dei simboli esportati potrebbe non essere corretto',
        unusedCallResult: 'Il risultato dell\'espressione di chiamata  di tipo "{type}" e non  usato. Assegnare alla variabile "_" se  intenzionale',
        unusedCoroutine: 'Il risultato della chiamata alla funzione async non viene usato. Usare "await" o assegnare il risultato alla variabile',
        unusedExpression: 'Il valore dell\'espressione non  utilizzato',
        varAnnotationIllegal: 'Le annotazioni type per le variabili richiedono Python 3.6 o versione successiva. Usare il commento di type per la compatibilit con le versioni precedenti',
        variableFinalOverride: 'La variabile "{name}"  contrassegnata come Final ed esegue l\'override della variabile non Final con lo stesso nome nella classe "{className}"',
        variadicTypeArgsTooMany: 'L\'elenco di argomenti del tipo pu contenere al massimo un tuple o TypeVarTuple non compresso',
        variadicTypeParamTooManyAlias: 'L\'alias di tipo pu avere al massimo un parametro di tipo TypeVarTuple, ma ne ha ricevuti pi ({names})',
        variadicTypeParamTooManyClass: 'La classe generica pu avere al massimo un parametro di tipo TypeVarTuple, ma ne ha ricevuti pi ({names})',
        walrusIllegal: 'L\'operatore ":=" richiede Python 3.8 o versione successiva',
        walrusNotAllowed: 'L\'operatore ":=" non  consentito in questo contesto senza parentesi circostanti',
        wildcardInFunction: 'Wildcard import non consentito all\'interno di una classe o di una funzione',
        wildcardLibraryImport: 'Wildcard import da una libreria non consentito',
        wildcardPatternTypePartiallyUnknown: 'Il tipo acquisito dal modello con caratteri jolly  parzialmente sconosciuto',
        wildcardPatternTypeUnknown: 'Il tipo acquisito dal criterio con caratteri jolly  sconosciuto',
        yieldFromIllegal: 'L\'uso di "yield from" richiede Python 3.3 o versione successiva',
        yieldFromOutsideAsync: '"yield from" non consentito in una funzione async',
        yieldOutsideFunction: '"yield" non consentito all\'esterno di una funzione o di un\'espressione lambda',
        yieldWithinComprehension: '"yield" non consentito all\'interno di una comprensione',
        zeroCaseStatementsFound: 'Listruzione Match deve includere almeno unistruzione case',
        zeroLengthTupleNotAllowed: 'Zero-length tuple is not allowed in this context'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Non  possibile usare il modulo speciale "Annotated" con controlli di istanza e classe',
        argParam: 'L\'argomento corrisponde al parametro "{paramName}"',
        argParamFunction: 'L\'argomento corrisponde al parametro "{paramName}" nella funzione "{functionName}"',
        argsParamMissing: 'Il parametro "*{paramName}" non ha un parametro corrispondente',
        argsPositionOnly: 'Parametro di sola posizione non corrispondente; previsto {expected} ma ricevuto {received}',
        argumentType: 'Il tipo di argomento  "{type}"',
        argumentTypes: 'Tipi di argomento: ({types})',
        assignToNone: 'Il tipo non  assegnabile a "None"',
        asyncHelp: 'Intendevi "async with"?',
        baseClassIncompatible: 'La classe base "{baseClass}" non  compatibile con il tipo "{type}"',
        baseClassIncompatibleSubclass: 'La classe base "{baseClass}" deriva da "{subclass}", che non  compatibile con il tipo "{type}"',
        baseClassOverriddenType: 'La classe di base "{baseClass}" fornisce il tipo "{type}", di cui viene eseguito l\'override',
        baseClassOverridesType: 'Override della classe base "{baseClass}" con tipo "{type}"',
        bytesTypePromotions: 'Imposta disableBytesTypePromotions su false per abilitare il comportamento di innalzamento di livello del tipo per "bytearray" e "memoryview"',
        conditionalRequiresBool: 'Il metodo __bool__ per il tipo "{operandType}" restituisce il tipo "{boolReturnType}" anzich "bool"',
        dataClassFieldLocation: 'Dichiarazione di campo',
        dataClassFrozen: '"{name}"  bloccato',
        dataProtocolUnsupported: '{name}  un protocollo dati',
        descriptorAccessBindingFailed: 'Impossibile associare il metodo "{name}" per la classe descrittore "{className}"',
        descriptorAccessCallFailed: 'Impossibile chiamare il metodo "{name}" per la classe descrittore "{className}"',
        finalMethod: 'Metodo Final',
        functionParamDefaultMissing: 'Nel parametro "{name}" manca un argomento predefinito',
        functionParamName: 'Nome del parametro non corrispondente: "{destName}" rispetto a "{srcName}"',
        functionParamPositionOnly: 'Parametro di sola posizione non corrispondente; il parametro {name} non  di sola posizione',
        functionReturnTypeMismatch: 'Il tipo restituito della funzione"{sourceType}" non  compatibile con il tipo "{destType}"',
        functionTooFewParams: 'La funzione accetta un numero insufficiente di parametri posizionale. Previsto {expected} ma ricevuto {received}',
        functionTooManyParams: 'La funzione accetta un numero eccessivo di parametri posizionale. Previsto {expected} ma ricevuto {received}',
        genericClassNotAllowed: 'Tipo generico con argomenti di tipo non consentiti per i controlli di istanza o classe',
        incompatibleDeleter: 'Il metodo deleter di Property non  compatibile',
        incompatibleGetter: 'Il metodo getter di Property non  compatibile',
        incompatibleSetter: 'Il metodo setter di Property non  compatibile',
        initMethodLocation: 'Il metodo __init__  definito nella classe "{type}"',
        initMethodSignature: 'Firma del __init__ "{type}"',
        initSubclassLocation: 'Il metodo __init_subclass__  definito nella classe "{name}"',
        invariantSuggestionDict: 'Prova a passare da "dict" a "Mapping", che  covariante nel tipo di valore',
        invariantSuggestionList: 'Prova a passare da "list" a "Sequence", che  covariante',
        invariantSuggestionSet: 'Prova a passare da "set" a "Container", che  covariante',
        isinstanceClassNotSupported: '"{type}" non  supportata per i controlli delle istanze e delle classi',
        keyNotRequired: '"{name}" non  una chiave obbligatoria in "{type}", quindi l\'accesso potrebbe causare un\'eccezione di runtime',
        keyReadOnly: '"{name}"  una chiave di sola lettura in "{type}"',
        keyRequiredDeleted: '"{name}"  una chiave obbligatoria e non pu essere eliminata',
        keyUndefined: '"{name}" non  una chiave definita in "{type}"',
        kwargsParamMissing: 'Il parametro "**{paramName}" non ha un parametro corrispondente',
        listAssignmentMismatch: 'Il tipo "{type}" non  compatibile con l\'elenco di destinazione',
        literalAssignmentMismatch: '"{sourceType}" non  assegnabile al tipo "{destType}"',
        matchIsNotExhaustiveHint: 'Se la gestione completa non  prevista, aggiungere "case _: pass"',
        matchIsNotExhaustiveType: 'Tipo non gestito: "{type}"',
        memberAssignment: 'L\'espressione di tipo "{type}" non pu essere assegnata all\'attributo "{name}" della classe "{classType}".',
        memberIsAbstract: '"{type}.{name}" non implementato',
        memberIsAbstractMore: 'e {{count}} altro...',
        memberIsClassVarInProtocol: '{name}  definito come ClassVar nel protocollo',
        memberIsInitVar: '"{name}"  un campo di init-only',
        memberIsInvariant: '"{name}"  invariante perch modificabile',
        memberIsNotClassVarInClass: '"{name}" deve essere definito come ClassVar per essere compatibile con il protocollo',
        memberIsNotClassVarInProtocol: '{name} non  definito come ClassVar nel protocollo',
        memberIsNotReadOnlyInProtocol: '"{name}" non  di sola lettura nel protocollo',
        memberIsReadOnlyInProtocol: '"{name}"  di sola lettura nel protocollo',
        memberIsWritableInProtocol: '"{name}"  scrivibile nel protocollo',
        memberSetClassVar: 'Non  possibile assegnare l\'attributo "{name}" tramite un\'istanza di classe perch  una ClassVar',
        memberTypeMismatch: '"{name}"  un tipo non compatibile',
        memberUnknown: 'L\'attributo "{name}"  sconosciuto',
        metaclassConflict: 'La metaclasse "{metaclass1}"  in conflitto con "{metaclass2}"',
        missingDeleter: 'Metodo deleter di Property mancante',
        missingGetter: 'Metodo getter di Property mancante',
        missingSetter: 'Metodo setter di Property mancante',
        namedParamMissingInDest: 'Parametro aggiuntivo {name}',
        namedParamMissingInSource: 'Parametro della parola chiave {name} mancante',
        namedParamTypeMismatch: 'Il parametro "{name}" della parola chiave di tipo "{sourceType}" non  compatibile con il tipo "{destType}"',
        namedTupleNotAllowed: 'Non  possibile usare NamedTuple per i controlli di istanze o classi',
        newMethodLocation: 'Il metodo __new__  definito nella classe "{type}"',
        newMethodSignature: 'La firma del __new__  "{type}"',
        newTypeClassNotAllowed: 'Impossibile utilizzare la classe creata con NewType con controlli di classe e di istanza',
        noOverloadAssignable: 'Nessuna funzione di overload corrisponde al tipo "{type}"',
        noneNotAllowed: 'Non  possibile usare None per i controlli di istanze o classi',
        orPatternMissingName: 'Nomi mancanti: {name}',
        overloadIndex: 'L\'overload {index}  la corrispondenza pi vicina',
        overloadNotAssignable: 'Uno o pi overload di "{name}" non sono assegnabili',
        overloadSignature: 'La firma di overload  definita qui',
        overriddenMethod: 'Metodo sottoposto a override',
        overriddenSymbol: 'Simbolo sottoposto a override',
        overrideInvariantMismatch: 'Il tipo di override "{overrideType}" non  uguale al tipo di base "{baseType}"',
        overrideIsInvariant: 'La variabile  modificabile, quindi il relativo tipo  invariante',
        overrideNoOverloadMatches: 'Nessuna firma di overload nell\'override  compatibile con il metodo di base',
        overrideNotClassMethod: 'Il metodo di base viene dichiarato come classmethod, ma l\'override non lo ',
        overrideNotInstanceMethod: 'Il metodo di base  dichiarato come metodo di istanza, ma loverride non lo ',
        overrideNotStaticMethod: 'Il metodo di base viene dichiarato come staticmethod, ma l\'override non lo ',
        overrideOverloadNoMatch: 'La sostituzione non gestisce tutti gli overload del metodo di base',
        overrideOverloadOrder: 'Gli overload per il metodo di override devono essere nello stesso ordine del metodo di base',
        overrideParamKeywordNoDefault: 'Parametro della parola chiave "{name}" non corrispondente: il parametro di base ha un valore di argomento predefinito, il parametro di override non ',
        overrideParamKeywordType: 'Tipo del parametro della parola chiave "{name}" non corrispondente: il parametro di base  di tipo "{baseType}", il parametro di override  di tipo "{overrideType}"',
        overrideParamName: 'Nome del parametro {index} non corrispondente: il parametro di base  denominato "{baseName}", il parametro di override  denominato "{overrideName}"',
        overrideParamNameExtra: 'Parametro "{name}" mancante nella base',
        overrideParamNameMissing: 'Parametro "{name}" mancante nell\'override',
        overrideParamNamePositionOnly: 'Mancata corrispondenza del parametro {index}: il parametro di base "{baseName}"  un parametro di parola chiave, il parametro di override  di sola posizione',
        overrideParamNoDefault: 'Parametro "{index}" non corrispondente: il parametro di base ha un valore di argomento predefinito, il parametro di override non ',
        overrideParamType: 'Tipo di parametro {index} non corrispondente: il parametro di base  di tipo "{baseType}", il parametro di override  di tipo "{overrideType}"',
        overridePositionalParamCount: 'Numero di parametri posizionali non corrispondente. Il metodo di base ne ha {baseCount}, ma l\'override ne ha {overrideCount}',
        overrideReturnType: 'Tipo restituito non corrispondente: il metodo di base restituisce il tipo "{baseType}", l\'override restituisce il tipo "{overrideType}"',
        overrideType: 'La classe di base definisce il tipo come "{type}"',
        paramAssignment: 'Parametro {index}: il tipo "{sourceType}" non  compatibile con il tipo "{destType}"',
        paramSpecMissingInOverride: 'Parametri ParamSpec mancanti nel metodo di override',
        paramType: 'Tipo di parametro "{paramType}"',
        privateImportFromPyTypedSource: 'Importa da "{module}"',
        propertyAccessFromProtocolClass: 'Non  possibile accedere a una propriet definita all\'interno di una classe di protocollo come variabile di classe',
        propertyMethodIncompatible: 'Il metodo di Property "{name}" non  compatibile',
        propertyMethodMissing: 'Metodo di Property "{name}" mancante nell\'override',
        propertyMissingDeleter: 'Property "{name}" non dispone di un deleter definito',
        propertyMissingSetter: 'Property "{name}" non dispone di un setter definito',
        protocolIncompatible: '"{sourceType}" non  compatibile con il protocollo "{destType}"',
        protocolMemberMissing: '"{name}" non  presente',
        protocolRequiresRuntimeCheckable: 'La classe di Protocol deve essere @runtime_checkable in modo che sia possibile usarla con i controlli di istanza e classe',
        protocolSourceIsNotConcrete: '"{sourceType}" non  un tipo di classe concreto e non pu essere assegnato al tipo "{destType}"',
        protocolUnsafeOverlap: 'Gli attributi di {name} hanno gli stessi nomi del protocollo',
        pyrightCommentIgnoreTip: 'Usa "# pyright: ignore[<diagnostic rules>]" per eliminare la diagnostica per una singola riga',
        readOnlyAttribute: 'L\'attributo "{name}"  di sola lettura',
        seeClassDeclaration: 'Vedere la dichiarazione di classe',
        seeDeclaration: 'Vedere la dichiarazione',
        seeFunctionDeclaration: 'Vedere la dichiarazione di funzione',
        seeMethodDeclaration: 'Vedere la dichiarazione del metodo',
        seeParameterDeclaration: 'Vedere la dichiarazione del parametro',
        seeTypeAliasDeclaration: 'Vedere la dichiarazione di alias di tipo',
        seeVariableDeclaration: 'Vedere la dichiarazione di variabile',
        tupleAssignmentMismatch: 'Il tipo "{type}" non  compatibile con il tuple di destinazione',
        tupleEntryTypeMismatch: 'Il tipo della voce di Tuple {entry} non  corretto',
        tupleSizeIndeterminateSrc: 'Dimensioni del tuple non corrispondenti; previsto {expected} ma ricevuto indeterminato',
        tupleSizeIndeterminateSrcDest: 'Dimensioni del tuple non corrispondenti; previsto {expected} o pi, ma ricevuto indeterminato',
        tupleSizeMismatch: 'Dimensioni tuple non corrispondenti; previsto {expected} ma ricevuto {received}',
        tupleSizeMismatchIndeterminateDest: 'Dimensioni del tuple non corrispondenti; previsto {expected} o pi ma ricevuto {received}',
        typeAliasInstanceCheck: 'Non  possibile usare l\'alias di tipo creato con l\'istruzione "type" con controlli di classe e istanza',
        typeAssignmentMismatch: 'Il tipo "{sourceType}" non  assegnabile al tipo "{destType}"',
        typeBound: 'Il tipo "{sourceType}" non  assegnabile al limite superiore "{destType}" per la variabile di tipo "{name}"',
        typeConstrainedTypeVar: 'Il tipo "{type}" non  assegnabile alla variabile di tipo vincolato "{name}"',
        typeIncompatible: '"{sourceType}" non  assegnabile a "{destType}"',
        typeNotClass: '"{type}" non  una classe',
        typeNotStringLiteral: '"{type}" non  un valore letterale stringa',
        typeOfSymbol: 'Il tipo di "{name}"  "{type}"',
        typeParamSpec: 'Il tipo "{type}" non  compatibile con il "{name}" ParamSpec',
        typeUnsupported: 'Il tipo "{type}" non  supportato',
        typeVarDefaultOutOfScope: 'La variabile di tipo "{name}" non  nell\'ambito',
        typeVarIsContravariant: 'Il parametro di tipo "{name}"  controvariante, ma "{sourceType}" non  un supertipo di "{destType}"',
        typeVarIsCovariant: 'Il parametro di tipo "{name}"  covariante, ma "{sourceType}" non  un sottotipo di "{destType}"',
        typeVarIsInvariant: 'Il parametro di tipo "{name}"  invariante, ma "{sourceType}" non  uguale a "{destType}"',
        typeVarNotAllowed: 'TypeVar non consentito per i controlli di istanze o classi',
        typeVarTupleRequiresKnownLength: 'Non  possibile associare TypeVarTuple a un tuple di lunghezza sconosciuta',
        typeVarUnnecessarySuggestion: 'Usare invece {type}',
        typeVarUnsolvableRemedy: 'Specificare un overload che specifica il tipo restituito quando l\'argomento non viene fornito',
        typeVarsMissing: 'Variabili di tipo mancanti: {names}',
        typedDictBaseClass: 'La classe "{type}" non  un TypedDict',
        typedDictClassNotAllowed: 'Classe TypedDict non consentita per i controlli di istanze o classi',
        typedDictClosedExtraNotAllowed: 'Non  possibile aggiungere l\'elemento "{name}"',
        typedDictClosedExtraTypeMismatch: 'Non  possibile aggiungere l\'elemento "{name}" con tipo "{type}"',
        typedDictClosedFieldNotRequired: 'Non  possibile aggiungere l\'elemento "{name}" perch deve essere NotRequired',
        typedDictExtraFieldNotAllowed: '"{name}" non  presente in "{type}"',
        typedDictExtraFieldTypeMismatch: 'Il tipo di "{name}" non  compatibile con il tipo ""extra_items" in "{type}"',
        typedDictFieldMissing: '"{name}" mancante nel "{type}"',
        typedDictFieldNotReadOnly: '"{name}" non  di sola lettura in "{type}"',
        typedDictFieldNotRequired: '"{name}" non  obbligatorio in "{type}"',
        typedDictFieldRequired: '"{name}"  obbligatorio in "{type}"',
        typedDictFieldTypeMismatch: 'Il tipo "{type}" non pu essere assegnato allelemento "{name}"',
        typedDictFieldUndefined: '"{name}"  un elemento non definito nel tipo "{type}"',
        typedDictFinalMismatch: '"{sourceType}" non  compatibile con "{destType}" a causa di una @final mancata corrispondenza',
        typedDictKeyAccess: 'Usare ["{name}"] per fare riferimento all\'elemento in TypedDict',
        typedDictNotAllowed: 'Non  possibile usare TypedDict per i controlli di istanze o classi',
        unhashableType: 'Il tipo "{type}" non  hashable',
        uninitializedAbstractVariable: 'La variabile di istanza "{name}"  definita nella classe di base astratta "{classType}" ma non  inizializzata',
        unreachableExcept: '"{exceptionType}"  una sottoclasse di "{parentType}"',
        useDictInstead: 'Usare Dict[T1, T2] per indicare un tipo di dizionario',
        useListInstead: 'Usare List[T] per indicare un tipo di list o Union[T1, T2] per indicare un tipo di unione',
        useTupleInstead: 'Usare tuple[T1, ..., Tn] per indicare un tipo di tuple o Union[T1, T2] per indicare un tipo di unione',
        useTypeInstead: 'In alternativa, usare Type[T]',
        varianceMismatchForClass: 'La varianza dell\'argomento tipo "{typeVarName}" non  compatibile con la classe di base "{className}"',
        varianceMismatchForTypeAlias: 'La varianza dell\'argomento tipo "{typeVarName}" non  compatibile con "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'Lenumerazione dei file di origine dellarea di lavoro sta richiedendo tempo. Provare ad aprire una sottocartella. [Altre informazioni](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  3879: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: ' Stub ',
        createTypeStubFor: '"{moduleName}"  Stub ',
        executingCommand: '',
        filesToAnalyzeCount: ' {count} ',
        filesToAnalyzeOne: ' 1 ',
        findingReferences: '',
        organizeImports: '',
        renameShadowedFile: '"{oldFile}"  "{newFile}" '
      },
      Completion: {
        autoImportDetail: '',
        indexValueDetail: ''
      },
      Diagnostic: {
        abstractMethodInvocation: ' "{method}" ',
        annotatedMetadataInconsistent: ' "{metadataType}"  "{type}" ',
        annotatedParamCountMismatch: ': {expected} {received} ',
        annotatedTypeArgMissing: '"Annotated"  1  1 ',
        annotationBytesString: '',
        annotationFormatString: ' (f ) ',
        annotationNotSupported: '',
        annotationRawString: '',
        annotationSpansStrings: '',
        annotationStringEscape: '',
        argAssignment: ' "{argType}"  "{paramType}" ',
        argAssignmentFunction: ' "{argType}"  "{functionName}"  "{paramType}" ',
        argAssignmentParam: ' "{argType}"  "{paramType}"  "{paramName}" ',
        argAssignmentParamFunction: ' "{argType}"  "{functionName}"  "{paramType}"  "{paramName}" ',
        argMissingForParam: ' {name} ',
        argMissingForParams: ' {names} ',
        argMorePositionalExpectedCount: ' {expected} ',
        argMorePositionalExpectedOne: ' 1 ',
        argPositional: '',
        argPositionalExpectedCount: '{expected} ',
        argPositionalExpectedOne: '1 ',
        argTypePartiallyUnknown: '',
        argTypeUnknown: '',
        assertAlwaysTrue: 'Assert  true ',
        assertTypeArgs: '"assert_type"  2 ',
        assertTypeTypeMismatch: '"assert_type" : "{expected}" "{received}" ',
        assignmentExprComprehension: ' "{name}" ',
        assignmentExprContext: '',
        assignmentExprInSubscript: 'Python 3.10 ',
        assignmentInProtocol: 'Protocol ',
        assignmentTargetExpr: '',
        asyncNotInAsyncFunction: 'async  "async" ',
        awaitIllegal: '"await"  Python 3.5 ',
        awaitNotAllowed: '"await" ',
        awaitNotInAsync: '"await"  async ',
        backticksIllegal: 'Python 3.x  repr ',
        baseClassCircular: '',
        baseClassFinal: ' "{type}"  final ',
        baseClassIncompatible: '{type} ',
        baseClassInvalid: '',
        baseClassMethodTypeIncompatible: '"{classType}"  "{name}" ',
        baseClassUnknown: '',
        baseClassVariableTypeIncompatible: ' "{classType}"  "{name}" ',
        binaryOperationNotAllowed: '2 ',
        bindTypeMismatch: '"{type}"  "{paramName}"  "{methodName}" ',
        breakInExceptionGroup: '"except*"  "break" ',
        breakOutsideLoop: '"break" ',
        callableExtraArgs: '"Callable"  2 ',
        callableFirstArg: ' "..." ',
        callableNotInstantiable: ' "{type}" ',
        callableSecondArg: '"Callable"  2 ',
        casePatternIsIrrefutable: ' case ',
        classAlreadySpecialized: ' "{type}" ',
        classDecoratorTypeUnknown: ' ',
        classDefinitionCycle: '"{name}" ',
        classGetItemClsParam: '__class_getitem__ override  "cls" ',
        classMethodClsParam: '  "cls" ',
        classNotRuntimeSubscriptable: ' "{name}" ',
        classPatternBuiltInArgPositional: ' ',
        classPatternPositionalArgCount: ' "{type}" {expected} {received} ',
        classPatternTypeAlias: '"{type}"  ',
        classPropertyDeprecated: '  Python 3.11 Python 3.13 ',
        classTypeParametersIllegal: ' Python 3.12 ',
        classVarFirstArgMissing: '"ClassVar" ',
        classVarNotAllowed: '"ClassVar" ',
        classVarOverridesInstanceVar: ' "{name}"  "{className}" ',
        classVarTooManyArgs: '"ClassVar"  1 ',
        classVarWithTypeVar: '"ClassVar" ',
        clsSelfParamTypeMismatch: ' "{name}"  "{classType}" ',
        codeTooComplexToAnalyze: ' ',
        collectionAliasInstantiation: ' "{type}"  "{alias}" ',
        comparisonAlwaysFalse: ' "{leftType}"  "{rightType}"  False ',
        comparisonAlwaysTrue: ' "{leftType}"  "{rightType}"  True ',
        comprehensionInDict: '',
        comprehensionInSet: ' set ',
        concatenateContext: '"Concatenate" ',
        concatenateParamSpecMissing: '"Concatenate"  ParamSpec  "..." ',
        concatenateTypeArgsMissing: '"Concatenate"  2 ',
        conditionalOperandInvalid: ' "{type}" ',
        constantRedefinition: '"{name}"  ()',
        constructorParametersMismatch: ' "{classType}" __new____init__',
        containmentAlwaysFalse: ' "{leftType}"  "{rightType}"  False ',
        containmentAlwaysTrue: ' "{leftType}"  "{rightType}"  True ',
        continueInExceptionGroup: '"except*"  "continue" ',
        continueOutsideLoop: '"continue" ',
        coroutineInConditionalExpression: ' True ',
        dataClassBaseClassFrozen: '',
        dataClassBaseClassNotFrozen: '',
        dataClassConverterFunction: ' "{argType}"  "{fieldType}"  "{fieldName}" ',
        dataClassConverterOverloads: '{funcName}"  "{fieldType}"  "{fieldName}" ',
        dataClassFieldInheritedDefault: '"{fieldName}" ',
        dataClassFieldWithDefault: '',
        dataClassFieldWithPrivateName: ' ',
        dataClassFieldWithoutAnnotation: ' ',
        dataClassPostInitParamCount: 'Dataclass __post_init__ InitVar  {expected} ',
        dataClassPostInitType: ' "{fieldName}"  Dataclass __post_init__  ',
        dataClassSlotsOverwrite: '__slots__',
        dataClassTransformExpectedBoolLiteral: ' True  False ',
        dataClassTransformFieldSpecifier: ' tuple  "{type}" ',
        dataClassTransformPositionalParam: '"dataclass_transform" ',
        dataClassTransformUnknownArgument: ' "{name}" dataclass_transform ',
        dataProtocolInSubclassCheck: '  () issubclass ',
        declaredReturnTypePartiallyUnknown: ' "{returnType}" ',
        declaredReturnTypeUnknown: '',
        defaultValueContainsCall: '',
        defaultValueNotAllowed: '"*"  "**" ',
        delTargetExpr: '',
        deprecatedClass: ' "{name}" ',
        deprecatedConstructor: ' "{name}" ',
        deprecatedDescriptorDeleter: ' "{name}"  "__delete__" ',
        deprecatedDescriptorGetter: ' "{name}"  "__get__" ',
        deprecatedDescriptorSetter: ' "{name}"  "__set__" ',
        deprecatedFunction: ' "{name}" ',
        deprecatedMethod: ' "{className}"  "{name}" ',
        deprecatedPropertyDeleter: 'The deleter for property "{name}" is deprecated',
        deprecatedPropertyGetter: 'The getter for property "{name}" is deprecated',
        deprecatedPropertySetter: 'The setter for property "{name}" is deprecated',
        deprecatedType: ' Python {version} "{replacement}"',
        dictExpandIllegalInComprehension: '',
        dictInAnnotation: '',
        dictKeyValuePairs: '/',
        dictUnpackIsNotMapping: ' ',
        dunderAllSymbolNotPresent: '"{name}"  __all__ ',
        duplicateArgsParam: ' "*"  1 ',
        duplicateBaseClass: '',
        duplicateCapturePatternTarget: 'Capture  "{name}" ',
        duplicateCatchAll: ' catch-all except  1 ',
        duplicateEnumMember: 'Enum  "{name}" ',
        duplicateGenericAndProtocolBase: ' Generic[...]  Protocol[...]  1 ',
        duplicateImport: '"{importName}" ',
        duplicateKeywordOnly: '"*"  1 ',
        duplicateKwargsParam: ' "**"  1 ',
        duplicateParam: ' "{name}" ',
        duplicatePositionOnly: ' "/"  1 ',
        duplicateStarPattern: '  "*"  1 ',
        duplicateStarStarPattern: ' "**"  1 ',
        duplicateUnpack: 'list  1 ',
        ellipsisAfterUnpacked: '"..."  TypeVarTuple  tuple ',
        ellipsisContext: '"..." ',
        ellipsisSecondArg: '"..." 2  2 ',
        enumClassOverride: 'Enum  "{name}"  final ',
        enumMemberDelete: 'Enum  "{name}" ',
        enumMemberSet: 'Enum  "{name}" ',
        enumMemberTypeAnnotation: 'Type annotations are not allowed for enum members',
        exceptGroupMismatch: 'Try  "except"  "except*" ',
        exceptGroupRequiresType: ' ("except*") ',
        exceptionGroupIncompatible: ' ("except*")  Python 3.11 ',
        exceptionGroupTypeIncorrect: 'except*  BaseGroupException ',
        exceptionTypeIncorrect: '"{type}"  BaseException ',
        exceptionTypeNotClass: '"{type}" ',
        exceptionTypeNotInstantiable: ' "{type}"  1 ',
        expectedAfterDecorator: '',
        expectedArrow: '"->" ',
        expectedAsAfterException: ' "as" ',
        expectedAssignRightHandExpr: '"=" ',
        expectedBinaryRightHandExpr: '',
        expectedBoolLiteral: 'True  False ',
        expectedCase: '"case" ',
        expectedClassName: '',
        expectedCloseBrace: '"{" ',
        expectedCloseBracket: '"[" ',
        expectedCloseParen: '"(" ',
        expectedColon: '":" ',
        expectedComplexNumberLiteral: ' ',
        expectedDecoratorExpr: 'Python 3.9 ',
        expectedDecoratorName: '',
        expectedDecoratorNewline: '',
        expectedDelExpr: '"del" ',
        expectedElse: '"else" ',
        expectedEquals: '"=" ',
        expectedExceptionClass: '',
        expectedExceptionObj: ' None ',
        expectedExpr: '',
        expectedFunctionAfterAsync: '"async" ',
        expectedFunctionName: '"def" ',
        expectedIdentifier: '',
        expectedImport: '"import" ',
        expectedImportAlias: '"as" ',
        expectedImportSymbols: '"import"  1 ',
        expectedIn: '\'in\' ',
        expectedInExpr: '"in" ',
        expectedIndentedBlock: '',
        expectedMemberName: '"" ',
        expectedModuleName: '',
        expectedNameAfterAs: '"as" ',
        expectedNamedParameter: '  "*" ',
        expectedNewline: '',
        expectedNewlineOrSemicolon: '',
        expectedOpenParen: '"(" ',
        expectedParamName: '',
        expectedPatternExpr: '',
        expectedPatternSubjectExpr: '',
        expectedPatternValue: '"a.b" ',
        expectedReturnExpr: '"return" ',
        expectedSliceIndex: '',
        expectedTypeNotString: '',
        expectedTypeParameterName: '',
        expectedYieldExpr: 'yield ',
        finalClassIsAbstract: ' "{type}"  final ',
        finalContext: '"Final" ',
        finalInLoop: '"Final" ',
        finalMethodOverride: ' "{name}"  "{className}"  final ',
        finalNonMethod: ' "{name}" @final ',
        finalReassigned: '"{name}"  Final ',
        finalRedeclaration: '"{name}"  Final ',
        finalRedeclarationBySubclass: ' "{className}"  Final "{name}" ',
        finalTooManyArgs: '"Final"  1 ',
        finalUnassigned: '"{name}"  Final ',
        formatStringBrace: 'f-string 1 ',
        formatStringBytes: ' (f ) ',
        formatStringDebuggingIllegal: 'F-string  "="  Python 3.8 ',
        formatStringEscape: 'Python 3.12  f-string   () ',
        formatStringExpectedConversion: 'f-string  "!" ',
        formatStringIllegal: ' (f )  Python 3.6 ',
        formatStringInPattern: '',
        formatStringNestedFormatSpecifier: '',
        formatStringNestedQuote: 'f-string Python 3.12  f-string ',
        formatStringUnicode: ' (f )  Unicode ',
        formatStringUnterminated: 'f-string "}" ',
        functionDecoratorTypeUnknown: '',
        functionInConditionalExpression: ' True ',
        functionTypeParametersIllegal: ' Python 3.12 ',
        futureImportLocationNotAllowed: '__future__ ',
        generatorAsyncReturnType: 'async "AsyncGenerator[{yieldType}, Any]" ',
        generatorNotParenthesized: '',
        generatorSyncReturnType: '"Generator[{yieldType}, Any, Any]" ',
        genericBaseClassNotAllowed: '"Generic" ',
        genericClassAssigned: ' ',
        genericClassDeleted: ' ',
        genericInstanceVariableAccess: ' ',
        genericNotAllowed: '"Generic" ',
        genericTypeAliasBoundTypeVar: ' {names} ',
        genericTypeArgMissing: '"Generic"  1 ',
        genericTypeArgTypeVar: '"Generic" ',
        genericTypeArgUnique: '"Generic" ',
        globalReassignment: '"{name}"  global ',
        globalRedefinition: '"{name}"  global ',
        implicitStringConcat: '',
        importCycleDetected: ' ',
        importDepthExceeded: '  {depth} ',
        importResolveFailure: ' "{importName}" ',
        importSourceResolveFailure: ' "{importName}" ',
        importSymbolUnknown: '"{name}"  ',
        incompatibleMethodOverride: ' "{name}"  "{className}" ',
        inconsistentIndent: '',
        inconsistentTabs: '',
        initMethodSelfParamTypeVar: '"__init__"  "self"  ',
        initMustReturnNone: '"__init__"  None ',
        initSubclassCallFailed: '__init_subclass__ ',
        initSubclassClsParam: '__init_subclass__  "cls" ',
        initVarNotAllowed: '"InitVar" ',
        instanceMethodSelfParam: '  "self" ',
        instanceVarOverridesClassVar: ' "{name}"  "{className}" ',
        instantiateAbstract: ' "{type}" ',
        instantiateProtocol: 'Protocol  "{type}" ',
        internalBindError: ' "{file}" : {message}',
        internalParseError: ' "{file}" : {message}',
        internalTypeCheckingError: ' "{file}" : {message}',
        invalidIdentifierChar: '',
        invalidStubStatement: ' stub ',
        invalidTokenChars: ' "{text}"',
        isInstanceInvalidType: '"isinstance"  2  tuple ',
        isSubclassInvalidType: '"issubclass"  2  tuple ',
        keyValueInSet: ' set ',
        keywordArgInTypeArgument: '',
        keywordArgShortcutIllegal: ' Python 3.14 ',
        keywordOnlyAfterArgs: '"*" ',
        keywordParameterMissing: '1   "*" ',
        keywordSubscriptIllegal: '',
        lambdaReturnTypePartiallyUnknown: '"{returnType}" ',
        lambdaReturnTypeUnknown: '',
        listAssignmentMismatch: ' "{type}"  ',
        listInAnnotation: 'List ',
        literalEmptyArgs: '"Literal"  1 ',
        literalNamedUnicodeEscape: ' Unicode  "Literal" ',
        literalNotAllowed: '"Literal" ',
        literalNotCallable: 'Literal ',
        literalUnsupportedType: '"Literal"  Noneliteral  (intboolstr bytes) enum ',
        matchIncompatible: 'Match  Python 3.10 ',
        matchIsNotExhaustive: 'match ',
        maxParseDepthExceeded: '',
        memberAccess: ' "{type}"  "{name}" ',
        memberDelete: ' "{type}"  "{name}" ',
        memberSet: ' "{type}"  "{name}" ',
        metaclassConflict: '',
        metaclassDuplicate: ' 1 ',
        metaclassIsGeneric: '',
        methodNotDefined: '"{name}" ',
        methodNotDefinedOnType: ' "{type}"  "{name}" ',
        methodOrdering: '',
        methodOverridden: '"{name}"  "{className}"  "{type}" ',
        methodReturnsNonObject: '"{name}" ',
        missingSuperCall: ' "{methodName}" ',
        mixingBytesAndStr: 'Bytes  str ',
        moduleAsType: '',
        moduleNotCallable: '',
        moduleUnknownMember: '"{memberName}"  "{moduleName}" ',
        namedExceptAfterCatchAll: ' except catch-all except ',
        namedParamAfterParamSpecArgs: 'ParamSpec args   "{name}" ',
        namedTupleEmptyName: ' tuple ',
        namedTupleEntryRedeclared: ' "{className}"  tuple "{name}" ',
        namedTupleFirstArg: ' tuple ',
        namedTupleMultipleInheritance: 'NamedTuple ',
        namedTupleNameKeyword: '',
        namedTupleNameType: ' 2  tuple ',
        namedTupleNameUnique: ' tuple ',
        namedTupleNoTypes: '"namedtuple"   "NamedTuple" ',
        namedTupleSecondArg: '2  tuple  list ',
        newClsParam: '__new__ override  "cls" ',
        newTypeAnyOrUnknown: 'NewType  2 Any  Unknown ',
        newTypeBadName: 'NewType ',
        newTypeLiteral: 'NewType  Literal ',
        newTypeNameMismatch: 'NewType ',
        newTypeNotAClass: 'NewType  2 ',
        newTypeParamCount: 'NewType  2 ',
        newTypeProtocolClass: 'NewType  (Protocol TypedDict ) ',
        noOverload: ' "{name}" ',
        noReturnContainsReturn: 'Function with declared return type "NoReturn" cannot include a return statement',
        noReturnContainsYield: ' "NoReturn"  yield ',
        noReturnReturnsNone: ' "NoReturn"  "None" ',
        nonDefaultAfterDefault: '',
        nonLocalInModule: '  nonlocal ',
        nonLocalNoBinding: 'nonlocal "{name}" ',
        nonLocalReassignment: '"{name}"  nonlocal ',
        nonLocalRedefinition: '"{name}"  nonlocal ',
        noneNotCallable: '"None" ',
        noneNotIterable: ' "None" ',
        noneNotSubscriptable: '"None" ',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: ' "{operator}"  "None" ',
        noneUnknownMember: '"{name}"  "None" ',
        notRequiredArgCount: '"NotRequired"  1 ',
        notRequiredNotInTypedDict: '"NotRequired" ',
        objectNotCallable: ' "{type}" ',
        obscuredClassDeclaration: ' "{name}" ',
        obscuredFunctionDeclaration: ' "{name}" ',
        obscuredMethodDeclaration: ' "{name}" ',
        obscuredParameterDeclaration: ' "{name}" ',
        obscuredTypeAliasDeclaration: ' "{name}" ',
        obscuredVariableDeclaration: ' "{name}" ',
        operatorLessOrGreaterDeprecated: ' "<>"  Python 3  "!=" ',
        optionalExtraArgs: '"Optional"  1 ',
        orPatternIrrefutable: '"or" ',
        orPatternMissingName: '"or" ',
        overlappingKeywordArgs: ' : {names}',
        overlappingOverload: ' {obscuredBy} "{name}"  {obscured} ',
        overloadAbstractImplMismatch: '',
        overloadAbstractMismatch: '',
        overloadClassMethodInconsistent: '"{name}" @classmethod ',
        overloadFinalInconsistencyImpl: '"{name}"  @final  @final ',
        overloadFinalInconsistencyNoImpl: '"{name}"  {index}  @final  1  @final ',
        overloadImplementationMismatch: ' {index} ',
        overloadReturnTypeMismatch: '"{name}"  {prevIndex}  {newIndex} ',
        overloadStaticMethodInconsistent: '"{name}" @staticmethod ',
        overloadWithoutImplementation: '"{name}"  overload ',
        overriddenMethodNotFound: ' "{name}"  override ',
        overrideDecoratorMissing: ' "{name}"  override  "{className}" ',
        paramAfterKwargsParam: ' "**" ',
        paramAlreadyAssigned: ' "{name}" ',
        paramAnnotationMissing: ' "{name}" ',
        paramAssignmentMismatch: ' "{sourceType}"  "{paramType}" ',
        paramNameMissing: '"{name}" ',
        paramSpecArgsKwargsDuplicate: 'ParamSpec "{type}" ',
        paramSpecArgsKwargsUsage: 'ParamSpec  "args"  "kwargs" ',
        paramSpecArgsMissing: 'ParamSpec "{type}" ',
        paramSpecArgsUsage: 'ParamSpec  "args" *args ',
        paramSpecAssignedName: 'ParamSpec  "{name}" ',
        paramSpecContext: 'ParamSpec ',
        paramSpecDefaultNotTuple: 'ParamSpec tuple  ParamSpec ',
        paramSpecFirstArg: ' ParamSpec ',
        paramSpecKwargsUsage: 'ParamSpec  "kwargs" **kwargs ',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" ',
        paramSpecUnknownArg: 'ParamSpec ',
        paramSpecUnknownMember: '"{name}"  ParamSpec ',
        paramSpecUnknownParam: '"{name}"  ParamSpec ',
        paramTypeCovariant: '',
        paramTypePartiallyUnknown: ' "{paramName}" ',
        paramTypeUnknown: ' "{paramName}" ',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: ' "{type}" ',
        positionArgAfterNamedArg: '',
        positionOnlyAfterArgs: '"*" ',
        positionOnlyAfterKeywordOnly: '"/"  "*" ',
        positionOnlyAfterNon: '',
        positionOnlyFirstParam: '',
        positionOnlyIncompatible: ' Python 3.8 ',
        privateImportFromPyTypedModule: '"{name}"  "{module}" ',
        privateUsedOutsideOfClass: '"{name}" ',
        privateUsedOutsideOfModule: '"{name}" ',
        propertyOverridden: '"{name}"  "{className}"  property ',
        propertyStaticMethod: 'property  gettersetter  deleter ',
        protectedUsedOutsideOfClass: '"{name}" ',
        protocolBaseClass: 'Protocol  "{classType}"  Protocol  "{baseType}" ',
        protocolBaseClassWithTypeArgs: 'Protocol ',
        protocolIllegal: '"Protocol"  Python 3.7 ',
        protocolNotAllowed: '"Protocol" ',
        protocolTypeArgMustBeTypeParam: '"Protocol" ',
        protocolUnsafeOverlap: ' "{name}" ',
        protocolVarianceContravariant: ' Protocol "{class}"  "{variable}" ',
        protocolVarianceCovariant: ' Protocol "{class}"  "{variable}" ',
        protocolVarianceInvariant: ' Protocol "{class}"  "{variable}" ',
        pyrightCommentInvalidDiagnosticBoolValue: 'Pyright   "="  true  false ',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Pyright   "="  truefalseerrorwarninginformation  none ',
        pyrightCommentMissingDirective: 'Pyright  (basic  strict) ',
        pyrightCommentNotOnOwnLine: '  Pyright ',
        pyrightCommentUnknownDiagnosticRule: '"{rule}"  pyright ',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" pyright truefalseerrorwarninginformation  none ',
        pyrightCommentUnknownDirective: '"{directive}" pyright "strict"  "basic" ',
        readOnlyArgCount: '"ReadOnly"  1 ',
        readOnlyNotInTypedDict: '"ReadOnly" ',
        recursiveDefinition: '"{name}" ',
        relativeImportNotAllowed: '"import .a"  "from . import a" ',
        requiredArgCount: '"Required"  1 ',
        requiredNotInTypedDict: ' "Required" ',
        returnInAsyncGenerator: ' return async ',
        returnInExceptionGroup: '"except*"  "return" ',
        returnMissing: ' "{returnType}"  ',
        returnOutsideFunction: '"return" ',
        returnTypeContravariant: '',
        returnTypeMismatch: ' "{exprType}"  "{returnType}" ',
        returnTypePartiallyUnknown: ' "{returnType}" ',
        returnTypeUnknown: '',
        revealLocalsArgs: '"reveal_locals" ',
        revealLocalsNone: ' locals ',
        revealTypeArgs: '"reveal_type"  1 ',
        revealTypeExpectedTextArg: ' "reveal_type"  "expected_text" str ',
        revealTypeExpectedTextMismatch: ';"{expected}" "{received}" ',
        revealTypeExpectedTypeMismatch: '"{expected}" "{received}" ',
        selfTypeContext: '"Self" ',
        selfTypeMetaclass: '"Self"  ("type" ) ',
        selfTypeWithTypedSelfOrCls: '"Self" "Self"  \'self\'  \'cls\' ',
        setterGetterTypeMismatch: 'property setter getter ',
        singleOverload: '"{name}" ',
        slotsAttributeError: '__slots__ "{name}" ',
        slotsClassVarConflict: '"{name}"  __slots__ ',
        starPatternInAsPattern: '  "as" ',
        starPatternInOrPattern: '  OR ',
        starStarWildcardNotAllowed: '**  "_" ',
        staticClsSelfParam: ' "self"  "cls" ',
        stdlibModuleOverridden: '"{path}"  stdlib  "{name}" ',
        stringNonAsciiBytes: ' ASCII ',
        stringNotSubscriptable: '',
        stringUnsupportedEscape: ' ',
        stringUnterminated: '',
        stubFileMissing: '"{importName}"  stub ',
        stubUsesGetAttr: ' stub "__getattr__" ',
        sublistParamsIncompatible: 'Python 3.x  sublist ',
        superCallArgCount: '"super"  2 ',
        superCallFirstArg: '"super" "{type}" ',
        superCallSecondArg: '"super"  2 "{type}" ',
        superCallZeroArgForm: '"super"  0 ',
        superCallZeroArgFormStaticMethod: '"super"  0 ',
        symbolIsPossiblyUnbound: '"{name}" ',
        symbolIsUnbound: '"{name}" ',
        symbolIsUndefined: '"{name}" ',
        symbolOverridden: '"{name}"  "{className}" ',
        ternaryNotAllowed: '3 ',
        totalOrderingMissingMethod: 'total_ordering "__lt__""__le__""__gt__" "__ge__" ',
        trailingCommaInFromImport: '',
        tryWithoutExcept: 'Try  1  except  finally ',
        tupleAssignmentMismatch: ' "{type}"  tuple ',
        tupleInAnnotation: 'tuple ',
        tupleIndexOutOfRange: ' {index}  {type} ',
        typeAliasIllegalExpressionForm: '',
        typeAliasIsRecursiveDirect: ' "{name}" ',
        typeAliasNotInModuleOrClass: 'TypeAlias ',
        typeAliasRedeclared: '"{name}"  TypeAlias 1 ',
        typeAliasStatementBadScope: 'type ',
        typeAliasStatementIllegal: '  Python 3.12 ',
        typeAliasTypeBaseClass: '"type" ',
        typeAliasTypeMustBeAssigned: 'TypeAliasType ',
        typeAliasTypeNameArg: 'TypeAliasType ',
        typeAliasTypeNameMismatch: '',
        typeAliasTypeParamInvalid: ' TypeVarTypeVarTuple ParamSpec  tuple ',
        typeAnnotationCall: '',
        typeAnnotationVariable: '',
        typeAnnotationWithCallable: '"type" ',
        typeArgListExpected: 'ParamSpec list ',
        typeArgListNotAllowed: ' list ',
        typeArgsExpectingNone: ' "{name}" ',
        typeArgsMismatchOne: '1 {received} ',
        typeArgsMissingForAlias: ' "{name}" ',
        typeArgsMissingForClass: '  "{name}" ',
        typeArgsTooFew: '"{name}" {expected} {received} ',
        typeArgsTooMany: '"{name}" {expected} {received} ',
        typeAssignmentMismatch: ' "{sourceType}"  "{destType}" ',
        typeAssignmentMismatchWildcard: '  "{name}"  "{sourceType}"  "{destType}" ',
        typeCallNotAllowed: 'type() ',
        typeCheckOnly: '"{name}" @type_check_only',
        typeCommentDeprecated: 'type  type ',
        typeExpectedClass: '"{type}" ',
        typeFormArgs: '"TypeForm"  1 ',
        typeGuardArgCount: '"TypeGuard"  "TypeIs"  1 ',
        typeGuardParamCount: ' 1 ',
        typeIsReturnType: 'TypeIs  ("{returnType}")  ("{type}") ',
        typeNotAwaitable: '"{type}"  awaitable ',
        typeNotIntantiable: '"{type}" ',
        typeNotIterable: '"{type}" ',
        typeNotSpecializable: ' "{type}" ',
        typeNotSubscriptable: ' "{type}" ',
        typeNotSupportBinaryOperator: ' "{operator}"  "{leftType}"  "{rightType}" ',
        typeNotSupportBinaryOperatorBidirectional: ' "{leftType}"  "{rightType}"  "{operator}"  "{expectedType}" ',
        typeNotSupportUnaryOperator: ' "{operator}"  "{type}" ',
        typeNotSupportUnaryOperatorBidirectional: ' "{type}"  "{expectedType}"  "{operator}" ',
        typeNotUsableWith: ' "{type}"  {method} "with" ',
        typeParameterBoundNotAllowed: ' ParamSpec ',
        typeParameterConstraintTuple: '2 ',
        typeParameterExistingTypeParameter: ' "{name}" ',
        typeParameterNotDeclared: ' "{name}" "{container}" ',
        typeParametersMissing: ' 1 ',
        typePartiallyUnknown: '"{name}" ',
        typeUnknown: '"{name}" ',
        typeVarAssignedName: 'TypeVar  "{name}" ',
        typeVarAssignmentMismatch: ' "{type}"  "{name}" ',
        typeVarBoundAndConstrained: 'TypeVar ',
        typeVarBoundGeneric: 'TypeVar ',
        typeVarConstraintGeneric: 'TypeVar ',
        typeVarDefaultBoundMismatch: 'TypeVar ',
        typeVarDefaultConstraintMismatch: 'TypeVar ',
        typeVarDefaultIllegal: ' Python 3.13 ',
        typeVarDefaultInvalidTypeVar: ' "{name}"  1 ',
        typeVarFirstArg: ' TypeVar ',
        typeVarInvalidForMemberVariable: '  "{name}" ',
        typeVarNoMember: 'TypeVar "{type}"  "{name}" ',
        typeVarNotSubscriptable: 'TypeVar "{type}" ',
        typeVarNotUsedByOuterScope: ' "{name}" ',
        typeVarPossiblyUnsolvable: ' "{param}"  "{name}" ',
        typeVarSingleConstraint: 'TypeVar  2 ',
        typeVarTupleConstraints: 'TypeVarTuple ',
        typeVarTupleContext: 'TypeVarTuple ',
        typeVarTupleDefaultNotUnpacked: 'TypeVarTuple  tuple  TypeVarTuple ',
        typeVarTupleMustBeUnpacked: 'TypeVarTuple ',
        typeVarTupleUnknownParam: '"{name}"  TypeVarTuple ',
        typeVarUnknownParam: '"{name}"  TypeVar ',
        typeVarUsedByOuterScope: 'TypeVar "{name}" ',
        typeVarUsedOnlyOnce: 'TypeVar "{name}"  1 ',
        typeVarVariance: 'TypeVar ',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}" TypeVarTuple "{variadicName}" ',
        typeVarWithoutDefault: '"{name}"   "{other}" ',
        typeVarsNotInGenericOrProtocol: 'Generic[]  Protocol[] ',
        typedDictAccess: 'TypedDict ',
        typedDictAssignedName: 'TypedDict  "{name}" ',
        typedDictBadVar: 'TypedDict ',
        typedDictBaseClass: 'TypedDict  TypedDict ',
        typedDictBoolParam: '"{name}"  True  False ',
        typedDictClosedExtras: ' "{name}"  closed  TypedDict  "{type}" ',
        typedDictClosedNoExtras: ' "{name}"  closed  TypedDict ',
        typedDictDelete: 'TypedDict ',
        typedDictEmptyName: 'TypedDict ',
        typedDictEntryName: '',
        typedDictEntryUnique: '',
        typedDictExtraArgs: ' TypedDict ',
        typedDictExtraItemsClosed: 'TypedDict  closed ',
        typedDictFieldNotRequiredRedefinition: 'TypedDict  "{name}"  NotRequired ',
        typedDictFieldReadOnlyRedefinition: 'TypedDict  "{name}"  ReadOnly ',
        typedDictFieldRequiredRedefinition: 'TypedDict  "{name}"  Required ',
        typedDictFirstArg: ' TypedDict ',
        typedDictInClassPattern: 'TypedDict  ',
        typedDictInitsubclassParameter: 'TypedDict  __init_subclass__ "{name}" ',
        typedDictNotAllowed: '"TypedDict" ',
        typedDictSecondArgDict: '2  dict  ',
        typedDictSecondArgDictEntry: '',
        typedDictSet: 'TypedDict ',
        unaccessedClass: ' "{name}" ',
        unaccessedFunction: ' "{name}" ',
        unaccessedImport: ' "{name}" ',
        unaccessedSymbol: '"{name}" ',
        unaccessedVariable: ' "{name}" ',
        unannotatedFunctionSkipped: ' "{name}" ',
        unaryOperationNotAllowed: '',
        unexpectedAsyncToken: '"def""with" "for"  "async" ',
        unexpectedExprToken: '',
        unexpectedIndent: '',
        unexpectedUnindent: '',
        unhashableDictKey: '',
        unhashableSetEntry: 'set ',
        uninitializedAbstractVariables: 'final  "{classType}" ',
        uninitializedInstanceVariable: ' "{name}" __init__ ',
        unionForwardReferenceNotAllowed: 'Union ',
        unionSyntaxIllegal: ' Python 3.10 ',
        unionTypeArgCount: 'Union  2 ',
        unionUnpackedTuple: 'Union cannot include an unpacked tuple',
        unionUnpackedTypeVarTuple: 'Union cannot include an unpacked TypeVarTuple',
        unnecessaryCast: ' "cast"  "{type}" ',
        unnecessaryIsInstanceAlways: ' isinstance "{testType}"  "{classType}" ',
        unnecessaryIsInstanceNever: ' isinstance ; "{testType}" "{classType}" ',
        unnecessaryIsSubclassAlways: ' issubclass "{testType}"  "{classType}" ',
        unnecessaryIsSubclassNever: ' issubclass ; "{testType}"  "{classType}" ',
        unnecessaryPyrightIgnore: ' "# pyright: ignore" ',
        unnecessaryPyrightIgnoreRule: ' "# pyright: ignore" : "{name}"',
        unnecessaryTypeIgnore: ' "# type: ignore" ',
        unpackArgCount: '"Unpack"  1 ',
        unpackExpectedTypeVarTuple: 'Unpack  TypeVarTuple  tuple ',
        unpackExpectedTypedDict: 'Unpack  TypedDict ',
        unpackIllegalInComprehension: '',
        unpackInAnnotation: '',
        unpackInDict: '',
        unpackInSet: ' set ',
        unpackNotAllowed: 'Unpack ',
        unpackOperatorNotAllowed: '',
        unpackTuplesIllegal: 'Python 3.8 ',
        unpackedArgInTypeArgument: '',
        unpackedArgWithVariadicParam: ' TypeVarTuple ',
        unpackedDictArgumentNotMapping: '** "str" ',
        unpackedDictSubscriptIllegal: '',
        unpackedSubscriptIllegal: ' Unpack  Python 3.11 ',
        unpackedTypeVarTupleExpected: ' TypeVarTuple Unpack[{name1}]  *{name2} ',
        unpackedTypedDictArgument: ' TypedDict ',
        unreachableCode: '',
        unreachableCodeType: '',
        unreachableExcept: 'Except ',
        unsupportedDunderAllOperation: '"__all__"  ',
        unusedCallResult: ' "{type}"  "_" ',
        unusedCoroutine: 'async "await" ',
        unusedExpression: '',
        varAnnotationIllegal: ' type  Python 3.6  type ',
        variableFinalOverride: ' "{name}"  Final  "{className}"  Final ',
        variadicTypeArgsTooMany: ' TypeVarTuple  tuple  1 ',
        variadicTypeParamTooManyAlias: ' TypeVarTuple  1  ({names}) ',
        variadicTypeParamTooManyClass: '  1  TypeVarTuple  ({names}) ',
        walrusIllegal: ' ":="  Python 3.8 ',
        walrusNotAllowed: ' ":=" ',
        wildcardInFunction: ' import ',
        wildcardLibraryImport: ' import ',
        wildcardPatternTypePartiallyUnknown: ' ',
        wildcardPatternTypeUnknown: ' ',
        yieldFromIllegal: '"yield from"  Python 3.3 ',
        yieldFromOutsideAsync: 'async  "yield from" ',
        yieldOutsideFunction: ' "yield" ',
        yieldWithinComprehension: '"yield" ',
        zeroCaseStatementsFound: 'Match  1  case ',
        zeroLengthTupleNotAllowed: ' 0  tuple '
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '"Annotated" ',
        argParam: ' "{paramName}" ',
        argParamFunction: ' "{functionName}"  "{paramName}" ',
        argsParamMissing: ' "*{paramName}" ',
        argsPositionOnly: '{expected} {received} ',
        argumentType: ' "{type}" ',
        argumentTypes: ': ({types})',
        assignToNone: ' "None" ',
        asyncHelp: '"async with" ?',
        baseClassIncompatible: ' "{baseClass}"  "{type}" ',
        baseClassIncompatibleSubclass: ' "{baseClass}"  "{type}"  "{subclass}" ',
        baseClassOverriddenType: ' "{baseClass}"  "{type}" ',
        baseClassOverridesType: ' "{baseClass}"  "{type}" ',
        bytesTypePromotions: 'disableBytesTypePromotions  false "bytearray"  "memoryview" ',
        conditionalRequiresBool: ' "{operandType}"  __bool__"bool"  "{boolReturnType}" ',
        dataClassFieldLocation: '',
        dataClassFrozen: '"{name}" ',
        dataProtocolUnsupported: '"{name}"  ',
        descriptorAccessBindingFailed: ' "{className}"  "{name}" ',
        descriptorAccessCallFailed: ' "{className}"  "{name}" ',
        finalMethod: 'Final ',
        functionParamDefaultMissing: ' "{name}" ',
        functionParamName: ': "{destName}"  "{srcName}"',
        functionParamPositionOnly: ';  "{name}" ',
        functionReturnTypeMismatch: ' "{sourceType}"  "{destType}" ',
        functionTooFewParams: '{expected} {received} ',
        functionTooManyParams: '{expected} {received} ',
        genericClassNotAllowed: '',
        incompatibleDeleter: 'property deleter ',
        incompatibleGetter: 'property getter ',
        incompatibleSetter: 'property setter ',
        initMethodLocation: '__init__  "{type}" ',
        initMethodSignature: '__init__ "{type}" ',
        initSubclassLocation: '__init_subclass__  "{name}" ',
        invariantSuggestionDict: '"dict"  "Mapping" ',
        invariantSuggestionList: '"list"  "Sequence" ',
        invariantSuggestionSet: '"set"  "Container" ',
        isinstanceClassNotSupported: '"{type}" ',
        keyNotRequired: '"{name}"  "{type}" ',
        keyReadOnly: '"{name}"  "{type}" ',
        keyRequiredDeleted: '"{name}" ',
        keyUndefined: '"{name}"  "{type}" ',
        kwargsParamMissing: ' "**{paramName}" ',
        listAssignmentMismatch: ' "{type}"  ',
        literalAssignmentMismatch: '"{sourceType}"  "{destType}" ',
        matchIsNotExhaustiveHint: '"case _: pass" ',
        matchIsNotExhaustiveType: ': "{type}"',
        memberAssignment: ' "{type}"  "{classType}"  "{name}" ',
        memberIsAbstract: '"{type}.{name}" ',
        memberIsAbstractMore: ' {count} ...',
        memberIsClassVarInProtocol: '"{name}"  ClassVar ',
        memberIsInitVar: '"{name}"  init-only ',
        memberIsInvariant: '"{name}" ',
        memberIsNotClassVarInClass: '"{name}"  ClassVar ',
        memberIsNotClassVarInProtocol: '"{name}"  ClassVar ',
        memberIsNotReadOnlyInProtocol: '"{name}" ',
        memberIsReadOnlyInProtocol: '"{name}" ',
        memberIsWritableInProtocol: '"{name}" ',
        memberSetClassVar: ' "{name}"  ClassVar  ',
        memberTypeMismatch: '"{name}" ',
        memberUnknown: ' "{name}" ',
        metaclassConflict: ' "{metaclass1}"  "{metaclass2}" ',
        missingDeleter: 'property deleter ',
        missingGetter: 'property getter ',
        missingSetter: 'property setter ',
        namedParamMissingInDest: ' "{name}"',
        namedParamMissingInSource: '  "{name}" ',
        namedParamTypeMismatch: ' "{sourceType}"   "{name}"  "{destType}" ',
        namedTupleNotAllowed: 'NamedTuple ',
        newMethodLocation: '__new__  "{type}" ',
        newMethodSignature: '__new__ "{type}" ',
        newTypeClassNotAllowed: 'NewType ',
        noOverloadAssignable: ' "{type}" ',
        noneNotAllowed: ' None ',
        orPatternMissingName: ': {name}',
        overloadIndex: ' {index} ',
        overloadNotAssignable: '"{name}"  1 ',
        overloadSignature: '',
        overriddenMethod: '',
        overriddenSymbol: '',
        overrideInvariantMismatch: ' "{overrideType}"  "{baseType}" ',
        overrideIsInvariant: '',
        overrideNoOverloadMatches: ' ',
        overrideNotClassMethod: ' classmethod ',
        overrideNotInstanceMethod: ' ',
        overrideNotStaticMethod: ' staticmethod ',
        overrideOverloadNoMatch: '',
        overrideOverloadOrder: ' ',
        overrideParamKeywordNoDefault: '  "{name}" :  ',
        overrideParamKeywordType: '  "{name}" :  "{baseType}"  "{overrideType}" ',
        overrideParamName: ' {index} :   "{baseName}"  "{overrideName}" ',
        overrideParamNameExtra: ' "{name}"   ',
        overrideParamNameMissing: ' "{name}" ',
        overrideParamNamePositionOnly: ' {index} :   "{baseName}"   ',
        overrideParamNoDefault: ' {index} :  ',
        overrideParamType: ' {index} :  "{baseType}"  "{overrideType}" ',
        overridePositionalParamCount: ' {baseCount}  {overrideCount} ',
        overrideReturnType: ':  "{baseType}"  "{overrideType}" ',
        overrideType: ' "{type}" ',
        paramAssignment: ' {index}:  "{sourceType}"  "{destType}" ',
        paramSpecMissingInOverride: 'ParamSpec  override ',
        paramType: ' "{paramType}" ',
        privateImportFromPyTypedSource: ' "{module}" ',
        propertyAccessFromProtocolClass: ' ',
        propertyMethodIncompatible: 'property  "{name}" ',
        propertyMethodMissing: 'property  "{name}" ',
        propertyMissingDeleter: 'property "{name}"  deleter ',
        propertyMissingSetter: 'property "{name}"  setter ',
        protocolIncompatible: '"{sourceType}"  "{destType}" ',
        protocolMemberMissing: '"{name}" ',
        protocolRequiresRuntimeCheckable: 'Protocol  @runtime_checkable ',
        protocolSourceIsNotConcrete: '"{sourceType}"  "{destType}" ',
        protocolUnsafeOverlap: '"{name}" ',
        pyrightCommentIgnoreTip: '"# pyright: ignore[<diagnostic rules>]  1 ',
        readOnlyAttribute: ' "{name}" ',
        seeClassDeclaration: '',
        seeDeclaration: '',
        seeFunctionDeclaration: '',
        seeMethodDeclaration: '',
        seeParameterDeclaration: '',
        seeTypeAliasDeclaration: '',
        seeVariableDeclaration: '',
        tupleAssignmentMismatch: ' "{type}"  tuple ',
        tupleEntryTypeMismatch: 'tuple  {entry} ',
        tupleSizeIndeterminateSrc: 'Tuple {expected} ',
        tupleSizeIndeterminateSrcDest: 'Tuple {expected} ',
        tupleSizeMismatch: 'tuple {expected} {received} ',
        tupleSizeMismatchIndeterminateDest: 'Tuple {expected} {received} ',
        typeAliasInstanceCheck: '"type" ',
        typeAssignmentMismatch: ' "{sourceType}"  "{destType}" ',
        typeBound: ' "{sourceType}"  "{name}"  "{destType}" ',
        typeConstrainedTypeVar: ' "{type}"  "{name}" ',
        typeIncompatible: '"{sourceType}"  "{destType}" ',
        typeNotClass: '"{type}" ',
        typeNotStringLiteral: '"{type}" ',
        typeOfSymbol: '"{name}"  "{type}" ',
        typeParamSpec: ' "{type}"  ParamSpec "{name}" ',
        typeUnsupported: ' "{type}" ',
        typeVarDefaultOutOfScope: ' "{name}" ',
        typeVarIsContravariant: ' "{name}" "{sourceType}"  "{destType}" ',
        typeVarIsCovariant: ' "{name}" "{sourceType}"  "{destType}" ',
        typeVarIsInvariant: ' "{name}" "{sourceType}"  "{destType}" ',
        typeVarNotAllowed: 'TypeVar ',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple  tuple ',
        typeVarUnnecessarySuggestion: ' {type} ',
        typeVarUnsolvableRemedy: '',
        typeVarsMissing: ': {names}',
        typedDictBaseClass: ' "{type}"  TypedDict ',
        typedDictClassNotAllowed: 'TypedDict ',
        typedDictClosedExtraNotAllowed: ' "{name}" ',
        typedDictClosedExtraTypeMismatch: ' "{type}"  "{name}" ',
        typedDictClosedFieldNotRequired: ' "{name}"  NotRequired ',
        typedDictExtraFieldNotAllowed: '"{name}"  "{type}" ',
        typedDictExtraFieldTypeMismatch: '"{name}" "{type}"  "extra_items" ',
        typedDictFieldMissing: '"{name}"  "{type}" ',
        typedDictFieldNotReadOnly: '"{name}"  "{type}" ',
        typedDictFieldNotRequired: '"{name}"  "{type}" ',
        typedDictFieldRequired: '"{name}"  "{type}" ',
        typedDictFieldTypeMismatch: ' "{type}"  "{name}" ',
        typedDictFieldUndefined: '"{name}"  "{type}" ',
        typedDictFinalMismatch: '@final "{sourceType}"  "{destType}" ',
        typedDictKeyAccess: '["{name}"]  TypedDict ',
        typedDictNotAllowed: 'TypedDict ',
        unhashableType: ' "{type}" ',
        uninitializedAbstractVariable: ' "{name}"  "{classType}" ',
        unreachableExcept: '"{exceptionType}"  "{parentType}" ',
        useDictInstead: 'Dict[T1, T2] ',
        useListInstead: 'List[T]  list Union[T1, T2]  union ',
        useTupleInstead: 'tuple[T1, ..., Tn]  tuple Union[T1, T2]  union ',
        useTypeInstead: ' Type[T] ',
        varianceMismatchForClass: ' "{typeVarName}"  "{className}" ',
        varianceMismatchForTypeAlias: ' "{typeVarName}"  "{typeAliasParam}" '
      },
      Service: {
        longOperation: '  [](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  83472: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: ' Stub ',
        createTypeStubFor: '"{moduleName}"   Stub ',
        executingCommand: ' ',
        filesToAnalyzeCount: '  {count}',
        filesToAnalyzeOne: '  1',
        findingReferences: ' ',
        organizeImports: ' ',
        renameShadowedFile: '{oldFile} {newFile}()  '
      },
      Completion: {
        autoImportDetail: ' ',
        indexValueDetail: ' '
      },
      Diagnostic: {
        abstractMethodInvocation: ' "{method}"()      .',
        annotatedMetadataInconsistent: '  "{metadataType}"   "{type}"   .',
        annotatedParamCountMismatch: '     . {expected})()  {received}() .',
        annotatedTypeArgMissing: '"Annotated"        .',
        annotationBytesString: '       .',
        annotationFormatString: '    (f )   .',
        annotationNotSupported: '     .',
        annotationRawString: '       .',
        annotationSpansStrings: '        .',
        annotationStringEscape: '      .',
        argAssignment: '"{argType}"   "{paramType}"      .',
        argAssignmentFunction: '"{argType}"   "{functionName}"  "{paramType}"      .',
        argAssignmentParam: '"{argType}"   "{paramType}"  "{paramName}"     .',
        argAssignmentParamFunction: '"{argType}"   "{functionName}"  "{paramType}"  "{paramName}"     .',
        argMissingForParam: '  {name}   .',
        argMissingForParams: '  {names}   .',
        argMorePositionalExpectedCount: '{expected}    .',
        argMorePositionalExpectedOne: '1    .',
        argPositional: '  .',
        argPositionalExpectedCount: '{expected}   .',
        argPositionalExpectedOne: '1   .',
        argTypePartiallyUnknown: '     .',
        argTypeUnknown: '    .',
        assertAlwaysTrue: '   true .',
        assertTypeArgs: '"assert_type"     .',
        assertTypeTypeMismatch: '"assert_type" : "{expected}"()  "{received}"() .',
        assignmentExprComprehension: '{name}           .',
        assignmentExprContext: '  ,      .',
        assignmentExprInSubscript: '     Python 3.10  .',
        assignmentInProtocol: 'Protocol            .',
        assignmentTargetExpr: '     .',
        asyncNotInAsyncFunction: 'async   async  .',
        awaitIllegal: '"await"  Python 3.5  .',
        awaitNotAllowed: '  "await"   .',
        awaitNotInAsync: '"await" allowed only within async function',
        backticksIllegal: '   Python 3.x  .  repr ',
        baseClassCircular: '    .',
        baseClassFinal: '  "{type}"() final    .',
        baseClassIncompatible: '{type}     .',
        baseClassInvalid: '     .',
        baseClassMethodTypeIncompatible: '"{classType}"       "{name}"  .',
        baseClassUnknown: '         .',
        baseClassVariableTypeIncompatible: '"{classType}"    "{name}"     .',
        binaryOperationNotAllowed: '      .',
        bindTypeMismatch: '{type}()   {paramName}    {methodName}    .',
        breakInExceptionGroup: '"except*"  "break"   ',
        breakOutsideLoop: 'break     .',
        callableExtraArgs: '"Callable"     .',
        callableFirstArg: '     "..." .',
        callableNotInstantiable: '"{type}"    .',
        callableSecondArg: '  "Callable"      .',
        casePatternIsIrrefutable: '     case    .',
        classAlreadySpecialized: '"{type}"    .',
        classDecoratorTypeUnknown: '       .  .',
        classDefinitionCycle: '{name}     .',
        classGetItemClsParam: '__class_getitem__  "cls"    .',
        classMethodClsParam: '  cls    .',
        classNotRuntimeSubscriptable: ' "{name}"     .    .',
        classPatternBuiltInArgPositional: '     .',
        classPatternPositionalArgCount: ' "{type}"     . {expected}()  {received}() .',
        classPatternTypeAlias: '{type}()        .',
        classPropertyDeprecated: '  Python 3.11     Python 3.13  .',
        classTypeParametersIllegal: '     Python 3.12  .',
        classVarFirstArgMissing: 'ClassVar    .',
        classVarNotAllowed: '  "ClassVar"   .',
        classVarOverridesInstanceVar: '  "{name}"() "{className}"      .',
        classVarTooManyArgs: 'ClassVar     .',
        classVarWithTypeVar: 'ClassVar      .',
        clsSelfParamTypeMismatch: '{name}     {classType}    .',
        codeTooComplexToAnalyze: '     .         ',
        collectionAliasInstantiation: '{type}    .  {alias}() .',
        comparisonAlwaysFalse: '"{leftType}"  "{rightType}"      False .',
        comparisonAlwaysTrue: '"{leftType}"  "{rightType}"      True .',
        comprehensionInDict: '       .',
        comprehensionInSet: '  set     .',
        concatenateContext: '  "Concatenate"   .',
        concatenateParamSpecMissing: '"Concatenate"    ParamSpec  "..." .',
        concatenateTypeArgsMissing: '"Concatenate"      .',
        conditionalOperandInvalid: '{type}   .',
        constantRedefinition: '{name}()      .',
        constructorParametersMismatch: '{classType}  __new__  __init__ .',
        containmentAlwaysFalse: '{leftType}  {rightType}      False .',
        containmentAlwaysTrue: '{leftType}  {rightType}      True .',
        continueInExceptionGroup: '"except*"  "continue"   ',
        continueOutsideLoop: '"continue"     .',
        coroutineInConditionalExpression: '  True   .',
        dataClassBaseClassFrozen: '       .',
        dataClassBaseClassNotFrozen: '       .',
        dataClassConverterFunction: '"{argType}"   "{fieldType}"  "{fieldName}"    .',
        dataClassConverterOverloads: '"{funcName}"  "{fieldType}"  "{fieldName}"    .',
        dataClassFieldInheritedDefault: '"{fieldName}"()      ',
        dataClassFieldWithDefault: '         .',
        dataClassFieldWithPrivateName: '       .',
        dataClassFieldWithoutAnnotation: '         .',
        dataClassPostInitParamCount: '  __post_init__    . InitVar   {expected}.',
        dataClassPostInitType: '  __post_init__      "{fieldName}"   .',
        dataClassSlotsOverwrite: '__slots__    .',
        dataClassTransformExpectedBoolLiteral: ' True  False   .',
        dataClassTransformFieldSpecifier: '   tuple  {type}  .',
        dataClassTransformPositionalParam: '"dataclass_transform"      .',
        dataClassTransformUnknownArgument: 'dataclass_transform "{name}"   .',
        dataProtocolInSubclassCheck: ' (   ) issubclass   .',
        declaredReturnTypePartiallyUnknown: '   "{returnType}"()    .',
        declaredReturnTypeUnknown: '     .',
        defaultValueContainsCall: '             .',
        defaultValueNotAllowed: '"*"  "**"       .',
        delTargetExpr: '   .',
        deprecatedClass: '{name}   .',
        deprecatedConstructor: ' "{name}"     .',
        deprecatedDescriptorDeleter: '"{name}"   "____delete____"   .',
        deprecatedDescriptorGetter: '"{name}"   "__get__"   .',
        deprecatedDescriptorSetter: '"{name}"   "__set__"   .',
        deprecatedFunction: '"{name}"     .',
        deprecatedMethod: '"{className}"  "{name}"     .',
        deprecatedPropertyDeleter: '"{name}" property  deleter  .',
        deprecatedPropertyGetter: '"{name}" property  getter  .',
        deprecatedPropertySetter: '"{name}" property  setter  .',
        deprecatedType: '  Python {version}  .  "{replacement}"() .',
        dictExpandIllegalInComprehension: '     .',
        dictInAnnotation: '      .',
        dictKeyValuePairs: '  /   .',
        dictUnpackIsNotMapping: '      .',
        dunderAllSymbolNotPresent: '"{name}"() __all__   .',
        duplicateArgsParam: '"*"    ',
        duplicateBaseClass: '    .',
        duplicateCapturePatternTarget: '{name}           .',
        duplicateCatchAll: ' catch-all except  ',
        duplicateEnumMember: 'Enum  "{name}"()  .',
        duplicateGenericAndProtocolBase: ' Generic[...]  Protocol[...]   .',
        duplicateImport: '"{importName}"()    .',
        duplicateKeywordOnly: '"*"      .',
        duplicateKwargsParam: '"**"    ',
        duplicateParam: '  "{name}"() .',
        duplicatePositionOnly: '/    .',
        duplicateStarPattern: '  *     .',
        duplicateStarStarPattern: '**   .',
        duplicateUnpack: 'list      .',
        ellipsisAfterUnpacked: '"..."    TypeVarTuple  tuple    .',
        ellipsisContext: '"..."    .',
        ellipsisSecondArg: '"..."       .',
        enumClassOverride: 'Enum  "{name}"() final    .',
        enumMemberDelete: 'Enum  "{name}"()   ',
        enumMemberSet: 'Enum  "{name}"()   ',
        enumMemberTypeAnnotation: 'Type annotations are not allowed for enum members',
        exceptGroupMismatch: 'Try  "except" "except*"     ',
        exceptGroupRequiresType: '  ("except*")   ',
        exceptionGroupIncompatible: '  ("except*") Python 3.11  .',
        exceptionGroupTypeIncorrect: 'except*   BaseGroupException   .',
        exceptionTypeIncorrect: '{type} BaseException  .',
        exceptionTypeNotClass: '"{type}"()    .',
        exceptionTypeNotInstantiable: '  "{type}"      .',
        expectedAfterDecorator: '      .',
        expectedArrow: '"->"      .',
        expectedAsAfterException: '   as .',
        expectedAssignRightHandExpr: '"="   .',
        expectedBinaryRightHandExpr: '   .',
        expectedBoolLiteral: 'True  False .',
        expectedCase: '"case"  .',
        expectedClassName: '  .',
        expectedCloseBrace: '"{"   .',
        expectedCloseBracket: '"[{0}"()   .',
        expectedCloseParen: '"("   ',
        expectedColon: '\':\' .',
        expectedComplexNumberLiteral: '    .',
        expectedDecoratorExpr: 'Python 3.9      .',
        expectedDecoratorName: '  .',
        expectedDecoratorNewline: '    .',
        expectedDelExpr: '"del"   .',
        expectedElse: '"else" .',
        expectedEquals: '"=" .',
        expectedExceptionClass: '    ',
        expectedExceptionObj: '  ,    None',
        expectedExpr: ' .',
        expectedFunctionAfterAsync: 'async    .',
        expectedFunctionName: '"def"    .',
        expectedIdentifier: ' .',
        expectedImport: '"import" .',
        expectedImportAlias: '"as"   .',
        expectedImportSymbols: '"import"      .',
        expectedIn: '"in" .',
        expectedInExpr: '"in"   .',
        expectedIndentedBlock: '  .',
        expectedMemberName: '"."    ',
        expectedModuleName: '  ',
        expectedNameAfterAs: 'as     .',
        expectedNamedParameter: '   "*"  .',
        expectedNewline: '  .',
        expectedNewlineOrSemicolon: '      .',
        expectedOpenParen: '( .',
        expectedParamName: '   .',
        expectedPatternExpr: '  .',
        expectedPatternSubjectExpr: '   .',
        expectedPatternValue: '"a.b"     .',
        expectedReturnExpr: '"return"   .',
        expectedSliceIndex: '    .',
        expectedTypeNotString: '    .',
        expectedTypeParameterName: '    .',
        expectedYieldExpr: 'yield   .',
        finalClassIsAbstract: '"{type}"  final       .',
        finalContext: '"Final"    .',
        finalInLoop: '  "Final"    .',
        finalMethodOverride: '"{name}"  "{className}"   final    .',
        finalNonMethod: ' "{name}"()   @final   .',
        finalReassigned: '{name} Final     .',
        finalRedeclaration: '"{name}"()  Final .',
        finalRedeclarationBySubclass: '  "{className}"() Final  "{name}"()    .',
        finalTooManyArgs: '"Final"     .',
        finalUnassigned: '"{name}"() Final    .',
        formatStringBrace: 'f-string        .    .',
        formatStringBytes: '  (f-strings)   .',
        formatStringDebuggingIllegal: 'F-string   = Python 3.8  .',
        formatStringEscape: 'Python 3.12  f-string    ()   .',
        formatStringExpectedConversion: 'f-string "!"    .',
        formatStringIllegal: '  (f-strings) Python 3.6  .',
        formatStringInPattern: '     .',
        formatStringNestedFormatSpecifier: '       ',
        formatStringNestedQuote: 'f-string    Python 3.12  f-string     .',
        formatStringUnicode: '  (f-)   .',
        formatStringUnterminated: 'f-string    . } .',
        functionDecoratorTypeUnknown: '       .  ',
        functionInConditionalExpression: '  True   .',
        functionTypeParametersIllegal: '     Python 3.12  .',
        futureImportLocationNotAllowed: '__future__      .',
        generatorAsyncReturnType: 'async     "AsyncGenerator[{yieldType}, Any]"  .',
        generatorNotParenthesized: '        .',
        generatorSyncReturnType: '    "Generator[{yieldType}, Any, Any]"  .',
        genericBaseClassNotAllowed: '"Generic"          .',
        genericClassAssigned: '     .',
        genericClassDeleted: '     .',
        genericInstanceVariableAccess: '       .',
        genericNotAllowed: '  "Generic" .',
        genericTypeAliasBoundTypeVar: '        {names}()   .',
        genericTypeArgMissing: '"Generic"     .',
        genericTypeArgTypeVar: '"Generic"     .',
        genericTypeArgUnique: '"Generic"    .',
        globalReassignment: 'global   "{name}"() .',
        globalRedefinition: '"{name}"()  global .',
        implicitStringConcat: '    .',
        importCycleDetected: '   .',
        importDepthExceeded: '   {depth}() .',
        importResolveFailure: ' "{importName}"()   .',
        importSourceResolveFailure: '  "{importName}"()   .',
        importSymbolUnknown: '"{name}"()     .',
        incompatibleMethodOverride: '"{name}"     "{className}"  .',
        inconsistentIndent: '      .',
        inconsistentTabs: '      ',
        initMethodSelfParamTypeVar: '"__init__"  "self"            ',
        initMustReturnNone: '"__init__"   None .',
        initSubclassCallFailed: '__init_subclass__    ',
        initSubclassClsParam: '__init_subclass__  "cls"    .',
        initVarNotAllowed: '  "InitVar"  .',
        instanceMethodSelfParam: '  "self"    .',
        instanceVarOverridesClassVar: '{name}   {className}      .',
        instantiateAbstract: '\'{type}\'     .',
        instantiateProtocol: 'Protocol  "{type}"()   .',
        internalBindError: ' "{file}"()     . {message}',
        internalParseError: ' "{file}"()      . {message}',
        internalTypeCheckingError: ' "{file}"      . {message}',
        invalidIdentifierChar: '   .',
        invalidStubStatement: ' stub     .',
        invalidTokenChars: '   {text}() .',
        isInstanceInvalidType: '"isinstance"        tuple .',
        isSubclassInvalidType: '"issubclass"        tuple .',
        keyValueInSet: 'set  /    .',
        keywordArgInTypeArgument: '       .',
        keywordArgShortcutIllegal: '    Python 3.14  ',
        keywordOnlyAfterArgs: '     "*"      .',
        keywordParameterMissing: '     *     .',
        keywordSubscriptIllegal: '      .',
        lambdaReturnTypePartiallyUnknown: '   "{returnType}"()    .',
        lambdaReturnTypeUnknown: '     .',
        listAssignmentMismatch: ' "{type}"      .',
        listInAnnotation: '  List    .',
        literalEmptyArgs: 'Literal      .',
        literalNamedUnicodeEscape: '    "Literal"    .',
        literalNotAllowed: '     "Literal"   .',
        literalNotCallable: 'Literal    .',
        literalUnsupportedType: '"Literal"   None,  (int, bool, str  bytes)  enum  .',
        matchIncompatible: 'Match  Python 3.10  .',
        matchIsNotExhaustive: 'match        .',
        maxParseDepthExceeded: '    .      ',
        memberAccess: '"{type}"  "{name}"    ',
        memberDelete: '"{type}"  "{name}"    ',
        memberSet: '"{type}"  "{name}"    ',
        metaclassConflict: '        .',
        metaclassDuplicate: '    .',
        metaclassIsGeneric: '   .',
        methodNotDefined: '"{name}"   .',
        methodNotDefinedOnType: '"{name}"  "{type}"   .',
        methodOrdering: '     .',
        methodOverridden: '{name}() {className}       {type}  .',
        methodReturnsNonObject: '"{name}"    .',
        missingSuperCall: '"{methodName}"        .',
        mixingBytesAndStr: 'Bytes  str    .',
        moduleAsType: '    .',
        moduleNotCallable: '   .',
        moduleUnknownMember: '{memberName}() {moduleName}    ',
        namedExceptAfterCatchAll: ' except  catch-all except     .',
        namedParamAfterParamSpecArgs: 'ParamSpec args       "{name}"()    .',
        namedTupleEmptyName: ' tuple      .',
        namedTupleEntryRedeclared: '  "{className}"()  tuple "{name}"()   .',
        namedTupleFirstArg: ' tuple      .',
        namedTupleMultipleInheritance: 'NamedTuple     .',
        namedTupleNameKeyword: '    .',
        namedTupleNameType: '     2  tuple .',
        namedTupleNameUnique: ' tuple    .',
        namedTupleNoTypes: '"namedtuple"      .  "NamedTuple" ',
        namedTupleSecondArg: '    tuple  list .',
        newClsParam: '__new__  "cls"    .',
        newTypeAnyOrUnknown: 'NewType     Any  Unknown    .',
        newTypeBadName: 'NewType      .',
        newTypeLiteral: 'NewType Literal     .',
        newTypeNameMismatch: 'NewType     .',
        newTypeNotAClass: 'NewType      .',
        newTypeParamCount: 'NewType     .',
        newTypeProtocolClass: ' (Protocol  TypedDict )  NewType   .',
        noOverload: '   "{name}"   .',
        noReturnContainsReturn: ' return  "NoReturn"  return    .',
        noReturnContainsYield: '   "NoReturn"  yield    .',
        noReturnReturnsNone: '   "NoReturn"  "None"   .',
        nonDefaultAfterDefault: '     .',
        nonLocalInModule: '  Nonlocal    .',
        nonLocalNoBinding: 'No binding for nonlocal "{name}" found',
        nonLocalReassignment: '"{name}" is assigned before nonlocal declaration',
        nonLocalRedefinition: '"{name}"()  nonlocal .',
        noneNotCallable: 'None     .',
        noneNotIterable: '"None"        .',
        noneNotSubscriptable: 'None       .',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: '"None"   "{operator}"()  .',
        noneUnknownMember: '"{name}"() "None"   ',
        notRequiredArgCount: '"NotRequired"     .',
        notRequiredNotInTypedDict: '  "NotRequired"   .',
        objectNotCallable: '"{type}"     .',
        obscuredClassDeclaration: '  "{name}"()     .',
        obscuredFunctionDeclaration: '  "{name}"()    .',
        obscuredMethodDeclaration: '  "{name}"()    .',
        obscuredParameterDeclaration: '   "{name}"()    .',
        obscuredTypeAliasDeclaration: '   "{name}"()    .',
        obscuredVariableDeclaration: '"{name}"     .',
        operatorLessOrGreaterDeprecated: '"<>"  Python 3  .  "!=" .',
        optionalExtraArgs: '"Optional"  1   .',
        orPatternIrrefutable: '    or     .',
        orPatternMissingName: '"or"          .',
        overlappingKeywordArgs: '     {names}() .',
        overlappingOverload: '   {obscuredBy}()  "{name}"   {obscured}()  .',
        overloadAbstractImplMismatch: '     .',
        overloadAbstractMismatch: '    ',
        overloadClassMethodInconsistent: '"{name}"  @classmethod   .',
        overloadFinalInconsistencyImpl: '"{name}"   @final   .',
        overloadFinalInconsistencyNoImpl: '"{name}"   {index} @final   1  .',
        overloadImplementationMismatch: '   {index}   .',
        overloadReturnTypeMismatch: '"{name}"  {prevIndex}   {newIndex}()     .',
        overloadStaticMethodInconsistent: '"{name}"  @staticmethod   .',
        overloadWithoutImplementation: '{name}() overload     .',
        overriddenMethodNotFound: '{name}  override       .',
        overrideDecoratorMissing: '{name}  override   {className}    .',
        paramAfterKwargsParam: '  **     .',
        paramAlreadyAssigned: '  "{name}"()  .',
        paramAnnotationMissing: '{name}      .',
        paramAssignmentMismatch: '{sourceType}   {paramType}      .',
        paramNameMissing: ' "{name}"   .',
        paramSpecArgsKwargsDuplicate: 'ParamSpec "{type}"   .',
        paramSpecArgsKwargsUsage: 'ParamSpec "args"  "kwargs"       ',
        paramSpecArgsMissing: 'ParamSpec "{type}"   .',
        paramSpecArgsUsage: 'ParamSpec "args"  *args      ',
        paramSpecAssignedName: 'ParamSpec "{name}"   .',
        paramSpecContext: 'ParamSpec    .',
        paramSpecDefaultNotTuple: 'ParamSpec  , tuple   ParamSpec .',
        paramSpecFirstArg: '   ParamSpec  .',
        paramSpecKwargsUsage: 'ParamSpec "kwargs"  **kwargs      ',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}"()    .',
        paramSpecUnknownArg: 'ParamSpec      .',
        paramSpecUnknownMember: '"{name}"() ParamSpec   ',
        paramSpecUnknownParam: '{name}() ParamSpec      .',
        paramTypeCovariant: '(Covariant)        .',
        paramTypePartiallyUnknown: '  "{paramName}"     .',
        paramTypeUnknown: '  "{paramName}"    .',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: '  "{type}"    .',
        positionArgAfterNamedArg: '       .',
        positionOnlyAfterArgs: '      "*"      .',
        positionOnlyAfterKeywordOnly: '"/"   "*"     .',
        positionOnlyAfterNon: '            .',
        positionOnlyFirstParam: '           .',
        positionOnlyIncompatible: '      Python 3.8  .',
        privateImportFromPyTypedModule: '"{name}"() "{module}"   .',
        privateUsedOutsideOfClass: '"{name}"()     .',
        privateUsedOutsideOfModule: '"{name}"()     .',
        propertyOverridden: '{name}() {className}    property  .',
        propertyStaticMethod: 'Static methods not allowed for property getter, setter or deleter',
        protectedUsedOutsideOfClass: '{name}()     .',
        protocolBaseClass: 'Protocol  "{classType}"() Protocol   "{baseType}"   .',
        protocolBaseClassWithTypeArgs: '      Protocol     .',
        protocolIllegal: '"Protocol"  Python 3.7  .',
        protocolNotAllowed: '  "Protocol"   .',
        protocolTypeArgMustBeTypeParam: '"Protocol"      .',
        protocolUnsafeOverlap: ' "{name}"()         .',
        protocolVarianceContravariant: ' Protocol "{class}"    "{variable}"()  .',
        protocolVarianceCovariant: ' Protocol "{class}"    "{variable}"() (covariant) .',
        protocolVarianceInvariant: ' Protocol "{class}"    "{variable}"()  .',
        pyrightCommentInvalidDiagnosticBoolValue: 'Pyright    "=" true  false   .',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Pyright    "=" true, false, error, warning, information  none   .',
        pyrightCommentMissingDirective: 'Pyright   (basic  strict)     .',
        pyrightCommentNotOnOwnLine: '     Pyright     .',
        pyrightCommentUnknownDiagnosticRule: '"{rule}"() pyright       .',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}"() pyright    . true, false, error, warning, information  none .',
        pyrightCommentUnknownDirective: '"{directive}"() pyright      . "strict"  "basic" .',
        readOnlyArgCount: 'ReadOnly     .',
        readOnlyNotInTypedDict: '  "ReadOnly"   .',
        recursiveDefinition: '{name}      .',
        relativeImportNotAllowed: '  "import .a"     .  "from . import a"() .',
        requiredArgCount: 'Required     .',
        requiredNotInTypedDict: '  "Required"   .',
        returnInAsyncGenerator: '  Return  async    .',
        returnInExceptionGroup: '"except*"  "return"   ',
        returnMissing: '   "{returnType}"       .',
        returnOutsideFunction: 'return     .',
        returnTypeContravariant: '       .',
        returnTypeMismatch: ' "{exprType}"  "{returnType}"    .',
        returnTypePartiallyUnknown: '  "{returnType}"()    .',
        returnTypeUnknown: '    .',
        revealLocalsArgs: 'reveal_locals    .',
        revealLocalsNone: '  locals .',
        revealTypeArgs: '"reveal_type"     .',
        revealTypeExpectedTextArg: 'reveal_type  expected_text  str   .',
        revealTypeExpectedTextMismatch: '   . "{expected}"()  "{received}"() .',
        revealTypeExpectedTypeMismatch: '   . {expected}()  {received}() .',
        selfTypeContext: '  "Self" .',
        selfTypeMetaclass: '("type" )  "Self"   .',
        selfTypeWithTypedSelfOrCls: '"Self" "Self"     \'self\'  \'cls\'       .',
        setterGetterTypeMismatch: 'Property setter   getter     .',
        singleOverload: '"{name}"()     .',
        slotsAttributeError: '__slots__ {name}()  .',
        slotsClassVarConflict: '{name}() __slots__  instance  .',
        starPatternInAsPattern: '  "as"     .',
        starPatternInOrPattern: '     ORed  .',
        starStarWildcardNotAllowed: '**  "_"    .',
        staticClsSelfParam: '  "self"  "cls"     .',
        stdlibModuleOverridden: '{path}() {name} stdlib   .',
        stringNonAsciiBytes: 'ASCII       .',
        stringNotSubscriptable: '      .    .',
        stringUnsupportedEscape: '      .',
        stringUnterminated: '   .',
        stubFileMissing: '"{importName}"  stub    .',
        stubUsesGetAttr: ' stub  . "__getattr__"      .',
        sublistParamsIncompatible: 'Sublist   Python 3.x  .',
        superCallArgCount: 'super   2  .',
        superCallFirstArg: '"super"         "{type}"() .',
        superCallSecondArg: '"super"      "{type}"     .',
        superCallZeroArgForm: '"super"   0    .',
        superCallZeroArgFormStaticMethod: '"super"   0      .',
        symbolIsPossiblyUnbound: '"{name}"()     .',
        symbolIsUnbound: '"{name}"  .',
        symbolIsUndefined: '"{name}"()  .',
        symbolOverridden: '"{name}"()  "{className}"    .',
        ternaryNotAllowed: '  3   .',
        totalOrderingMissingMethod: ' total_ordering  "__lt__", "__le__", "__gt__"  "__ge__"    .',
        trailingCommaInFromImport: '       .',
        tryWithoutExcept: 'try  except  finally     .',
        tupleAssignmentMismatch: ' {type}   tuple   .',
        tupleInAnnotation: '  tuple    .',
        tupleIndexOutOfRange: '{index}  {type}   .',
        typeAliasIllegalExpressionForm: '      .',
        typeAliasIsRecursiveDirect: '  {name}     .',
        typeAliasNotInModuleOrClass: 'TypeAlias        .',
        typeAliasRedeclared: '"{name}"() TypeAlias      .',
        typeAliasStatementBadScope: 'type         .',
        typeAliasStatementIllegal: '   Python 3.12  .',
        typeAliasTypeBaseClass: '"type"         .',
        typeAliasTypeMustBeAssigned: 'TypeAliasType       .',
        typeAliasTypeNameArg: 'TypeAliasType          .',
        typeAliasTypeNameMismatch: '       .',
        typeAliasTypeParamInvalid: '    TypeVar, TypeVarTuple  ParamSpec  tuple .',
        typeAnnotationCall: '      .',
        typeAnnotationVariable: '     .',
        typeAnnotationWithCallable: '"type"     .   .',
        typeArgListExpected: 'ParamSpec,    list .',
        typeArgListNotAllowed: '   list    .',
        typeArgsExpectingNone: ' "{name}"    .',
        typeArgsMismatchOne: '    {received}() .',
        typeArgsMissingForAlias: '   "{name}"    .',
        typeArgsMissingForClass: '{name}      .',
        typeArgsTooFew: '"{name}"      . {expected}()  {received}() .',
        typeArgsTooMany: '{name}     . {expected}()  {received}() .',
        typeAssignmentMismatch: ' "{sourceType}"   "{destType}"   .',
        typeAssignmentMismatchWildcard: '  "{name}"   "{destType}"    "{sourceType}"  .',
        typeCallNotAllowed: 'type()      .',
        typeCheckOnly: '"{name}"() @type_check_only       .',
        typeCommentDeprecated: 'type     .  type  ',
        typeExpectedClass: '  "{type}"() ',
        typeFormArgs: '"TypeForm"    .',
        typeGuardArgCount: '"TypeGuard"  "TypeIs"     .',
        typeGuardParamCount: '  type guard          .',
        typeIsReturnType: 'TypeIs  ("{returnType}")    ("{type}")  .',
        typeNotAwaitable: '{type}() awaitable .',
        typeNotIntantiable: '"{type}"()   .',
        typeNotIterable: '"{type}"   .',
        typeNotSpecializable: '{type}    .',
        typeNotSubscriptable: '"{type}"     .',
        typeNotSupportBinaryOperator: '{operator}  {leftType}  {rightType}    .',
        typeNotSupportBinaryOperatorBidirectional: '  {expectedType}  {leftType}  {rightType}   {operator}   .',
        typeNotSupportUnaryOperator: '{type}  {operator}   .',
        typeNotSupportUnaryOperatorBidirectional: '  "{expectedType}"   "{type}"   "{operator}"()  .',
        typeNotUsableWith: '"{type}"   {method}()   "with"    .',
        typeParameterBoundNotAllowed: '          ParamSpec    .',
        typeParameterConstraintTuple: '          .',
        typeParameterExistingTypeParameter: '   "{name}"()   .',
        typeParameterNotDeclared: '   "{name}"() "{container}"       .',
        typeParametersMissing: '      .',
        typePartiallyUnknown: '"{name}"     .',
        typeUnknown: '"{name}"    .',
        typeVarAssignedName: 'TypeVar "{name}"   .',
        typeVarAssignmentMismatch: '{type}  {name}     .',
        typeVarBoundAndConstrained: 'TypeVar    .',
        typeVarBoundGeneric: 'TypeVar     .',
        typeVarConstraintGeneric: 'TypeVar      .',
        typeVarDefaultBoundMismatch: 'TypeVar       .',
        typeVarDefaultConstraintMismatch: 'TypeVar        .',
        typeVarDefaultIllegal: '    Python 3.13  .',
        typeVarDefaultInvalidTypeVar: '   "{name}"          .',
        typeVarFirstArg: 'TypeVar     .',
        typeVarInvalidForMemberVariable: '      "{name}"     ',
        typeVarNoMember: 'TypeVar "{type}"  "{name}"() ',
        typeVarNotSubscriptable: 'TypeVar "{type}"()   .',
        typeVarNotUsedByOuterScope: '  "{name}"()    .',
        typeVarPossiblyUnsolvable: ' {param}       {name}      .',
        typeVarSingleConstraint: 'TypeVar       .',
        typeVarTupleConstraints: 'TypeVarTuple      .',
        typeVarTupleContext: 'TypeVarTuple    .',
        typeVarTupleDefaultNotUnpacked: 'TypeVarTuple     tuple  TypeVarTuple .',
        typeVarTupleMustBeUnpacked: 'TypeVarTuple     .',
        typeVarTupleUnknownParam: '"{name}"() TypeVarTuple      .',
        typeVarUnknownParam: '{name}() TypeVar      .',
        typeVarUsedByOuterScope: 'TypeVar {name}()     .',
        typeVarUsedOnlyOnce: 'TypeVar "{name}"()      .',
        typeVarVariance: 'TypeVar    .',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}"   TypeVarTuple "{variadicName}"()   .',
        typeVarWithoutDefault: '{name}        {other}    .',
        typeVarsNotInGenericOrProtocol: 'Generic[]  Protocol[]     .',
        typedDictAccess: 'TypedDict    .',
        typedDictAssignedName: 'TypedDict "{name}"   .',
        typedDictBadVar: 'TypedDict      .',
        typedDictBaseClass: 'TypedDict     TypedDict  .',
        typedDictBoolParam: '"{name}"   True  False   .',
        typedDictClosedExtras: '  "{name}"() closed TypedDict.   "{type}"  .',
        typedDictClosedNoExtras: '  "{name}"() closed TypedDict.    .',
        typedDictDelete: 'TypedDict    .',
        typedDictEmptyName: 'TypedDict      .',
        typedDictEntryName: '     ',
        typedDictEntryUnique: '    .',
        typedDictExtraArgs: ' TypedDict   ',
        typedDictExtraItemsClosed: '    TypedDict closed  .',
        typedDictFieldNotRequiredRedefinition: 'TypedDict  "{name}"() NotRequired   .',
        typedDictFieldReadOnlyRedefinition: 'TypedDict  "{name}"() ReadOnly   .',
        typedDictFieldRequiredRedefinition: 'TypedDict  "{name}"() Required   .',
        typedDictFirstArg: 'TypedDict      .',
        typedDictInClassPattern: 'TypedDict      .',
        typedDictInitsubclassParameter: 'TypedDict __init_subclass__   "{name}"()  .',
        typedDictNotAllowed: '  "TypedDict"   .',
        typedDictSecondArgDict: '    dict     .',
        typedDictSecondArgDictEntry: '   .',
        typedDictSet: 'TypedDict    .',
        unaccessedClass: '{name}    .',
        unaccessedFunction: ' "{name}"   .',
        unaccessedImport: ' "{name}"   .',
        unaccessedSymbol: '"{name}"   .',
        unaccessedVariable: ' "{name}"   .',
        unannotatedFunctionSkipped: '  {name}   .',
        unaryOperationNotAllowed: '      .',
        unexpectedAsyncToken: '"async"  "def", "with"  "for" .',
        unexpectedExprToken: '     .',
        unexpectedIndent: '  ',
        unexpectedUnindent: '  ',
        unhashableDictKey: '    .',
        unhashableSetEntry: 'Set    .',
        uninitializedAbstractVariables: '     final  "{classType}"  .',
        uninitializedInstanceVariable: '  "{name}"()    __init__   .',
        unionForwardReferenceNotAllowed: 'Union      .     ',
        unionSyntaxIllegal: '     Python 3.10  .',
        unionTypeArgCount: 'Union     .',
        unionUnpackedTuple: 'Union   tuple   .',
        unionUnpackedTypeVarTuple: 'Union   TypeVarTuple   .',
        unnecessaryCast: ' "cast" .   {type}.',
        unnecessaryIsInstanceAlways: ' isinstance . "{testType}"()  "{classType}" .',
        unnecessaryIsInstanceNever: ' isinstance . "{testType}"()  "{classType}" .',
        unnecessaryIsSubclassAlways: ' issubclass . {testType}()  {classType}  .',
        unnecessaryIsSubclassNever: ' issubclass . {testType}()  {classType}  .',
        unnecessaryPyrightIgnore: ' "# pyright: ignore" .',
        unnecessaryPyrightIgnoreRule: ' "# pyright: ignore" : "{name}"',
        unnecessaryTypeIgnore: ' "# type: ignore" .',
        unpackArgCount: '"Unpack"     .',
        unpackExpectedTypeVarTuple: 'Unpack    TypeVarTuple  tuple .',
        unpackExpectedTypedDict: 'Unpack  TypedDict   .',
        unpackIllegalInComprehension: '      .',
        unpackInAnnotation: '  Unpack    .',
        unpackInDict: '     ',
        unpackInSet: 'set       .',
        unpackNotAllowed: '  Unpack  .',
        unpackOperatorNotAllowed: '      .',
        unpackTuplesIllegal: 'Python 3.8       .',
        unpackedArgInTypeArgument: '       ',
        unpackedArgWithVariadicParam: '   TypeVarTuple     .',
        unpackedDictArgumentNotMapping: '**    "str"    .',
        unpackedDictSubscriptIllegal: '        .',
        unpackedSubscriptIllegal: '     Python 3.11  .',
        unpackedTypeVarTupleExpected: '  TypeVarTuple . Unpack[{name1}]  *{name2} ',
        unpackedTypedDictArgument: '  TypedDict      .',
        unreachableCode: '   .',
        unreachableCodeType: '       .',
        unreachableExcept: '   Except    .',
        unsupportedDunderAllOperation: '"__all__"          .',
        unusedCallResult: '   {type}   .    _ .',
        unusedCoroutine: 'async     . "await"    ',
        unusedExpression: '   .',
        varAnnotationIllegal: '  type  Python 3.6  .     type  ',
        variableFinalOverride: ' "{name}"() Final  "{className}"    -Final  .',
        variadicTypeArgsTooMany: '      TypeVarTuple  tuple    .',
        variadicTypeParamTooManyAlias: '  TypeVarTuple          ({names}) .',
        variadicTypeParamTooManyClass: '  TypeVarTuple         ({names})() .',
        walrusIllegal: ' ":=" Python 3.8  .',
        walrusNotAllowed: '     ":="    .',
        wildcardInFunction: '     import  ',
        wildcardLibraryImport: '  import  .',
        wildcardPatternTypePartiallyUnknown: '       .',
        wildcardPatternTypeUnknown: '       .',
        yieldFromIllegal: '"yield from"  Python 3.3  .',
        yieldFromOutsideAsync: 'async  "yield from"   .',
        yieldOutsideFunction: '    yield   .',
        yieldWithinComprehension: 'comprehension  "yield"   .',
        zeroCaseStatementsFound: 'Match  case     .',
        zeroLengthTupleNotAllowed: ' 0 tuple    .'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '"Annotated"          .',
        argParam: ' "{paramName}"   .',
        argParamFunction: ' "{functionName}"  "{paramName}"   .',
        argsParamMissing: '*{paramName}      .',
        argsPositionOnly: '     . {expected})()  {received}() .',
        argumentType: '  "{type}".',
        argumentTypes: ' : ({types})',
        assignToNone: ' "None"   .',
        asyncHelp: 'async with ?',
        baseClassIncompatible: '  "{baseClass}"() "{type}"   .',
        baseClassIncompatibleSubclass: '  "{baseClass}"() "{type}"    "{subclass}" .',
        baseClassOverriddenType: '  "{baseClass}"()  "{type}"  .',
        baseClassOverridesType: '{baseClass}   {type}  .',
        bytesTypePromotions: 'disableBytesTypePromotions false  "bytearray"  "memoryview"      .',
        conditionalRequiresBool: '"{operandType}"    __bool__ "bool"  "{boolReturnType}"  .',
        dataClassFieldLocation: ' ',
        dataClassFrozen: '"{name}"()  .',
        dataProtocolUnsupported: '"{name}"()  .',
        descriptorAccessBindingFailed: '  "{className}"   "{name}"()  .',
        descriptorAccessCallFailed: '  "{className}"   "{name}"()  .',
        finalMethod: 'Final ',
        functionParamDefaultMissing: '{name}     .',
        functionParamName: '   : "{destName}"  "{srcName}"',
        functionParamPositionOnly: '     .   "{name}"()   .',
        functionReturnTypeMismatch: '{sourceType}    {destType}   .',
        functionTooFewParams: '      . {expected}()  {received}() .',
        functionTooManyParams: '      . {expected}()  {received}() .',
        genericClassNotAllowed: '         ',
        incompatibleDeleter: 'Property deleter   .',
        incompatibleGetter: 'Property getter   .',
        incompatibleSetter: 'Property setter   .',
        initMethodLocation: '__init__  "{type}"   .',
        initMethodSignature: '__init__  "{type}".',
        initSubclassLocation: '__init_subclass__  "{name}"   ',
        invariantSuggestionDict: '  (covariant) "dict" "Mapping"()   .',
        invariantSuggestionList: '(covariant) "list" "Sequence"   .',
        invariantSuggestionSet: '(covariant) "set" "Container"   .',
        isinstanceClassNotSupported: '"{type}"()      ',
        keyNotRequired: '{name}() {type}          .',
        keyReadOnly: '"{name}"() "{type}"   .',
        keyRequiredDeleted: '"{name}"()     .',
        keyUndefined: '"{name}" "{type}"   .',
        kwargsParamMissing: '**{paramName}      .',
        listAssignmentMismatch: '"{type}"     .',
        literalAssignmentMismatch: '"{sourceType}"  "{destType}"   .',
        matchIsNotExhaustiveHint: '     "case _: pass" .',
        matchIsNotExhaustiveType: '  : "{type}"',
        memberAssignment: '"{type}"   "{classType}"  "{name}"    ',
        memberIsAbstract: '"{type}.{name}"()  .',
        memberIsAbstractMore: '{count} ...',
        memberIsClassVarInProtocol: '"{name}"()  ClassVar .',
        memberIsInitVar: '"{name}"() init-only ',
        memberIsInvariant: '"{name}"()    .',
        memberIsNotClassVarInClass: '"{name}"()   ClassVar  .',
        memberIsNotClassVarInProtocol: '"{name}"()  ClassVar  .',
        memberIsNotReadOnlyInProtocol: '"{name}"()    .',
        memberIsReadOnlyInProtocol: '"{name}"()   .',
        memberIsWritableInProtocol: '"{name}"()    .',
        memberSetClassVar: '"{name}"  ClassVar      ',
        memberTypeMismatch: '"{name}"()   .',
        memberUnknown: ' "{name}"   ',
        metaclassConflict: ' "{metaclass1}"() "{metaclass2}"() .',
        missingDeleter: 'Property deleter  .',
        missingGetter: 'Property getter  .',
        missingSetter: 'Property setter  .',
        namedParamMissingInDest: '"{name}"   ',
        namedParamMissingInSource: '"{name}"    ',
        namedParamTypeMismatch: '"{sourceType}"     "{name}"() "{destType}"   ',
        namedTupleNotAllowed: '    NamedTuple   .',
        newMethodLocation: '__new__  "{type}"   .',
        newMethodSignature: '__new__   "{type}".',
        newTypeClassNotAllowed: 'NewType         .',
        noOverloadAssignable: '"{type}"     .',
        noneNotAllowed: '    None   ',
        orPatternMissingName: ' : {name}',
        overloadIndex: ' {index}()    .',
        overloadNotAssignable: '"{name}"      .',
        overloadSignature: '    .',
        overriddenMethod: ' ',
        overriddenSymbol: ' ',
        overrideInvariantMismatch: '"{overrideType}"   "{baseType}"    .',
        overrideIsInvariant: '      .',
        overrideNoOverloadMatches: '      .',
        overrideNotClassMethod: '  classmethod     ',
        overrideNotInstanceMethod: '  instance   ',
        overrideNotStaticMethod: '  staticmethod    .',
        overrideOverloadNoMatch: '      .',
        overrideOverloadOrder: '        .',
        overrideParamKeywordNoDefault: '{name}    .       .    .',
        overrideParamKeywordType: '{name}      .     {baseType},     {overrideType}.',
        overrideParamName: '{index}     .     {baseName}.     {overrideName}.',
        overrideParamNameExtra: '   "{name}"() .',
        overrideParamNameMissing: ' {name}   .',
        overrideParamNamePositionOnly: '  {index} :    "{baseName}"()        ',
        overrideParamNoDefault: '{index}   .       .    .',
        overrideParamType: '{index}     .     {baseType},     {overrideType}.',
        overridePositionalParamCount: '     .   {baseCount}   {overrideCount} .',
        overrideReturnType: '  :   "{baseType}"    "{overrideType}"  .',
        overrideType: '   "{type}" .',
        paramAssignment: '  {index}: "{sourceType}"  "{destType}"   ',
        paramSpecMissingInOverride: '  ParamSpec   .',
        paramType: '   "{paramType}".',
        privateImportFromPyTypedSource: ' "{module}" ',
        propertyAccessFromProtocolClass: '         .',
        propertyMethodIncompatible: 'Property  "{name}"()  .',
        propertyMethodMissing: 'Property  {name}  .',
        propertyMissingDeleter: '"{name}" property  deleter .',
        propertyMissingSetter: '"{name}" property  setter .',
        protocolIncompatible: '{sourceType}() {destType}   .',
        protocolMemberMissing: '"{name}"() .',
        protocolRequiresRuntimeCheckable: '      Protocol  @runtime_checkable .',
        protocolSourceIsNotConcrete: '{sourceType}()     {destType}    .',
        protocolUnsafeOverlap: '"{name}"    .',
        pyrightCommentIgnoreTip: '"# pyright: ignore[<diagnostic rules>]"       .',
        readOnlyAttribute: ' "{name}"()  .',
        seeClassDeclaration: '  ',
        seeDeclaration: ' ',
        seeFunctionDeclaration: '  ',
        seeMethodDeclaration: '  ',
        seeParameterDeclaration: '   ',
        seeTypeAliasDeclaration: '   ',
        seeVariableDeclaration: '  ',
        tupleAssignmentMismatch: '"{type}"   tuple  .',
        tupleEntryTypeMismatch: 'Tuple  {entry}()  .',
        tupleSizeIndeterminateSrc: 'Tuple  : {expected}()   .',
        tupleSizeIndeterminateSrcDest: 'Tuple  : {expected}    .',
        tupleSizeMismatch: 'Tuple  : {expected}()  {received}() .',
        tupleSizeMismatchIndeterminateDest: 'Tuple  : {expected}   {received}() .',
        typeAliasInstanceCheck: '"type"            .',
        typeAssignmentMismatch: ' "{sourceType}"  "{destType}"   .',
        typeBound: '  "{name}"   "{destType}"  "{sourceType}"   .',
        typeConstrainedTypeVar: ' "{type}"    "{name}"   .',
        typeIncompatible: '"{sourceType}" "{destType}"   .',
        typeNotClass: '"{type}"  .',
        typeNotStringLiteral: '{type}()   .',
        typeOfSymbol: '{name}  {type}.',
        typeParamSpec: '"{type}"  ParamSpec "{name}"()  .',
        typeUnsupported: '"{type}"   .',
        typeVarDefaultOutOfScope: '  "{name}"()  .',
        typeVarIsContravariant: '"{name}"      ) "{sourceType}"() "{destType}"   .',
        typeVarIsCovariant: '"{name}"    (covariant) "{sourceType}"() "{destType}"   .',
        typeVarIsInvariant: '"{name}"     "{sourceType}"() "{destType}"  .',
        typeVarNotAllowed: '    TypeVar  ',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple     tuple   .',
        typeVarUnnecessarySuggestion: ' {type}() .',
        typeVarUnsolvableRemedy: '        .',
        typeVarsMissing: '  : {names}',
        typedDictBaseClass: '"{type}"  TypedDict .',
        typedDictClassNotAllowed: '    TypedDict    .',
        typedDictClosedExtraNotAllowed: ' "{name}"()   ',
        typedDictClosedExtraTypeMismatch: ' "{type}"  "{name}"()   ',
        typedDictClosedFieldNotRequired: '"{name}"  NotRequired    .',
        typedDictExtraFieldNotAllowed: '"{name}"() "{type}" ',
        typedDictExtraFieldTypeMismatch: '"{name}"  "{type}" "extra_items"   .',
        typedDictFieldMissing: '"{name}"() "{type}" .',
        typedDictFieldNotReadOnly: '"{name}"() "{type}"   .',
        typedDictFieldNotRequired: '"{name}"() "{type}"  .',
        typedDictFieldRequired: '"{type}" "{name}"() .',
        typedDictFieldTypeMismatch: '"{type}"  "{name}"    .',
        typedDictFieldUndefined: '"{name}"() "{type}"    .',
        typedDictFinalMismatch: '@final   "{sourceType}"() "{destType}"()  .',
        typedDictKeyAccess: 'TypedDict   ["{name}"]() .',
        typedDictNotAllowed: 'TypedDict       .',
        unhashableType: '{type}    .',
        uninitializedAbstractVariable: '  "{name}"()    "{classType}"    .',
        unreachableExcept: '"{exceptionType}"() "{parentType}" .',
        useDictInstead: '   Dict[T1, T2] .',
        useListInstead: 'List[T]  list   Union[T1, T2]  union  .',
        useTupleInstead: 'tuple[T1, ..., Tn]  tuple   Union[T1, T2]  union  .',
        useTypeInstead: ' Type[T] ',
        varianceMismatchForClass: '{typeVarName}    {className}    .',
        varianceMismatchForTypeAlias: '{typeVarName}    {typeAliasParam}()  .'
      },
      Service: {
        longOperation: '        .      . [ ](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  96838: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Utwrz typ zastpczy Stub',
        createTypeStubFor: 'Utwrz typ Stub dla {moduleName}',
        executingCommand: 'Wykonywanie polecenia',
        filesToAnalyzeCount: 'Pliki do przeanalizowania: {count}',
        filesToAnalyzeOne: '1 plik do analizy',
        findingReferences: 'Znajdowanie odwoa',
        organizeImports: 'Organizuj dyrektywy Import',
        renameShadowedFile: 'Zmie nazw {oldFile} na {newFile}'
      },
      Completion: {
        autoImportDetail: 'Automatyczne importowanie',
        indexValueDetail: 'Warto indeksu'
      },
      Diagnostic: {
        abstractMethodInvocation: 'Nie mona wywoa metody {method}, poniewa jest abstrakcyjna i niezaimplementowana',
        annotatedMetadataInconsistent: 'Opisany typ metadanych {metadataType} nie jest zgodny z typem {type}',
        annotatedParamCountMismatch: 'Niezgodno liczby adnotacji parametru; oczekiwano {expected}, a uzyskano {received}',
        annotatedTypeArgMissing: 'Oczekiwano jednego argumentu typu i co najmniej jednej adnotacji dla wartoci Annotated',
        annotationBytesString: 'Wyraenia typu nie mog uywa literaw cigu bajtw',
        annotationFormatString: 'Wyraenia typu nie mog uywa literaw cigw formatu (cigw f)',
        annotationNotSupported: 'Adnotacja typu nie jest obsugiwana dla tej instrukcji',
        annotationRawString: 'Wyraenia typu nie mog uywa nieprzetworzonych literaw cigw',
        annotationSpansStrings: 'Wyraenia typu nie mog obejmowa wielu literaw cigw',
        annotationStringEscape: 'Wyraenia typu nie mog zawiera znakw ucieczki',
        argAssignment: 'Argumentu typu {argType} nie mona przypisa do parametru typu {paramType}',
        argAssignmentFunction: 'Argumentu typu {argType} nie mona przypisa do parametru typu {paramType} w funkcji {functionName}',
        argAssignmentParam: 'Argumentu typu {argType} nie mona przypisa do parametru {paramName} typu {paramType}',
        argAssignmentParamFunction: 'Argumentu typu {argType} nie mona przypisa do parametru {paramName} typu {paramType} w funkcji {functionName}',
        argMissingForParam: 'Brak argumentu dla parametru {name}',
        argMissingForParams: 'Brak argumentw dla parametrw {names}',
        argMorePositionalExpectedCount: 'Oczekiwano wikszej liczby argumentw pozycyjnych: {expected}',
        argMorePositionalExpectedOne: 'Oczekiwano jeszcze 1 argumentu pozycyjnego',
        argPositional: 'Oczekiwano argumentu pozycyjnego',
        argPositionalExpectedCount: 'Oczekiwano liczby argumentw pozycyjnych: {expected}',
        argPositionalExpectedOne: 'Oczekiwano 1 argumentu pozycyjnego',
        argTypePartiallyUnknown: 'Typ argumentu jest czciowo nieznany',
        argTypeUnknown: 'Typ argumentu jest nieznany',
        assertAlwaysTrue: 'Wyraenie Assert zawsze ma warto true',
        assertTypeArgs: 'Typ assert_type oczekuje dwch argumentw pozycyjnych',
        assertTypeTypeMismatch: 'Niezgodno assert_type; oczekiwano {expected}, ale otrzymano {received}',
        assignmentExprComprehension: 'Element docelowy wyraenia przypisania {name} nie moe uywa tej samej nazwy co zrozumienie dla elementu docelowego',
        assignmentExprContext: 'Wyraenie przypisania musi nalee do moduu, funkcji lub wyraenia lambda',
        assignmentExprInSubscript: 'Wyraenia przypisania w indeksie dolnym s obsugiwane tylko w jzyku Python w wersji 3.10 i nowszej',
        assignmentInProtocol: 'Zmienne wystpienia lub klasy w klasie Protocol musz by jawnie zadeklarowane w treci klasy',
        assignmentTargetExpr: 'Wyraenie nie moe by elementem docelowym przypisania',
        asyncNotInAsyncFunction: 'Uycie warto async jest niedozwolone poza funkcj asynchroniczn',
        awaitIllegal: 'Uycie await wymaga jzyka Python w wersji 3.5 lub nowszej',
        awaitNotAllowed: 'Wyraenia typu nie mog uywa instrukcji await',
        awaitNotInAsync: 'Warto await jest dozwolona tylko w ramach funkcji asynchronicznej',
        backticksIllegal: 'Wyraenia otoczone znakami wstecznymi nie s obsugiwane w jzyku Python w wersji 3.x; zamiast tego uyj wyraenia repr',
        baseClassCircular: 'Klasa nie moe pochodzi od samej siebie',
        baseClassFinal: 'Klasa bazowa {type} jest oznaczona jako final i nie mona jej podzieli na podklasy',
        baseClassIncompatible: 'Klasy bazowe typu {type} s wzajemnie niezgodne',
        baseClassInvalid: 'Argument klasy musi by klas bazow',
        baseClassMethodTypeIncompatible: 'Klasy bazowe dla klasy {classType} definiuj metod {name} w niezgodny sposb',
        baseClassUnknown: 'Typ klasy bazowej jest nieznany, zasaniajc typ klasy pochodnej',
        baseClassVariableTypeIncompatible: 'Klasy bazowe dla klasy {classType} definiuj zmienn {name} w niezgodny sposb',
        binaryOperationNotAllowed: 'Operator binarny nie jest dozwolony w wyraeniu typu',
        bindTypeMismatch: 'Nie mona powiza metody {methodName}, poniewa nie mona przypisa typu {type} do parametru {paramName}',
        breakInExceptionGroup: 'break nie jest dozwolone w bloku except*',
        breakOutsideLoop: 'Warto break moe by uywana tylko w ptli',
        callableExtraArgs: 'Oczekiwano tylko dwch argumentw typu Callable',
        callableFirstArg: 'Oczekiwano listy typw parametrw lub znakw ...',
        callableNotInstantiable: 'Nie mona utworzy wystpienia typu {type}',
        callableSecondArg: 'Oczekiwano zwracanego typu jako drugiego argumentu typu dla elementu Callable',
        casePatternIsIrrefutable: 'Niepodwaalny wzorzec jest dozwolony tylko dla ostatniej instrukcji dotyczcej wielkoci liter',
        classAlreadySpecialized: 'Typ {type} jest ju wyspecjalizowany',
        classDecoratorTypeUnknown: 'Dekorator klasy bez typu przesania typ klasy; ignorowanie dekoratora',
        classDefinitionCycle: 'Definicja klasy dla {name} zaley od niej samej',
        classGetItemClsParam: 'Przesonicie __class_getitem__ powinno przyjmowa parametr cls.',
        classMethodClsParam: 'Metody klasy powinny przyjmowa parametr cls',
        classNotRuntimeSubscriptable: 'Indeks dolny dla klasy {name} wygeneruje wyjtek rodowiska uruchomieniowego; umieci wyraenie typu w cudzysowy',
        classPatternBuiltInArgPositional: 'Wzorzec klasy akceptuje tylko podwzorzec pozycyjny',
        classPatternPositionalArgCount: 'Zbyt wiele wzorcw pozycyjnych dla klasy {type}; oczekiwano {expected}, ale otrzymano {received}',
        classPatternTypeAlias: '{type} nie moe by uywany we wzorcu klasy, poniewa jest to alias typu specjalnego',
        classPropertyDeprecated: 'Waciwoci klasy s przestarzae w jzyku Python 3.11 i nie bd obsugiwane w jzyku Python 3.13',
        classTypeParametersIllegal: 'Skadnia parametru typu klasy wymaga jzyka Python w wersji 3.12 lub nowszej',
        classVarFirstArgMissing: 'Oczekiwano argumentu typu po wartoci ClassVar',
        classVarNotAllowed: 'Element ClassVar jest niedozwolony w tym kontekcie',
        classVarOverridesInstanceVar: 'Zmienna klasy {name} przesania zmienn wystpienia o tej samej nazwie w klasie {className}',
        classVarTooManyArgs: 'Oczekiwano tylko jednego argumentu typu po wartoci ClassVar',
        classVarWithTypeVar: 'Typ ClassVar nie moe zawiera zmiennych typu',
        clsSelfParamTypeMismatch: 'Typ parametru {name} musi by nadtypem jego klasy {classType}',
        codeTooComplexToAnalyze: 'Kod jest zbyt zoony, aby go analizowa; zmniejsz zoono przez refaktoryzacj w podprocedury lub poprzez zmniejszenie cieek kodu warunkowego',
        collectionAliasInstantiation: 'Nie mona utworzy wystpienia typu {type}. Zamiast niego uyj {alias}',
        comparisonAlwaysFalse: 'Warunek zawsze bdzie mia warto False, poniewa typy {leftType} i {rightType} nie nakadaj si',
        comparisonAlwaysTrue: 'Warunek zawsze bdzie mia warto True, poniewa typy {leftType} i {rightType} nie nakadaj si',
        comprehensionInDict: 'Zrozumienia nie mona uywa z innymi wpisami sownika',
        comprehensionInSet: 'Nie mona uywa rozumienia z innymi wpisami set',
        concatenateContext: 'Klasa Concatenate jest niedozwolona w tym kontekcie',
        concatenateParamSpecMissing: 'Ostatni argument typu dla elementu Concatenate musi mie warto ParamSpec lub ...',
        concatenateTypeArgsMissing: 'Element Concatenate wymaga co najmniej dwch argumentw typu',
        conditionalOperandInvalid: 'Nieprawidowy warunkowy argument operacji typu {type}',
        constantRedefinition: 'Nazwa {name} jest sta (poniewa jest pisana wielkimi literami) i nie mona jej ponownie zdefiniowa',
        constructorParametersMismatch: 'Niezgodno midzy sygnatur __new__ i __init__ w klasie {classType}',
        containmentAlwaysFalse: 'Warunek zawsze bdzie mia warto False, poniewa typy {leftType} i {rightType} nie nakadaj si na siebie',
        containmentAlwaysTrue: 'Warunek zawsze bdzie mia warto True, poniewa typy {leftType} i {rightType} nie nakadaj si na siebie',
        continueInExceptionGroup: 'continue nie jest dozwolone w bloku except*',
        continueOutsideLoop: 'Warto continue moe by uywana tylko w ptli',
        coroutineInConditionalExpression: 'Wyraenie warunkowe odwouje si do koprocedury, ktra zawsze wyznacza warto True',
        dataClassBaseClassFrozen: 'Klasa niezablokowana nie moe dziedziczy po klasie zablokowanej',
        dataClassBaseClassNotFrozen: 'Zamroona klasa nie moe dziedziczy po klasie niezamroonej',
        dataClassConverterFunction: 'Argument typu {argType} nie jest prawidowym konwerterem pola {fieldName} typu {fieldType}',
        dataClassConverterOverloads: 'adne przecienia {funcName} nie s prawidowymi konwerterami dla pola {fieldName} typu {fieldType}',
        dataClassFieldInheritedDefault: 'Pole {fieldName} zastpuje pole o tej samej nazwie, ale brakuje wartoci domylnej',
        dataClassFieldWithDefault: 'Pola bez wartoci domylnych nie mog wystpowa po polach z wartociami domylnymi',
        dataClassFieldWithPrivateName: 'Pole klasy danych nie moe uywa nazwy prywatnej',
        dataClassFieldWithoutAnnotation: 'Pole klasy danych bez adnotacji typu spowoduje wyjtek rodowiska uruchomieniowego',
        dataClassPostInitParamCount: 'Klasa danych __post_init__ ma niepoprawn liczb parametrw; oczekiwana liczba pl InitVar to: {expected}',
        dataClassPostInitType: 'Klasa danych __post_init__ ma niezgodno typu parametru metody dla pola {fieldName}',
        dataClassSlotsOverwrite: 'Element __slots__ jest ju zdefiniowany w klasie',
        dataClassTransformExpectedBoolLiteral: 'Oczekiwano wyraenia, ktre statycznie daje w wyniku warto True lub False',
        dataClassTransformFieldSpecifier: 'Oczekiwano spjnej kolekcji (tuple) klas lub funkcji, a uzyskano typ {type}',
        dataClassTransformPositionalParam: 'Wszystkie argumenty elementu dataclass_transform musz by argumentami sw kluczowych',
        dataClassTransformUnknownArgument: 'Argument {name} nie jest obsugiwany przez dataclass_transform',
        dataProtocolInSubclassCheck: 'Protokoy danych (ktre zawieraj atrybuty niebdce atrybutami metody) s niedozwolone w wywoaniach klasy issubclass',
        declaredReturnTypePartiallyUnknown: 'Zadeklarowany zwracany typ {returnType} jest czciowo nieznany',
        declaredReturnTypeUnknown: 'Deklarowany zwracany typ jest nieznany',
        defaultValueContainsCall: 'Wywoania funkcji i modyfikowalne obiekty s niedozwolone w wyraeniu wartoci domylnej parametru',
        defaultValueNotAllowed: 'Parametr o wartoci * lub ** nie moe mie wartoci domylnej',
        delTargetExpr: 'Nie mona usun wyraenia',
        deprecatedClass: 'Klasa {name} jest przestarzaa',
        deprecatedConstructor: 'Konstruktor klasy {name} jest przestarzay',
        deprecatedDescriptorDeleter: 'Metoda __set__ dla deskryptora {name} jest przestarzaa',
        deprecatedDescriptorGetter: 'Metoda __set__ dla deskryptora {name} jest przestarzaa',
        deprecatedDescriptorSetter: 'Metoda __set__ dla deskryptora {name} jest przestarzaa',
        deprecatedFunction: 'Ta funkcja {name} jest przestarzaa',
        deprecatedMethod: 'Metoda {name} w klasie {className} jest przestarzaa',
        deprecatedPropertyDeleter: 'deleter dla property {name} jest przestarzaa',
        deprecatedPropertyGetter: 'getter dla property {name} jest przestarzaa',
        deprecatedPropertySetter: 'setter dla property {name} jest przestarzaa',
        deprecatedType: 'Ten typ jest przestarzay dla jzyka Python w wersji {version}; zamiast tego uyj {replacement}.',
        dictExpandIllegalInComprehension: 'Rozszerzanie sownika jest niedozwolone w rozumieniu',
        dictInAnnotation: 'Wyraenie sownika jest niedozwolone w wyraeniu typu',
        dictKeyValuePairs: 'Wpisy sownika musz zawiera pary klucz/warto',
        dictUnpackIsNotMapping: 'Oczekiwano mapowania dla operatora rozpakowywania sownika',
        dunderAllSymbolNotPresent: 'Nazwa {name} jest okrelona w wartoci __all__, ale nie wystpuje w module',
        duplicateArgsParam: 'Dozwolony tylko jeden parametr *',
        duplicateBaseClass: 'Zduplikowana klasa bazowa jest niedozwolona',
        duplicateCapturePatternTarget: 'Element docelowy przechwytywania {name} nie moe wystpowa wicej ni raz w obrbie tego samego wzorca',
        duplicateCatchAll: 'Dozwolona jest tylko jedna klauzula typu catch-all except klauzuli',
        duplicateEnumMember: 'Skadowa Enum {name} jest ju zadeklarowana',
        duplicateGenericAndProtocolBase: 'Dozwolona jest tylko jedna klasa bazowa Generic[...] lub Protocol[...].',
        duplicateImport: 'Nazwa {importName} zostaa zaimportowana wicej ni raz',
        duplicateKeywordOnly: 'Dozwolony tylko jeden separator *.',
        duplicateKwargsParam: 'Dozwolony tylko jeden parametr **.',
        duplicateParam: 'Duplikuj parametr {name}',
        duplicatePositionOnly: 'Dozwolony tylko jeden parametr /',
        duplicateStarPattern: 'W sekwencji wzorca dozwolony jest tylko jeden wzorzec *',
        duplicateStarStarPattern: 'Dozwolony jest tylko jeden wpis **',
        duplicateUnpack: 'Na list dozwolona jest tylko jedna operacja rozpakowywania',
        ellipsisAfterUnpacked: 'Nie mona uywa ... z rozpakowanym parametrem TypeVarTuple lub kolekcj tuple',
        ellipsisContext: 'Warto ... jest niedozwolona w tym kontekcie',
        ellipsisSecondArg: 'Warto ... jest dozwolona tylko jako drugi z dwch argumentw',
        enumClassOverride: 'Klasa Enum {name} jest final i nie mona jej podzieli na podklasy',
        enumMemberDelete: 'Nie mona usun skadowej Enum "{name}"',
        enumMemberSet: 'Nie mona przypisa skadowej Enum {name}',
        enumMemberTypeAnnotation: 'Adnotacje typu nie s dozwolone dla skadowych enum',
        exceptGroupMismatch: 'Instrukcja Try nie moe zawiera jednoczenie except i except*',
        exceptGroupRequiresType: 'Skadnia grupy wyjtkw ("except*") wymaga typu wyjtku',
        exceptionGroupIncompatible: 'Skadnia grupy wyjtkw (except*) wymaga jzyka Python w wersji 3.11 lub nowszej',
        exceptionGroupTypeIncorrect: 'Typ wyjtku w wyraeniu except* nie moe pochodzi z grupy BaseGroupException',
        exceptionTypeIncorrect: 'Typ {type} nie pochodzi od parametru BaseException',
        exceptionTypeNotClass: 'Typ {type} nie jest prawidow klas wyjtku',
        exceptionTypeNotInstantiable: 'Konstruktor typu wyjtku {type} wymaga co najmniej jednego argumentu',
        expectedAfterDecorator: 'Oczekiwano deklaracji funkcji lub klasy po dekoratorze',
        expectedArrow: 'Oczekiwano wartoci ->, po ktrej nastpuje adnotacja zwracanego typu',
        expectedAsAfterException: 'Oczekiwano wartoci as po typie wyjtku',
        expectedAssignRightHandExpr: 'Oczekiwano wyraenia po prawej stronie znaku =',
        expectedBinaryRightHandExpr: 'Oczekiwano wyraenia po prawej stronie operatora',
        expectedBoolLiteral: 'Oczekiwano wartoci True lub False',
        expectedCase: 'Oczekiwano instrukcji case',
        expectedClassName: 'Oczekiwano nazwy klasy',
        expectedCloseBrace: 'Brak zamknicia dla: {',
        expectedCloseBracket: 'Brak zamknicia dla: [',
        expectedCloseParen: 'Brak zamknicia dla: (',
        expectedColon: 'Oczekiwano :',
        expectedComplexNumberLiteral: 'Oczekiwano literau liczby zespolonej na potrzeby dopasowywania wzorca',
        expectedDecoratorExpr: 'Formularz wyraenia nie jest obsugiwany przez dekorator w wersji wczeniejszej ni Python 3.9',
        expectedDecoratorName: 'Oczekiwano nazwy dekoratora',
        expectedDecoratorNewline: 'Oczekiwano nowego wiersza na kocu dekoratora',
        expectedDelExpr: 'Oczekiwano wyraenia po del',
        expectedElse: 'Oczekiwano elementu else',
        expectedEquals: 'Oczekiwano =',
        expectedExceptionClass: 'Nieprawidowa klasa lub obiekt wyjtku',
        expectedExceptionObj: 'Oczekiwano obiektu wyjtku, klasy wyjtku lub wartoci None',
        expectedExpr: 'Oczekiwano wyraenia',
        expectedFunctionAfterAsync: 'Oczekiwano definicji funkcji po wartoci async',
        expectedFunctionName: 'Oczekiwano nazwy funkcji po wyraeniu def',
        expectedIdentifier: 'Oczekiwany identyfikator',
        expectedImport: 'Oczekiwano wartoci import',
        expectedImportAlias: 'Oczekiwano symbolu po parametrze as',
        expectedImportSymbols: 'Oczekiwano jednej lub wicej nazw symboli po wyraeniu import',
        expectedIn: 'Oczekiwano parametru in',
        expectedInExpr: 'Oczekiwano wyraenia po in',
        expectedIndentedBlock: 'Oczekiwano wcitego bloku',
        expectedMemberName: 'Oczekiwano nazwy atrybutu po .',
        expectedModuleName: 'Oczekiwana nazwa moduu',
        expectedNameAfterAs: 'Oczekiwano nazwy symbolu po wartoci as',
        expectedNamedParameter: 'Parametr sowa kluczowego musi nastpowa po znaku *',
        expectedNewline: 'Oczekiwano nowego wiersza',
        expectedNewlineOrSemicolon: 'Instrukcje musz by oddzielone znakami nowych wierszy lub rednikami',
        expectedOpenParen: 'Oczekiwano (',
        expectedParamName: 'Oczekiwano nazwy parametru',
        expectedPatternExpr: 'Oczekiwano wyraenia wzorca',
        expectedPatternSubjectExpr: 'Oczekiwano wyraenia tematu wzorca',
        expectedPatternValue: 'Oczekiwano wyraenia wartoci wzorca w postaci a.b',
        expectedReturnExpr: 'Oczekiwano wyraenia po return.',
        expectedSliceIndex: 'Oczekiwano wyraenia indeksu lub wycinka',
        expectedTypeNotString: 'Oczekiwano typu, ale otrzymano litera cigu',
        expectedTypeParameterName: 'Oczekiwano nazwy parametru typu',
        expectedYieldExpr: 'Oczekiwano wyraenia w instrukcji yield',
        finalClassIsAbstract: 'Klasa {type} jest oznaczona jako final i musi implementowa wszystkie symbole abstrakcyjne',
        finalContext: 'Warto Final jest niedozwolona w tym kontekcie',
        finalInLoop: 'Nie mona przypisa zmiennej Final w ptli',
        finalMethodOverride: 'Metoda {name} nie moe przesoni metody final zdefiniowanej w klasie {className}',
        finalNonMethod: 'Nie mona oznaczy funkcji {name} jako @final, poniewa nie jest to metoda',
        finalReassigned: 'Element {name} jest zadeklarowany jako wersja Final i nie mona go ponownie przypisa',
        finalRedeclaration: 'Nazwa {name} zostaa wczeniej zadeklarowana jako Final',
        finalRedeclarationBySubclass: 'Nie mona ponownie zadeklarowa nazwy {name}, poniewa klasa nadrzdna {className} deklaruje j jako Final',
        finalTooManyArgs: 'Oczekiwano jednego argumentu typu po wartoci Final',
        finalUnassigned: 'Nazwa {name} jest zadeklarowana jako warto Final, ale warto nie jest przypisana',
        formatStringBrace: 'Pojedynczy zamykajcy nawias klamrowy jest niedozwolony w literale cigu f; uyj podwjnego zamykajcego nawiasu klamrowego',
        formatStringBytes: 'Literay cigw formatu (cigi f) nie mog by binarne',
        formatStringDebuggingIllegal: 'Specyfikator debugowania cigu f = wymaga wersji jzyka Python 3.8 lub nowszej',
        formatStringEscape: 'Sekwencja ucieczki (ukonik odwrotny) jest niedozwolona w czci wyraenia cigu f w wersji jzyka wczeniejszej ni Python 3.12',
        formatStringExpectedConversion: 'Oczekiwano specyfikatora konwersji po znaku ! w cigu f-string',
        formatStringIllegal: 'Literay cigw formatu (cigi f) wymagaj wersji jzyka Python 3.6 lub nowszej',
        formatStringInPattern: 'Cig formatu jest niedozwolony we wzorcu',
        formatStringNestedFormatSpecifier: 'Wyraenia zagniedone zbyt gboko w specyfikatorze cigu formatu',
        formatStringNestedQuote: 'Cigi zagniedone w cigu f nie mog uywa tego samego znaku cudzysowu co cig f w wersji jzyka wczeniejszej ni Python 3.12',
        formatStringUnicode: 'Literay cigu formatu (f-strings) nie mog by formatu unicode',
        formatStringUnterminated: 'Niezakoczone wyraenie w cigu f; oczekiwano znaku }',
        functionDecoratorTypeUnknown: 'Nietypowany dekorator funkcji zasania typ funkcji; ignorujc dekoratora',
        functionInConditionalExpression: 'Wyraenie warunkowe odwouje si do funkcji, ktrej wynikiem zawsze jest warto True',
        functionTypeParametersIllegal: 'Skadnia parametru typu klasy wymaga wersji jzyka Python 3.12 lub nowszej',
        futureImportLocationNotAllowed: 'Importy z __future__ musz znajdowa si na pocztku pliku',
        generatorAsyncReturnType: 'Zwracany typ funkcji generatora asynchronicznego musi by zgodny z elementem AsyncGenerator[{yieldType}, Any]',
        generatorNotParenthesized: 'Wyraenia generatora musz by ujte w nawiasy, jeli nie s jedynym argumentem',
        generatorSyncReturnType: 'Zwracany typ funkcji generatora musi by zgodny z elementem Generator[{yieldType}, Any, Any]',
        genericBaseClassNotAllowed: 'Nie mona uy klasy bazowej Generic ze skadni parametru typu',
        genericClassAssigned: 'Nie mona przypisa oglnego typu klasy',
        genericClassDeleted: 'Nie mona usun oglnego typu klasy',
        genericInstanceVariableAccess: 'Dostp do oglnej zmiennej wystpienia za porednictwem klasy jest niejednoznaczny',
        genericNotAllowed: 'Element Generic jest nieprawidowy w tym kontekcie',
        genericTypeAliasBoundTypeVar: 'Alias typu oglnego w klasie nie moe uywa zmiennych typu powizanego {names}',
        genericTypeArgMissing: 'Warto Generic wymaga co najmniej jednego argumentu typu',
        genericTypeArgTypeVar: 'Argument typu dla wartoci Generic musi by zmienn typu',
        genericTypeArgUnique: 'Argumenty typu dla elementu Generic musz by unikatowe',
        globalReassignment: 'Nazwa {name} jest przypisywana przed deklaracj globaln',
        globalRedefinition: 'Nazwa {name} zostaa ju zadeklarowana jako globalna',
        implicitStringConcat: 'Niejawne czenie cigw jest niedozwolone',
        importCycleDetected: 'Wykryto cykl w acuchu importu',
        importDepthExceeded: 'Gboko acucha importu przekroczya {depth}',
        importResolveFailure: 'Nie mona rozpozna importu {importName}.',
        importSourceResolveFailure: 'Nie mona rozpozna importu {importName} ze rda',
        importSymbolUnknown: 'Nazwa {name} jest nieznanym symbolem importu',
        incompatibleMethodOverride: 'Metoda {name} przesania klas {className} w niezgodny sposb',
        inconsistentIndent: 'Warto zmniejszenia wcicia jest niezgodna z poprzednim wciciem',
        inconsistentTabs: 'Niespjne uycie tabulatorw i spacji we wciciach',
        initMethodSelfParamTypeVar: 'Adnotacja typu dla parametru self metody __init__ nie moe zawiera zmiennych typu o zakresie klasy',
        initMustReturnNone: 'Zwracany typ __init__ musi mie warto None',
        initSubclassCallFailed: 'Nieprawidowe argumenty sw kluczowych dla metody __init_subclass__',
        initSubclassClsParam: 'Przesonicie __init_subclass__ powinno przyjmowa parametr cls.',
        initVarNotAllowed: 'Element InitVar jest niedozwolony w tym kontekcie',
        instanceMethodSelfParam: 'Metody wystpienia powinny przyjmowa parametr self',
        instanceVarOverridesClassVar: 'Zmienna wystpienia {name} zastpuje zmienn klasy o tej samej nazwie w klasie {className}',
        instantiateAbstract: 'Nie mona utworzy wystpienia klasy abstrakcyjnej {type}',
        instantiateProtocol: 'Nie mona utworzy wystpienia klasy Protocol typu {type}',
        internalBindError: 'Wystpi bd wewntrzny podczas wizania pliku {file}: {message}',
        internalParseError: 'Wystpi bd wewntrzny podczas analizowania pliku {file}: {message}',
        internalTypeCheckingError: 'Wystpi bd wewntrzny podczas sprawdzania typu pliku {file}: {message}',
        invalidIdentifierChar: 'Nieprawidowy znak w identyfikatorze',
        invalidStubStatement: 'Instrukcja nie ma znaczenia w pliku stub typu',
        invalidTokenChars: 'Nieprawidowy znak {text} w tokenie',
        isInstanceInvalidType: 'Drugi argument instrukcji isinstance musi by klas lub tuple',
        isSubclassInvalidType: 'Drugi argument issubclass musi by klas lub tuple',
        keyValueInSet: 'Pary klucz/warto nie s dozwolone w set',
        keywordArgInTypeArgument: 'Argumentw sw kluczowych nie mona uywa na listach argumentw typu',
        keywordArgShortcutIllegal: 'Skrt do argumentu sowa kluczowego wymaga jzyka Python 3.14 lub nowszego',
        keywordOnlyAfterArgs: 'Separator argumentw tylko ze sowami kluczowymi jest niedozwolony po parametrze *',
        keywordParameterMissing: 'Co najmniej jeden parametr sowa kluczowego musi wystpowa po parametrze *',
        keywordSubscriptIllegal: 'Argumenty sw kluczowych w indeksach podrzdnych nie s obsugiwane',
        lambdaReturnTypePartiallyUnknown: 'Zwracany typ wyraenia lambda {returnType} jest czciowo nieznany',
        lambdaReturnTypeUnknown: 'Zwracany typ wyraenia lambda jest nieznany',
        listAssignmentMismatch: 'Wyraenia typu {type} nie mona przypisa do listy docelowej',
        listInAnnotation: 'Wyraenie List jest niedozwolone w wyraeniu typu',
        literalEmptyArgs: 'Oczekiwano co najmniej jednego argumentu typu po wartoci Literal',
        literalNamedUnicodeEscape: 'Nazwane sekwencje ucieczki Unicode nie s obsugiwane w adnotacjach cigw Literal',
        literalNotAllowed: 'Klasa Literal nie moe by uywana w tym kontekcie bez argumentu typu',
        literalNotCallable: 'Nie mona utworzy wystpienia typu Literal',
        literalUnsupportedType: 'Argumenty typu dla elementu Literal musz mie warto None, warto literau (int, bool, str lub bytes) lub warto enum',
        matchIncompatible: 'Instrukcje Match wymagaj jzyka Python w wersji 3.10 lub nowszej',
        matchIsNotExhaustive: 'Przypadki w instrukcji match nie obsuguj wyczerpujco wszystkich wartoci',
        maxParseDepthExceeded: 'Przekroczono maksymaln gboko analizy; podziel wyraenie na mniejsze wyraenia podrzdne',
        memberAccess: 'Nie mona uzyska dostpu do atrybutu {name} dla klasy {type}',
        memberDelete: 'Nie mona usun atrybutu {name} dla klasy {type}',
        memberSet: 'Nie mona przypisa atrybutu {name} dla klasy {type}',
        metaclassConflict: 'Metaklasa klasy pochodnej musi by podklas metaklas wszystkich jej klas bazowych',
        metaclassDuplicate: 'Mona poda tylko jedn metaklas',
        metaclassIsGeneric: 'Metaklasa nie moe by oglna',
        methodNotDefined: 'Nie zdefiniowano metody {name}.',
        methodNotDefinedOnType: 'Metoda {name} nie zostaa zdefiniowana dla typu {type}',
        methodOrdering: 'Nie mona utworzy spjnej kolejnoci metod',
        methodOverridden: '{name} przesania metod o tej samej nazwie w klasie {className} o niezgodnym typie {type}',
        methodReturnsNonObject: 'Metoda {name} nie zwraca obiektu',
        missingSuperCall: 'Metoda {methodName} nie wywouje metody o tej samej nazwie w klasie nadrzdnej',
        mixingBytesAndStr: 'Nie mona czy wartoci bytes i str',
        moduleAsType: 'Nie mona uy moduu jako typu',
        moduleNotCallable: 'Modu nie jest wywoywalny',
        moduleUnknownMember: '{memberName} nie jest znanym atrybutem moduu {moduleName}',
        namedExceptAfterCatchAll: 'Nazwana klauzula except nie moe wystpowa po klauzuli catch-all except',
        namedParamAfterParamSpecArgs: 'Parametr sowa kluczowego {name} nie moe wystpowa w sygnaturze po parametrze ParamSpec args',
        namedTupleEmptyName: 'Nazwy w ramach nazwanej kolekcji tuple nie mog by puste',
        namedTupleEntryRedeclared: 'Nie mona nadpisa nazwy {name}, poniewa klasa nadrzdna {className} jest nazwan kolekcj tuple',
        namedTupleFirstArg: 'Oczekiwano nazwanej nazwy klasy tuple jako pierwszego argumentu',
        namedTupleMultipleInheritance: 'Wielokrotne dziedziczenie z kotki NamedTuple nie jest obsugiwane',
        namedTupleNameKeyword: 'Nazwy pl nie mog by sowem kluczowym',
        namedTupleNameType: 'Oczekiwano tuple z dwoma wpisami okrelajcej nazw i typ wpisu',
        namedTupleNameUnique: 'Nazwy w nazwanej tuple musz by unikatowe',
        namedTupleNoTypes: 'Krotka namedtuple nie zapewnia typw wpisw krotki; zamiast tego uyj NamedTuple.',
        namedTupleSecondArg: 'Oczekiwano nazwanej listy wpisw kolekcji tuple jako drugiego argumentu',
        newClsParam: 'Przesonicie __new__ powinno przyjmowa parametr cls.',
        newTypeAnyOrUnknown: 'Drugi argument parametru NewType musi by znan klas, a nie wartoci Any lub Unknown',
        newTypeBadName: 'Pierwszy argument elementu NewType musi by literaem cigu',
        newTypeLiteral: 'Typ NewType nie moe by uywany z typem Literal',
        newTypeNameMismatch: 'Element NewType musi by przypisany do zmiennej o tej samej nazwie',
        newTypeNotAClass: 'Oczekiwano klasy jako drugiego argumentu dla elementu NewType',
        newTypeParamCount: 'Typ NewType wymaga dwch argumentw pozycyjnych',
        newTypeProtocolClass: 'Elementu NewType nie mona uywa z typem strukturalnym (klasy Protocol lub TypedDict)',
        noOverload: 'adne przecienia dla nazwy {name} nie pasuj do podanych argumentw',
        noReturnContainsReturn: 'Funkcja z zadeklarowanym return typem NoReturn nie moe zawiera instrukcji return',
        noReturnContainsYield: 'Funkcja z zadeklarowanym zwracanym typem NoReturn nie moe zawiera instrukcji yield',
        noReturnReturnsNone: 'Funkcja z zadeklarowanym typem zwracanym NoReturn nie moe zwraca wartoci None',
        nonDefaultAfterDefault: 'Argument inny ni domylny nastpuje po argumencie domylnym',
        nonLocalInModule: 'Deklaracja nonlocal nie jest dozwolona na poziomie moduu',
        nonLocalNoBinding: 'Nie znaleziono powizania dla nonlocal {name}.',
        nonLocalReassignment: 'Nazwa {name} jest przypisywana przed deklaracj nonlocal',
        nonLocalRedefinition: 'Nazwa {name} zostaa ju zadeklarowana jako nonlocal',
        noneNotCallable: 'Nie mona wywoa obiektu typu None',
        noneNotIterable: 'Obiekt typu None nie moe by uywany jako warto iterowalna',
        noneNotSubscriptable: 'Obiekt typu None nie moe by uyty w indeksie dolnym',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Operator {operator} nie jest obsugiwany dla wartoci None',
        noneUnknownMember: 'Nazwa {name} nie jest znanym atrybutem None',
        notRequiredArgCount: 'Oczekiwano jednego argumentu typu po wartoci NotRequired',
        notRequiredNotInTypedDict: 'Element NotRequired jest niedozwolony w tym kontekcie',
        objectNotCallable: 'Obiekt typu {type} nie jest wywoywalny',
        obscuredClassDeclaration: 'Deklaracja klasy {name} jest zasonita przez deklaracj o tej samej nazwie',
        obscuredFunctionDeclaration: 'Deklaracja funkcji {name} jest zasonita przez deklaracj o tej samej nazwie',
        obscuredMethodDeclaration: 'Deklaracja metody {name} jest zasonita przez deklaracj o tej samej nazwie',
        obscuredParameterDeclaration: 'Deklaracja parametru {name} jest zasonita przez deklaracj o tej samej nazwie',
        obscuredTypeAliasDeclaration: 'Deklaracja aliasu typu {name} jest zasonita przez deklaracj o tej samej nazwie',
        obscuredVariableDeclaration: 'Deklaracja {name} jest zasonita przez deklaracj o tej samej nazwie',
        operatorLessOrGreaterDeprecated: 'Operator <> nie jest obsugiwany w jzyku Python w wersji 3; zamiast tego uyj !=.',
        optionalExtraArgs: 'Oczekiwano jednego argumentu typu po parametrze Optional',
        orPatternIrrefutable: 'Niepodwaalny wzorzec jest dozwolony tylko jako ostatni podwzorzec we wzorcu or',
        orPatternMissingName: 'Wszystkie wzorce podrzdne we wzorcu or musz dotyczy tych samych nazw',
        overlappingKeywordArgs: 'Wpisany sownik nakada si na parametr sowa kluczowego: {names}',
        overlappingOverload: 'Przecienie {obscured} dla nazwy {name} nigdy nie zostanie uyte, poniewa jego parametry nakadaj si na przecienie {obscuredBy}',
        overloadAbstractImplMismatch: 'Przecienia musz by zgodne ze stanem abstrakcyjnym implementacji',
        overloadAbstractMismatch: 'Przecienia musz by abstrakcyjne lub nieabstrakcyjne',
        overloadClassMethodInconsistent: 'Przecienia dla nazwy {name} uywaj metody @classmethod niekonsekwentnie',
        overloadFinalInconsistencyImpl: 'Przecienie elementu {name} jest oznaczone @final, ale implementacja nie jest',
        overloadFinalInconsistencyNoImpl: 'Przecienie {index} dla elementu {name} jest oznaczone @final, ale przecienie 1 nie jest',
        overloadImplementationMismatch: 'Przecione wdroenie jest niespjne z sygnatur przecienia {index}',
        overloadReturnTypeMismatch: 'Przecienie {prevIndex} dla nazwy {name} nakada si na przecienie {newIndex} i zwraca niezgodny typ',
        overloadStaticMethodInconsistent: 'Przecienia dla nazwy {name} uywaj metody @staticmethod niekonsekwentnie',
        overloadWithoutImplementation: 'Nazwa {name} jest oznaczona jako overload, ale nie zapewniono implementacji',
        overriddenMethodNotFound: 'Metoda {name} jest oznaczona jako override, ale nie istnieje metoda bazowa o tej samej nazwie',
        overrideDecoratorMissing: 'Metoda {name} nie jest oznaczona jako override, ale zastpuje metod w klasie {className}',
        paramAfterKwargsParam: 'Parametr nie moe nastpowa po parametrze **',
        paramAlreadyAssigned: 'Parametr {name} jest ju przypisany',
        paramAnnotationMissing: 'Brak adnotacji typu dla parametru {name}',
        paramAssignmentMismatch: 'Wyraenia typu {sourceType} nie mona przypisa do parametru typu {paramType}',
        paramNameMissing: 'Brak parametru o nazwie {name}',
        paramSpecArgsKwargsDuplicate: 'Argumenty parametru ParamSpec {type} zostay ju podane',
        paramSpecArgsKwargsUsage: 'Atrybuty args i kwargs specyfikacji ParamSpec musz znajdowa si w sygnaturze funkcji',
        paramSpecArgsMissing: 'Brak argumentw dla parametru ParamSpec {type}.',
        paramSpecArgsUsage: 'Atrybut args parametru ParamSpec jest wana tylko wtedy, gdy jest uywana z parametrem *args',
        paramSpecAssignedName: 'Parametr ParamSpec musi by przypisany do zmiennej o nazwie {name}',
        paramSpecContext: 'Warto ParamSpec jest niedozwolona w tym kontekcie',
        paramSpecDefaultNotTuple: 'Oczekiwano wielokropka, wyraenia kolekcji tuple lub parametru ParamSpec dla wartoci domylnej ParamSpec',
        paramSpecFirstArg: 'Oczekiwano nazwy parametru ParamSpec jako pierwszego argumentu',
        paramSpecKwargsUsage: 'Atrybut kwargs parametru ParamSpec jest wana tylko wtedy, gdy jest uywana z parametrem **kwargs',
        paramSpecNotUsedByOuterScope: 'Element ParamSpec {name} nie ma znaczenia w tym kontekcie',
        paramSpecUnknownArg: 'Parametr ParamSpec nie obsuguje wicej ni jednego argumentu',
        paramSpecUnknownMember: '{name} nie jest znanym atrybutem parametru ParamSpec',
        paramSpecUnknownParam: '{name} jest nieznanym parametrem dla parametru ParamSpec',
        paramTypeCovariant: 'Zmienna typu kowariantnego nie moe by uywana w typie parametru',
        paramTypePartiallyUnknown: 'Typ parametru {paramName} jest czciowo nieznany',
        paramTypeUnknown: 'Typ parametru {paramName} jest nieznany',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Wzorzec nigdy nie zostanie dopasowany do typu podmiotu {type}',
        positionArgAfterNamedArg: 'Argument pozycyjny nie moe wystpowa po argumentach sw kluczowych',
        positionOnlyAfterArgs: 'Separator parametru tylko do pozycjonowania jest niedozwolony po parametrze *',
        positionOnlyAfterKeywordOnly: 'Parametr / musi wystpowa przed parametrem *.',
        positionOnlyAfterNon: 'Parametr tylko do pozycjonowania jest niedozwolony po parametrze, ktry nie jest tylko do pozycjonowania',
        positionOnlyFirstParam: 'Separator parametrw tylko do pozycjonowania nie jest dozwolony jako pierwszy parametr',
        positionOnlyIncompatible: 'Separator parametrw tylko do pozycjonowania wymaga jzyka Python 3.8 lub nowszego',
        privateImportFromPyTypedModule: 'Nazwa {name} nie jest eksportowana z moduu {module}',
        privateUsedOutsideOfClass: 'Nazwa {name} jest prywatna i uywana poza klas, w ktrej zostaa zadeklarowana',
        privateUsedOutsideOfModule: 'Nazwa {name} jest prywatna i uywana poza moduem, w ktrym zostaa zadeklarowana',
        propertyOverridden: 'Nazwa {name} nieprawidowo zastpuje property o tej samej nazwie w klasie {className}',
        propertyStaticMethod: 'Metody statyczne nie s dozwolone w przypadku getter, setter lub deleter property',
        protectedUsedOutsideOfClass: 'Nazwa {name} jest chroniona i uywana poza klas, w ktrej zostaa zadeklarowana',
        protocolBaseClass: 'Klasa Protocol typu {classType} nie moe pochodzi od klasy niebdcej klas Protocol typu {baseType}',
        protocolBaseClassWithTypeArgs: 'Argumenty typu s niedozwolone z klas Protocol, gdy jest uywana skadnia parametru typu',
        protocolIllegal: 'Uycie elementu Protocol wymaga jzyka Python w wersji 3.7 lub nowszej',
        protocolNotAllowed: 'Klasa Protocol nie moe by uywana w tym kontekcie',
        protocolTypeArgMustBeTypeParam: 'Argument typu dla elementy Protocol musi by parametrem typu',
        protocolUnsafeOverlap: 'Klasa nakada si niebezpiecznie na element {name} i moe utworzy dopasowanie w czasie wykonywania',
        protocolVarianceContravariant: 'Zmienna typu {variable} uywana w klasie oglnej Protocol {class} powinna by kontrawariantna',
        protocolVarianceCovariant: 'Zmienna typu {variable} uywana w klasie oglnej Protocol {class} powinna by kowariantna',
        protocolVarianceInvariant: 'Zmienna typu {variable} uywana w klasie oglnego Protocol {class} powinna by niezmienna',
        pyrightCommentInvalidDiagnosticBoolValue: 'Po dyrektywie komentarza Pyright musi nastpowa znak = oraz warto true lub false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Po dyrektywie komentarza Pyright musi nastpowa znak = oraz warto true, false, error, warning, information lub none',
        pyrightCommentMissingDirective: 'Po komentarzu Pyright musi nastpowa dyrektywa (basic lub strict) lub regua diagnostyczna',
        pyrightCommentNotOnOwnLine: 'Komentarze Pyright uywane do kontrolowania ustawie na poziomie plikw musz pojawia si w oddzielnych wierszach',
        pyrightCommentUnknownDiagnosticRule: 'Regua {rule} jest nieznan regu diagnostyczn dla komentarza pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: 'Warto {value} jest nieprawidowa dla komentarza pyright; oczekiwano wartoci: true, false, error, warning, information lub none',
        pyrightCommentUnknownDirective: 'Warto {directive} jest nieznan dyrektyw dla komentarza pyright; oczekiwano wartoci strict lub basic',
        readOnlyArgCount: 'Oczekiwano jednego argumentu typu po wartoci ReadOnly',
        readOnlyNotInTypedDict: 'Element ReadOnly jest niedozwolony w tym kontekcie',
        recursiveDefinition: 'Nie mona okreli typu {name}, poniewa odwouje si on do samego siebie',
        relativeImportNotAllowed: 'Importy wzgldne nie mog by uywane z formularzem import .a; zamiast tego uyj from . import a.',
        requiredArgCount: 'Oczekiwano jednego argumentu typu po wartoci Required',
        requiredNotInTypedDict: 'Element Required jest niedozwolony w tym kontekcie',
        returnInAsyncGenerator: 'Instrukcja return z wartoci jest niedozwolona w generatorze asynchronicznym',
        returnInExceptionGroup: 'return nie jest dozwolone w bloku except*',
        returnMissing: 'Funkcja z zadeklarowanym typem zwracanym {returnType} musi zwraca warto we wszystkich ciekach kodu',
        returnOutsideFunction: 'Instrukcja return moe by uywana tylko w ramach funkcji',
        returnTypeContravariant: 'Kontrawariantna zmienna typu nie moe by uywana w zwracanym typie',
        returnTypeMismatch: 'Nie mona przypisa typu {exprType} do zwracanego typu {returnType}',
        returnTypePartiallyUnknown: 'Zwracany typ {returnType} jest czciowo nieznany',
        returnTypeUnknown: 'Zwracany typ jest nieznany',
        revealLocalsArgs: 'Oczekiwano braku argumentw dla wywoania reveal_locals',
        revealLocalsNone: 'Brak locals w tym zakresie',
        revealTypeArgs: 'Oczekiwano pojedynczego argumentu pozycyjnego dla wywoania reveal_type',
        revealTypeExpectedTextArg: 'Argument expected_text dla funkcji reveal_type musi by wartoci literau str',
        revealTypeExpectedTextMismatch: 'Wpisz niezgodno tekstu; oczekiwano {expected}, ale otrzymano {received}',
        revealTypeExpectedTypeMismatch: 'Niezgodno typu; oczekiwano wartoci {expected}, a uzyskano {received}',
        selfTypeContext: 'Warto Self jest nieprawidowa w tym kontekcie',
        selfTypeMetaclass: 'Nie mona uy elementu Self w ramach metaklasy (podklasy elementu type)',
        selfTypeWithTypedSelfOrCls: 'Nie mona uy wartoci Self w funkcji z parametrem self lub cls, ktra ma adnotacj typu inn ni Self',
        setterGetterTypeMismatch: 'Typu wartoci setter property nie mona przypisa do zwracanego typu getter',
        singleOverload: 'Nazwa {name} jest oznaczona jako przeciona, ale brakuje dodatkowych przecie',
        slotsAttributeError: 'Nie okrelono atrybutu {name} w elemencie __slots__',
        slotsClassVarConflict: '{name} powoduje konflikt ze zmienn wystpienia zadeklarowan w elemencie __slots__',
        starPatternInAsPattern: 'Wzr gwiazdy nie moe by uyty z miejscem docelowym parametru as.',
        starPatternInOrPattern: 'Wzr gwiazdy nie moe mie wartoci ORed w ramach innych wzorw',
        starStarWildcardNotAllowed: 'Symbolu ** nie mona uywa z symbolem wieloznacznym _',
        staticClsSelfParam: 'Metody statyczne nie powinny przyjmowa parametru self ani cls.',
        stdlibModuleOverridden: 'cieka {path} zastpuje modu stdlib {name}',
        stringNonAsciiBytes: 'Znak inny ni ASCII jest niedozwolony w literale cigu bajtw',
        stringNotSubscriptable: 'Wyraenie cigu nie moe by indeksowane w wyraeniu typu; ujmij cae wyraenie w cudzysowy',
        stringUnsupportedEscape: 'Nieobsugiwana sekwencja ucieczki w literale cigu',
        stringUnterminated: 'Litera cigu jest niezakoczony',
        stubFileMissing: 'Nie znaleziono pliku stub dla nazwy {importName}',
        stubUsesGetAttr: 'Plik stub typu jest niekompletny; element __getattr__ przesania bdy w przypadku moduu',
        sublistParamsIncompatible: 'Parametry sublisty nie s obsugiwane w wersji jzyka Python 3.x',
        superCallArgCount: 'Oczekiwano nie wicej ni dwch argumentw wywoania super',
        superCallFirstArg: 'Oczekiwano typu klasy jako pierwszego argumentu wywoania super, ale otrzymano {type}',
        superCallSecondArg: 'Drugi argument wywoania super musi by obiektem lub klas wywodzc si z typu {type}',
        superCallZeroArgForm: 'Forma bez argumentw wywoania super jest prawidowa tylko w ramach metody',
        superCallZeroArgFormStaticMethod: 'Forma z zerowym argumentem wywoania super jest nieprawidowa w metodzie statycznej',
        symbolIsPossiblyUnbound: 'Nazwa {name} jest prawdopodobnie niepowizana',
        symbolIsUnbound: 'Nazwa {name} jest niepowizana',
        symbolIsUndefined: 'Nazwa {name} nie jest zdefiniowana',
        symbolOverridden: 'Nazwa {name} przesania symbol o tej samej nazwie w klasie {className}',
        ternaryNotAllowed: 'Wyraenie trjskadnikowe nie jest dozwolone w wyraeniu typu',
        totalOrderingMissingMethod: 'Klasa musi definiowa jedn z nastpujcych wartoci: __lt__, __le__, __gt__ lub __ge__, aby uy parametru total_ordering',
        trailingCommaInFromImport: 'Kocowy przecinek nie jest dozwolony bez otaczajcych nawiasw',
        tryWithoutExcept: 'Instrukcja Try musi mie co najmniej jedn klauzul except lub finally',
        tupleAssignmentMismatch: 'Nie mona przypisywa wyraenia w ramach typu {type} do docelowej kolekcji tuple',
        tupleInAnnotation: 'Wyraenie kolekcji tuple jest niedozwolone w wyraeniu typu',
        tupleIndexOutOfRange: 'Indeks {index} jest poza zakresem dla typu {type}',
        typeAliasIllegalExpressionForm: 'Nieprawidowy formularz wyraenia dla definicji aliasu typu',
        typeAliasIsRecursiveDirect: 'Alias typu {name} nie moe uywa samego siebie w swojej definicji',
        typeAliasNotInModuleOrClass: 'Typ TypeAlias mona zdefiniowa tylko w zakresie moduu lub klasy',
        typeAliasRedeclared: 'Nazwa {name} jest zadeklarowana jako TypeAlias i moe by przypisana tylko raz',
        typeAliasStatementBadScope: 'Instrukcja type moe by uyta tylko w zakresie moduu lub klasy',
        typeAliasStatementIllegal: 'Instrukcja typu alias wymaga jzyka Python w wersji 3.12 lub nowszej',
        typeAliasTypeBaseClass: 'A type alias defined in a "type" statement cannot be used as a base class',
        typeAliasTypeMustBeAssigned: 'Typ TypeAliasType musi by przypisany do zmiennej o takiej samej nazwie jak alias typu',
        typeAliasTypeNameArg: 'Pierwszy argument dla typu TypeAliasType musi by literaem cigu reprezentujcym nazw aliasu typu',
        typeAliasTypeNameMismatch: 'Nazwa aliasu typu musi by zgodna z nazw zmiennej, do ktrej jest przypisana',
        typeAliasTypeParamInvalid: 'Lista parametrw typu musi by kolekcj tuple zawierajc tylko parametry TypeVar, TypeVarTuple lub ParamSpec',
        typeAnnotationCall: 'Wyraenie wywoania jest niedozwolone w wyraeniu typu',
        typeAnnotationVariable: 'Zmienna niedozwolona w wyraeniu typu',
        typeAnnotationWithCallable: 'Argument typu type musi by klas; elementy wywoywane nie s obsugiwane',
        typeArgListExpected: 'Oczekiwano parametru ParamSpec, wielokropka lub listy typw',
        typeArgListNotAllowed: 'Wyraenie listy jest niedozwolone dla tego argumentu typu',
        typeArgsExpectingNone: 'Oczekiwano braku argumentw typu dla klasy {name}',
        typeArgsMismatchOne: 'Oczekiwano jednego argumentu typu, ale otrzymano {received}',
        typeArgsMissingForAlias: 'Oczekiwano argumentw typu dla aliasu typu oglnego {name}',
        typeArgsMissingForClass: 'Oczekiwano argumentw typu dla oglnej klasy {name}',
        typeArgsTooFew: 'Podano zbyt mao argumentw typu dla {name}; oczekiwano wartoci {expected}, ale otrzymano {received}',
        typeArgsTooMany: 'Podano zbyt wiele argumentw typu dla nazwy {name}; oczekiwano {expected}, a uzyskano {received}',
        typeAssignmentMismatch: 'Nie mona przypisa typu {sourceType} do zadeklarowanego typu {destType}',
        typeAssignmentMismatchWildcard: 'Symbol importu {name} ma typ {sourceType}, ktrego nie mona przypisa do zadeklarowanego typu {destType}',
        typeCallNotAllowed: 'wywoanie type() nie powinno by uywane w wyraeniu typu',
        typeCheckOnly: 'Nazwa {name} jest oznaczona jako @type_check_only i moe by uywana tylko w adnotacjach typu',
        typeCommentDeprecated: 'Use of type comments is deprecated; use type annotation instead',
        typeExpectedClass: 'Oczekiwano klasy, ale odebrano typ {type}',
        typeFormArgs: 'TypeForm akceptuje pojedynczy argument pozycyjny',
        typeGuardArgCount: 'Oczekiwano pojedynczego argumentu typu po parametrze TypeGuard lub TypeIs',
        typeGuardParamCount: 'Funkcje i metody zabezpieczajce typu zdefiniowane przez uytkownika musz mie co najmniej jeden parametr wejciowy',
        typeIsReturnType: 'Zwracany typ TypeIs ({returnType}) jest niezgodny z typem parametru wartoci ({type})',
        typeNotAwaitable: '"{type}" is not awaitable',
        typeNotIntantiable: 'Nie mona utworzy wystpienia {type}',
        typeNotIterable: 'Typ {type} nie jest iterowalny',
        typeNotSpecializable: 'Nie mona specjalizowa typu {type}',
        typeNotSubscriptable: 'Obiekt typu {type} nie moe by uyty w indeksie dolnym',
        typeNotSupportBinaryOperator: 'Operator {operator} nieobsugiwany dla typw {leftType} i {rightType}',
        typeNotSupportBinaryOperatorBidirectional: 'Operator {operator} nie jest obsugiwany dla typw {leftType} i {rightType}, gdy oczekiwanym typem jest {expectedType}',
        typeNotSupportUnaryOperator: 'Operator {operator} nie jest obsugiwany dla typu {type}',
        typeNotSupportUnaryOperatorBidirectional: 'Operator {operator} nie jest obsugiwany dla typu {type}, gdy oczekiwanym typem jest {expectedType}',
        typeNotUsableWith: 'Obiekt typu {type} nie moe by uywany z parametrem with, poniewa nie wdraa metody {method}',
        typeParameterBoundNotAllowed: 'Powizanie lub ograniczenie nie moe by uywane z parametrem typu ze zmienn liczb argumentw lub parametrem ParamSpec',
        typeParameterConstraintTuple: 'Ograniczenie parametru typu musi by krotk dwch lub wicej typw',
        typeParameterExistingTypeParameter: 'Parametr typu {name} jest ju uywany',
        typeParameterNotDeclared: 'Parametr typu {name} nie znajduje si na licie parametrw typu dla {container}',
        typeParametersMissing: 'Naley okreli co najmniej jeden parametr typu',
        typePartiallyUnknown: 'Typ {name} jest czciowo nieznany',
        typeUnknown: 'Typ {name} jest nieznany',
        typeVarAssignedName: 'Typ TypeVar musi by przypisany do zmiennej o nazwie {name}',
        typeVarAssignmentMismatch: 'Nie mona przypisa typu {type} do zmiennej typu {name}',
        typeVarBoundAndConstrained: 'Typ TypeVar nie moe by jednoczenie powizany i ograniczony',
        typeVarBoundGeneric: 'Typ powizany TypeVar nie moe by oglny',
        typeVarConstraintGeneric: 'Typ ograniczenia TypeVar nie moe by oglny',
        typeVarDefaultBoundMismatch: 'Domylny typ TypeVar musi by podtypem powizanego typu',
        typeVarDefaultConstraintMismatch: 'Typ domylny TypeVar musi by jednym z typw z ograniczeniami',
        typeVarDefaultIllegal: 'Typy domylne zmiennych typw wymagaj wersji jzyka Python 3.13 lub nowszej',
        typeVarDefaultInvalidTypeVar: 'Parametr typu {name} ma typ domylny, ktry odnosi si do co najmniej jednej zmiennej typu, ktra jest poza zakresem',
        typeVarFirstArg: 'Oczekiwano nazwy TypeVar jako pierwszego argumentu',
        typeVarInvalidForMemberVariable: 'Typ atrybutu nie moe uywa zmiennej typu {name} w zakresie metody lokalnej',
        typeVarNoMember: 'Typ atrybutu TypeVar {type} nie ma atrybutu {name}',
        typeVarNotSubscriptable: 'Typ TypeVar {type} nie moe by subskrybowany',
        typeVarNotUsedByOuterScope: 'Zmienna typu {name} nie ma w tym kontekcie adnego znaczenia',
        typeVarPossiblyUnsolvable: 'Zmienna typu {name} moe zosta nierozwizana, jeli obiekt wywoujcy nie poda argumentu dla parametru {param}',
        typeVarSingleConstraint: 'Typ TypeVar musi mie co najmniej dwa typy ograniczone',
        typeVarTupleConstraints: 'Element TypeVarTuple nie moe mie ogranicze wartoci',
        typeVarTupleContext: 'Warto TypeVarTuple jest niedozwolona w tym kontekcie',
        typeVarTupleDefaultNotUnpacked: 'Typ domylny TypeVarTuple musi by nierozpakowan kolekcj tuple lub parametrem TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'Operator rozpakowywania jest wymagany dla wartoci parametru TypeVarTuple',
        typeVarTupleUnknownParam: 'Nazwa {name} jest nieznanym parametrem typu TypeVarTuple',
        typeVarUnknownParam: '{name} jest nieznanym parametrem dla argumentu TypeVar',
        typeVarUsedByOuterScope: 'Argument TypeVar {name} jest ju uywany przez zakres zewntrzny',
        typeVarUsedOnlyOnce: 'Typ TypeVar {name} pojawia si tylko raz w sygnaturze funkcji oglnej',
        typeVarVariance: 'Zmienna typu TypeVar nie moe by jednoczenie kowariantna i kontrawariantna',
        typeVarWithDefaultFollowsVariadic: 'Warto TypeVar {typeVarName} ma warto domyln i nie moe nastpowa po wartoci TypeVarTuple {variadicName}.',
        typeVarWithoutDefault: 'Element {name} nie moe wystpowa po elemencie {other} na licie parametrw typu, poniewa nie ma typu domylnego',
        typeVarsNotInGenericOrProtocol: 'Elementy Generic[] lub Protocol[] musz zawiera wszystkie zmienne typu',
        typedDictAccess: 'Nie mona uzyska dostpu do elementu w TypedDict',
        typedDictAssignedName: 'Element TypedDict musi by przypisany do zmiennej o nazwie {name}',
        typedDictBadVar: 'Klasy TypedDict mog zawiera tylko adnotacje typu',
        typedDictBaseClass: 'Wszystkie klasy bazowe dla klas TypedDict musz by rwnie klasami TypedDict',
        typedDictBoolParam: 'Oczekiwano, e parametr {name} bdzie mia warto True lub False',
        typedDictClosedExtras: 'Klasa bazowa {name} jest closed TypedDict; dodatkowe elementy musz by typu {type}',
        typedDictClosedNoExtras: 'Klasa bazowa {name} jest closed TypedDict; dodatkowe elementy s niedozwolone',
        typedDictDelete: 'Nie mona usun elementu w typie TypedDict',
        typedDictEmptyName: 'Nazwy w elemencie TypedDict nie mog by puste',
        typedDictEntryName: 'Oczekiwano literau cigu dla nazwy wpisu sownika',
        typedDictEntryUnique: 'Nazwy w sowniku musz by unikatowe',
        typedDictExtraArgs: 'Dodatkowe argumenty TypedDict nie s obsugiwane',
        typedDictExtraItemsClosed: 'Element TypedDict nie moe by closed, jeli obsuguje dodatkowe elementy',
        typedDictFieldNotRequiredRedefinition: 'Element TypedDict {name} nie moe zosta przedefiniowany jako NotRequired',
        typedDictFieldReadOnlyRedefinition: 'Element TypedDict {name} nie moe by przedefiniowany jako ReadOnly.',
        typedDictFieldRequiredRedefinition: 'Element TypedDict {name} nie moe zosta przedefiniowany jako Required',
        typedDictFirstArg: 'Oczekiwano nazwy klasy TypedDict jako pierwszego argumentu',
        typedDictInClassPattern: 'klasa TypedDict nie jest dozwolona we wzorcu klasy',
        typedDictInitsubclassParameter: 'Element TypedDict nie obsuguje parametru __init_subclass__ {name}',
        typedDictNotAllowed: 'Nie mona uy elementu TypedDict w tym kontekcie',
        typedDictSecondArgDict: 'Oczekiwano parametru dict lub sowa kluczowego jako drugiego parametru',
        typedDictSecondArgDictEntry: 'Oczekiwano prostego wpisu sownika',
        typedDictSet: 'Nie mona przypisa elementu w TypedDict',
        unaccessedClass: 'Nie uzyskano dostpu do klasy {name}',
        unaccessedFunction: 'Brak dostpu do funkcji {name}.',
        unaccessedImport: 'Import {name} nie jest dostpny',
        unaccessedSymbol: 'Brak dostpu do {name}.',
        unaccessedVariable: 'Brak dostpu do zmiennej {name}.',
        unannotatedFunctionSkipped: 'Analiza funkcji {name} zostaa pominita, poniewa nie ma adnotacji',
        unaryOperationNotAllowed: 'Operator jednoargumentowy nie jest dozwolony w wyraeniu typu',
        unexpectedAsyncToken: 'Oczekiwano wartoci def, with lub for po async',
        unexpectedExprToken: 'Nieoczekiwany token na kocu wyraenia',
        unexpectedIndent: 'Nieoczekiwane wcicie',
        unexpectedUnindent: 'Nieoczekiwany brak wcicia',
        unhashableDictKey: 'Klucz sownika musi by wartoci skrtu',
        unhashableSetEntry: 'Set wpis musi by wartoci skrtu',
        uninitializedAbstractVariables: 'Zmienne zdefiniowane w abstrakcyjnej klasie bazowej nie s inicjowane w klasie final {classType}',
        uninitializedInstanceVariable: 'Zmienna wystpienia {name} nie zostaa zainicjowana w treci klasy ani w metodzie __init__',
        unionForwardReferenceNotAllowed: 'Skadnia elementu Union nie moe by uywana z operandem cigu; uyj cudzysoww wok caego wyraenia',
        unionSyntaxIllegal: 'Alternatywna skadnia unii wymaga jzyka Python w wersji 3.10 lub nowszej',
        unionTypeArgCount: 'Element Union wymaga co najmniej dwch argumentw typu',
        unionUnpackedTuple: 'Typ Union nie moe zawiera niespakowanej kolekcji tuple',
        unionUnpackedTypeVarTuple: 'Typ Union nie moe zawiera niespakowanego parametru TypeVarTuple',
        unnecessaryCast: 'Niepotrzebne wywoanie cast; typ jest ju {type}',
        unnecessaryIsInstanceAlways: 'Niepotrzebne wywoanie elementu isinstance; {testType} jest zawsze wystpieniem {classType}',
        unnecessaryIsInstanceNever: 'Niepotrzebne wywoanie funkcji isinstance; {testType} nigdy nie jest instancj {classType}',
        unnecessaryIsSubclassAlways: 'Niepotrzebne wywoanie issubclass; {testType} jest zawsze podklas klasy {classType}',
        unnecessaryIsSubclassNever: 'Niepotrzebne wywoanie funkcji issubclass; {testType} nigdy nie jest podklas {classType}',
        unnecessaryPyrightIgnore: 'Niepotrzebny komentarz # pyright: ignore',
        unnecessaryPyrightIgnoreRule: 'Niepotrzebna regua # pyright: ignore: {name}',
        unnecessaryTypeIgnore: 'Niepotrzebny komentarz # type: ignore',
        unpackArgCount: 'Oczekiwano jednego argumentu typu po wartoci Unpack',
        unpackExpectedTypeVarTuple: 'Oczekiwano typu TypeVarTuple lub tuple jako argumentu typu dla elementu Unpack',
        unpackExpectedTypedDict: 'Oczekiwano argumentu typu TypedDict dla elementu Unpack',
        unpackIllegalInComprehension: 'Operacja rozpakowywania nie jest dozwolona w rozumieniu',
        unpackInAnnotation: 'Operator rozpakowywania nie jest dozwolony w wyraeniu typu',
        unpackInDict: 'Operacja rozpakowywania nie jest dozwolona w sownikach',
        unpackInSet: 'Rozpakowywanie operatora jest niedozwolone w set',
        unpackNotAllowed: 'Element Unpack jest niedozwolony w tym kontekcie',
        unpackOperatorNotAllowed: 'Operacja rozpakowywania jest niedozwolona w tym kontekcie',
        unpackTuplesIllegal: 'Operacja rozpakowywania nie jest dozwolona w krotkach przed jzykiem Python w wersji 3.8',
        unpackedArgInTypeArgument: 'Nie mona uy nierozpakowanych argumentw w tym kontekcie',
        unpackedArgWithVariadicParam: 'Nie mona uy nierozpakowanego argumentu dla parametru TypeVarTuple',
        unpackedDictArgumentNotMapping: 'Wyraenie argumentu po znakach ** musi by mapowaniem z typem klucza str',
        unpackedDictSubscriptIllegal: 'Operator rozpakowywania sownika w indeksie dolnym jest niedozwolony',
        unpackedSubscriptIllegal: 'Operator rozpakowywania w indeksie dolnym wymaga jzyka Python w wersji 3.11 lub nowszej',
        unpackedTypeVarTupleExpected: 'Oczekiwano nierozpakowanego typu TypeVarTuple; uyj Unpack[{name1}] lub *{name2}',
        unpackedTypedDictArgument: 'Nie mona dopasowa nierozpakowanego argumentu TypedDict do parametrw',
        unreachableCode: 'Kod jest nieosigalny',
        unreachableCodeType: 'Analiza typw wskazuje, e kod jest nieosigalny',
        unreachableExcept: 'Klauzula Except jest nieosigalna, poniewa wyjtek jest ju obsugiwany',
        unsupportedDunderAllOperation: 'Operacja na elemencie __all__ nie jest obsugiwana, wic wyeksportowana lista symboli moe by nieprawidowa',
        unusedCallResult: 'Wynik wyraenia wywoania jest typu {type} i nie jest uywany; przypisz do zmiennej _, jeli jest to zamierzone',
        unusedCoroutine: 'Wynik wywoania funkcji asynchronicznej nie jest uywany; uyj wartoci await lub przypisz wynik do zmiennej',
        unusedExpression: 'Warto wyraenia jest nieuywana',
        varAnnotationIllegal: 'Type annotations for variables requires Python 3.6 or newer; use type comment for compatibility with previous versions',
        variableFinalOverride: 'Zmienna {name} jest oznaczona jako Final i zastpuje zmienn inn non-Final o tej samej nazwie w klasie {className}',
        variadicTypeArgsTooMany: 'Lista argumentw typu moe zawiera co najwyej jeden nierozpakowany typ TypeVarTuple lub tuple',
        variadicTypeParamTooManyAlias: 'Alias typu moe mie co najwyej jeden parametr typu TypeVarTuple, ale otrzyma wiele ({names})',
        variadicTypeParamTooManyClass: 'Klasa oglna moe mie co najwyej jeden parametr typu TypeVarTuple, ale otrzyma wiele ({names})',
        walrusIllegal: 'Operator := wymaga jzyka Python w wersji 3.8 lub nowszej',
        walrusNotAllowed: 'Operator := jest niedozwolony w tym kontekcie bez otaczajcych nawiasw',
        wildcardInFunction: 'Wildcard import not allowed within a class or function',
        wildcardLibraryImport: 'Wildcard import from a library not allowed',
        wildcardPatternTypePartiallyUnknown: 'Typ przechwycony przez wzorzec symboli wieloznacznych jest czciowo nieznany',
        wildcardPatternTypeUnknown: 'Typ przechwycony przez wzorzec symboli wieloznacznych jest nieznany',
        yieldFromIllegal: 'Uycie wartoci yield from wymaga jzyka Python w wersji 3.3 lub nowszej',
        yieldFromOutsideAsync: 'Instrukcja yield from jest niedozwolona w funkcji asynchronicznej',
        yieldOutsideFunction: 'Instrukcja yield jest niedozwolona poza funkcj lub wyraeniem lambda',
        yieldWithinComprehension: 'Instrukcja yield nie jest dozwolona w rozumieniu',
        zeroCaseStatementsFound: 'Match statement must include at least one case statement',
        zeroLengthTupleNotAllowed: 'Zero-length tuple is not allowed in this context'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Formularza specjalnego Annotated nie mona uywa z kontrolami wystpie i klas',
        argParam: 'Argument odpowiada parametrowi {paramName}',
        argParamFunction: 'Argument odpowiada parametrowi {paramName} w funkcji {functionName}',
        argsParamMissing: 'Parametr *{paramName} nie ma odpowiadajcego mu parametru',
        argsPositionOnly: 'Niezgodno parametrw tylko dla pozycji; oczekiwano wartoci {expected}, a uzyskano {received}',
        argumentType: 'Typ argumentu to {type}',
        argumentTypes: 'Typy argumentw: ({types})',
        assignToNone: 'Nie mona przypisa typu do elementu None',
        asyncHelp: 'Czy chodzio o warto async with?',
        baseClassIncompatible: 'Klasa bazowa {baseClass} jest niezgodna z typem {type}',
        baseClassIncompatibleSubclass: 'Klasa bazowa {baseClass} pochodzi od klasy podrzdnej {subclass}, ktra jest niezgodna z typem {type}',
        baseClassOverriddenType: 'Klasa bazowa {baseClass} udostpnia typ {type}, ktry jest przesonity',
        baseClassOverridesType: 'Zastpienie klasy bazowej {baseClass} typem {type}',
        bytesTypePromotions: 'Ustaw waciwo disableBytesTypePromotions na warto false, aby wczy zachowanie promocji typu dla elementw bytearray i memoryview',
        conditionalRequiresBool: 'Metoda __bool__ dla typu {operandType} zwraca typ "{boolReturnType}" zamiast bool',
        dataClassFieldLocation: 'Deklaracja pola',
        dataClassFrozen: 'Nazwa {name} jest zamroona',
        dataProtocolUnsupported: 'Element {name} to protok danych',
        descriptorAccessBindingFailed: 'Nie mona powiza metody {name} dla klasy deskryptora {className}',
        descriptorAccessCallFailed: 'Nie mona wywoa metody {name} dla klasy deskryptora {className}',
        finalMethod: 'Final method',
        functionParamDefaultMissing: 'Brak domylnego argumentu dla parametru {name}',
        functionParamName: 'Niezgodno nazw parametrw: {destName} a {srcName}',
        functionParamPositionOnly: 'Niezgodno parametrw tylko do pooenia; parametr {name} nie jest tylko pozycj',
        functionReturnTypeMismatch: 'Typ zwracanego typu funkcji {sourceType} jest niezgodny z typem {destType}',
        functionTooFewParams: 'Funkcja akceptuje zbyt mao parametrw pozycyjnych; oczekiwano {expected}, ale otrzymano {received}',
        functionTooManyParams: 'Funkcja akceptuje zbyt wiele parametrw pozycyjnych; oczekiwano {expected}, ale otrzymano {received}',
        genericClassNotAllowed: 'Typ oglny z argumentami typu jest niedozwolony dla sprawdzania wystpienia lub klasy',
        incompatibleDeleter: 'Property deleter method is incompatible',
        incompatibleGetter: 'Property getter method is incompatible',
        incompatibleSetter: 'Property setter method is incompatible',
        initMethodLocation: 'Metoda __init__ jest zdefiniowana w klasie {type}',
        initMethodSignature: 'Sygnatura __init__ to typ {type}',
        initSubclassLocation: 'Metoda __init_subclass__ jest zdefiniowana w klasie {name}',
        invariantSuggestionDict: 'Rozwa przeczenie z wartoci dict na Mapping, ktra jest kowariantna w typie wartoci',
        invariantSuggestionList: 'Rozwa zmian wartoci list na Sequence, ktra jest kowariantna',
        invariantSuggestionSet: 'Rozwa przeczenie z wartoci set na Container, ktra jest kowariantna',
        isinstanceClassNotSupported: 'Typ {type} nie jest obsugiwany w przypadku kontroli wystpie i klas',
        keyNotRequired: '{name} nie jest wymaganym kluczem w typie {type}, wic dostp moe spowodowa wyjtek rodowiska uruchomieniowego',
        keyReadOnly: 'Nazwa {name} jest kluczem tylko do odczytu w typie {type}',
        keyRequiredDeleted: 'Nazwa {name} jest wymaganym kluczem i nie mona go usun',
        keyUndefined: 'Nazwa {name} nie jest zdefiniowanym kluczem w typie {type}',
        kwargsParamMissing: 'Parametr **{paramName} nie ma odpowiadajcego mu parametru',
        listAssignmentMismatch: 'Typ {type} jest niezgodny z list docelow',
        literalAssignmentMismatch: 'Nie mona przypisa typu {sourceType} do typu {destType}',
        matchIsNotExhaustiveHint: 'Jeli kompleksowa obsuga nie jest zamierzona, dodaj case _: pass',
        matchIsNotExhaustiveType: 'Nieobsugiwany typ: {type}',
        memberAssignment: 'Wyraenia typu {type} nie mona przypisa do atrybutu {name} klasy {classType}',
        memberIsAbstract: '{type}.{name} nie zostao zaimplementowane',
        memberIsAbstractMore: 'i jeszcze {count}...',
        memberIsClassVarInProtocol: 'Element {name} jest zdefiniowany jako element ClassVar w protokole',
        memberIsInitVar: 'Skadowa {name} jest polem do operacji init-only',
        memberIsInvariant: 'Nazwa {name} jest niezmienna, poniewa jest modyfikowalna',
        memberIsNotClassVarInClass: 'Element {name} musi by zdefiniowany jako ClassVar, aby by zgodny z protokoem',
        memberIsNotClassVarInProtocol: 'Element {name} nie jest zdefiniowany jako ClassVar w protokole',
        memberIsNotReadOnlyInProtocol: '{name} nie jest tylko do odczytu w protokole',
        memberIsReadOnlyInProtocol: '{name} jest tylko do odczytu w protokole',
        memberIsWritableInProtocol: 'Nazwa {name} jest zapisywalna w protokole',
        memberSetClassVar: 'Atrybut {name} nie moe zosta przypisany przez wystpienie klasy, poniewa jest to element ClassVar',
        memberTypeMismatch: 'Nazwa {name} jest niezgodnym typem',
        memberUnknown: 'Atrybut {name} jest nieznany',
        metaclassConflict: 'Metaklasa {metaclass1} powoduje konflikt z {metaclass2}',
        missingDeleter: 'Property deleter method is missing',
        missingGetter: 'Property getter method is missing',
        missingSetter: 'Property setter method is missing',
        namedParamMissingInDest: 'Dodatkowy parametr {name}',
        namedParamMissingInSource: 'Brak parametru sowa kluczowego {name}',
        namedParamTypeMismatch: 'Parametr sowa kluczowego {name} typu {sourceType} jest niezgodny z typem {destType}',
        namedTupleNotAllowed: 'Funkcja NamedTuple nie moe by uywana do sprawdzania wystpie lub klas',
        newMethodLocation: 'Metoda __new__ jest zdefiniowana w klasie {type}',
        newMethodSignature: 'Sygnatura __new__ to typ {type}',
        newTypeClassNotAllowed: 'Klasy utworzonej za pomoc elementu NewType nie mona uywa z sprawdzaniem wystpie i klas',
        noOverloadAssignable: 'adna przeciona funkcja nie pasuje do typu {type}',
        noneNotAllowed: 'Warto None nie moe by uywana w przypadku kontroli wystpie lub klas',
        orPatternMissingName: 'Brak nazw: {name}',
        overloadIndex: 'Przecienie {index} jest najbardziej zblionym dopasowaniem',
        overloadNotAssignable: 'Nie mona przypisa jednego lub wicej przecie {name}.',
        overloadSignature: 'Sygnatura przecienia jest zdefiniowana tutaj',
        overriddenMethod: 'Przesonita metoda',
        overriddenSymbol: 'Przesonity symbol',
        overrideInvariantMismatch: 'Typ zastpienia {overrideType} nie jest taki sam jak typ podstawowy {baseType}',
        overrideIsInvariant: 'Zmienna podlega przeobraeniom, dlatego jej typ jest niezmienny',
        overrideNoOverloadMatches: 'adna sygnatura przecienia w przesoniciu nie jest zgodna z metod bazow',
        overrideNotClassMethod: 'Metoda bazowa jest zadeklarowana jako metoda classmethod, ale przesonicie nie',
        overrideNotInstanceMethod: 'Metoda bazowa jest zadeklarowana jako metoda wystpienia, ale zastpienie nie jest',
        overrideNotStaticMethod: 'Metoda bazowa jest zadeklarowana jako staticmethod, ale przesonicie nie',
        overrideOverloadNoMatch: 'Zastpienie nie obsuguje wszystkich przecie metody podstawowej',
        overrideOverloadOrder: 'Przecienia dla metody przesaniania musz by w takiej samej kolejnoci, co metoda bazowa',
        overrideParamKeywordNoDefault: 'Niezgodno parametru sowa kluczowego {name}: parametr bazowy ma domyln warto argumentu, parametr zastpienia nie ma jej',
        overrideParamKeywordType: 'Niezgodno typu parametru sowa kluczowego {name}: parametr bazowy jest typu {baseType}, a parametr zastpienia jest typu {overrideType}',
        overrideParamName: 'Niezgodno nazwy parametru {index}: parametr podstawowy nosi nazw {baseName}, a parametr zastpienia  {overrideName}',
        overrideParamNameExtra: 'W bazie brakuje parametru {name}.',
        overrideParamNameMissing: 'Brak parametru {name} w zastpieniu',
        overrideParamNamePositionOnly: 'Niezgodno parametru {index}: parametr podstawowy {baseName} jest parametrem sowa kluczowego, parametr przesonicia jest tylko w pozycji',
        overrideParamNoDefault: 'Niezgodno parametru {index}: parametr bazowy ma domyln warto argumentu, a parametr zastpienia nie ma jej',
        overrideParamType: 'Niezgodno typw parametru {index}: parametr bazowy jest typu {baseType}, parametr zastpienia jest typu {overrideType}',
        overridePositionalParamCount: 'Niezgodno liczby parametrw pozycyjnych; metoda podstawowa ma {baseCount}, a zastpienie {overrideCount}',
        overrideReturnType: 'Niezgodno zwracanego typu: metoda podstawowa zwraca typ {baseType}, przesonicie zwraca typ {overrideType}',
        overrideType: 'Klasa bazowa definiuje typ jako {type}',
        paramAssignment: 'Parametr {index}: typ {sourceType} jest niezgodny z typem {destType}',
        paramSpecMissingInOverride: 'Brak parametrw ParamSpec w metodzie zastpienia',
        paramType: 'Typ parametru to {paramType}',
        privateImportFromPyTypedSource: 'Zamiast tego importuj z moduu {module}.',
        propertyAccessFromProtocolClass: 'Nie mona uzyska dostpu do waciwoci zdefiniowanej w klasie protokou jako zmiennej klasy',
        propertyMethodIncompatible: 'Property method "{name}" is incompatible',
        propertyMethodMissing: 'Property method "{name}" is missing in override',
        propertyMissingDeleter: 'Property "{name}" has no defined deleter',
        propertyMissingSetter: 'Property "{name}" has no defined setter',
        protocolIncompatible: 'Protok {sourceType} jest niezgodny z protokoem {destType}',
        protocolMemberMissing: 'Brak nazwy {name}.',
        protocolRequiresRuntimeCheckable: 'Klasa Protocol musi by @runtime_checkable, aby moga by uywana z kontrolami wystpie i klas',
        protocolSourceIsNotConcrete: '{sourceType} nie jest typem specyficznej klasy i nie mona go przypisa do typu {destType}',
        protocolUnsafeOverlap: 'Atrybuty {name} maj takie same nazwy jak protok',
        pyrightCommentIgnoreTip: 'Uyj polecenia # pyright: ignore[<diagnostic rules>], aby wyczy diagnostyk dla pojedynczego wiersza',
        readOnlyAttribute: 'Atrybut {name} jest tylko do odczytu',
        seeClassDeclaration: 'Zobacz deklaracj klasy',
        seeDeclaration: 'Zobacz deklaracj',
        seeFunctionDeclaration: 'Zobacz deklaracj funkcji',
        seeMethodDeclaration: 'Zobacz deklaracj metody',
        seeParameterDeclaration: 'Zobacz deklaracj parametru',
        seeTypeAliasDeclaration: 'Zobacz deklaracj aliasu typu',
        seeVariableDeclaration: 'Zobacz deklaracj zmiennej',
        tupleAssignmentMismatch: 'Typ {type} jest niezgodny z docelow tuple',
        tupleEntryTypeMismatch: 'Wpis tuple {entry} jest nieprawidowego typu',
        tupleSizeIndeterminateSrc: 'Niezgodno rozmiaru kolekcji tuple; oczekiwano {expected}, ale otrzymano rozmiar nieokrelony',
        tupleSizeIndeterminateSrcDest: 'Niezgodno rozmiaru kolekcji tuple; oczekiwano {expected} lub wicej, a otrzymano rozmiar nieokrelony',
        tupleSizeMismatch: 'Niezgodno rozmiaru tuple; oczekiwano {expected}, ale otrzymano {received}',
        tupleSizeMismatchIndeterminateDest: 'Niezgodno rozmiaru kolekcji tuple; oczekiwano {expected} lub wicej, a otrzymano {received}',
        typeAliasInstanceCheck: 'Alias typu utworzony za pomoc instrukcji {type} nie moe by uyty do sprawdzania wystpie i klas',
        typeAssignmentMismatch: 'Typu {sourceType} nie mona przypisa do typu {destType}',
        typeBound: 'Typu {sourceType} nie mona przypisa do grnej granicy {destType} dla zmiennej typu {name}',
        typeConstrainedTypeVar: 'Typu {type} nie mona przypisa do zmiennej typu ograniczonego {name}',
        typeIncompatible: 'Nie mona przypisa typu {sourceType} do typu {destType}',
        typeNotClass: 'Typ {type} nie jest klas',
        typeNotStringLiteral: '{type} nie jest literaem cigu',
        typeOfSymbol: 'Typ nazwy {name} jest to {type}',
        typeParamSpec: 'Typ {type} jest niezgodny ze specyfikacj ParamSpec {name}',
        typeUnsupported: 'Typ {type} nie jest obsugiwany',
        typeVarDefaultOutOfScope: 'Zmienna typu {name} nie wchodzi w zakres',
        typeVarIsContravariant: 'Parametr typu {name} jest kontrawariantny, ale {sourceType} nie jest nadtypem {destType}',
        typeVarIsCovariant: 'Parametr typu {name} jest kowariantny, ale {sourceType} nie jest podtypem {destType}',
        typeVarIsInvariant: 'Parametr typu {name} jest niezmienny, ale {sourceType} nie jest taki sam jak {destType}',
        typeVarNotAllowed: 'Typ TypeVar nie jest dozwolony dla sprawdzania wystpienia lub klasy',
        typeVarTupleRequiresKnownLength: 'Nie mona powiza parametru TypeVarTuple ze tuple o nieznanej dugoci',
        typeVarUnnecessarySuggestion: 'Zamiast tego uyj elementu {type}',
        typeVarUnsolvableRemedy: 'Podaj przecienie, ktre okrela zwracany typ, gdy nie podano argumentu',
        typeVarsMissing: 'Brak zmiennych typu: {names}',
        typedDictBaseClass: 'Klasa {type} nie jest typem TypedDict',
        typedDictClassNotAllowed: 'Klasa TypedDict nie jest dozwolona na potrzeby sprawdzania wystpienia lub klasy',
        typedDictClosedExtraNotAllowed: 'Nie mona doda elementu "{name}"',
        typedDictClosedExtraTypeMismatch: 'Nie mona doda elementu "{name}" z typem {type}',
        typedDictClosedFieldNotRequired: 'Nie mona doda elementu "{name}", poniewa musi on mie warto NotRequired',
        typedDictExtraFieldNotAllowed: 'Element {name} nie jest obecny w typie {type}',
        typedDictExtraFieldTypeMismatch: 'Typ {name} jest niezgodny z typem extra_items w typie {type}',
        typedDictFieldMissing: 'Brak nazwy {name} w {type}',
        typedDictFieldNotReadOnly: 'Nazwa {name} nie jest tylko do odczytu w {type}',
        typedDictFieldNotRequired: 'Nazwa {name} nie jest wymagana w typie {type}',
        typedDictFieldRequired: 'Nazwa {name} jest wymagana w typie {type}',
        typedDictFieldTypeMismatch: 'Nie mona przypisa typu {type} do elementu {name}',
        typedDictFieldUndefined: 'Nazwa {name} jest niezdefiniowanym elementem w typie {type}',
        typedDictFinalMismatch: 'Typ {sourceType} jest niezgodny z typem {destType} z powodu niezgodnoci @final',
        typedDictKeyAccess: 'Uyj elementu ["{name}"], aby odwoa si do elementu w TypedDict',
        typedDictNotAllowed: 'Funkcja TypedDict nie moe by uywana do sprawdzania wystpie lub klas',
        unhashableType: 'Typ {type} nie jest wartoci skrtu',
        uninitializedAbstractVariable: 'zmienna wystpienia {name} jest zdefiniowana w abstrakcyjnej klasie bazowej {classType} ale nie zostaa zainicjowana',
        unreachableExcept: 'Typ {exceptionType} jest podklas typu {parentType}',
        useDictInstead: 'Uyj funkcji Dict[T1, T2], aby wskaza typ sownika',
        useListInstead: 'Use List[T] to indicate a list type or Union[T1, T2] to indicate a union type',
        useTupleInstead: 'Use tuple[T1, ..., Tn] to indicate a tuple type or Union[T1, T2] to indicate a union type',
        useTypeInstead: 'Zamiast tego uyj typu Type[T].',
        varianceMismatchForClass: 'Wariancja argumentu typu {typeVarName} jest niezgodna z klas bazow {className}',
        varianceMismatchForTypeAlias: 'Wariancja argumentu typu {typeVarName} jest niezgodna z parametrem {typeAliasParam}'
      },
      Service: {
        longOperation: 'Wyliczanie plikw rdowych obszaru roboczego zajmuje duo czasu. Zamiast tego rozwa otwarcie podfolderu. [Dowiedz si wicej](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  55169: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Criar Stub de Tipo',
        createTypeStubFor: 'Criar Stub de tipo para "{moduleName}"',
        executingCommand: 'Executando comando',
        filesToAnalyzeCount: '{count} arquivos a serem analisados',
        filesToAnalyzeOne: '1 arquivo a ser analisado',
        findingReferences: 'Localizando referncias',
        organizeImports: 'Organizar as importaes',
        renameShadowedFile: 'Renomear "{oldFile}" para "{newFile}"'
      },
      Completion: {
        autoImportDetail: 'Importao automtica',
        indexValueDetail: 'Valor do ndice'
      },
      Diagnostic: {
        abstractMethodInvocation: 'O mtodo "{method}" no pode ser chamado porque  abstrato e no est implementado',
        annotatedMetadataInconsistent: 'O tipo de metadados anotados "{metadataType}" no  compatvel com o tipo "{type}"',
        annotatedParamCountMismatch: 'Incompatibilidade de contagem de anotaes de parmetro: esperado {expected}, mas recebido {received}',
        annotatedTypeArgMissing: 'Esperava-se um argumento de tipo e uma ou mais anotaes para "Annotated"',
        annotationBytesString: 'Expresses de tipo no podem usar literais de cadeia de caracteres de bytes',
        annotationFormatString: 'As expresses de tipo no podem usar literais de cadeia de caracteres de formato (cadeias de caracteres f)',
        annotationNotSupported: 'Anotao de tipo sem suporte para esta instruo',
        annotationRawString: 'Expresses de tipo no podem usar literais de cadeia de caracteres brutas',
        annotationSpansStrings: 'Expresses de tipo no podem abranger vrios literais de cadeia de caracteres',
        annotationStringEscape: 'Expresses de tipo no podem conter caracteres de escape',
        argAssignment: 'O argumento do tipo "{argType}" no pode ser atribudo ao parmetro do tipo "{paramType}"',
        argAssignmentFunction: 'O argumento do tipo "{argType}" no pode ser atribudo ao parmetro do tipo "{paramType}" na funo "{functionName}"',
        argAssignmentParam: 'O argumento do tipo "{argType}" no pode ser atribudo ao parmetro "{paramName}" do tipo "{paramType}"',
        argAssignmentParamFunction: 'O argumento do tipo "{argType}" no pode ser atribudo ao parmetro "{paramName}" do tipo "{paramType}" na funo "{functionName}"',
        argMissingForParam: 'Argumento ausente para o parmetro {name}',
        argMissingForParams: 'Argumentos ausentes para os parmetros {names}',
        argMorePositionalExpectedCount: 'Esperavam-se mais {expected} argumentos posicionais',
        argMorePositionalExpectedOne: 'Espera-se mais um argumento posicional',
        argPositional: 'Argumento posicional esperado',
        argPositionalExpectedCount: '{expected} argumentos posicionais esperados',
        argPositionalExpectedOne: 'Argumento posicional esperado 1',
        argTypePartiallyUnknown: 'O tipo de argumento  parcialmente desconhecido',
        argTypeUnknown: 'O tipo de argumento  desconhecido',
        assertAlwaysTrue: 'A expresso assert sempre  avaliada como true',
        assertTypeArgs: '"assert_type" espera dois argumentos posicionais',
        assertTypeTypeMismatch: 'Incompatibilidade "assert_type": esperava-se "{expected}", mas recebeu "{received}"',
        assignmentExprComprehension: 'O destino da expresso de atribuio "{name}" no pode usar o mesmo nome da compreenso para o destino',
        assignmentExprContext: 'A expresso de atribuio deve estar dentro de mdulo, funo ou lambda',
        assignmentExprInSubscript: 'Expresses de atribuio em um subscrito so compatveis apenas no Python 3.10 e mais recente',
        assignmentInProtocol: 'As variveis de instncia ou classe dentro de uma classe Protocol devem ser declaradas explicitamente dentro do corpo da classe',
        assignmentTargetExpr: 'A expresso no pode ser o destino de atribuio',
        asyncNotInAsyncFunction: 'Uso de "async" no permitido fora da funo async',
        awaitIllegal: 'O uso de "await" requer o Python 3.5 ou mais recente',
        awaitNotAllowed: 'Expresses de tipo no podem usar "await"',
        awaitNotInAsync: '"await" permitido somente dentro da funo async',
        backticksIllegal: 'No h suporte para expresses delimitadas por backticks no Python 3.x. Use repr em vez disso',
        baseClassCircular: 'A classe no pode derivar de si mesma',
        baseClassFinal: 'A classe base "{type}" est marcada como final e no pode ser subclasse',
        baseClassIncompatible: 'Classes base de {type} so mutuamente incompatveis',
        baseClassInvalid: 'O argumento para a classe deve ser uma classe base',
        baseClassMethodTypeIncompatible: 'Classes base para a classe "{classType}" definem o mtodo "{name}" de maneira incompatvel',
        baseClassUnknown: 'O tipo de classe base  desconhecido, ocultando o tipo de classe derivada',
        baseClassVariableTypeIncompatible: 'Classes base para a classe "{classType}" definem a varivel "{name}" de maneira incompatvel',
        binaryOperationNotAllowed: 'Operador binrio no permitido na expresso de tipo',
        bindTypeMismatch: 'No foi possvel associar o mtodo "{methodName}" porque "{type}" no  atribuvel ao parmetro "{paramName}"',
        breakInExceptionGroup: '"break" no  permitido em um bloco "except*"',
        breakOutsideLoop: '"break" s pode ser usado dentro de um loop',
        callableExtraArgs: 'Esperava-se apenas dois argumentos de tipo para "Callable"',
        callableFirstArg: 'Lista de tipos de parmetro esperado ou "..."',
        callableNotInstantiable: 'No  possvel criar uma instncia do tipo "{type}"',
        callableSecondArg: 'Tipo de retorno esperado como segundo argumento de tipo para "Callable"',
        casePatternIsIrrefutable: 'O padro irrefutvel  permitido somente para a ltima instruo case',
        classAlreadySpecialized: 'O tipo "{type}" j  especializado',
        classDecoratorTypeUnknown: 'Um decorador de classe sem tipo obscurece o tipo de classe. Ignorando o decorador',
        classDefinitionCycle: 'A definio de classe para "{name}" depende de si mesma',
        classGetItemClsParam: 'A substituio__class_getitem__ deve usar um parmetro "cls"',
        classMethodClsParam: 'Os mtodos de classe devem usar um parmetro "cls"',
        classNotRuntimeSubscriptable: 'O subscrito para a classe "{name}" gerar uma exceo de runtime. Coloque a expresso de tipo entre aspas',
        classPatternBuiltInArgPositional: 'O padro de classe aceita apenas sub-padro posicional',
        classPatternPositionalArgCount: 'Muitos padres posicionais para a classe "{type}"; esperado {expected} mas recebido {received}',
        classPatternTypeAlias: '"{type}" no pode ser usado em um padro de classe porque  um alias de tipo especializado',
        classPropertyDeprecated: 'As propriedades de classe foram preteridas no Python 3.11 e no tero suporte no Python 3.13',
        classTypeParametersIllegal: 'A sintaxe do parmetro de tipo de classe requer o Python 3.12 ou mais recente',
        classVarFirstArgMissing: 'Um argumento de tipo era esperado aps "ClassVar"',
        classVarNotAllowed: '"ClassVar" no  permitido neste contexto',
        classVarOverridesInstanceVar: 'A varivel de classe "{name}" substitui a varivel de instncia do mesmo nome na classe "{className}"',
        classVarTooManyArgs: 'Espera-se apenas um argumento de tipo aps "ClassVar"',
        classVarWithTypeVar: 'O tipo "ClassVar" no pode incluir variveis de tipo',
        clsSelfParamTypeMismatch: 'O tipo de parmetro "{name}" deve ser um supertipo de sua classe "{classType}"',
        codeTooComplexToAnalyze: 'O cdigo  muito complexo para ser analisado. Reduza a complexidade refatorando em sub-rotinas ou reduzindo caminhos de cdigo condicionais',
        collectionAliasInstantiation: 'O tipo "{type}" no pode ser instanciado, use "{alias}" em vez disso',
        comparisonAlwaysFalse: 'A condio sempre ser avaliada como False, pois os tipos "{leftType}" e "{rightType}" no tm sobreposio',
        comparisonAlwaysTrue: 'A condio sempre ser avaliada como True, pois os tipos "{leftType}" e "{rightType}" no tm sobreposio',
        comprehensionInDict: 'A compreenso no pode ser usada com outras entradas de dicionrio',
        comprehensionInSet: 'A compreenso no pode ser usada com outras entradas de set',
        concatenateContext: '"Concatenate" no  permitido nesse contexto',
        concatenateParamSpecMissing: 'O ltimo tipo de argumento para "Concatenate" deve ser um ParamSpec ou "..."',
        concatenateTypeArgsMissing: '"Concatenate" requer pelo menos dois argumentos de tipo',
        conditionalOperandInvalid: 'Operando condicional invlido do tipo "{type}"',
        constantRedefinition: '"{name}"  constante (porque est em maisculas) e no pode ser redefinido',
        constructorParametersMismatch: 'Incompatibilidade entre a assinatura de __new__ e __init__ na classe "{classType}"',
        containmentAlwaysFalse: 'A expresso sempre ser avaliada como False, pois os tipos "{leftType}" e "{rightType}" no tm sobreposio',
        containmentAlwaysTrue: 'A expresso sempre ser avaliada como True, pois os tipos "{leftType}" e "{rightType}" no tm sobreposio',
        continueInExceptionGroup: '"continue" no  permitido em um bloco "except*"',
        continueOutsideLoop: '"continue" s pode ser usado dentro de um loop',
        coroutineInConditionalExpression: 'A expresso condicional faz referncia  corrotina, que sempre  avaliada como True',
        dataClassBaseClassFrozen: 'Uma classe no congelada no pode herdar de uma classe congelada',
        dataClassBaseClassNotFrozen: 'Uma classe congelada no pode herdar de uma classe que no est congelada',
        dataClassConverterFunction: 'O argumento do tipo "{argType}" no  um conversor vlido para o campo "{fieldName}" do tipo "{fieldType}"',
        dataClassConverterOverloads: 'Nenhuma sobrecarga de "{funcName}" so conversores vlidos para o campo "{fieldName}" do tipo "{fieldType}"',
        dataClassFieldInheritedDefault: '"{fieldName}" substitui um campo com o mesmo nome, mas no possui um valor padro',
        dataClassFieldWithDefault: 'Campos sem valores padro no podem aparecer aps campos com valores padro',
        dataClassFieldWithPrivateName: 'O campo Dataclass no pode usar o nome privado',
        dataClassFieldWithoutAnnotation: 'O campo Dataclass sem anotao de tipo causar uma exceo de runtime',
        dataClassPostInitParamCount: 'Contagem de parmetros de dataclasse __post_init__ incorreta. O nmero de campos InitVar  {expected}',
        dataClassPostInitType: 'Incompatibilidade de tipo de parmetro de mtodo de dataclasse __post_init__ para o campo "{fieldName}"',
        dataClassSlotsOverwrite: '__slots__ j est definido na classe',
        dataClassTransformExpectedBoolLiteral: 'Expresso esperada que  avaliada estaticamente como True ou False',
        dataClassTransformFieldSpecifier: 'Esperava-se tuple de classes ou funes, mas recebeu o tipo "{type}"',
        dataClassTransformPositionalParam: 'Todos os argumentos para "dataclass_transform" devem ser argumentos de palavra-chave',
        dataClassTransformUnknownArgument: 'O argumento "{name}" dataclass_transform no  compatvel',
        dataProtocolInSubclassCheck: 'Protocolos de dados (que incluem atributos que no so de mtodo) no so permitidos em chamadas issubclass',
        declaredReturnTypePartiallyUnknown: 'O tipo de retorno declarado, "{returnType}",  parcialmente desconhecido',
        declaredReturnTypeUnknown: 'O tipo de retorno declarado  desconhecido',
        defaultValueContainsCall: 'Chamadas de funo e objetos mutveis no permitidos na expresso de valor padro do parmetro',
        defaultValueNotAllowed: 'O parmetro com "*" ou "**" no pode ter valor padro',
        delTargetExpr: 'A expresso no pode ser excluda',
        deprecatedClass: 'A classe "{name}" foi preterida',
        deprecatedConstructor: 'O construtor da classe "{name}" foi preterido',
        deprecatedDescriptorDeleter: 'O mtodo "__delete__" para o descritor "{name}" est preterido',
        deprecatedDescriptorGetter: 'O mtodo "__get__" para o descritor "{name}" est preterido',
        deprecatedDescriptorSetter: 'O mtodo "__set__" para o descritor "{name}" est preterido',
        deprecatedFunction: 'A funo "{name}" est obsoleta',
        deprecatedMethod: 'O mtodo "{name}" na classe "{className}" est obsoleto',
        deprecatedPropertyDeleter: 'O deleter da property "{name}" foi preterido',
        deprecatedPropertyGetter: 'O getter da property "{name}" foi preterido',
        deprecatedPropertySetter: 'O setter da property "{name}" est preterido',
        deprecatedType: 'Este tipo foi preterido no Python {version}. Use "{replacement}" em vez disso',
        dictExpandIllegalInComprehension: 'Expanso de dicionrio no permitida na compreenso',
        dictInAnnotation: 'Expresso de dicionrio no permitida na expresso de tipo',
        dictKeyValuePairs: 'Entradas de dicionrio devem conter pares chave/valor',
        dictUnpackIsNotMapping: 'Mapeamento esperado para o operador de desempacotamento de dicionrio',
        dunderAllSymbolNotPresent: '"{name}" est especificado no __all__ mas no est presente no mdulo',
        duplicateArgsParam: 'Somente um parmetro "*" permitido',
        duplicateBaseClass: 'Classe base duplicada no permitida',
        duplicateCapturePatternTarget: 'O destino de captura "{name}" no pode aparecer mais de uma vez dentro do mesmo padro',
        duplicateCatchAll: 'Somente uma clusula de except catch-all  permitida',
        duplicateEnumMember: 'O membro de Enum "{name}" j est declarado',
        duplicateGenericAndProtocolBase: 'Somente uma classe base Generic[...] ou Protocol[...]  permitida',
        duplicateImport: '"{importName}" foi importado mais de uma vez',
        duplicateKeywordOnly: 'Somente um separador "*" permitido',
        duplicateKwargsParam: 'Somente um parmetro "**"  permitido',
        duplicateParam: 'Nome de parmetro "{name}" duplicado',
        duplicatePositionOnly: 'Somente um parmetro "/" permitido',
        duplicateStarPattern: 'Somente um padro "*" permitido em uma sequncia de padres',
        duplicateStarStarPattern: 'Somente uma entrada "**"  permitida',
        duplicateUnpack: 'Somente uma operao unpack  permitida na lista',
        ellipsisAfterUnpacked: '"..." no pode ser usado com um TypeVarTuple ou tuple descompactado',
        ellipsisContext: '"..." no  permitido neste contexto',
        ellipsisSecondArg: '"..."  permitido apenas como o segundo de dois argumentos',
        enumClassOverride: 'A classe Enum "{name}"  final e no pode ser subclasse',
        enumMemberDelete: 'O membro Enum "{name}" no pode ser excludo',
        enumMemberSet: 'O membro Enum "{name}" no pode ser atribudo',
        enumMemberTypeAnnotation: 'Anotaes de tipo noso permitidas para membros de enumerao',
        exceptGroupMismatch: 'A instruo Try no pode incluir "except" e "except*"',
        exceptGroupRequiresType: 'A sintaxe do grupo de exceo ("except*") requer um tipo de exceo',
        exceptionGroupIncompatible: 'A sintaxe do grupo de exceo ("except*") requer o Python 3.11 ou mais recente',
        exceptionGroupTypeIncorrect: 'O tipo de exceo em except* nopode derivar de BaseGroupException',
        exceptionTypeIncorrect: '"{type}" no deriva de BaseException',
        exceptionTypeNotClass: '"{type}" no  uma classe de exceo vlida',
        exceptionTypeNotInstantiable: 'O construtor para o tipo de exceo "{type}" requer um ou mais argumentos',
        expectedAfterDecorator: 'Funo ou declarao de classe esperada aps o decorador',
        expectedArrow: 'Esperava-se "->" seguido pela anotao de tipo de retorno',
        expectedAsAfterException: 'Espera-se "as" aps o tipo de exceo',
        expectedAssignRightHandExpr: 'Expresso esperada  direita de "="',
        expectedBinaryRightHandExpr: 'Expresso esperada  direita do operador',
        expectedBoolLiteral: 'Espera-se True ou False',
        expectedCase: 'Instruo "case" esperada',
        expectedClassName: 'Nome de classe esperado',
        expectedCloseBrace: '"{" no foi fechado',
        expectedCloseBracket: '"[" no foi fechado',
        expectedCloseParen: '"(" no foi fechado',
        expectedColon: 'Esperava-se ":"',
        expectedComplexNumberLiteral: 'Literal de nmero complexo esperado para correspondncia de padres',
        expectedDecoratorExpr: 'Formulrio de expresso sem suporte para decorador antes do Python 3.9',
        expectedDecoratorName: 'Nome do decorador esperado',
        expectedDecoratorNewline: 'Nova linha esperada no final do decorador',
        expectedDelExpr: 'Expresso esperada aps "del"',
        expectedElse: 'Esperava-se #else',
        expectedEquals: 'Esperava-se "="',
        expectedExceptionClass: 'Classe ou objeto de exceo invlido',
        expectedExceptionObj: 'Objeto de exceo esperado: classe de exceo ou None',
        expectedExpr: 'Expresso esperada',
        expectedFunctionAfterAsync: 'Definio de funo esperada aps "async"',
        expectedFunctionName: 'Nome da funo esperado aps "def"',
        expectedIdentifier: 'Identificador esperado',
        expectedImport: '"importao" esperada',
        expectedImportAlias: 'Smbolo esperado aps "as"',
        expectedImportSymbols: 'Esperado um ou mais nomes de smbolos aps importar',
        expectedIn: 'Esperava-se "in"',
        expectedInExpr: 'Expresso esperada aps "in"',
        expectedIndentedBlock: 'Bloco recuado esperado',
        expectedMemberName: 'Nome de atributo esperado aps "."',
        expectedModuleName: 'Nome do mdulo esperado',
        expectedNameAfterAs: 'Nome de smbolo esperado aps "as"',
        expectedNamedParameter: 'O parmetro de palavra-chave deve seguir "*"',
        expectedNewline: 'Nova linha esperada',
        expectedNewlineOrSemicolon: 'As instrues devem ser separadas por novas linhas ou ponto e vrgula',
        expectedOpenParen: 'Esperava-se "("',
        expectedParamName: 'Nome do parmetro esperado',
        expectedPatternExpr: 'Expresso padro esperada',
        expectedPatternSubjectExpr: 'Expresso de assunto padro esperada',
        expectedPatternValue: 'Expresso de valor padro esperada da forma "a.b"',
        expectedReturnExpr: 'Expresso esperada aps "return" ',
        expectedSliceIndex: 'Expresso de ndice ou fatia esperada',
        expectedTypeNotString: 'Tipo esperado, mas recebeu um literal de cadeia de caracteres',
        expectedTypeParameterName: 'Nome do parmetro de tipo esperado',
        expectedYieldExpr: 'Expresso esperada na instruo yield',
        finalClassIsAbstract: 'A classe "{type}" est marcada como final e deve implementar todos os smbolos abstratos',
        finalContext: '"Final" no  permitido neste contexto',
        finalInLoop: 'Uma varivel "Final" no pode ser atribuda em um loop',
        finalMethodOverride: 'O mtodo "{name}" no pode substituir o mtodo final definido na classe "{className}"',
        finalNonMethod: 'A funo "{name}" no pode ser marcada como @final porque no  um mtodo',
        finalReassigned: '"{name}" est declarado como Final e no pode ser reatribudo',
        finalRedeclaration: '"{name}" foi declarado anteriormente como Final',
        finalRedeclarationBySubclass: '"{name}" no pode ser redeclarado porque a classe pai "{className}" a declara como Final',
        finalTooManyArgs: 'Argumento de tipo nico esperado aps "Final"',
        finalUnassigned: '"{name}" est declarado como Final, mas o valor no foi atribudo',
        formatStringBrace: 'Chave de fechamento nica no permitida no literal de cadeia de caracteres f. Usar chave de fechamento dupla',
        formatStringBytes: 'Literais de cadeia de caracteres de formato (cadeia de caracteres f) no podem ser binrias',
        formatStringDebuggingIllegal: 'O especificador de depurao de cadeia de caracteres f "=" requer o Python 3.8 ou mais recente',
        formatStringEscape: 'Sequncia de escape (barra invertida) no permitida na parte de expresso da cadeia de caracteres f em verses anteriores ao Python 3.12',
        formatStringExpectedConversion: 'Esperava-se um especificador de converso aps "!" na cadeia de caracteres f',
        formatStringIllegal: 'Literais de cadeia de caracteres de formato (cadeias de caracteres f) exigem Python 3.6 ou mais recente',
        formatStringInPattern: 'Cadeia de caracteres de formato no permitida no padro',
        formatStringNestedFormatSpecifier: 'Expresses aninhadas muito profundamente dentro do especificador de cadeia de caracteres de formato',
        formatStringNestedQuote: 'Cadeias de caracteres aninhadas em uma cadeia de caracteres f no podem usar o mesmo caractere de aspas que a cadeia de caracteres f antes do Python 3.12',
        formatStringUnicode: 'As literais de cadeia de caracteres de formato (f-strings) no podem ser unicode',
        formatStringUnterminated: 'Expresso no finalizada na cadeia de caracteres f. "}" era esperado',
        functionDecoratorTypeUnknown: 'Um decorador de funo sem tipo obscurece o tipo de funo. Ignorando o decorador',
        functionInConditionalExpression: 'Funo de referncias de expresso condicional que sempre  avaliada como True',
        functionTypeParametersIllegal: 'A sintaxe do parmetro de tipo de funo requer o Python 3.12 ou mais recente',
        futureImportLocationNotAllowed: 'As importaes __future__ devem estar no incio do arquivo',
        generatorAsyncReturnType: 'O tipo de retorno da funo geradora async deve ser compatvel com "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: 'As expresses de gerador devem estar entre parnteses se no forem argumentos exclusivos',
        generatorSyncReturnType: 'O tipo de retorno da funo de gerador deve ser compatvel com "Generator[{yieldType}, Any, Any]"',
        genericBaseClassNotAllowed: 'A classe base "Generic" no pode ser usada com sintaxe de parmetro de tipo',
        genericClassAssigned: 'O tipo de classe genrica no pode ser atribudo',
        genericClassDeleted: 'O tipo de classe genrica no pode ser excludo',
        genericInstanceVariableAccess: 'O acesso  varivel de instncia genrica por meio da classe  ambguo',
        genericNotAllowed: '"Generic" no  vlido neste contexto',
        genericTypeAliasBoundTypeVar: 'O alias de tipo genrico dentro da classe no pode usar variveis de tipo associado {names}',
        genericTypeArgMissing: '"Generic" requer pelo menos um argumento de tipo',
        genericTypeArgTypeVar: 'O argumento de tipo para "Generic" deve ser uma varivel de tipo',
        genericTypeArgUnique: 'Os argumentos de tipo para "Generic" devem ser exclusivos',
        globalReassignment: '"{name}"  atribudo antes da declarao global',
        globalRedefinition: '"{name}" j foi declarado global',
        implicitStringConcat: 'Concatenao de cadeia de caracteres implcita no permitida',
        importCycleDetected: 'Ciclo detectado na cadeia de importao',
        importDepthExceeded: 'A profundidade da cadeia de importao excedeu {depth}',
        importResolveFailure: 'No foi possvel resolver a importao "{importName}"',
        importSourceResolveFailure: 'No foi possvel resolver a importao "{importName}" da origem',
        importSymbolUnknown: '"{name}"  um smbolo de importao desconhecido',
        incompatibleMethodOverride: 'O mtodo "{name}" substitui a classe "{className}" de maneira incompatvel',
        inconsistentIndent: 'O valor de recuo no corresponde ao recuo anterior',
        inconsistentTabs: 'Uso inconsistente de guias e espaos no recuo',
        initMethodSelfParamTypeVar: 'A anotao de tipo para o parmetro "self" do mtodo "__init__" no pode conter variveis de tipo com escopo de classe',
        initMustReturnNone: 'O tipo de retorno de "__init__" deve ser None',
        initSubclassCallFailed: 'Argumentos de palavra-chave incorretos para o mtodo __init_subclass__',
        initSubclassClsParam: 'A substituio __init_subclass__ deve usar um parmetro "cls"',
        initVarNotAllowed: '"InitVar" no  permitido neste contexto',
        instanceMethodSelfParam: 'Os mtodos de instncia devem usar um parmetro "self"',
        instanceVarOverridesClassVar: 'A varivel de instncia "{name}" substitui a varivel de classe de mesmo nome na classe "{className}"',
        instantiateAbstract: 'No  possvel instanciar a classe abstrata "{type}"',
        instantiateProtocol: 'No  possvel instanciar a classe Protocol "{type}"',
        internalBindError: 'Erro interno ao associar o arquivo de associao "{file}": {message}',
        internalParseError: 'Ocorreu um erro interno ao analisar o arquivo "{file}": {message}',
        internalTypeCheckingError: 'Erro interno ao digitar o arquivo de verificao "{file}": {message}',
        invalidIdentifierChar: 'Caractere invlido no identificador',
        invalidStubStatement: 'A instruo no faz sentido dentro de um arquivo stub de tipo',
        invalidTokenChars: 'Caractere invlido "{text}" no token',
        isInstanceInvalidType: 'O segundo argumento para "isinstance" deve ser uma classe ou tuple de classes',
        isSubclassInvalidType: 'O segundo argumento para "issubclass" deve ser uma classe ou tuple de classes',
        keyValueInSet: 'Pares chave/valor no so permitidos em um set',
        keywordArgInTypeArgument: 'Argumentos de palavra-chave no podem ser usados em listas de argumentos de tipo',
        keywordArgShortcutIllegal: 'O atalho do argumento de palavra-chave requer Python 3.14 ou mais recente',
        keywordOnlyAfterArgs: 'Separador de argumento somente palavra-chave no permitido aps o parmetro "*"',
        keywordParameterMissing: 'Um ou mais parmetros de palavra-chave devem seguir o parmetro "*"',
        keywordSubscriptIllegal: 'No h suporte para argumentos de palavra-chave em subscritos',
        lambdaReturnTypePartiallyUnknown: 'O tipo de retorno de lambda, "{returnType}",  parcialmente desconhecido',
        lambdaReturnTypeUnknown: 'O tipo de retorno de lambda  desconhecido',
        listAssignmentMismatch: 'A expresso com o tipo "{type}" no pode ser atribuda  lista de destino',
        listInAnnotation: 'Expresso de List no permitida na expresso de tipo',
        literalEmptyArgs: 'Um ou mais argumentos de tipo esperados aps "Literal"',
        literalNamedUnicodeEscape: 'No h suporte para sequncias de escape unicode nomeadas em anotaes de cadeia de caracteres "Literal"',
        literalNotAllowed: '"Literal" no pode ser usado nesse contexto sem um argumento de tipo',
        literalNotCallable: 'O tipo Literal no pode ser instanciado',
        literalUnsupportedType: 'Os argumentos de tipo para "Literal" devem ser None, um valor literal (int, bool, str ou bytes) ou um valor de enumerao',
        matchIncompatible: 'As match de correspondncia exigem Python 3.10 ou mais recente',
        matchIsNotExhaustive: 'Os casos dentro da instruo match no lidam exaustivamente com todos os valores',
        maxParseDepthExceeded: 'Profundidade mxima de anlise excedida. Divida a expresso em subexpresses menores',
        memberAccess: 'No  possvel acessar o atributo "{name}" para a classe "{type}"',
        memberDelete: 'No  possvel excluir o atributo "{name}" para a classe "{type}"',
        memberSet: 'No  possvel atribuir o atributo "{name}" para a classe "{type}"',
        metaclassConflict: 'A metaclasse de uma classe derivada deve ser uma subclasse das metaclasses de todas as suas classes base',
        metaclassDuplicate: 'Apenas uma metaclasse pode ser fornecida',
        metaclassIsGeneric: 'A metaclasse no pode ser genrica',
        methodNotDefined: 'Mtodo "{name}" no definido',
        methodNotDefinedOnType: 'Mtodo "{name}" no definido no tipo "{type}"',
        methodOrdering: 'No  possvel criar ordenao de mtodo consistente',
        methodOverridden: '"{name}" substitui o mtodo de mesmo nome na classe "{className}" pelo tipo incompatvel "{type}"',
        methodReturnsNonObject: 'O mtodo "{name}" no retorna um objeto',
        missingSuperCall: 'O mtodo "{methodName}" no chama o mtodo do mesmo nome na classe pai',
        mixingBytesAndStr: 'Valores de bytes e str no podem ser concatenados',
        moduleAsType: 'O mdulo no pode ser usado como um tipo.',
        moduleNotCallable: 'O mdulo no pode ser chamado',
        moduleUnknownMember: '"{memberName}" no  um atributo conhecido do mdulo "{moduleName}"',
        namedExceptAfterCatchAll: 'Uma clusula except nomeada no pode aparecer aps a clusula catch-all except',
        namedParamAfterParamSpecArgs: 'O parmetro de palavra-chave "{name}" no pode aparecer na assinatura aps o parmetro args ParamSpec',
        namedTupleEmptyName: 'Nomes dentro de uma tuple nomeada no podem ficar vazios',
        namedTupleEntryRedeclared: 'No  possvel substituir "{name}" porque a classe pai "{className}"  uma tuple nomeada',
        namedTupleFirstArg: 'Nome de classe de tuple nomeado esperado como primeiro argumento',
        namedTupleMultipleInheritance: 'No h suporte para herana mltipla com NamedTuple',
        namedTupleNameKeyword: 'Os nomes dos campos no podem ser uma palavra-chave',
        namedTupleNameType: 'Expected two-entry tuple specifying entry name and type',
        namedTupleNameUnique: 'Os nomes dentro de uma tuple nomeada devem ser exclusivos',
        namedTupleNoTypes: '"namedtuple" no fornece tipos para entradas de tupla. Em vez disso, use "NamedTuple"',
        namedTupleSecondArg: 'Expected named tuple entry list as second argument',
        newClsParam: 'A substituio __new__ deve usar um parmetro "cls"',
        newTypeAnyOrUnknown: 'O segundo argumento para NewType deve ser uma classe conhecida, no Any ou Unknown',
        newTypeBadName: 'O primeiro argumento para NewType deve ser um literal de cadeia de caracteres',
        newTypeLiteral: 'NewType no pode ser usado com o tipo Literal',
        newTypeNameMismatch: 'NewType deve ser atribudo a uma varivel com o mesmo nome',
        newTypeNotAClass: 'Classe esperada como segundo argumento para NewType',
        newTypeParamCount: 'NewType requer dois argumentos posicionais',
        newTypeProtocolClass: 'NewType no pode ser usado com um tipo estrutural (uma classe Protocol ou TypedDict)',
        noOverload: 'Nenhuma sobrecarga para "{name}" corresponde aos argumentos fornecidos',
        noReturnContainsReturn: 'A funo com o tipo de return declarado "NoReturn" no pode incluir uma instruo return',
        noReturnContainsYield: 'A funo com o tipo de retorno declarado "NoReturn" no pode incluir uma instruo yield',
        noReturnReturnsNone: 'Funo com tipo de retorno declarado "NoReturn" no pode retornar "None"',
        nonDefaultAfterDefault: 'O argumento no padro segue o argumento padro',
        nonLocalInModule: 'Declarao nonlocal no permitida no nvel do mdulo',
        nonLocalNoBinding: 'Nenhuma associao para "{name}" nonlocal encontrada',
        nonLocalReassignment: '"{name}"  atribudo antes da declarao nonlocal',
        nonLocalRedefinition: '"{name}" j foi declarado nonlocal',
        noneNotCallable: 'O objeto do tipo "None" no pode ser chamado',
        noneNotIterable: 'O objeto do tipo "None" no pode ser usado como valor itervel',
        noneNotSubscriptable: 'O objeto do tipo "None" no  subscrito',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'Operador "{operator}" incompatvel com "None"',
        noneUnknownMember: '"{name}" no  um atributo conhecido de "None"',
        notRequiredArgCount: 'Argumento de tipo nico esperado aps "NotRequired"',
        notRequiredNotInTypedDict: '"NotRequired" no  permitido neste contexto',
        objectNotCallable: 'O objeto do tipo "{type}" no pode ser chamado',
        obscuredClassDeclaration: 'A declarao de classe "{name}" est obscurecida por uma declarao de mesmo nome',
        obscuredFunctionDeclaration: 'A declarao de funo "{name}"  obscurecida por uma declarao de mesmo nome',
        obscuredMethodDeclaration: 'A declarao de mtodo "{name}"  obscurecida por uma declarao de mesmo nome',
        obscuredParameterDeclaration: 'A declarao de parmetro "{name}"  obscurecida por uma declarao de mesmo nome',
        obscuredTypeAliasDeclaration: 'A declarao de alias de tipo "{name}"  obscurecida por uma declarao de mesmo nome',
        obscuredVariableDeclaration: 'A declarao "{name}"  obscurecida por uma declarao de mesmo nome',
        operatorLessOrGreaterDeprecated: 'O operador "<>" no  compatvel no Python 3. Use "!=" em vez disso',
        optionalExtraArgs: 'Espera-se um argumento de tipo aps "Optional"',
        orPatternIrrefutable: 'Padro irrefutvel permitido somente como o ltimo subpadro em um padro "or"',
        orPatternMissingName: 'Todos os subpadres dentro de um padro "or" devem ter como destino os mesmos nomes',
        overlappingKeywordArgs: 'O dicionrio digitado se sobrepe ao parmetro de palavra-chave: {names}',
        overlappingOverload: 'A sobrecarga {obscured} para "{name}" nunca ser usada porque seus parmetros se sobrepem  sobrecarga {obscuredBy}',
        overloadAbstractImplMismatch: 'As sobrecargas devem corresponder ao status abstrato da implementao',
        overloadAbstractMismatch: 'As sobrecargas devem ser abstratas ou no',
        overloadClassMethodInconsistent: 'Sobrecargas para "{name}" usam @classmethod inconsistentemente',
        overloadFinalInconsistencyImpl: 'A sobrecarga para "{name}" est marcada como @final mas a implementao no est',
        overloadFinalInconsistencyNoImpl: 'A sobrecarga {index} para "{name}" est marcada como @final mas a sobrecarga 1 no est',
        overloadImplementationMismatch: 'A implementao sobrecarregada no  consistente com a assinatura da sobrecarga {index}',
        overloadReturnTypeMismatch: 'A sobrecarga {prevIndex} para "{name}" sobrepe a sobrecarga {newIndex} e retorna um tipo incompatvel',
        overloadStaticMethodInconsistent: 'Sobrecargas para "{name}" usam @staticmethod inconsistentemente',
        overloadWithoutImplementation: '"{name}" est marcado como overload, mas nenhuma implementao foi fornecida',
        overriddenMethodNotFound: 'O mtodo "{name}" est marcado como override, mas nenhum mtodo base de mesmo nome est presente',
        overrideDecoratorMissing: 'O mtodo "{name}" no est marcado como override, mas est substituindo um mtodo na classe "{className}"',
        paramAfterKwargsParam: 'O parmetro no pode seguir o parmetro "**"',
        paramAlreadyAssigned: 'O parmetro "{name}" j est atribudo',
        paramAnnotationMissing: 'A anotao de tipo est ausente para o parmetro "{name}"',
        paramAssignmentMismatch: 'A expresso do tipo "{sourceType}" no pode ser atribuda ao parmetro do tipo "{paramType}"',
        paramNameMissing: 'Nenhum parmetro chamado "{name}"',
        paramSpecArgsKwargsDuplicate: 'Os argumentos para ParamSpec "{type}" j foram fornecidos',
        paramSpecArgsKwargsUsage: 'Os atributos "args" e "kwargs" de ParamSpec devem aparecer dentro de uma assinatura de funo',
        paramSpecArgsMissing: 'Argumentos para ParamSpec "{type}" esto ausentes',
        paramSpecArgsUsage: 'O atributo "args" de ParamSpec  vlido somente quando usado com o parmetro *args',
        paramSpecAssignedName: 'ParamSpec deve ser atribudo a uma varivel chamada "{name}"',
        paramSpecContext: 'ParamSpec no  permitido neste contexto',
        paramSpecDefaultNotTuple: 'Reticncias esperadas, uma expresso de tuple ou ParamSpec para o valor padro de ParamSpec',
        paramSpecFirstArg: 'Nome esperado de ParamSpec como primeiro argumento',
        paramSpecKwargsUsage: 'O atributo "kwargs" de ParamSpec  vlido somente quando usado com o parmetro **kwargs',
        paramSpecNotUsedByOuterScope: 'O ParamSpec "{name}" no tem significado neste contexto',
        paramSpecUnknownArg: 'ParamSpec no  compatvel com mais de um argumento',
        paramSpecUnknownMember: '"{name}" no  um atributo conhecido de ParamSpec',
        paramSpecUnknownParam: '"{name}"  um parmetro desconhecido para ParamSpec',
        paramTypeCovariant: 'Varivel de tipo covariante no pode ser usada no tipo de parmetro',
        paramTypePartiallyUnknown: 'O tipo de parmetro "{paramName}"  parcialmente desconhecido',
        paramTypeUnknown: 'O tipo de parmetro "{paramName}"  desconhecido',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'O padro nunca ser correspondido para o tipo de assunto "{type}"',
        positionArgAfterNamedArg: 'O argumento posicional no pode aparecer aps argumentos de palavra-chave',
        positionOnlyAfterArgs: 'Separador de parmetro somente de posio no permitido aps o parmetro "*"',
        positionOnlyAfterKeywordOnly: 'O parmetro "/" deve aparecer antes do parmetro "*"',
        positionOnlyAfterNon: 'Parmetro somente de posio no permitido aps o parmetro que no  somente posio',
        positionOnlyFirstParam: 'Separador de parmetro somente de posio no permitido como primeiro parmetro',
        positionOnlyIncompatible: 'O separador de parmetro somente de posio requer o Python 3.8 ou mais recente',
        privateImportFromPyTypedModule: '"{name}" no  exportado do mdulo "{module}"',
        privateUsedOutsideOfClass: '"{name}"  privado e usado fora da classe na qual  declarado',
        privateUsedOutsideOfModule: '"{name}"  privado e usado fora do mdulo no qual ele  declarado',
        propertyOverridden: '"{name}" override incorretamente a property de mesmo nome na classe "{className}"',
        propertyStaticMethod: 'Mtodos estticos no permitidos para as property getter, setter ou deleter',
        protectedUsedOutsideOfClass: '"{name}" est protegido e usado fora da classe na qual est declarado',
        protocolBaseClass: 'A classe "{classType}" Protocol no pode derivar da classe no Protocol "{baseType}"',
        protocolBaseClassWithTypeArgs: 'Argumentos de tipo no so permitidos com a classe Protocol ao usar a sintaxe de parmetro de tipo',
        protocolIllegal: 'O uso de "Protocol" requer o Python 3.7 ou mais recente',
        protocolNotAllowed: '"Protocol" no pode ser usado nesse contexto',
        protocolTypeArgMustBeTypeParam: 'O argumento de tipo para o "Protocolo" deve ser um parmetro de tipo',
        protocolUnsafeOverlap: 'A classe se sobrepe a "{name}" de forma no segura e pode produzir uma correspondncia em runtime',
        protocolVarianceContravariant: 'A varivel de tipo "{variable}" usada na "{class}" Protocol genrica deve ser contravariante',
        protocolVarianceCovariant: 'A varivel de tipo "{variable}" usada na "{class}" Protocol genrica deve ser covariante',
        protocolVarianceInvariant: 'A varivel de tipo "{variable}" usada na "{class}" Protocol genrica deve ser invarivel',
        pyrightCommentInvalidDiagnosticBoolValue: 'A diretiva de comentrio Pyright deve ser seguida por "=" e um valor true ou false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'A diretiva de comentrio Pyright deve ser seguida por "=" e um valor de true, false, error, warning, information ou none',
        pyrightCommentMissingDirective: 'O comentrio Pyright deve ser seguido por uma diretiva (basic ou strict) ou uma regra de diagnstico',
        pyrightCommentNotOnOwnLine: 'Comentrios Pyright usados para controlar as configuraes de nvel de arquivo devem aparecer em sua prpria linha',
        pyrightCommentUnknownDiagnosticRule: '"{rule}"  uma regra de diagnstico desconhecida para o comentrio pyright',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}"  um valor invlido para o comentrio pyright. true, false, error, warning, information ou none esperados.',
        pyrightCommentUnknownDirective: '"{directive}"  uma diretiva desconhecida para o comentrio pyright. Esperava-se "strict" ou "basic"',
        readOnlyArgCount: 'Argumento de tipo nico esperado aps "ReadOnly"',
        readOnlyNotInTypedDict: '"ReadOnly" no  permitido neste contexto',
        recursiveDefinition: 'No foi possvel determinar o tipo de "{name}" porque ele refere-se a si mesmo',
        relativeImportNotAllowed: 'Importaes relativas no podem ser usadas com o formulrio "import .a". Use "from . import a" em vez disso',
        requiredArgCount: 'Argumento de tipo nico esperado aps "Required"',
        requiredNotInTypedDict: '"Required" no  permitido neste contexto',
        returnInAsyncGenerator: 'A instruo return com valor no  permitida no gerador async',
        returnInExceptionGroup: '"return" no  permitido em um bloco "except*"',
        returnMissing: 'Funo com tipo de retorno declarado "{returnType}" deve retornar valor em todos os caminhos de cdigo',
        returnOutsideFunction: '"return" s pode ser usado dentro de uma funo',
        returnTypeContravariant: 'A varivel de tipo contravariante no pode ser usada no tipo de retorno',
        returnTypeMismatch: 'O tipo "{exprType}" no pode ser atribudo ao tipo "{returnType}"',
        returnTypePartiallyUnknown: 'O tipo de retorno, "{returnType}",  parcialmente desconhecido',
        returnTypeUnknown: 'O tipo de retorno  desconhecido',
        revealLocalsArgs: 'Nenhum argumento esperado para a chamada "reveal_locals"',
        revealLocalsNone: 'Nenhum locals neste escopo',
        revealTypeArgs: 'Esperava-se um nico argumento posicional para a chamada "reveal_type"',
        revealTypeExpectedTextArg: 'O argumento "expected_text" para a funo "reveal_type" deve ser um valor literal str',
        revealTypeExpectedTextMismatch: 'Tipo de incompatibilidade de texto. O esperado era "{expected}", mas recebeu "{received}"',
        revealTypeExpectedTypeMismatch: 'Incompatibilidade de tipo. Esperava-se "{expected}", mas recebeu "{received}"',
        selfTypeContext: '"Self" no  vlido neste contexto.',
        selfTypeMetaclass: '"Self" no pode ser usado em uma metaclasse (uma subclasse de "type")',
        selfTypeWithTypedSelfOrCls: '"Self" no pode ser usado em uma funo com um parmetro `self` ou `cls que tenha uma anotao de tipo diferente de "Self"',
        setterGetterTypeMismatch: 'O tipo de valor do setter da property no  atribuvel ao tipo de retorno getter',
        singleOverload: '"{name}" est marcado como sobrecarga, mas sobrecargas adicionais esto ausentes',
        slotsAttributeError: '"{name}" no est especificado em __slots__',
        slotsClassVarConflict: '"{name}" est em conflito com a varivel de instncia declarada __slots__',
        starPatternInAsPattern: 'O padro de estrela no pode ser usado com o destino "as"',
        starPatternInOrPattern: 'O padro de estrela no pode ser ORed em outros padres',
        starStarWildcardNotAllowed: '** no pode ser usado com curinga "_"',
        staticClsSelfParam: 'Os mtodos estticos no devem usar um parmetro "self" ou "cls"',
        stdlibModuleOverridden: '"{path}" est substituindo o mdulo stdlib "{name}"',
        stringNonAsciiBytes: 'Caractere no ASCII no permitido em literal de cadeia de caracteres de bytes',
        stringNotSubscriptable: 'A expresso de cadeia de caracteres no pode ser subscrita na expresso de tipo. Coloque toda a expresso entre aspas',
        stringUnsupportedEscape: 'Sequncia de escape sem suporte no literal de cadeia de caracteres',
        stringUnterminated: 'Literal de cadeia de caracteres no finalizado',
        stubFileMissing: 'Arquivo stub no encontrado para "{importName}"',
        stubUsesGetAttr: 'O arquivo stub de tipo est incompleto. "__getattr__" obscurece erros de tipo para o mdulo',
        sublistParamsIncompatible: 'parmetros de sublista no so suportados no Python 3.x',
        superCallArgCount: 'No mais que dois argumentos eram esperados para a chamada "super"',
        superCallFirstArg: 'Tipo de classe esperado como o primeiro argumento para a chamada "super", mas recebeu "{type}"',
        superCallSecondArg: 'O segundo argumento para a chamada "super" deve ser objeto ou classe que deriva de "{type}"',
        superCallZeroArgForm: 'A forma de chamada "super" com argumento zero  vlida apenas dentro de um mtodo',
        superCallZeroArgFormStaticMethod: 'A forma de chamada "super" com argumento zero  vlida apenas dentro de um mtodo',
        symbolIsPossiblyUnbound: '"{name}" possivelmente no est associado',
        symbolIsUnbound: '"{name}" no est associado',
        symbolIsUndefined: '"{name}" no est definido',
        symbolOverridden: '"{name}" substitui o smbolo de mesmo nome na classe "{className}"',
        ternaryNotAllowed: 'Expresso de ternrio no permitida na expresso de tipo',
        totalOrderingMissingMethod: 'A classe deve definir um dos "__lt__", "__le__", "__gt__" ou "__ge__" para usar total_ordering',
        trailingCommaInFromImport: 'A vrgula  direita no  permitida sem parnteses ao redor',
        tryWithoutExcept: 'A instruo Try deve ter pelo menos uma clusula except ou finally',
        tupleAssignmentMismatch: 'A expresso com o tipo "{type}" no pode ser atribuda  tuple de destino',
        tupleInAnnotation: 'Expresso de tuple no permitida na expresso de tipo',
        tupleIndexOutOfRange: 'O ndice {index} est fora do intervalo para o tipo {type}',
        typeAliasIllegalExpressionForm: 'Formulrio de expresso invlido para definio de alias de tipo',
        typeAliasIsRecursiveDirect: 'O alias de tipo "{name}" no pode usar a si mesmo em sua definio',
        typeAliasNotInModuleOrClass: 'Um TypeAlias s pode ser definido dentro de um mdulo ou escopo de classe',
        typeAliasRedeclared: '"{name}"  declarado como um TypeAlias e s pode ser atribudo uma vez',
        typeAliasStatementBadScope: 'Uma instruo type s pode ser usada dentro de um mdulo ou escopo de classe',
        typeAliasStatementIllegal: 'A instruo de alias de tipo requer o Python 3.12 ou mais recente',
        typeAliasTypeBaseClass: 'Um alias de tipo definido em uma instruo "type" no pode ser usado como uma classe base',
        typeAliasTypeMustBeAssigned: 'TypeAliasType deve ser atribudo a uma varivel com o mesmo nome que o alias de tipo',
        typeAliasTypeNameArg: 'O primeiro argumento para TypeAliasType deve ser um literal de cadeia de caracteres que representa o nome do alias de tipo',
        typeAliasTypeNameMismatch: 'O nome do alias de tipo deve corresponder ao nome da varivel  qual ela est atribuda',
        typeAliasTypeParamInvalid: 'A lista de parmetros de tipo deve ser uma tuple contendo apenas TypeVar, TypeVarTuple ou ParamSpec',
        typeAnnotationCall: 'Expresso de chamada no permitida na expresso de tipo',
        typeAnnotationVariable: 'Varivel no permitida na expresso de tipo',
        typeAnnotationWithCallable: 'O argumento de tipo para "type" deve ser uma classe; no h suporte para callables',
        typeArgListExpected: 'ParamSpec, reticncias ou lista de tipos esperados',
        typeArgListNotAllowed: 'Expresso de lista no permitida para este argumento de tipo',
        typeArgsExpectingNone: 'Nenhum argumento de tipo era esperado para a classe "{name}"',
        typeArgsMismatchOne: 'Esperava-se um argumento de tipo, mas recebeu {received}',
        typeArgsMissingForAlias: 'Argumentos de tipo esperados para o alias de tipo genrico "{name}"',
        typeArgsMissingForClass: 'Argumentos de tipo esperados para a classe genrica "{name}"',
        typeArgsTooFew: 'Poucos argumentos de tipo fornecidos para "{name}". Esperava-se {expected}, mas recebeu {received}',
        typeArgsTooMany: 'Muitos argumentos de tipo fornecidos para "{name}". Esperava-se {expected}, mas recebeu {received}',
        typeAssignmentMismatch: 'O tipo "{sourceType}" no pode ser atribudo ao tipo declarado "{destType}"',
        typeAssignmentMismatchWildcard: 'O smbolo de importao "{name}" tem o tipo "{sourceType}", que no pode ser atribudo ao tipo declarado "{destType}"',
        typeCallNotAllowed: 'A chamada type() no deve ser usada na expresso de tipo',
        typeCheckOnly: '"{name}" est marcado como @type_check_only e pode ser usado apenas em anotaes de tipo',
        typeCommentDeprecated: 'O uso de comentrios de type foi preterido. Use anotao de type em vez disso',
        typeExpectedClass: 'Classe esperada, mas a recebida foi "{type}"',
        typeFormArgs: '"TypeForm" aceita um nico argumento posicional',
        typeGuardArgCount: 'Argumento de tipo nico esperado aps "TypeGuard" ou "TypeIs"',
        typeGuardParamCount: 'Funes e mtodos de proteo de tipo definidos pelo usurio devem ter pelo menos um parmetro de entrada',
        typeIsReturnType: 'O tipo de retorno de TypeIs ("{returnType}") no  consistente com o tipo de parmetro de valor ("{type}")',
        typeNotAwaitable: '"{type}" no  awaitable',
        typeNotIntantiable: '"{type}" no pode ser instanciado',
        typeNotIterable: '"{type}" no  itervel',
        typeNotSpecializable: 'No foi possvel especializar o tipo "{type}"',
        typeNotSubscriptable: 'O objeto do tipo "{type}" no  subscrito',
        typeNotSupportBinaryOperator: 'Operador "{operator}" sem suporte para os tipos "{leftType}" e "{rightType}"',
        typeNotSupportBinaryOperatorBidirectional: 'O operador "{operator}" no tem suporte para os tipos "{leftType}" e "{rightType}" quando o tipo esperado  "{expectedType}"',
        typeNotSupportUnaryOperator: 'Operador "{operator}" sem suporte para o tipo "{type}"',
        typeNotSupportUnaryOperatorBidirectional: 'O operador "{operator}" no tem suporte para o tipo "{type}" quando o tipo esperado  "{expectedType}"',
        typeNotUsableWith: 'O objeto do tipo "{type}" no pode ser usado com "with" porque no implementa {method}',
        typeParameterBoundNotAllowed: 'Associao ou restrio no pode ser usada com um parmetro de tipo variadic ou ParamSpec',
        typeParameterConstraintTuple: 'A restrio de parmetro de tipo deve ser uma tupla de dois ou mais tipos',
        typeParameterExistingTypeParameter: 'O parmetro de tipo "{name}" j est em uso',
        typeParameterNotDeclared: 'O parmetro de tipo "{name}" no est includo na lista de parmetros de tipo para "{container}"',
        typeParametersMissing: 'Pelo menos um parmetro de tipo deve ser especificado',
        typePartiallyUnknown: 'O tipo de "{name}"  parcialmente desconhecido',
        typeUnknown: 'O tipo de "{name}"  desconhecido',
        typeVarAssignedName: 'TypeVar deve ser atribudo a uma varivel chamada "{name}"',
        typeVarAssignmentMismatch: 'O tipo "{type}" no pode ser atribudo  varivel de tipo "{name}"',
        typeVarBoundAndConstrained: 'TypeVar no pode ser associado e restrito',
        typeVarBoundGeneric: 'O tipo associado TypeVar no pode ser genrico',
        typeVarConstraintGeneric: 'O tipo de restrio TypeVar no pode ser genrico',
        typeVarDefaultBoundMismatch: 'O tipo padro TypeVar deve ser um subtipo do tipo associado',
        typeVarDefaultConstraintMismatch: 'O tipo padro TypeVar deve ser um dos tipos restritos',
        typeVarDefaultIllegal: 'Tipos padro de varivel de tipo exigem Python 3.13 ou mais recente',
        typeVarDefaultInvalidTypeVar: 'O parmetro de tipo "{name}" tem um tipo padro que se refere a uma ou mais variveis de tipo que esto fora do escopo',
        typeVarFirstArg: 'Nome esperado de TypeVar como primeiro argumento',
        typeVarInvalidForMemberVariable: 'O tipo de atributo no pode usar a varivel de tipo "{name}" com escopo para omtodo local',
        typeVarNoMember: 'TypeVar "{type}" no tem atributo "{name}"',
        typeVarNotSubscriptable: 'No  possvel subscrever TypeVar "{type}"',
        typeVarNotUsedByOuterScope: 'A varivel de tipo "{name}" no tem significado neste contexto',
        typeVarPossiblyUnsolvable: 'A varivel de tipo "{name}" pode ficar sem resoluo se o chamador no fornecer nenhum argumento para o parmetro "{param}"',
        typeVarSingleConstraint: 'TypeVar deve ter pelo menos dois tipos restritos',
        typeVarTupleConstraints: 'TypeVarTuple no pode ter restries de valor',
        typeVarTupleContext: 'TypeVarTuple no  permitido neste contexto',
        typeVarTupleDefaultNotUnpacked: 'O tipo padro TypeVarTuple deve ser uma tuple desempacotamento ou TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'O operador Unpack  necessrio para o valor TypeVarTuple',
        typeVarTupleUnknownParam: '"{name}"  um parmetro desconhecido para TypeVarTuple',
        typeVarUnknownParam: '"{name}"  um parmetro desconhecido para TypeVar',
        typeVarUsedByOuterScope: 'TypeVar "{name}" j est em uso por um escopo externo',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" aparece apenas uma vez na assinatura de funo genrica',
        typeVarVariance: 'TypeVar no pode ser covariante e contravariante',
        typeVarWithDefaultFollowsVariadic: 'O TypeVar "{typeVarName}" tem um valor padro e no pode seguir TypeVarTuple "{variadicName}"',
        typeVarWithoutDefault: '"{name}" no pode aparecer aps "{other}" na lista de parmetros de tipo porque no tem nenhum tipo padro',
        typeVarsNotInGenericOrProtocol: 'Generic[] ou Protocol[] deve incluir todas as variveis de tipo',
        typedDictAccess: 'No foi possvel acessar o item em TypedDict',
        typedDictAssignedName: 'TypedDict deve ser atribudo a uma varivel chamada "{name}"',
        typedDictBadVar: 'As classes TypedDict podem conter apenas anotaes de tipo',
        typedDictBaseClass: 'Todas as classes base para classes TypedDict tambm devem ser classes TypedDict',
        typedDictBoolParam: 'Esperava-se que o parmetro "{name}" tivesse um valor True ou False',
        typedDictClosedExtras: 'A classe base "{name}"  um TypedDict closed; itens extras devem ser do tipo "{type}"',
        typedDictClosedNoExtras: 'A classe base "{name}"  um TypedDict closed; itens extras no so permitidos',
        typedDictDelete: 'No foi possvel excluir o item em TypedDict',
        typedDictEmptyName: 'Os nomes dentro de um TypedDict no podem estar vazios',
        typedDictEntryName: 'Literal de cadeia de caracteres esperado para o nome da entrada do dicionrio',
        typedDictEntryUnique: 'Os nomes dentro de um dicionrio devem ser exclusivos',
        typedDictExtraArgs: 'Argumentos TypedDict extras so incompatveis',
        typedDictExtraItemsClosed: 'Um TypedDict no pode ser closed seder suporte a itens extras',
        typedDictFieldNotRequiredRedefinition: 'O item TypedDict "{name}" no pode ser redefinido como NotRequired',
        typedDictFieldReadOnlyRedefinition: 'O item TypedDict "{name}" no pode ser redefinido como ReadOnly',
        typedDictFieldRequiredRedefinition: 'O item TypedDict "{name}" no pode ser redefinido como Required',
        typedDictFirstArg: 'Nome da classe TypedDict esperado como primeiro argumento',
        typedDictInClassPattern: 'A classe TypedDict no  permitida no padro de classe',
        typedDictInitsubclassParameter: 'TypedDict no d suporte ao parmetro __init_subclass__ "{name}"',
        typedDictNotAllowed: '"TypedDict" no pode ser usado neste contexto',
        typedDictSecondArgDict: 'Parmetro dict ou de palavra-chave esperado como segundo parmetro',
        typedDictSecondArgDictEntry: 'Entrada de dicionrio simples esperada',
        typedDictSet: 'No foi possvel atribuir o item em TypedDict',
        unaccessedClass: 'A classe "{name}" no foi acessada',
        unaccessedFunction: 'A funo "{name}" no foi acessada',
        unaccessedImport: 'A importao "{name}" no foi acessada',
        unaccessedSymbol: '"{name}" no foi acessado',
        unaccessedVariable: 'A varivel "{name}" no foi acessada',
        unannotatedFunctionSkipped: 'A anlise da funo "{name}" foi ignorada porque no foi anotada',
        unaryOperationNotAllowed: 'Operador unrio no permitido na expresso de tipo',
        unexpectedAsyncToken: 'Esperado "def", "with" ou "for" para acompanhar "async"',
        unexpectedExprToken: 'Token inesperado no final da expresso',
        unexpectedIndent: 'Recuo inesperado',
        unexpectedUnindent: 'Recuo no esperado',
        unhashableDictKey: 'A chave do dicionrio deve ser hash',
        unhashableSetEntry: 'A entrada set deve ser permitir hash',
        uninitializedAbstractVariables: 'As variveis definidas na classe base abstrata no so inicializadas na classe final "{classType}"',
        uninitializedInstanceVariable: 'A varivel de instncia "{name}" no foi inicializada no corpo da classe ou no mtodo __init__',
        unionForwardReferenceNotAllowed: 'A sintaxe de Union no pode ser usada com operando de cadeia de caracteres. Use aspas em toda a expresso',
        unionSyntaxIllegal: 'A sintaxe alternativa para unies requer o Python 3.10 ou mais recente',
        unionTypeArgCount: 'A Union requer dois ou mais argumentos de tipo',
        unionUnpackedTuple: 'A Union no pode incluir uma tuple desempacotada',
        unionUnpackedTypeVarTuple: 'A Union no pode incluir um TypeVarTuple desempacotado',
        unnecessaryCast: 'Chamada "cast" desnecessria. O tipo j  "{type}"',
        unnecessaryIsInstanceAlways: 'Chamada de isinstance desnecessria. "{testType}"  sempre uma instncia de "{classType}"',
        unnecessaryIsInstanceNever: 'Chamada de isinstance desnecessria; \'{testType}\' nunca  uma instncia de \'{classType}\'',
        unnecessaryIsSubclassAlways: 'Chamada issubclass desnecessria. "{testType}"  sempre uma subclasse de "{classType}"',
        unnecessaryIsSubclassNever: 'Chamada issubclass desnecessria; \'{testType}\' nunca  uma subclasse de \'{classType}\'',
        unnecessaryPyrightIgnore: 'Comentrio desnecessrio "# pyright: ignore"',
        unnecessaryPyrightIgnoreRule: 'Regra desnecessria "# pyright: ignore": "{name}"',
        unnecessaryTypeIgnore: 'Comentrio "# type: ignore" desnecessrio',
        unpackArgCount: 'Argumento de tipo nico esperado aps "Unpack"',
        unpackExpectedTypeVarTuple: 'TypeVarTuple ou tuple esperado como argumento de tipo para Unpack',
        unpackExpectedTypedDict: 'Argumento de tipo TypedDict esperado para Unpack',
        unpackIllegalInComprehension: 'Operao de desempacotamento no permitida na compreenso',
        unpackInAnnotation: 'Operador de desempacotamento no permitido na expresso de tipo',
        unpackInDict: 'Operao de desempacotamento no permitida em dicionrios',
        unpackInSet: 'Operador unpack no permitido em um set',
        unpackNotAllowed: 'Unpack no  permitido neste contexto',
        unpackOperatorNotAllowed: 'A operao de descompactao no  permitida neste contexto',
        unpackTuplesIllegal: 'Operao de desempacotamento no permitida em tuplas anteriores ao Python 3.8',
        unpackedArgInTypeArgument: 'Os argumentos descompactados no podem ser usados nesse contexto',
        unpackedArgWithVariadicParam: 'O argumento desempacotado no pode ser usado para o parmetro TypeVarTuple',
        unpackedDictArgumentNotMapping: 'A expresso de argumento aps ** deve ser um mapeamento com um tipo de chave "str"',
        unpackedDictSubscriptIllegal: 'O operador de desempacotamento de dicionrio no subscrito no  permitido',
        unpackedSubscriptIllegal: 'O operador Unpack no subscrito requer o Python 3.11 ou mais recente',
        unpackedTypeVarTupleExpected: 'Esperava-se TypeVarTuple desempacotada. Use Unpack[{name1}] ou *{name2}',
        unpackedTypedDictArgument: 'No  possvel corresponder o argumento TypedDict desempacotado aos parmetros',
        unreachableCode: 'O cdigo est inacessvel.',
        unreachableCodeType: 'A anlise de tipo indica que o cdigo est inacessvel',
        unreachableExcept: 'A clusula Except est inacessvel porque a exceo j foi tratada',
        unsupportedDunderAllOperation: 'A operao em "__all__" no  compatvel, portanto, a lista de smbolos exportada pode estar incorreta',
        unusedCallResult: 'O resultado da expresso de chamada  do tipo "{type}" e no  usado. Atribua  varivel "_" se isso for intencional',
        unusedCoroutine: 'O resultado da chamada de funo async no foi usado. Use "await" ou atribua o resultado  varivel',
        unusedExpression: 'O valor da expresso no  usado',
        varAnnotationIllegal: 'As anotaes de tipo para variveis exigem Python 3.6 ou mais recente. Use comentrio de type para compatibilidade com verses anteriores',
        variableFinalOverride: 'A varivel "{name}" est marcada como Final e substitui a varivel no Final de mesmo nome na classe "{className}"',
        variadicTypeArgsTooMany: 'A lista de argumentos de tipo pode ter no mximo um TypeVarTuple ou tuple descompactado',
        variadicTypeParamTooManyAlias: 'O alias de tipo pode ter no mximo um parmetro de tipo TypeVarTuple, mas recebeu vrios ({names})',
        variadicTypeParamTooManyClass: 'A classe genrica pode ter no mximo um parmetro de tipo TypeVarTuple, mas recebeu vrios ({names})',
        walrusIllegal: 'O operador ":=" requer o Python 3.8 ou mais recente',
        walrusNotAllowed: 'Operador ":=" no  permitido neste contexto sem parnteses',
        wildcardInFunction: 'Wildcard import not allowed within a class or function',
        wildcardLibraryImport: 'Wildcard import from a library not allowed',
        wildcardPatternTypePartiallyUnknown: 'O tipo capturado pelo padro curinga  parcialmente desconhecido',
        wildcardPatternTypeUnknown: 'O tipo capturado pelo padro curinga  desconhecido',
        yieldFromIllegal: 'O uso de "yield from" requer o Python 3.3 ou mais recente',
        yieldFromOutsideAsync: '"yield from" no  permitido em uma funo async',
        yieldOutsideFunction: '"yield" no permitido fora de uma funo ou lambda',
        yieldWithinComprehension: '"yield" no  permitido dentro de uma compreenso',
        zeroCaseStatementsFound: 'A instruo Match deve incluir pelo menos uma instruo case',
        zeroLengthTupleNotAllowed: 'Zero-length tuple is not allowed in this context'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'O formulrio especial "Annotated" no pode ser usado com verificaes de instncia e classe',
        argParam: 'O argumento corresponde ao parmetro "{paramName}"',
        argParamFunction: 'O argumento corresponde ao parmetro "{paramName}" na funo "{functionName}"',
        argsParamMissing: 'O parmetro "*{paramName}" no tem nenhum parmetro correspondente',
        argsPositionOnly: 'Incompatibilidade de parmetro somente de posio; esperava-se {expected}, mas recebeu {received}',
        argumentType: 'O tipo de argumento  "{type}"',
        argumentTypes: 'Tipos de argumento: ({types})',
        assignToNone: 'O tipo no pode ser atribudo a "None"',
        asyncHelp: 'Voc quis dizer "async with"?',
        baseClassIncompatible: 'A classe base "{baseClass}"  incompatvel com o tipo "{type}"',
        baseClassIncompatibleSubclass: 'A classe base "{baseClass}" deriva de "{subclass}" que  incompatvel com o tipo "{type}"',
        baseClassOverriddenType: 'A classe base "{baseClass}" fornece o tipo "{type}", que  substitudo',
        baseClassOverridesType: 'A classe base "{baseClass}" substitui pelo tipo "{type}"',
        bytesTypePromotions: 'Defina disableBytesTypePromotions como false para habilitar o comportamento de promoo de tipo para "bytearray" e "memoryview"',
        conditionalRequiresBool: 'O mtodo __bool__ para o tipo "{operandType}" retorna o tipo "{boolReturnType}" em vez de "bool"',
        dataClassFieldLocation: 'Declarao de campo',
        dataClassFrozen: '"{name}" est congelado',
        dataProtocolUnsupported: '"{name}"  um protocolo de dados',
        descriptorAccessBindingFailed: 'Falha ao associar o mtodo "{name}" para a classe de descritor "{className}"',
        descriptorAccessCallFailed: 'Falha ao chamar o mtodo "{name}" para a classe de descritor "{className}"',
        finalMethod: 'Mtodo Final',
        functionParamDefaultMissing: 'O parmetro "{name}" no tem um argumento padro',
        functionParamName: 'Incompatibilidade de nome de parmetro: "{destName}" versus "{srcName}"',
        functionParamPositionOnly: 'Incompatibilidade de parmetro somente posio; o parmetro "{name}" no  somente posio',
        functionReturnTypeMismatch: 'O tipo de retorno de funo "{sourceType}"  incompatvel com o tipo "{destType}"',
        functionTooFewParams: 'A funo aceita poucos parmetros posicionais. Esperava-se {expected}, mas recebeu {received}',
        functionTooManyParams: 'A funo aceita muitos parmetros posicionais. Esperava-se {expected}, mas recebeu {received}',
        genericClassNotAllowed: 'Tipo genrico com argumentos de tipo no permitidos para verificaes de instncia ou de classe',
        incompatibleDeleter: 'O mtodo de deleter de property  incompatvel',
        incompatibleGetter: 'O mtodo getter de property  incompatvel',
        incompatibleSetter: 'O mtodo setter de property  incompatvel',
        initMethodLocation: 'O mtodo __init__  definido na classe "{type}"',
        initMethodSignature: 'A assinatura de __init__  "{type}"',
        initSubclassLocation: 'O mtodo __init_subclass__  definido na classe "{name}"',
        invariantSuggestionDict: 'Considere alternar de "dict" para "Mapping", que  covariante no tipo de valor',
        invariantSuggestionList: 'Considere alternar de "list" para "Sequence", que  covariante',
        invariantSuggestionSet: 'Considere alternar de "set" para "Container", que  covariante',
        isinstanceClassNotSupported: '"{type}" no tem suporte para verificaes de instncia e classe',
        keyNotRequired: '"{name}" no  uma chave necessria em "{type}", portanto, o acesso pode resultar em exceo de runtime',
        keyReadOnly: '"{name}"  uma chave somente leitura em "{type}"',
        keyRequiredDeleted: '"{name}"  uma chave obrigatria e no pode ser excluda',
        keyUndefined: '"{name}" no  uma chave definida em "{type}"',
        kwargsParamMissing: 'O parmetro "**{paramName}" no tem nenhum parmetro correspondente',
        listAssignmentMismatch: 'O tipo "{type}"  incompatvel com a lista de destino',
        literalAssignmentMismatch: '"{sourceType}" no pode ser atribudo a o tipo"{destType}"',
        matchIsNotExhaustiveHint: 'Se no pretende usar a manipulao exaustiva, adicione "case _: pass"',
        matchIsNotExhaustiveType: 'Tipo sem tratamento: "{type}"',
        memberAssignment: 'A expresso do tipo "{type}" no pode ser atribuda ao atributo "{name}" da classe "{classType}"',
        memberIsAbstract: '"{type}.{name}" no est implementado',
        memberIsAbstractMore: 'e mais {count}...',
        memberIsClassVarInProtocol: '"{name}"  definido como um ClassVar no protocolo',
        memberIsInitVar: '"{name}"  um campo somente de init-only',
        memberIsInvariant: '"{name}"  invarivel porque  mutvel',
        memberIsNotClassVarInClass: '"{name}" deve ser definido como um ClassVar para ser compatvel com o protocolo',
        memberIsNotClassVarInProtocol: '"{name}" no est definido como um ClassVar no protocolo',
        memberIsNotReadOnlyInProtocol: '"{name}" no  somente leitura no protocolo',
        memberIsReadOnlyInProtocol: '"{name}"  somente leitura no protocolo',
        memberIsWritableInProtocol: '"{name}"  gravvel no protocolo',
        memberSetClassVar: 'O atributo "{name}" no pode ser atribudo por meio de uma instncia de classe porque  um ClassVar',
        memberTypeMismatch: '"{name}"  um tipo incompatvel',
        memberUnknown: 'O atributo "{name}"  desconhecido',
        metaclassConflict: 'A metaclasse "{metaclass1}" entra em conflito com "{metaclass2}"',
        missingDeleter: 'O mtodo de deleter de property est ausente',
        missingGetter: 'O mtodo getter da property est ausente',
        missingSetter: 'O mtodo setter da property est ausente',
        namedParamMissingInDest: 'Parmetroextra "{name}"',
        namedParamMissingInSource: 'Parmetrode palavra-chave ausente "{name}"',
        namedParamTypeMismatch: 'O parmetro de palavra-chave "{name}" do tipo "{sourceType}"  incompatvel com o tipo "{destType}"',
        namedTupleNotAllowed: 'NamedTuple no pode ser usado para verificaes de instncia ou de classe',
        newMethodLocation: 'O mtodo __new__  definido na classe "{type}"',
        newMethodSignature: 'A assinatura de__new__  "{type}"',
        newTypeClassNotAllowed: 'A classe criada com NewType no pode ser usada com verificaes de instncia e classe',
        noOverloadAssignable: 'Nenhuma funo sobrecarregada corresponde ao tipo "{type}"',
        noneNotAllowed: 'None no pode ser usado para verificaes de instncia ou de classe',
        orPatternMissingName: 'Nomes ausentes: {name}',
        overloadIndex: 'Sobrecarga {index}  a correspondncia mais prxima',
        overloadNotAssignable: 'Uma ou mais sobrecargas de "{name}" no podem ser atribudas',
        overloadSignature: 'A assinatura de sobrecarga  definida aqui',
        overriddenMethod: 'Mtodo substitudo',
        overriddenSymbol: 'Smbolo substitudo',
        overrideInvariantMismatch: 'O tipo da substituio "{overrideType}" no  o mesmo do tipo bsico "{baseType}"',
        overrideIsInvariant: 'A varivel  mutvel, ento seu tipo  invarivel',
        overrideNoOverloadMatches: 'Nenhuma assinatura de sobrecarga na substituio  compatvel com o mtodo base',
        overrideNotClassMethod: 'O mtodo base  declarado como um classmethod, mas a substituio no ',
        overrideNotInstanceMethod: 'O mtodo base  declarado como um mtodo de instncia, mas a substituio no ',
        overrideNotStaticMethod: 'O mtodo base  declarado como staticmethod, mas a substituio no ',
        overrideOverloadNoMatch: 'Override no lida com todas as sobrecargas do mtodo base',
        overrideOverloadOrder: 'As sobrecargas para o mtodo de substituio devem estar na mesma ordem que o mtodo base',
        overrideParamKeywordNoDefault: 'Incompatibilidade de parmetro de palavra-chave "{name}": o parmetro base tem valor de argumento padro, o parmetro de substituio no',
        overrideParamKeywordType: 'Incompatibilidade de tipo de parmetro de palavra-chave "{name}": o parmetro base  do tipo "{baseType}", o parmetro de substituio  do tipo "{overrideType}"',
        overrideParamName: 'Incompatibilidade de nome de parmetro {index}: o parmetro base  denominado "{baseName}", o parmetro de substituio  denomidado "{overrideName}"',
        overrideParamNameExtra: 'O parmetro "{name}" est ausente na base',
        overrideParamNameMissing: 'O parmetro "{name}" est ausente na substituio',
        overrideParamNamePositionOnly: 'Incompatibilidade de parmetro {index}: o parmetro base "{baseName}"  o parmetro de palavra-chave, o parmetro de substituio  somente posio',
        overrideParamNoDefault: 'Parmetro {index} incompatvel: o parmetro base tem valor de argumento padro, o parmetro de substituio no',
        overrideParamType: 'Incompatibilidade de tipo de parmetro {index}: o parmetro base  do tipo "{baseType}", o parmetro de substituio  do tipo "{overrideType}"',
        overridePositionalParamCount: 'Incompatibilidade de contagem de parmetros posicionais. O mtodo base tem {baseCount}, mas a substituio tem {overrideCount}',
        overrideReturnType: 'Incompatibilidade de tipo de retorno: o mtodo base retorna o tipo "{baseType}", a substituio retorna o tipo "{overrideType}"',
        overrideType: 'A classe base define o tipo como "{type}"',
        paramAssignment: 'Parmetro {index}: o tipo "{sourceType}"  incompatvel com o tipo "{destType}"',
        paramSpecMissingInOverride: 'Os parmetros ParamSpec esto ausentes no mtodo de substituio',
        paramType: 'O tipo de parmetro  "{paramType}"',
        privateImportFromPyTypedSource: 'Em vez disso, importe de "{module}"',
        propertyAccessFromProtocolClass: 'Uma propriedade definida dentro de uma classe de protocolo no pode ser acessada como uma varivel de classe',
        propertyMethodIncompatible: 'O mtodo de property "{name}"  incompatvel',
        propertyMethodMissing: 'O mtodo de property "{name}" est ausente na substituio',
        propertyMissingDeleter: 'A property "{name}" no tem nenhum deleter definido',
        propertyMissingSetter: 'A property "{name}" no tem um setter definido',
        protocolIncompatible: '"{sourceType}"  incompatvel com o protocolo "{destType}"',
        protocolMemberMissing: '"{name}" no est presente',
        protocolRequiresRuntimeCheckable: 'A classe do Protocol deve ser @runtime_checkable para ser usada com verificaes de instncia e de classe',
        protocolSourceIsNotConcrete: '"{sourceType}" no  um tipo de classe concreta e no pode ser atribudo ao tipo "{destType}"',
        protocolUnsafeOverlap: 'Os atributos de "{name}" tm os mesmos nomes que o protocolo',
        pyrightCommentIgnoreTip: 'Use "# pyright: ignore[<diagnostic rules>]" para suprimir o diagnstico de uma nica linha',
        readOnlyAttribute: 'O atributo "{name}"  somente leitura',
        seeClassDeclaration: 'Consulte a declarao de classe',
        seeDeclaration: 'Consulte a declarao',
        seeFunctionDeclaration: 'Ver declarao de funo',
        seeMethodDeclaration: 'Consulte a declarao de mtodo',
        seeParameterDeclaration: 'Consulte a declarao de parmetro',
        seeTypeAliasDeclaration: 'Ver declarao de alias de tipo',
        seeVariableDeclaration: 'Consulte a declarao de varivel',
        tupleAssignmentMismatch: 'O tipo "{type}"  incompatvel com a tuple de destino',
        tupleEntryTypeMismatch: 'A entrada de tuple {entry}  do tipo incorreto',
        tupleSizeIndeterminateSrc: 'Incompatibilidade de tamanho de tuple; esperado {expected} mas recebido indeterminado',
        tupleSizeIndeterminateSrcDest: 'Incompatibilidade de tamanho de tuple; {expected} ou mais esperado, mas indeterminado recebido',
        tupleSizeMismatch: 'Incompatibilidade de tamanho de tuple; esperado {expected} mas recebido {received}',
        tupleSizeMismatchIndeterminateDest: 'Incompatibilidade de tamanho de tuple; {expected} ou mais esperado, mas {received} recebido',
        typeAliasInstanceCheck: 'O alias de tipo criado com a instruo "type" no pode ser usado com verificaes de instncia e de classe',
        typeAssignmentMismatch: '"{sourceType}" no pode ser atribudo ao tipo"{destType}"',
        typeBound: 'O tipo "{sourceType}" no pode ser atribudo ao limite superior "{destType}" na varivel do tipo "{name}"',
        typeConstrainedTypeVar: 'O tipo "{type}" no pode ser atribudo  varivel do tipo restrita "{name}"',
        typeIncompatible: '"{sourceType}" no pode ser atribudo a "{destType}"',
        typeNotClass: '"{type}" no  uma classe.',
        typeNotStringLiteral: '"{type}" no  um literal de cadeia de caracteres',
        typeOfSymbol: 'O tipo de "{name}"  "{type}"',
        typeParamSpec: 'O tipo "{type}"  incompatvel com ParamSpec "{name}"',
        typeUnsupported: 'O tipo "{type}"  incompatvel',
        typeVarDefaultOutOfScope: 'A varivel de tipo "{name}" no est no escopo',
        typeVarIsContravariant: 'O parmetro de tipo "{name}"  contravariante, mas "{sourceType}" no  um supertipo de "{destType}"',
        typeVarIsCovariant: 'O parmetro de tipo "{name}"  covariante, mas "{sourceType}" no  um subtipo de "{destType}"',
        typeVarIsInvariant: 'O parmetro de tipo "{name}"  invarivel, mas "{sourceType}" no  o mesmo que "{destType}"',
        typeVarNotAllowed: 'TypeVar no permitido para verificaes de instncia ou de classe',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple no pode ser associado a uma tuple de comprimento desconhecido',
        typeVarUnnecessarySuggestion: 'Use {type} em vez disso',
        typeVarUnsolvableRemedy: 'Fornea uma sobrecarga que especifica o tipo de retorno quando o argumento no  fornecido',
        typeVarsMissing: 'Variveis de tipo ausentes: {names}',
        typedDictBaseClass: 'A classe "{type}" no  um TypedDict',
        typedDictClassNotAllowed: 'A classe TypedDict no  permitida para verificaes de instncia ou classe',
        typedDictClosedExtraNotAllowed: 'No  possvel adicionar o item "{name}"',
        typedDictClosedExtraTypeMismatch: 'No  possvel adicionar o item "{name}" com o tipo "{type}"',
        typedDictClosedFieldNotRequired: 'No  possvel adicionar o item "{name}" porque ele deve ser NotRequired',
        typedDictExtraFieldNotAllowed: '"{name}" no est presente em "{type}"',
        typedDictExtraFieldTypeMismatch: 'Tipo de "{name}"  incompatvel com tipo de "extra_items" em "{type}"',
        typedDictFieldMissing: '"{name}" est ausente de "{type}"',
        typedDictFieldNotReadOnly: '"{name}" no  somente leitura em "{type}"',
        typedDictFieldNotRequired: '"{name}" no  obrigatrio em "{type}"',
        typedDictFieldRequired: '"{name}"  necessrio em "{type}"',
        typedDictFieldTypeMismatch: 'O tipo "{type}" no  atribuvel ao item "{name}"',
        typedDictFieldUndefined: '"{name}"  um item indefinido no tipo "{type}"',
        typedDictFinalMismatch: '"{sourceType}"  incompatvel com "{destType}" devido a uma @final incompatvel',
        typedDictKeyAccess: 'Usar ["{name}"] para fazer referncia ao item em TypedDict',
        typedDictNotAllowed: 'TypedDict no pode ser usado para verificaes de instncia ou de classe',
        unhashableType: 'O tipo "{type}" no  pode fazer hash',
        uninitializedAbstractVariable: 'A varivel de instncia "{name}" est definida na classe base abstrata "{classType}", mas no foi inicializada',
        unreachableExcept: '"{exceptionType}"  uma subclasse de "{parentType}"',
        useDictInstead: 'Use Dict[T1, T2] para indicar um tipo de dicionrio',
        useListInstead: 'Use List[T] para indicar um tipo de lista ou Union[T1, T2] para indicar um tipo de union',
        useTupleInstead: 'Use tuple[T1, ..., Tn] para indicar um tipo de tuple ou Union[T1, T2] para indicar um tipo de union',
        useTypeInstead: 'Use Type[T] em vez disso',
        varianceMismatchForClass: 'A variao do argumento de tipo "{typeVarName}"  incompatvel com a classe base "{className}"',
        varianceMismatchForTypeAlias: 'A variao do argumento de tipo "{typeVarName}"  incompatvel com "{typeAliasParam}"'
      },
      Service: {
        longOperation: 'A enumerao de arquivos de origem do espao de trabalho est demorando muito. Em vez disso, considere abrir uma subpasta. [Saiba mais](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  12957: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: '[4i3uH][rt Tp Stub]',
        createTypeStubFor: '[oXYb0][rt Tp Stub Fr "{mlm}"]',
        executingCommand: '[AxS1Z][xtg mm]',
        filesToAnalyzeCount: '[94Ml3][{t} fls t lz]',
        filesToAnalyzeOne: '[2zuMu][1 fl t lz]',
        findingReferences: '[0UmwS][Fg rfrs]',
        organizeImports: '[KhOyl][rgz mprts]',
        renameShadowedFile: '[E02Ab][Rm "{lFl}" t "{wFl}"]'
      },
      Completion: {
        autoImportDetail: '[WdNQG][t-mprt]',
        indexValueDetail: '[mX94Q][x vl]'
      },
      Diagnostic: {
        abstractMethodInvocation: '[fE8MD][Mth "{mth}" t  ll s t s strt  mplmt]',
        annotatedMetadataInconsistent: '[iOP70][tt mtt tp "{mttTp}" s t mptl wth tp "{tp}"]',
        annotatedParamCountMismatch: '[VZvZc][Prmtr tt t msmth: xpt {xpt} t rv {rv}]',
        annotatedTypeArgMissing: '[mTgtG][xpt  tp rgmt   r mr tts fr "Annotated"]',
        annotationBytesString: '[W1g86][Tp xprsss t s ts strg ltrls]',
        annotationFormatString: '[zaI8H][Tp xprsss t s frmt strg ltrls (f-strgs)]',
        annotationNotSupported: '[xYlM8][Tp tt t spprt fr ths sttmt]',
        annotationRawString: '[WOMum][Tp xprsss t s rw strg ltrls]',
        annotationSpansStrings: '[6Gg9x][Tp xprsss t sp mltpl strg ltrls]',
        annotationStringEscape: '[MQdsm][Tp xprsss t t sp hrtrs]',
        argAssignment: '[7pdVt][rgmt f tp "{rgTp}" t  ssg t prmtr f tp "{prmTp}"]',
        argAssignmentFunction: '[J08ms][rgmt f tp "{rgTp}" t  ssg t prmtr f tp "{prmTp}"  ft "{ftm}"]',
        argAssignmentParam: '[hEBRl][rgmt f tp "{rgTp}" t  ssg t prmtr "{prmm}" f tp "{prmTp}"]',
        argAssignmentParamFunction: '[0sIuD][rgmt f tp "{rgTp}" t  ssg t prmtr "{prmm}" f tp "{prmTp}"  ft "{ftm}"]',
        argMissingForParam: '[1oqiG][rgmt mssg fr prmtr {m}]',
        argMissingForParams: '[iAF8C][rgmts mssg fr prmtrs {ms}]',
        argMorePositionalExpectedCount: '[q3jgC][xpt {xpt} mr pstl rgmts]',
        argMorePositionalExpectedOne: '[DNcCo][xpt 1 mr pstl rgmt]',
        argPositional: '[XBHa9][xpt pstl rgmt]',
        argPositionalExpectedCount: '[F5Y6t][xpt {xpt} pstl rgmts]',
        argPositionalExpectedOne: '[XW4kV][xpt 1 pstl rgmt]',
        argTypePartiallyUnknown: '[Y02o3][rgmt tp s prtll kw]',
        argTypeUnknown: '[l0ccD][rgmt tp s kw]',
        assertAlwaysTrue: '[5Weld][ssrt xprss lws vlts t true]',
        assertTypeArgs: '[QHRQ7]["assert_type" xpts tw pstl rgmts]',
        assertTypeTypeMismatch: '[fc1Kk]["assert_type" msmth: xpt "{xpt}" t rv "{rv}"]',
        assignmentExprComprehension: '[F5OTr][ssgmt xprss trgt "{m}" t s sm m s mprhs fr trgt]',
        assignmentExprContext: '[U4d41][ssgmt xprss mst  wth ml, ft r lm]',
        assignmentExprInSubscript: '[mnJzw][ssgmt xprsss wth  ssrpt r spprt l  Pth 3.10  wr]',
        assignmentInProtocol: '[vey5h][st r lss vrls wth  Protocol lss mst  xpltl lr wth th lss ]',
        assignmentTargetExpr: '[22xbu][xprss t  ssgmt trgt]',
        asyncNotInAsyncFunction: '[u0Y7U][s f "async" t llw ts f async ft]',
        awaitIllegal: '[2Wa68][s f "await" rqrs Pth 3.5 r wr]',
        awaitNotAllowed: '[TpX77][Tp xprsss t s "await"]',
        awaitNotInAsync: '[qau2Q]["await" llw l wth async ft]',
        backticksIllegal: '[V1LZI][xprsss srr  ktks r t spprt  Pth 3.x; s repr st]',
        baseClassCircular: '[frqWt][lss t rv frm tslf]',
        baseClassFinal: '[C9i92][s lss "{tp}" s mrk final  t  slss]',
        baseClassIncompatible: '[K3wZ2][s lsss f {tp} r mtll mptl]',
        baseClassInvalid: '[qULQr][rgmt t lss mst   s lss]',
        baseClassMethodTypeIncompatible: '[2lM0z][s lsss fr lss "{lssTp}" f mth "{m}"  mptl w]',
        baseClassUnknown: '[QQxIX][s lss tp s kw, srg tp f rv lss]',
        baseClassVariableTypeIncompatible: '[YmxlD][s lsss fr lss "{lssTp}" f vrl "{m}"  mptl w]',
        binaryOperationNotAllowed: '[1lzlz][r prtr t llw  tp xprss]',
        bindTypeMismatch: '[x4sbf][l t  mth "{mthm}" s "{tp}" s t ssgl t prmtr "{prmm}"]',
        breakInExceptionGroup: '[Kwoku]["break" s t llw   "except*" lk]',
        breakOutsideLoop: '[Ca4Ip]["break"   s l wth  lp]',
        callableExtraArgs: '[M3UIb][xpt l tw tp rgmts t "Callable"]',
        callableFirstArg: '[W1wTU][xpt prmtr tp lst r "..."]',
        callableNotInstantiable: '[sJ0Q8][t sttt tp "{tp}"]',
        callableSecondArg: '[9c1cS][xpt rtr tp s s tp rgmt fr "Callable"]',
        casePatternIsIrrefutable: '[NR6tj][rrftl pttr s llw l fr th lst s sttmt]',
        classAlreadySpecialized: '[Puetc][Tp "{tp}" s lr splz]',
        classDecoratorTypeUnknown: '[FhL8V][tp lss rtr srs tp f lss; grg rtr]',
        classDefinitionCycle: '[21Tlp][lss ft fr "{m}" ps  tslf]',
        classGetItemClsParam: '[A2iHF][__class_getitem__ vrr shl tk  "cls" prmtr]',
        classMethodClsParam: '[aWMN3][lss mths shl tk  "cls" prmtr]',
        classNotRuntimeSubscriptable: '[O9BL6][srpt fr lss "{m}" wll grt rtm xpt; ls tp xprss  qts]',
        classPatternBuiltInArgPositional: '[DOfs5][lss pttr pts l pstl s-pttr]',
        classPatternPositionalArgCount: '[B65y5][T m pstl pttrs fr lss "{tp}"; xpt {xpt} t rv {rv}]',
        classPatternTypeAlias: '[AxDtv]["{tp}" t  s   lss pttr s t s  splz tp ls]',
        classPropertyDeprecated: '[Q6JgP][lss prprts r prt  Pth 3.11  wll t  spprt  Pth 3.13]',
        classTypeParametersIllegal: '[GybXD][lss tp prmtr stx rqrs Pth 3.12 r wr]',
        classVarFirstArgMissing: '[VtcEd][xpt  tp rgmt ftr "ClassVar"]',
        classVarNotAllowed: '[BU07G]["ClassVar" s t llw  ths txt]',
        classVarOverridesInstanceVar: '[UEaro][lss vrl "{m}" vrrs st vrl f sm m  lss "{lssm}"]',
        classVarTooManyArgs: '[Mj1R5][xpt l  tp rgmt ftr "ClassVar"]',
        classVarWithTypeVar: '[6mnjY]["ClassVar" tp t l tp vrls]',
        clsSelfParamTypeMismatch: '[MBrCQ][Tp f prmtr "{m}" mst   sprtp f ts lss "{lssTp}"]',
        codeTooComplexToAnalyze: '[FNQd7][ s t mplx t lz; r mplxt  rftrg t srts r rg tl  pths]',
        collectionAliasInstantiation: '[rZb8i][Tp "{tp}" t  sttt, s "{ls}" st]',
        comparisonAlwaysFalse: '[N16ve][t wll lws vlt t False s th tps "{lftTp}"  "{rghtTp}" hv  vrlp]',
        comparisonAlwaysTrue: '[0TOLo][t wll lws vlt t True s th tps "{lftTp}"  "{rghtTp}" hv  vrlp]',
        comprehensionInDict: '[Orm2O][mprhs t  s wth thr tr trs]',
        comprehensionInSet: '[YUnu9][mprhs t  s wth thr set trs]',
        concatenateContext: '[8tRy6]["Concatenate" s t llw  ths txt]',
        concatenateParamSpecMissing: '[3s1CV][st tp rgmt fr "Concatenate" mst   ParamSpec r "..."]',
        concatenateTypeArgsMissing: '[aH5g8]["Concatenate" rqrs t lst tw tp rgmts]',
        conditionalOperandInvalid: '[HnbrG][vl tl pr f tp "{tp}"]',
        constantRedefinition: '[oRKBh]["{m}" s stt (s t s pprs)  t  rf]',
        constructorParametersMismatch: '[WWloK][Msmth tw sgtr f __new__  __init__  lss "{lssTp}"]',
        containmentAlwaysFalse: '[e6PIv][xprss wll lws vlt t False s th tps "{lftTp}"  "{rghtTp}" hv  vrlp]',
        containmentAlwaysTrue: '[8OhUO][xprss wll lws vlt t True s th tps "{lftTp}"  "{rghtTp}" hv  vrlp]',
        continueInExceptionGroup: '[h1tNi]["continue" s t llw   "except*" lk]',
        continueOutsideLoop: '[6ACvd]["continue"   s l wth  lp]',
        coroutineInConditionalExpression: '[ygK2r][tl xprss rfrs rt whh lws vlts t True]',
        dataClassBaseClassFrozen: '[jjiw4][ -frz lss t hrt frm  lss tht s frz]',
        dataClassBaseClassNotFrozen: '[KOz4K][ frz lss t hrt frm  lss tht s t frz]',
        dataClassConverterFunction: '[FxD8r][rgmt f tp "{rgTp}" s t  vl vrtr fr fl "{flm}" f tp "{flTp}"]',
        dataClassConverterOverloads: '[ZJ0SE][ vrls f "{fm}" r vl vrtrs fr fl "{flm}" f tp "{flTp}"]',
        dataClassFieldInheritedDefault: '[BKxvn]["{flm}" vrrs  fl f th sm m t s mssg  flt vl]',
        dataClassFieldWithDefault: '[iJuju][Fls wtht flt vls t ppr ftr fls wth flt vls]',
        dataClassFieldWithPrivateName: '[miQYb][tlss fl t s prvt m]',
        dataClassFieldWithoutAnnotation: '[zq5t5][tlss fl wtht tp tt wll s rtm xpt]',
        dataClassPostInitParamCount: '[yl0Bg][tlss __post_init__ rrt prmtr t; mr f InitVar fls s {xpt}]',
        dataClassPostInitType: '[74TW4][tlss __post_init__ mth prmtr tp msmth fr fl "{flm}"]',
        dataClassSlotsOverwrite: '[D17er][__slots__ s lr f  lss]',
        dataClassTransformExpectedBoolLiteral: '[y2upJ][xpt xprss tht sttll vlts t True r False]',
        dataClassTransformFieldSpecifier: '[xE1Cp][xpt tuple f lsss r fts t rv tp "{tp}"]',
        dataClassTransformPositionalParam: '[Cu7w4][ll rgmts t "dataclass_transform" mst  kwr rgmts]',
        dataClassTransformUnknownArgument: '[hLQXL][rgmt "{m}" s t spprt  dataclass_transform]',
        dataProtocolInSubclassCheck: '[kIIkO][t prtls (whh l -mth ttrts) r t llw  issubclass lls]',
        declaredReturnTypePartiallyUnknown: '[pDeOu][lr rtr tp, "{rtrTp}", s prtll kw]',
        declaredReturnTypeUnknown: '[XRFJs][lr rtr tp s kw]',
        defaultValueContainsCall: '[G3smw][Ft lls  mtl jts t llw wth prmtr flt vl xprss]',
        defaultValueNotAllowed: '[SuRpb][Prmtr wth "*" r "**" t hv flt vl]',
        delTargetExpr: '[VLtXk][xprss t  lt]',
        deprecatedClass: '[DIyRn][Th lss "{m}" s prt]',
        deprecatedConstructor: '[jq4aQ][Th strtr fr lss "{m}" s prt]',
        deprecatedDescriptorDeleter: '[ljYHS][Th "__lt__" mth fr srptr "{m}" s prt]',
        deprecatedDescriptorGetter: '[06Y3N][Th "__gt__" mth  fr srptr "{m}" s prt]',
        deprecatedDescriptorSetter: '[6nQQu][Th "__st__" mth  fr srptr "{m}" s prt]',
        deprecatedFunction: '[GdF0l][Th ft "{m}" s prt]',
        deprecatedMethod: '[GxfND][Th mth "{m}"  lss "{lssm}" s prt]',
        deprecatedPropertyDeleter: '[BUlI2][Th deleter fr property "{m}" s prt]',
        deprecatedPropertyGetter: '[54BuI][Th getter fr property "{m}" s prt]',
        deprecatedPropertySetter: '[EHGoz][Th setter fr property "{m}" s prt]',
        deprecatedType: '[IWdSs][Ths tp s prt s f Pth {vrs}; s "{rplmt}" st]',
        dictExpandIllegalInComprehension: '[3B8LL][tr xps t llw  mprhs]',
        dictInAnnotation: '[0UcII][tr xprss t llw  tp xprss]',
        dictKeyValuePairs: '[Hnd6W][tr trs mst t k/vl prs]',
        dictUnpackIsNotMapping: '[RhO60][xpt mppg fr tr pk prtr]',
        dunderAllSymbolNotPresent: '[mlrcI]["{m}" s spf  __all__ t s t prst  ml]',
        duplicateArgsParam: '[bt3Os][l  "*" prmtr llw]',
        duplicateBaseClass: '[HIzyw][plt s lss t llw]',
        duplicateCapturePatternTarget: '[zq38Z][ptr trgt "{m}" t ppr mr th  wth th sm pttr]',
        duplicateCatchAll: '[6gO00][l  th-ll except ls llw]',
        duplicateEnumMember: '[k9W8A][Enum mmr "{m}" s lr lr]',
        duplicateGenericAndProtocolBase: '[4EO4W][l  Generic[...] r Protocol[...] s lss llw]',
        duplicateImport: '[qgZGm]["{mprtm}" s mprt mr th ]',
        duplicateKeywordOnly: '[pbf3W][l  "*" sprtr llw]',
        duplicateKwargsParam: '[4QsUE][l  "**" prmtr llw]',
        duplicateParam: '[s0XGf][plt prmtr "{m}"]',
        duplicatePositionOnly: '[9hzW4][l  "/" prmtr llw]',
        duplicateStarPattern: '[8quwQ][l  "*" pttr llw   pttr sq]',
        duplicateStarStarPattern: '[wScoI][l  "**" tr llw]',
        duplicateUnpack: '[wjeOP][l  pk prt llw  list]',
        ellipsisAfterUnpacked: '[4EsWH]["..." t  s wth  pk TypeVarTuple r tuple]',
        ellipsisContext: '[Y4jK3]["..." s t llw  ths txt]',
        ellipsisSecondArg: '[pvXJA]["..." s llw l s th s f tw rgmts]',
        enumClassOverride: '[2JsL1][Enum lss "{m}" s final  t  slss]',
        enumMemberDelete: '[5wmRY][Enum mmr "{m}" t  lt]',
        enumMemberSet: '[mBLro][Enum mmr "{m}" t  ssg]',
        enumMemberTypeAnnotation: '[z8FaL][Tp tts r t llw fr enum mmrs]',
        exceptGroupMismatch: '[XbzjN][Tr sttmt t l th "except"  "except*"]',
        exceptGroupRequiresType: '[740wj][xpt grp stx ("except*") rqrs  xpt tp]',
        exceptionGroupIncompatible: '[d0SLP][xpt grp stx ("except*") rqrs Pth 3.11 r wr]',
        exceptionGroupTypeIncorrect: '[Kanvz][xpt tp  except* t rv frm BaseGroupException]',
        exceptionTypeIncorrect: '[G7AZt]["{tp}" s t rv frm BaseException]',
        exceptionTypeNotClass: '[v1FmY]["{tp}" s t  vl xpt lss]',
        exceptionTypeNotInstantiable: '[PfdeG][strtr fr xpt tp "{tp}" rqrs  r mr rgmts]',
        expectedAfterDecorator: '[rzMVF][xpt ft r lss lrt ftr rtr]',
        expectedArrow: '[DrZKr][xpt "->" fllw  rtr tp tt]',
        expectedAsAfterException: '[FDdTe][xpt "as" ftr xpt tp]',
        expectedAssignRightHandExpr: '[mPzHP][xpt xprss t th rght f "="]',
        expectedBinaryRightHandExpr: '[MgqnF][xpt xprss t th rght f prtr]',
        expectedBoolLiteral: '[bhZAe][xpt True r False]',
        expectedCase: '[kQ1sa][xpt "case" sttmt]',
        expectedClassName: '[f0XRc][xpt lss m]',
        expectedCloseBrace: '[MQHKY]["{" ws t ls]',
        expectedCloseBracket: '[YfM0n]["[" ws t ls]',
        expectedCloseParen: '[tAuag]["(" ws t ls]',
        expectedColon: '[KmzHa][xpt ":"]',
        expectedComplexNumberLiteral: '[dc2rM][xpt mplx mr ltrl fr pttr mthg]',
        expectedDecoratorExpr: '[415JG][xprss frm t spprt fr rtr prr t Pth 3.9]',
        expectedDecoratorName: '[IKO4m][xpt rtr m]',
        expectedDecoratorNewline: '[Bsyx3][xpt w l t  f rtr]',
        expectedDelExpr: '[u8JgL][xpt xprss ftr "del"]',
        expectedElse: '[eROaU][xpt "else"]',
        expectedEquals: '[TXK4x][xpt "="]',
        expectedExceptionClass: '[sYtUr][vl xpt lss r jt]',
        expectedExceptionObj: '[w4tAQ][xpt xpt jt, xpt lss r None]',
        expectedExpr: '[iKSsw][xpt xprss]',
        expectedFunctionAfterAsync: '[fWBMb][xpt ft ft ftr "async"]',
        expectedFunctionName: '[cR036][xpt ft m ftr "def"]',
        expectedIdentifier: '[Lj4l5][xpt tfr]',
        expectedImport: '[FNK2F][xpt "import"]',
        expectedImportAlias: '[mb4fF][xpt sml ftr "as"]',
        expectedImportSymbols: '[QUZ7S][xpt  r mr sml ms ftr "import"]',
        expectedIn: '[9XkiC][xpt "in"]',
        expectedInExpr: '[RXryp][xpt xprss ftr "in"]',
        expectedIndentedBlock: '[7ZvJC][xpt t lk]',
        expectedMemberName: '[VvTAF][xpt ttrt m ftr "."]',
        expectedModuleName: '[Jky7g][xpt ml m]',
        expectedNameAfterAs: '[KnNbR][xpt sml m ftr "as"]',
        expectedNamedParameter: '[ZsE8l][Kwr prmtr mst fllw "*"]',
        expectedNewline: '[bW0cY][xpt wl]',
        expectedNewlineOrSemicolon: '[av2Gz][ttmts mst  sprt  wls r smls]',
        expectedOpenParen: '[CLuzo][xpt "("]',
        expectedParamName: '[b0il7][xpt prmtr m]',
        expectedPatternExpr: '[76AU4][xpt pttr xprss]',
        expectedPatternSubjectExpr: '[GUw9q][xpt pttr sjt xprss]',
        expectedPatternValue: '[Ah06c][xpt pttr vl xprss f th frm "a.b"]',
        expectedReturnExpr: '[nyeYf][xpt xprss ftr "return"]',
        expectedSliceIndex: '[0HjFA][xpt x r sl xprss]',
        expectedTypeNotString: '[FXeAr][xpt tp t rv  strg ltrl]',
        expectedTypeParameterName: '[aHX5Q][xpt tp prmtr m]',
        expectedYieldExpr: '[TrB0N][xpt xprss  yield sttmt]',
        finalClassIsAbstract: '[qEcDN][lss "{tp}" s mrk final  mst mplmt ll strt smls]',
        finalContext: '[KT2Ma]["Final" s t llw  ths txt]',
        finalInLoop: '[yUnYn][ "Final" vrl t  ssg wth  lp]',
        finalMethodOverride: '[rVyi2][Mth "{m}" t vrr final mth f  lss "{lssm}"]',
        finalNonMethod: '[ITFlU][Ft "{m}" t  mrk @final s t s t  mth]',
        finalReassigned: '[fgpqP]["{m}" s lr s Final  t  rssg]',
        finalRedeclaration: '[8jVSa]["{m}" ws prvsl lr s Final]',
        finalRedeclarationBySubclass: '[0VswQ]["{m}" t  rlr s prt lss "{lssm}" lrs t s Final]',
        finalTooManyArgs: '[9fleE][xpt  sgl tp rgmt ftr "Final"]',
        finalUnassigned: '[PmdtN]["{m}" s lr Final, t vl s t ssg]',
        formatStringBrace: '[j606J][gl ls r t llw wth f-strg ltrl; s l ls r]',
        formatStringBytes: '[1Xo44][Frmt strg ltrls (f-strgs) t  r]',
        formatStringDebuggingIllegal: '[mQueA][F-strg ggg spfr "=" rqrs Pth 3.8 r wr]',
        formatStringEscape: '[lcP3H][sp sq (kslsh) t llw  xprss prt f f-strg prr t Pth 3.12]',
        formatStringExpectedConversion: '[AjO2F][xpt  vrs spfr ftr "!"  f-strg]',
        formatStringIllegal: '[HhOeX][Frmt strg ltrls (f-strgs) rqr Pth 3.6 r wr]',
        formatStringInPattern: '[KqV2l][Frmt strg t llw  pttr]',
        formatStringNestedFormatSpecifier: '[OFqi6][xprsss st t pl wth frmt strg spfr]',
        formatStringNestedQuote: '[buq49][trgs st wth  f-strg t s th sm qt hrtr s th f-strg prr t Pth 3.12]',
        formatStringUnicode: '[RCCfD][Frmt strg ltrls (f-strgs) t  ]',
        formatStringUnterminated: '[PnOZr][trmt xprss  f-strg; xptg "}"]',
        functionDecoratorTypeUnknown: '[Gv66U][tp ft rtr srs tp f ft; grg rtr]',
        functionInConditionalExpression: '[9A68n][tl xprss rfrs ft whh lws vlts t True]',
        functionTypeParametersIllegal: '[0JM96][Ft tp prmtr stx rqrs Pth 3.12 r wr]',
        futureImportLocationNotAllowed: '[IdoQY][mprts frm __future__ mst  t th gg f th fl]',
        generatorAsyncReturnType: '[dYKl9][Rtr tp f async grtr ft mst  mptl wth "AsyncGenerator[{yieldType}, Any]"]',
        generatorNotParenthesized: '[WmWZM][Grtr xprsss mst  prthsz f t sl rgmt]',
        generatorSyncReturnType: '[ASD1z][Rtr tp f grtr ft mst  mptl wth "Generator[{yieldType}, Any, Any]"]',
        genericBaseClassNotAllowed: '[fniUT]["Generic" s lss t  s wth tp prmtr stx]',
        genericClassAssigned: '[iU1tH][Gr lss tp t  ssg]',
        genericClassDeleted: '[C942e][Gr lss tp t  lt]',
        genericInstanceVariableAccess: '[rpanq][ss t gr st vrl thrgh lss s mgs]',
        genericNotAllowed: '[vnF07]["Generic" s t vl  ths txt]',
        genericTypeAliasBoundTypeVar: '[S1NAS][Gr tp ls wth lss t s  tp vrls {ms}]',
        genericTypeArgMissing: '[OlCEv]["Generic" rqrs t lst  tp rgmt]',
        genericTypeArgTypeVar: '[09E7H][Tp rgmt fr "Generic" mst   tp vrl]',
        genericTypeArgUnique: '[xHwpY][Tp rgmts fr "Generic" mst  q]',
        globalReassignment: '[B2UyK]["{m}" s ssg fr global lrt]',
        globalRedefinition: '[UZSMp]["{m}" ws lr lr global]',
        implicitStringConcat: '[t0D1l][mplt strg tt t llw]',
        importCycleDetected: '[FFPSZ][l tt  mprt h]',
        importDepthExceeded: '[8G4s1][mprt h pth x {pth}]',
        importResolveFailure: '[oBYA4][mprt "{mprtm}" l t  rslv]',
        importSourceResolveFailure: '[hjHFa][mprt "{mprtm}" l t  rslv frm sr]',
        importSymbolUnknown: '[jY9ZH]["{m}" s kw mprt sml]',
        incompatibleMethodOverride: '[i45Ka][Mth "{m}" vrrs lss "{lssm}"   mptl mr]',
        inconsistentIndent: '[gdrcy][t mt s t mth prvs t]',
        inconsistentTabs: '[I3Z6K][sstt s f ts  sps  tt]',
        initMethodSelfParamTypeVar: '[S5RC7][Tp tt fr "self" prmtr f "__init__" mth t t lss-sp tp vrls]',
        initMustReturnNone: '[RlXyC][Rtr tp f "__init__" mst  None]',
        initSubclassCallFailed: '[w22Kh][rrt kwr rgmts fr __init_subclass__ mth]',
        initSubclassClsParam: '[6CWuS][__init_subclass__ vrr shl tk  "cls" prmtr]',
        initVarNotAllowed: '[Bb6V0]["InitVar" s t llw  ths txt]',
        instanceMethodSelfParam: '[dPZPj][st mths shl tk  "self" prmtr]',
        instanceVarOverridesClassVar: '[cfYeg][st vrl "{m}" vrrs lss vrl f sm m  lss "{lssm}"]',
        instantiateAbstract: '[IyeLb][t sttt strt lss "{tp}"]',
        instantiateProtocol: '[Xa6p2][t sttt Protocol lss "{tp}"]',
        internalBindError: '[PnkgK][ trl rrr rr whl g fl "{fl}": {mssg}]',
        internalParseError: '[T91nL][ trl rrr rr whl prsg fl "{fl}": {mssg}]',
        internalTypeCheckingError: '[9E5Bn][ trl rrr rr whl tp hkg fl "{fl}": {mssg}]',
        invalidIdentifierChar: '[Vpy5i][vl hrtr  tfr]',
        invalidStubStatement: '[sxuu1][ttmt s mglss wth  tp stub fl]',
        invalidTokenChars: '[n9Jty][vl hrtr "{txt}"  tk]',
        isInstanceInvalidType: '[Q3jK3][ rgmt t "isinstance" mst   lss r tuple f lsss]',
        isSubclassInvalidType: '[6Q7qf][ rgmt t "issubclass" mst   lss r tuple f lsss]',
        keyValueInSet: '[tmmyt][K/vl prs r t llw wth  set]',
        keywordArgInTypeArgument: '[BzcKx][Kwr rgmts t  s  tp rgmt lsts]',
        keywordArgShortcutIllegal: '[KU0tn][Kwr rgmt shrtt rqrs Pth 3.14 r wr]',
        keywordOnlyAfterArgs: '[RLvT4][Kwr-l rgmt sprtr t llw ftr "*" prmtr]',
        keywordParameterMissing: '[gTcAl][ r mr kwr prmtrs mst fllw "*" prmtr]',
        keywordSubscriptIllegal: '[khu47][Kwr rgmts wth ssrpts r t spprt]',
        lambdaReturnTypePartiallyUnknown: '[Z5ML1][Rtr tp f lm, "{rtrTp}", s prtll kw]',
        lambdaReturnTypeUnknown: '[h4icY][Rtr tp f lm s kw]',
        listAssignmentMismatch: '[DZh64][xprss wth tp "{tp}" t  ssg t trgt lst]',
        listInAnnotation: '[i5U8t][List xprss t llw  tp xprss]',
        literalEmptyArgs: '[VkrFm][xpt  r mr tp rgmts ftr "Literal"]',
        literalNamedUnicodeEscape: '[8cbe7][m  sp sqs r t spprt  "Literal" strg tts]',
        literalNotAllowed: '[FAk6E]["Literal" t  s  ths txt wtht  tp rgmt]',
        literalNotCallable: '[C75sx][Literal tp t  sttt]',
        literalUnsupportedType: '[10Yse][Tp rgmts fr "Literal" mst  None,  ltrl vl (int, bool, str, r bytes), r  enum vl]',
        matchIncompatible: '[9ljpM][Match sttmts rqr Pth 3.10 r wr]',
        matchIsNotExhaustive: '[BJ8EI][ss wth match sttmt  t xhstvl hl ll vls]',
        maxParseDepthExceeded: '[5nAZx][Mxmm prs pth x; rk xprss t smllr s-xprsss]',
        memberAccess: '[YP5V0][t ss ttrt "{m}" fr lss "{tp}"]',
        memberDelete: '[o47cn][t lt ttrt "{m}" fr lss "{tp}"]',
        memberSet: '[JCDqa][t ssg t ttrt "{m}" fr lss "{tp}"]',
        metaclassConflict: '[XgAJj][Th mtlss f  rv lss mst   slss f th mtlsss f ll ts s lsss]',
        metaclassDuplicate: '[wrGuH][l  mtlss   prv]',
        metaclassIsGeneric: '[K5fXC][Mtlss t  gr]',
        methodNotDefined: '[ZuPf7]["{m}" mth t f]',
        methodNotDefinedOnType: '[sEtO5]["{m}" mth t f  tp "{tp}"]',
        methodOrdering: '[0M0tn][t rt sstt mth rrg]',
        methodOverridden: '[2Bu15]["{m}" vrrs mth f sm m  lss "{lssm}" wth mptl tp "{tp}"]',
        methodReturnsNonObject: '[9nnVb]["{m}" mth s t rtr  jt]',
        missingSuperCall: '[jNXGA][Mth "{mthm}" s t ll th mth f th sm m  prt lss]',
        mixingBytesAndStr: '[Ng6gL][Bytes  str vls t  tt]',
        moduleAsType: '[p9N4B][Ml t  s s  tp]',
        moduleNotCallable: '[YY0Jq][Ml s t lll]',
        moduleUnknownMember: '[tegoa]["{mmrm}" s t  kw ttrt f ml "{mlm}"]',
        namedExceptAfterCatchAll: '[pMR1l][ m except ls t ppr ftr th-ll except ls]',
        namedParamAfterParamSpecArgs: '[sF38r][Kwr prmtr "{m}" t ppr  sgtr ftr ParamSpec args prmtr]',
        namedTupleEmptyName: '[vnXqF][ms wth  m tuple t  mpt]',
        namedTupleEntryRedeclared: '[0tiaC][t vrr "{m}" s prt lss "{lssm}" s  m tuple]',
        namedTupleFirstArg: '[L5ZXq][xpt m tuple lss m s frst rgmt]',
        namedTupleMultipleInheritance: '[KYJOA][Mltpl hrt wth NamedTuple s t spprt]',
        namedTupleNameKeyword: '[g6NTa][Fl ms t   kwr]',
        namedTupleNameType: '[AxfdS][xpt tw-tr tuple spfg tr m  tp]',
        namedTupleNameUnique: '[TQaej][ms wth  m tuple mst  q]',
        namedTupleNoTypes: '[Fn6FF]["mtpl" prvs  tps fr tpl trs; s "mTpl" st]',
        namedTupleSecondArg: '[SqoXY][xpt m tuple tr list s s rgmt]',
        newClsParam: '[EUESX][__new__ vrr shl tk  "cls" prmtr]',
        newTypeAnyOrUnknown: '[D4ZjA][Th s rgmt t NewType mst   kw lss, t Any r Unknown]',
        newTypeBadName: '[cqWvO][Th frst rgmt t NewType mst   strg ltrl]',
        newTypeLiteral: '[4k8om][NewType t  s wth Literal tp]',
        newTypeNameMismatch: '[kQgMv][NewType mst  ssg t  vrl wth th sm m]',
        newTypeNotAClass: '[ta6tZ][xpt lss s s rgmt t NewType]',
        newTypeParamCount: '[6b2ro][NewType rqrs tw pstl rgmts]',
        newTypeProtocolClass: '[1l02t][NewType t  s wth strtrl tp ( Protocol r TypedDict lss)]',
        noOverload: '[IcBNQ][ vrls fr "{m}" mth th prv rgmts]',
        noReturnContainsReturn: '[nBLDq][Ft wth lr return tp "NoReturn" t l  return sttmt]',
        noReturnContainsYield: '[V3G36][Ft wth lr rtr tp "NoReturn" t l  yield sttmt]',
        noReturnReturnsNone: '[O3XA6][Ft wth lr rtr tp "NoReturn" t rtr "None"]',
        nonDefaultAfterDefault: '[mFFgP][-flt rgmt fllws flt rgmt]',
        nonLocalInModule: '[kmLlv][Nonlocal lrt t llw t ml lvl]',
        nonLocalNoBinding: '[WTA2d][ g fr nonlocal "{m}" f]',
        nonLocalReassignment: '[T1M6J]["{m}" s ssg fr nonlocal lrt]',
        nonLocalRedefinition: '[gwh1h]["{m}" ws lr lr nonlocal]',
        noneNotCallable: '[sIZ5J][jt f tp "None" t  ll]',
        noneNotIterable: '[spDD0][jt f tp "None" t  s s trl vl]',
        noneNotSubscriptable: '[Emzwj][jt f tp "None" s t ssrptl]',
        noneNotUsableWith: '[zlOOD][jt f tp "None" t  s with "with"]',
        noneOperator: '[3U0d3][prtr "{prtr}" t spprt fr "None"]',
        noneUnknownMember: '[4KvEX]["{m}" s t  kw ttrt f "None"]',
        notRequiredArgCount: '[uOeAb][xpt  sgl tp rgmt ftr "NotRequired"]',
        notRequiredNotInTypedDict: '[Vl6XL]["NotRequired" s t llw  ths txt]',
        objectNotCallable: '[bzlKk][jt f tp "{tp}" s t lll]',
        obscuredClassDeclaration: '[ixjN9][lss lrt "{m}" s sr   lrt f th sm m]',
        obscuredFunctionDeclaration: '[O71DX][Ft lrt "{m}" s sr   lrt f th sm m]',
        obscuredMethodDeclaration: '[m04yf][Mth lrt "{m}" s sr   lrt f th sm m]',
        obscuredParameterDeclaration: '[NaF76][Prmtr lrt "{m}" s sr   lrt f th sm m]',
        obscuredTypeAliasDeclaration: '[0GZdR][Tp ls lrt "{m}" s sr   lrt f th sm m]',
        obscuredVariableDeclaration: '[HR10j][lrt "{m}" s sr   lrt f th sm m]',
        operatorLessOrGreaterDeprecated: '[bNZp7][prtr "<>" s t spprt  Pth 3; s "!=" st]',
        optionalExtraArgs: '[yW5W0][xpt  tp rgmt ftr "Optional"]',
        orPatternIrrefutable: '[peFRW][rrftl pttr llw l s th lst spttr   "or" pttr]',
        orPatternMissingName: '[OxMxP][ll spttrs wth  "or" pttr mst trgt th sm ms]',
        overlappingKeywordArgs: '[46dQE][Tp tr vrlps wth kwr prmtr: {ms}]',
        overlappingOverload: '[SCQMv][vrl {sr} fr "{m}" wll vr  s s ts prmtrs vrlp vrl {sr}]',
        overloadAbstractImplMismatch: '[IgMzu][vrls mst mth strt stts f mplmtt]',
        overloadAbstractMismatch: '[54DCM][vrls mst ll  strt r t]',
        overloadClassMethodInconsistent: '[8y6vM][vrls fr "{m}" s @classmethod ssttl]',
        overloadFinalInconsistencyImpl: '[0hpZY][vrl fr "{m}" s mrk @final t mplmtt s t]',
        overloadFinalInconsistencyNoImpl: '[Z6TSL][vrl {x} fr "{m}" s mrk @final t vrl 1 s t]',
        overloadImplementationMismatch: '[dXlXE][vrl mplmtt s t sstt wth sgtr f vrl {x}]',
        overloadReturnTypeMismatch: '[6BN74][vrl {prvx} fr "{m}" vrlps vrl {wx}  rtrs  mptl tp]',
        overloadStaticMethodInconsistent: '[PKQvM][vrls fr "{m}" s @staticmethod ssttl]',
        overloadWithoutImplementation: '[mn33a]["{m}" s mrk s overload, t  mplmtt s prv]',
        overriddenMethodNotFound: '[YKdBy][Mth "{m}" s mrk s override, t  s mth f sm m s prst]',
        overrideDecoratorMissing: '[2BnJq][Mth "{m}" s t mrk s override t s vrrg  mth  lss "{lssm}"]',
        paramAfterKwargsParam: '[wJZkp][Prmtr t fllw "**" prmtr]',
        paramAlreadyAssigned: '[srzhT][Prmtr "{m}" s lr ssg]',
        paramAnnotationMissing: '[1OYGc][Tp tt s mssg fr prmtr "{m}"]',
        paramAssignmentMismatch: '[Q8zha][xprss f tp "{srTp}" t  ssg t prmtr f tp "{prmTp}"]',
        paramNameMissing: '[ivXu4][ prmtr m "{m}"]',
        paramSpecArgsKwargsDuplicate: '[4Ie64][rgmts fr ParamSpec "{tp}" hv lr  prv]',
        paramSpecArgsKwargsUsage: '[oVRV0]["args"  "kwargs" ttrts f ParamSpec mst th ppr wth  ft sgtr]',
        paramSpecArgsMissing: '[rd6zO][rgmts fr ParamSpec "{tp}" r mssg]',
        paramSpecArgsUsage: '[2U9SN]["args" ttrt f ParamSpec s vl l wh s wth *args prmtr]',
        paramSpecAssignedName: '[ww5mM][ParamSpec mst  ssg t  vrl m "{m}"]',
        paramSpecContext: '[y6xyK][ParamSpec s t llw  ths txt]',
        paramSpecDefaultNotTuple: '[6Tdff][xpt llpss,  tuple xprss, r ParamSpec fr flt vl f ParamSpec]',
        paramSpecFirstArg: '[W2Y3X][xpt m f ParamSpec s frst rgmt]',
        paramSpecKwargsUsage: '[2UE71]["kwargs" ttrt f ParamSpec s vl l wh s wth **kwargs prmtr]',
        paramSpecNotUsedByOuterScope: '[5Pk7H][ParamSpec "{m}" hs  mg  ths txt]',
        paramSpecUnknownArg: '[6zeYc][ParamSpec s t spprt mr th  rgmt]',
        paramSpecUnknownMember: '[GhhiY]["{m}" s t  kw ttrt f ParamSpec]',
        paramSpecUnknownParam: '[YADLo]["{m}" s kw prmtr t ParamSpec]',
        paramTypeCovariant: '[USAuF][vrt tp vrl t  s  prmtr tp]',
        paramTypePartiallyUnknown: '[1ShLP][Tp f prmtr "{prmm}" s prtll kw]',
        paramTypeUnknown: '[fweDh][Tp f prmtr "{prmm}" s kw]',
        parenthesizedContextManagerIllegal: '[NBxCb][Prthss with "with" sttmt rqrs Pth 3.9 r wr]',
        patternNeverMatches: '[lyG7p][Pttr wll vr  mth fr sjt tp "{tp}"]',
        positionArgAfterNamedArg: '[szCz2][Pstl rgmt t ppr ftr kwr rgmts]',
        positionOnlyAfterArgs: '[Vqb7c][Pst-l prmtr sprtr t llw ftr "*" prmtr]',
        positionOnlyAfterKeywordOnly: '[z1FIK]["/" prmtr mst ppr fr "*" prmtr]',
        positionOnlyAfterNon: '[iXb2r][Pst-l prmtr t llw ftr prmtr tht s t pst-l]',
        positionOnlyFirstParam: '[bmnbs][Pst-l prmtr sprtr t llw s frst prmtr]',
        positionOnlyIncompatible: '[Ick28][Pst-l prmtr sprtr rqrs Pth 3.8 r wr]',
        privateImportFromPyTypedModule: '[VRdf4]["{m}" s t xprt frm ml "{ml}"]',
        privateUsedOutsideOfClass: '[3YBNL]["{m}" s prvt  s ts f th lss  whh t s lr]',
        privateUsedOutsideOfModule: '[TgDgt]["{m}" s prvt  s ts f th ml  whh t s lr]',
        propertyOverridden: '[mwp5C]["{m}" rrtl vrrs property f sm m  lss "{lssm}"]',
        propertyStaticMethod: '[qs3pr][tt mths t llw fr property getter, setter r deleter]',
        protectedUsedOutsideOfClass: '[z2Y7X]["{m}" s prtt  s ts f th lss  whh t s lr]',
        protocolBaseClass: '[lv3rP][Protocol lss "{lssTp}" t rv frm -Protocol lss "{sTp}"]',
        protocolBaseClassWithTypeArgs: '[tpYEx][Tp rgmts r t llw wth Protocol lss wh sg tp prmtr stx]',
        protocolIllegal: '[jYjYe][s f "Protocol" rqrs Pth 3.7 r wr]',
        protocolNotAllowed: '[2GEt6]["Protocol" t  s  ths txt]',
        protocolTypeArgMustBeTypeParam: '[WTgkM][Tp rgmt fr "Protocol" mst   tp prmtr]',
        protocolUnsafeOverlap: '[79LbC][lss vrlps "{m}" sfl  l pr  mth t rtm]',
        protocolVarianceContravariant: '[B4htZ][Tp vrl "{vrl}" s  gr Protocol "{lss}" shl  trvrt]',
        protocolVarianceCovariant: '[Hcnn5][Tp vrl "{vrl}" s  gr Protocol "{lss}" shl  vrt]',
        protocolVarianceInvariant: '[o8oB7][Tp vrl "{vrl}" s  gr Protocol "{lss}" shl  vrt]',
        pyrightCommentInvalidDiagnosticBoolValue: '[eaJY0][Pyright mmt rtv mst  fllw  "="   vl f true r false]',
        pyrightCommentInvalidDiagnosticSeverityValue: '[2YA7K][Pyright mmt rtv mst  fllw  "="   vl f true, false, error, warning, information, r none]',
        pyrightCommentMissingDirective: '[yy6rB][Pyright mmt mst  fllw   rtv (basic r strict) r  gst rl]',
        pyrightCommentNotOnOwnLine: '[mM2bV][Pyright mmts s t trl fl-lvl sttgs mst ppr  thr w l]',
        pyrightCommentUnknownDiagnosticRule: '[DFAZp]["{rl}" s  kw gst rl fr pyright mmt]',
        pyrightCommentUnknownDiagnosticSeverityValue: '[Tgt0Y]["{vl}" s vl vl fr pyright mmt; xpt true, false, error, warning, information, r none]',
        pyrightCommentUnknownDirective: '[HD6T4]["{rtv}" s  kw rtv fr pyright mmt; xpt "strict" r "basic"]',
        readOnlyArgCount: '[B1Erm][xpt  sgl tp rgmt ftr "ReadOnly"]',
        readOnlyNotInTypedDict: '[xJrLN]["ReadOnly" s t llw  ths txt]',
        recursiveDefinition: '[G3UUN][Tp f "{m}" l t  trm s t rfrs t tslf]',
        relativeImportNotAllowed: '[JZqjC][Rltv mprts t  s wth "import .a" frm; s "from . import a" st]',
        requiredArgCount: '[aZX4z][xpt  sgl tp rgmt ftr "Required"]',
        requiredNotInTypedDict: '[TArW6]["Required" s t llw  ths txt]',
        returnInAsyncGenerator: '[qb5pt][Rtr sttmt wth vl s t llw  async grtr]',
        returnInExceptionGroup: '[wRRjc]["return" s t llw   "except*" lk]',
        returnMissing: '[kPevK][Ft wth lr rtr tp "{rtrTp}" mst rtr vl  ll  pths]',
        returnOutsideFunction: '[O4SJp]["return"   s l wth  ft]',
        returnTypeContravariant: '[KkMhh][trvrt tp vrl t  s  rtr tp]',
        returnTypeMismatch: '[QYqHy][Tp "{xprTp}" s t ssgl t rtr tp "{rtrTp}"]',
        returnTypePartiallyUnknown: '[261DZ][Rtr tp, "{rtrTp}", s prtll kw]',
        returnTypeUnknown: '[II3Ix][Rtr tp s kw]',
        revealLocalsArgs: '[qKEIL][xpt  rgmts fr "reveal_locals" ll]',
        revealLocalsNone: '[xOTfI][ locals  ths sp]',
        revealTypeArgs: '[Sdo9V][xpt  sgl pstl rgmt fr "reveal_type" ll]',
        revealTypeExpectedTextArg: '[6cFBk][Th "expected_text" rgmt fr ft "reveal_type" mst   str ltrl vl]',
        revealTypeExpectedTextMismatch: '[ILnEV][Tp txt msmth; xpt "{xpt}" t rv "{rv}"]',
        revealTypeExpectedTypeMismatch: '[3XS8T][Tp msmth; xpt "{xpt}" t rv "{rv}"]',
        selfTypeContext: '[Hugyy]["Self" s t vl  ths txt]',
        selfTypeMetaclass: '[YvoBy]["Self" t  s wth  mtlss ( slss f "tp")]',
        selfTypeWithTypedSelfOrCls: '[sYgyY]["Self" t  s   ft wth  `self` r `cls` prmtr tht hs  tp tt thr th "Self"]',
        setterGetterTypeMismatch: '[8ZD1z][Property setter vl tp s t ssgl t th getter rtr tp]',
        singleOverload: '[YQVUc]["{m}" s mrk s vrl, t tl vrls r mssg]',
        slotsAttributeError: '[OF4rK]["{m}" s t spf  __slots__]',
        slotsClassVarConflict: '[tcS3q]["{m}" flts wth st vrl lr  __slots__]',
        starPatternInAsPattern: '[ZFdWe][tr pttr t  s wth "as" trgt]',
        starPatternInOrPattern: '[y9LX3][tr pttr t  R wth thr pttrs]',
        starStarWildcardNotAllowed: '[Ll1UV][** t  s wth wlr "_"]',
        staticClsSelfParam: '[mO4QU][tt mths shl t tk  "self" r "cls" prmtr]',
        stdlibModuleOverridden: '[AV6K3]["{pth}" s vrrg th stdlib ml "{m}"]',
        stringNonAsciiBytes: '[dFNRn][-ASCII hrtr t llw  ts strg ltrl]',
        stringNotSubscriptable: '[hKZT7][trg xprss t  ssrpt  tp xprss; ls tr xprss  qts]',
        stringUnsupportedEscape: '[K2WsY][spprt sp sq  strg ltrl]',
        stringUnterminated: '[jUKYA][trg ltrl s trmt]',
        stubFileMissing: '[Ua5GT][Stub fl t f fr "{mprtm}"]',
        stubUsesGetAttr: '[KMBwK][Tp stub fl s mplt; "__getattr__" srs tp rrrs fr ml]',
        sublistParamsIncompatible: '[582LE][Sublist prmtrs r t spprt  Pth 3.x]',
        superCallArgCount: '[iLYq6][xpt  mr th tw rgmts t "super" ll]',
        superCallFirstArg: '[HSEvD][xpt lss tp s frst rgmt t "super" ll t rv "{tp}"]',
        superCallSecondArg: '[dKoHi][ rgmt t "super" ll mst  jt r lss tht rvs frm "{tp}"]',
        superCallZeroArgForm: '[0XO27][Zr-rgmt frm f "super" ll s vl l wth  mth]',
        superCallZeroArgFormStaticMethod: '[9hJPB][Zr-rgmt frm f "super" ll s t vl wth  stt mth]',
        symbolIsPossiblyUnbound: '[cUgue]["{m}" s pssl ]',
        symbolIsUnbound: '[zhGl5]["{m}" s ]',
        symbolIsUndefined: '[qCm6F]["{m}" s t f]',
        symbolOverridden: '[JwRrv]["{m}" vrrs sml f sm m  lss "{lssm}"]',
        ternaryNotAllowed: '[5NH6C][Trr xprss t llw  tp xprss]',
        totalOrderingMissingMethod: '[eYfjn][lss mst f  f "__lt__", "__le__", "__gt__", r "__ge__" t s total_ordering]',
        trailingCommaInFromImport: '[NcaZY][Trlg mm t llw wtht srrg prthss]',
        tryWithoutExcept: '[6z9oA][Try sttmt mst hv t lst  except r finally ls]',
        tupleAssignmentMismatch: '[xySRW][xprss wth tp "{tp}" t  ssg t trgt tuple]',
        tupleInAnnotation: '[j2RAZ][Tuple xprss t llw  tp xprss]',
        tupleIndexOutOfRange: '[aNqDv][x {x} s t f rg fr tp {tp}]',
        typeAliasIllegalExpressionForm: '[4u4ay][vl xprss frm fr tp ls ft]',
        typeAliasIsRecursiveDirect: '[r8PyZ][Tp ls "{m}" t s tslf  ts ft]',
        typeAliasNotInModuleOrClass: '[iQpDJ][ TypeAlias   f l wth  ml r lss sp]',
        typeAliasRedeclared: '[P036x]["{m}" s lr s  TypeAlias    ssg l ]',
        typeAliasStatementBadScope: '[C24Up][ type sttmt   s l wth  ml r lss sp]',
        typeAliasStatementIllegal: '[2EW0Q][Tp ls sttmt rqrs Pth 3.12 r wr]',
        typeAliasTypeBaseClass: '[RIpMs][ tp ls f   "type" sttmt t  s s  s lss]',
        typeAliasTypeMustBeAssigned: '[aV4Nn][TypeAliasType mst  ssg t  vrl wth th sm m s th tp ls]',
        typeAliasTypeNameArg: '[dUUf1][Frst rgmt t TypeAliasType mst   strg ltrl rprstg th m f th tp ls]',
        typeAliasTypeNameMismatch: '[jW1bQ][m f tp ls mst mth th m f th vrl t whh t s ssg]',
        typeAliasTypeParamInvalid: '[RdHRE][Tp prmtr lst mst   tuple tg l TypeVar, TypeVarTuple, r ParamSpec]',
        typeAnnotationCall: '[7pNts][ll xprss t llw  tp xprss]',
        typeAnnotationVariable: '[GeXWQ][Vrl t llw  tp xprss]',
        typeAnnotationWithCallable: '[JJENJ][Tp rgmt fr "type" mst   lss; llls r t spprt]',
        typeArgListExpected: '[2efoA][xpt ParamSpec, llpss, r list f tps]',
        typeArgListNotAllowed: '[oV7JF][List xprss t llw fr ths tp rgmt]',
        typeArgsExpectingNone: '[faycH][xpt  tp rgmts fr lss "{m}"]',
        typeArgsMismatchOne: '[BBe1n][xpt  tp rgmt t rv {rv}]',
        typeArgsMissingForAlias: '[hk8aw][xpt tp rgmts fr gr tp ls "{m}"]',
        typeArgsMissingForClass: '[SkdfG][xpt tp rgmts fr gr lss "{m}"]',
        typeArgsTooFew: '[6PAb0][T fw tp rgmts prv fr "{m}"; xpt {xpt} t rv {rv}]',
        typeArgsTooMany: '[NKF2Z][T m tp rgmts prv fr "{m}"; xpt {xpt} t rv {rv}]',
        typeAssignmentMismatch: '[wwjSP][Tp "{srTp}" s t ssgl t lr tp "{stTp}"]',
        typeAssignmentMismatchWildcard: '[qdgVA][mprt sml "{m}" hs tp "{srTp}", whh s t ssgl t lr tp "{stTp}"]',
        typeCallNotAllowed: '[OGMmG][type() ll shl t  s  tp xprss]',
        typeCheckOnly: '[cSmKj]["{m}" s mrk s @type_check_only    s l  tp tts]',
        typeCommentDeprecated: '[SRhVz][s f type mmts s prt; s type tt st]',
        typeExpectedClass: '[r0pdu][xpt lss t rv "{tp}"]',
        typeFormArgs: '[ivrdh]["TypeForm" pts  sgl pstl rgmt]',
        typeGuardArgCount: '[Zl47K][xpt  sgl tp rgmt ftr "TypeGuard" r "TypeIs"]',
        typeGuardParamCount: '[I3HUH][sr-f tp gr fts  mths mst hv t lst  pt prmtr]',
        typeIsReturnType: '[5bBbd][Rtr tp f TypeIs ("{rtrTp}") s t sstt wth vl prmtr tp ("{tp}")]',
        typeNotAwaitable: '[NZ9Yu]["{tp}" s t awaitable]',
        typeNotIntantiable: '[f3xEe]["{tp}" t  sttt]',
        typeNotIterable: '[XMDzF]["{tp}" s t trl]',
        typeNotSpecializable: '[ZCsyD][l t splz tp "{tp}"]',
        typeNotSubscriptable: '[fpefi][jt f tp "{tp}" s t ssrptl]',
        typeNotSupportBinaryOperator: '[C0OGX][prtr "{prtr}" t spprt fr tps "{lftTp}"  "{rghtTp}"]',
        typeNotSupportBinaryOperatorBidirectional: '[25nah][prtr "{prtr}" t spprt fr tps "{lftTp}"  "{rghtTp}" wh xpt tp s "{xptTp}"]',
        typeNotSupportUnaryOperator: '[f2pEG][prtr "{prtr}" t spprt fr tp "{tp}"]',
        typeNotSupportUnaryOperatorBidirectional: '[Z51QN][prtr "{prtr}" t spprt fr tp "{tp}" wh xpt tp s "{xptTp}"]',
        typeNotUsableWith: '[R7VpZ][jt f tp "{tp}" t  s wth "wth" s t s t mplmt {mth}]',
        typeParameterBoundNotAllowed: '[iA0kz][ r strt t  s wth  vr tp prmtr r ParamSpec]',
        typeParameterConstraintTuple: '[8wa57][Tp prmtr strt mst   tpl f tw r mr tps]',
        typeParameterExistingTypeParameter: '[M2QXP][Tp prmtr "{m}" s lr  s]',
        typeParameterNotDeclared: '[WD9B6][Tp prmtr "{m}" s t l  th tp prmtr lst fr "{tr}"]',
        typeParametersMissing: '[7nPE2][t lst  tp prmtr mst  spf]',
        typePartiallyUnknown: '[K72xm][Tp f "{m}" s prtll kw]',
        typeUnknown: '[flab2][Tp f "{m}" s kw]',
        typeVarAssignedName: '[AnBke][TypeVar mst  ssg t  vrl m "{m}"]',
        typeVarAssignmentMismatch: '[IYCuH][Tp "{tp}" t  ssg t tp vrl "{m}"]',
        typeVarBoundAndConstrained: '[nSFES][TypeVar t  th   str]',
        typeVarBoundGeneric: '[scFkM][TypeVar  tp t  gr]',
        typeVarConstraintGeneric: '[k7N05][TypeVar strt tp t  gr]',
        typeVarDefaultBoundMismatch: '[knxtI][TypeVar flt tp mst   stp f th  tp]',
        typeVarDefaultConstraintMismatch: '[BlQvu][TypeVar flt tp mst   f th str tps]',
        typeVarDefaultIllegal: '[Z5lrX][Tp vrl flt tps rqr Pth 3.13 r wr]',
        typeVarDefaultInvalidTypeVar: '[bOQ21][Tp prmtr "{m}" hs  flt tp tht rfrs t  r mr tp vrls tht r t f sp]',
        typeVarFirstArg: '[XBVgA][xpt m f TypeVar s frst rgmt]',
        typeVarInvalidForMemberVariable: '[m45Yw][ttrt tp t s tp vrl "{m}" sp t ll mth]',
        typeVarNoMember: '[Trelb][TypeVar "{tp}" hs  ttrt "{m}"]',
        typeVarNotSubscriptable: '[3KoEm][TypeVar "{tp}" s t ssrptl]',
        typeVarNotUsedByOuterScope: '[on7uQ][Tp vrl "{m}" hs  mg  ths txt]',
        typeVarPossiblyUnsolvable: '[PP5xz][Tp vrl "{m}" m g slv f llr sppls  rgmt fr prmtr "{prm}"]',
        typeVarSingleConstraint: '[51MwX][TypeVar mst hv t lst tw str tps]',
        typeVarTupleConstraints: '[ouP8u][TypeVarTuple t hv vl strts]',
        typeVarTupleContext: '[Q8vE2][TypeVarTuple s t llw  ths txt]',
        typeVarTupleDefaultNotUnpacked: '[S2joz][TypeVarTuple flt tp mst   pk tuple r TypeVarTuple]',
        typeVarTupleMustBeUnpacked: '[TA5HX][pk prtr s rqr fr TypeVarTuple vl]',
        typeVarTupleUnknownParam: '[fOW23]["{m}" s kw prmtr t TypeVarTuple]',
        typeVarUnknownParam: '[veXvU]["{m}" s kw prmtr t TypeVar]',
        typeVarUsedByOuterScope: '[GJ5N3][TypeVar "{m}" s lr  s   tr sp]',
        typeVarUsedOnlyOnce: '[vSn0W][TypeVar "{m}" pprs l   gr ft sgtr]',
        typeVarVariance: '[1Dxdn][TypeVar t  th vrt  trvrt]',
        typeVarWithDefaultFollowsVariadic: '[h1V5a][TypeVar "{tpVrm}" hs  flt vl  t fllw TypeVarTuple "{vrm}"]',
        typeVarWithoutDefault: '[w630R]["{m}" t ppr ftr "{thr}"  tp prmtr lst s t hs  flt tp]',
        typeVarsNotInGenericOrProtocol: '[ydmAV][Generic[] r Protocol[] mst l ll tp vrls]',
        typedDictAccess: '[55CCf][l t ss tm  TypedDict]',
        typedDictAssignedName: '[Dkf5M][TypedDict mst  ssg t  vrl m "{m}"]',
        typedDictBadVar: '[OL8Ox][TypedDict lsss  t l tp tts]',
        typedDictBaseClass: '[HxyA2][ll s lsss fr TypedDict lsss mst ls  TypedDict lsss]',
        typedDictBoolParam: '[GALOD][xpt "{m}" prmtr t hv  vl f True r False]',
        typedDictClosedExtras: '[mlkJO][s lss "{m}" s  closed TypedDict; xtr tms mst  tp "{tp}"]',
        typedDictClosedNoExtras: '[BCyXd][s lss "{m}" s  closed TypedDict; xtr tms r t llw]',
        typedDictDelete: '[bdBu7][l t lt tm  TypedDict]',
        typedDictEmptyName: '[h45e7][ms wth  TypedDict t  mpt]',
        typedDictEntryName: '[NT4np][xpt strg ltrl fr tr tr m]',
        typedDictEntryUnique: '[nWy0L][ms wth  tr mst  q]',
        typedDictExtraArgs: '[0gX32][xtr TypedDict rgmts t spprt]',
        typedDictExtraItemsClosed: '[5BDXE][ TypedDict t  closed f t spprts xtr tms]',
        typedDictFieldNotRequiredRedefinition: '[rNYD1][TypedDict tm "{m}" t  rf s NotRequired]',
        typedDictFieldReadOnlyRedefinition: '[8IFAz][TypedDict tm "{m}" t  rf s ReadOnly]',
        typedDictFieldRequiredRedefinition: '[lpw97][TypedDict tm "{m}" t  rf s Required]',
        typedDictFirstArg: '[OPlNk][xpt TypedDict lss m s frst rgmt]',
        typedDictInClassPattern: '[IqJCA][TypedDict lss t llw  lss pttr]',
        typedDictInitsubclassParameter: '[HMpfK][TypedDict s t spprt __init_subclass__ prmtr "{m}"]',
        typedDictNotAllowed: '[UWg4F]["TypedDict" t  s  ths txt]',
        typedDictSecondArgDict: '[mwrv7][xpt dict r kwr prmtr s s prmtr]',
        typedDictSecondArgDictEntry: '[oAT5Z][xpt smpl tr tr]',
        typedDictSet: '[30hTC][l t ssg tm  TypedDict]',
        unaccessedClass: '[dou8i][lss "{m}" s t ss]',
        unaccessedFunction: '[AdgDz][Ft "{m}" s t ss]',
        unaccessedImport: '[2a90g][mprt "{m}" s t ss]',
        unaccessedSymbol: '[MmnM7]["{m}" s t ss]',
        unaccessedVariable: '[n5l1e][Vrl "{m}" s t ss]',
        unannotatedFunctionSkipped: '[Ovgyl][lss f ft "{m}" s skpp s t s tt]',
        unaryOperationNotAllowed: '[2WB31][r prtr t llw  tp xprss]',
        unexpectedAsyncToken: '[fKSJb][xpt "def", "with" r "for" t fllw "async"]',
        unexpectedExprToken: '[MtBsu][xpt tk t  f xprss]',
        unexpectedIndent: '[uZUVS][xpt tt]',
        unexpectedUnindent: '[yqwy4][t t xpt]',
        unhashableDictKey: '[pIvHj][tr k mst  hshl]',
        unhashableSetEntry: '[rWf72][Set tr mst  hshl]',
        uninitializedAbstractVariables: '[SpCPH][Vrls f  strt s lss r t tlz  final lss "{lssTp}"]',
        uninitializedInstanceVariable: '[5pgFw][st vrl "{m}" s t tlz  th lss  r __init__ mth]',
        unionForwardReferenceNotAllowed: '[MOLby][Union stx t  s wth strg pr; s qts r tr xprss]',
        unionSyntaxIllegal: '[vbTDG][ltrtv stx fr s rqrs Pth 3.10 r wr]',
        unionTypeArgCount: '[vc6vA][Union rqrs tw r mr tp rgmts]',
        unionUnpackedTuple: '[owRjE][Union t l  pk tuple]',
        unionUnpackedTypeVarTuple: '[a6msY][Union t l  pk TypeVarTuple]',
        unnecessaryCast: '[QgPoI][ssr "cast" ll; tp s lr "{tp}"]',
        unnecessaryIsInstanceAlways: '[gX4s7][ssr isinstance ll; "{tstTp}" s lws  st f "{lssTp}"]',
        unnecessaryIsInstanceNever: '[60nSE][ssr isinstance ll; "{tstTp}" s vr  st f "{lssTp}"]',
        unnecessaryIsSubclassAlways: '[BzHtx][ssr issubclass ll; "{tstTp}" s lws  slss f "{lssTp}"]',
        unnecessaryIsSubclassNever: '[bOMnf][ssr issubclass ll; "{tstTp}" s vr  slss f "{lssTp}"]',
        unnecessaryPyrightIgnore: '[7QhdX][ssr "# pyright: ignore" mmt]',
        unnecessaryPyrightIgnoreRule: '[0ESoQ][ssr "# pyright: ignore" rl: "{m}"]',
        unnecessaryTypeIgnore: '[IoWr9][ssr "# type: ignore" mmt]',
        unpackArgCount: '[bkAT1][xpt  sgl tp rgmt ftr "Unpack"]',
        unpackExpectedTypeVarTuple: '[CWX8o][xpt TypeVarTuple r tuple s tp rgmt fr Unpack]',
        unpackExpectedTypedDict: '[ha9qw][xpt TypedDict tp rgmt fr Unpack]',
        unpackIllegalInComprehension: '[7a4pV][pk prt t llw  mprhs]',
        unpackInAnnotation: '[6gqFu][pk prtr t llw  tp xprss]',
        unpackInDict: '[eKn69][pk prt t llw  trs]',
        unpackInSet: '[lKyO0][pk prtr t llw wth  set]',
        unpackNotAllowed: '[MZq6e][Unpack s t llw  ths txt]',
        unpackOperatorNotAllowed: '[lMq2B][pk prt s t llw  ths txt]',
        unpackTuplesIllegal: '[RJvzW][pk prt t llw  tpls prr t Pth 3.8]',
        unpackedArgInTypeArgument: '[skxlo][pk rgmts t  s  ths txt]',
        unpackedArgWithVariadicParam: '[ZP3kP][pk rgmt t  s fr TypeVarTuple prmtr]',
        unpackedDictArgumentNotMapping: '[iSTnU][rgmt xprss ftr ** mst   mppg wth  "str" k tp]',
        unpackedDictSubscriptIllegal: '[slATr][tr pk prtr  ssrpt s t llw]',
        unpackedSubscriptIllegal: '[2CpZz][pk prtr  ssrpt rqrs Pth 3.11 r wr]',
        unpackedTypeVarTupleExpected: '[tgdHs][xpt pk TypeVarTuple; s Unpack[{name1}] r *{name2}]',
        unpackedTypedDictArgument: '[iCgjR][l t mth pk TypedDict rgmt t prmtrs]',
        unreachableCode: '[bpJSK][ s rhl]',
        unreachableCodeType: '[v80nR][Tp lss ts  s rhl]',
        unreachableExcept: '[zFMWg][Except ls s rhl s xpt s lr hl]',
        unsupportedDunderAllOperation: '[KsX0f][prt  "__all__" s t spprt, s xprt sml lst m  rrt]',
        unusedCallResult: '[9IsV5][Rslt f ll xprss s f tp "{tp}"  s t s; ssg t vrl "_" f ths s ttl]',
        unusedCoroutine: '[nQUJ2][Rslt f async ft ll s t s; s "wt" r ssg rslt t vrl]',
        unusedExpression: '[ghmaU][xprss vl s s]',
        varAnnotationIllegal: '[v2cs9][Tp tts fr vrls rqrs Pth 3.6 r wr; s type mmt fr mptlt wth prvs vrss]',
        variableFinalOverride: '[LcrNS][Vrl "{m}" s mrk Final  vrrs -Final vrl f sm m  lss "{lssm}"]',
        variadicTypeArgsTooMany: '[1QX0D][Tp rgmt lst  hv t mst  pk TypeVarTuple r tuple]',
        variadicTypeParamTooManyAlias: '[43VIR][Tp ls  hv t mst  TypeVarTuple tp prmtr t rv mltpl ({ms})]',
        variadicTypeParamTooManyClass: '[fboqC][Gr lss  hv t mst  TypeVarTuple tp prmtr t rv mltpl ({ms})]',
        walrusIllegal: '[iR3y3][prtr ":=" rqrs Pth 3.8 r wr]',
        walrusNotAllowed: '[kdD5j][prtr ":=" s t llw  ths txt wtht srrg prthss]',
        wildcardInFunction: '[NyGOv][Wlr import t llw wth  lss r ft]',
        wildcardLibraryImport: '[Yk3ai][Wlr import frm  lrr t llw]',
        wildcardPatternTypePartiallyUnknown: '[eRR5M][Tp ptr  wlr pttr s prtll kw]',
        wildcardPatternTypeUnknown: '[Bo3gT][Tp ptr  wlr pttr s kw]',
        yieldFromIllegal: '[DkXto][s f "yield from" rqrs Pth 3.3 r wr]',
        yieldFromOutsideAsync: '[ZONEz]["yield from" t llw   async ft]',
        yieldOutsideFunction: '[2lDBQ]["yield" t llw ts f  ft r lm]',
        yieldWithinComprehension: '[yALS5]["yield" t llw s  mprhs]',
        zeroCaseStatementsFound: '[ArU3j][Match sttmt mst l t lst  case sttmt]',
        zeroLengthTupleNotAllowed: '[3gVpF][Zr-lgth tuple s t llw  ths txt]'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '[Mws6g]["Annotated" spl frm t  s wth st  lss hks]',
        argParam: '[nmvvb][rgmt rrsps t prmtr "{prmm}"]',
        argParamFunction: '[7Xwg8][rgmt rrsps t prmtr "{prmm}"  ft "{ftm}"]',
        argsParamMissing: '[vg3b8][Prmtr "*{prmm}" hs  rrspg prmtr]',
        argsPositionOnly: '[sNlU1][Pst-l prmtr msmth; xpt {xpt} t rv {rv}]',
        argumentType: '[JJxeD][rgmt tp s "{tp}"]',
        argumentTypes: '[Omlwm][rgmt tps: ({tps})]',
        assignToNone: '[z249G][Tp s t ssgl t "None"]',
        asyncHelp: '[2nasS][  m "async with"?]',
        baseClassIncompatible: '[oW6Ip][s lss "{slss}" s mptl wth tp "{tp}"]',
        baseClassIncompatibleSubclass: '[mMUCH][s lss "{slss}" rvs frm "{slss}" whh s mptl wth tp "{tp}"]',
        baseClassOverriddenType: '[Hp8Sl][s lss "{slss}" prvs tp "{tp}", whh s vrr]',
        baseClassOverridesType: '[P7N4Y][s lss "{slss}" vrrs wth tp "{tp}"]',
        bytesTypePromotions: '[qIXYb][t disableBytesTypePromotions t false t l tp prmt hvr fr "bytearray"  "memoryview"]',
        conditionalRequiresBool: '[k1G9a][Mth __bool__ fr tp "{prTp}" rtrs tp "{lRtrTp}" rthr th "l"]',
        dataClassFieldLocation: '[vQxtf][Fl lrt]',
        dataClassFrozen: '[d4uiK]["{m}" s frz]',
        dataProtocolUnsupported: '[7gIT2]["{m}" s  t prtl]',
        descriptorAccessBindingFailed: '[RiEhE][Fl t  mth "{m}" fr srptr lss "{lssm}"]',
        descriptorAccessCallFailed: '[8EXvg][Fl t ll mth "{m}" fr srptr lss "{lssm}"]',
        finalMethod: '[zz1yN][Final mth]',
        functionParamDefaultMissing: '[yWAIy][Prmtr "{m}" s mssg flt rgmt]',
        functionParamName: '[NrJqx][Prmtr m msmth: "{stm}" vrss "{srm}"]',
        functionParamPositionOnly: '[XOhUP][Pst-l prmtr msmth; prmtr "{m}" s t pst-l]',
        functionReturnTypeMismatch: '[x4qH0][Ft rtr tp "{srTp}" s mptl wth tp "{stTp}"]',
        functionTooFewParams: '[575uy][Ft pts t fw pstl prmtrs; xpt {xpt} t rv {rv}]',
        functionTooManyParams: '[zj9vw][Ft pts t m pstl prmtrs; xpt {xpt} t rv {rv}]',
        genericClassNotAllowed: '[MDEt3][Gr tp wth tp rgmts t llw fr st r lss hks]',
        incompatibleDeleter: '[LCJuj][Property deleter mth s mptl]',
        incompatibleGetter: '[yds2G][Property getter mth s mptl]',
        incompatibleSetter: '[GDoso][Property setter mth s mptl]',
        initMethodLocation: '[D4O2l][Th __init__ mth s f  lss "{tp}"]',
        initMethodSignature: '[EULjB][gtr f __init__ s "{tp}"]',
        initSubclassLocation: '[eEcCS][Th __init_subclass__ mth s f  lss "{m}"]',
        invariantSuggestionDict: '[OIoHo][sr swthg frm "dict" t "Mapping" whh s vrt  th vl tp]',
        invariantSuggestionList: '[irYWI][sr swthg frm "list" t "Sequence" whh s vrt]',
        invariantSuggestionSet: '[64U47][sr swthg frm "set" t "Container" whh s vrt]',
        isinstanceClassNotSupported: '[uTDu4]["{tp}" s t spprt fr st  lss hks]',
        keyNotRequired: '[K1bDP]["{m}" s t  rqr k  "{tp}", s ss m rslt  rtm xpt]',
        keyReadOnly: '[dhAH3]["{m}" s  r-l k  "{tp}"]',
        keyRequiredDeleted: '[YeZa5]["{m}" s  rqr k  t  lt]',
        keyUndefined: '[6mQGu]["{m}" s t  f k  "{tp}"]',
        kwargsParamMissing: '[KHgb2][Prmtr "**{prmm}" hs  rrspg prmtr]',
        listAssignmentMismatch: '[fERKI][Tp "{tp}" s mptl wth trgt lst]',
        literalAssignmentMismatch: '[17LiQ]["{srTp}" s t ssgl t tp "{stTp}"]',
        matchIsNotExhaustiveHint: '[3NR39][f xhstv hlg s t t,  "case _: pass"]',
        matchIsNotExhaustiveType: '[9RN1P][hl tp: "{tp}"]',
        memberAssignment: '[1WFCt][xprss f tp "{tp}" t  ssg t ttrt "{m}" f lss "{lssTp}"]',
        memberIsAbstract: '[l912U]["{tp}.{m}" s t mplmt]',
        memberIsAbstractMore: '[dgfwa][ {t} mr]...',
        memberIsClassVarInProtocol: '[ZZeb4]["{m}" s f s  ClassVar  prtl]',
        memberIsInitVar: '[0SGIB]["{m}" s  init-only fl]',
        memberIsInvariant: '[rBPX6]["{m}" s vrt s t s mtl]',
        memberIsNotClassVarInClass: '[bKhkE]["{m}" mst  f s  ClassVar t  mptl wth prtl]',
        memberIsNotClassVarInProtocol: '[OAmE1]["{m}" s t f s  ClassVar  prtl]',
        memberIsNotReadOnlyInProtocol: '[TKk1U]["{m}" s t r-l  prtl]',
        memberIsReadOnlyInProtocol: '[xOSqy]["{m}" s r-l  prtl]',
        memberIsWritableInProtocol: '[x53Kg]["{m}" s wrtl  prtl]',
        memberSetClassVar: '[2pVfQ][ttrt "{m}" t  ssg thrgh  lss st s t s  ClassVar]',
        memberTypeMismatch: '[IHN4x]["{m}" s  mptl tp]',
        memberUnknown: '[7kDIF][ttrt "{m}" s kw]',
        metaclassConflict: '[fjWW1][Mtlss "{mtlss1}" flts wth "{mtlss2}"]',
        missingDeleter: '[5IVNI][Property deleter mth s mssg]',
        missingGetter: '[Mzn4K][Property getter mth s mssg]',
        missingSetter: '[goeIY][Property setter mth s mssg]',
        namedParamMissingInDest: '[dc07X][xtr prmtr "{m}"]',
        namedParamMissingInSource: '[N59fC][Mssg kwr prmtr "{m}"]',
        namedParamTypeMismatch: '[9CAV6][Kwr prmtr "{m}" f tp "{srTp}" s mptl wth tp "{stTp}"]',
        namedTupleNotAllowed: '[gAlSp][NamedTuple t  s fr st r lss hks]',
        newMethodLocation: '[n0dxL][Th __new__ mth s f  lss "{tp}"]',
        newMethodSignature: '[NeWKO][gtr f __new__ s "{tp}"]',
        newTypeClassNotAllowed: '[JQmcY][lss rt wth NewType t  s wth st  lss hks]',
        noOverloadAssignable: '[FJ88c][ vrl ft mths tp "{tp}"]',
        noneNotAllowed: '[Yn8Lx][None t  s fr st r lss hks]',
        orPatternMissingName: '[kgiPM][Mssg ms: {m}]',
        overloadIndex: '[vNPxL][vrl {x} s th lsst mth]',
        overloadNotAssignable: '[BA2kK][ r mr vrls f "{m}" s t ssgl]',
        overloadSignature: '[NPzwf][vrl sgtr s f hr]',
        overriddenMethod: '[CcUB2][vrr mth]',
        overriddenSymbol: '[cvpXz][vrr sml]',
        overrideInvariantMismatch: '[uODzM][vrr tp "{vrrTp}" s t th sm s s tp "{sTp}"]',
        overrideIsInvariant: '[j45KZ][Vrl s mtl s ts tp s vrt]',
        overrideNoOverloadMatches: '[vG14w][ vrl sgtr  vrr s mptl wth s mth]',
        overrideNotClassMethod: '[t5OaH][s mth s lr s  classmethod t vrr s t]',
        overrideNotInstanceMethod: '[e2Xo5][s mth s lr s  st mth t vrr s t]',
        overrideNotStaticMethod: '[Eu8Oy][s mth s lr s  staticmethod t vrr s t]',
        overrideOverloadNoMatch: '[smVSW][vrr s t hl ll vrls f s mth]',
        overrideOverloadOrder: '[HrUeN][vrls fr vrr mth mst   th sm rr s th s mth]',
        overrideParamKeywordNoDefault: '[yIoa8][Kwr prmtr "{m}" msmth: s prmtr hs flt rgmt vl, vrr prmtr s t]',
        overrideParamKeywordType: '[SAOAr][Kwr prmtr "{m}" tp msmth: s prmtr s tp "{sTp}", vrr prmtr s tp "{vrrTp}"]',
        overrideParamName: '[fRWyy][Prmtr {x} m msmth: s prmtr s m "{sm}", vrr prmtr s m "{vrrm}"]',
        overrideParamNameExtra: '[HEG0d][Prmtr "{m}" s mssg  s]',
        overrideParamNameMissing: '[PN8Rl][Prmtr "{m}" s mssg  vrr]',
        overrideParamNamePositionOnly: '[3yVlj][Prmtr {x} msmth: s prmtr "{sm}" s kwr prmtr, vrr prmtr s pst-l]',
        overrideParamNoDefault: '[azvZD][Prmtr {x} msmth: s prmtr hs flt rgmt vl, vrr prmtr s t]',
        overrideParamType: '[FXBcO][Prmtr {x} tp msmth: s prmtr s tp "{sTp}", vrr prmtr s tp "{vrrTp}"]',
        overridePositionalParamCount: '[jJZNP][Pstl prmtr t msmth; s mth hs {st}, t vrr hs {vrrt}]',
        overrideReturnType: '[mdPwX][Rtr tp msmth: s mth rtrs tp "{sTp}", vrr rtrs tp "{vrrTp}"]',
        overrideType: '[ryAgb][s lss fs tp s "{tp}"]',
        paramAssignment: '[HGg7D][Prmtr {x}: tp "{srTp}" s mptl wth tp "{stTp}"]',
        paramSpecMissingInOverride: '[AUge7][ParamSpec prmtrs r mssg  vrr mth]',
        paramType: '[hHLAX][Prmtr tp s "{prmTp}"]',
        privateImportFromPyTypedSource: '[8gX6u][mprt frm "{ml}" st]',
        propertyAccessFromProtocolClass: '[h75EJ][ prprt f wth  prtl lss t  ss s  lss vrl]',
        propertyMethodIncompatible: '[dWDwG][Property mth "{m}" s mptl]',
        propertyMethodMissing: '[xWlRK][Property mth "{m}" s mssg  vrr]',
        propertyMissingDeleter: '[r2oGK][Property "{m}" hs  f deleter]',
        propertyMissingSetter: '[Sr1R9][Property "{m}" hs  f setter]',
        protocolIncompatible: '[4uTqc]["{srTp}" s mptl wth prtl "{stTp}"]',
        protocolMemberMissing: '[Ad9PZ]["{m}" s t prst]',
        protocolRequiresRuntimeCheckable: '[c9ewn][Protocol lss mst  @runtime_checkable t  s wth st  lss hks]',
        protocolSourceIsNotConcrete: '[DnLrN]["{srTp}" s t  rt lss tp  t  ssg t tp "{stTp}"]',
        protocolUnsafeOverlap: '[fKiUM][ttrts f "{m}" hv th sm ms s th prtl]',
        pyrightCommentIgnoreTip: '[raFZN][s "# pyright: ignore[<diagnostic rules>]" t spprss gsts fr  sgl l]',
        readOnlyAttribute: '[k9waY][ttrt "{m}" s r-l]',
        seeClassDeclaration: '[8sx7n][ lss lrt]',
        seeDeclaration: '[K0X6p][ lrt]',
        seeFunctionDeclaration: '[1N6ig][ ft lrt]',
        seeMethodDeclaration: '[eJSye][ mth lrt]',
        seeParameterDeclaration: '[mBEpT][ prmtr lrt]',
        seeTypeAliasDeclaration: '[Pjnb8][ tp ls lrt]',
        seeVariableDeclaration: '[M3EiY][ vrl lrt]',
        tupleAssignmentMismatch: '[aLGep][Tp "{tp}" s mptl wth trgt tuple]',
        tupleEntryTypeMismatch: '[ny8Sn][Tuple tr {tr} s rrt tp]',
        tupleSizeIndeterminateSrc: '[EnNiw][Tuple sz msmth; xpt {xpt} t rv trmt]',
        tupleSizeIndeterminateSrcDest: '[lrxYh][Tuple sz msmth; xpt {xpt} r mr t rv trmt]',
        tupleSizeMismatch: '[F2Yc7][Tuple sz msmth; xpt {xpt} t rv {rv}]',
        tupleSizeMismatchIndeterminateDest: '[6vxdi][Tuple sz msmth; xpt {xpt} r mr t rv {rv}]',
        typeAliasInstanceCheck: '[29G7K][Tp ls rt wth "type" sttmt t  s wth st  lss hks]',
        typeAssignmentMismatch: '[VF9B4][Tp "{srTp}" s t ssgl t tp "{stTp}"]',
        typeBound: '[AIZri][Tp "{srTp}" s t ssgl t ppr  "{stTp}" fr tp vrl "{m}"]',
        typeConstrainedTypeVar: '[qHztb][Tp "{tp}" s t ssgl t str tp vrl "{m}"]',
        typeIncompatible: '[L3llJ]["{srTp}" s t ssgl t "{stTp}"]',
        typeNotClass: '[DTm1E]["{tp}" s t  lss]',
        typeNotStringLiteral: '[D7UY3]["{tp}" s t  strg ltrl]',
        typeOfSymbol: '[qlRHN][Tp f "{m}" s "{tp}"]',
        typeParamSpec: '[m23b5][Tp "{tp}" s mptl wth ParamSpec "{m}"]',
        typeUnsupported: '[Dx3Cx][Tp "{tp}" s spprt]',
        typeVarDefaultOutOfScope: '[05ALy][Tp vrl "{m}" s t  sp]',
        typeVarIsContravariant: '[kup2Y][Tp prmtr "{m}" s trvrt, t "{srTp}" s t  sprtp f "{stTp}"]',
        typeVarIsCovariant: '[EeRng][Tp prmtr "{m}" s vrt, t "{srTp}" s t  stp f "{stTp}"]',
        typeVarIsInvariant: '[WLZaN][Tp prmtr "{m}" s vrt, t "{srTp}" s t th sm s "{stTp}"]',
        typeVarNotAllowed: '[37OGF][TypeVar t llw fr st r lss hks]',
        typeVarTupleRequiresKnownLength: '[GGttd][TypeVarTuple t   t  tuple f kw lgth]',
        typeVarUnnecessarySuggestion: '[k0XTd][s {tp} st]',
        typeVarUnsolvableRemedy: '[PaRa7][Prv  vrl tht spfs th rtr tp wh th rgmt s t sppl]',
        typeVarsMissing: '[R1SEV][Mssg tp vrls: {ms}]',
        typedDictBaseClass: '[Zv6vP][lss "{tp}" s t  TypedDict]',
        typedDictClassNotAllowed: '[Vgl7x][TypedDict lss t llw fr st r lss hks]',
        typedDictClosedExtraNotAllowed: '[zT7Rm][t  tm "{m}"]',
        typedDictClosedExtraTypeMismatch: '[blC1e][t  tm "{m}" wth tp "{tp}"]',
        typedDictClosedFieldNotRequired: '[6rtDR][t  tm "{m}" s t mst  NotRequired]',
        typedDictExtraFieldNotAllowed: '[kFDh9]["{m}" s t prst  "{tp}"]',
        typedDictExtraFieldTypeMismatch: '[DnAhM][Tp f "{m}" s mptl wth tp f "extra_items"  "{tp}"]',
        typedDictFieldMissing: '[rNzn7]["{m}" s mssg frm "{tp}"]',
        typedDictFieldNotReadOnly: '[BJy1V]["{m}" s t r-l  "{tp}"]',
        typedDictFieldNotRequired: '[eqatW]["{m}" s t rqr  "{tp}"]',
        typedDictFieldRequired: '[ckyH4]["{m}" s rqr  "{tp}"]',
        typedDictFieldTypeMismatch: '[XYIBH][Tp "{tp}" s t ssgl t tm "{m}"]',
        typedDictFieldUndefined: '[UsDC9]["{m}" s  f tm  tp "{tp}"]',
        typedDictFinalMismatch: '[tFb04]["{srTp}" s mptl wth "{stTp}" s f  @final msmth]',
        typedDictKeyAccess: '[67DLq][s ["{m}"] t rfr tm  TypedDict]',
        typedDictNotAllowed: '[eTsPP][TypedDict t  s fr st r lss hks]',
        unhashableType: '[IJEeq][Tp "{tp}" s t hshl]',
        uninitializedAbstractVariable: '[uDuHt][st vrl "{m}" s f  strt s lss "{lssTp}" t t tlz]',
        unreachableExcept: '[3CSUL]["{xptTp}" s  slss f "{prtTp}"]',
        useDictInstead: '[LReB5][s Dict[T1, T2] t t  tr tp]',
        useListInstead: '[RPu0E][s List[T] t t  list tp r Union[T1, T2] t t  union tp]',
        useTupleInstead: '[jaFqC][s tuple[T1, ..., Tn] t t  tuple tp r Union[T1, T2] t t  union tp]',
        useTypeInstead: '[Zig8D][s Type[T] st]',
        varianceMismatchForClass: '[fqhIl][Vr f tp rgmt "{tpVrm}" s mptl wth s lss "{lssm}"]',
        varianceMismatchForTypeAlias: '[YSiVx][Vr f tp rgmt "{tpVrm}" s mptl wth "{tplsPrm}"]'
      },
      Service: {
        longOperation: '[Mvrp3][mrt f wrksp sr fls s tkg  lg tm. sr pg  s-flr st. [r mr](https://k.ms/wrksp-t-m-fls)]'
      }
    };
  },
  78483: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: ' Stub ',
        createTypeStubFor: ' Stub   "{moduleName}"',
        executingCommand: '  ',
        filesToAnalyzeCount: '{count}   ',
        filesToAnalyzeOne: '1   ',
        findingReferences: '  ',
        organizeImports: ' ',
        renameShadowedFile: ' "{oldFile}"  "{newFile}"'
      },
      Completion: {
        autoImportDetail: ' ',
        indexValueDetail: ' '
      },
      Diagnostic: {
        abstractMethodInvocation: '   "{method}",       ',
        annotatedMetadataInconsistent: '   "{metadataType}"    "{type}"',
        annotatedParamCountMismatch: '   :  {expected},   {received}',
        annotatedTypeArgMissing: ' "Annotated"          ',
        annotationBytesString: '       ',
        annotationFormatString: '         (f-)',
        annotationNotSupported: '      ',
        annotationRawString: '       ',
        annotationSpansStrings: '       ',
        annotationStringEscape: '     escape-',
        argAssignment: '  "{argType}"     "{paramType}"',
        argAssignmentFunction: '  "{argType}"     "{paramType}"   "{functionName}"',
        argAssignmentParam: '  "{argType}"    "{paramName}"  "{paramType}"',
        argAssignmentParamFunction: '  "{argType}"    "{paramName}"  "{paramType}"   "{functionName}"',
        argMissingForParam: '    {name}',
        argMissingForParams: '    {names}',
        argMorePositionalExpectedCount: '   : {expected}',
        argMorePositionalExpectedOne: '  1  ',
        argPositional: '  ',
        argPositionalExpectedCount: '  : {expected}',
        argPositionalExpectedOne: ' 1  ',
        argTypePartiallyUnknown: '   ',
        argTypeUnknown: '  ',
        assertAlwaysTrue: ' assert    true',
        assertTypeArgs: ' "assert_type"    ',
        assertTypeTypeMismatch: '  "assert_type":  "{expected}",   "{received}"',
        assignmentExprComprehension: '   "{name}"      ,      ',
        assignmentExprContext: '     ,   ',
        assignmentExprInSubscript: '         Python    3.10',
        assignmentInProtocol: '      Protocol       ',
        assignmentTargetExpr: '      ',
        asyncNotInAsyncFunction: ' "async"    async ',
        awaitIllegal: ' "await"    Python    3.5',
        awaitNotAllowed: '     "await"',
        awaitNotInAsync: '  "await"    async ',
        backticksIllegal: ',    ,    Python 3.x;     repr',
        baseClassCircular: '      ',
        baseClassFinal: '  "{type}"   final,       ',
        baseClassIncompatible: '  {type}  ',
        baseClassInvalid: '     ',
        baseClassMethodTypeIncompatible: '   "{classType}"   "{name}"  ',
        baseClassUnknown: '       ',
        baseClassVariableTypeIncompatible: '   "{classType}"   "{name}"  ',
        binaryOperationNotAllowed: '      ',
        bindTypeMismatch: '    "{methodName}", "{type}"      "{paramName}"',
        breakInExceptionGroup: '  "break"   "except*"',
        breakOutsideLoop: '"break"     ',
        callableExtraArgs: ' "Callable"     ',
        callableFirstArg: '     "..."',
        callableNotInstantiable: '    "{type}"',
        callableSecondArg: '      "Callable"   ',
        casePatternIsIrrefutable: '       case',
        classAlreadySpecialized: ' "{type}"  ',
        classDecoratorTypeUnknown: '     .  ',
        classDefinitionCycle: '   "{name}"   ',
        classGetItemClsParam: '  __class_getitem__    "cls"',
        classMethodClsParam: '     cls',
        classNotRuntimeSubscriptable: '     "{name}"    ;     ',
        classPatternBuiltInArgPositional: '      ',
        classPatternPositionalArgCount: '      "{type}";  {expected},   {received}',
        classPatternTypeAlias: '"{type}"     ,     ',
        classPropertyDeprecated: '    Python 3.11      Python 3.13',
        classTypeParametersIllegal: '       Python    3.12.',
        classVarFirstArgMissing: '    "ClassVar"',
        classVarNotAllowed: ' "ClassVar"     ',
        classVarOverridesInstanceVar: '  "{name}"          "{className}"',
        classVarTooManyArgs: '      "ClassVar"',
        classVarWithTypeVar: ' "ClassVar"     ',
        clsSelfParamTypeMismatch: '  "{name}"      "{classType}"',
        codeTooComplexToAnalyze: '    ;  ,     ( )     ',
        collectionAliasInstantiation: ' "{type}"    ,    "{alias}"',
        comparisonAlwaysFalse: '     False,   "{leftType}"  "{rightType}"  ',
        comparisonAlwaysTrue: '     True,   "{leftType}"  "{rightType}"  ',
        comprehensionInDict: '       ',
        comprehensionInSet: '       set',
        concatenateContext: '"Concatenate"     ',
        concatenateParamSpecMissing: '    "Concatenate"   ParamSpec  "..."',
        concatenateTypeArgsMissing: ' "Concatenate"       ',
        conditionalOperandInvalid: '    "{type}"',
        constantRedefinition: '"{name}"   (    )     .',
        constructorParametersMismatch: '  __new__  __init__   "{classType}"',
        containmentAlwaysFalse: '     False,    "{leftType}"  "{rightType}"  ',
        containmentAlwaysTrue: '     True,    "{leftType}"  "{rightType}"  ',
        continueInExceptionGroup: '  "continue"   "except*"',
        continueOutsideLoop: '  "continue"     ',
        coroutineInConditionalExpression: '    ,     True',
        dataClassBaseClassFrozen: '       ',
        dataClassBaseClassNotFrozen: '       ',
        dataClassConverterFunction: '  "{argType}"       "{fieldName}"  "{fieldType}"',
        dataClassConverterOverloads: '   "{funcName}"      "{fieldName}"  "{fieldType}"',
        dataClassFieldInheritedDefault: '"{fieldName}"      ,       ',
        dataClassFieldWithDefault: '             .',
        dataClassFieldWithPrivateName: '       ',
        dataClassFieldWithoutAnnotation: ' dataclass        ',
        dataClassPostInitParamCount: '     __post_init__  ;  ,    InitVar {expected}',
        dataClassPostInitType: '   __post_init__        "{fieldName}"',
        dataClassSlotsOverwrite: '__slots__    ',
        dataClassTransformExpectedBoolLiteral: ' ,    True  False',
        dataClassTransformFieldSpecifier: ' tuple   ,    "{type}"',
        dataClassTransformPositionalParam: '  "dataclass_transform"     " "',
        dataClassTransformUnknownArgument: ' "{name}"    dataclass_transform',
        dataProtocolInSubclassCheck: '  ( ,    )    issubclass',
        declaredReturnTypePartiallyUnknown: '    "{returnType}"  ',
        declaredReturnTypeUnknown: '    ',
        defaultValueContainsCall: '            ',
        defaultValueNotAllowed: '  "*"  "**"      ',
        delTargetExpr: '   ',
        deprecatedClass: ' "{name}"  ',
        deprecatedConstructor: '   "{name}"     ',
        deprecatedDescriptorDeleter: ' "__delete__"   "{name}"  ',
        deprecatedDescriptorGetter: ' "__get__"   "{name}"  ',
        deprecatedDescriptorSetter: ' "__set__"   "{name}"  ',
        deprecatedFunction: ' "{name}"     ',
        deprecatedMethod: ' "{name}"   "{className}"    ',
        deprecatedPropertyDeleter: ' deleter  property "{name}"  ',
        deprecatedPropertyGetter: ' getter  property "{name}"  ',
        deprecatedPropertySetter: ' setter  property "{name}"  ',
        deprecatedType: '          Python {version};    "{replacement}"',
        dictExpandIllegalInComprehension: '     ',
        dictInAnnotation: '      ',
        dictKeyValuePairs: '     "-"',
        dictUnpackIsNotMapping: '     ',
        dunderAllSymbolNotPresent: '"{name}"    __all__,    ',
        duplicateArgsParam: '    "*"',
        duplicateBaseClass: '    ',
        duplicateCapturePatternTarget: '   "{name}"         ',
        duplicateCatchAll: '  except     catch-all',
        duplicateEnumMember: ' Enum  "{name}"  ',
        duplicateGenericAndProtocolBase: '     Generic[...]  Protocol[...]',
        duplicateImport: '"{importName}"   ',
        duplicateKeywordOnly: '    "*"',
        duplicateKwargsParam: '    "**"',
        duplicateParam: ' "{name}" ',
        duplicatePositionOnly: '    "/"',
        duplicateStarPattern: '       "*"',
        duplicateStarStarPattern: '    "**"',
        duplicateUnpack: ' list     ',
        ellipsisAfterUnpacked: '"..."       TypeVarTuple  tuple',
        ellipsisContext: '"..."     ',
        ellipsisSecondArg: '"..."        ',
        enumClassOverride: 'Enum  "{name}"  final      ',
        enumMemberDelete: '    Enum "{name}"',
        enumMemberSet: '    Enum "{name}"',
        enumMemberTypeAnnotation: '      enum',
        exceptGroupMismatch: ' Try     "except"  "except*"',
        exceptGroupRequiresType: '    ("except*")   ',
        exceptionGroupIncompatible: '   ("except*")    Python    3.11',
        exceptionGroupTypeIncorrect: '   except*      BaseGroupException',
        exceptionTypeIncorrect: '"{type}"     BaseException',
        exceptionTypeNotClass: '"{type}"     ',
        exceptionTypeNotInstantiable: '   "{type}"     ',
        expectedAfterDecorator: '      ',
        expectedArrow: ' "->",        ',
        expectedAsAfterException: ' "as"   ',
        expectedAssignRightHandExpr: '  "="  ',
        expectedBinaryRightHandExpr: '    ',
        expectedBoolLiteral: ' True  False',
        expectedCase: '  case',
        expectedClassName: '  ',
        expectedCloseBrace: '  "{"   ',
        expectedCloseBracket: '  "["   ',
        expectedCloseParen: '  "("   ',
        expectedColon: ' ":"',
        expectedComplexNumberLiteral: '      ',
        expectedDecoratorExpr: '       Python    3.9',
        expectedDecoratorName: '  ',
        expectedDecoratorNewline: '        ',
        expectedDelExpr: ' "del"  ',
        expectedElse: '   "else"',
        expectedEquals: ' "="',
        expectedExceptionClass: '    ',
        expectedExceptionObj: '  ,     None',
        expectedExpr: ' ',
        expectedFunctionAfterAsync: '    "async"',
        expectedFunctionName: '   "def"   ',
        expectedIdentifier: ' ',
        expectedImport: ' "import"',
        expectedImportAlias: ' "as"  ',
        expectedImportSymbols: ' "import"      ',
        expectedIn: ' "in"',
        expectedInExpr: '   "in"  ',
        expectedIndentedBlock: '   ',
        expectedMemberName: '     "."',
        expectedModuleName: '  ',
        expectedNameAfterAs: '    "as"',
        expectedNamedParameter: ' "*"     " "',
        expectedNewline: '  ',
        expectedNewlineOrSemicolon: '          ',
        expectedOpenParen: ' "("',
        expectedParamName: '  ',
        expectedPatternExpr: '  ',
        expectedPatternSubjectExpr: '   ',
        expectedPatternValue: '      "a.b"',
        expectedReturnExpr: ' "return"  ',
        expectedSliceIndex: '    ',
        expectedTypeNotString: ' ,    ',
        expectedTypeParameterName: '   ',
        expectedYieldExpr: '    yield',
        finalClassIsAbstract: ' "{type}"   final ()      .',
        finalContext: '"Final"     ',
        finalInLoop: ' "Final"      ',
        finalMethodOverride: ' "{name}"    final ,    "{className}"',
        finalNonMethod: ' "{name}"    @final,      ',
        finalReassigned: '"{name}"  Final     ',
        finalRedeclaration: '"{name}"    Final',
        finalRedeclarationBySubclass: '"{name}"   ,     "{className}"    Final',
        finalTooManyArgs: ' "Final"    ',
        finalUnassigned: '"{name}"   Final,     ',
        formatStringBrace: '       f-.    ',
        formatStringBytes: '   (f-)    ',
        formatStringDebuggingIllegal: '   F- "="   Python 3.8   ',
        formatStringEscape: 'Escape- (  )      f-   Python 3.12',
        formatStringExpectedConversion: ' "!"  f-   ',
        formatStringIllegal: '    (f-)   Python 3.6   ',
        formatStringInPattern: '     ',
        formatStringNestedFormatSpecifier: '        ',
        formatStringNestedQuote: ',   f-,       ,   f-  Python 3.12',
        formatStringUnicode: '   (f-)      Unicode',
        formatStringUnterminated: '   f-;  "}"',
        functionDecoratorTypeUnknown: '     ;   ',
        functionInConditionalExpression: '    ,     True',
        functionTypeParametersIllegal: '       Python 3.12   ',
        futureImportLocationNotAllowed: '   __future__     ',
        generatorAsyncReturnType: '     async     "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: '     ,    ',
        generatorSyncReturnType: '        "Generator[{yieldType}, Any, Any]"',
        genericBaseClassNotAllowed: '  "Generic"      ',
        genericClassAssigned: '    ',
        genericClassDeleted: '     ',
        genericInstanceVariableAccess: '        ',
        genericNotAllowed: '  "Generic"    ',
        genericTypeAliasBoundTypeVar: '           {names}',
        genericTypeArgMissing: ' "Generic"       ',
        genericTypeArgTypeVar: '   "Generic"    ',
        genericTypeArgUnique: '   "Generic"   ',
        globalReassignment: ' "{name}"   global ',
        globalRedefinition: ' "{name}"     global',
        implicitStringConcat: '    ',
        importCycleDetected: '    ',
        importDepthExceeded: '    {depth}',
        importResolveFailure: '    "{importName}"',
        importSourceResolveFailure: '    "{importName}"  ',
        importSymbolUnknown: '"{name}"    ',
        incompatibleMethodOverride: ' "{name}"   "{className}"  ',
        inconsistentIndent: '     ',
        inconsistentTabs: '      ',
        initMethodSelfParamTypeVar: '    "self"  "__init__"        .',
        initMustReturnNone: ' "__init__"    None',
        initSubclassCallFailed: '      __init_subclass__',
        initSubclassClsParam: '  __init_subclass__    "cls"',
        initVarNotAllowed: ' "InitVar"     ',
        instanceMethodSelfParam: '     "self"',
        instanceVarOverridesClassVar: '  "{name}"          "{className}"',
        instantiateAbstract: '      "{type}"',
        instantiateProtocol: '     Protocol "{type}"',
        internalBindError: '   "{file}"   : {message}',
        internalParseError: '   "{file}"   : {message}',
        internalTypeCheckingError: '   "{file}"   : {message}',
        invalidIdentifierChar: '   ',
        invalidStubStatement: '      stub ',
        invalidTokenChars: '  "{text}"  ',
        isInstanceInvalidType: '  "isinstance"     tuple ',
        isSubclassInvalidType: '   "issubclass"     tuple ',
        keyValueInSet: ' "-"    set',
        keywordArgInTypeArgument: '        ',
        keywordArgShortcutIllegal: '     Python 3.14    ',
        keywordOnlyAfterArgs: '   "  "     "*"',
        keywordParameterMissing: '  "*"        .',
        keywordSubscriptIllegal: '       ',
        lambdaReturnTypePartiallyUnknown: '    "{returnType}"  ',
        lambdaReturnTypeUnknown: ' ,  , ',
        listAssignmentMismatch: '   "{type}"    ',
        listInAnnotation: 'List      ',
        literalEmptyArgs: '       "Literal"',
        literalNamedUnicodeEscape: ' escape-       Literal',
        literalNotAllowed: '  "Literal"      ',
        literalNotCallable: '     Literal',
        literalUnsupportedType: '   "Literal"    None,   (int, bool, str  bytes)   enum ',
        matchIncompatible: ' Match    Python    3.10',
        matchIsNotExhaustive: ' case   match      ',
        maxParseDepthExceeded: '   ;       ',
        memberAccess: '      "{name}"   "{type}"',
        memberDelete: '    "{name}"   "{type}"',
        memberSet: '    "{name}"   "{type}"',
        metaclassConflict: '           ',
        metaclassDuplicate: '    ',
        metaclassIsGeneric: '    ',
        methodNotDefined: ' "{name}"  ',
        methodNotDefinedOnType: ' "{name}"     "{type}"',
        methodOrdering: '     ',
        methodOverridden: '"{name}"         "{className}"    "{type}"',
        methodReturnsNonObject: ' "{name}"   ',
        missingSuperCall: ' "{methodName}"          ',
        mixingBytesAndStr: '  bytes  str ',
        moduleAsType: '      ',
        moduleNotCallable: '   ',
        moduleUnknownMember: '"{memberName}"      "{moduleName}"',
        namedExceptAfterCatchAll: '  except      catch-all except',
        namedParamAfterParamSpecArgs: '   "{name}"        ParamSpec args',
        namedTupleEmptyName: '   tuple    ',
        namedTupleEntryRedeclared: '   "{name}",     "{className}"   tuple',
        namedTupleFirstArg: '        tuple',
        namedTupleMultipleInheritance: '   NamedTuple  ',
        namedTupleNameKeyword: '      ',
        namedTupleNameType: '  tuple      ',
        namedTupleNameUnique: '   tuple   ',
        namedTupleNoTypes: '"namedtuple"      ;    "NamedTuple"',
        namedTupleSecondArg: '      list  tuple',
        newClsParam: '  __new__    "cls"',
        newTypeAnyOrUnknown: '   NewType    ,    "Any"  "Unknown"',
        newTypeBadName: '  NewType    ',
        newTypeLiteral: 'NewType     Literal',
        newTypeNameMismatch: 'NewType        ',
        newTypeNotAClass: ' NewType      ',
        newTypeParamCount: ' NewType    ',
        newTypeProtocolClass: 'NewType      ( Protocol  TypedDict)',
        noOverload: '    "{name}",   ',
        noReturnContainsReturn: '    return  "NoReturn"     return',
        noReturnContainsYield: '      "NoReturn"     yield',
        noReturnReturnsNone: '      "NoReturn"    "None"',
        nonDefaultAfterDefault: ',     ,     ',
        nonLocalInModule: 'Nonlocal      ',
        nonLocalNoBinding: '  nonlocal  "{name}"  ',
        nonLocalReassignment: ' "{name}"   nonlocal ',
        nonLocalRedefinition: '"{name}"     nonlocal',
        noneNotCallable: '  "None"    ',
        noneNotIterable: '  "None"       ',
        noneNotSubscriptable: '  "None"   ',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: ' "{operator}"    "None"',
        noneUnknownMember: '"{name}"     "None"',
        notRequiredArgCount: ' "NotRequired"    ',
        notRequiredNotInTypedDict: ' "NotRequired"     ',
        objectNotCallable: '  "{type}"   ',
        obscuredClassDeclaration: '  "{name}"      ',
        obscuredFunctionDeclaration: '  "{name}"      ',
        obscuredMethodDeclaration: '  "{name}"      ',
        obscuredParameterDeclaration: '  "{name}"      ',
        obscuredTypeAliasDeclaration: '   "{name}"      ',
        obscuredVariableDeclaration: ' "{name}"      ',
        operatorLessOrGreaterDeprecated: ' "<>"    Python 3;    "!="',
        optionalExtraArgs: '     "Optional"',
        orPatternIrrefutable: '           "or"',
        orPatternMissingName: '     "or"         ',
        overlappingKeywordArgs: '      : {names}',
        overlappingOverload: ' {obscured}  "{name}"    ,       {obscuredBy}',
        overloadAbstractImplMismatch: '     ',
        overloadAbstractMismatch: '       ',
        overloadClassMethodInconsistent: '  "{name}"  @classmethod ',
        overloadFinalInconsistencyImpl: '  "{name}"   @final,    ',
        overloadFinalInconsistencyNoImpl: ' {index}  "{name}"   @final,   1  ',
        overloadImplementationMismatch: '       {index}',
        overloadReturnTypeMismatch: ' {prevIndex}  "{name}"   {newIndex}    ',
        overloadStaticMethodInconsistent: '  "{name}"  @staticmethod ',
        overloadWithoutImplementation: '"{name}"   overload,    ',
        overriddenMethodNotFound: ' "{name}"   override,        ',
        overrideDecoratorMissing: ' "{name}"    override,      "{className}"',
        paramAfterKwargsParam: '      "**"',
        paramAlreadyAssigned: ' "{name}"  .',
        paramAnnotationMissing: '      "{name}"',
        paramAssignmentMismatch: '  "{sourceType}"       "{paramType}"',
        paramNameMissing: '   "{name}"  ',
        paramSpecArgsKwargsDuplicate: '  "{type}" ParamSpec  ',
        paramSpecArgsKwargsUsage: ' "args"  "kwargs" ParamSpec      ',
        paramSpecArgsMissing: '   "{type}" ParamSpec',
        paramSpecArgsUsage: ' "args" ParamSpec       *args',
        paramSpecAssignedName: 'ParamSpec      "{name}"',
        paramSpecContext: 'ParamSpec     ',
        paramSpecDefaultNotTuple: '  ParamSpec    ,  tuple  ParamSpec',
        paramSpecFirstArg: '  ParamSpec    ',
        paramSpecKwargsUsage: ' "kwargs" ParamSpec       **kwargs',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}"      ',
        paramSpecUnknownArg: 'ParamSpec     ',
        paramSpecUnknownMember: '"{name}"     ParamSpec',
        paramSpecUnknownParam: '"{name}"     ParamSpec',
        paramTypeCovariant: '       ',
        paramTypePartiallyUnknown: '  "{paramName}"  ',
        paramTypeUnknown: '  "{paramName}" ',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: '        "{type}"',
        positionArgAfterNamedArg: '        " "',
        positionOnlyAfterArgs: '      "*"  ',
        positionOnlyAfterKeywordOnly: ' "/"     "*"',
        positionOnlyAfterNon: '      ,     ',
        positionOnlyFirstParam: '         ',
        positionOnlyIncompatible: '       Python    3.8',
        privateImportFromPyTypedModule: '"{name}"     "{module}"',
        privateUsedOutsideOfClass: ' "{name}"  ,    ,   ',
        privateUsedOutsideOfModule: '"{name}"  ,    ,   ',
        propertyOverridden: '"{name}"   property       "{className}"',
        propertyStaticMethod: '      getter, setter  deleter property',
        protectedUsedOutsideOfClass: '"{name}"     ,    ',
        protocolBaseClass: ' Protocol "{classType}"       "{baseType}",   Protocol',
        protocolBaseClassWithTypeArgs: '      Protocol     ',
        protocolIllegal: '  "Protocol"    Python    3.7',
        protocolNotAllowed: '  "Protocol"   ',
        protocolTypeArgMustBeTypeParam: '    "Protocol"    ',
        protocolUnsafeOverlap: '   "{name}"       ',
        protocolVarianceContravariant: '  "{variable}",    Protocol "{class}",   .',
        protocolVarianceCovariant: '  "{variable}",    Protocol "{class}",   ',
        protocolVarianceInvariant: '  "{variable}",    Protocol "{class}",   ',
        pyrightCommentInvalidDiagnosticBoolValue: '   Pyright   "="   true  false',
        pyrightCommentInvalidDiagnosticSeverityValue: '   Pyright   "="     : true, false, error, warning, information  none',
        pyrightCommentMissingDirective: '  Pyright    (basic  strict)   ',
        pyrightCommentNotOnOwnLine: ' Pyright,       ,     ',
        pyrightCommentUnknownDiagnosticRule: '  "{rule}"   pyright ',
        pyrightCommentUnknownDiagnosticSeverityValue: ' "{value}"    pyright;     true, false, error, warning, information  none',
        pyrightCommentUnknownDirective: '"{directive}"      pyright;  "strict"  "basic"',
        readOnlyArgCount: '     "ReadOnly"',
        readOnlyNotInTypedDict: ' "ReadOnly"     ',
        recursiveDefinition: '    "{name}",      ',
        relativeImportNotAllowed: '         "import .a";    "from . import a"',
        requiredArgCount: '     "Required"',
        requiredNotInTypedDict: ' "Required"     ',
        returnInAsyncGenerator: ' return       async',
        returnInExceptionGroup: '  "return"   "except*"',
        returnMissing: '      "{returnType}"       ',
        returnOutsideFunction: '"return"     ',
        returnTypeContravariant: '        ',
        returnTypeMismatch: ' "{exprType}"        "{returnType}"',
        returnTypePartiallyUnknown: '   "{returnType}"  ',
        returnTypeUnknown: '   ',
        revealLocalsArgs: '     "reveal_locals"',
        revealLocalsNone: '    locals',
        revealTypeArgs: '  "reveal_type"    ',
        revealTypeExpectedTextArg: ' "expected_text"   "reveal_type"     str',
        revealTypeExpectedTextMismatch: '   ;  "{expected}",   "{received}"',
        revealTypeExpectedTypeMismatch: ' ;  "{expected}",   "{received}"',
        selfTypeContext: '\'     "Self" ',
        selfTypeMetaclass: '"Self"     ( "type")',
        selfTypeWithTypedSelfOrCls: '  "Self"       "self"  "cls"   ,   "Self".',
        setterGetterTypeMismatch: '  setter property      getter',
        singleOverload: ' "{name}"   ,    ',
        slotsAttributeError: '"{name}"    __slots__',
        slotsClassVarConflict: '"{name}"    ,   __slots__',
        starPatternInAsPattern: ' ""       "as"',
        starPatternInOrPattern: ' ""      OR   ',
        starStarWildcardNotAllowed: '**      "_"',
        staticClsSelfParam: '       "self"  "cls"',
        stdlibModuleOverridden: '"{path}"   stdlib "{name}"',
        stringNonAsciiBytes: ',   ASCII,      ',
        stringNotSubscriptable: '        ;     ',
        stringUnsupportedEscape: ' escape-   ',
        stringUnterminated: '      ',
        stubFileMissing: ' stub  "{importName}"  ',
        stubUsesGetAttr: ' stub  ; "__getattr__"     ',
        sublistParamsIncompatible: ' sublist     Python 3.x',
        superCallArgCount: '       "super"',
        superCallFirstArg: '      "super"   ,   "{type}"',
        superCallSecondArg: '    "super"     ,   "{type}"',
        superCallZeroArgForm: '  "super"       ',
        superCallZeroArgFormStaticMethod: '  "super"       ',
        symbolIsPossiblyUnbound: ' "{name}", ,  ',
        symbolIsUnbound: ' "{name}"  ',
        symbolIsUndefined: '"{name}"  ',
        symbolOverridden: '"{name}"         "{className}"',
        ternaryNotAllowed: '      ',
        totalOrderingMissingMethod: '    total_ordering,        : "__lt__", "__le__", "__gt__"  "__ge__"',
        trailingCommaInFromImport: '        ',
        tryWithoutExcept: '  try       except  finally',
        tupleAssignmentMismatch: '   "{type}"      tuple',
        tupleInAnnotation: ' tuple     ',
        tupleIndexOutOfRange: ' {index}        {type}',
        typeAliasIllegalExpressionForm: '      ',
        typeAliasIsRecursiveDirect: '  "{name}"       ',
        typeAliasNotInModuleOrClass: 'TypeAlias        ',
        typeAliasRedeclared: '"{name}"   TypeAlias       ',
        typeAliasStatementBadScope: ' type        ',
        typeAliasStatementIllegal: '      Python    3.12',
        typeAliasTypeBaseClass: ' ,    "type",       .',
        typeAliasTypeMustBeAssigned: 'TypeAliasType        ,    ',
        typeAliasTypeNameArg: '  TypeAliasType    ,    ',
        typeAliasTypeNameMismatch: '      ,   ',
        typeAliasTypeParamInvalid: '     tuple,   TypeVar, TypeVarTuple  ParamSpec',
        typeAnnotationCall: '      ',
        typeAnnotationVariable: '     ',
        typeAnnotationWithCallable: '   "type"   .    ',
        typeArgListExpected: ' ParamSpec,   list ',
        typeArgListNotAllowed: ' list      ',
        typeArgsExpectingNone: '  "{name}"    ',
        typeArgsMismatchOne: '   ,   {received}',
        typeArgsMissingForAlias: '    "{name}"   ',
        typeArgsMissingForClass: '      "{name}"',
        typeArgsTooFew: '      "{name}";  {expected},   {received}',
        typeArgsTooMany: ' "{name}"     .  {expected},   {received}',
        typeAssignmentMismatch: ' "{sourceType}"       "{destType}"',
        typeAssignmentMismatchWildcard: '  "{name}"   "{sourceType}",        "{destType}"',
        typeCallNotAllowed: ' type()     ',
        typeCheckOnly: '"{name}"   @type_check_only        ',
        typeCommentDeprecated: ' type     ;     type',
        typeExpectedClass: ' ,   "{type}"',
        typeFormArgs: '"TypeForm"    ',
        typeGuardArgCount: ' "TypeGuard"  "TypeIs"    ',
        typeGuardParamCount: '              ',
        typeIsReturnType: '   TypeIs ("{returnType}")      ("{type}")',
        typeNotAwaitable: '"{type}"   awaitable',
        typeNotIntantiable: '    "{type}"',
        typeNotIterable: '"{type}"   ',
        typeNotSpecializable: '    "{type}"',
        typeNotSubscriptable: '  "{type}"     ',
        typeNotSupportBinaryOperator: ' "{operator}"     "{leftType}"  "{rightType}"',
        typeNotSupportBinaryOperatorBidirectional: ' "{operator}"     "{leftType}"  "{rightType}",     "{expectedType}"',
        typeNotSupportUnaryOperator: ' "{operator}"     "{type}"',
        typeNotSupportUnaryOperatorBidirectional: ' "{operator}"     "{type}",    "{expectedType}"',
        typeNotUsableWith: '  "{type}"      "with",       {method}',
        typeParameterBoundNotAllowed: '        variadic  ParamSpec',
        typeParameterConstraintTuple: '         ',
        typeParameterExistingTypeParameter: '  "{name}"  ',
        typeParameterNotDeclared: '  "{name}"         "{container}"',
        typeParametersMissing: '      ',
        typePartiallyUnknown: ' "{name}"  ',
        typeUnknown: ' "{name}" ',
        typeVarAssignedName: 'TypeVar      "{name}"',
        typeVarAssignmentMismatch: ' "{type}"       "{name}"',
        typeVarBoundAndConstrained: 'TypeVar       ',
        typeVarBoundGeneric: '  TypeVar    ',
        typeVarConstraintGeneric: '  TypeVar    ',
        typeVarDefaultBoundMismatch: '   TypeVar     ',
        typeVarDefaultConstraintMismatch: '   TypeVar      ',
        typeVarDefaultIllegal: '       Python 3.13   ',
        typeVarDefaultInvalidTypeVar: '  "{name}"    ,        ,   ',
        typeVarFirstArg: '      TypeVar',
        typeVarInvalidForMemberVariable: '      "{name}"   ',
        typeVarNoMember: ' TypeVar "{type}"   "{name}"',
        typeVarNotSubscriptable: '    "{type}" TypeVar',
        typeVarNotUsedByOuterScope: '  "{name}"      ',
        typeVarPossiblyUnsolvable: '  "{name}"   ,         "{param}"',
        typeVarSingleConstraint: 'TypeVar       ',
        typeVarTupleConstraints: 'TypeVarTuple     ',
        typeVarTupleContext: 'TypeVarTuple     ',
        typeVarTupleDefaultNotUnpacked: '   TypeVarTuple    tuple  TypeVarTuple',
        typeVarTupleMustBeUnpacked: '  TypeVarTuple   ',
        typeVarTupleUnknownParam: '"{name}"     TypeVarTuple',
        typeVarUnknownParam: '"{name}"     TypeVar',
        typeVarUsedByOuterScope: 'TypeVar "{name}"    ',
        typeVarUsedOnlyOnce: 'TypeVar "{name}"        ',
        typeVarVariance: 'TypeVar       ',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}"          TypeVarTuple "{variadicName}"',
        typeVarWithoutDefault: '"{name}"     "{other}"    ,        ',
        typeVarsNotInGenericOrProtocol: 'Generic[]  Protocol[]     ',
        typedDictAccess: '       TypedDict',
        typedDictAssignedName: 'TypedDict      "{name}"',
        typedDictBadVar: ' TypedDict      ',
        typedDictBaseClass: '     TypedDict     TypedDict',
        typedDictBoolParam: '  "{name}"   True  False',
        typedDictClosedExtras: '  "{name}"   closed TypedDict;      "{type}"',
        typedDictClosedNoExtras: '  "{name}"   closed TypedDict;    ',
        typedDictDelete: '     TypedDict',
        typedDictEmptyName: '  TypedDict    ',
        typedDictEntryName: '      ',
        typedDictEntryUnique: '     ',
        typedDictExtraArgs: '  TypedDict  ',
        typedDictExtraItemsClosed: 'TypedDict    "closed",     ',
        typedDictFieldNotRequiredRedefinition: ' TypedDict "{name}"    NotRequired',
        typedDictFieldReadOnlyRedefinition: ' TypedDict "{name}"     ReadOnly',
        typedDictFieldRequiredRedefinition: ' TypedDict "{name}"    Required',
        typedDictFirstArg: '       TypedDict',
        typedDictInClassPattern: ' TypedDict     ',
        typedDictInitsubclassParameter: 'TypedDict    __init_subclass__ "{name}"',
        typedDictNotAllowed: '  "TypedDict"   ',
        typedDictSecondArgDict: '     dict   ',
        typedDictSecondArgDictEntry: '   ',
        typedDictSet: '     TypedDict',
        unaccessedClass: '    "{name}"',
        unaccessedFunction: '   "{name}"  ',
        unaccessedImport: '   "{name}"  ',
        unaccessedSymbol: '  "{name}"  ',
        unaccessedVariable: '   "{name}"  ',
        unannotatedFunctionSkipped: '  "{name}" ,     .',
        unaryOperationNotAllowed: '      ',
        unexpectedAsyncToken: ' "async"  "def", "with"  "for"',
        unexpectedExprToken: '    ',
        unexpectedIndent: ' ',
        unexpectedUnindent: '  ',
        unhashableDictKey: '    ',
        unhashableSetEntry: ' set   ',
        uninitializedAbstractVariables: ',     ,    final  "{classType}"',
        uninitializedInstanceVariable: '  "{name}"      ,    __init__',
        unionForwardReferenceNotAllowed: ' Union      ;     ',
        unionSyntaxIllegal: '       Python   3.10',
        unionTypeArgCount: ' Union      ',
        unionUnpackedTuple: 'Union     tuple',
        unionUnpackedTypeVarTuple: 'Union     TypeVarTuple',
        unnecessaryCast: '  "cast";    "{type}"',
        unnecessaryIsInstanceAlways: '  isinstance; "{testType}"    "{classType}"',
        unnecessaryIsInstanceNever: '  isinstance; "{testType}"     "{classType}"',
        unnecessaryIsSubclassAlways: '  issubclass. "{testType}"    "{classType}"',
        unnecessaryIsSubclassNever: '  issubclass; "{testType}"     "{classType}"',
        unnecessaryPyrightIgnore: '  "# pyright: ignore"',
        unnecessaryPyrightIgnoreRule: '  "# pyright: ignore": "{name}"',
        unnecessaryTypeIgnore: '  "# type: ignore"',
        unpackArgCount: '     "Unpack"',
        unpackExpectedTypeVarTuple: '     Unpack   TypeVarTuple  tuple',
        unpackExpectedTypedDict: '   TypedDict  Unpack',
        unpackIllegalInComprehension: '     ',
        unpackInAnnotation: '      ',
        unpackInDict: '     ',
        unpackInSet: '     set',
        unpackNotAllowed: 'Unpack    ',
        unpackOperatorNotAllowed: '     ',
        unpackTuplesIllegal: '       Python    3.8',
        unpackedArgInTypeArgument: '      ',
        unpackedArgWithVariadicParam: '      TypeVarTuple',
        unpackedDictArgumentNotMapping: '   **       "str".',
        unpackedDictSubscriptIllegal: '        ',
        unpackedSubscriptIllegal: '         Python    3.11',
        unpackedTypeVarTupleExpected: '  TypeVarTuple;  Unpack[{name1}]  *{name2}',
        unpackedTypedDictArgument: '     TypedDict  ',
        unreachableCode: ' ',
        unreachableCodeType: '  ,   ',
        unreachableExcept: ' Except ,     ',
        unsupportedDunderAllOperation: '  "__all__"  ,       ',
        unusedCallResult: '      "{type}"   .   "_",    ',
        unusedCoroutine: '  async   ;    "await"    ',
        unusedExpression: '   ',
        varAnnotationIllegal: ' type      Python    3.6.          .',
        variableFinalOverride: ' "{name}"   Final   non-Final        "{className}"',
        variadicTypeArgsTooMany: '          TypeVarTuple  tuple',
        variadicTypeParamTooManyAlias: '         TypeVarTuple,    ({names})',
        variadicTypeParamTooManyClass: '         TypeVarTuple,    ({names})',
        walrusIllegal: ' ":="    Python    3.8',
        walrusNotAllowed: ' ":="         ',
        wildcardInFunction: 'import        ',
        wildcardLibraryImport: 'import     ',
        wildcardPatternTypePartiallyUnknown: ',   ,  ',
        wildcardPatternTypeUnknown: ',   , ',
        yieldFromIllegal: '"yield from"    Python    3.3',
        yieldFromOutsideAsync: '"yield from"    async ',
        yieldOutsideFunction: '"yield"       -',
        yieldWithinComprehension: '"yield"    ',
        zeroCaseStatementsFound: ' match        case',
        zeroLengthTupleNotAllowed: 'tuple       '
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '  "Annotated"       ',
        argParam: '   "{paramName}"',
        argParamFunction: '   "{paramName}"  "{functionName}"',
        argsParamMissing: '  "*{paramName}"   ',
        argsPositionOnly: '   .  {expected},   {received}',
        argumentType: '    "{type}"',
        argumentTypes: ' : ({types})',
        assignToNone: '       "None"',
        asyncHelp: '    "async with"?',
        baseClassIncompatible: '  "{baseClass}"    "{type}"',
        baseClassIncompatibleSubclass: '  "{baseClass}"    "{subclass}",     "{type}"',
        baseClassOverriddenType: '  "{baseClass}"   "{type}",  ',
        baseClassOverridesType: '  "{baseClass}"   "{type}"',
        bytesTypePromotions: '   disableBytesTypePromotions  false,      "bytearray"  "memoryview"',
        conditionalRequiresBool: ' __bool__   "{operandType}"   "{boolReturnType}",   "bool"',
        dataClassFieldLocation: ' ',
        dataClassFrozen: ' "{name}" ',
        dataProtocolUnsupported: '"{name}"   ',
        descriptorAccessBindingFailed: '    "{name}"    "{className}"',
        descriptorAccessCallFailed: '    "{name}"    "{className}"',
        finalMethod: 'Final ',
        functionParamDefaultMissing: '  "{name}"    .',
        functionParamName: '  : "{destName}"  "{srcName}"',
        functionParamPositionOnly: '   ;  "{name}"    ',
        functionReturnTypeMismatch: '    "{sourceType}"    "{destType}"',
        functionTooFewParams: '     ;  {expected},   {received}',
        functionTooManyParams: '     ;  {expected},   {received}',
        genericClassNotAllowed: '          ',
        incompatibleDeleter: ' deleter property  ',
        incompatibleGetter: '  getter property',
        incompatibleSetter: ' setter property  ',
        initMethodLocation: ' __init__    "{type}"',
        initMethodSignature: ' __init__  "{type}"',
        initSubclassLocation: ' __init_subclass__    "{name}"',
        invariantSuggestionDict: '    "dict"  "Mapping",     .',
        invariantSuggestionList: '    "list"  "Sequence",  .',
        invariantSuggestionSet: '    "set"  "Container",   ',
        isinstanceClassNotSupported: '"{type}"       ',
        keyNotRequired: '"{name}"      "{type}",        ',
        keyReadOnly: '"{name}"       "{type}"',
        keyRequiredDeleted: '"{name}"       ',
        keyUndefined: '"{name}"      "{type}"',
        kwargsParamMissing: '  "**{paramName}"   ',
        listAssignmentMismatch: ' "{type}"    ',
        literalAssignmentMismatch: '"{sourceType}"    "{destType}"',
        matchIsNotExhaustiveHint: '    ,  "case _: pass"',
        matchIsNotExhaustiveType: ' "{type}"  ',
        memberAssignment: '  "{type}"      "{name}"  "{classType}"',
        memberIsAbstract: '  "{type}.{name}".',
        memberIsAbstractMore: '  {{count}}...',
        memberIsClassVarInProtocol: '"{name}"    ClassVar  ',
        memberIsInitVar: '"{name}"     init-only',
        memberIsInvariant: ' "{name}" ,    mutable',
        memberIsNotClassVarInClass: '  "{name}"  ClassVar    .',
        memberIsNotClassVarInProtocol: '"{name}"     ClassVar  ',
        memberIsNotReadOnlyInProtocol: '"{name}"        ',
        memberIsReadOnlyInProtocol: '"{name}"     ',
        memberIsWritableInProtocol: '"{name}"     ',
        memberSetClassVar: ' "{name}"       ,    ClassVar',
        memberTypeMismatch: '"{name}"   ',
        memberUnknown: ' "{name}" ',
        metaclassConflict: ' "{metaclass1}"   "{metaclass2}"',
        missingDeleter: '  deleter property',
        missingGetter: '  getter property',
        missingSetter: '  setter property',
        namedParamMissingInDest: '  "{name}"',
        namedParamMissingInSource: '    "{name}".',
        namedParamTypeMismatch: '   "{name}"  "{sourceType}"    "{destType}"',
        namedTupleNotAllowed: 'NamedTuple        ',
        newMethodLocation: ' __new__    "{type}"',
        newMethodSignature: '  __new__  "{type}"',
        newTypeClassNotAllowed: ',   NewType,       ',
        noOverloadAssignable: '  ,   "{type}"',
        noneNotAllowed: 'None       ',
        orPatternMissingName: ' : {name}',
        overloadIndex: ' : {index} ',
        overloadNotAssignable: '    "{name}"   ',
        overloadSignature: '   ',
        overriddenMethod: ' ',
        overriddenSymbol: ' ',
        overrideInvariantMismatch: '  "{overrideType}"      "{baseType}"',
        overrideIsInvariant: ' ,     ',
        overrideNoOverloadMatches: '    ,    ',
        overrideNotClassMethod: '    classmethod,     ',
        overrideNotInstanceMethod: '     ,     ',
        overrideNotStaticMethod: '    staticmethod,     ',
        overrideOverloadNoMatch: '      ',
        overrideOverloadOrder: '         ,     ',
        overrideParamKeywordNoDefault: '    "{name}":       ,    ',
        overrideParamKeywordType: '     "{name}":     "{baseType}",     "{overrideType}"',
        overrideParamName: '   {index}:    "{baseName}",    "{overrideName}"',
        overrideParamNameExtra: ' "{name}"    ',
        overrideParamNameMissing: ' "{name}"   ',
        overrideParamNamePositionOnly: '  {index}:   "{baseName}"    ,      ',
        overrideParamNoDefault: '  {index}:       ,    ',
        overrideParamType: '   {index}:     "{baseType}",     "{overrideType}"',
        overridePositionalParamCount: '   .    {baseCount},    {overrideCount}',
        overrideReturnType: '   :     "{baseType}",    "{overrideType}"',
        overrideType: '     "{type}"',
        paramAssignment: ' {index}:  "{sourceType}"    "{destType}"',
        paramSpecMissingInOverride: '     ParamSpec.',
        paramType: '    "{paramType}"',
        privateImportFromPyTypedSource: '     "{module}"',
        propertyAccessFromProtocolClass: ',    ,       .',
        propertyMethodIncompatible: ' property "{name}" ',
        propertyMethodMissing: ' property "{name}"   ',
        propertyMissingDeleter: ' property "{name}"    deleter',
        propertyMissingSetter: ' property "{name}"    setter',
        protocolIncompatible: '"{sourceType}"    "{destType}"',
        protocolMemberMissing: '"{name}" .',
        protocolRequiresRuntimeCheckable: ' Protocol   @runtime_checkable,          ',
        protocolSourceIsNotConcrete: '"{sourceType}"            "{destType}"',
        protocolUnsafeOverlap: ' "{name}"    ,   ',
        pyrightCommentIgnoreTip: '        "# pyright: ignore[<diagnostic rules>]"',
        readOnlyAttribute: ' "{name}"    ',
        seeClassDeclaration: '.  ',
        seeDeclaration: '. ',
        seeFunctionDeclaration: '.  ',
        seeMethodDeclaration: '.  ',
        seeParameterDeclaration: '  ',
        seeTypeAliasDeclaration: '   ',
        seeVariableDeclaration: '  ',
        tupleAssignmentMismatch: ' "{type}"    tuple',
        tupleEntryTypeMismatch: ' tuple {entry}   ',
        tupleSizeIndeterminateSrc: '  tuple:  "{expected}",    ',
        tupleSizeIndeterminateSrcDest: '  tuple:  {expected}  ,    ',
        tupleSizeMismatch: '  tuple:  "{expected}",   "{received}"',
        tupleSizeMismatchIndeterminateDest: '  tuple:  {expected}  ,   {received}',
        typeAliasInstanceCheck: ' ,   "type",        .',
        typeAssignmentMismatch: '"{sourceType}"     "{destType}"',
        typeBound: ' "{sourceType}"       "{destType}"    "{name}"',
        typeConstrainedTypeVar: ' "{type}"        "{name}"',
        typeIncompatible: '"{sourceType}"   "{destType}"',
        typeNotClass: '"{type}"   .',
        typeNotStringLiteral: '"{type}"    ',
        typeOfSymbol: ' "{name}"  "{type}"',
        typeParamSpec: ' "{type}"   ParamSpec "{name}"',
        typeUnsupported: ' "{type}"  ',
        typeVarDefaultOutOfScope: '  "{name}"    ',
        typeVarIsContravariant: '  "{name}"  ,  "{sourceType}"    "{destType}"',
        typeVarIsCovariant: '  "{name}"  ,  "{sourceType}"    "{destType}"',
        typeVarIsInvariant: '  "{name}"  ,  "{sourceType}"    "{destType}"',
        typeVarNotAllowed: 'TypeVar       ',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple     tuple  ',
        typeVarUnnecessarySuggestion: '   {type}',
        typeVarUnsolvableRemedy: ' ,     ,    ',
        typeVarsMissing: '  : {names}',
        typedDictBaseClass: ' "{type}"   TypedDict',
        typedDictClassNotAllowed: ' TypedDict       ',
        typedDictClosedExtraNotAllowed: '    "{name}"',
        typedDictClosedExtraTypeMismatch: '    "{name}"  "{type}"',
        typedDictClosedFieldNotRequired: '    "{name}",        NotRequired',
        typedDictExtraFieldNotAllowed: ' "{name}"    "{type}"',
        typedDictExtraFieldTypeMismatch: ' "{name}"    "extra_items"  "{type}"',
        typedDictFieldMissing: '"{name}"   "{type}"',
        typedDictFieldNotReadOnly: '"{name}"    "{type}"   ',
        typedDictFieldNotRequired: '"{name}"     "{type}"',
        typedDictFieldRequired: '"{name}"    "{type}"',
        typedDictFieldTypeMismatch: ' "{type}"    "{name}"',
        typedDictFieldUndefined: ' "{name}"     "{type}"',
        typedDictFinalMismatch: '"{sourceType}"   "{destType}" -  @final',
        typedDictKeyAccess: ' ["{name}"]      TypedDict',
        typedDictNotAllowed: 'TypedDict        ',
        unhashableType: ' "{type}"   ',
        uninitializedAbstractVariable: '  "{name}"      "{classType}",   ',
        unreachableExcept: '"{exceptionType}"   "{parentType}"',
        useDictInstead: ' Dict[T1, T2]    ',
        useListInstead: ' List[T]    list  Union[T1, T2]    union',
        useTupleInstead: '  tuple[T1, ..., Tn],    tuple,  Union[T1, T2],    union',
        useTypeInstead: '   Type[T]',
        varianceMismatchForClass: '   "{typeVarName}"     "{className}"',
        varianceMismatchForTypeAlias: '   "{typeVarName}"   "{typeAliasParam}"'
      },
      Service: {
        longOperation: '       .       . [](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  83132: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: 'Create Type Stub',
        createTypeStubFor: 'Create Type Stub For "{moduleName}"',
        executingCommand: 'Komut yrtlyor',
        filesToAnalyzeCount: 'analiz edilecek {count} dosya var',
        filesToAnalyzeOne: 'Analiz edilecek 1 dosya',
        findingReferences: 'Bavurular bulunuyor',
        organizeImports: 'eri Aktarmalar Dzenle',
        renameShadowedFile: '"{oldFile}" dosyasn "{newFile}" olarak yeniden adlandr'
      },
      Completion: {
        autoImportDetail: 'Otomatik ieri aktarma',
        indexValueDetail: 'Dizin deeri'
      },
      Diagnostic: {
        abstractMethodInvocation: '"{method}" metodu soyut veya uygulanmam olduundan arlamaz',
        annotatedMetadataInconsistent: '"{metadataType}" not eklenmi meta veri tr "{type}" tryle uyumlu deil',
        annotatedParamCountMismatch: 'Parametre ek aklama says uyumazl: {expected} bekleniyordu ancak {received} alnd',
        annotatedTypeArgMissing: '"Annotated" iin bir tr bamsz deikeni ve bir veya daha fazla ek aklama bekleniyordu',
        annotationBytesString: 'Tr ifadeleri bayt sabit deerli dizeleri kullanamaz',
        annotationFormatString: 'Tr ifadeleri biim dizesi sabit deerlerini (f-strings) kullanamaz',
        annotationNotSupported: 'Tr ek aklamas bu deyim iin desteklenmiyor',
        annotationRawString: 'Tr ifadeleri ham dize sabit deerlerini kullanamaz',
        annotationSpansStrings: 'Tr ifadeleri birden ok dize sabit deerine yaylamaz',
        annotationStringEscape: 'Tr ifadeleri ka karakterleri ieremez',
        argAssignment: '"{argType}" trnde bamsz deiken, "{paramType}" trndeki parametreye atanamaz',
        argAssignmentFunction: '"{argType}" trnde bamsz deiken, "{functionName}" ilevi iinde "{paramType}" trndeki parametreye atanamaz',
        argAssignmentParam: '"{argType}" trnde bamsz deiken, "{paramName}" trndeki "{paramType}" parametresine atanamaz',
        argAssignmentParamFunction: '"{argType}" trnde bamsz deiken, "{functionName}" ilevi iinde "{paramName}" trndeki "{paramType}" parametresine atanamaz',
        argMissingForParam: '{name} parametresi iin bamsz deiken eksik',
        argMissingForParams: '{names} parametrelerinin bamsz deikenleri eksik',
        argMorePositionalExpectedCount: '{expected} tane daha konumsal bamsz deiken bekleniyordu',
        argMorePositionalExpectedOne: '1 tane daha konumsal bamsz deiken bekleniyordu',
        argPositional: 'Konumsal bamsz deiken bekleniyordu',
        argPositionalExpectedCount: '{expected} konumsal bamsz deiken bekleniyordu',
        argPositionalExpectedOne: '1 konumsal bamsz deiken bekleniyordu',
        argTypePartiallyUnknown: 'Bamsz deiken tr ksmen bilinmiyor',
        argTypeUnknown: 'Bamsz deiken tr bilinmiyor',
        assertAlwaysTrue: 'Assert ifadesi her zaman true olarak deerlendirilir',
        assertTypeArgs: '"assert_type" iki konumsal bamsz deiken bekliyor',
        assertTypeTypeMismatch: '"assert_type" uyumuyor; "{expected}" bekleniyordu ancak "{received}" alnd',
        assignmentExprComprehension: '"{name}" atama ifadesi hedefi, hedef iin anlama ile ayn ad kullanamaz',
        assignmentExprContext: 'Atama ifadesi modl, ilev veya lambda iinde olmaldr',
        assignmentExprInSubscript: 'Bir alt simge iindeki atama ifadeleri yalnzca Python 3.10 ve daha yeni srmlerinde desteklenir',
        assignmentInProtocol: 'Instance or class variables within a Protocol class must be explicitly declared within the class body',
        assignmentTargetExpr: 'fade, atama hedefi olamaz',
        asyncNotInAsyncFunction: 'Use of "async" not allowed outside of async function',
        awaitIllegal: '"await" kullanm iin Python 3.5 veya daha yeni bir srm gerekiyor',
        awaitNotAllowed: 'Tr ifadeleri "await" kullanamaz',
        awaitNotInAsync: '"await" allowed only within async function',
        backticksIllegal: 'Eski kesme iaretleri arasnda yer almayan ifadeler Python3.xde desteklenmiyor; bunun yerine repr kullann',
        baseClassCircular: 'Snf kendi trevi olamaz',
        baseClassFinal: '"{type}" temel snf final olarak iaretlendi ve alt snf olamaz',
        baseClassIncompatible: '{type} trndeki temel snflar karlkl olarak uyumsuzdur',
        baseClassInvalid: 'Snfn bamsz deikeni bir temel snf olmaldr',
        baseClassMethodTypeIncompatible: '"{classType}" snfna ait temel snflar, "{name}" metodunu uyumsuz bir ekilde tanmlyor',
        baseClassUnknown: 'Temel snf tr bilinmiyor, tretilmi snf gizliyor',
        baseClassVariableTypeIncompatible: '"{classType}" snf iin temel snflar, "{name}" deikenini uyumsuz bir ekilde tanmlyor',
        binaryOperationNotAllowed: 'Tr ifadesinde ikili ile kullanlamaz',
        bindTypeMismatch: '"{type}", "{paramName}" parametresine atanamadndan "{methodName}" metodu balanamad',
        breakInExceptionGroup: '"except*" blounda "break" kullanlamaz',
        breakOutsideLoop: '"break" yalnzca bir dng iinde kullanlabilir',
        callableExtraArgs: '"Callable" iin yalnzca iki tr bamsz deikeni bekleniyordu',
        callableFirstArg: 'Parametre tr listesi veya "..." bekleniyordu',
        callableNotInstantiable: '"{type}" trnn rnei oluturulamyor',
        callableSecondArg: '"Callable" iin ikinci tr bamsz deikeni olarak dn tr bekleniyordu',
        casePatternIsIrrefutable: 'Reddedilemez desene yalnzca son case deyimi iin izin verilir',
        classAlreadySpecialized: '"{type}" tr zaten zelletirilmi',
        classDecoratorTypeUnknown: 'Tr belirtilmemi snf dekoratr snf trn gizliyor; dekoratr yoksaylyor',
        classDefinitionCycle: '"{name}" iin snf tanm kendisine baml',
        classGetItemClsParam: '__class_getitem__ geersiz klmas bir "cls" parametresi almal',
        classMethodClsParam: 'Snf metotlar bir "cls" parametresi almaldr',
        classNotRuntimeSubscriptable: '"{name}" snfna ait alt simge alma zaman zel durumunu oluturur; tr ifadelerini trnak iine aln',
        classPatternBuiltInArgPositional: 'Snf deseni yalnzca konumsal alt desen kabul eder',
        classPatternPositionalArgCount: '"{type}" snf iin ok fazla konumsal desen var; {expected} bekleniyordu ancak {received} alnd',
        classPatternTypeAlias: '"{type}" zel bir tr dier ad olduundan snf deseninde kullanlamaz',
        classPropertyDeprecated: 'Snf zellikleri Python 3.11\'de kullanm ddr ve Python 3.13\'te desteklenmez',
        classTypeParametersIllegal: 'Snf tr parametresi sz dizimi iin Python 3.12 veya daha yeni bir srm gerekiyor',
        classVarFirstArgMissing: '"ClassVar" sonrasnda tr bamsz deikeni bekleniyordu',
        classVarNotAllowed: 'Bu balamda "ClassVar" kullanmna izin verilmiyor',
        classVarOverridesInstanceVar: '"{name}" snf deikeni "{className}" snfndaki ayn ada sahip rnek deikenini geersiz klyor',
        classVarTooManyArgs: '"ClassVar" sonrasnda yalnzca bir tr bamsz deikeni bekleniyordu',
        classVarWithTypeVar: '"ClassVar" tr tr deikenleri ieremez',
        clsSelfParamTypeMismatch: '"{name}" parametre tr, "{classType}" snfnn st tr olmaldr',
        codeTooComplexToAnalyze: 'Kod analiz edilemeyecek kadar karmak; alt yordamlara ayrarak yeniden dzenleyip veya koullu kod yollarn azaltarak karmakl azaltn',
        collectionAliasInstantiation: '"{type}" trndeki rnek oluturulamyor, bunun yerine "{alias}" kullann',
        comparisonAlwaysFalse: '"{leftType}" trleri ve "{rightType}" trleri akmadndan koul her zaman False olarak deerlendirilir',
        comparisonAlwaysTrue: '"{leftType}" ve "{rightType}" trleri akmadndan ifade her zaman True olarak deerlendirilir',
        comprehensionInDict: 'Anlama dier kme girdileri ile kullanlamaz',
        comprehensionInSet: 'Comprehension cannot be used with other set entries',
        concatenateContext: 'Bu balamda "Concatenate" kullanlamaz',
        concatenateParamSpecMissing: '"Concatenate" iin son tr bamsz deikeni bir ParamSpec veya "..." olmaldr',
        concatenateTypeArgsMissing: '"Concatenate" requires at least two type arguments',
        conditionalOperandInvalid: '"{type}" trndeki koullu ilenen geersiz',
        constantRedefinition: '"{name}" sabit (byk harf olduundan) ve yeniden tanmlanamaz',
        constructorParametersMismatch: '"{classType}" snfndaki __new__ ve __init__ imzalar arasnda uyumazlk var',
        containmentAlwaysFalse: '"{leftType}" trleri ve "{rightType}" trleri akmadndan ifade her zaman False olarak deerlendirilir',
        containmentAlwaysTrue: '"{leftType}" trleri ve "{rightType}" trleri akmadndan ifade her zaman True olarak deerlendirilir',
        continueInExceptionGroup: '"except*" blounda "continue" kullanlamaz',
        continueOutsideLoop: '"continue" yalnzca bir dng iinde kullanlabilir',
        coroutineInConditionalExpression: 'Koullu ifade, her zaman True olarak deerlendirilen e yordama bavurur',
        dataClassBaseClassFrozen: 'Dondurulmu olmayan bir snf dondurulmu bir snftan devralamaz',
        dataClassBaseClassNotFrozen: 'Dondurulmu snf, dondurulmu olmayan bir snftan devralamaz',
        dataClassConverterFunction: '"{argType}" trndeki bamsz deiken, "{fieldName}" trndeki "{fieldType}" alan iin geerli bir dntrc deil',
        dataClassConverterOverloads: '"{funcName}" ilevinin ar yklemelerinden hibiri "{fieldType}" trndeki "{fieldName}" alan iin geerli dntrcler deil',
        dataClassFieldInheritedDefault: '"{fieldName}", ayn ada sahip bir alan geersiz klyor ancak varsaylan deeri yok',
        dataClassFieldWithDefault: 'Varsaylan deerleri olmayan alanlar, varsaylan deerleri olan alanlardan sonra gelemez',
        dataClassFieldWithPrivateName: 'Veri snf alan zel ad kullanamyor',
        dataClassFieldWithoutAnnotation: 'Tr ek aklamas olmayan veri snf alan alma zaman zel durumuna neden olur',
        dataClassPostInitParamCount: 'Veri snf __post_init__ parametre says yanl; InitVar alanlarnn says {expected}',
        dataClassPostInitType: 'Veri snf __post_init__ metodu parametre tr ile "{fieldName}" alan uyumuyor',
        dataClassSlotsOverwrite: '__slots__ zaten snfta tanml',
        dataClassTransformExpectedBoolLiteral: 'Statik olarak True veya False olarak deerlendirilen ifade bekleniyordu',
        dataClassTransformFieldSpecifier: 'Expected tuple of classes or functions but received type "{type}"',
        dataClassTransformPositionalParam: '"dataclass_transform" iin tm bamsz deikenlerin anahtar szck bamsz deikenleri olmas gerekiyor',
        dataClassTransformUnknownArgument: '"{name}" bamsz deikeni, dataclass_transform tarafndan desteklenmiyor',
        dataProtocolInSubclassCheck: 'issubclass arlarnda veri protokollerine (yntem d znitelikler dahil) izin verilmez',
        declaredReturnTypePartiallyUnknown: 'Bildirilen "{returnType}" dn tr ksmen bilinmiyor',
        declaredReturnTypeUnknown: 'Bildirilen dn tr bilinmiyor',
        defaultValueContainsCall: 'Parametre varsaylan deer ifadesinde ilev arlarna ve deitirilebilir nesnelere izin verilmez',
        defaultValueNotAllowed: '"*" veya "**" olan parametre varsaylan deere sahip olamaz',
        delTargetExpr: 'fade silinemiyor',
        deprecatedClass: '"{name}" snf kullanm d',
        deprecatedConstructor: '"{name}" snfnn oluturucusu kullanm d',
        deprecatedDescriptorDeleter: '"{name}" tanmlaycs iin "__delete__" yntemi kullanm d',
        deprecatedDescriptorGetter: '"{name}" tanmlaycs iin "__get__" yntemi kullanm d',
        deprecatedDescriptorSetter: '"{name}" tanmlaycs iin "__set__" yntemi kullanm d',
        deprecatedFunction: '"{name}" ilevi kullanm d',
        deprecatedMethod: '"{className}" snfndaki "{name}" yntemi kullanm d',
        deprecatedPropertyDeleter: '"{name}" property deleter kullanm d',
        deprecatedPropertyGetter: '"{name}" property getter kullanm d',
        deprecatedPropertySetter: '"{name}" property setter kullanm d',
        deprecatedType: 'Bu tr Python {version} srmnden itibaren kullanm d; bunun yerine "{replacement}" kullann',
        dictExpandIllegalInComprehension: 'Szlk geniletmeye anlamada izin verilmiyor',
        dictInAnnotation: 'Tr ifadesinde szlk ifadesi kullanlamaz',
        dictKeyValuePairs: 'Szlk girdileri anahtar/deer iftleri iermelidir',
        dictUnpackIsNotMapping: 'Szlk ama ileci iin eleme bekleniyordu',
        dunderAllSymbolNotPresent: '"{name}" __all__ ile belirtildi ancak modlde yok',
        duplicateArgsParam: 'Yalnzca bir "*" parametresi kullanlabilir',
        duplicateBaseClass: 'Yinelenen temel snfa izin verilmiyor',
        duplicateCapturePatternTarget: '"{name}" yakalama hedefi, ayn desen iinde birden ok kez bulunamaz',
        duplicateCatchAll: 'Yalnzca bir catch-all except yan tmcesine izin verilir',
        duplicateEnumMember: 'Enum member "{name}" is already declared',
        duplicateGenericAndProtocolBase: 'Only one Generic[...] or Protocol[...] base class allowed',
        duplicateImport: '"{importName}" birden ok kez ieri aktarld',
        duplicateKeywordOnly: 'Yalnzca bir "*" ayrcs kullanlabilir',
        duplicateKwargsParam: 'Yalnzca bir "**" parametresine izin verilir',
        duplicateParam: '"{name}" yinelenen parametresi',
        duplicatePositionOnly: 'Yalnzca bir "/" parametresine izin verilir',
        duplicateStarPattern: 'Desen dizisinde yalnzca bir "*" desenine izin verilir',
        duplicateStarStarPattern: 'Yalnzca bir "**" girdisine izin verilir',
        duplicateUnpack: 'Only one unpack operation allowed in list',
        ellipsisAfterUnpacked: '"..." paketlenmemi TypeVarTuple veya tuple ile kullanlamaz',
        ellipsisContext: '"..." kullanmna bu balamda izin verilmiyor',
        ellipsisSecondArg: '"..." yalnzca iki bamsz deikenin ikincisi olarak kullanlabilir',
        enumClassOverride: 'Enum class "{name}" is final and cannot be subclassed',
        enumMemberDelete: 'Enum yesi "{name}" silinemiyor',
        enumMemberSet: 'Enum yesi "{name}" atanamyor',
        enumMemberTypeAnnotation: 'Type annotations are not allowed for enum members',
        exceptGroupMismatch: 'Try ifadesi hem "except*" hem de "except" ieremez',
        exceptGroupRequiresType: 'zel durum grubu sz dizimi ("except*") biri zel durum tr gerektirir',
        exceptionGroupIncompatible: 'zel durum grubu sz dizimi ("except*") iin Python 3.11 veya daha yeni bir srm gerekiyor',
        exceptionGroupTypeIncorrect: 'except* altndaki zel durum tr BaseGroupException deerinden tretilemiyor',
        exceptionTypeIncorrect: '"{type}", BaseException trevi deil',
        exceptionTypeNotClass: '"{type}" geerli bir zel durum snf deil',
        exceptionTypeNotInstantiable: '"{type}" zel durum tr oluturucusu bir veya daha fazla bamsz deiken gerektiriyor',
        expectedAfterDecorator: 'Dekoratrden sonra ilev veya snf bildirimi bekleniyordu',
        expectedArrow: 'Dn tr ek aklamas sonrasnda "->" bekleniyordu',
        expectedAsAfterException: 'zel durum trnden sonra "as" bekleniyordu',
        expectedAssignRightHandExpr: '"=" esinin sa tarafnda ifade bekleniyordu',
        expectedBinaryRightHandExpr: 'lecin sanda ifade bekleniyordu',
        expectedBoolLiteral: 'True veya False bekleniyor',
        expectedCase: '"case" deyimi bekleniyordu',
        expectedClassName: 'Snf ad bekleniyordu',
        expectedCloseBrace: '"{" kapatlmad',
        expectedCloseBracket: '"[" kapatlmad',
        expectedCloseParen: '"(" kapatlmad',
        expectedColon: '":" bekleniyordu',
        expectedComplexNumberLiteral: 'Desen eleme iin karmak say sabit deeri bekleniyordu',
        expectedDecoratorExpr: 'fade formu Python 3.9\'dan nceki dekoratr iin desteklenmiyor',
        expectedDecoratorName: 'Dekoratr ad bekleniyordu',
        expectedDecoratorNewline: 'Dekoratr sonunda yeni satr bekleniyordu',
        expectedDelExpr: '"del" sonrasnda ifade bekleniyordu',
        expectedElse: '"else" bekleniyordu',
        expectedEquals: '"=" bekleniyordu',
        expectedExceptionClass: 'Geersiz zel durum snf veya nesnesi',
        expectedExceptionObj: 'zel durum nesnesi, zel durum snf veya None bekleniyordu',
        expectedExpr: 'fade bekleniyor',
        expectedFunctionAfterAsync: '"async" sonrasnda ilev tanm bekleniyordu',
        expectedFunctionName: '"def" sonrasnda ilev ad bekleniyordu',
        expectedIdentifier: 'Tanmlayc bekleniyordu',
        expectedImport: '"import" bekleniyordu',
        expectedImportAlias: '"as" sonrasnda sembol bekleniyordu',
        expectedImportSymbols: '"import" sonrasnda bir veya daha fazla sembol ad bekleniyordu',
        expectedIn: '"in" bekleniyordu',
        expectedInExpr: '"in" sonrasnda ifade bekleniyordu',
        expectedIndentedBlock: 'Girintili blok bekleniyordu',
        expectedMemberName: '"." sonrasnda bir znitelik ad bekleniyor',
        expectedModuleName: 'Modl ad bekleniyordu',
        expectedNameAfterAs: '"as" sonrasnda sembol ad bekleniyordu',
        expectedNamedParameter: 'Anahtar szck parametresi, "*" sonrasnda gelmelidir',
        expectedNewline: 'Yeni satr bekleniyordu',
        expectedNewlineOrSemicolon: 'Deyimler yeni satrlarla veya noktal virgllerle ayrlarak belirtilmelidir',
        expectedOpenParen: '"(" bekleniyordu',
        expectedParamName: 'Parametre ad bekleniyordu',
        expectedPatternExpr: 'Desen ifadesi bekleniyordu',
        expectedPatternSubjectExpr: 'Beklenen desen konusu ifadesi',
        expectedPatternValue: '"a.b" biiminde bir desen deeri ifadesi bekleniyordu',
        expectedReturnExpr: '"return" sonrasnda ifade bekleniyordu',
        expectedSliceIndex: 'Dizin veya dilim ifadesi bekleniyordu',
        expectedTypeNotString: 'Tr bekleniyordu ancak sabit deerli dize alnd',
        expectedTypeParameterName: 'Beklenen tr parametresi ad',
        expectedYieldExpr: 'Expected expression in yield statement',
        finalClassIsAbstract: 'Class "{type}" is marked final and must implement all abstract symbols',
        finalContext: 'Bu balamda "Final" kullanlamaz',
        finalInLoop: 'Bir dng iinde Final deikeni atanamaz',
        finalMethodOverride: '"{name}" yntemi "{className}" snf iinde tanmlanan final metodu geersiz klamaz',
        finalNonMethod: '"{name}" ilevi bir yntem olmadndan @final olarak iaretlenemez',
        finalReassigned: '"{name}" is declared as Final and cannot be reassigned',
        finalRedeclaration: '"{name}" daha nce Final olarak bildirildi',
        finalRedeclarationBySubclass: '"{name}", "{className}" snf ad bu ad Final olarak bildirdiinden yeniden bildirilemez',
        finalTooManyArgs: '"Final" sonrasnda tek bir tr bamsz deiken bekleniyordu',
        finalUnassigned: '"{name}" Final olarak bildirildi, ancak deer atanmad',
        formatStringBrace: 'f dizesi sabit deerinde tek bir kapatma kme ayrac kullanlamaz; ift sa ayra kullann',
        formatStringBytes: 'Biim dizesi sabit deerleri (f-strings) ikili olamaz',
        formatStringDebuggingIllegal: 'F dizesi hata ayklama belirticisi "=", Python 3.8 veya daha yeni bir srm gerektirir',
        formatStringEscape: 'Python 3.12 ncesinde f dizesinin ifade blmnde ka srasna (ters eik izgi) izin verilmez',
        formatStringExpectedConversion: 'f-string\'de "!" esinden sonra bir dntrme tanmlaycs bekleniyordu',
        formatStringIllegal: 'Biim dizesi sabit deerleri (f dizeleri) Python 3.6 veya daha yeni bir srm gerektirir',
        formatStringInPattern: 'Desende biim dizesine izin verilmiyor',
        formatStringNestedFormatSpecifier: 'fadeler biim dizesi belirticisi iinde ok derin i ie gemi',
        formatStringNestedQuote: 'F dizesi iinde i ie gemi dizeler Python 3.12\'den nceki f dizesiyle ayn trnak karakterini kullanamaz',
        formatStringUnicode: 'Biim dizesi sabit deerleri (f-strings) unicode olamaz',
        formatStringUnterminated: 'F dizesi iinde sonlandrlmam ifade; "}" bekleniyor',
        functionDecoratorTypeUnknown: 'Tr belirsiz ilev dekoratr ilevin trn gizler; dekoratr yoksaylyor',
        functionInConditionalExpression: 'Koullu ifade, her zaman True olarak deerlendirilen ileve bavurur',
        functionTypeParametersIllegal: 'lev tr parametre szdizimi Python 3.12 veya daha yeni bir srm gerektirir',
        futureImportLocationNotAllowed: '__future__ ieri aktarmalar dosyann banda olmaldr',
        generatorAsyncReturnType: 'Return type of async generator function must be compatible with "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: 'Tek bamsz deiken olmadklarnda oluturucu ifadeleri ayra iine alnmaldr',
        generatorSyncReturnType: 'Oluturucu ilevinin dn tr "Generator[{yieldType}, Any, Any]" ile uyumlu olmaldr',
        genericBaseClassNotAllowed: '"Generic" temel snf, tr parametresi szdizimiyle kullanlamaz',
        genericClassAssigned: 'Genel snf tr atanamyor',
        genericClassDeleted: 'Genel snf tr silinemiyor',
        genericInstanceVariableAccess: 'Snf zerinden genel rnek deikenine eriim belirsiz',
        genericNotAllowed: '"Generic" bu balamda geerli deil',
        genericTypeAliasBoundTypeVar: 'Snf iindeki genel tr dier ad {names} bal tr deikenlerini kullanamyor',
        genericTypeArgMissing: '"Generic" en az bir tr bamsz deikeni gerektirir',
        genericTypeArgTypeVar: '"Generic" iin tr bamsz deikeni bir tr deikeni olmaldr',
        genericTypeArgUnique: '"Generic" iin tr bamsz deikenleri benzersiz olmaldr',
        globalReassignment: '"{name}" is assigned before global declaration',
        globalRedefinition: '"{name}" was already declared global',
        implicitStringConcat: 'rtk dize birletirmesine izin verilmiyor',
        importCycleDetected: 'eri aktarma zincirinde dng algland',
        importDepthExceeded: 'eri aktarma zinciri derinlii {depth} snrn at',
        importResolveFailure: '"{importName}" adl ieri aktarma zmlenemedi',
        importSourceResolveFailure: '"{importName}" adl ieri aktarma kaynaktan zmlenemedi',
        importSymbolUnknown: '"{name}" alma simgesi bilinmiyor',
        incompatibleMethodOverride: '"{name}" metodu "{className}" snfn uyumsuz bir ekilde geersiz klyor',
        inconsistentIndent: 'Girintisiz miktar nceki girintiyle elemiyor',
        inconsistentTabs: 'Girinti iinde sekmelerin ve boluklarn kullanm tutarsz',
        initMethodSelfParamTypeVar: '"__init__" metodunun "self" parametresi iin tr ek aklamas snf kapsaml tr deikenleri ieremez',
        initMustReturnNone: '"__init__" dn tr None olmaldr',
        initSubclassCallFailed: '__init_subclass__ yntemi iin yanl anahtar bamsz deikenleri',
        initSubclassClsParam: '__init_subclass__ geersiz klmas bir "cls" parametresi almal',
        initVarNotAllowed: '"InitVar" esi bu balamda kullanlamaz',
        instanceMethodSelfParam: 'rnek metotlar bir "self" parametresi almaldr',
        instanceVarOverridesClassVar: '"{name}" rnek deikeni "{className}" snfndaki ayn ada sahip snf deikenini geersiz klyor',
        instantiateAbstract: '"{type}" soyut snf rnei oluturulamyor',
        instantiateProtocol: '"{type}" Protocol snfnn rnei oluturulamyor',
        internalBindError: '"{file}" dosyas balanrken dahili bir hata olutu: {message}',
        internalParseError: '"{file}" dosyas ayrtrlrken dahili bir hata olutu: {message}',
        internalTypeCheckingError: '"{file}" dosyas tr denetimi gerekletirilirken dahili bir hata olutu: {message}',
        invalidIdentifierChar: 'Tanmlaycda geersiz karakter',
        invalidStubStatement: 'Statement is meaningless within a type stub file',
        invalidTokenChars: 'Belirtete geersiz "{text}" karakteri var',
        isInstanceInvalidType: 'Second argument to "isinstance" must be a class or tuple of classes',
        isSubclassInvalidType: 'Second argument to "issubclass" must be a class or tuple of classes',
        keyValueInSet: 'Key/value pairs are not allowed within a set',
        keywordArgInTypeArgument: 'Anahtar szck bamsz deikenleri tr bamsz deiken listelerinde kullanlamaz',
        keywordArgShortcutIllegal: 'Anahtar szck bamsz deikeni ksayolu iin Python 3.14 veya daha yenisini gereklidir.',
        keywordOnlyAfterArgs: '"*" parametresinden sonra keyword-only bamsz deiken ayrcs kullanlamaz',
        keywordParameterMissing: 'Bir veya daha fazla anahtar szck parametresi "*" parametresini izlemeli',
        keywordSubscriptIllegal: 'Alt simge iindeki anahtar szck bamsz deikenleri desteklenmiyor',
        lambdaReturnTypePartiallyUnknown: 'Lambdann "{returnType}" dn tr ksmen bilinmiyor',
        lambdaReturnTypeUnknown: 'Lambdann dn tr bilinmiyor',
        listAssignmentMismatch: '"{type}" trndeki ifade hedef listesine atanamaz',
        listInAnnotation: 'List expression not allowed in type expression',
        literalEmptyArgs: '"Literal" sonrasnda bir veya daha fazla tr bamsz deikeni bekleniyordu',
        literalNamedUnicodeEscape: 'Adlandrlm unicode ka sralar Literal dize ek aklamalarnda desteklenmiyor',
        literalNotAllowed: '"Literal" bir tr bamsz deiken olmadan bu balamda kullanlamaz',
        literalNotCallable: 'Literal type cannot be instantiated',
        literalUnsupportedType: 'Type arguments for "Literal" must be None, a literal value (int, bool, str, or bytes), or an enum value',
        matchIncompatible: 'Match statements require Python 3.10 or newer',
        matchIsNotExhaustive: 'Cases within match statement do not exhaustively handle all values',
        maxParseDepthExceeded: 'Maksimum ayrtrma derinlii ald; ifadeyi daha kk alt ifadelere bln',
        memberAccess: 'Snf "{type}" iin "{name}" zniteliine eriilemiyor',
        memberDelete: 'Snf "{type}" iin "{name}" znitelii silinemiyor',
        memberSet: 'Snf "{type}" iin "{name}" znitelii atanamyor',
        metaclassConflict: 'Tretilmi snfn meta snf, tm temel snflarnn meta snflarnn bir alt snf olmaldr',
        metaclassDuplicate: 'Yalnzca bir meta snf salanmaldr',
        metaclassIsGeneric: 'Meta snf genel olamaz',
        methodNotDefined: '"{name}" metodu tanmlanmad',
        methodNotDefinedOnType: '"{name}" metodu "{type}" tr zerinde tanmlanmad',
        methodOrdering: 'Tutarl metot sralamas oluturulamyor',
        methodOverridden: '"{name}", uyumsuz "{type}" trne sahip "{className}" snfnda ayn ad metodunu geersiz klar',
        methodReturnsNonObject: '"{name}" metodu bir nesne dndrmez',
        missingSuperCall: '"{methodName}" metodu st snftaki ayn ada sahip metodu aramaz',
        mixingBytesAndStr: 'Bytes ve str deerleri birletirilemez',
        moduleAsType: 'Modl tr olarak kullanlamaz',
        moduleNotCallable: 'Modl arlabilir deil',
        moduleUnknownMember: '"{memberName}", "{moduleName}" modlnn bilinen bir znitelii deil',
        namedExceptAfterCatchAll: 'Adlandrlm except yan tmcesi, catch-all except yan tmcesinden sonra gelemez',
        namedParamAfterParamSpecArgs: '"{name}" anahtar szck parametresi ParamSpec args parametresinden sonra imzada yer alamaz',
        namedTupleEmptyName: 'Names within a named tuple cannot be empty',
        namedTupleEntryRedeclared: 'st snf "{name}" adlandrlm bir tuple olduundan "{className}" geersiz klnamyor',
        namedTupleFirstArg: 'Expected named tuple class name as first argument',
        namedTupleMultipleInheritance: 'NamedTuple bulunan birden ok devralma desteklenmiyor',
        namedTupleNameKeyword: 'Alan adlar anahtar szck olamaz',
        namedTupleNameType: 'Expected two-entry tuple specifying entry name and type',
        namedTupleNameUnique: 'Names within a named tuple must be unique',
        namedTupleNoTypes: '"namedtuple" demet girdileri iin tr salamaz; bunun yerine "NamedTuple" kullann',
        namedTupleSecondArg: 'Expected named tuple entry list as second argument',
        newClsParam: '__new__ geersiz klmas bir "cls" parametresi almal',
        newTypeAnyOrUnknown: 'NewType\'n ikinci bamsz deikeni Any veya Unknown deil, bilinen bir snf olmaldr',
        newTypeBadName: 'NewType iin ilk bamsz deiken bir sabit deerli dize olmaldr',
        newTypeLiteral: 'NewType Literal tryle kullanlamaz',
        newTypeNameMismatch: 'NewType, ayn ada sahip bir deikene atanmaldr',
        newTypeNotAClass: 'NewType iin ikinci bamsz deiken olarak snf bekleniyordu',
        newTypeParamCount: 'NewType iin iki konumsal bamsz deiken gerekiyor',
        newTypeProtocolClass: 'NewType yapsal trle (Protocol veya TypedDict snf) kullanlamaz',
        noOverload: '"{name}" iin ar yklemelerin hibiri salanan bamsz deikenlerle elemiyor',
        noReturnContainsReturn: 'Function with declared return type "NoReturn" cannot include a return statement',
        noReturnContainsYield: 'Bildirilen dn tr "NoReturn" olan ilev bir yield deyimi ieremez',
        noReturnReturnsNone: 'Bildirilen "NoReturn" dndrme trne sahip ilev "None" dndremez',
        nonDefaultAfterDefault: 'Varsaylan olmayan bamsz deiken varsaylan bamsz deikeni izler',
        nonLocalInModule: 'Nonlocal declaration not allowed at module level',
        nonLocalNoBinding: 'No binding for nonlocal "{name}" found',
        nonLocalReassignment: '"{name}" is assigned before nonlocal declaration',
        nonLocalRedefinition: '"{name}" was already declared nonlocal',
        noneNotCallable: '"None" trndeki nesne arlamaz',
        noneNotIterable: '"None" trndeki nesne, yeniden kullanlabilir deer olarak kullanlamaz',
        noneNotSubscriptable: '"None" trndeki nesne alt simgeletirilebilir deil',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: '"{operator}" ileci "None" iin desteklenmiyor',
        noneUnknownMember: '"{name}" bilinen bir "None" znitelii deil',
        notRequiredArgCount: '"NotRequired" sonrasnda tek bir tr bamsz deiken bekleniyordu',
        notRequiredNotInTypedDict: 'Bu balamda "NotRequired" kullanmna izin verilmiyor',
        objectNotCallable: '"{type}" trndeki nesne arlamaz',
        obscuredClassDeclaration: '"{name}" snf bildirimi ayn ada sahip bir bildirim tarafndan gizlendi',
        obscuredFunctionDeclaration: '"{name}" ilev bildirimi ayn ada sahip bir bildirim tarafndan gizlendi',
        obscuredMethodDeclaration: '"{name}" metot bildirimi ayn ada sahip bir bildirim tarafndan gizlendi',
        obscuredParameterDeclaration: '"{name}" parametre bildirimi ayn ada sahip bir bildirim tarafndan gizlendi',
        obscuredTypeAliasDeclaration: '"{name}" tr dier ad bildirimi ayn ada sahip bir bildirim tarafndan etkisiz klnd',
        obscuredVariableDeclaration: '"{name}" bildirimi ayn ada sahip bir bildirim tarafndan gizlendi',
        operatorLessOrGreaterDeprecated: '"<>" ileci Python 3\'de desteklenmiyor; bunun yerine "!=" kullann',
        optionalExtraArgs: 'Expected one type argument after "Optional"',
        orPatternIrrefutable: 'Reddedilemez desene yalnzca "or" deseninde son alt desen olarak izin verilir',
        orPatternMissingName: 'Bir "or" deseni iindeki tm alt desenlerde ayn adlar hedeflenmeli',
        overlappingKeywordArgs: 'Tr belirlenmi szlk anahtar szck parametresiyle akyor: {names}',
        overlappingOverload: 'Parametreleri {obscuredBy} ar yklemesi ile aktndan "{name}" {obscured} ar yklemesi hibir zaman kullanlmayacak',
        overloadAbstractImplMismatch: 'Ar yklemeler uygulamann zet durumuyla elemelidir',
        overloadAbstractMismatch: 'Ar yklemelerin tm soyut olmal veya tm olmamaldr',
        overloadClassMethodInconsistent: '"{name}" iin ar yklemeler, @classmethod yntemini tutarl kullanyor',
        overloadFinalInconsistencyImpl: '"{name}" iin ar ykleme @final olarak iaretlendi ancak uygulama iaretlenmedi',
        overloadFinalInconsistencyNoImpl: '"{name}" iin ar ykleme {index} @final olarak iaretlendi ancak ar ykleme 1 iaretlenmedi',
        overloadImplementationMismatch: 'Ar yklenmi uygulama, {index} ar ykleme imzas ile tutarl deil',
        overloadReturnTypeMismatch: '"{name}" iin {prevIndex} ar yklemesi {newIndex} ar yklemesi ile akyor ve uyumsuz bir tr dndryor',
        overloadStaticMethodInconsistent: '"{name}" iin ar yklemeler, @staticmethod yntemini tutarsz kullanyor',
        overloadWithoutImplementation: '"{name}" is marked as overload, but no implementation is provided',
        overriddenMethodNotFound: 'Method "{name}" is marked as override, but no base method of same name is present',
        overrideDecoratorMissing: 'Method "{name}" is not marked as override but is overriding a method in class "{className}"',
        paramAfterKwargsParam: 'Parametre "**" parametresini izleyemez',
        paramAlreadyAssigned: '"{name}" parametresi zaten atanm',
        paramAnnotationMissing: '"{name}" parametresi iin tr ek aklamas eksik',
        paramAssignmentMismatch: '"{sourceType}" trndeki ifade, "{paramType}" trndeki parametreye atanamaz',
        paramNameMissing: '"{name}" adl parametre yok',
        paramSpecArgsKwargsDuplicate: '"{type}" ParamSpec\'i iin bamsz deikenler zaten saland',
        paramSpecArgsKwargsUsage: 'ParamSpec\'in "args" ve "kwargs" zniteliklerinin ikisi de ilev imzasnda grnmelidir',
        paramSpecArgsMissing: 'ParamSpec "{type}" bamsz deikenleri eksik',
        paramSpecArgsUsage: 'ParamSpec\'in "args" znitelii yalnzca *args parametresiyle kullanldnda geerlidir',
        paramSpecAssignedName: 'ParamSpec, "{name}" adl bir deikene atanmal',
        paramSpecContext: 'ParamSpec bu balamda kullanlamaz',
        paramSpecDefaultNotTuple: 'Expected ellipsis, a tuple expression, or ParamSpec for default value of ParamSpec',
        paramSpecFirstArg: 'lk bamsz deiken olarak ParamSpec ad bekleniyordu',
        paramSpecKwargsUsage: 'ParamSpec\'in "kwargs" znitelii yalnzca **kwargs parametresiyle kullanldnda geerlidir',
        paramSpecNotUsedByOuterScope: '"{name}" adl ParamSpec bu balamda bir anlam ifade etmiyor',
        paramSpecUnknownArg: 'ParamSpec birden fazla bamsz deikeni desteklemiyor',
        paramSpecUnknownMember: '"{name}" bilinen bir ParamSpec znitelii deil',
        paramSpecUnknownParam: '"{name}", ParamSpec iin bilinmeyen bir parametre',
        paramTypeCovariant: 'Kovaryant tr deikeni parametre trnde kullanlamaz',
        paramTypePartiallyUnknown: '"{paramName}" parametresinin tr ksmen bilinmiyor',
        paramTypeUnknown: '"{paramName}" parametresinin tr bilinmiyor',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: 'Desen, "{type}" konu tr ile hibir zaman elemez',
        positionArgAfterNamedArg: 'Konumsal bamsz deiken anahtar szck bamsz deikenlerden sonra gelemez',
        positionOnlyAfterArgs: '"*" parametresinden sonra yalnzca konum parametre ayrcs kullanlamaz',
        positionOnlyAfterKeywordOnly: '"/" parametresi "*" parametresinden nce gelmelidir',
        positionOnlyAfterNon: 'Yalnzca konum parametresi olmayan parametreden sonra yalnzca konum parametresine izin verilmez',
        positionOnlyFirstParam: 'Yalnzca konum parametre ayrcs ilk parametre olarak kullanlamaz',
        positionOnlyIncompatible: 'Yalnzca konum parametre ayrcs iin Python 3.8 veya daha yeni bir srm gerekiyor',
        privateImportFromPyTypedModule: '"{name}" "{module}" modlnden dar aktarlamad',
        privateUsedOutsideOfClass: '"{name}" zeldir ve bildirildii snfn dnda kullanlr',
        privateUsedOutsideOfModule: '"{name}" zeldir ve bildirildii modln dnda kullanlr',
        propertyOverridden: '"{name}" incorrectly overrides property of same name in class "{className}"',
        propertyStaticMethod: 'Static methods not allowed for property getter, setter or deleter',
        protectedUsedOutsideOfClass: '"{name}" korumaldr ve iinde bildirildii snfn dnda kullanlr',
        protocolBaseClass: '"{classType}" Protocol snf, Protocol olmayan "{baseType}" snfnn trevi olamaz',
        protocolBaseClassWithTypeArgs: 'Type arguments are not allowed with Protocol class when using type parameter syntax',
        protocolIllegal: '"Protocol" kullanm iin Python 3.7 veya daha yeni bir srm gerekiyor',
        protocolNotAllowed: '"Protocol" bu balamda kullanlamaz',
        protocolTypeArgMustBeTypeParam: 'Protocol iin tr bamsz deikeni bir tr parametresi olmaldr',
        protocolUnsafeOverlap: 'Snf, "{name}" ile gvenli olmayan bir ekilde akyor ve alma zamannda bir eleme retebilir',
        protocolVarianceContravariant: 'Genel Protocol "{class}" iin kullanlan "{variable}" tr deikeni, deiken kart olmaldr',
        protocolVarianceCovariant: 'Genel Protocol "{class}" iin kullanlan "{variable}" tr deikeni, birlikte deien olmaldr',
        protocolVarianceInvariant: 'Genel Protocol "{class}" iin kullanlan "{variable}" tr deikeni sabit olmaldr',
        pyrightCommentInvalidDiagnosticBoolValue: 'Pyright aklama ynergesinden sonra "=" ve true veya false deeri olmaldr',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Pyright aklama ynergesinden sonra "=" ve true, false, error, warning, information veya none deeri girilmelidir',
        pyrightCommentMissingDirective: 'Pyright comment must be followed by a directive (basic or strict) or a diagnostic rule',
        pyrightCommentNotOnOwnLine: 'Pyright comments used to control file-level settings must appear on their own line',
        pyrightCommentUnknownDiagnosticRule: '"{rule}", pyright aklamas iin bilinmeyen bir tanlama kural',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" pyright aklamas iin geersiz deer; true, false, error, warning, information veya none bekleniyordu',
        pyrightCommentUnknownDirective: '"{directive}", pyright aklamas iin bilinmeyen bir ynergedir; "strict" veya "basic" bekleniyordu',
        readOnlyArgCount: '"ReadOnly" sonrasnda tek bir tr bamsz deiken bekleniyordu',
        readOnlyNotInTypedDict: 'Bu balamda "ReadOnly" kullanmna izin verilmiyor',
        recursiveDefinition: 'Kendine bavurduundan "{name}" tr belirlenemedi',
        relativeImportNotAllowed: 'Greli ieri aktarmalar "import .a" formuyla kullanlamaz; bunun yerine "from . import a" kullann',
        requiredArgCount: '"Required" sonrasnda tek bir tr bamsz deiken bekleniyordu',
        requiredNotInTypedDict: 'Bu balamda "Required" kullanmna izin verilmiyor',
        returnInAsyncGenerator: 'Return statement with value is not allowed in async generator',
        returnInExceptionGroup: '"except*" blounda "return" kullanlamaz',
        returnMissing: 'Bildirilen "{returnType}" dndrme trne sahip ilev, tm kod yollarnda deer dndrmelidir',
        returnOutsideFunction: '"return" yalnzca bir ilev iinde kullanlabilir',
        returnTypeContravariant: 'Deiken kart tr deikeni dn trnde kullanlamaz',
        returnTypeMismatch: '"{exprType}" tr "{returnType}" dn trne atanamaz',
        returnTypePartiallyUnknown: '"{returnType}" dn tr ksmen bilinmiyor',
        returnTypeUnknown: 'Dn tr bilinmiyor',
        revealLocalsArgs: '"reveal_locals" ars iin bamsz deiken beklenmiyordu',
        revealLocalsNone: 'No locals in this scope',
        revealTypeArgs: '"reveal_type" ars iin tek bir konumsal bamsz deiken bekleniyordu',
        revealTypeExpectedTextArg: '"reveal_type" bamsz deikeni iin "expected_text" argman bir str sabit deeri olmaldr',
        revealTypeExpectedTextMismatch: 'Tr uyumazl; "{expected}" bekleniyordu ancak "{received}" alnd',
        revealTypeExpectedTypeMismatch: 'Tr uyumazl; "{expected}" bekleniyordu ancak "{received}" alnd',
        selfTypeContext: '"Self" bu balamda geerli deil',
        selfTypeMetaclass: '"Self" bir meta snf ("type" alt snf) iinde kullanlamaz',
        selfTypeWithTypedSelfOrCls: '"Self", "Self" dnda bir tr ek aklamasna sahip bir `self` veya `cls` parametresine sahip bir ilevde kullanlamaz',
        setterGetterTypeMismatch: 'Property setter value type is not assignable to the getter return type',
        singleOverload: '"{name}" ar ykleme olarak iaretlenmi, ancak ek ar yklemeler eksik',
        slotsAttributeError: '"{name}", __slots__ iinde belirtilmedi',
        slotsClassVarConflict: '"{name}", __slots__ iinde bildirilen rnek deikenle akyor',
        starPatternInAsPattern: 'Yldz deseni "as" hedefiyle kullanlamaz',
        starPatternInOrPattern: 'Yldz deseni dier desenlerde ORed olamaz',
        starStarWildcardNotAllowed: '"_" joker karakteriyle ** kullanlamaz',
        staticClsSelfParam: 'Static metotlar "self" veya "cls" parametresi almamaldr',
        stdlibModuleOverridden: '"{path}", "{name}" stdlib modln geersiz klyor',
        stringNonAsciiBytes: 'ASCII olmayan karaktere bayt sabit deerli dizesinde izin verilmez',
        stringNotSubscriptable: 'Tr ifadesinde dize ifadesi alt simge olarak belirtilemez; ifadenin tamamn trnak iine aln',
        stringUnsupportedEscape: 'Dize sabit deerinde desteklenmeyen ka dizisi',
        stringUnterminated: 'Sabit deerli dize sonlandrlmam',
        stubFileMissing: 'Stub file not found for "{importName}"',
        stubUsesGetAttr: 'Type stub file is incomplete; "__getattr__" obscures type errors for module',
        sublistParamsIncompatible: 'Sublist parameters are not supported in Python 3.x',
        superCallArgCount: '"super" ars iin ikiden fazla bamsz deiken beklenmiyordu',
        superCallFirstArg: '"super" arsnn ilk bamsz deikeni olarak snf tr bekleniyordu ancak "{type}" alnd',
        superCallSecondArg: '"super" arsnn ikinci bamsz deikeni, "{type}" trnden tretilen nesne veya snf olmaldr',
        superCallZeroArgForm: '"super" arsnn zero-argument biimi yalnzca bir metot iinde geerlidir',
        superCallZeroArgFormStaticMethod: '"super" arsnn zero-argument biimi statik bir metot iinde geerli deildir',
        symbolIsPossiblyUnbound: '"{name}" byk olaslkla bal deil',
        symbolIsUnbound: '"{name}" bal deil',
        symbolIsUndefined: '"{name}" tanmlanmad',
        symbolOverridden: '"{name}", "{className}" snfnda ayn ada sahip sembol geersiz klar',
        ternaryNotAllowed: 'Tr ifadesinde l ifade kullanlamaz',
        totalOrderingMissingMethod: 'total_ordering kullanmak iin snfta "__lt__", "__le__", "__gt__" veya "__ge__" metotlarndan biri tanmlanmaldr',
        trailingCommaInFromImport: 'evreleyen parantezler olmadan sondaki virgle izin verilmez',
        tryWithoutExcept: 'Try deyimi en az bir except veya finally yan tmcesi iermelidir',
        tupleAssignmentMismatch: 'Expression with type "{type}" cannot be assigned to target tuple',
        tupleInAnnotation: 'Tuple expression not allowed in type expression',
        tupleIndexOutOfRange: '{index} dizini {type} tr iin aralk dnda',
        typeAliasIllegalExpressionForm: 'Tr dier ad tanm iin geersiz ifade form',
        typeAliasIsRecursiveDirect: 'Tr dier ad "{name}", tanmnda kendisini kullanamaz',
        typeAliasNotInModuleOrClass: 'TypeAlias yalnzca bir modl veya snf kapsamnda tanmlanabilir',
        typeAliasRedeclared: '"{name}" bir TypeAlias olarak bildirilmi ve yalnzca bir kez atanabilir',
        typeAliasStatementBadScope: 'A type statement can be used only within a module or class scope',
        typeAliasStatementIllegal: 'Tr dier ad deyimi iin Python 3.12 veya daha yeni bir srm gerekiyor',
        typeAliasTypeBaseClass: 'Bir "type" deyiminde tanmlanan type dier ad temel snf olarak kullanlamaz',
        typeAliasTypeMustBeAssigned: 'TypeAliasType, tr dier adyla ayn ada sahip bir deikene atanmaldr',
        typeAliasTypeNameArg: 'TypeAliasType iin ilk bamsz deiken, tr dier adnn adn temsil eden bir sabit deerli dize olmaldr',
        typeAliasTypeNameMismatch: 'Tr dier adnn atand deikenin adyla elemesi gerekiyor',
        typeAliasTypeParamInvalid: 'Type parameter list must be a tuple containing only TypeVar, TypeVarTuple, or ParamSpec',
        typeAnnotationCall: 'Tr ifadesinde ar ifadesine izin verilmiyor',
        typeAnnotationVariable: 'Tr ifadesinde deikene izin verilmiyor',
        typeAnnotationWithCallable: 'Type argument for "type" must be a class; callables are not supported',
        typeArgListExpected: 'ParamSpec,  nokta veya tr listesi bekleniyordu',
        typeArgListNotAllowed: 'Bu tr bamsz deikeni iin liste ifadesine izin verilmiyor',
        typeArgsExpectingNone: '"{name}" snf iin tr bamsz deikeni beklenmiyordu',
        typeArgsMismatchOne: 'Bir tane tr bamsz deikeni bekleniyordu ancak {received} alnd',
        typeArgsMissingForAlias: '"{name}" genel tr dier ad iin tr bamsz deikenleri bekleniyordu',
        typeArgsMissingForClass: '"{name}" genel snf ad iin tr bamsz deikenleri bekleniyordu',
        typeArgsTooFew: '"{name}" iin ok az tr bamsz deikeni saland; {expected} bekleniyordu ancak {received} alnd',
        typeArgsTooMany: '"{name}" iin ok fazla tr bamsz deikeni saland; {expected} bekleniyordu ancak {received} alnd',
        typeAssignmentMismatch: '"{sourceType}" tr "{destType}" bildirilen trne atanamaz',
        typeAssignmentMismatchWildcard: '"{name}" ieri aktarma sembol "{sourceType}" trne sahip ve bu tr "{destType}" bildirilen trne atanamaz',
        typeCallNotAllowed: 'Tr ifadesinde type() ars kullanlmamaldr',
        typeCheckOnly: '"{name}", @type_check_only olarak iaretlendi ve yalnzca tr ek aklamalarnda kullanlabilir',
        typeCommentDeprecated: 'Use of type comments is deprecated; use type annotation instead',
        typeExpectedClass: 'Snf bekleniyordu ancak "{type}" alnd',
        typeFormArgs: '"TypeForm" tek bir konumsal bamsz deikeni kabul eder',
        typeGuardArgCount: 'Expected a single type argument after "TypeGuard" or "TypeIs"',
        typeGuardParamCount: 'Kullanc tanml tr koruma ilevleri ve metotlarnda en az bir giri parametresi olmaldr',
        typeIsReturnType: 'TypeIs dn tr ("{returnType}"), deer parametresi tr ("{type}") ile tutarl deil',
        typeNotAwaitable: '"{type}" is not awaitable',
        typeNotIntantiable: '"{type}" rnei oluturulamyor',
        typeNotIterable: '"{type}" yeniden kullanlamaz',
        typeNotSpecializable: '"{type}" tr zelletirilemedi',
        typeNotSubscriptable: '"{type}" trndeki nesne alt simgeletirilebilir deil',
        typeNotSupportBinaryOperator: 'le "{operator}", "{leftType}" ve "{rightType}" trleri iin desteklenmiyor',
        typeNotSupportBinaryOperatorBidirectional: '"{operator}" ileci, beklenen tr "{expectedType}" olduunda "{leftType}" ve "{rightType}" trleri iin desteklenmez',
        typeNotSupportUnaryOperator: '"{operator}" ileci "{type}" tr iin desteklenmiyor',
        typeNotSupportUnaryOperatorBidirectional: '"{operator}" ileci, beklenen tr "{expectedType}" olduunda "{type}" tr iin desteklenmiyor',
        typeNotUsableWith: '{method} metodunu uygulamadndan "{type}" trndeki nesne "with" ile kullanlamaz',
        typeParameterBoundNotAllowed: 'Snr veya kstlama, deien tr parametresi veya ParamSpec ile kullanlamaz',
        typeParameterConstraintTuple: 'Tr parametresi kstlamas iki veya daha fazla trde bir demet olmaldr',
        typeParameterExistingTypeParameter: '"{name}" tr parametresi zaten kullanlyor',
        typeParameterNotDeclared: '"{name}" tr parametresi "{container}" esine ait tr parametreleri listesinde yok',
        typeParametersMissing: 'En az bir tr parametresi belirtilmelidir',
        typePartiallyUnknown: '"{name}" tr ksmen bilinmiyor',
        typeUnknown: '"{name}" tr bilinmiyor',
        typeVarAssignedName: 'TypeVar, "{name}" adl bir deikene atanmal',
        typeVarAssignmentMismatch: '"{type}" tr "{name}" tr deikenine atanamaz',
        typeVarBoundAndConstrained: 'TypeVar hem bal hem de kstlanm olamaz',
        typeVarBoundGeneric: 'TypeVar bal tr genel olamaz',
        typeVarConstraintGeneric: 'TypeVar kstlama tr genel olamaz',
        typeVarDefaultBoundMismatch: 'TypeVar varsaylan tr, bal trn bir alt tr olmaldr',
        typeVarDefaultConstraintMismatch: 'TypeVar varsaylan tr kstlanm trlerden biri olmaldr',
        typeVarDefaultIllegal: 'Tr deikeni varsaylan trleri Python 3.13 veya daha yeni bir srm gerektirir',
        typeVarDefaultInvalidTypeVar: '"{name}" tr parametresi, kapsam d bir veya daha fazla tr deikenine bavuran varsaylan bir tre sahip',
        typeVarFirstArg: 'lk bamsz deiken olarak TypeVar ad bekleniyordu',
        typeVarInvalidForMemberVariable: 'znitelik tr, yerel yntem kapsamna alnan "{name}" tr deikenini kullanamaz',
        typeVarNoMember: 'TypeVar "{type}", "{name}" zniteliine sahip deil',
        typeVarNotSubscriptable: 'TypeVar "{type}" alt yazlabilir deil',
        typeVarNotUsedByOuterScope: '"{name}" tr deikeni bu balamda bir anlam ifade etmiyor',
        typeVarPossiblyUnsolvable: '"{name}" tr deikeni, aran "{param}" parametresi iin bamsz deiken salamazsa zmlenemeyebilir',
        typeVarSingleConstraint: 'TypeVar en az iki kstlanm tre sahip olmaldr',
        typeVarTupleConstraints: 'TypeVarTuple deer kstlamalarna sahip olamaz',
        typeVarTupleContext: 'TypeVarTuple bu balamda kullanlamaz',
        typeVarTupleDefaultNotUnpacked: 'TypeVarTuple default type must be an unpacked tuple or TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'TypeVarTuple deeri iin Paket ama ileci gereklidir',
        typeVarTupleUnknownParam: '"{name}" is unknown parameter to TypeVarTuple',
        typeVarUnknownParam: '"{name}", TypeVar iin bilinmeyen bir parametre',
        typeVarUsedByOuterScope: 'TypeVar "{name}" zaten bir d kapsam tarafndan kullanlyor',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" genel ilev imzasnda yalnzca bir kez grnr',
        typeVarVariance: 'TypeVar hem birlikte deiken hem de deiken kart olamaz',
        typeVarWithDefaultFollowsVariadic: '"{typeVarName}" TypeVar alan bir varsaylan deer ierir ve "{variadicName}" TypeVarTuple alanna uyamaz',
        typeVarWithoutDefault: '"{name}" varsaylan tre sahip olmadndan tr parametresi listesinde "{other}" sonrasnda bulunamaz',
        typeVarsNotInGenericOrProtocol: 'Generic[] veya Protocol[] tm tr deikenlerini iermeli',
        typedDictAccess: 'TypedDict\'da eye eriilemedi',
        typedDictAssignedName: 'TypedDict, "{name}" adl bir deikene atanmal',
        typedDictBadVar: 'TypedDict snflar yalnzca tr ek aklamalar ierebilir',
        typedDictBaseClass: 'TypedDict snflar iin tm temel snflar da TypedDict snflar olmaldr',
        typedDictBoolParam: 'True veya False deeri olmas iin "{name}" parametresi bekleniyordu',
        typedDictClosedExtras: '"{name}" temel snf closed bir TypedDict esidir; ek eler "{type}" trnde olmaldr',
        typedDictClosedNoExtras: '"{name}" temel snf closed bir TypedDict esidir; ek elere izin verilmiyor',
        typedDictDelete: 'TypedDict\'da e silinemedi',
        typedDictEmptyName: 'TypedDict iindeki adlar bo olamaz',
        typedDictEntryName: 'Szlk girdisi ad iin sabit deerli dize bekleniyordu',
        typedDictEntryUnique: 'Szlk iindeki adlar benzersiz olmaldr',
        typedDictExtraArgs: 'Ekstra TypedDict bamsz deikenleri desteklenmiyor',
        typedDictExtraItemsClosed: 'Bir TypedDict ek eleri destekliyorsa closed olamaz',
        typedDictFieldNotRequiredRedefinition: '"{name}" TypedDict esi NotRequired olarak yeniden tanmlanamaz',
        typedDictFieldReadOnlyRedefinition: '"{name}" TypedDict esi ReadOnly olarak yeniden tanmlanamaz',
        typedDictFieldRequiredRedefinition: '"{name}" TypedDict esi Required olarak yeniden tanmlanamaz',
        typedDictFirstArg: 'Birinci bamsz deiken olarak TypedDict snf ad bekleniyordu',
        typedDictInClassPattern: 'TypedDict snfna snf deseninde izin verilmez',
        typedDictInitsubclassParameter: 'TypedDict, "{name}" __init_subclass__ parametresini desteklemez',
        typedDictNotAllowed: '"TypedDict" bu balamda kullanlamaz',
        typedDictSecondArgDict: 'Expected dict or keyword parameter as second parameter',
        typedDictSecondArgDictEntry: 'Basit szlk girii bekleniyordu',
        typedDictSet: 'TypedDict iinde e atanamad',
        unaccessedClass: '"{name}" snfna eriilemiyor',
        unaccessedFunction: '"{name}" ilevine eriilemiyor',
        unaccessedImport: '"{name}" ieri aktarma ilemine eriilemiyor',
        unaccessedSymbol: '"{name}" esine eriilemiyor',
        unaccessedVariable: '"{name}" deikenine eriilemiyor',
        unannotatedFunctionSkipped: '"{name}" ilevinin analizi, aklanmadndan atland',
        unaryOperationNotAllowed: 'Tr ifadesinde birli ile kullanlamaz',
        unexpectedAsyncToken: '"async" esinin ardndan "def", "with" veya "for" bekleniyordu',
        unexpectedExprToken: 'fadenin sonunda beklenmeyen belirte',
        unexpectedIndent: 'Beklenmeyen girinti',
        unexpectedUnindent: 'Girintiyi kaldrma beklenmiyordu',
        unhashableDictKey: 'Szlk anahtar karmalanabilir olmaldr',
        unhashableSetEntry: 'Set entry must be hashable',
        uninitializedAbstractVariables: 'Soyut temel snfta tanmlanan deikenler "{classType}" final snfnda balatlmaz',
        uninitializedInstanceVariable: '"{name}" rnek deikeni snf gvdesinde veya __init__ metodunda balatlmad',
        unionForwardReferenceNotAllowed: 'Union sz dizimi dize ileneni ile kullanlamaz; ifadenin tamamn trnak iine aln',
        unionSyntaxIllegal: 'Union ilemlerinde alternatif sz dizimi kullanlabilmesi iin Python 3.10 veya daha yeni bir srm gerekiyor',
        unionTypeArgCount: 'Union iin iki veya daha fazla tr bamsz deikeni gerekiyor',
        unionUnpackedTuple: 'Union, paketlenmemi bir tuple ieremez',
        unionUnpackedTypeVarTuple: 'Union, paketlenmemi bir TypeVarTuple ieremez',
        unnecessaryCast: 'Gereksiz "cast" ars; tr zaten "{type}"',
        unnecessaryIsInstanceAlways: 'Gereksiz isinstance ars; "{testType}" her zaman bir "{classType}" rneidir',
        unnecessaryIsInstanceNever: 'Gereksiz isinstance ars; "{testType}" asla bir "{classType}" rnei deildir',
        unnecessaryIsSubclassAlways: 'Gereksiz issubclass ars; "{testType}" her zaman "{classType}" snf trnn bir alt snfdr',
        unnecessaryIsSubclassNever: 'Gereksiz issubclass ars; "{testType}" asla "{classType}" snf trnn bir alt snf deildir',
        unnecessaryPyrightIgnore: 'Gereksiz "# pyright: ignore" aklamas',
        unnecessaryPyrightIgnoreRule: '"# pyright: ignore" rule: "{name}" gereksiz',
        unnecessaryTypeIgnore: 'Unnecessary "# type: ignore" comment',
        unpackArgCount: '"Unpack" sonrasnda tek bir tr bamsz deiken bekleniyordu',
        unpackExpectedTypeVarTuple: 'Unpack iin tr bamsz deikeni olarak TypeVarTuple veya tuple bekleniyordu',
        unpackExpectedTypedDict: 'Unpack iin TypedDict tr bamsz deikeni bekleniyordu',
        unpackIllegalInComprehension: 'Anlamada paket ama ilemi kullanlamaz',
        unpackInAnnotation: 'Tr ifadesinde paket ama ileci kullanlamaz',
        unpackInDict: 'Szlklerde paket ama ilemi kullanlamaz',
        unpackInSet: 'Unpack operator not allowed within a set',
        unpackNotAllowed: 'Unpack is not allowed in this context',
        unpackOperatorNotAllowed: 'Bu balamda paket ama ilemi kullanlamaz',
        unpackTuplesIllegal: 'Python 3.8\'den nceki demetler iinde paket ama ilemi kullanlamyor',
        unpackedArgInTypeArgument: 'Paketlenmemi bamsz deikenler bu balamda kullanlamaz',
        unpackedArgWithVariadicParam: 'Paketlenmemi bamsz deiken, TypeVarTuple parametresi iin kullanlamaz',
        unpackedDictArgumentNotMapping: '** sonrasndaki bamsz deiken ifadesi "str" anahtar trne sahip bir eleme olmaldr',
        unpackedDictSubscriptIllegal: 'Alt simgede szlk ama ilecine izin verilmiyor',
        unpackedSubscriptIllegal: 'Alt simgede ama ileci iin Python 3.11 veya daha yeni bir srm gerekiyor',
        unpackedTypeVarTupleExpected: 'Paketlenmemi TypeVarTuple bekleniyordu; Unpack[{name1}] veya *{name2} kullann',
        unpackedTypedDictArgument: 'Paketlenmemi TypedDict bamsz deikeni parametrelerle elenemiyor',
        unreachableCode: 'Koda ulalamyor',
        unreachableCodeType: 'Tr analizi koda eriilemediini gsteriyor',
        unreachableExcept: 'Except clause is unreachable because exception is already handled',
        unsupportedDunderAllOperation: '"__all__" zerinde ilem desteklenmiyor, bu nedenle dar aktarlan sembol listesi yanl olabilir',
        unusedCallResult: 'ar ifadesinin sonucu "{type}" trnde ve kullanlmyor; bilerek yapldysa "_" deikenine atayn',
        unusedCoroutine: 'Result of async function call is not used; use "await" or assign result to variable',
        unusedExpression: 'fade deeri kullanlmad',
        varAnnotationIllegal: 'Type annotations for variables requires Python 3.6 or newer; use type comment for compatibility with previous versions',
        variableFinalOverride: '"{name}" deikeni Final olarak iaretlendi ve "{className}" snf iinde ayn ada sahip Final olmayan deikeni geersiz klyor',
        variadicTypeArgsTooMany: 'Tr bamsz deikeni listesinde en fazla bir paketlenmemi TypeVarTuple veya tuple olabilir',
        variadicTypeParamTooManyAlias: 'Tr dier ad en fazla bir TypeVarTuple tr parametresine sahip olabilir ancak birden fazlas {names}) alnd',
        variadicTypeParamTooManyClass: 'Genel snf en fazla bir TypeVarTuple tr parametresine sahip olabilir ancak birden fazlas {names}) alnd',
        walrusIllegal: '":=" ileci iin Python 3.8 veya daha yeni bir srm gerekiyor',
        walrusNotAllowed: 'evreleyen parantezler olmadan bu balamda ":=" ilecine izin verilmiyor',
        wildcardInFunction: 'Wildcard import not allowed within a class or function',
        wildcardLibraryImport: 'Wildcard import from a library not allowed',
        wildcardPatternTypePartiallyUnknown: 'Joker karakter deseni tarafndan yakalanan tr ksmen bilinmiyor',
        wildcardPatternTypeUnknown: 'Joker karakter deseni tarafndan yakalanan tr bilinmiyor',
        yieldFromIllegal: '"yield from" kullanm iin Python 3.3 veya daha yeni bir srm gerekiyor',
        yieldFromOutsideAsync: '"yield from" not allowed in an async function',
        yieldOutsideFunction: '"yield", ilev veya lambda dnda kullanlamaz',
        yieldWithinComprehension: 'Bir anlama iinde yield kullanlamaz',
        zeroCaseStatementsFound: 'Match deyimi en az bir case deyimi iermeli',
        zeroLengthTupleNotAllowed: 'Zero-length tuple is not allowed in this context'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: 'Annotated zel biimi, rnek ve snf denetimleriyle kullanlamaz',
        argParam: 'Bamsz deiken "{paramName}" parametresine karlk gelir',
        argParamFunction: 'Bamsz deiken, "{functionName}" ilevinde "{paramName}" parametresine karlk gelir',
        argsParamMissing: '"*{paramName}" parametresine karlk gelen bir parametre yok',
        argsPositionOnly: 'Yalnzca konum parametresi uyumazl; {expected} bekleniyordu ancak {received} alnd',
        argumentType: 'Bamsz deiken tr "{type}"',
        argumentTypes: 'Bamsz deiken trleri: ({types})',
        assignToNone: 'Tr "None" esine atanamaz',
        asyncHelp: '"async with" mi demek istediniz?',
        baseClassIncompatible: '"{baseClass}" temel snf "{type}" tryle uyumlu deil',
        baseClassIncompatibleSubclass: '"{baseClass}" temel snf, "{type}" tryle uyumlu olmayan "{subclass}" alt snfndan tretiliyor',
        baseClassOverriddenType: '"{baseClass}" temel snf geersiz klnan "{type}" trn salar',
        baseClassOverridesType: 'Temel snf "{baseClass}", "{type}" trn geersiz klyor',
        bytesTypePromotions: 'bytearray ve memoryview iin tr ykseltme davrann etkinletirmek iin disableBytesTypePromotions seeneini false olarak ayarlayn',
        conditionalRequiresBool: '"{operandType}" tr iin __bool__ metodu "bool" yerine "{boolReturnType}" tr dndrr',
        dataClassFieldLocation: 'Alan bildirimi',
        dataClassFrozen: '"{name}" donduruldu',
        dataProtocolUnsupported: '"{name}" bir veri protokol',
        descriptorAccessBindingFailed: 'Tanmlayc snf "{className}" iin "{name}" yntemi balanamad',
        descriptorAccessCallFailed: 'Tanmlayc snf "{className}" iin "{name}" yntemi arlamad',
        finalMethod: 'Final metodu',
        functionParamDefaultMissing: '"{name}" parametresinde varsaylan bamsz deiken eksik',
        functionParamName: 'Parametre ad uyumazl: "{destName}" ve "{srcName}"',
        functionParamPositionOnly: 'Yalnzca konum parametresi uyumazl; "{name}" parametresi yalnzca konum deil',
        functionReturnTypeMismatch: '"{sourceType}" ilev dn tr, "{destType}" tryle uyumsuz',
        functionTooFewParams: 'lev ok az konumsal parametre kabul ediyor; {expected} bekleniyordu ancak {received} alnd',
        functionTooManyParams: 'lev ok fazla konumsal parametre kabul ediyor; {expected} bekleniyordu ancak {received} alnd',
        genericClassNotAllowed: 'rnek veya snf denetimleri iin tr bamsz deikenlerine sahip genel tre izin verilmiyor',
        incompatibleDeleter: 'Property deleter method is incompatible',
        incompatibleGetter: 'Property getter method is incompatible',
        incompatibleSetter: 'Property setter method is incompatible',
        initMethodLocation: '"{type}" snf iinde __init__ metodu tanmland',
        initMethodSignature: '__init__ imzas "{type}"',
        initSubclassLocation: '__init_subclass__ yntemi "{name}" snf iinde tanmland',
        invariantSuggestionDict: 'dict esinden deer trnde e deiken olan Mapping esine gemeyi deneyin',
        invariantSuggestionList: 'list esinden e deiken olan Sequence esine gemeyi deneyin',
        invariantSuggestionSet: 'Consider switching from "set" to "Container" which is covariant',
        isinstanceClassNotSupported: '"{type}", rnek ve snf denetimleri iin desteklenmiyor',
        keyNotRequired: '"{name}", "{type}" trnde gerekli bir anahtar olmadndan alma zaman zel durumuna neden olabilir',
        keyReadOnly: '"{name}", "{type}" iinde salt okunur',
        keyRequiredDeleted: '"{name}" gerekli bir anahtar olduundan silinemez',
        keyUndefined: '"{name}", "{type}" iinde tanml bir anahtar deil',
        kwargsParamMissing: '"**{paramName}" parametresine karlk gelen bir parametre yok',
        listAssignmentMismatch: '"{type}" tr hedef listeyle uyumsuz',
        literalAssignmentMismatch: '"{sourceType}" "{destType}" trne atanamaz',
        matchIsNotExhaustiveHint: 'Tmlemeli ileme amalanmadysa "case _: pass" ekleyin',
        matchIsNotExhaustiveType: '"{type}" tr ilenmemi',
        memberAssignment: '"{type}" trndeki ifade, "{classType}" snfnn "{name}" zniteliine atanamaz',
        memberIsAbstract: '"{type}.{name}" uygulanmad',
        memberIsAbstractMore: 've +{count} tane daha...',
        memberIsClassVarInProtocol: '"{name}", protokolde ClassVar olarak tanmland',
        memberIsInitVar: '"{name}" is an init-only field',
        memberIsInvariant: '"{name}" deitirilebilir olduundan sabit ayarlanr',
        memberIsNotClassVarInClass: '"{name}" protokolle uyumlu olmas iin ClassVar olarak tanmlanmaldr',
        memberIsNotClassVarInProtocol: '"{name}" protokolde ClassVar olarak tanmlanmad',
        memberIsNotReadOnlyInProtocol: '"{name}" protokolde salt okunur durumda deil',
        memberIsReadOnlyInProtocol: '"{name}" protokolde salt okunur durumda',
        memberIsWritableInProtocol: '"{name}" protokolde yazlabilir',
        memberSetClassVar: '"{name}" znitelii bir ClassVar olduundan snf rnei araclyla atanamaz',
        memberTypeMismatch: '"{name}" uyumsuz bir tr',
        memberUnknown: '"{name}" znitelii bilinmiyor',
        metaclassConflict: 'Metaclass "{metaclass1}", "{metaclass2}" ile akyor',
        missingDeleter: 'Property deleter method is missing',
        missingGetter: 'Property getter method is missing',
        missingSetter: 'Property setter method is missing',
        namedParamMissingInDest: '"{name}" ek parametresi',
        namedParamMissingInSource: '"{name}" eksik anahtar szck parametresi',
        namedParamTypeMismatch: '"{sourceType}" trndeki "{name}" anahtar szck parametresi, "{destType}" tryle uyumsuz',
        namedTupleNotAllowed: 'NamedTuple rnek veya snf kontrolleri iin kullanlamaz',
        newMethodLocation: '"{type}" snf iinde __new__ metodu tanmland',
        newMethodSignature: '__new__ imzas "{type}"',
        newTypeClassNotAllowed: 'NewType ile oluturulan snf, rnek ve snf denetimleriyle kullanlamaz',
        noOverloadAssignable: 'Ar yklenmi ilevlerden hibiri "{type}" tryle uyumuyor',
        noneNotAllowed: 'rnek veya snf denetimleri iin None kullanlamaz',
        orPatternMissingName: 'Eksik adlar: {name}',
        overloadIndex: 'Ar ykleme {index} en yakn elemedir',
        overloadNotAssignable: 'Bir veya daha fazla "{name}" ar yklemesi atanabilir deil',
        overloadSignature: 'Ar ykleme imzas burada tanml',
        overriddenMethod: 'Geersiz klnan metot',
        overriddenSymbol: 'Geersiz klnan simge',
        overrideInvariantMismatch: '"{overrideType}" geersiz klma tr "{baseType}" temel tryle ayn deil',
        overrideIsInvariant: 'Deiken deiebilir, bu nedenle tr sabit',
        overrideNoOverloadMatches: 'Geersiz klmadaki hibir ar ykleme imzas temel metotla uyumlu deil',
        overrideNotClassMethod: 'Base method is declared as a classmethod but override is not',
        overrideNotInstanceMethod: 'Temel metot bir rnek metodu olarak bildirilir, ancak geersiz klma bu ekilde bildirilmez',
        overrideNotStaticMethod: 'Temel metot bir staticmethod olarak bildirilir, ancak geersiz klma bu ekilde bildirilmez',
        overrideOverloadNoMatch: 'Geersiz klma temel yntemin tm ar yklemelerini ilemez',
        overrideOverloadOrder: 'Geersiz klma metoduna ait ar yklemeler temel metotla ayn srada olmaldr',
        overrideParamKeywordNoDefault: '"{name}" anahtar szck parametresi elemiyor: Temel parametrede varsaylan bamsz deiken deer var, geersiz klma parametresinde yok',
        overrideParamKeywordType: '"{name}" anahtar szck parametresi tr uyumazl: temel parametre "{baseType}" trnde, geersiz klma parametresi "{overrideType}" trnde',
        overrideParamName: '{index} parametresi ad uyumazl: temel parametre ad "{baseName}", geersiz klma parametresinin ad "{overrideName}"',
        overrideParamNameExtra: 'Temelde "{name}" parametresi eksik',
        overrideParamNameMissing: 'Geersiz klmada "{name}" parametresi eksik',
        overrideParamNamePositionOnly: '{index} parametresi elemiyor: "{baseName}" temel parametresi, anahtar szck parametresidir, geersiz klma parametresi ise yalnzca konumdur',
        overrideParamNoDefault: '{index} parametresi elemiyor: Temel parametrede varsaylan bamsz deiken deer var, geersiz klma parametresinde yok',
        overrideParamType: '"{index}" parametresi tr uyumazl: temel parametre "{baseType}" trnde, geersiz klma parametresi "{overrideType}" trnde',
        overridePositionalParamCount: 'Konumsal parametre says uyumazl; temel metotta {baseCount} var, ancak geersiz klmada {overrideCount} var',
        overrideReturnType: 'Dn tr uyumazl: temel metot tr "{baseType}" tr dndrr, geersiz klma ise "{overrideType}" tr dndrr',
        overrideType: 'Temel snf, tr "{type}" olarak tanmlar',
        paramAssignment: '{index} parametresi: "{sourceType}" tr "{destType}" tryle uyumsuz',
        paramSpecMissingInOverride: 'Geersiz klma metodunda ParamSpec parametreleri eksik',
        paramType: 'Parametre tr "{paramType}"',
        privateImportFromPyTypedSource: 'Bunun yerine "{module}" zerinden ieri aktarn',
        propertyAccessFromProtocolClass: 'Protokol snf iinde tanmlanan bir zellie snf deikeni olarak eriilemez',
        propertyMethodIncompatible: 'Property method "{name}" is incompatible',
        propertyMethodMissing: 'Property method "{name}" is missing in override',
        propertyMissingDeleter: 'Property "{name}" has no defined deleter',
        propertyMissingSetter: 'Property "{name}" has no defined setter',
        protocolIncompatible: '"{sourceType}", "{destType}" protokol ayarlaryla uyumsuz',
        protocolMemberMissing: '"{name}" yok',
        protocolRequiresRuntimeCheckable: 'Protocol snfnn rnekle ve snf denetimleriyle birlikte kullanlabilmesi iin @runtime_checkable olmas gerekir',
        protocolSourceIsNotConcrete: '"{sourceType}" somut bir snf tr deil ve "{destType}" trne atanamaz',
        protocolUnsafeOverlap: '"{name}" znitelikleri protokolle ayn adlara sahip',
        pyrightCommentIgnoreTip: 'Tek bir satrda tanlamay durdurmak iin "# pyright: ignore[<diagnostic rules>]" kullann',
        readOnlyAttribute: '"{name}" znitelii salt okunur',
        seeClassDeclaration: 'Snf bildirimine bakn',
        seeDeclaration: 'Bildirime bakn',
        seeFunctionDeclaration: 'lev bildirimine bakn',
        seeMethodDeclaration: 'Metot bildirimine bakn',
        seeParameterDeclaration: 'Parametre bildirimine bakn',
        seeTypeAliasDeclaration: 'Tr dier ad bildirimine bakn',
        seeVariableDeclaration: 'Deiken bildirimine bakn',
        tupleAssignmentMismatch: 'Type "{type}" is incompatible with target tuple',
        tupleEntryTypeMismatch: 'Tuple entry {entry} is incorrect type',
        tupleSizeIndeterminateSrc: 'Tuple boyutu uyumuyor; {expected} bekleniyordu ancak indeterminate alnd',
        tupleSizeIndeterminateSrcDest: 'Tuple boyutu uyumuyor; {expected} veya daha byk bir deer bekleniyordu ancak belirsiz bir deer alnd',
        tupleSizeMismatch: 'Tuple size mismatch; expected {expected} but received {received}',
        tupleSizeMismatchIndeterminateDest: 'Tuple boyutu uyumuyor; {expected} veya daha byk bir deer bekleniyordu ancak {received} alnd',
        typeAliasInstanceCheck: 'Type deyimi ile oluturulan type dier ad rnek ve snf denetimleri kullanlamaz',
        typeAssignmentMismatch: '"{sourceType}" tr "{destType}" trne atanamaz',
        typeBound: '"{sourceType}" tr "{name}" tr deikeni iin "{destType}" st snrna atanamaz',
        typeConstrainedTypeVar: '"{type}" tr "{name}" kstlanm tr deikenine atanamaz',
        typeIncompatible: '"{sourceType}" "{destType}" esine atanamaz',
        typeNotClass: '"{type}" bir snf deil',
        typeNotStringLiteral: '"{type}" bir sabit deeri dize deil',
        typeOfSymbol: '"{name}" tr "{type}"',
        typeParamSpec: '"{type}" tr "{name}" ParamSpec ile uyumlu deil',
        typeUnsupported: '"{type}" tr desteklenmiyor',
        typeVarDefaultOutOfScope: '"{name}" tr deikeni kapsamda deil',
        typeVarIsContravariant: '"{name}" tr parametresi bir kart deiken ancak "{sourceType}", "{destType}" esinin bir st tr deil',
        typeVarIsCovariant: '"{name}" tr parametresi bir edeiken ancak "{sourceType}", "{destType}" esinin bir alt tr deil',
        typeVarIsInvariant: '"{name}" tr parametresi bir deimez deer ancak "{sourceType}", "{destType}" ile ayn deil',
        typeVarNotAllowed: 'rnek veya snf denetimleri iin TypeVar\'a izin verilmiyor',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple cannot be bound to a tuple of unknown length',
        typeVarUnnecessarySuggestion: 'Bunun yerine {type} kullann',
        typeVarUnsolvableRemedy: 'Bamsz deiken salanmamken dn trn belirten bir ar ykleme belirtin',
        typeVarsMissing: 'Eksik tr deikenleri: {names}',
        typedDictBaseClass: '"{type}" snf bir TypedDict deil',
        typedDictClassNotAllowed: 'rnek veya snf denetimleri iin TypedDict snfna izin verilmiyor',
        typedDictClosedExtraNotAllowed: '"{name}" esi eklenemiyor',
        typedDictClosedExtraTypeMismatch: '"{type}" trndeki "{name}" esi eklenemiyor',
        typedDictClosedFieldNotRequired: 'NotRequired olmas gerektiinden "{name}" esi eklenemiyor',
        typedDictExtraFieldNotAllowed: '"{name}" esi "{type}" trnde mevcut deil',
        typedDictExtraFieldTypeMismatch: '"{name}" tr, "{type}" altndaki "extra_items" tryle uyumlu deil',
        typedDictFieldMissing: '"{type}" iin "{name}" eksik',
        typedDictFieldNotReadOnly: '"{name}", "{type}" iinde salt okunur deil',
        typedDictFieldNotRequired: '"{type}" iinde "{name}" gerekli deil',
        typedDictFieldRequired: '"{type}" iinde "{name}" gerekiyor',
        typedDictFieldTypeMismatch: '"{type}" tr "{name}" esine atanamaz',
        typedDictFieldUndefined: '"{name}", "{type}" trndeki tanmsz bir edir',
        typedDictFinalMismatch: '"{sourceType}" @final uyumsuzluu nedeniyle "{destType}" ile uyumsuz',
        typedDictKeyAccess: 'TypedDictte eye bavurmak iin ["{name}"] deerini kullann',
        typedDictNotAllowed: 'TypedDict rnek veya snf kontrolleri iin kullanlamaz',
        unhashableType: '"{type}" tr karmalanabilir deil',
        uninitializedAbstractVariable: '"{name}" rnek deikeni, "{classType}" soyut temel snfnda tanmland ancak balatlmad',
        unreachableExcept: '"{exceptionType}", "{parentType}" st esinin bir alt snf',
        useDictInstead: 'Szlk trn belirtmek iin Dict[T1, T2] kullann',
        useListInstead: 'Use List[T] to indicate a list type or Union[T1, T2] to indicate a union type',
        useTupleInstead: 'Use tuple[T1, ..., Tn] to indicate a tuple type or Union[T1, T2] to indicate a union type',
        useTypeInstead: 'Bunun yerine Type[T] kullann',
        varianceMismatchForClass: '"{typeVarName}" tr bamsz deikeni "{className}" taban snfyla uyumsuz',
        varianceMismatchForTypeAlias: '"{typeVarName}" tr bamsz deikeninin varyans, "{typeAliasParam}" ile uyumsuz'
      },
      Service: {
        longOperation: 'alma alan kaynak dosyalarnn numaralandrlmas uzun zaman alyor. Bunun yerine bir alt klasr aabilirsiniz. [Daha fazla bilgi edinin](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  63982: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: ' Stub',
        createTypeStubFor: ' "{moduleName}"  Stub',
        executingCommand: '',
        filesToAnalyzeCount: ' {count} ',
        filesToAnalyzeOne: '1 ',
        findingReferences: '',
        organizeImports: ' Import',
        renameShadowedFile: '{oldFile}{newFile}'
      },
      Completion: {
        autoImportDetail: '',
        indexValueDetail: ''
      },
      Diagnostic: {
        abstractMethodInvocation: '{method}',
        annotatedMetadataInconsistent: '{metadataType}{type}',
        annotatedParamCountMismatch: ':  {expected} {received}',
        annotatedTypeArgMissing: 'Annotated',
        annotationBytesString: '',
        annotationFormatString: '(f-string)',
        annotationNotSupported: '',
        annotationRawString: '',
        annotationSpansStrings: '',
        annotationStringEscape: '',
        argAssignment: '{argType}{paramType}',
        argAssignmentFunction: '"{argType}""{functionName}""{paramType}"',
        argAssignmentParam: '{argType}{paramType}{paramName}',
        argAssignmentParamFunction: '{argType}{functionName}{paramType}{paramName}',
        argMissingForParam: ' {name} ',
        argMissingForParams: ' {names} ',
        argMorePositionalExpectedCount: ' {expected} ',
        argMorePositionalExpectedOne: ' 1 ',
        argPositional: '',
        argPositionalExpectedCount: ' {expected} ',
        argPositionalExpectedOne: ' 1 ',
        argTypePartiallyUnknown: '',
        argTypeUnknown: '',
        assertAlwaysTrue: ' true',
        assertTypeArgs: 'assert_type',
        assertTypeTypeMismatch: 'assert_type:{expected}{received}',
        assignmentExprComprehension: '{name}',
        assignmentExprContext: ' lambda ',
        assignmentExprInSubscript: ' Python 3.10 ',
        assignmentInProtocol: 'Protocol ',
        assignmentTargetExpr: '',
        asyncNotInAsyncFunction: ' async  "async"',
        awaitIllegal: ' await  Python 3.5 ',
        awaitNotAllowed: ' "await"',
        awaitNotInAsync: ' async  "await"',
        backticksIllegal: 'Python 3.x  repr',
        baseClassCircular: '',
        baseClassFinal: ' "{type}"  final ',
        baseClassIncompatible: '{type} ',
        baseClassInvalid: '',
        baseClassMethodTypeIncompatible: '{classType}{name}',
        baseClassUnknown: '',
        baseClassVariableTypeIncompatible: '{classType}{name}',
        binaryOperationNotAllowed: '',
        bindTypeMismatch: '{methodName}{type}{paramName}',
        breakInExceptionGroup: '"except*"  "break"',
        breakOutsideLoop: 'break',
        callableExtraArgs: '"Callable"',
        callableFirstArg: '...',
        callableNotInstantiable: '{type}',
        callableSecondArg: '"Callable"',
        casePatternIsIrrefutable: ' case ',
        classAlreadySpecialized: '"{type}"',
        classDecoratorTypeUnknown: ';',
        classDefinitionCycle: '{name}',
        classGetItemClsParam: '__class_getitem__cls',
        classMethodClsParam: 'cls',
        classNotRuntimeSubscriptable: ' "{name}" ; ',
        classPatternBuiltInArgPositional: '',
        classPatternPositionalArgCount: '{type};  {expected} {received}',
        classPatternTypeAlias: '{type}',
        classPropertyDeprecated: ' Python 3.11  Python 3.13 ',
        classTypeParametersIllegal: ' Python 3.12 ',
        classVarFirstArgMissing: '"ClassVar"',
        classVarNotAllowed: 'ClassVar',
        classVarOverridesInstanceVar: '"{name}""{className}"',
        classVarTooManyArgs: 'ClassVar',
        classVarWithTypeVar: 'ClassVar',
        clsSelfParamTypeMismatch: '{name}{classType}',
        codeTooComplexToAnalyze: '',
        collectionAliasInstantiation: '{type}{alias}',
        comparisonAlwaysFalse: ' False{leftType}{rightType}',
        comparisonAlwaysTrue: ' True{leftType}{rightType}',
        comprehensionInDict: '',
        comprehensionInSet: ' set ',
        concatenateContext: 'Concatenate',
        concatenateParamSpecMissing: 'Concatenate ParamSpec  "..."',
        concatenateTypeArgsMissing: 'Concatenate ',
        conditionalOperandInvalid: '{type}',
        constantRedefinition: '{name} ()',
        constructorParametersMismatch: '{classType}__new____init__',
        containmentAlwaysFalse: ' False{leftType}{rightType}',
        containmentAlwaysTrue: ' True{leftType}{rightType}',
        continueInExceptionGroup: '"except*"  "continue"',
        continueOutsideLoop: 'continue',
        coroutineInConditionalExpression: ' True ',
        dataClassBaseClassFrozen: '',
        dataClassBaseClassNotFrozen: '',
        dataClassConverterFunction: '{argType}{fieldType}{fieldName}',
        dataClassConverterOverloads: '{funcName}{fieldType}{fieldName}',
        dataClassFieldInheritedDefault: '{fieldName}',
        dataClassFieldWithDefault: '',
        dataClassFieldWithPrivateName: '',
        dataClassFieldWithoutAnnotation: '',
        dataClassPostInitParamCount: '__post_init__InitVar  {expected}',
        dataClassPostInitType: '__post_init__ "{fieldName}"',
        dataClassSlotsOverwrite: '__slots__',
        dataClassTransformExpectedBoolLiteral: ' True  False ',
        dataClassTransformFieldSpecifier: ' tuple "{type}"',
        dataClassTransformPositionalParam: 'dataclass_transform',
        dataClassTransformUnknownArgument: 'dataclass_transform{name}',
        dataProtocolInSubclassCheck: 'issubclass ()',
        declaredReturnTypePartiallyUnknown: '{returnType}',
        declaredReturnTypeUnknown: '',
        defaultValueContainsCall: '',
        defaultValueNotAllowed: '***',
        delTargetExpr: '',
        deprecatedClass: '"{name}"',
        deprecatedConstructor: '"{name}"',
        deprecatedDescriptorDeleter: '{name}__delete__',
        deprecatedDescriptorGetter: '{name}__get__',
        deprecatedDescriptorSetter: '{name}__set__',
        deprecatedFunction: '{name}',
        deprecatedMethod: '{className}{name}',
        deprecatedPropertyDeleter: ' property "{name}"  deleter',
        deprecatedPropertyGetter: ' property "{name}"  getter',
        deprecatedPropertySetter: ' property "{name}"  setter',
        deprecatedType: ' Python {version} {replacement}',
        dictExpandIllegalInComprehension: '',
        dictInAnnotation: '',
        dictKeyValuePairs: '/',
        dictUnpackIsNotMapping: '',
        dunderAllSymbolNotPresent: '"{name}"__all__',
        duplicateArgsParam: ' "*" ',
        duplicateBaseClass: '',
        duplicateCapturePatternTarget: '{name}',
        duplicateCatchAll: ' catch-all except ',
        duplicateEnumMember: 'Enum  "{name}" ',
        duplicateGenericAndProtocolBase: ' Generic[...]  Protocol[...] ',
        duplicateImport: '{importName}',
        duplicateKeywordOnly: '*',
        duplicateKwargsParam: ' ** ',
        duplicateParam: '{name}',
        duplicatePositionOnly: '/',
        duplicateStarPattern: '*',
        duplicateStarStarPattern: '**',
        duplicateUnpack: 'list ',
        ellipsisAfterUnpacked: '"..."  TypeVarTuple  tuple ',
        ellipsisContext: ' "..."',
        ellipsisSecondArg: ' "..." ',
        enumClassOverride: 'Enum  "{name}"  final ',
        enumMemberDelete: ' Enum  "{name}"',
        enumMemberSet: ' Enum  "{name}"',
        enumMemberTypeAnnotation: 'enum ',
        exceptGroupMismatch: 'Try  "except"  "except*"',
        exceptGroupRequiresType: '("except*")',
        exceptionGroupIncompatible: ' ("except*")  Python 3.11 ',
        exceptionGroupTypeIncorrect: 'except*  BaseGroupException',
        exceptionTypeIncorrect: '"{type}"  BaseException',
        exceptionTypeNotClass: '{type}',
        exceptionTypeNotInstantiable: '"{type}"',
        expectedAfterDecorator: '',
        expectedArrow: '->',
        expectedAsAfterException: 'as',
        expectedAssignRightHandExpr: ' = ',
        expectedBinaryRightHandExpr: '',
        expectedBoolLiteral: ' True  False',
        expectedCase: ' case ',
        expectedClassName: '',
        expectedCloseBrace: '"{" ',
        expectedCloseBracket: '[',
        expectedCloseParen: '"(" ',
        expectedColon: ' ":"',
        expectedComplexNumberLiteral: '',
        expectedDecoratorExpr: 'Python 3.9 ',
        expectedDecoratorName: '',
        expectedDecoratorNewline: '',
        expectedDelExpr: '"del"',
        expectedElse: ' "else"',
        expectedEquals: ' "="',
        expectedExceptionClass: '',
        expectedExceptionObj: ' None',
        expectedExpr: '',
        expectedFunctionAfterAsync: '"async"',
        expectedFunctionName: 'def',
        expectedIdentifier: '',
        expectedImport: ' "import"',
        expectedImportAlias: ' as ',
        expectedImportSymbols: '"import" ',
        expectedIn: ' "in"',
        expectedInExpr: '"in"',
        expectedIndentedBlock: '',
        expectedMemberName: '"." ',
        expectedModuleName: '',
        expectedNameAfterAs: '"as" ',
        expectedNamedParameter: ' * ',
        expectedNewline: '',
        expectedNewlineOrSemicolon: '',
        expectedOpenParen: ' "("',
        expectedParamName: '',
        expectedPatternExpr: '',
        expectedPatternSubjectExpr: '',
        expectedPatternValue: ' a.b',
        expectedReturnExpr: 'return ',
        expectedSliceIndex: '',
        expectedTypeNotString: '',
        expectedTypeParameterName: '',
        expectedYieldExpr: 'yield ',
        finalClassIsAbstract: '{type} final',
        finalContext: ' "Final"',
        finalInLoop: ' "Final" ',
        finalMethodOverride: ' "{name}"  "{className}"  final ',
        finalNonMethod: '{name} @final',
        finalReassigned: '"{name}" Final',
        finalRedeclaration: '"{name}" Final',
        finalRedeclarationBySubclass: '{name}{className} Final',
        finalTooManyArgs: 'Final',
        finalUnassigned: '"{name}"  Final',
        formatStringBrace: 'f ',
        formatStringBytes: '(f )',
        formatStringDebuggingIllegal: 'F = Python 3.8 ',
        formatStringEscape: 'Python 3.12  f ()',
        formatStringExpectedConversion: ' f  "!" ',
        formatStringIllegal: '(f ) Python 3.6 ',
        formatStringInPattern: '',
        formatStringNestedFormatSpecifier: '',
        formatStringNestedQuote: ' f  Python 3.12  f ',
        formatStringUnicode: '(f ) unicode',
        formatStringUnterminated: 'f  "}"',
        functionDecoratorTypeUnknown: '',
        functionInConditionalExpression: ' True ',
        functionTypeParametersIllegal: ' Python 3.12 ',
        futureImportLocationNotAllowed: '__future__',
        generatorAsyncReturnType: 'async  "AsyncGenerator[{yieldType}, Any]" ',
        generatorNotParenthesized: '',
        generatorSyncReturnType: ' "Generator[{yieldType}, Any, Any]"',
        genericBaseClassNotAllowed: 'Generic ',
        genericClassAssigned: '',
        genericClassDeleted: '',
        genericInstanceVariableAccess: '',
        genericNotAllowed: '"Generic" ',
        genericTypeAliasBoundTypeVar: ' {names}',
        genericTypeArgMissing: 'Generic',
        genericTypeArgTypeVar: 'Generic',
        genericTypeArgUnique: 'Generic',
        globalReassignment: '"{name}"  global ',
        globalRedefinition: '"{name}"  global',
        implicitStringConcat: '',
        importCycleDetected: '',
        importDepthExceeded: ' {depth}',
        importResolveFailure: '{importName}',
        importSourceResolveFailure: '{importName}',
        importSymbolUnknown: '{name}',
        incompatibleMethodOverride: '{name}{className}',
        inconsistentIndent: '',
        inconsistentTabs: '',
        initMethodSelfParamTypeVar: '"__init__"  self ',
        initMustReturnNone: '__init__ None',
        initSubclassCallFailed: '__init_subclass__ ',
        initSubclassClsParam: '__init_subclass__cls',
        initVarNotAllowed: 'InitVar',
        instanceMethodSelfParam: ' self ',
        instanceVarOverridesClassVar: '"{name}""{className}"',
        instantiateAbstract: '{type}',
        instantiateProtocol: ' Protocol  "{type}"',
        internalBindError: '{file}:{message}',
        internalParseError: '{file}:{message}',
        internalTypeCheckingError: '{file}:{message}',
        invalidIdentifierChar: '',
        invalidStubStatement: ' stub ',
        invalidTokenChars: '"{text}"',
        isInstanceInvalidType: '"isinstance"  tuple',
        isSubclassInvalidType: '"issubclass"  tuple',
        keyValueInSet: ' set /',
        keywordArgInTypeArgument: '',
        keywordArgShortcutIllegal: ' Python 3.14 ',
        keywordOnlyAfterArgs: '*',
        keywordParameterMissing: ' "*"',
        keywordSubscriptIllegal: '',
        lambdaReturnTypePartiallyUnknown: 'lambda {returnType}',
        lambdaReturnTypeUnknown: 'lambda ',
        listAssignmentMismatch: ' "{type}" ',
        listInAnnotation: ' List ',
        literalEmptyArgs: 'Literal',
        literalNamedUnicodeEscape: '"Literal"  unicode ',
        literalNotAllowed: ' "Literal" ',
        literalNotCallable: ' Literal ',
        literalUnsupportedType: '"Literal"  None(intboolstr  bytes) enum ',
        matchIncompatible: 'Match  Python 3.10 ',
        matchIsNotExhaustive: 'match ',
        maxParseDepthExceeded: ';',
        memberAccess: '{type}{name}',
        memberDelete: '{type}{name}',
        memberSet: '{type}{name}',
        metaclassConflict: '',
        metaclassDuplicate: '',
        metaclassIsGeneric: '',
        methodNotDefined: '{name}',
        methodNotDefinedOnType: '"{type}""{name}"',
        methodOrdering: '',
        methodOverridden: '{name}{type}{className}',
        methodReturnsNonObject: '{name}',
        missingSuperCall: '{methodName}',
        mixingBytesAndStr: 'Bytes  str ',
        moduleAsType: '',
        moduleNotCallable: '',
        moduleUnknownMember: '{memberName}{moduleName}',
        namedExceptAfterCatchAll: ' except  catch-all except ',
        namedParamAfterParamSpecArgs: '{name} ParamSpec args ',
        namedTupleEmptyName: ' tuple ',
        namedTupleEntryRedeclared: ' "{name}" "{className}"  tuple',
        namedTupleFirstArg: ' tuple ',
        namedTupleMultipleInheritance: ' NamedTuple ',
        namedTupleNameKeyword: '',
        namedTupleNameType: ' tuple',
        namedTupleNameUnique: ' tuple ',
        namedTupleNoTypes: 'namedtupleNamedTuple',
        namedTupleSecondArg: ' tuple  list ',
        newClsParam: '__new__cls',
        newTypeAnyOrUnknown: 'NewType  Any  Unknown',
        newTypeBadName: 'NewType ',
        newTypeLiteral: 'NewType  Literal ',
        newTypeNameMismatch: ' NewType ',
        newTypeNotAClass: ' NewType ',
        newTypeParamCount: 'NewType ',
        newTypeProtocolClass: 'NewType (Protocol  TypedDict )',
        noOverload: '{name}',
        noReturnContainsReturn: ' return  "NoReturn"  return ',
        noReturnContainsYield: ' NoReturn  yield ',
        noReturnReturnsNone: ' "NoReturn"  "None"',
        nonDefaultAfterDefault: '',
        nonLocalInModule: ' nonlocal ',
        nonLocalNoBinding: ' nonlocal "{name}" ',
        nonLocalReassignment: '"{name}"  nonlocal ',
        nonLocalRedefinition: '"{name}"  nonlocal',
        noneNotCallable: 'None',
        noneNotIterable: 'None',
        noneNotSubscriptable: 'None',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: 'None"{operator}"',
        noneUnknownMember: '{name} "None" ',
        notRequiredArgCount: 'NotRequired ',
        notRequiredNotInTypedDict: 'NotRequired',
        objectNotCallable: '{type}',
        obscuredClassDeclaration: '"{name}"',
        obscuredFunctionDeclaration: '{name}',
        obscuredMethodDeclaration: '{name}',
        obscuredParameterDeclaration: '{name}',
        obscuredTypeAliasDeclaration: '{name}',
        obscuredVariableDeclaration: '{name}',
        operatorLessOrGreaterDeprecated: 'Python 3 <> "!="',
        optionalExtraArgs: '"Optional"',
        orPatternIrrefutable: ' "or"',
        orPatternMissingName: 'or',
        overlappingKeywordArgs: ': {names}',
        overlappingOverload: '{name} {obscured} {obscuredBy} ',
        overloadAbstractImplMismatch: '',
        overloadAbstractMismatch: '',
        overloadClassMethodInconsistent: '{name} @classmethod ',
        overloadFinalInconsistencyImpl: '{name} @final',
        overloadFinalInconsistencyNoImpl: '{name} {index}  @final 1 ',
        overloadImplementationMismatch: ' {index} ',
        overloadReturnTypeMismatch: '{name} {prevIndex}  {newIndex} ',
        overloadStaticMethodInconsistent: '{name} @staticmethod ',
        overloadWithoutImplementation: '"{name}"  overload',
        overriddenMethodNotFound: ' "{name}"  override',
        overrideDecoratorMissing: ' "{name}"  override  "{className}" ',
        paramAfterKwargsParam: '**',
        paramAlreadyAssigned: '{name}',
        paramAnnotationMissing: '{name}',
        paramAssignmentMismatch: '"{sourceType}""{paramType}"',
        paramNameMissing: '{name}',
        paramSpecArgsKwargsDuplicate: ' ParamSpec "{type}" ',
        paramSpecArgsKwargsUsage: 'ParamSpec  "args"  "kwargs" ',
        paramSpecArgsMissing: ' ParamSpec{type}',
        paramSpecArgsUsage: 'ParamSpec  "args"  *args ',
        paramSpecAssignedName: ' ParamSpec {name}',
        paramSpecContext: ' ParamSpec',
        paramSpecDefaultNotTuple: 'ParamSpec tuple  ParamSpec',
        paramSpecFirstArg: 'ParamSpec ',
        paramSpecKwargsUsage: 'ParamSpec  "kwargs"  **kwargs ',
        paramSpecNotUsedByOuterScope: 'ParamSpec{name}',
        paramSpecUnknownArg: 'ParamSpec ',
        paramSpecUnknownMember: '{name} ParamSpec ',
        paramSpecUnknownParam: '{name} ParamSpec ',
        paramTypeCovariant: '',
        paramTypePartiallyUnknown: '"{paramName}"',
        paramTypeUnknown: '{paramName}',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: '{type}',
        positionArgAfterNamedArg: '',
        positionOnlyAfterArgs: '*',
        positionOnlyAfterKeywordOnly: '/*',
        positionOnlyAfterNon: '',
        positionOnlyFirstParam: '',
        positionOnlyIncompatible: ' Python 3.8 ',
        privateImportFromPyTypedModule: '{module}{name}',
        privateUsedOutsideOfClass: '"{name}"',
        privateUsedOutsideOfModule: '{name}',
        propertyOverridden: '"{name}"  "{className}"  property',
        propertyStaticMethod: 'property gettersetter  deleter ',
        protectedUsedOutsideOfClass: '{name}',
        protocolBaseClass: 'Protocol  "{classType}"  Protocol  "{baseType}"',
        protocolBaseClassWithTypeArgs: 'Protocol ',
        protocolIllegal: ' "Protocol"  Python 3.7 ',
        protocolNotAllowed: '"Protocol" ',
        protocolTypeArgMustBeTypeParam: '"Protocol" ',
        protocolUnsafeOverlap: '{name}',
        protocolVarianceContravariant: ' Protocol "{class}"  "{variable}" ',
        protocolVarianceCovariant: ' Protocol "{class}"  "{variable}" ',
        protocolVarianceInvariant: ' Protocol "{class}"  "{variable}" ',
        pyrightCommentInvalidDiagnosticBoolValue: 'Pyright = true  false ',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Pyright = truefalseerrorwarninginformation  none',
        pyrightCommentMissingDirective: 'Pyright (basic  strict)',
        pyrightCommentNotOnOwnLine: ' Pyright ',
        pyrightCommentUnknownDiagnosticRule: '{rule} pyright ',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}" pyright  truefalseerrorwarninginformation  none',
        pyrightCommentUnknownDirective: '"{directive}" pyright  strict  basic',
        readOnlyArgCount: 'ReadOnly',
        readOnlyNotInTypedDict: 'ReadOnly',
        recursiveDefinition: '{name}',
        relativeImportNotAllowed: 'import .a "from . import a"',
        requiredArgCount: '"Required"',
        requiredNotInTypedDict: '"Required"',
        returnInAsyncGenerator: 'async  return ',
        returnInExceptionGroup: '"except*"  "return"',
        returnMissing: '{returnType}',
        returnOutsideFunction: 'return',
        returnTypeContravariant: '',
        returnTypeMismatch: '{exprType}{returnType}',
        returnTypePartiallyUnknown: '{returnType}',
        returnTypeUnknown: '',
        revealLocalsArgs: 'reveal_locals',
        revealLocalsNone: ' locals ',
        revealTypeArgs: 'reveal_type',
        revealTypeExpectedTextArg: 'reveal_typeexpected_text str ',
        revealTypeExpectedTextMismatch: '"{expected}""{received}"',
        revealTypeExpectedTypeMismatch: ';{expected}{received}',
        selfTypeContext: 'Self',
        selfTypeMetaclass: 'Self(type)',
        selfTypeWithTypedSelfOrCls: 'SelfselfclsSelf',
        setterGetterTypeMismatch: 'Property setter  getter ',
        singleOverload: '{name}',
        slotsAttributeError: '__slots__{name}',
        slotsClassVarConflict: '"{name}"__slots__',
        starPatternInAsPattern: 'as',
        starPatternInOrPattern: ' ORed',
        starStarWildcardNotAllowed: '** _',
        staticClsSelfParam: 'selfcls',
        stdlibModuleOverridden: '"{path}" stdlib "{name}"',
        stringNonAsciiBytes: ' ASCII ()',
        stringNotSubscriptable: '; ',
        stringUnsupportedEscape: '',
        stringUnterminated: '',
        stubFileMissing: ' "{importName}"  Stub ',
        stubUsesGetAttr: ' stub ; "__getattr__" ',
        sublistParamsIncompatible: 'Python 3.x  Sublist ',
        superCallArgCount: 'super ',
        superCallFirstArg: 'super{type}',
        superCallSecondArg: 'super{type}',
        superCallZeroArgForm: '"super" ',
        superCallZeroArgFormStaticMethod: 'super',
        symbolIsPossiblyUnbound: '{name}',
        symbolIsUnbound: '{name}',
        symbolIsUndefined: '{name}',
        symbolOverridden: '{name}{className}',
        ternaryNotAllowed: '',
        totalOrderingMissingMethod: '__lt____le____gt____ge__total_ordering',
        trailingCommaInFromImport: '',
        tryWithoutExcept: 'Try  except  finally ',
        tupleAssignmentMismatch: ' "{type}"  tuple',
        tupleInAnnotation: ' tuple ',
        tupleIndexOutOfRange: ' {type}  {index} ',
        typeAliasIllegalExpressionForm: '',
        typeAliasIsRecursiveDirect: '{name}',
        typeAliasNotInModuleOrClass: 'TypeAlias ',
        typeAliasRedeclared: '{name} TypeAlias',
        typeAliasStatementBadScope: 'type ',
        typeAliasStatementIllegal: ' Python 3.12 ',
        typeAliasTypeBaseClass: '"type" ',
        typeAliasTypeMustBeAssigned: ' TypeAliasType ',
        typeAliasTypeNameArg: 'TypeAliasType ',
        typeAliasTypeNameMismatch: '',
        typeAliasTypeParamInvalid: ' TypeVarTypeVarTuple  ParamSpec  tuple',
        typeAnnotationCall: '',
        typeAnnotationVariable: '',
        typeAnnotationWithCallable: 'type; ',
        typeArgListExpected: ' ParamSpec list',
        typeArgListNotAllowed: ' list ',
        typeArgsExpectingNone: '{name}',
        typeArgsMismatchOne: ' {received}',
        typeArgsMissingForAlias: '{name}',
        typeArgsMissingForClass: '{name}',
        typeArgsTooFew: '{name} {expected} {received}',
        typeArgsTooMany: '{name} {expected} {received}',
        typeAssignmentMismatch: '{sourceType}{destType}',
        typeAssignmentMismatchWildcard: '{name}{sourceType}{destType}',
        typeCallNotAllowed: ' type() ',
        typeCheckOnly: '{name} @type_check_only',
        typeCommentDeprecated: ' type ;  type ',
        typeExpectedClass: '{type}',
        typeFormArgs: '"TypeForm" ',
        typeGuardArgCount: 'TypeGuardTypeIs',
        typeGuardParamCount: '',
        typeIsReturnType: 'TypeIs ({returnType})({type})',
        typeNotAwaitable: '"{type}"  awaitable',
        typeNotIntantiable: '"{type}"',
        typeNotIterable: '{type}',
        typeNotSpecializable: '{type}',
        typeNotSubscriptable: '{type}',
        typeNotSupportBinaryOperator: '{leftType}{rightType}{operator}',
        typeNotSupportBinaryOperatorBidirectional: '{expectedType}{leftType}{rightType}{operator}',
        typeNotSupportUnaryOperator: '{type}{operator}',
        typeNotSupportUnaryOperatorBidirectional: ' "{expectedType}""{type}""{operator}"',
        typeNotUsableWith: '"{type}" with {method}',
        typeParameterBoundNotAllowed: ' variadic  ParamSpec ',
        typeParameterConstraintTuple: '',
        typeParameterExistingTypeParameter: '"{name}"',
        typeParameterNotDeclared: '{name}{container}',
        typeParametersMissing: '',
        typePartiallyUnknown: '{name}',
        typeUnknown: '"{name}"',
        typeVarAssignedName: ' TypeVar {name}',
        typeVarAssignmentMismatch: '"{type}""{name}"',
        typeVarBoundAndConstrained: 'TypeVar ',
        typeVarBoundGeneric: 'TypeVar ',
        typeVarConstraintGeneric: 'TypeVar ',
        typeVarDefaultBoundMismatch: 'TypeVar ',
        typeVarDefaultConstraintMismatch: 'TypeVar ',
        typeVarDefaultIllegal: ' Python 3.13 ',
        typeVarDefaultInvalidTypeVar: '{name}',
        typeVarFirstArg: 'TypeVar ',
        typeVarInvalidForMemberVariable: '"{name}"',
        typeVarNoMember: 'TypeVar{type}{name}',
        typeVarNotSubscriptable: 'TypeVar{type}',
        typeVarNotUsedByOuterScope: '{name}',
        typeVarPossiblyUnsolvable: '"{param}""{name}"',
        typeVarSingleConstraint: 'TypeVar ',
        typeVarTupleConstraints: 'TypeVarTuple ',
        typeVarTupleContext: ' TypeVarTuple',
        typeVarTupleDefaultNotUnpacked: 'TypeVarTuple  tuple  TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'TypeVarTuple ',
        typeVarTupleUnknownParam: '{name} TypeVarTuple ',
        typeVarUnknownParam: '"{name}"  TypeVar ',
        typeVarUsedByOuterScope: 'TypeVar{name}',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" ',
        typeVarVariance: 'TypeVar ',
        typeVarWithDefaultFollowsVariadic: 'TypeVar{typeVarName} TypeVarTuple{variadicName}',
        typeVarWithoutDefault: '{name}{other}',
        typeVarsNotInGenericOrProtocol: 'Generic[]  Protocol[] ',
        typedDictAccess: ' TypedDict ',
        typedDictAssignedName: ' TypedDict {name}',
        typedDictBadVar: 'TypedDict ',
        typedDictBaseClass: 'TypedDict  TypedDict ',
        typedDictBoolParam: '{name} True  False',
        typedDictClosedExtras: ' "{name}"  closed TypedDict;  "{type}"',
        typedDictClosedNoExtras: ' "{name}"  closed TypedDict; ',
        typedDictDelete: ' TypedDict ',
        typedDictEmptyName: 'TypedDict ',
        typedDictEntryName: '',
        typedDictEntryUnique: '',
        typedDictExtraArgs: ' TypedDict ',
        typedDictExtraItemsClosed: ' TypedDict  closed',
        typedDictFieldNotRequiredRedefinition: ' TypedDict {name} NotRequired',
        typedDictFieldReadOnlyRedefinition: ' TypedDict {name} ReadOnly',
        typedDictFieldRequiredRedefinition: ' TypedDict {name} Required',
        typedDictFirstArg: ' TypedDict ',
        typedDictInClassPattern: ' TypedDict ',
        typedDictInitsubclassParameter: 'TypedDict  __init_subclass__ parameter{name}',
        typedDictNotAllowed: '"TypedDict" ',
        typedDictSecondArgDict: ' dict ',
        typedDictSecondArgDictEntry: '',
        typedDictSet: ' TypedDict ',
        unaccessedClass: '{name}',
        unaccessedFunction: '"{name}"',
        unaccessedImport: '{name}',
        unaccessedSymbol: '{name}',
        unaccessedVariable: '{name}',
        unannotatedFunctionSkipped: '{name}',
        unaryOperationNotAllowed: '',
        unexpectedAsyncToken: 'defwith  for  async',
        unexpectedExprToken: '',
        unexpectedIndent: '',
        unexpectedUnindent: '',
        unhashableDictKey: '',
        unhashableSetEntry: 'Set ',
        uninitializedAbstractVariables: ' final  "{classType}" ',
        uninitializedInstanceVariable: '__init__{name}',
        unionForwardReferenceNotAllowed: 'Union ; ',
        unionSyntaxIllegal: ' Python 3.10 ',
        unionTypeArgCount: 'Union ',
        unionUnpackedTuple: 'Union  tuple',
        unionUnpackedTypeVarTuple: 'Union  TypeVarTuple',
        unnecessaryCast: ' "cast" {type}',
        unnecessaryIsInstanceAlways: ' isinstance {testType}{classType}',
        unnecessaryIsInstanceNever: ' isinstance {testType}{classType}',
        unnecessaryIsSubclassAlways: ' issubclass {testType}{classType}',
        unnecessaryIsSubclassNever: ' issubclass {testType}{classType}',
        unnecessaryPyrightIgnore: ' "# pyright: ignore" ',
        unnecessaryPyrightIgnoreRule: ' "# pyright: ignore": "{name}"',
        unnecessaryTypeIgnore: ' "# type: ignore" ',
        unpackArgCount: '"Unpack"',
        unpackExpectedTypeVarTuple: 'Unpack  TypeVarTuple  tuple ',
        unpackExpectedTypedDict: 'Unpack  TypedDict ',
        unpackIllegalInComprehension: '',
        unpackInAnnotation: '',
        unpackInDict: '',
        unpackInSet: 'set ',
        unpackNotAllowed: ' Unpack',
        unpackOperatorNotAllowed: '',
        unpackTuplesIllegal: 'Python 3.8 ',
        unpackedArgInTypeArgument: '',
        unpackedArgWithVariadicParam: ' TypeVarTuple ',
        unpackedDictArgumentNotMapping: '** str',
        unpackedDictSubscriptIllegal: '',
        unpackedSubscriptIllegal: ' Python 3.11 ',
        unpackedTypeVarTupleExpected: ' TypeVarTuple Unpack[{name1}]  *{name2}',
        unpackedTypedDictArgument: ' TypedDict ',
        unreachableCode: '',
        unreachableCodeType: '',
        unreachableExcept: ' Except ',
        unsupportedDunderAllOperation: '__all__',
        unusedCallResult: ' "{type}"  _',
        unusedCoroutine: ' async ;  "await" ',
        unusedExpression: '',
        varAnnotationIllegal: ' Type  Python 3.6 ;  type ',
        variableFinalOverride: '"{name}" Final"{className}" Final ',
        variadicTypeArgsTooMany: ' TypeVarTuple  tuple',
        variadicTypeParamTooManyAlias: ' TypeVarTuple  ({names})',
        variadicTypeParamTooManyClass: ' TypeVarTuple  ({names})',
        walrusIllegal: ' ":="  Python 3.8 ',
        walrusNotAllowed: ' ":="',
        wildcardInFunction: ' import',
        wildcardLibraryImport: ' import ',
        wildcardPatternTypePartiallyUnknown: '',
        wildcardPatternTypeUnknown: '',
        yieldFromIllegal: 'yield from Python 3.3 ',
        yieldFromOutsideAsync: 'async  "yield from"',
        yieldOutsideFunction: ' lambda yield',
        yieldWithinComprehension: ' "yield"',
        zeroCaseStatementsFound: 'Match  case ',
        zeroLengthTupleNotAllowed: ' tuple'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '"Annotated" ',
        argParam: '{paramName}',
        argParamFunction: '{functionName}{paramName}',
        argsParamMissing: '*{paramName}',
        argsPositionOnly: ' {expected} {received}',
        argumentType: '{type}',
        argumentTypes: ':({types})',
        assignToNone: 'None',
        asyncHelp: 'async with?',
        baseClassIncompatible: '{baseClass}{type}',
        baseClassIncompatibleSubclass: '{baseClass}{type}{subclass}',
        baseClassOverriddenType: '"{baseClass}""{type}"',
        baseClassOverridesType: '{baseClass}{type}',
        bytesTypePromotions: ' disableBytesTypePromotions  falsebytearraymemoryview',
        conditionalRequiresBool: '{operandType}__bool__{boolReturnType}bool',
        dataClassFieldLocation: '',
        dataClassFrozen: '"{name}"',
        dataProtocolUnsupported: '{name}',
        descriptorAccessBindingFailed: '{className}{name}',
        descriptorAccessCallFailed: '{className}{name}',
        finalMethod: 'Final ',
        functionParamDefaultMissing: '{name}',
        functionParamName: ': "{destName}" versus "{srcName}"',
        functionParamPositionOnly: '; {name}',
        functionReturnTypeMismatch: '"{sourceType}""{destType}"',
        functionTooFewParams: ' {expected} {received}',
        functionTooManyParams: ' {expected} {received}',
        genericClassNotAllowed: '',
        incompatibleDeleter: 'Property deleter ',
        incompatibleGetter: 'Property getter ',
        incompatibleSetter: 'Property setter ',
        initMethodLocation: '__init__{type}',
        initMethodSignature: '__init__{type}',
        initSubclassLocation: '__init_subclass__ {name}',
        invariantSuggestionDict: ' dict  Mapping()',
        invariantSuggestionList: 'listSequence()',
        invariantSuggestionSet: 'setContainer',
        isinstanceClassNotSupported: '{type}',
        keyNotRequired: '{type}{name}',
        keyReadOnly: '{name}{type}',
        keyRequiredDeleted: '{name}',
        keyUndefined: '{name}{type}',
        kwargsParamMissing: '**{paramName}',
        listAssignmentMismatch: '{type}',
        literalAssignmentMismatch: '{sourceType}{destType}',
        matchIsNotExhaustiveHint: '"case _: pass"',
        matchIsNotExhaustiveType: ': "{type}"',
        memberAssignment: '{type}{classType}{name}',
        memberIsAbstract: '{type}.{name}',
        memberIsAbstractMore: ' {count} ...',
        memberIsClassVarInProtocol: '{name} ClassVar',
        memberIsInitVar: '"{name}"  init-only ',
        memberIsInvariant: '{name}',
        memberIsNotClassVarInClass: '{name} ClassVar ',
        memberIsNotClassVarInProtocol: '{name} ClassVar',
        memberIsNotReadOnlyInProtocol: '{name}',
        memberIsReadOnlyInProtocol: '{name}',
        memberIsWritableInProtocol: '{name}',
        memberSetClassVar: '{name} ClassVar',
        memberTypeMismatch: '"{name}"',
        memberUnknown: '{name}',
        metaclassConflict: '{metaclass1}{metaclass2}',
        missingDeleter: ' Property deleter ',
        missingGetter: ' Property getter ',
        missingSetter: ' Property setter ',
        namedParamMissingInDest: '{name}',
        namedParamMissingInSource: '{name}',
        namedParamTypeMismatch: '{sourceType}{name}{destType}',
        namedTupleNotAllowed: ' NamedTuple',
        newMethodLocation: '__new__{type}',
        newMethodSignature: '__new__{type}',
        newTypeClassNotAllowed: ' NewType ',
        noOverloadAssignable: '{type}',
        noneNotAllowed: ' None',
        orPatternMissingName: ': {name}',
        overloadIndex: ' {index} ',
        overloadNotAssignable: '{name}',
        overloadSignature: '',
        overriddenMethod: '',
        overriddenSymbol: '',
        overrideInvariantMismatch: '{overrideType}{baseType}',
        overrideIsInvariant: '',
        overrideNoOverloadMatches: '',
        overrideNotClassMethod: ' classmethod',
        overrideNotInstanceMethod: '',
        overrideNotStaticMethod: ' staticmethod',
        overrideOverloadNoMatch: '',
        overrideOverloadOrder: '',
        overrideParamKeywordNoDefault: '"{name}": ',
        overrideParamKeywordType: '{name}: {baseType}{overrideType}',
        overrideParamName: '{index}:  "{baseName}" "{overrideName}"',
        overrideParamNameExtra: '{name}',
        overrideParamNameMissing: '{name}',
        overrideParamNamePositionOnly: ' {index} : {baseName}',
        overrideParamNoDefault: ' {index} : ',
        overrideParamType: ' {index} : {baseType}{overrideType}',
        overridePositionalParamCount: ' {baseCount} {overrideCount}',
        overrideReturnType: ':"{baseType}""{overrideType}"',
        overrideType: '"{type}"',
        paramAssignment: ' {index}: {sourceType}{destType}',
        paramSpecMissingInOverride: ' ParamSpec ',
        paramType: '{paramType}',
        privateImportFromPyTypedSource: '"{module}"',
        propertyAccessFromProtocolClass: '',
        propertyMethodIncompatible: 'Property  "{name}" ',
        propertyMethodMissing: ' Property  "{name}"',
        propertyMissingDeleter: 'Property "{name}"  deleter',
        propertyMissingSetter: 'Property "{name}"  setter',
        protocolIncompatible: '{sourceType}{destType}',
        protocolMemberMissing: '{name}',
        protocolRequiresRuntimeCheckable: 'Protocol  @runtime_checkable ',
        protocolSourceIsNotConcrete: '{sourceType}{destType}',
        protocolUnsafeOverlap: '{name}',
        pyrightCommentIgnoreTip: ' "# pyright: ignore[<diagnostic rules>]" ',
        readOnlyAttribute: '{name}',
        seeClassDeclaration: '',
        seeDeclaration: '',
        seeFunctionDeclaration: '',
        seeMethodDeclaration: '',
        seeParameterDeclaration: '',
        seeTypeAliasDeclaration: '',
        seeVariableDeclaration: '',
        tupleAssignmentMismatch: ' "{type}"  tuple ',
        tupleEntryTypeMismatch: 'Tuple  {entry} ',
        tupleSizeIndeterminateSrc: 'Tuple ;  {expected}',
        tupleSizeIndeterminateSrcDest: 'Tuple ;  {expected} ',
        tupleSizeMismatch: 'Tuple ;  {expected} {received}',
        tupleSizeMismatchIndeterminateDest: 'Tuple ;  {expected}  {received}',
        typeAliasInstanceCheck: ' "type" ',
        typeAssignmentMismatch: '{sourceType}{destType}',
        typeBound: '{sourceType}{name}{destType}',
        typeConstrainedTypeVar: '{type}{name}',
        typeIncompatible: '{sourceType}{destType}',
        typeNotClass: '{type}',
        typeNotStringLiteral: '{type}',
        typeOfSymbol: '{name}{type}',
        typeParamSpec: '{type} ParamSpec{name}',
        typeUnsupported: '{type}',
        typeVarDefaultOutOfScope: '{name}',
        typeVarIsContravariant: ' "{name}"  "{sourceType}"  "{destType}" ',
        typeVarIsCovariant: ' "{name}"  "{sourceType}"  "{destType}" ',
        typeVarIsInvariant: ' "{name}"  "{sourceType}"  "{destType}" ',
        typeVarNotAllowed: ' TypeVar',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple  tuple',
        typeVarUnnecessarySuggestion: ' {type}',
        typeVarUnsolvableRemedy: '',
        typeVarsMissing: ': {names}',
        typedDictBaseClass: '{type} TypedDict',
        typedDictClassNotAllowed: ' TypedDict ',
        typedDictClosedExtraNotAllowed: '{name}',
        typedDictClosedExtraTypeMismatch: '{type}{name}',
        typedDictClosedFieldNotRequired: '{name} NotRequired',
        typedDictExtraFieldNotAllowed: '{type}{name}',
        typedDictExtraFieldTypeMismatch: '{name}{type} extra_items ',
        typedDictFieldMissing: '"{type}""{name}"',
        typedDictFieldNotReadOnly: '"{name}""{type}"',
        typedDictFieldNotRequired: '{type}{name}',
        typedDictFieldRequired: '"{type}""{name}"',
        typedDictFieldTypeMismatch: '{type}{name}',
        typedDictFieldUndefined: '{name}{type}',
        typedDictFinalMismatch: '"{sourceType}""{destType}"@final',
        typedDictKeyAccess: ' ["{name}"]  TypedDict ',
        typedDictNotAllowed: ' TypedDict',
        unhashableType: '{type}',
        uninitializedAbstractVariable: '{name}{classType}',
        unreachableExcept: '{exceptionType}{parentType}',
        useDictInstead: ' Dict[T1, T2] ',
        useListInstead: ' List[T]  list  Union[T1, T2]  union ',
        useTupleInstead: ' tuple[T1, ..., Tn]  tuple  Union[T1, T2]  union ',
        useTypeInstead: ' Type[T]',
        varianceMismatchForClass: '"{typeVarName}""{className}"',
        varianceMismatchForTypeAlias: '"{typeVarName}""{typeAliasParam}"'
      },
      Service: {
        longOperation: '[](https://aka.ms/workspace-too-many-files)'
      }
    };
  },
  95610: module => {
    module.exports = {
      CodeAction: {
        createTypeStub: ' Stub',
        createTypeStubFor: ' "{moduleName}"  Stub',
        executingCommand: '',
        filesToAnalyzeCount: ' {count} ',
        filesToAnalyzeOne: '1 ',
        findingReferences: '',
        organizeImports: '',
        renameShadowedFile: ' "{oldFile}"  "{newFile}"'
      },
      Completion: {
        autoImportDetail: '',
        indexValueDetail: ''
      },
      Diagnostic: {
        abstractMethodInvocation: ' "{method}"',
        annotatedMetadataInconsistent: ' "{metadataType}"  "{type}" ',
        annotatedParamCountMismatch: ':  {expected} {received}',
        annotatedTypeArgMissing: ' "Annotated" ',
        annotationBytesString: '',
        annotationFormatString: ' (f-strings)',
        annotationNotSupported: '',
        annotationRawString: '',
        annotationSpansStrings: '',
        annotationStringEscape: '',
        argAssignment: ' "{argType}"  "{paramType}" ',
        argAssignmentFunction: ' "{argType}"  "{functionName}"  "{paramType}" ',
        argAssignmentParam: ' "{argType}"  "{paramType}"  "{paramName}"',
        argAssignmentParamFunction: ' "{argType}"  "{functionName}"  "{paramType}"  "{paramName}"',
        argMissingForParam: ' {name} ',
        argMissingForParams: ' {names} ',
        argMorePositionalExpectedCount: ' {expected} ',
        argMorePositionalExpectedOne: ' 1 ',
        argPositional: '',
        argPositionalExpectedCount: ' {expected} ',
        argPositionalExpectedOne: ' 1 ',
        argTypePartiallyUnknown: '',
        argTypeUnknown: '',
        assertAlwaysTrue: 'Assert  true',
        assertTypeArgs: '"assert_type" ',
        assertTypeTypeMismatch: '"assert_type" :  "{expected}" "{received}"',
        assignmentExprComprehension: ' "{name}"  Comprehension ',
        assignmentExprContext: 'Assignment  Lambda ',
        assignmentExprInSubscript: ' Assignment  Python 3.10 ',
        assignmentInProtocol: ' Protocol ',
        assignmentTargetExpr: '',
        asyncNotInAsyncFunction: ' async  "async"',
        awaitIllegal: ' "await"  Python 3.5 ',
        awaitNotAllowed: ' "await"',
        awaitNotInAsync: ' async  "await"',
        backticksIllegal: 'Python 3.x ;  repr',
        baseClassCircular: '',
        baseClassFinal: ' "{type}"  final',
        baseClassIncompatible: '{type} ',
        baseClassInvalid: '',
        baseClassMethodTypeIncompatible: ' "{classType}"  "{name}"',
        baseClassUnknown: '',
        baseClassVariableTypeIncompatible: ' "{classType}"  "{name}"',
        binaryOperationNotAllowed: '',
        bindTypeMismatch: ' "{methodName}" "{type}"  "{paramName}"',
        breakInExceptionGroup: '"except*"  "break"',
        breakOutsideLoop: '"break" ',
        callableExtraArgs: ' "Callable" ',
        callableFirstArg: ' "..."',
        callableNotInstantiable: ' "{type}"',
        callableSecondArg: ' "Callable" ',
        casePatternIsIrrefutable: '',
        classAlreadySpecialized: ' "{type}" ',
        classDecoratorTypeUnknown: '; ',
        classDefinitionCycle: '"{name}" ',
        classGetItemClsParam: '__class_getitem__  "cls" ',
        classMethodClsParam: ' "cls" ',
        classNotRuntimeSubscriptable: ' "{name}" ; ',
        classPatternBuiltInArgPositional: '',
        classPatternPositionalArgCount: ' "{type}" ; {expected}  {received}',
        classPatternTypeAlias: ' "{type}"',
        classPropertyDeprecated: ' Python 3.11  Python 3.13 ',
        classTypeParametersIllegal: ' Python 3.12 ',
        classVarFirstArgMissing: '"ClassVar" ',
        classVarNotAllowed: ' "ClassVar"',
        classVarOverridesInstanceVar: ' "{name}"  "{className}" ',
        classVarTooManyArgs: '"ClassVar" ',
        classVarWithTypeVar: '"ClassVar" ',
        clsSelfParamTypeMismatch: ' "{name}"  "{classType}" ',
        codeTooComplexToAnalyze: '; ',
        collectionAliasInstantiation: ' "{type}"  "{alias}"',
        comparisonAlwaysFalse: ' False "{leftType}"  "{rightType}" ',
        comparisonAlwaysTrue: ' True "{leftType}"  "{rightType}" ',
        comprehensionInDict: 'Comprehension ',
        comprehensionInSet: 'Comprehension  set ',
        concatenateContext: ' "Concatenate"',
        concatenateParamSpecMissing: '"Concatenate"  ParamSpec  "..."',
        concatenateTypeArgsMissing: '"Concatenate" ',
        conditionalOperandInvalid: ' "{type}" ',
        constantRedefinition: '"{name}"  () ',
        constructorParametersMismatch: ' "{classType}" __new____init__',
        containmentAlwaysFalse: ' False "{leftType}"  "{rightType}" ',
        containmentAlwaysTrue: ' True "{leftType}"  "{rightType}" ',
        continueInExceptionGroup: '"except*"  "continue"',
        continueOutsideLoop: '"continue"  loop ',
        coroutineInConditionalExpression: ' True',
        dataClassBaseClassFrozen: '',
        dataClassBaseClassNotFrozen: '',
        dataClassConverterFunction: ' "{argType}"  "{fieldType}"  "{fieldName}" ',
        dataClassConverterOverloads: '"{funcName}"  "{fieldType}"  "{fieldName}" ',
        dataClassFieldInheritedDefault: '"{fieldName}" ',
        dataClassFieldWithDefault: '',
        dataClassFieldWithPrivateName: 'Dataclass ',
        dataClassFieldWithoutAnnotation: ' Dataclass ',
        dataClassPostInitParamCount: 'Dataclass __post_init__ ; InitVar  {expected}',
        dataClassPostInitType: ' "{fieldName}"  Dataclass __post_init__ ',
        dataClassSlotsOverwrite: '__slots__',
        dataClassTransformExpectedBoolLiteral: ' True  False ',
        dataClassTransformFieldSpecifier: ' tuple "{type}"',
        dataClassTransformPositionalParam: '"dataclass_transform" ',
        dataClassTransformUnknownArgument: 'dataclass_transform  "{name}"',
        dataProtocolInSubclassCheck: 'issubclass  ()',
        declaredReturnTypePartiallyUnknown: ' "{returnType}" ',
        declaredReturnTypeUnknown: '',
        defaultValueContainsCall: '',
        defaultValueNotAllowed: ' "*"  "**" ',
        delTargetExpr: '',
        deprecatedClass: ' "{name}" ',
        deprecatedConstructor: ' "{name}" ',
        deprecatedDescriptorDeleter: ' "{name}"  "__delete__" ',
        deprecatedDescriptorGetter: ' "{name}"  "__get__" ',
        deprecatedDescriptorSetter: ' "{name}"  "__set__" ',
        deprecatedFunction: ' "{name}" ',
        deprecatedMethod: ' "{className}"  "{name}" ',
        deprecatedPropertyDeleter: 'The deleter for property "{name}" is deprecated',
        deprecatedPropertyGetter: 'The getter for property "{name}" is deprecated',
        deprecatedPropertySetter: 'The setter for property "{name}" is deprecated',
        deprecatedType: ' Python {version} ;  "{replacement}"',
        dictExpandIllegalInComprehension: 'Comprehension ',
        dictInAnnotation: '',
        dictKeyValuePairs: '/',
        dictUnpackIsNotMapping: '',
        dunderAllSymbolNotPresent: '"{name}"  __all__ ',
        duplicateArgsParam: ' "*" ',
        duplicateBaseClass: '',
        duplicateCapturePatternTarget: ' "{name}" ',
        duplicateCatchAll: ' catch-all except ',
        duplicateEnumMember: ' Enum  "{name}"',
        duplicateGenericAndProtocolBase: ' Generic[...]  Protocol[...] ',
        duplicateImport: '"{importName}" ',
        duplicateKeywordOnly: ' "*" ',
        duplicateKwargsParam: ' "**" ',
        duplicateParam: ' "{name}"',
        duplicatePositionOnly: ' "/" ',
        duplicateStarPattern: ' "*" ',
        duplicateStarStarPattern: ' "**"',
        duplicateUnpack: 'list ',
        ellipsisAfterUnpacked: '"..."  TypeVarTuple  tuple ',
        ellipsisContext: ' "..."',
        ellipsisSecondArg: '"..." ',
        enumClassOverride: 'Enum  "{name}"  final',
        enumMemberDelete: 'Enum member "{name}" cannot be deleted',
        enumMemberSet: 'Enum member "{name}" cannot be assigned',
        enumMemberTypeAnnotation: 'Type annotations are not allowed for enum members',
        exceptGroupMismatch: 'Try  "except"  except*',
        exceptGroupRequiresType: ' ("except*") ',
        exceptionGroupIncompatible: ' ("except*")  Python 3.11 ',
        exceptionGroupTypeIncorrect: 'except*  BaseGroupException',
        exceptionTypeIncorrect: '"{type}"  BaseException',
        exceptionTypeNotClass: '"{type}" ',
        exceptionTypeNotInstantiable: ' "{type}" ',
        expectedAfterDecorator: '',
        expectedArrow: ' "->"',
        expectedAsAfterException: ' "as"',
        expectedAssignRightHandExpr: '"=" ',
        expectedBinaryRightHandExpr: '',
        expectedBoolLiteral: ' True  False',
        expectedCase: ' "case" ',
        expectedClassName: '',
        expectedCloseBrace: '"{" ',
        expectedCloseBracket: '"[" ',
        expectedCloseParen: '"(" ',
        expectedColon: ' ":"',
        expectedComplexNumberLiteral: '',
        expectedDecoratorExpr: 'Python 3.9 ',
        expectedDecoratorName: '',
        expectedDecoratorNewline: '',
        expectedDelExpr: '"del" ',
        expectedElse: ' "else"',
        expectedEquals: ' "="',
        expectedExceptionClass: '',
        expectedExceptionObj: ' None',
        expectedExpr: '',
        expectedFunctionAfterAsync: '"async" ',
        expectedFunctionName: '"def" ',
        expectedIdentifier: '',
        expectedImport: ' "import"',
        expectedImportAlias: '"as" ',
        expectedImportSymbols: ' "import" ',
        expectedIn: ' "in"',
        expectedInExpr: '"in" ',
        expectedIndentedBlock: '',
        expectedMemberName: '"." ',
        expectedModuleName: '',
        expectedNameAfterAs: '"as" ',
        expectedNamedParameter: ' "*"',
        expectedNewline: '',
        expectedNewlineOrSemicolon: '',
        expectedOpenParen: ' "("',
        expectedParamName: '',
        expectedPatternExpr: '',
        expectedPatternSubjectExpr: '',
        expectedPatternValue: ' "a.b" ',
        expectedReturnExpr: '"return" ',
        expectedSliceIndex: '',
        expectedTypeNotString: '',
        expectedTypeParameterName: '',
        expectedYieldExpr: 'yield ',
        finalClassIsAbstract: ' "{type}"  final',
        finalContext: ' "Final"',
        finalInLoop: ' "Final" ',
        finalMethodOverride: ' "{name}"  "{className}"  final ',
        finalNonMethod: ' "{name}"  @final',
        finalReassigned: '"{name}"  Final',
        finalRedeclaration: '"{name}"  Final',
        finalRedeclarationBySubclass: ' "{name}" "{className}"  Final',
        finalTooManyArgs: ' "Final" ',
        finalUnassigned: '"{name}"  Final',
        formatStringBrace: 'F ; ',
        formatStringBytes: ' (f-strings) ',
        formatStringDebuggingIllegal: 'F  "="  Python 3.8 ',
        formatStringEscape: 'Python 3.12  f  ()',
        formatStringExpectedConversion: ' f-string  "!" ',
        formatStringIllegal: ' (f-strings)  Python 3.6 ',
        formatStringInPattern: '',
        formatStringNestedFormatSpecifier: '',
        formatStringNestedQuote: 'f  Python 3.12  f ',
        formatStringUnicode: ' (f-strings)  Unicode',
        formatStringUnterminated: 'f ;  "}"',
        functionDecoratorTypeUnknown: '; ',
        functionInConditionalExpression: ' True',
        functionTypeParametersIllegal: ' Python 3.12 ',
        futureImportLocationNotAllowed: ' __future__ ',
        generatorAsyncReturnType: 'Return type of async generator function must be compatible with "AsyncGenerator[{yieldType}, Any]"',
        generatorNotParenthesized: '',
        generatorSyncReturnType: ' "Generator[{yieldType}, Any, Any]" ',
        genericBaseClassNotAllowed: '"Generic" ',
        genericClassAssigned: '',
        genericClassDeleted: '',
        genericInstanceVariableAccess: '',
        genericNotAllowed: '"Generic" ',
        genericTypeAliasBoundTypeVar: ' {names}',
        genericTypeArgMissing: '"Generic" ',
        genericTypeArgTypeVar: '"Generic" ',
        genericTypeArgUnique: '"Generic" ',
        globalReassignment: '"{name}"  global ',
        globalRedefinition: '"{name}"  global',
        implicitStringConcat: '',
        importCycleDetected: '',
        importDepthExceeded: ' {depth}',
        importResolveFailure: ' "{importName}"',
        importSourceResolveFailure: ' "{importName}"',
        importSymbolUnknown: '"{name}" ',
        incompatibleMethodOverride: ' "{name}"  "{className}"',
        inconsistentIndent: '',
        inconsistentTabs: ' Tab ',
        initMethodSelfParamTypeVar: '"__init__"  "self" ',
        initMustReturnNone: '"__init__"  None',
        initSubclassCallFailed: '__init_subclass__ ',
        initSubclassClsParam: '__init_subclass__  "cls" ',
        initVarNotAllowed: ' "InitVar"',
        instanceMethodSelfParam: ' "self" ',
        instanceVarOverridesClassVar: ' "{name}"  "{className}" ',
        instantiateAbstract: ' "{type}" ',
        instantiateProtocol: ' Protocol  "{type}" ',
        internalBindError: ' "{file}" : {message}',
        internalParseError: ' "{file}" : {message}',
        internalTypeCheckingError: ' "{file}" : {message}',
        invalidIdentifierChar: '',
        invalidStubStatement: ' stub ',
        invalidTokenChars: ' "{text}" ',
        isInstanceInvalidType: '"isinstance" tuple',
        isSubclassInvalidType: '"issubclass"  tuple',
        keyValueInSet: 'set /',
        keywordArgInTypeArgument: '',
        keywordArgShortcutIllegal: ' Python 3.14 ',
        keywordOnlyAfterArgs: '"*" ',
        keywordParameterMissing: ' "*" ',
        keywordSubscriptIllegal: '',
        lambdaReturnTypePartiallyUnknown: 'Lambda  "{returnType}" ',
        lambdaReturnTypeUnknown: 'Lambda ',
        listAssignmentMismatch: ' "{type}" ',
        listInAnnotation: ' List ',
        literalEmptyArgs: '"Literal" ',
        literalNamedUnicodeEscape: '"Literal"  Unicode ',
        literalNotAllowed: '"Literal" ',
        literalNotCallable: 'Literal ',
        literalUnsupportedType: '"Literal"  Noneliteral (intboolstr  bytes)  enum ',
        matchIncompatible: 'Match  Python 3.10 ',
        matchIsNotExhaustive: 'match ',
        maxParseDepthExceeded: '; ',
        memberAccess: ' "{type}"  "{name}"',
        memberDelete: ' "{type}"  "{name}"',
        memberSet: ' "{type}"  "{name}"',
        metaclassConflict: '',
        metaclassDuplicate: '',
        metaclassIsGeneric: '',
        methodNotDefined: '"{name}" ',
        methodNotDefinedOnType: ' "{type}"  "{name}" ',
        methodOrdering: '',
        methodOverridden: '"{name}"  "{type}"  "{className}" ',
        methodReturnsNonObject: '"{name}" ',
        missingSuperCall: ' "{methodName}" ',
        mixingBytesAndStr: ' Bytes  str ',
        moduleAsType: '',
        moduleNotCallable: '',
        moduleUnknownMember: '"{memberName}"  "{moduleName}" ',
        namedExceptAfterCatchAll: 'catch-all except  except ',
        namedParamAfterParamSpecArgs: ' "{name}"  ParamSpec args ',
        namedTupleEmptyName: ' tuple ',
        namedTupleEntryRedeclared: ' "{name}" "{className}"  tuple',
        namedTupleFirstArg: ' tuple ',
        namedTupleMultipleInheritance: ' NamedTuple ',
        namedTupleNameKeyword: '',
        namedTupleNameType: ' tuple',
        namedTupleNameUnique: ' tuple ',
        namedTupleNoTypes: '"namedtuple"  Tuple ;  "NamedTuple"',
        namedTupleSecondArg: ' tuple  list ',
        newClsParam: '__new__  "cls" ',
        newTypeAnyOrUnknown: 'NewType  Any  Unknown',
        newTypeBadName: 'NewType ',
        newTypeLiteral: 'NewType  Literal ',
        newTypeNameMismatch: 'NewType ',
        newTypeNotAClass: ' NewType ',
        newTypeParamCount: 'NewType ',
        newTypeProtocolClass: 'NewType  (Protocol  TypedDict ) ',
        noOverload: '"{name}" ',
        noReturnContainsReturn: ' return  "NoReturn"  return ',
        noReturnContainsYield: ' "NoReturn"  yield ',
        noReturnReturnsNone: ' "NoReturn"  "None"',
        nonDefaultAfterDefault: '',
        nonLocalInModule: ' nonlocal ',
        nonLocalNoBinding: ' nonlocal "{name}" ',
        nonLocalReassignment: '"{name}"  nonlocal ',
        nonLocalRedefinition: '"{name}"  nonlocal',
        noneNotCallable: ' "None" ',
        noneNotIterable: ' "None" ',
        noneNotSubscriptable: ' "None" ',
        noneNotUsableWith: 'Object of type "None" cannot be used with "with"',
        noneOperator: '"None"  "{operator}"',
        noneUnknownMember: '"{name}"  "None" ',
        notRequiredArgCount: ' "NotRequired" ',
        notRequiredNotInTypedDict: ' "NotRequired"',
        objectNotCallable: ' "{type}" ',
        obscuredClassDeclaration: ' "{name}" ',
        obscuredFunctionDeclaration: ' "{name}" ',
        obscuredMethodDeclaration: ' "{name}" ',
        obscuredParameterDeclaration: ' "{name}" ',
        obscuredTypeAliasDeclaration: ' "{name}" ',
        obscuredVariableDeclaration: ' "{name}" ',
        operatorLessOrGreaterDeprecated: 'Python 3  "<>";  "!="',
        optionalExtraArgs: '"Optional" ',
        orPatternIrrefutable: ' "or" ',
        orPatternMissingName: '"or" ',
        overlappingKeywordArgs: ':: {names}',
        overlappingOverload: '"{name}"  {obscured}  {obscuredBy} ',
        overloadAbstractImplMismatch: '',
        overloadAbstractMismatch: '',
        overloadClassMethodInconsistent: '"{name}"  @classmethod',
        overloadFinalInconsistencyImpl: '"{name}"  @final ',
        overloadFinalInconsistencyNoImpl: '"{name}"  {index}  @final  1 ',
        overloadImplementationMismatch: ' {index} ',
        overloadReturnTypeMismatch: '"{name}"  {prevIndex}  {newIndex} ',
        overloadStaticMethodInconsistent: '"{name}"  @staticmethod',
        overloadWithoutImplementation: '"{name}"  overload',
        overriddenMethodNotFound: ' "{name}"  override',
        overrideDecoratorMissing: ' "{name}"  override "{className}" ',
        paramAfterKwargsParam: ' "**" ',
        paramAlreadyAssigned: ' "{name}"',
        paramAnnotationMissing: ' "{name}" ',
        paramAssignmentMismatch: ' "{sourceType}"  "{paramType}" ',
        paramNameMissing: ' "{name}" ',
        paramSpecArgsKwargsDuplicate: 'ParamSpec "{type}" ',
        paramSpecArgsKwargsUsage: 'ParamSpec  "args"  "kwargs" ',
        paramSpecArgsMissing: 'ParamSpec "{type}" ',
        paramSpecArgsUsage: ' *args ParamSpec  "args" ',
        paramSpecAssignedName: 'ParamSpec  "{name}" ',
        paramSpecContext: ' ParamSpec',
        paramSpecDefaultNotTuple: 'ParamSpec tuple  ParamSpec',
        paramSpecFirstArg: ' ParamSpec ',
        paramSpecKwargsUsage: ' **kwargs ParamSpec  "kwargs" ',
        paramSpecNotUsedByOuterScope: 'ParamSpec "{name}" ',
        paramSpecUnknownArg: 'ParamSpec ',
        paramSpecUnknownMember: '"{name}"  ParamSpec ',
        paramSpecUnknownParam: '"{name}"  ParamSpec ',
        paramTypeCovariant: '',
        paramTypePartiallyUnknown: ' "{paramName}" ',
        paramTypeUnknown: ' "{paramName}" ',
        parenthesizedContextManagerIllegal: 'Parentheses within "with" statement requires Python 3.9 or newer',
        patternNeverMatches: ' "{type}"',
        positionArgAfterNamedArg: '',
        positionOnlyAfterArgs: '"*"  Position-only ',
        positionOnlyAfterKeywordOnly: '"/"  "*" ',
        positionOnlyAfterNon: ' Position-only  Position-only ',
        positionOnlyFirstParam: ' Position-only ',
        positionOnlyIncompatible: 'Position-only  Python 3.8 ',
        privateImportFromPyTypedModule: '"{name}"  "{module}" ',
        privateUsedOutsideOfClass: '"{name}" ',
        privateUsedOutsideOfModule: '"{name}" ',
        propertyOverridden: '"{name}"  "{className}"  property',
        propertyStaticMethod: 'Static methods not allowed for property getter, setter or deleter',
        protectedUsedOutsideOfClass: '"{name}" ',
        protocolBaseClass: 'Protocol  "{classType}"  Protocol  "{baseType}"',
        protocolBaseClassWithTypeArgs: 'Protocol ',
        protocolIllegal: ' "Protocol"  Python 3.7 ',
        protocolNotAllowed: '"Protocol" ',
        protocolTypeArgMustBeTypeParam: 'Protocol ',
        protocolUnsafeOverlap: ' "{name}"',
        protocolVarianceContravariant: ' Protocol "{class}"  "{variable}" ',
        protocolVarianceCovariant: ' Protocol "{class}"  "{variable}" ',
        protocolVarianceInvariant: ' Protocol "{class}"  "{variable}" ',
        pyrightCommentInvalidDiagnosticBoolValue: 'Pyright  "=" true  false',
        pyrightCommentInvalidDiagnosticSeverityValue: 'Pyright  "=" truefalseerrorwarninginformation  none',
        pyrightCommentMissingDirective: 'Pyright  (basic  strict) ',
        pyrightCommentNotOnOwnLine: ' Pyright ',
        pyrightCommentUnknownDiagnosticRule: '"{rule}"  pyright ',
        pyrightCommentUnknownDiagnosticSeverityValue: '"{value}"  pyright ;  truefalseerrorwarninginformation  none',
        pyrightCommentUnknownDirective: '"{directive}"  pyright ;  "strict"  "basic"',
        readOnlyArgCount: '"ReadOnly" ',
        readOnlyNotInTypedDict: ' "ReadOnly"',
        recursiveDefinition: ' "{name}" ',
        relativeImportNotAllowed: ' "import .a" ;  "from . import a"',
        requiredArgCount: '"Required" ',
        requiredNotInTypedDict: ' "Required"',
        returnInAsyncGenerator: 'Return statement with value is not allowed in async generator',
        returnInExceptionGroup: '"except*"  "return"',
        returnMissing: ' "{returnType}" ',
        returnOutsideFunction: '"return" ',
        returnTypeContravariant: '',
        returnTypeMismatch: ' "{exprType}"  "{returnType}"',
        returnTypePartiallyUnknown: ' "{returnType}" ',
        returnTypeUnknown: '',
        revealLocalsArgs: '"reveal_locals" ',
        revealLocalsNone: ' locals',
        revealTypeArgs: '"reveal_type" ',
        revealTypeExpectedTextArg: ' "reveal_type"  "expected_text"  str ',
        revealTypeExpectedTextMismatch: ';  "{expected}" "{received}"',
        revealTypeExpectedTypeMismatch: ';  "{expected}" "{received}"',
        selfTypeContext: '"Self" ',
        selfTypeMetaclass: 'Self  Metaclass  (type )',
        selfTypeWithTypedSelfOrCls: '"Self"  `self`  `cls`  "Self"',
        setterGetterTypeMismatch: 'Property setter  getter ',
        singleOverload: '"{name}" ',
        slotsAttributeError: '__slots__ "{name}"',
        slotsClassVarConflict: '"{name}"  __slots__ ',
        starPatternInAsPattern: ' "as" ',
        starPatternInOrPattern: ' OR',
        starStarWildcardNotAllowed: '**  "_" ',
        staticClsSelfParam: ' "self"  "cls" ',
        stdlibModuleOverridden: '"{path}"  stdlib  "{name}"',
        stringNonAsciiBytes: ' ASCII ',
        stringNotSubscriptable: '; ',
        stringUnsupportedEscape: '',
        stringUnterminated: '',
        stubFileMissing: ' "{importName}"  stub ',
        stubUsesGetAttr: ' stub ; "__getattr__" ',
        sublistParamsIncompatible: 'Python 3.x  sublist ',
        superCallArgCount: '"super" ',
        superCallFirstArg: ' "super"  "{type}"',
        superCallSecondArg: '"super"  "{type}" ',
        superCallZeroArgForm: '"super" ',
        superCallZeroArgFormStaticMethod: '"super" ',
        symbolIsPossiblyUnbound: '"{name}" ',
        symbolIsUnbound: '"{name}" ',
        symbolIsUndefined: '"{name}" ',
        symbolOverridden: '"{name}"  "{className}" ',
        ternaryNotAllowed: '',
        totalOrderingMissingMethod: ' "__lt__""__le__""__gt__"  "__ge__"  total_ordering',
        trailingCommaInFromImport: '',
        tryWithoutExcept: 'Try  except  finally ',
        tupleAssignmentMismatch: ' "{type}"  tuple',
        tupleInAnnotation: ' Tuple ',
        tupleIndexOutOfRange: ' {index}  {type} ',
        typeAliasIllegalExpressionForm: '',
        typeAliasIsRecursiveDirect: ' "{name}" ',
        typeAliasNotInModuleOrClass: 'TypeAlias ',
        typeAliasRedeclared: '"{name}"  TypeAlias',
        typeAliasStatementBadScope: 'A type statement can be used only within a module or class scope',
        typeAliasStatementIllegal: ' Python 3.12 ',
        typeAliasTypeBaseClass: '"type" ',
        typeAliasTypeMustBeAssigned: 'TypeAliasType ',
        typeAliasTypeNameArg: 'TypeAliasType ',
        typeAliasTypeNameMismatch: '',
        typeAliasTypeParamInvalid: ' TypeVarTypeVarTuple  ParamSpec  tuple',
        typeAnnotationCall: '',
        typeAnnotationVariable: '',
        typeAnnotationWithCallable: '"type" ; ',
        typeArgListExpected: ' ParamSpec list',
        typeArgListNotAllowed: ' list ',
        typeArgsExpectingNone: ' "{name}" ',
        typeArgsMismatchOne: ' {received}',
        typeArgsMissingForAlias: ' "{name}" ',
        typeArgsMissingForClass: ' "{name}" ',
        typeArgsTooFew: ' "{name}" ;  {expected}  {received}',
        typeArgsTooMany: ' "{name}" ;  {expected}  {received}',
        typeAssignmentMismatch: ' "{sourceType}"  "{destType}"',
        typeAssignmentMismatchWildcard: ' "{name}"  "{sourceType}" "{destType}"',
        typeCallNotAllowed: ' type() ',
        typeCheckOnly: '"{name}"  @type_check_only',
        typeCommentDeprecated: ' type ;  type ',
        typeExpectedClass: ' "{type}"',
        typeFormArgs: '"TypeForm" ',
        typeGuardArgCount: ' "TypeGuard"  "TypeIs" ',
        typeGuardParamCount: '',
        typeIsReturnType: 'TypeIs  ("{returnType}")  ("{type}") ',
        typeNotAwaitable: '"{type}"  awaitable',
        typeNotIntantiable: '"{type}" ',
        typeNotIterable: '"{type}" ',
        typeNotSpecializable: ' "{type}" ',
        typeNotSubscriptable: ' "{type}" ',
        typeNotSupportBinaryOperator: ' "{leftType}"  "{rightType}"  "{operator}"',
        typeNotSupportBinaryOperatorBidirectional: ' "{expectedType}"  "{leftType}"  "{rightType}"  "{operator}"',
        typeNotSupportUnaryOperator: ' "{type}"  "{operator}"',
        typeNotSupportUnaryOperatorBidirectional: ' "{expectedType}"  "{type}"  "{operator}"',
        typeNotUsableWith: ' "{type}"  "with"  {method}',
        typeParameterBoundNotAllowed: ' variadic  ParamSpec ',
        typeParameterConstraintTuple: ' Tuple',
        typeParameterExistingTypeParameter: ' "{name}" ',
        typeParameterNotDeclared: ' "{name}"  "{container}" ',
        typeParametersMissing: '',
        typePartiallyUnknown: '"{name}" ',
        typeUnknown: '"{name}" ',
        typeVarAssignedName: 'TypeVar  "{name}" ',
        typeVarAssignmentMismatch: ' "{type}"  "{name}"',
        typeVarBoundAndConstrained: 'TypeVar ',
        typeVarBoundGeneric: 'TypeVar ',
        typeVarConstraintGeneric: 'TypeVar ',
        typeVarDefaultBoundMismatch: 'TypeVar ',
        typeVarDefaultConstraintMismatch: 'TypeVar ',
        typeVarDefaultIllegal: ' Python 3.13 ',
        typeVarDefaultInvalidTypeVar: ' "{name}" ',
        typeVarFirstArg: ' TypeVar ',
        typeVarInvalidForMemberVariable: ' local  "{name}"',
        typeVarNoMember: 'TypeVar "{type}"  "{name}"',
        typeVarNotSubscriptable: 'TypeVar "{type}" ',
        typeVarNotUsedByOuterScope: ' "{name}" ',
        typeVarPossiblyUnsolvable: ' "{param}"  "{name}" ',
        typeVarSingleConstraint: 'TypeVar ',
        typeVarTupleConstraints: 'TypeVarTuple ',
        typeVarTupleContext: ' TypeVarTuple',
        typeVarTupleDefaultNotUnpacked: 'TypeVarTuple  tuple  TypeVarTuple',
        typeVarTupleMustBeUnpacked: 'TypeVarTuple ',
        typeVarTupleUnknownParam: '"{name}"  TypeVarTuple ',
        typeVarUnknownParam: '"{name}"  TypeVar ',
        typeVarUsedByOuterScope: ' TypeVar "{name}"',
        typeVarUsedOnlyOnce: 'TypeVar "{name}" ',
        typeVarVariance: 'TypeVar ',
        typeVarWithDefaultFollowsVariadic: 'TypeVar "{typeVarName}"  TypeVarTuple "{variadicName}"',
        typeVarWithoutDefault: '"{name}"  "{other}" ',
        typeVarsNotInGenericOrProtocol: 'Generic[]  Protocol[] ',
        typedDictAccess: ' TypedDict ',
        typedDictAssignedName: 'TypedDict  "{name}" ',
        typedDictBadVar: 'TypedDict ',
        typedDictBaseClass: 'TypedDict  TypedDict ',
        typedDictBoolParam: ' "{name}"  True  False',
        typedDictClosedExtras: ' "{name}"  closed  TypedDict;  "{type}"',
        typedDictClosedNoExtras: ' "{name}"  closed  TypedDict; ',
        typedDictDelete: ' TypedDict ',
        typedDictEmptyName: 'TypedDict ',
        typedDictEntryName: '',
        typedDictEntryUnique: '',
        typedDictExtraArgs: ' TypedDict ',
        typedDictExtraItemsClosed: ' TypedDict  closed',
        typedDictFieldNotRequiredRedefinition: 'TypedDict  "{name}"  NotRequired',
        typedDictFieldReadOnlyRedefinition: 'TypedDict  "{name}"  ReadOnly',
        typedDictFieldRequiredRedefinition: 'TypedDict  "{name}"  Required',
        typedDictFirstArg: ' TypedDict ',
        typedDictInClassPattern: ' TypedDict ',
        typedDictInitsubclassParameter: 'TypedDict __init_subclass__ "{name}"',
        typedDictNotAllowed: '"TypedDict" ',
        typedDictSecondArgDict: ' dict ',
        typedDictSecondArgDictEntry: '',
        typedDictSet: ' TypedDict ',
        unaccessedClass: ' "{name}"',
        unaccessedFunction: ' "{name}"',
        unaccessedImport: ' "{name}"',
        unaccessedSymbol: ' "{name}"',
        unaccessedVariable: ' "{name}"',
        unannotatedFunctionSkipped: ' "{name}"',
        unaryOperationNotAllowed: '',
        unexpectedAsyncToken: ' "def""with"  "for"  "async"',
        unexpectedExprToken: '',
        unexpectedIndent: '',
        unexpectedUnindent: '',
        unhashableDictKey: '',
        unhashableSetEntry: 'Set ',
        uninitializedAbstractVariables: ' final  "{classType}" ',
        uninitializedInstanceVariable: ' "{name}"  __init__ ',
        unionForwardReferenceNotAllowed: 'Union ; ',
        unionSyntaxIllegal: ' Python 3.10 ',
        unionTypeArgCount: 'Union ',
        unionUnpackedTuple: 'Union  tuple',
        unionUnpackedTypeVarTuple: 'Union  TypeVarTuple',
        unnecessaryCast: ' "cast" ;  "{type}"',
        unnecessaryIsInstanceAlways: ' isinstance ; "{testType}"  "{classType}" ',
        unnecessaryIsInstanceNever: ' isinstance ; "{testType}"  "{classType}" ',
        unnecessaryIsSubclassAlways: ' issubclass ; "{testType}" "{classType}" ',
        unnecessaryIsSubclassNever: ' issubclass ; "{testType}" "{classType}" ',
        unnecessaryPyrightIgnore: ' "# pyright: ignore" ',
        unnecessaryPyrightIgnoreRule: ' "# pyright: ignore" : "{name}"',
        unnecessaryTypeIgnore: ' "# type: ignore" ',
        unpackArgCount: '"Unpack" ',
        unpackExpectedTypeVarTuple: ' TypeVarTuple  tuple  Unpack ',
        unpackExpectedTypedDict: ' Unpack  TypedDict ',
        unpackIllegalInComprehension: 'Comprehension ',
        unpackInAnnotation: '',
        unpackInDict: '',
        unpackInSet: 'Unpack operator not allowed within a set',
        unpackNotAllowed: ' Unpack',
        unpackOperatorNotAllowed: '',
        unpackTuplesIllegal: 'Python 3.8  Tuple ',
        unpackedArgInTypeArgument: '',
        unpackedArgWithVariadicParam: ' TypeVarTuple ',
        unpackedDictArgumentNotMapping: '**  "str" ',
        unpackedDictSubscriptIllegal: '',
        unpackedSubscriptIllegal: ' Python 3.11 ',
        unpackedTypeVarTupleExpected: ' TypeVarTuple;  Unpack[{name1}]  *{name2}',
        unpackedTypedDictArgument: ' TypedDict ',
        unreachableCode: '',
        unreachableCodeType: '',
        unreachableExcept: ' Except ',
        unsupportedDunderAllOperation: ' "__all__" ',
        unusedCallResult: ' "{type}" ;  "_"',
        unusedCoroutine: ' async ;  "await" ',
        unusedExpression: '',
        varAnnotationIllegal: ' type  Python 3.6 ; ',
        variableFinalOverride: ' "{name}"  Final "{className}"  Final ',
        variadicTypeArgsTooMany: ' TypeVarTuple  tuple',
        variadicTypeParamTooManyAlias: ' TypeVarTuple  ({names})',
        variadicTypeParamTooManyClass: ' TypeVarTuple  ({names})',
        walrusIllegal: ' ":="  Python 3.8 ',
        walrusNotAllowed: ' ":="',
        wildcardInFunction: ' import',
        wildcardLibraryImport: ' import ',
        wildcardPatternTypePartiallyUnknown: '',
        wildcardPatternTypeUnknown: '',
        yieldFromIllegal: ' "yield from"  Python 3.3 ',
        yieldFromOutsideAsync: '"yield from" not allowed in an async function',
        yieldOutsideFunction: ' lambda  "yield"',
        yieldWithinComprehension: 'Comprehension  "yield"',
        zeroCaseStatementsFound: 'Match  case ',
        zeroLengthTupleNotAllowed: ' tuple'
      },
      DiagnosticAddendum: {
        annotatedNotAllowed: '[Annotated] ',
        argParam: ' "{paramName}"',
        argParamFunction: ' "{functionName}"  "{paramName}"',
        argsParamMissing: ' "*{paramName}" ',
        argsPositionOnly: ';  {expected} {received}',
        argumentType: ' "{type}"',
        argumentTypes: ': ({types})',
        assignToNone: 'None',
        asyncHelp: ' "async with" ?',
        baseClassIncompatible: ' "{baseClass}"  "{type}" ',
        baseClassIncompatibleSubclass: ' "{baseClass}"  "{type}"  "{subclass}"',
        baseClassOverriddenType: ' "{baseClass}"  "{type}"',
        baseClassOverridesType: ' "{baseClass}"  "{type}" ',
        bytesTypePromotions: ' disableBytesTypePromotions  falsebytearraymemoryview',
        conditionalRequiresBool: ' "{operandType}"  __bool__  "{boolReturnType}"  "bool"',
        dataClassFieldLocation: '',
        dataClassFrozen: '"{name}" ',
        dataProtocolUnsupported: '"{name}" ',
        descriptorAccessBindingFailed: ' "{className}"  "{name}"',
        descriptorAccessCallFailed: ' "{className}"  "{name}"',
        finalMethod: 'Final ',
        functionParamDefaultMissing: ' "{name}" ',
        functionParamName: ': "{destName}"  "{srcName}"',
        functionParamPositionOnly: ' "{name}" ',
        functionReturnTypeMismatch: ' "{sourceType}"  "{destType}" ',
        functionTooFewParams: ';  {expected} {received}',
        functionTooManyParams: ';  {expected} {received}',
        genericClassNotAllowed: '',
        incompatibleDeleter: 'Property deleter ',
        incompatibleGetter: 'Property getter ',
        incompatibleSetter: 'Property setter ',
        initMethodLocation: '__init__  "{type}" ',
        initMethodSignature: '__init__  "{type}"',
        initSubclassLocation: '__init_subclass__  "{name}" ',
        invariantSuggestionDict: 'dictMapping',
        invariantSuggestionList: 'listSequence',
        invariantSuggestionSet: ' set Container',
        isinstanceClassNotSupported: ' "{type}"',
        keyNotRequired: '"{name}"  "{type}" ',
        keyReadOnly: '"{name}"  "{type}" ',
        keyRequiredDeleted: '"{name}" ',
        keyUndefined: '"{name}"  "{type}" ',
        kwargsParamMissing: ' "**{paramName}" ',
        listAssignmentMismatch: ' "{type}" ',
        literalAssignmentMismatch: '"{sourceType}"  "{destType}"',
        matchIsNotExhaustiveHint: ' "case _: pass"',
        matchIsNotExhaustiveType: ': "{type}"',
        memberAssignment: ' "{type}"  "{classType}"  "{name}"',
        memberIsAbstract: '"{type}.{name}" ',
        memberIsAbstractMore: ' {count} ...',
        memberIsClassVarInProtocol: '"{name}"  ClassVar',
        memberIsInitVar: '"{name}"  init-only ',
        memberIsInvariant: '"{name}" ',
        memberIsNotClassVarInClass: '"{name}"  ClassVar',
        memberIsNotClassVarInProtocol: '"{name}"  ClassVar',
        memberIsNotReadOnlyInProtocol: ' {name} ',
        memberIsReadOnlyInProtocol: ' {name} ',
        memberIsWritableInProtocol: '"{name}" ',
        memberSetClassVar: ' "{name}" ClassVar',
        memberTypeMismatch: '"{name}" ',
        memberUnknown: ' "{name}" ',
        metaclassConflict: 'Metaclass{metaclass1}{metaclass2}',
        missingDeleter: 'Property deleter ',
        missingGetter: 'Property getter ',
        missingSetter: ' property setter ',
        namedParamMissingInDest: ' "{name}"',
        namedParamMissingInSource: ' "{name}"',
        namedParamTypeMismatch: ' "{sourceType}"  "{name}"  "{destType}" ',
        namedTupleNotAllowed: ' NamedTuple',
        newMethodLocation: '__new__  "{type}" ',
        newMethodSignature: '__new__  "{type}"',
        newTypeClassNotAllowed: ' NewType ',
        noOverloadAssignable: ' "{type}"',
        noneNotAllowed: ' None',
        orPatternMissingName: ': {name}',
        overloadIndex: ' {index} ',
        overloadNotAssignable: '"{name}" ',
        overloadSignature: '',
        overriddenMethod: '',
        overriddenSymbol: '',
        overrideInvariantMismatch: ' "{overrideType}"  "{baseType}" ',
        overrideIsInvariant: '',
        overrideNoOverloadMatches: '',
        overrideNotClassMethod: ' classmethod',
        overrideNotInstanceMethod: '',
        overrideNotStaticMethod: ' staticmethod',
        overrideOverloadNoMatch: '',
        overrideOverloadOrder: '',
        overrideParamKeywordNoDefault: ' "{name}" : ',
        overrideParamKeywordType: ' "{name}" :  "{baseType}" "{overrideType}"',
        overrideParamName: ' {index} :  "{baseName}" "{overrideName}"',
        overrideParamNameExtra: ' "{name}"',
        overrideParamNameMissing: ' "{name}"',
        overrideParamNamePositionOnly: ' {index} :  "{baseName}"  "position-only"',
        overrideParamNoDefault: ' {index} : ',
        overrideParamType: ' "{index}" :  "{baseType}" "{overrideType}"',
        overridePositionalParamCount: ';  {baseCount}  {overrideCount} ',
        overrideReturnType: ':  "{baseType}" "{overrideType}"',
        overrideType: ' "{type}"',
        paramAssignment: ' {index}:  "{sourceType}"  "{destType}" ',
        paramSpecMissingInOverride: ' ParamSpec ',
        paramType: ' "{paramType}"',
        privateImportFromPyTypedSource: ' "{module}" ',
        propertyAccessFromProtocolClass: '',
        propertyMethodIncompatible: 'Property  "{name}" ',
        propertyMethodMissing: ' property  "{name}"',
        propertyMissingDeleter: 'Property "{name}"  deleter',
        propertyMissingSetter: 'Property "{name}"  setter',
        protocolIncompatible: '"{sourceType}"  "{destType}" ',
        protocolMemberMissing: '"{name}" ',
        protocolRequiresRuntimeCheckable: 'Protocol  @runtime_checkable',
        protocolSourceIsNotConcrete: '"{sourceType}"  "{destType}"',
        protocolUnsafeOverlap: '"{name}" ',
        pyrightCommentIgnoreTip: ' "# pyright: ignore[<diagnostic rules>]" ',
        readOnlyAttribute: ' "{name}" ',
        seeClassDeclaration: '',
        seeDeclaration: '',
        seeFunctionDeclaration: '',
        seeMethodDeclaration: '',
        seeParameterDeclaration: '',
        seeTypeAliasDeclaration: '',
        seeVariableDeclaration: '',
        tupleAssignmentMismatch: ' "{type}"  tuple ',
        tupleEntryTypeMismatch: 'Tuple  {entry} ',
        tupleSizeIndeterminateSrc: 'Tuple ;  {expected}',
        tupleSizeIndeterminateSrcDest: 'Tuple ;  {expected} ',
        tupleSizeMismatch: 'Tuple ;  {expected} {received}',
        tupleSizeMismatchIndeterminateDest: 'Tuple ;  {expected}  {received}',
        typeAliasInstanceCheck: ' "type" ',
        typeAssignmentMismatch: ' "{sourceType}"  "{destType}"',
        typeBound: ' "{sourceType}"  "{name}"  "{destType}"',
        typeConstrainedTypeVar: ' "{type}"  "{name}"',
        typeIncompatible: '"{sourceType}"  "{destType}"',
        typeNotClass: '"{type}" ',
        typeNotStringLiteral: '"{type}" ',
        typeOfSymbol: '"{name}"  "{type}"',
        typeParamSpec: ' "{type}"  ParamSpec "{name}" ',
        typeUnsupported: ' "{type}" ',
        typeVarDefaultOutOfScope: ' "{name}" ',
        typeVarIsContravariant: ' "{name}"  "{sourceType}"  "{destType}" ',
        typeVarIsCovariant: ' "{name}"  "{sourceType}"  "{destType}" ',
        typeVarIsInvariant: ' "{name}"  "{sourceType}"  "{destType}" ',
        typeVarNotAllowed: ' TypeVar',
        typeVarTupleRequiresKnownLength: 'TypeVarTuple  tuple',
        typeVarUnnecessarySuggestion: ' {type}',
        typeVarUnsolvableRemedy: '',
        typeVarsMissing: ': {names}',
        typedDictBaseClass: ' "{type}"  TypedDict',
        typedDictClassNotAllowed: ' TypedDict ',
        typedDictClosedExtraNotAllowed: ' "{name}"',
        typedDictClosedExtraTypeMismatch: ' "{type}"  "{name}"',
        typedDictClosedFieldNotRequired: ' "{name}" NotRequired',
        typedDictExtraFieldNotAllowed: '"{name}"  "{type}"',
        typedDictExtraFieldTypeMismatch: '"{name}"  "{type}"  "extra_items" ',
        typedDictFieldMissing: '"{type}"  "{name}"',
        typedDictFieldNotReadOnly: '"{name}"  "{type}" ',
        typedDictFieldNotRequired: '"{type}"  "{name}"',
        typedDictFieldRequired: '"{type}"  "{name}"',
        typedDictFieldTypeMismatch: ' "{type}"  "{name}"',
        typedDictFieldUndefined: '"{name}"  "{type}" ',
        typedDictFinalMismatch: '"{sourceType}"  "{destType}" @final ',
        typedDictKeyAccess: ' ["{name}"]  TypedDict ',
        typedDictNotAllowed: ' TypedDict',
        unhashableType: ' "{type}" ',
        uninitializedAbstractVariable: ' "{name}"  "{classType}" ',
        unreachableExcept: '"{exceptionType}"  "{parentType}" ',
        useDictInstead: ' Dict[T1, T2] ',
        useListInstead: ' List[T]  list  Union[T1, T2]  union ',
        useTupleInstead: ' tuple[T1, ..., Tn]  tuple  Union[T1, T2]  union ',
        useTypeInstead: ' Type[T]',
        varianceMismatchForClass: ' "{typeVarName}"  "{className}" ',
        varianceMismatchForTypeAlias: ' "{typeVarName}"  "{typeAliasParam}" '
      },
      Service: {
        longOperation: '[](https://aka.ms/workspace-too-many-files)'
      }
    };
  }
}; //# sourceMappingURL=pyright.bundle.js.map