{"version":3,"names":["createRequire","resolve","polyfill","require","import","meta","url","import_","_unused","importMetaResolveP","process","execArgv","includes","then","m","default","Promise","_x","_x2","_resolve","apply","arguments","_asyncToGenerator","specifier","parent"],"sources":["../../../src/config/files/import-meta-resolve.ts"],"sourcesContent":["import { createRequire } from \"module\";\nimport { resolve as polyfill } from \"../../vendor/import-meta-resolve\";\n\nconst require = createRequire(import.meta.url);\n\nlet import_;\ntry {\n  // Node < 13.3 doesn't support import() syntax.\n  import_ = require(\"./import.cjs\");\n} catch {}\n\n// import.meta.resolve is only available in ESM, but this file is compiled to CJS.\n// We can extract it using dynamic import.\nconst importMetaResolveP: Promise<ImportMeta[\"resolve\"]> =\n  import_ &&\n  // Due to a Node.js/V8 bug (https://github.com/nodejs/node/issues/35889), we cannot\n  // use always dynamic import because it segfaults when running in a Node.js `vm` context,\n  // which is used by the default Jest environment and by webpack-cli.\n  //\n  // However, import.meta.resolve is experimental and only enabled when Node.js is run\n  // with the `--experimental-import-meta-resolve` flag: we can avoid calling import()\n  // when that flag is not enabled, so that the default behavior never segfaults.\n  //\n  // Hopefully, before Node.js unflags import.meta.resolve, either:\n  // - we will move to ESM, so that we have direct access to import.meta.resolve, or\n  // - the V8 bug will be fixed so that we can safely use dynamic import by default.\n  //\n  // I (@nicolo-ribaudo) am really annoyed by this bug, because there is no known\n  // work-around other than \"don't use dynamic import if you are running in a `vm` context\",\n  // but there is no reliable way to detect it (you cannot try/catch segfaults).\n  //\n  // This is the only place where we *need* to use dynamic import because we need to access\n  // an ES module. All the other places will first try using require() and *then*, if\n  // it throws because it's a module, will fallback to import().\n  process.execArgv.includes(\"--experimental-import-meta-resolve\")\n    ? import_(\"data:text/javascript,export default import.meta.resolve\").then(\n        (m: { default: ImportMeta[\"resolve\"] | undefined }) =>\n          m.default || polyfill,\n        () => polyfill,\n      )\n    : Promise.resolve(polyfill);\n\nexport default async function resolve(\n  specifier: Parameters<ImportMeta[\"resolve\"]>[0],\n  parent?: Parameters<ImportMeta[\"resolve\"]>[1],\n): ReturnType<ImportMeta[\"resolve\"]> {\n  return (await importMetaResolveP)(specifier, parent);\n}\n"],"mappings":";;AAAA,SAASA,aAAa,QAAQ,QAAQ;AACtC,SAASC,OAAO,IAAIC,QAAQ,QAAQ,qCAAkC;AAEtE,MAAMC,OAAO,GAAGH,aAAa,CAACI,MAAM,CAACC,IAAI,CAACC,GAAG,CAAC;AAE9C,IAAIC,OAAO;AACX,IAAI;EAEFA,OAAO,GAAGJ,OAAO,CAAC,cAAc,CAAC;AACnC,CAAC,CAAC,OAAAK,OAAA,EAAM,CAAC;AAIT,MAAMC,kBAAkD,GACtDF,OAAO,IAoBPG,OAAO,CAACC,QAAQ,CAACC,QAAQ,CAAC,oCAAoC,CAAC,GAC3DL,OAAO,CAAC,yDAAyD,CAAC,CAACM,IAAI,CACpEC,CAAiD,IAChDA,CAAC,CAACC,OAAO,IAAIb,QAAQ,EACvB,MAAMA,QAAQ,CACf,GACDc,OAAO,CAACf,OAAO,CAACC,QAAQ,CAAC;AAE/B,wBAA8BD,OAAOA,CAAAgB,EAAA,EAAAC,GAAA;EAAA,OAAAC,QAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAKpC,SAAAF,SAAA;EAAAA,QAAA,GAAAG,iBAAA,CALc,WACbC,SAA+C,EAC/CC,MAA6C,EACV;IACnC,OAAO,OAAOf,kBAAkB,EAAEc,SAAS,EAAEC,MAAM,CAAC;EACtD,CAAC;EAAA,OAAAL,QAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"}